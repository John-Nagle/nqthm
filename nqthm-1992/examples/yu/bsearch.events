#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

;         Proof of the Correctness of a Binary Search Program
;
(note-lib "mc20-2" t)
#|
The following C function BSEARCH determines if a given value x occurs
in the sorted array a.

/* from K&R */
/* bsearch:  find x in a[0] <= a[1] <= ... <= a[n-1] */
int bsearch (int x, int a[], int n)
{
  int low, high, mid;

  low = 0;
  high = n;
  while (low < high) {
    mid = (low + high) / 2;
    if (x < a[mid])
      high = mid;
    else if (x > a[mid])
      low = mid + 1;
    else return mid;
  }
  return -1;
}

Here is the MC68020 assembly code of the above BSEARCH program.  The code 
is generated by "gcc -O".

0x22f0 <bsearch>:       linkw a6,#0
0x22f4 <bsearch+4>:     moveml d2-d3,sp@-
0x22f8 <bsearch+8>:     movel a6@(8),d3
0x22fc <bsearch+12>:    moveal a6@(12),a0
0x2300 <bsearch+16>:    clrl d1
0x2302 <bsearch+18>:    movel a6@(16),d2
0x2306 <bsearch+22>:    cmpl d1,d2
0x2308 <bsearch+24>:    ble 0x232a <bsearch+58>
0x230a <bsearch+26>:    movel d1,d0
0x230c <bsearch+28>:    addl d2,d0
0x230e <bsearch+30>:    bpl 0x2312 <bsearch+34>
0x2310 <bsearch+32>:    addql #1,d0
0x2312 <bsearch+34>:    asrl #1,d0
0x2314 <bsearch+36>:    cmpl 0(a0)[d0.l*4],d3
0x2318 <bsearch+40>:    bge 0x231e <bsearch+46>
0x231a <bsearch+42>:    movel d0,d2
0x231c <bsearch+44>:    bra 0x2306 <bsearch+22>
0x231e <bsearch+46>:    cmpl 0(a0)[d0.l*4],d3
0x2322 <bsearch+50>:    ble 0x232c <bsearch+60>
0x2324 <bsearch+52>:    movel d0,d1
0x2326 <bsearch+54>:    addql #1,d1
0x2328 <bsearch+56>:    bra 0x2306 <bsearch+22>
0x232a <bsearch+58>:    movel #-1,d0
0x232c <bsearch+60>:    moveml a6@(-8),d2-d3
0x2332 <bsearch+66>:    unlk a6
0x2334 <bsearch+68>:    rts

The machine code of the above program is:

<bsearch>:       0x4e56  0x0000  0x48e7  0x3000  0x262e  0x0008  0x206e  0x000c
<bsearch+16>:    0x4281  0x242e  0x0010  0xb481  0x6f20  0x2001  0xd082  0x6a02
<bsearch+32>:    0x5280  0xe280  0xb6b0  0x0c00  0x6c04  0x2400  0x60e8  0xb6b0
<bsearch+48>:    0x0c00  0x6f08  0x2200  0x5281  0x60dc  0x70ff  0x4cee  0x000c
<bsearch+64>:    0xfff8  0x4e5e  0x4e75

In the Logic, this is:

'(78      86      0       0       72      231     48      0
  38      46      0       8       32      110     0       12
  66      129     36      46      0       16      180     129
  111     32      32      1       208     130     106     2
  82      128     226     128     182     176     12      0
  108     4       36      0       96      232     182     176
  12      0       111     8       34      0       82      129
  96      220     112     255     76      238     0       12
  255     248     78      94      78      117)

|#

; in the logic, the above program is defined by (bsearch-code).
(defn bsearch-code ()
  '(78      86      0       0       72      231     48      0
    38      46      0       8       32      110     0       12
    66      129     36      46      0       16      180     129
    111     32      32      1       208     130     106     2
    82      128     226     128     182     176     12      0
    108     4       36      0       96      232     182     176
    12      0       111     8       34      0       82      129
    96      220     112     255     76      238     0       12
    255     248     78      94      78      117))

(prove-lemma mean-bounds (rewrite)
     (implies (lessp i j)
	      (and (lessp (quotient (plus i j) 2) j)
		   (not (lessp (quotient (plus i j) 2) i)))))

(prove-lemma ilessp-lessp (rewrite)
     (implies (and (numberp x)
		   (numberp y))
	      (equal (ilessp x y) (lessp x y))))

(disable ilessp)

; bsearch1 is a function in the logic to simulate the loop of the
; above code.
(defn bsearch1 (x lst i j)
  (let ((k (quotient (plus i j) 2)))
    (if (lessp i j)
	(if (ilessp x (get-nth k lst))
	    (bsearch1 x lst i k)
	  (if (ilessp (get-nth k lst) x)
	      (bsearch1 x lst (add1 k) j)
	    k))
      -1))
  ((lessp (difference j i))))

; bsearch is a function in the logic to simulate the above code.
(defn bsearch (x n lst)
  (bsearch1 x lst 0 n))

; the computation time of the loop.
(defn bsearch1-t (x lst i j)
  (let ((k (quotient (plus i j) 2)))
    (if (lessp i j)
	(if (ilessp x (get-nth k lst))
	    (splus 10 (bsearch1-t x lst i k))
	  (if (ilessp (get-nth k lst) x)
	      (splus 13 (bsearch1-t x lst (add1 k) j))
	    13))
      6))
  ((lessp (difference j i))))

; the computation time of the code.
(defn bsearch-t (x n lst)
  (splus 6 (bsearch1-t x lst 0 n)))

; an induction hint.
(defn bsearch-induct (s x lst i j)
  (let ((k (quotient (plus i j) 2)))
    (if (lessp i j)
	(if (ilessp x (get-nth k lst))
	    (bsearch-induct (stepn s 10) x lst i k)
	  (if (ilessp (get-nth k lst) x)
	      (bsearch-induct (stepn s 13) x lst (add1 k) j)
	    t))
      t))
  ((lessp (difference j i))))

; the preconditions of the initial state.
(defn bsearch-statep (s x a n lst)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 70)
       (mcode-addrp (mc-pc s) (mc-mem s) (bsearch-code))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 28)
       (ram-addrp a (mc-mem s) (times 4 n))
       (mem-ilst 4 a (mc-mem s) n lst)
       (disjoint (sub 32 12 (read-sp s)) 28 a (times 4 n))
       (equal a (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal n (iread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (equal x (iread-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (int-rangep (times 2 n) 32)
       (numberp n)))

; the conditions of an intermediate state.
(defn bsearch-s0p (s x a n lst i j)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 22 (mc-pc s)) (mc-mem s) 70)
       (mcode-addrp (sub 32 22 (mc-pc s)) (mc-mem s) (bsearch-code))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 28)
       (ram-addrp a (mc-mem s) (times 4 n))
       (mem-ilst 4 a (mc-mem s) n lst)
       (disjoint (sub 32 8 (read-an 32 6 s)) 28 a (times 4 n))
       (equal a (read-an 32 0 s))
       (equal i (nat-to-int (read-dn 32 1 s) 32))
       (equal j (nat-to-int (read-dn 32 2 s) 32))
       (equal x (nat-to-int (read-dn 32 3 s) 32))
       (int-rangep (times 2 j) 32)
       (numberp i)
       (numberp j)
       (numberp n)
       (leq i n)
       (leq j n)))

; the initial segment.  From the initial state to s0.
(prove-lemma bsearch-s-s0p ()
     (implies (bsearch-statep s x a n lst)
	      (bsearch-s0p (stepn s 6) x a n lst 0 n)))

(prove-lemma bsearch-s-s0 (rewrite)
     (implies (bsearch-statep s x a n lst)
	      (and (equal (linked-rts-addr (stepn s 6))
			  (rts-addr s))
		   (equal (linked-a6 (stepn s 6))
			  (read-an 32 6 s))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
			  (sub 32 4 (read-sp s)))
		   (equal (movem-saved (stepn s 6) 4 8 2)
			  (readm-rn 32 '(2 3) (mc-rfile s))))))

(prove-lemma bsearch-s-s0-rfile (rewrite)
     (implies (and (bsearch-statep s x a n lst)
		   (d4-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s)))))
	      
(prove-lemma bsearch-s-s0-mem (rewrite)
     (implies (and (bsearch-statep s x a n lst)
		   (disjoint x k (sub 32 12 (read-sp s)) 28))
	      (equal (read-mem x (mc-mem (stepn s 6)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s0 (induction case), from s0 to exit (base case).
; base case: s0 --> sn.
(prove-lemma bsearch-s0-sn-base1 (rewrite)
     (implies (and (bsearch-s0p s x a n lst i j)
		   (not (lessp i j)))
	      (and (equal (mc-status (stepn s 6)) 'running)
		   (equal (mc-pc (stepn s 6)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 6)) -1)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 6)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 6)) l)
			  (read-mem x (mc-mem s) l)))))

(prove-lemma bsearch-s0-sn-rfile-base1 (rewrite)
     (implies (and (bsearch-s0p s x a n lst i j)
		   (not (lessp i j))
		   (d2-7a2-5p rn)
		   (leq oplen 32))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (if (d4-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

(enable iplus)
(enable iquotient)
(disable quotient)
(disable remainder)
(disable times)

(prove-lemma bsearch-crock(rewrite)
     (implies (and (int-rangep (times 2 j) n)
		   (lessp i j))
	      (int-rangep (plus i j) n)))

(prove-lemma bsearch-s0-sn-base2 (rewrite)
     (let ((k (quotient (plus i j) 2)))
       (implies (and (bsearch-s0p s x a n lst i j)
		     (lessp i j)
		     (not (ilessp x (get-nth k lst)))
		     (not (ilessp (get-nth k lst) x)))
		(and (equal (mc-status (stepn s 13)) 'running)
		     (equal (mc-pc (stepn s 13)) (linked-rts-addr s))
		     (equal (iread-dn 32 0 (stepn s 13))
			    (quotient (plus i j) 2))
		     (equal (read-rn 32 14 (mc-rfile (stepn s 13)))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile (stepn s 13)))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem (stepn s 13)) l)
			    (read-mem x (mc-mem s) l))))))		     

(prove-lemma bsearch1-s0-sn-rfile-base2 (rewrite)
    (let ((k (quotient (plus i j) 2)))
      (implies (and (bsearch-s0p s x a n lst i j)
		    (lessp i j)
		    (not (ilessp x (get-nth k lst)))
		    (not (ilessp (get-nth k lst) x))
		    (d2-7a2-5p rn)
		    (leq oplen 32))
	       (equal (read-rn oplen rn (mc-rfile (stepn s 13)))
		      (if (d4-7a2-5p rn)
			  (read-rn oplen rn (mc-rfile s))
			(get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2)))))))

; from s0 to s0 (induction case).
(prove-lemma bsearch-s0-s0-1 (rewrite)
     (let ((k (quotient (plus i j) 2)))
       (implies (and (bsearch-s0p s x a n lst i j)
		     (lessp i j)
		     (ilessp x (get-nth k lst)))
		(and (bsearch-s0p (stepn s 10) x a n lst i k)
		     (equal (read-rn oplen 14 (mc-rfile (stepn s 10)))
			    (read-rn oplen 14 (mc-rfile s)))
		     (equal (linked-a6 (stepn s 10)) (linked-a6 s))
		     (equal (linked-rts-addr (stepn s 10)) 
			    (linked-rts-addr s))
		     (equal (movem-saved (stepn s 10) 4 8 2)
			    (movem-saved s 4 8 2))
		     (equal (read-mem x (mc-mem (stepn s 10)) l)
			    (read-mem x (mc-mem s) l))))))

(prove-lemma bsearch-s0-s0-rfile1 (rewrite)
     (let ((k (quotient (plus i j) 2)))
       (implies (and (bsearch-s0p s x a n lst i j)
		     (lessp i j)
		     (ilessp x (get-nth k lst))
		     (d4-7a2-5p rn))
		(equal (read-rn oplen rn (mc-rfile (stepn s 10)))
		       (read-rn oplen rn (mc-rfile s))))))

(prove-lemma bsearch-s0-s0-2 (rewrite)
     (let ((k (quotient (plus i j) 2)))
       (implies (and (bsearch-s0p s x a n lst i j)
		     (lessp i j)
		     (not (ilessp x (get-nth k lst)))
		     (ilessp (get-nth k lst) x))
		(and (bsearch-s0p (stepn s 13) x a n lst (add1 k) j)
		     (equal (read-rn oplen 14 (mc-rfile (stepn s 13)))
			    (read-rn oplen 14 (mc-rfile s)))
		     (equal (linked-a6 (stepn s 13)) (linked-a6 s))
		     (equal (linked-rts-addr (stepn s 13)) (linked-rts-addr s))
		     (equal (movem-saved (stepn s 13) 4 8 2)
			    (movem-saved s 4 8 2))
		     (equal (read-mem x (mc-mem (stepn s 13)) l)
			    (read-mem x (mc-mem s) l))))))		     

(prove-lemma bsearch1-s0-s0-rfile2 (rewrite)
     (let ((k (quotient (plus i j) 2)))
       (implies (and (bsearch-s0p s x a n lst i j)
		     (lessp i j)
		     (not (ilessp x (get-nth k lst)))
		     (ilessp (get-nth k lst) x)
		     (d4-7a2-5p rn))
		(equal (read-rn oplen rn (mc-rfile (stepn s 13)))
		       (read-rn oplen rn (mc-rfile s))))))

(disable bsearch-statep)
(disable bsearch-s0p)

; put together. s0 --> sn
(prove-lemma bsearch-s0-sn (rewrite)
     (let ((sn (stepn s (bsearch1-t x lst i j))))
       (implies (bsearch-s0p s x a n lst i j)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (iread-dn 32 0 sn) (bsearch1 x lst i j))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (bsearch-induct s x lst i j))
      (disable linked-rts-addr linked-a6)))

(prove-lemma bsearch-s0-sn-rfile (rewrite)
     (implies
      (and (bsearch-s0p s x a n lst i j)
	   (d2-7a2-5p rn)
	   (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s (bsearch1-t x lst i j))))
	     (if (d4-7a2-5p rn)
		 (read-rn oplen rn (mc-rfile s))
	       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2)))))
     ((induct (bsearch-induct s x lst i j))))

; the correctness statement of this BSEARCH program.
; after an execution of this program,  the machine state satisfies:
;  0. normal exit.
;  1. the program counter is returned to the next instruction of the caller.
;  2. the result -- (bsearch x n lst), is stored in the register D0.
;  3. a6, used by LINK, is restored to its original value.
;  4. a7, the stack pointer, is updated correctly to pop off one frame.
;  5. the registers d2-d7 and a2-a5 maintain their original values.
;  6. the memory is only locally changed wrt this program.
(prove-lemma bsearch-correctness (rewrite)
     (let ((sn (stepn s (bsearch-t x n lst))))
       (implies (bsearch-statep s x a n lst)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 12 (read-sp s)) 28)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (iread-dn 32 0 sn) (bsearch x n lst)))))
     ((use (bsearch-s-s0p))
      (disable rts-addr linked-rts-addr linked-a6)))

(disable bsearch-t)

; in the logic, bsearch has these properties:
;      1. if it returns a nonnegative integer i, then lst[i] = x.
;      2. if it returns -1, then x is not in lst.
(defn member1 (x lst i j)
  (if (lessp i j)
      (if (equal x (get-nth i lst))
	  t
	(member1 x lst (add1 i) j))
    f)
  ((lessp (difference j i))))

(defn orderedp (lst)
  (if (nlistp lst)
      t
    (if (nlistp (cdr lst))
	t
      (and (ileq (car lst) (cadr lst))
	   (orderedp (cdr lst))))))

(prove-lemma leq-trans (rewrite)
     (implies (and (not (ilessp x y))
		   (not (ilessp y z)))
	      (not (ilessp x z)))
     ((enable ilessp)))

(prove-lemma int-equal (rewrite)
     (implies (and (integerp x)
		   (integerp y)
		   (not (ilessp x y))
		   (not (ilessp y x)))
	      (equal (equal x y) t))
     ((enable ilessp integerp)))

(prove-lemma orderedp-ordered (rewrite)
     (implies (and (orderedp lst)
		   (leq i j)
		   (lessp j (len lst)))
	      (equal (ilessp (get-nth j lst) (get-nth i lst)) f))
     ((enable get-nth)))

(prove-lemma bsearch1-found (rewrite)
     (implies (and (not (equal (bsearch1 x lst i j) -1))
		   (lst-integerp lst)
		   (integerp x))
	      (equal (get-nth (bsearch1 x lst i j) lst)
		     x))
     ((disable quotient remainder)))

(prove-lemma bsearch1-not-found-1 (rewrite)
     (implies (and (orderedp lst)
		   (ilessp (get-nth k lst) x)
		   (leq i k)
		   (lessp k j)
		   (leq j (len lst)))
	      (equal (member1 x lst i j) 
		     (member1 x lst (add1 k) j))))

(prove-lemma bsearch1-not-found-2-lemma (rewrite)
     (implies (and (orderedp lst)
		   (ilessp x (get-nth k lst))
		   (leq k i)
		   (lessp j (len lst)))
	      (not (member1 x lst i j))))

(prove-lemma bsearch1-not-found-2 (rewrite)
     (implies (and (orderedp lst)
		   (ilessp x (get-nth k lst))
		   (lessp k j)
		   (leq j (len lst)))
	      (equal (member1 x lst i j) 
		     (member1 x lst i k))))

(disable bsearch1-not-found-2-lemma)

(prove-lemma bsearch1-not-found (rewrite)
     (implies (and (equal (bsearch1 x lst i j) -1)
		   (orderedp lst)
		   (lst-integerp lst)
		   (integerp x)
		   (leq j (len lst)))
	      (not (member1 x lst i j)))
     ((induct (bsearch1 x lst i j))))

(defn member2 (x lst i j)
  (if (lessp i j)
      (if (equal x (get-nth i lst))
	  t
	(member2 x (cdr lst) i (sub1 j)))
    f)
  ((lessp (difference j i))))

(prove-lemma member2-member ()
     (equal (member2 x lst 0 (len lst))
	    (member x lst))
     ((enable get-nth)))

(prove-lemma member2-lemma (rewrite)
     (implies (not (equal x (get-nth i lst)))
	      (equal (member2 x lst (add1 i) j)
		     (member2 x lst i j)))
     ((enable get-nth)))

(prove-lemma member1-member2 ()
     (equal (member1 x lst i j)
	    (member2 x lst i j)))

(prove-lemma bsearch-found (rewrite)
     (implies (and (not (equal (bsearch x n lst) -1))
		   (lst-integerp lst)
		   (integerp x))
	      (equal (get-nth (bsearch x n lst) lst)
		     x)))

(prove-lemma bsearch-not-found (rewrite)
     (implies (and (equal (bsearch x (len lst) lst) -1)
		   (orderedp lst)
		   (lst-integerp lst)
		   (integerp x))
	      (not (member x lst)))
     ((use (member1-member2 (i 0) (j (len lst)))
	   (member2-member))))

; an upper bound.
(prove-lemma bsearch1-t-0 (rewrite)
     (equal (bsearch1-t x lst i i) 6)
     ((expand (bsearch1-t x lst i i))))
	    
(prove-lemma bsearch1-t-crock (rewrite)
     (implies (and (lessp i j)
		   (not
		    (lessp
		     (plus 26
			   (times 13
				  (log 2
				       (difference (sub1 j)
						   (quotient (plus i j) 2)))))
		     (bsearch1-t x lst (add1 (quotient (plus i j) 2)) j))))
	      (equal 
	       (lessp 
		(plus 26 (times 13 (log 2 (difference j i))))
		(plus 13 (bsearch1-t x lst (add1 (quotient (plus i j) 2)) j)))
	       f))
     ((use (log-leq (b 2)
                    (x (difference (sub1 j) (quotient (plus i j) 2)))
                    (y (quotient (difference j i) 2)))
           (mean-difference-2))))

(prove-lemma bsearch1-t-ubound (rewrite)
     (not (lessp (plus 26 (times 13 (log 2 (difference j i))))
		 (bsearch1-t x lst i j)))
     ((enable splus)))

(disable bsearch1-t-crock)

(prove-lemma bsearch-t-ubound-la ()
     (leq (bsearch-t x n lst)
	  (plus 32 (times 13 (log 2 n))))
     ((enable splus bsearch-t)))

(prove-lemma bsearch-t-ubound ()
     (implies (lessp n (exp 2 31))
	      (leq (bsearch-t x n lst) 435))
     ((use (ta-lemma-1 (x 32) (y 13) (a n) (a1 (exp 2 31)))
	   (bsearch-t-ubound-la))))
