#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRCAT Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strcat function in the Berkeley string library.

/* concatenate char append[] to the end of s[] */
char *
strcat(s, append)
	register char *s, *append;
{
	char *save = s;

	for (; *s; ++s);
	while (*s++ = *append++);
	return(save);
}

The MC68020 assembly code of the C function strcat on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x24d8 <strcat>:        linkw fp,#0
0x24dc <strcat+4>:      moveal fp@(8),a0
0x24e0 <strcat+8>:      moveal fp@(12),a1
0x24e4 <strcat+12>:     movel a0,d1
0x24e6 <strcat+14>:     tstb a0@
0x24e8 <strcat+16>:     beq 0x24f0 <strcat+24>
0x24ea <strcat+18>:     addqw #1,a0
0x24ec <strcat+20>:     tstb a0@
0x24ee <strcat+22>:     bne 0x24ea <strcat+18>
0x24f0 <strcat+24>:     moveb a1@+,d0
0x24f2 <strcat+26>:     moveb d0,a0@+
0x24f4 <strcat+28>:     bne 0x24f0 <strcat+24>
0x24f6 <strcat+30>:     movel d1,d0
0x24f8 <strcat+32>:     unlk fp
0x24fa <strcat+34>:     rts

The machine code of the above program is:

<strcat>:      0x4e56  0x0000  0x206e  0x0008  0x226e  0x000c  0x2208  0x4a10
<strcat+16>:   0x6706  0x5248  0x4a10  0x66fa  0x1019  0x10c0  0x66fa  0x2001
<strcat+32>:   0x4e5e  0x4e75

'(78      86      0       0       32      110     0       8
  34      110     0       12      34      8       74      16
  103     6       82      72      74      16      102     250
  16      25      16      192     102     250     32      1
  78      94      78      117)

Bird-eye view of the control flow of the program:

                
   s -------> s0* -------> s1* --------> exit
    \_____________________/

|#
; in the logic, the above program is defined by (strcat-code).
(defn strcat-code ()
  '(78      86      0       0       32      110     0       8
    34      110     0       12      34      8       74      16
    103     6       82      72      74      16      102     250
    16      25      16      192     102     250     32      1
    78      94      78      117))

; the computation time of the program.
(defn strcat-t0 (i n1 lst1)
  (if (lessp i n1)
      (if (equal (get-nth i lst1) 0)
          2
	(splus 3 (strcat-t0 (add1 i) n1 lst1)))
    0)
  ((lessp (difference n1 i))))

(defn strcat-t1 (n1 lst1)
  (splus 7 (strcat-t0 1 n1 lst1)))

(defn strcat-t2 (j n2 lst2)
  (if (lessp j n2)
      (if (equal (get-nth j lst2) 0)
	  6
	(splus 3 (strcat-t2 (add1 j) n2 lst2)))
    0)
  ((lessp (difference n2 j))))

(defn strcat-t (n1 lst1 n2 lst2)
  (if (equal (get-nth 0 lst1) 0)
      (splus 6 (strcat-t2 0 n2 lst2))
    (splus (strcat-t1 n1 lst1) (strcat-t2 0 n2 lst2))))

; two induction hints for the two loops in the program.
(defn strcat-induct0 (s i* i lst1 n1)
  (if (lessp i n1)
      (if (equal (get-nth i lst1) 0)
	  t
	(strcat-induct0 (stepn s 3) (add 32 i* 1) (add1 i) lst1 n1))
    t)
  ((lessp (difference n1 i))))

(defn strcat-induct1 (s i* i lst1 j* j n2 lst2)
  (if (lessp j n2)
      (if (equal (get-nth j lst2) 0)
	  t
	  (strcat-induct1 (stepn s 3) (add 32 i* 1) (add1 i) 
			  (put-nth (get-nth j lst2) i lst1) (add 32 j* 1)
			  (add1 j) n2 lst2))
    t)
  ((lessp (difference n2 j))))

; the preconditions of the initial state.
(defn strcat-statep (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 36)
       (mcode-addrp (mc-pc s) (mc-mem s) (strcat-code))
       (ram-addrp (sub 32 4 (read-sp s)) (mc-mem s) 16)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)       
       (disjoint (sub 32 4 (read-sp s)) 16 str1 n1)
       (disjoint (sub 32 4 (read-sp s)) 16 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (lessp (plus (slen 0 n1 lst1) (slen 0 n2 lst2)) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)))

; an intermediate state.  
(defn strcat-s0p (s i* i str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 20 (mc-pc s)) (mc-mem s) 36)
       (mcode-addrp (sub 32 20 (mc-pc s)) (mc-mem s) (strcat-code))
       (ram-addrp (read-an 32 6 s) (mc-mem s) 16)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)       
       (disjoint (read-an 32 6 s) 16 str1 n1)
       (disjoint (read-an 32 6 s) 16 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal* (read-an 32 0 s) (add 32 str1 i*))
       (equal str1 (read-dn 32 1 s))
       (equal str2 (read-an 32 1 s))
       (lessp (plus (slen i n1 lst1) (slen 0 n2 lst2)) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)))

; an intermediate state.
(defn strcat-s1p (s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 24 (mc-pc s)) (mc-mem s) 36)
       (mcode-addrp (sub 32 24 (mc-pc s)) (mc-mem s) (strcat-code))
       (ram-addrp (read-an 32 6 s) (mc-mem s) 16)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)       
       (disjoint (read-an 32 6 s) 16 str1 n1)
       (disjoint (read-an 32 6 s) 16 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal* (read-an 32 0 s) (add 32 str1 i*))
       (equal* (read-an 32 1 s) (add 32 str2 j*))
       (equal str1 (read-dn 32 1 s))
       (lessp (plus i_ (slen j n2 lst2)) n1)
       (lessp (slen j n2 lst2) n2)
       (leq i (plus i_ j))
       (numberp i_)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp j*)
       (nat-rangep j* 32)
       (equal j (nat-to-uint j*))
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)))

; from the initial state to s1:  s --> s1, if lst1[0] == 0.
(prove-lemma strcat-s-s1-1 ()
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst1) 0))
	      (and (strcat-s1p (stepn s 6) 0 0 str1 n1 lst1 0 0 str2 n2 lst2 0)
		   (equal (linked-rts-addr (stepn s 6)) (rts-addr s))
                   (equal (linked-a6 (stepn s 6)) (read-an 32 6 s))
                   (equal* (read-rn 32 14 (mc-rfile (stepn s 6)))
                          (sub 32 4 (read-sp s))))))

(prove-lemma strcat-s-s1-1-rfile (rewrite)
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst1) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcat-s-s1-1-mem (rewrite)
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst1) 0)
		   (disjoint x k (sub 32 4 (read-sp s)) 16))
	      (equal (read-mem x (mc-mem (stepn s 6)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state to s0:  s --> s0, if lst1[0] =\= 0.
(prove-lemma strcat-s-s0 ()
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst1) 0)))
	      (and (strcat-s0p (stepn s 7) 1 1 str1 n1 lst1 str2 n2 lst2)
                   (equal (linked-rts-addr (stepn s 7)) (rts-addr s))
                   (equal (linked-a6 (stepn s 7)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (sub 32 4 (read-sp s))))))

(prove-lemma strcat-s-s0-rfile (rewrite)
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst1) 0))
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcat-s-s0-mem (rewrite)
     (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst1) 0))
		   (disjoint x k (sub 32 4 (read-sp s)) 16))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s1:  s0 --> s1.
; base case: s0 --> s1, when lst1[i] == 0.
(prove-lemma strcat-s0-s1-base (rewrite)
     (implies (and (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth i lst1) 0))
	      (and (strcat-s1p (stepn s 2) i* i str1 n1 lst1 0 0 str2 n2 lst2
			       i)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 2)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 2)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 2))
                          (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 2)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strcat-s0-s1-rfile-base (rewrite)
     (implies (and (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth i lst1) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 2)))
		     (read-rn oplen rn (mc-rfile s)))))

; induction case: s0 --> s0, when lst[i] =\= 0.
(prove-lemma strcat-s0-s0 (rewrite)
     (implies (and (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth i lst1) 0)))
	      (and (strcat-s0p (stepn s 3) (add 32 i* 1) (add1 i)
			       str1 n1 lst1 str2 n2 lst2)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 3))
                          (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 3)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strcat-s0-s0-rfile (rewrite)
     (implies (and (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth i lst1) 0))
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

; put together:  s0 --> s1.
(prove-lemma strcat-s0p-info (rewrite)
     (implies (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
	      (equal (lessp i n1) t)))

(prove-lemma strcat-s0-s1 (rewrite)
     (let ((s1 (stepn s (strcat-t0 i n1 lst1))))
       (implies (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
		(and (strcat-s1p s1 (strlen* i* i n1 lst1) (strlen i n1 lst1)
				 str1 n1 lst1 0 0 str2 n2 lst2 
				 (strlen i n1 lst1))
		     (equal (read-rn 32 14 (mc-rfile s1))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s1) (linked-a6 s))
		     (equal (linked-rts-addr s1) (linked-rts-addr s))
		     (equal (read-mem x (mc-mem s1) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strcat-induct0 s i* i lst1 n1))
      (disable strcat-s0p strcat-s1p)))

(disable strcat-s0p-info)

(prove-lemma strcat-s0-s1-rfile (rewrite)
     (implies 
      (and (strcat-s0p s i* i str1 n1 lst1 str2 n2 lst2)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strcat-t0 i n1 lst1))))
	     (read-rn oplen rn (mc-rfile s))))
     ((induct (strcat-induct0 s i* i lst1 n1))
      (disable strcat-s0p)))

; from s1 to exit:  s1 --> sn.
; base case:  s1 --> sn, when lst2[j] == 0.
(prove-lemma strcat-s1-sn-base (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
		   (equal (get-nth j lst2) 0))
	      (and (equal (mc-status (stepn s 6)) 'running)
		   (equal (mc-pc (stepn s 6)) (linked-rts-addr s))
		   (equal (read-rn 32 0 (mc-rfile (stepn s 6))) str1)
		   (mem-lst 1 str1 (mc-mem (stepn s 6)) n1 (put-nth 0 i lst1))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6))) (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 6)))
			  (add 32 (read-an 32 6 s) 8)))))

(prove-lemma strcat-s1-sn-rfile-base (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
                   (equal (get-nth j lst2) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcat-s1-sn-mem-base (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
                   (equal (get-nth j lst2) 0)
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s 6)) k)
		     (read-mem x (mc-mem s) k))))

; induction case: s1 --> s1.
(prove-lemma strcat-s1-s1 (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
		   (not (equal (get-nth j lst2) 0)))
	      (and (strcat-s1p (stepn s 3) (add 32 i* 1) (add1 i) str1 n1
			       (put-nth (get-nth j lst2) i lst1) (add 32 j* 1)
			       (add1 j) str2 n2 lst2 i_)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 3))
                          (linked-rts-addr s)))))

(prove-lemma strcat-s1-s1-rfile (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
		   (not (equal (get-nth j lst2) 0))
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcat-s1-s1-mem (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
                   (not (equal (get-nth j lst2) 0))
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s 3)) k)
		     (read-mem x (mc-mem s) k))))

; put together. s1 --> sn.
(prove-lemma strcat-s1-info (rewrite)
     (implies (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
	      (equal (lessp j n2) t)))

(prove-lemma strcat-s1-sn (rewrite)
     (let ((sn (stepn s (strcat-t2 j n2 lst2))))
       (implies (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n1 (strcpy1 i lst1 j n2 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strcat-induct1 s i* i lst1 j* j n2 lst2))
      (disable strcat-s1p)))

(prove-lemma strcat-s1-sn-rfile (rewrite)
     (implies
      (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strcat-t2 j n2 lst2))))
             (read-rn oplen rn (mc-rfile s))))
     ((induct (strcat-induct1  s i* i lst1 j* j n2 lst2))
      (disable strcat-s1p)))      
	     
(prove-lemma strcat-s1-sn-mem (rewrite)
     (implies (and (strcat-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2 i_)
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s (strcat-t2 j n2 lst2))) k)
                     (read-mem x (mc-mem s) k)))
     ((induct (strcat-induct1 s i* i lst1 j* j n2 lst2))
      (disable strcat-s1p)))

; put together: s --> s1, if lst[0] =\= 0.
(prove-lemma strcat-s-s1-2 ()
     (let ((s1 (stepn s (strcat-t1 n1 lst1))))
       (implies (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		     (not (equal (get-nth 0 lst1) 0)))
		(and (strcat-s1p s1 (strlen* 1 1 n1 lst1) (strlen 1 n1 lst1)
				 str1 n1 lst1 0 0 str2 n2 lst2 
				 (strlen 1 n1 lst1))
		     (equal (read-rn 32 14 (mc-rfile s1))
			    (sub 32 4 (read-sp s)))
		     (equal (linked-a6 s1) (read-an 32 6 s))
		     (equal (linked-rts-addr s1) (rts-addr s)))))
     ((use (strcat-s-s0))
      (disable strcat-statep strcat-s0p strcat-t0)))

(prove-lemma strcat-s-s1-2-rfile (rewrite)
     (implies 
      (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
	   (not (equal (get-nth 0 lst1) 0))
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strcat-t1 n1 lst1))))
             (read-rn oplen rn (mc-rfile s))))
     ((use (strcat-s-s0))
      (disable strcat-statep strcat-s0p strcat-t0)))

(prove-lemma strcat-s-s1-2-mem (rewrite)
     (implies 
      (and (strcat-statep s str1 n1 lst1 str2 n2 lst2)
	   (not (equal (get-nth 0 lst1) 0))
	   (disjoint x k (sub 32 4 (read-sp s)) 16))
      (equal (read-mem x (mc-mem (stepn s (strcat-t1 n1 lst1))) k)
	     (read-mem x (mc-mem s) k)))
     ((use (strcat-s-s0))
      (disable strcat-statep strcat-s0p strcat-t0)))

; the correctness of the strcat program.
(prove-lemma strcat-correctness (rewrite)
     (let ((sn (stepn s (strcat-t n1 lst1 n2 lst2))))
       (implies (strcat-statep s str1 n1 lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-an 32 6 sn) (read-an 32 6 s))
		     (equal (read-an 32 7 sn)
			    (add 32 (read-an 32 7 s) 4))
		     (implies (d2-7a2-5p rn)
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (and (disjoint x k str1 n1)
				   (disjoint x k (sub 32 4 (read-sp s)) 16))
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n1 
			      (strcat n1 lst1 n2 lst2)))))
     ((use (strcat-s-s1-1) (strcat-s-s1-2))
      (disable strcat-statep strcat-s1p strcat-t1 strcat-t2 read-dn
	       linked-rts-addr linked-a6)))

(disable strcat-t)

; some properties of strcat.
; see file cstring.events.
