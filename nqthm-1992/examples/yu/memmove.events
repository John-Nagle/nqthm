#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the MEMMOVE Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of memmove function in the Berkeley string library.

typedef int word;               /* "word" used for optimal copy speed */

#define wsize   sizeof(word)
#define wmask   (wsize - 1)

/*
 * Copy a block of memory, handling overlap.
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
void *
memmove(dst0, src0, length)
        void *dst0;
        const void *src0;
        register size_t length;
{
        register char *dst = dst0;
        register const char *src = src0;
        register size_t t;

        if (length == 0 || dst == src)          /* nothing to do */
                goto done;

        /*
         * Macros: loop-t-times; and loop-t-times, t>0
         */
#define TLOOP(s) if (t) TLOOP1(s)
#define TLOOP1(s) do { s; } while (--t)

        if ((unsigned long)dst < (unsigned long)src) {
                /*
                 * Copy forward.
                 */
                t = (int)src;   /* only need low bits */
                if ((t | (int)dst) & wmask) {
                        /*
                         * Try to align operands.  This cannot be done
                         * unless the low bits match.
                         */
                        if ((t ^ (int)dst) & wmask || length < wsize)
                                t = length;
                        else
                                t = wsize - (t & wmask);
                        length -= t;
                        TLOOP1(*dst++ = *src++);
                }
                /*
                 * Copy whole words, then mop up any trailing bytes.
                 */
                t = length / wsize;
                TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
                t = length & wmask;
                TLOOP(*dst++ = *src++);
        } else {
                /*
                 * Copy backwards.  Otherwise essentially the same.
                 * Alignment works as before, except that it takes
                 * (t&wmask) bytes to align, not wsize-(t&wmask).
                 */
                src += length;
                dst += length;
                t = (int)src;
                if ((t | (int)dst) & wmask) {
                        if ((t ^ (int)dst) & wmask || length <= wsize)
                                t = length;
                        else
                                t &= wmask;
                        length -= t;
                        TLOOP1(*--dst = *--src);
                }
                t = length / wsize;
                TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
                t = length & wmask;
                TLOOP(*--dst = *--src);
        }
done:
        return (dst0);
}

The MC68020 assembly code of the C function memmove on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2550 <memmove>:       linkw fp,#0
0x2554 <memmove+4>:     moveml d2-d4,sp@-
0x2558 <memmove+8>:     movel fp@(8),d3
0x255c <memmove+12>:    movel fp@(16),d2
0x2560 <memmove+16>:    moveal d3,a1
0x2562 <memmove+18>:    moveal fp@(12),a0
0x2566 <memmove+22>:    beq 0x2604 <memmove+180>
0x256a <memmove+26>:    cmpal d3,a0
0x256c <memmove+28>:    beq 0x2604 <memmove+180>
0x2570 <memmove+32>:    bls 0x25bc <memmove+108>
0x2572 <memmove+34>:    movel a0,d1
0x2574 <memmove+36>:    movel d1,d0
0x2576 <memmove+38>:    orl d3,d0
0x2578 <memmove+40>:    movel #3,d4
0x257a <memmove+42>:    andl d4,d0
0x257c <memmove+44>:    beq 0x25a2 <memmove+82>
0x257e <memmove+46>:    movel d1,d0
0x2580 <memmove+48>:    eorl d3,d0
0x2582 <memmove+50>:    movel #3,d4
0x2584 <memmove+52>:    andl d4,d0
0x2586 <memmove+54>:    bne 0x258e <memmove+62>
0x2588 <memmove+56>:    movel #3,d4
0x258a <memmove+58>:    cmpl d2,d4
0x258c <memmove+60>:    bcs 0x2592 <memmove+66>
0x258e <memmove+62>:    movel d2,d1
0x2590 <memmove+64>:    bra 0x259a <memmove+74>
0x2592 <memmove+66>:    movel #3,d0
0x2594 <memmove+68>:    andl d1,d0
0x2596 <memmove+70>:    movel #4,d1
0x2598 <memmove+72>:    subl d0,d1
0x259a <memmove+74>:    subl d1,d2
0x259c <memmove+76>:    moveb a0@+,a1@+
0x259e <memmove+78>:    subl #1,d1
0x25a0 <memmove+80>:    bne 0x259c <memmove+76>
0x25a2 <memmove+82>:    movel d2,d1
0x25a4 <memmove+84>:    lsrl #2,d1
0x25a6 <memmove+86>:    beq 0x25ae <memmove+94>
0x25a8 <memmove+88>:    movel a0@+,a1@+
0x25aa <memmove+90>:    subl #1,d1
0x25ac <memmove+92>:    bne 0x25a8 <memmove+88>
0x25ae <memmove+94>:    movel #3,d1
0x25b0 <memmove+96>:    andl d2,d1
0x25b2 <memmove+98>:    beq 0x2604 <memmove+180>
0x25b4 <memmove+100>:   moveb a0@+,a1@+
0x25b6 <memmove+102>:   subl #1,d1
0x25b8 <memmove+104>:   bne 0x25b4 <memmove+100>
0x25ba <memmove+106>:   bra 0x2604 <memmove+180>
0x25bc <memmove+108>:   addal d2,a0
0x25be <memmove+110>:   addal d2,a1
0x25c0 <memmove+112>:   movel a0,d1
0x25c2 <memmove+114>:   movel a1,d0
0x25c4 <memmove+116>:   orl d1,d0
0x25c6 <memmove+118>:   movel #3,d4
0x25c8 <memmove+120>:   andl d4,d0
0x25ca <memmove+122>:   beq 0x25ec <memmove+156>
0x25cc <memmove+124>:   movel a1,d0
0x25ce <memmove+126>:   eorl d1,d0
0x25d0 <memmove+128>:   movel #3,d4
0x25d2 <memmove+130>:   andl d4,d0
0x25d4 <memmove+132>:   bne 0x25dc <memmove+140>
0x25d6 <memmove+134>:   movel #4,d4
0x25d8 <memmove+136>:   cmpl d2,d4
0x25da <memmove+138>:   bcs 0x25e0 <memmove+144>
0x25dc <memmove+140>:   movel d2,d1
0x25de <memmove+142>:   bra 0x25e4 <memmove+148>
0x25e0 <memmove+144>:   movel #3,d4
0x25e2 <memmove+146>:   andl d4,d1
0x25e4 <memmove+148>:   subl d1,d2
0x25e6 <memmove+150>:   moveb a0@-,a1@-
0x25e8 <memmove+152>:   subl #1,d1
0x25ea <memmove+154>:   bne 0x25e6 <memmove+150>
0x25ec <memmove+156>:   movel d2,d1
0x25ee <memmove+158>:   lsrl #2,d1
0x25f0 <memmove+160>:   beq 0x25f8 <memmove+168>
0x25f2 <memmove+162>:   movel a0@-,a1@-
0x25f4 <memmove+164>:   subl #1,d1
0x25f6 <memmove+166>:   bne 0x25f2 <memmove+162>
0x25f8 <memmove+168>:   movel #3,d1
0x25fa <memmove+170>:   andl d2,d1
0x25fc <memmove+172>:   beq 0x2604 <memmove+180>
0x25fe <memmove+174>:   moveb a0@-,a1@-
0x2600 <memmove+176>:   subl #1,d1
0x2602 <memmove+178>:   bne 0x25fe <memmove+174>
0x2604 <memmove+180>:   movel d3,d0
0x2606 <memmove+182>:   moveml fp@(-12),d2-d4
0x260c <memmove+188>:   unlk fp
0x260e <memmove+190>:   rts

The machine code of the above program is:

<memmove>:       0x4e56  0x0000  0x48e7  0x3800  0x262e  0x0008  0x242e  0x0010
<memmove+16>:    0x2243  0x206e  0x000c  0x6700  0x009c  0xb1c3  0x6700  0x0096
<memmove+32>:    0x634a  0x2208  0x2001  0x8083  0x7803  0xc084  0x6724  0x2001
<memmove+48>:    0xb780  0x7803  0xc084  0x6606  0x7803  0xb882  0x6504  0x2202
<memmove+64>:    0x6008  0x7003  0xc081  0x7204  0x9280  0x9481  0x12d8  0x5381
<memmove+80>:    0x66fa  0x2202  0xe489  0x6706  0x22d8  0x5381  0x66fa  0x7203
<memmove+96>:    0xc282  0x6750  0x12d8  0x5381  0x66fa  0x6048  0xd1c2  0xd3c2
<memmove+112>:   0x2208  0x2009  0x8081  0x7803  0xc084  0x6720  0x2009  0xb380
<memmove+128>:   0x7803  0xc084  0x6606  0x7804  0xb882  0x6504  0x2202  0x6004
<memmove+144>:   0x7803  0xc284  0x9481  0x1320  0x5381  0x66fa  0x2202  0xe489
<memmove+160>:   0x6706  0x2320  0x5381  0x66fa  0x7203  0xc282  0x6706  0x1320
<memmove+176>:   0x5381  0x66fa  0x2003  0x4cee  0x001c  0xfff4  0x4e5e  0x4e75

'(78      86      0       0       72      231     56      0
  38      46      0       8       36      46      0       16
  34      67      32      110     0       12      103     0
  0       156     177     195     103     0       0       150
  99      74      34      8       32      1       128     131
  120     3       192     132     103     36      32      1
  183     128     120     3       192     132     102     6
  120     3       184     130     101     4       34      2
  96      8       112     3       192     129     114     4
  146     128     148     129     18      216     83      129
  102     250     34      2       228     137     103     6
  34      216     83      129     102     250     114     3
  194     130     103     80      18      216     83      129
  102     250     96      72      209     194     211     194
  34      8       32      9       128     129     120     3
  192     132     103     32      32      9       179     128
  120     3       192     132     102     6       120     4
  184     130     101     4       34      2       96      4
  120     3       194     132     148     129     19      32
  83      129     102     250     34      2       228     137
  103     6       35      32      83      129     102     250
  114     3       194     130     103     6       19      32
  83      129     102     250     32      3       76      238
  0       28      255     244     78      94      78      117)

|#

;  in the logic, the above program is defined by (memmove-code).
(defn memmove-code ()
  '(78      86      0       0       72      231     56      0
    38      46      0       8       36      46      0       16
    34      67      32      110     0       12      103     0
    0       156     177     195     103     0       0       150
    99      74      34      8       32      1       128     131
    120     3       192     132     103     36      32      1
    183     128     120     3       192     132     102     6
    120     3       184     130     101     4       34      2
    96      8       112     3       192     129     114     4
    146     128     148     129     18      216     83      129
    102     250     34      2       228     137     103     6
    34      216     83      129     102     250     114     3
    194     130     103     80      18      216     83      129
    102     250     96      72      209     194     211     194
    34      8       32      9       128     129     120     3
    192     132     103     32      32      9       179     128
    120     3       192     132     102     6       120     4
    184     130     101     4       34      2       96      4
    120     3       194     132     148     129     19      32
    83      129     102     250     34      2       228     137
    103     6       35      32      83      129     102     250
    114     3       194     130     103     6       19      32
    83      129     102     250     32      3       76      238
    0       28      255     244     78      94      78      117))

; the preconditions of the initial state.
(defn memmove-statep (s str1 n lst1 str2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 192)
       (mcode-addrp (mc-pc s) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 16 (read-sp s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n)
       (mem-lst 1 str1 (mc-mem s) n lst1)
       (ram-addrp str2 (mc-mem s) n)
       (mem-lst 1 str2 (mc-mem s) n lst2)
       (disjoint (sub 32 16 (read-sp s)) 32 str1 n)
       (disjoint (sub 32 16 (read-sp s)) 32 str2 n)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (uint-rangep (plus (nat-to-uint str1) n) 32)
       (uint-rangep (plus (nat-to-uint str2) n) 32)))

; intermediate states.
(defn memmove-s0p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 76 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 76 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp (add 32 str2 i*) (mc-mem s) (difference n_ i))
       (mem-lst 1 (add 32 str2 i*) (mc-mem s) (difference n_ i) (mcdr i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal n (uread-dn 32 2 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str1) (nat-to-uint str2))
       (nat-rangep str2 32)                  
       (leq (plus i nt n) n_)
       (not (equal nt 0))
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n_))))

(defn memmove-s1p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 88 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 88 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp (add 32 str2 i*) (mc-mem s) (difference n_ i))
       (mem-lst 1 (add 32 str2 i*) (mc-mem s) (difference n_ i) (mcdr i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal n (uread-dn 32 2 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str1) (nat-to-uint str2))
       (nat-rangep str2 32)
       (leq (plus i (times 4 nt) (remainder n 4)) n_)
       (not (equal nt 0))
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n_))))

(defn memmove-s2p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 100 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 100 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp (add 32 str2 i*) (mc-mem s) (difference n_ i))
       (mem-lst 1 (add 32 str2 i*) (mc-mem s) (difference n_ i) (mcdr i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str1) (nat-to-uint str2))
       (nat-rangep str2 32)
       (leq (plus i nt) n_)
       (not (equal nt 0))
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n_))))

(defn memmove-s3p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 150 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 150 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp str2 (mc-mem s) i)
       (mem-lst 1 str2 (mc-mem s) i (mcar i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal n (uread-dn 32 2 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str2) (nat-to-uint str1))
       (nat-rangep str2 32)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (leq i n_)
       (leq (plus nt n) i)
       (not (zerop nt))
       (not (zerop i))
       (not (zerop n_))))

(defn memmove-s4p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 162 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 162 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp str2 (mc-mem s) i)
       (mem-lst 1 str2 (mc-mem s) i (mcar i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal n (uread-dn 32 2 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str2) (nat-to-uint str1))
       (nat-rangep str2 32)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (leq i n_)
       (leq (plus (times 4 nt) (remainder n 4)) i)
       (not (lessp i 4))
       (not (zerop nt))
       (not (zerop n_))))

(defn memmove-s5p (s i* i str1 n lst1 str2 lst2 nt n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 174 (mc-pc s)) (mc-mem s) 192)
       (mcode-addrp (sub 32 174 (mc-pc s)) (mc-mem s) (memmove-code))
       (ram-addrp (sub 32 12 (read-an 32 6 s)) (mc-mem s) 32)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp str2 (mc-mem s) i)
       (mem-lst 1 str2 (mc-mem s) i (mcar i lst2))
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str1 n_)
       (disjoint (sub 32 12 (read-an 32 6 s)) 32 str2 n_)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 3 s))
       (equal nt (uread-dn 32 1 s))
       (lessp (plus (nat-to-uint str1) n_) 4294967296)
       (lessp (plus (nat-to-uint str2) n_) 4294967296)
       (lessp (nat-to-uint str2) (nat-to-uint str1))
       (nat-rangep str2 32)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (leq i n_)
       (leq nt i)
       (not (zerop nt))
       (not (zerop i))
       (not (zerop n_))))

; enable a few events for this proof.
(enable disjoint-leq-uint)
(enable disjoint-leq1-uint)
(enable add-uintxxx)
(enable plus-times-sub1)

; from the initial state to exit:  s --> sn, when n == 0.
(prove-lemma memmove-s-sn-1 (rewrite)
     (let ((sn (stepn s 11)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (zerop n))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (rts-addr s))
                     (mem-lst 1 str1 (mc-mem sn) n lst1)
                     (equal (read-dn 32 0 sn) str1)
                     (equal (read-rn 32 14 (mc-rfile sn)) 
                            (read-an 32 6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 7 s) 4))))))

(prove-lemma memmove-s-sn-rfile-1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (zerop n)
                   (leq oplen 32)
                   (d2-7a2-5p rn))                 
              (equal (read-rn oplen rn (mc-rfile (stepn s 11)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-sn-mem-1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (zerop n)
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 11)) k)
                     (read-mem x (mc-mem s) k))))

; from the initial state to exit:  s --> sn, when n =\= 0 and str1 == str2.
(prove-lemma memmove-s-sn-2 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (equal (nat-to-uint str1) (nat-to-uint str2)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (rts-addr s))
                     (mem-lst 1 str1 (mc-mem sn) n lst2)
                     (equal (read-dn 32 0 sn) str1)
                     (equal (read-rn 32 14 (mc-rfile sn)) 
                            (read-an 32 6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 7 s) 4)))))
     ((enable mem-lst-same)))

(prove-lemma memmove-s-sn-rfile-2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (equal (nat-to-uint str1) (nat-to-uint str2))
                   (leq oplen 32)
                   (d2-7a2-5p rn))                 
              (equal (read-rn oplen rn (mc-rfile (stepn s 13)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-sn-mem-2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (equal (nat-to-uint str1) (nat-to-uint str2))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 13)) k)
                     (read-mem x (mc-mem s) k))))

; from the initial state s to s0:  s --> s0.
(prove-lemma memmove-s-s0-1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (not (equal (remainder (nat-to-uint str1) 4)
                               (remainder (nat-to-uint str2) 4)))
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0))))
              (memmove-s0p (stepn s 24) 0 0 str1 0 lst1 str2 lst2 n n)))

(prove-lemma memmove-s-s0-else-1 (rewrite)
     (let ((s0 (stepn s 24)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (not (equal (remainder (nat-to-uint str1) 4)
                                 (remainder (nat-to-uint str2) 4)))
                     (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                         (not (equal (remainder (nat-to-uint str2) 4) 0))))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s0-rfile-1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (not (equal (remainder (nat-to-uint str1) 4)
                               (remainder (nat-to-uint str2) 4)))
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 24)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s0-mem-1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (not (equal (remainder (nat-to-uint str1) 4)
                               (remainder (nat-to-uint str2) 4)))
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 24)) k)
                     (read-mem x (mc-mem s) k))))

(prove-lemma memmove-s-s0-2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4)
                          (remainder (nat-to-uint str2) 4))
                   (leq n 3)
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0))))
              (memmove-s0p (stepn s 27) 0 0 str1 0 lst1 str2 lst2 n n)))

(prove-lemma memmove-s-s0-else-2 (rewrite)
     (let ((s0 (stepn s 27)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (equal (remainder (nat-to-uint str1) 4)
                            (remainder (nat-to-uint str2) 4))
                     (leq n 3)
                     (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                         (not (equal (remainder (nat-to-uint str2) 4) 0))))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s0-rfile-2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4)
                          (remainder (nat-to-uint str2) 4))
                   (leq n 3)
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 27)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s0-mem-2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4)
                          (remainder (nat-to-uint str2) 4))
                   (leq n 3)
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 27)) k)
                     (read-mem x (mc-mem s) k))))

(prove-lemma memmove-s-s0-3 (rewrite)
     (let ((r (remainder (nat-to-uint str1) 4)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (equal (remainder (nat-to-uint str1) 4)
                            (remainder (nat-to-uint str2) 4))
                     (lessp 3 n)
                     (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                         (not (equal (remainder (nat-to-uint str2) 4) 0))))
                (memmove-s0p (stepn s 29) 0 0 str1 (difference (plus n r) 4)
                             lst1 str2 lst2 (difference 4 r) n))))

(prove-lemma memmove-s-s0-else-3 (rewrite)
     (let ((s0 (stepn s 29)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (equal (remainder (nat-to-uint str1) 4)
                            (remainder (nat-to-uint str2) 4))
                     (lessp 3 n)
                     (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                         (not (equal (remainder (nat-to-uint str2) 4) 0))))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s0-rfile-3 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4)
                          (remainder (nat-to-uint str2) 4))
                   (lessp 3 n)
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 29)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s0-mem-3 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4)
                          (remainder (nat-to-uint str2) 4))
                   (lessp 3 n)
                   (or (not (equal (remainder (nat-to-uint str1) 4) 0))
                       (not (equal (remainder (nat-to-uint str2) 4) 0)))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 29)) k)
                     (read-mem x (mc-mem s) k))))

; from the initial state s to s1:  s --> s1.
(prove-lemma memmove-s-s1 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (not (lessp n 4)))
              (memmove-s1p (stepn s 19) 0 0 str1 n lst1 
                           str2 lst2 (quotient n 4) n)))

(prove-lemma memmove-s-s1-else (rewrite)
     (let ((s1 (stepn s 19)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (equal (remainder (nat-to-uint str1) 4) 0)
                     (equal (remainder (nat-to-uint str2) 4) 0)
                     (not (lessp n 4)))
                (and (equal (linked-rts-addr s1) (rts-addr s))
                     (equal (linked-a6 s1) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s1))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s1 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s1-rfile (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (not (lessp n 4))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 19)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s1-mem (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (not (lessp n 4))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 19)) k)
                     (read-mem x (mc-mem s) k))))

; from s to s2.  s --> s2.
(prove-lemma memmove-s-s2 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (lessp n 4))
              (memmove-s2p (stepn s 22) 0 0 str1 n lst1 str2 lst2 n n)))

(prove-lemma memmove-s-s2-else (rewrite)
     (let ((s2 (stepn s 22)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (lessp (nat-to-uint str1) (nat-to-uint str2))
                     (equal (remainder (nat-to-uint str1) 4) 0)
                     (equal (remainder (nat-to-uint str2) 4) 0)
                     (lessp n 4))
                (and (equal (linked-rts-addr s2) (rts-addr s))
                     (equal (linked-a6 s2) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s2))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s2 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s2-rfile (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (lessp n 4)
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 22)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s2-mem (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (lessp (nat-to-uint str1) (nat-to-uint str2))
                   (equal (remainder (nat-to-uint str1) 4) 0)
                   (equal (remainder (nat-to-uint str2) 4) 0)
                   (lessp n 4)
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 22)) k)
                     (read-mem x (mc-mem s) k))))

; s0 --> s1.
(prove-lemma memmove-s0-s1 ()
     (let ((s1 (stepn s 6)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (lessp n 4)))
                (memmove-s1p s1 (add 32 i* 1) (add1 i) str1 n
			     (put-nth (get-nth i lst2) i lst1) 
			     str2 lst2 (quotient n 4) n_)))
     ((disable mcdr)))

(prove-lemma memmove-s0-s1-else (rewrite)
     (let ((s1 (stepn s 6)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (lessp n 4)))
                (and (equal (linked-rts-addr s1) (linked-rts-addr s))
                     (equal (linked-a6 s1) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s1))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s1 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s0-s1-rfile (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (lessp n 4))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s0-s1-mem (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (lessp n 4))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 6)) k)
                     (read-mem x (mc-mem s) k))))

; s0 --> s2.
(prove-lemma memmove-s0-s2 ()
     (let ((s2 (stepn s 9)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (lessp n 4)
                     (not (zerop n)))
                (memmove-s2p s2 (add 32 i* 1) (add1 i) str1 n
			     (put-nth (get-nth i lst2) i lst1) str2 
			     lst2 n n_)))
     ((disable mcdr)))

(prove-lemma memmove-s0-s2-else (rewrite)
     (let ((s2 (stepn s 9)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (lessp n 4)
                     (not (zerop n)))
                (and (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s2))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s2 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s0-s2-rfile (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (lessp n 4)
                   (not (zerop n))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s0-s2-mem (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (lessp n 4)
                   (not (zerop n))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 9)) k)
                     (read-mem x (mc-mem s) k))))

; s0 --> s0.
(prove-lemma memmove-s0-s0 (rewrite)
     (let ((s0 (stepn s 3)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s0p s0 (add 32 i* 1) (add1 i) str1 n 
                                  (put-nth (get-nth i lst2) i lst1) str2 
                                  lst2 (sub1 nt) n_)
                     (equal (linked-rts-addr s0) (linked-rts-addr s))
                     (equal (linked-a6 s0) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s0))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s0 4 12 3)
                            (movem-saved s 4 12 3)))))
     ((disable mcdr)))

(prove-lemma memmove-s0-s0-rfile (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s0-s0-mem (rewrite)
     (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; s1 --> s2.
(prove-lemma memmove-s1-s2 ()
     (let ((s2 (stepn s 6)))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (equal (remainder n 4) 0)))
                (memmove-s2p s2 (add 32 i* 4) (plus 4 i) str1 n 
			     (movn-lst 4 lst1 lst2 i) str2 lst2 
			     (remainder n 4) n_)))
     ((disable mcdr plus)))

(prove-lemma memmove-s1-s2-else (rewrite)
     (let ((s2 (stepn s 6)))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (equal (remainder n 4) 0)))
                (and (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s2))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s2 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s1-s2-rfile (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (equal (remainder n 4) 0))                 
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s1-s2-mem (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (equal (remainder n 4) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 6)) k)
                     (read-mem x (mc-mem s) k))))

; s1 --> s1.
(prove-lemma memmove-s1-s1 (rewrite)
     (let ((s1 (stepn s 3)))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s1p s1 (add 32 i* 4) (plus 4 i) str1 n
				  (movn-lst 4 lst1 lst2 i) str2 lst2 
				  (sub1 nt) n_)
                     (equal (linked-rts-addr s1) (linked-rts-addr s))
                     (equal (linked-a6 s1) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s1))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s1 4 12 3)
                            (movem-saved s 4 12 3)))))
     ((disable mcdr plus)))

(prove-lemma memmove-s1-s1-rfile (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s1-s1-mem (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; from s2 to exit:  s2 --> sn.
; base case:  s2 --> sn.
(prove-lemma memmove-s2-sn-base (rewrite)
     (let ((sn (stepn s 8)))
       (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0))                    
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ 
                              (put-nth (get-nth i lst2) i lst1))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8))))))

(prove-lemma memmove-s2-sn-rfile-base (rewrite)
     (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (d2-7a2-5p rn)
                   (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
                                 (movem-saved s 4 12 3))))))

(prove-lemma memmove-s2-sn-mem-base (rewrite)
     (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 8)) k)
                     (read-mem x (mc-mem s) k))))

; induction case:  s2 --> s2.
(prove-lemma memmove-s2-s2 (rewrite)
     (let ((s2 (stepn s 3)))
       (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s2p s2 (add 32 i* 1) (add1 i) str1 n
                                  (put-nth (get-nth i lst2) i lst1) str2 
                                  lst2 (sub1 nt) n_)
                     (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s2))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s2 4 12 3)
                            (movem-saved s 4 12 3)))))
     ((disable mcdr)))

(prove-lemma memmove-s2-s2-rfile (rewrite)
     (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s2-s2-mem (rewrite)
     (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; put together: s2 --> sn.
(defn memmove-s2-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      8
    (splus 3 (memmove-s2-sn-t (add 32 i* 1) (add1 i) str1 n 
			      (put-nth (get-nth i lst2) i lst1) str2 
			      lst2 (sub1 nt) n_))))

(defn memmove-s2-sn-induct (s i* i lst1 lst2 nt)
  (if (equal (sub1 nt) 0)
      t
    (memmove-s2-sn-induct (stepn s 3) (add 32 i* 1) (add1 i)
                          (put-nth (get-nth i lst2) i lst1) lst2 (sub1 nt))))

(prove-lemma memmove-s2p-info (rewrite)
     (implies (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
	      (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s2-sn (rewrite)
     (let ((sn (stepn s (memmove-s2-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ (mmov1-lst i lst1 lst2 nt))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
       ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
        (disable memmove-s2p read-dn)))

(prove-lemma memmove-s2-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s2-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                     (d2-7a2-5p rn)
                     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d5-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3 4)
                                   (movem-saved s 4 12 3))))))
     ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s2p)))

(prove-lemma memmove-s2-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s2-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s2p s i* i str1 n lst1 str2 lst2 nt n_)
                     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s2p)))

(disable memmove-s2p-info)

; from s1 to sn: s1 --> sn.
; base case 1: s1 --> sn.
(prove-lemma memmove-s1-sn-base-1 (rewrite)
     (let ((sn (stepn s 10)))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (equal (remainder n 4) 0))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ (movn-lst 4 lst1 lst2 i))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((disable mcdr plus)))

(prove-lemma memmove-s1-sn-rfile-base-1 (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
		   (equal (remainder n 4) 0)
                   (d2-7a2-5p rn)
                   (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile (stepn s 10)))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
                                 (movem-saved s 4 12 3))))))

(prove-lemma memmove-s1-sn-mem-base-1 (rewrite)
     (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
		   (equal (remainder n 4) 0)
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 10)) k)
                     (read-mem x (mc-mem s) k))))
     
; base case 2: s1 --> s2 --> sn.
(defn memmove-s1-sn-t0 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 6 (memmove-s2-sn-t (add 32 i* 4) (plus 4 i) str1 n 
			    (movn-lst 4 lst1 lst2 i) str2 lst2 
			    (remainder n 4) n_)))

(prove-lemma memmove-s1-sn-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (mmov1-lst (plus 4 i) (movn-lst 4 lst1 lst2 i) 
					 lst2 (remainder n 4)))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s1-s2))
      (disable memmove-s1p memmove-s2p read-dn movn-lst)))

(prove-lemma memmove-s1-sn-rfile-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
				 (movem-saved s 4 12 3))))))
     ((use (memmove-s1-s2))
      (disable memmove-s1p memmove-s2p)))     

(prove-lemma memmove-s1-sn-mem-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0))
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s1-s2))
      (disable memmove-s1p memmove-s2p)))     

; put together:  s1 --> s2.
(defn memmove-s1-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      (if (equal (remainder n 4) 0) 
	  10 
	(memmove-s1-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))
    (splus 3 (memmove-s1-sn-t (add 32 i* 4) (plus 4 i) str1 n
			      (movn-lst 4 lst1 lst2 i) str2 lst2
			      (sub1 nt) n_))))

(defn memmove-s1-sn-induct (s i* i lst1 lst2 nt)
  (if (equal (sub1 nt) 0)
      t
    (memmove-s1-sn-induct (stepn s 3) (add 32 i* 4) (plus 4 i)
			  (movn-lst 4 lst1 lst2 i) lst2 (sub1 nt))))

(prove-lemma memmove-s1p-info (rewrite)
     (implies (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
	      (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s1-sn (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-1 lst1 lst2 i nt n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((induct (memmove-s1-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s1p memmove-s1-sn-t0 movn-lst plus read-dn)))

(prove-lemma memmove-s1-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		       (if (d5-7a2-5p rn)
			   (read-rn oplen rn (mc-rfile s))
			 (get-vlst oplen 0 rn '(2 3 4)
				   (movem-saved s 4 12 3))))))
     ((induct (memmove-s1-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s1p memmove-s1-sn-t0 movn-lst plus)))

(prove-lemma memmove-s1-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s1-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s1p s i* i str1 n lst1 str2 lst2 nt n_)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
		(equal (read-mem x (mc-mem sn) k)
		       (read-mem x (mc-mem s) k))))
     ((induct (memmove-s1-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s1p memmove-s1-sn-t0 movn-lst plus)))

(disable memmove-s1p-info)

; from s0 to sn: s0 --> sn.
; base case 1: s0 --> sn.
(prove-lemma memmove-s0-sn-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (zerop n))
		(and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (put-nth (get-nth i lst2) i lst1))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8))))))

(prove-lemma memmove-s0-sn-rfile-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (zerop n)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d5-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3 4)
                                   (movem-saved s 4 12 3)))))))

(prove-lemma memmove-s0-sn-mem-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (zerop n)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                     (disjoint x k str1 n_))
                (equal (read-mem x (mc-mem sn) k)
                       (read-mem x (mc-mem s) k)))))		
		
; base case 2: s0 --> s1 --> sn.
(defn memmove-s0-sn-t0 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 6 (memmove-s1-sn-t (add 32 i* 1) (add1 i) str1 n
			    (put-nth (get-nth i lst2) i lst1)
                             str2 lst2 (quotient n 4) n_)))

(prove-lemma memmove-s0-sn-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (not (lessp n 4)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-1 (put-nth (get-nth i lst2) i lst1)
					 lst2 (add1 i) (quotient n 4) n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s0-s1))
      (disable memmove-s0p memmove-s1p read-dn memmove-1)))

(prove-lemma memmove-s0-sn-rfile-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (lessp n 4))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
				 (movem-saved s 4 12 3))))))
     ((use (memmove-s0-s1))
      (disable memmove-s0p memmove-s1p)))     

(prove-lemma memmove-s0-sn-mem-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (lessp n 4))
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s0-s1))
      (disable memmove-s0p memmove-s1p)))     

; base case 3: s0 --> s2 --> sn.
(defn memmove-s0-sn-t1 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 9 (memmove-s2-sn-t (add 32 i* 1) (add1 i) str1 n
			    (put-nth (get-nth i lst2) i lst1) str2
			    lst2 n n_)))

(prove-lemma memmove-s0-sn-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (mmov1-lst (add1 i) 
					 (put-nth (get-nth i lst2) i lst1)
					 lst2 n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s0-s2))
      (disable memmove-s0p memmove-s2p read-dn)))

(prove-lemma memmove-s0-sn-rfile-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
				 (movem-saved s 4 12 3))))))
     ((use (memmove-s0-s2))
      (disable memmove-s0p memmove-s2p)))

(prove-lemma memmove-s0-sn-mem-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n))		
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s0-s2))
      (disable memmove-s0p memmove-s2p)))     

; put together: s0 --> sn.
(defn memmove-s0-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      (if (lessp n 4)
	  (if (zerop n) 
	      13 
	    (memmove-s0-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))
	(memmove-s0-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))
    (splus 3 (memmove-s0-sn-t (add 32 i* 1) (add1 i) str1 n
			      (put-nth (get-nth i lst2) i lst1) str2
			      lst2 (sub1 nt) n_))))

(prove-lemma memmove-s0p-info (rewrite)
     (implies (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
              (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s0-sn (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-0 lst1 lst2 i nt n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s0p read-dn memmove-s0-sn-t0 memmove-s0-sn-t1 memmove-1)
      (enable plus-add1-sub1 plus-add1-1)))

(prove-lemma memmove-s0-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		       (if (d5-7a2-5p rn)
			   (read-rn oplen rn (mc-rfile s))
			 (get-vlst oplen 0 rn '(2 3 4)
				   (movem-saved s 4 12 3))))))
     ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s0p memmove-s0-sn-t0 memmove-s0-sn-t1)))

(prove-lemma memmove-s0-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s0-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s0p s i* i str1 n lst1 str2 lst2 nt n_)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
		(equal (read-mem x (mc-mem sn) k)
		       (read-mem x (mc-mem s) k))))
     ((induct (memmove-s2-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s0p memmove-s0-sn-t0 memmove-s0-sn-t1)))

(disable memmove-s0p-info)

; from the initial state s to s3:  s --> s3.
(prove-lemma memmove-s-s3-1 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
	   (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (not (equal (remainder x1 4) (remainder x2 4)))
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0))))
		(memmove-s3p (stepn s 26) (uint-to-nat n) n str1 0 lst1 str2 
			     lst2 n n)))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-else-1 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n))
	   (s3 (stepn s 26)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                     (not (equal (remainder x1 4) (remainder x2 4)))
                     (or (not (equal (remainder x1 4) 0))
                         (not (equal (remainder x2 4) 0))))
                (and (equal (linked-rts-addr s3) (rts-addr s))
                     (equal (linked-a6 s3) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s3))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s3 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s))))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-rfile-1 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (not (equal (remainder x1 4) (remainder x2 4)))
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (d5-7a2-5p rn))
		(equal (read-rn oplen rn (mc-rfile (stepn s 26)))
		       (read-rn oplen rn (mc-rfile s)))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-mem-1 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))	     
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (not (equal (remainder x1 4) (remainder x2 4)))
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 26)) k)
                     (read-mem x (mc-mem s) k))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-2 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder x1 4) (remainder x2 4))
		     (leq n 4)
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0))))
              (memmove-s3p (stepn s 29) (uint-to-nat n) n str1 0 lst1 
			   str2 lst2 n n)))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-else-2 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n))
	   (s3 (stepn s 29)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                     (equal (remainder x1 4) (remainder x2 4))
                     (leq n 4)
                     (or (not (equal (remainder x1 4) 0))
                         (not (equal (remainder x2 4) 0))))
                (and (equal (linked-rts-addr s3) (rts-addr s))
                     (equal (linked-a6 s3) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s3))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s3 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s))))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-rfile-2 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder x1 4) (remainder x2 4))
		     (leq n 4)
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 29)))
                     (read-rn oplen rn (mc-rfile s)))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-mem-2 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder x1 4) (remainder x2 4))
		     (leq n 4)
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (disjoint x k (sub 32 16 (read-sp s)) 32))
		(equal (read-mem x (mc-mem (stepn s 29)) k)
		       (read-mem x (mc-mem s) k))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-3 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n))
	   (nt (remainder (plus n (nat-to-uint str1)) 4)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                     (equal (remainder x1 4) (remainder x2 4))
		     (lessp 4 n)
                     (or (not (equal (remainder x1 4) 0))
                         (not (equal (remainder x2 4) 0))))
                (memmove-s3p (stepn s 29) (uint-to-nat n) n str1 
			     (difference n nt) lst1 str2 lst2 nt n)))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-else-3 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n))
	   (s3 (stepn s 29)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                     (equal (remainder x1 4) (remainder x2 4))
		     (lessp 4 n)
                     (or (not (equal (remainder x1 4) 0))
                         (not (equal (remainder x2 4) 0))))
                (and (equal (linked-rts-addr s3) (rts-addr s))
                     (equal (linked-a6 s3) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s3))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s3 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s))))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-rfile-3 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))	     
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder x1 4) (remainder x2 4))
		     (lessp 4 n)
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 29)))
                     (read-rn oplen rn (mc-rfile s)))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

(prove-lemma memmove-s-s3-mem-3 (rewrite)
     (let ((x1 (plus (nat-to-uint str1) n))
           (x2 (plus (nat-to-uint str2) n)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
		     (not (zerop n))
		     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder x1 4) (remainder x2 4))
		     (lessp 4 n)
		     (or (not (equal (remainder x1 4) 0))
			 (not (equal (remainder x2 4) 0)))
		     (disjoint x k (sub 32 16 (read-sp s)) 32))
		(equal (read-mem x (mc-mem (stepn s 29)) k)
		       (read-mem x (mc-mem s) k))))
     ((disable plus remainder quotient disjoint-leq-uint disjoint-leq1-uint)))

; from the initial state s to s4:  s --> s4. 
(prove-lemma memmove-s-s4 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (not (lessp n 4)))
              (memmove-s4p (stepn s 21) (uint-to-nat n) n str1 n lst1 
                           str2 lst2 (quotient n 4) n)))

(prove-lemma memmove-s-s4-else (rewrite)
     (let ((s4 (stepn s 21)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
		     (equal (remainder (plus n (nat-to-uint str2)) 4) 0)  
                     (not (lessp n 4)))
                (and (equal (linked-rts-addr s4) (rts-addr s))
                     (equal (linked-a6 s4) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s4))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s4 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s4-rfile (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (not (lessp n 4))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 21)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s4-mem (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (not (lessp n 4))
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 21)) k)
                     (read-mem x (mc-mem s) k))))

; from s to s5.  s --> s5.
(prove-lemma memmove-s-s5 (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (lessp n 4))
              (memmove-s5p (stepn s 24) (uint-to-nat n) n str1 n lst1
                           str2 lst2 n n)))

(prove-lemma memmove-s-s5-else (rewrite)
     (let ((s0 (stepn s 24)))
       (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                     (not (zerop n))
                     (not (equal (nat-to-uint str1) (nat-to-uint str2)))
                     (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
		     (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
		     (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                     (lessp n 4))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 12 3)
                            (readm-rn 32 '(2 3 4) (mc-rfile s)))))))

(prove-lemma memmove-s-s5-rfile (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (lessp n 4)
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 24)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s-s5-mem (rewrite)
     (implies (and (memmove-statep s str1 n lst1 str2 lst2)
                   (not (zerop n))
                   (not (equal (nat-to-uint str1) (nat-to-uint str2)))
		   (not (lessp (nat-to-uint str1) (nat-to-uint str2)))
                   (equal (remainder (plus n (nat-to-uint str1)) 4) 0)
                   (equal (remainder (plus n (nat-to-uint str2)) 4) 0)
                   (lessp n 4)
                   (disjoint x k (sub 32 16 (read-sp s)) 32))
              (equal (read-mem x (mc-mem (stepn s 24)) k)
                     (read-mem x (mc-mem s) k))))

; s3 --> s4.
(prove-lemma memmove-s3-s4 ()
     (let ((s4 (stepn s 6)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (lessp n 4)))
		(memmove-s4p s4 (sub 32 1 i*) (sub1 i) str1 n
			     (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1) 
			     str2 lst2 (quotient n 4) n_))))

(prove-lemma memmove-s3-s4-else (rewrite)
     (let ((s4 (stepn s 6)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (lessp n 4)))
                (and (equal (linked-rts-addr s4) (linked-rts-addr s))
                     (equal (linked-a6 s4) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s4))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s4 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s3-s4-rfile-base (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (lessp n 4))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s3-s4-mem-base (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (lessp n 4))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 6)) k)
                     (read-mem x (mc-mem s) k))))

; s3 --> s5.
(prove-lemma memmove-s3-s5 ()
     (let ((s5 (stepn s 9)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (lessp n 4)
                     (not (zerop n)))
                (memmove-s5p s5 (sub 32 1 i*) (sub1 i) str1 n
			     (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1) 
			     str2 lst2 n n_))))

(prove-lemma memmove-s3-s5-else (rewrite)
     (let ((s5 (stepn s 9)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (lessp n 4)
                     (not (zerop n)))
                (and (equal (linked-rts-addr s5) (linked-rts-addr s))
                     (equal (linked-a6 s5) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s5))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s5 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s3-s5-rfile (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (lessp n 4)
                   (not (zerop n))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s3-s5-mem (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (lessp n 4)
                   (not (zerop n))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 9)) k)
                     (read-mem x (mc-mem s) k))))

; s3 --> s3.
(prove-lemma memmove-s3-s3 (rewrite)
     (let ((s3 (stepn s 3)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s3p s3 (sub 32 1 i*) (sub1 i) str1 n 
                                  (put-nth (get-nth (sub1 i) lst2) 
					   (sub1 i) lst1) 
				  str2 lst2 (sub1 nt) n_)
                     (equal (linked-rts-addr s3) (linked-rts-addr s))
                     (equal (linked-a6 s3) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s3))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s3 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s3-s3-rfile (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s3-s3-mem (rewrite)
     (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; s4 --> s5.
(prove-lemma memmove-s4-s5 ()
     (let ((s5 (stepn s 6)))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (equal (remainder n 4) 0)))
                (memmove-s5p s5 (sub 32 4 i*) (difference i 4) str1 n 
			     (movn-lst 4 lst1 lst2 (difference i 4)) str2 
			     lst2 (remainder n 4) n_)))
     ((disable put-get-vals-is-cpy)))

(prove-lemma memmove-s4-s5-else (rewrite)
     (let ((s5 (stepn s 6)))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (not (equal (remainder n 4) 0)))
                (and (equal (linked-rts-addr s5) (linked-rts-addr s))
                     (equal (linked-a6 s5) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s5))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s5 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s4-s5-rfile (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (equal (remainder n 4) 0))                 
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s4-s5-mem (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (not (equal (remainder n 4) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 6)) k)
                     (read-mem x (mc-mem s) k))))

; s4 --> s4.
(prove-lemma memmove-s4-s4 (rewrite)
     (let ((s4 (stepn s 3)))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s4p s4 (sub 32 4 i*) (difference i 4) str1 n 
				  (movn-lst 4 lst1 lst2 (difference i 4)) 
				  str2 lst2 (sub1 nt) n_)
		     (equal (linked-rts-addr s4) (linked-rts-addr s))
                     (equal (linked-a6 s4) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s4))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s4 4 12 3)
                            (movem-saved s 4 12 3)))))
     ((disable put-get-vals-is-cpy)))

(prove-lemma memmove-s4-s4-rfile (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s4-s4-mem (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; from s5 to exit:  s5 --> sn.
; base case: s5 --> sn.
(prove-lemma memmove-s5-sn-base (rewrite)
     (let ((sn (stepn s 7)))
       (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0))                    
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ 
                              (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8))))))

(prove-lemma memmove-s5-sn-rfile-base (rewrite)
     (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (d2-7a2-5p rn)
                   (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
                                 (movem-saved s 4 12 3))))))

(prove-lemma memmove-s5-sn-mem-base (rewrite)
     (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 7)) k)
                     (read-mem x (mc-mem s) k))))

; induction case:  s5 --> s5.
(prove-lemma memmove-s5-s5 (rewrite)
     (let ((s5 (stepn s 3)))
       (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                     (not (equal (sub1 nt) 0)))
                (and (memmove-s5p s5 (sub 32 1 i*) (sub1 i) str1 n
                                  (put-nth (get-nth (sub1 i) lst2) (sub1 i)
					   lst1) 
				  str2 lst2 (sub1 nt) n_)
                     (equal (linked-rts-addr s5) (linked-rts-addr s))
                     (equal (linked-a6 s5) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s5))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s5 4 12 3)
                            (movem-saved s 4 12 3))))))

(prove-lemma memmove-s5-s5-rfile (rewrite)
     (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (d5-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memmove-s5-s5-mem (rewrite)
     (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                   (not (equal (sub1 nt) 0))
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 3)) k)
                     (read-mem x (mc-mem s) k))))

; put together: s5 --> sn.
(defn memmove-s5-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      7
    (splus 3 (memmove-s5-sn-t (sub 32 1 i*) (sub1 i) str1 n
			      (put-nth (get-nth (sub1 i) lst2) (sub1 i)
				       lst1)
			      str2 lst2 (sub1 nt) n_))))

(defn memmove-s5-sn-induct (s i* i lst1 lst2 nt)
  (if (equal (sub1 nt) 0)
      t
    (memmove-s5-sn-induct (stepn s 3) (sub 32 1 i*) (sub1 i)
                          (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1) 
			  lst2 (sub1 nt))))

(prove-lemma memmove-s5p-info (rewrite)
     (implies (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
              (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s5-sn (rewrite)
     (let ((sn (stepn s (memmove-s5-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (mmov1-lst1 i lst1 lst2 nt))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
       ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
        (disable memmove-s5p read-dn sub-neg)))

(prove-lemma memmove-s5-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s5-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                     (d2-7a2-5p rn)
                     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d5-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3 4)
                                   (movem-saved s 4 12 3))))))
     ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s5p sub-neg)))

(prove-lemma memmove-s5-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s5-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s5p s i* i str1 n lst1 str2 lst2 nt n_)
                     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s5p sub-neg)))

(disable memmove-s5p-info)

; from s4 to sn: s4 --> sn.
; base case 1: s4 --> sn.
(prove-lemma memmove-s4-sn-base-1 (rewrite)
     (let ((sn (stepn s 10)))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (equal (remainder n 4) 0))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (movn-lst 4 lst1 lst2 (difference i 4)))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((disable put-get-vals-is-cpy)))

(prove-lemma memmove-s4-sn-rfile-base-1 (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
		   (equal (remainder n 4) 0)
                   (d2-7a2-5p rn)
                   (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile (stepn s 10)))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
                                 (movem-saved s 4 12 3))))))

(prove-lemma memmove-s4-sn-mem-base-1 (rewrite)
     (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                   (equal (sub1 nt) 0)
		   (equal (remainder n 4) 0)
                   (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                   (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem (stepn s 10)) k)
                     (read-mem x (mc-mem s) k))))

; base case 2: s4 --> s5 --> sn.
(defn memmove-s4-sn-t0 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 6 (memmove-s5-sn-t (sub 32 4 i*) (difference i 4) str1 n
			    (movn-lst 4 lst1 lst2 (difference i 4)) str2
			    lst2 (remainder n 4) n_)))

(prove-lemma memmove-s4-sn-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (mmov1-lst1 (difference i 4) 
					  (movn-lst 4 lst1 lst2 
						    (difference i 4))
					  lst2 (remainder n 4)))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s4-s5))
      (disable memmove-s4p memmove-s5p read-dn movn-lst sub-neg)))

(prove-lemma memmove-s4-sn-rfile-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
                                 (movem-saved s 4 12 3))))))
     ((use (memmove-s4-s5))
      (disable memmove-s4p memmove-s5p sub-neg)))

(prove-lemma memmove-s4-sn-mem-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (equal (remainder n 4) 0))
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s4-s5))
      (disable memmove-s4p memmove-s5p sub-neg)))     

; put together:  s4 --> sn.
(defn memmove-s4-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      (if (equal (remainder n 4) 0) 
	  10 
	(memmove-s4-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))
    (splus 3 (memmove-s4-sn-t (sub 32 4 i*) (difference i 4) str1 n
			      (movn-lst 4 lst1 lst2 (difference i 4)) str2
			      lst2 (sub1 nt) n_))))
	   
(defn memmove-s4-sn-induct (s i* i lst1 lst2 nt)
  (if (equal (sub1 nt) 0)
      t
    (memmove-s4-sn-induct (stepn s 3) (sub 32 4 i*) (difference i 4)
                          (movn-lst 4 lst1 lst2 (difference i 4)) lst2 
			  (sub1 nt))))

(prove-lemma memmove-s4p-info (rewrite)
     (implies (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
	      (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s4-sn (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
		(and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-4 lst1 lst2 i nt n))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((induct (memmove-s4-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s4p memmove-s4-sn-t0 read-dn movn-lst sub-neg)))

(prove-lemma memmove-s4-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		       (if (d5-7a2-5p rn)
			   (read-rn oplen rn (mc-rfile s))
			 (get-vlst oplen 0 rn '(2 3 4)
				   (movem-saved s 4 12 3))))))
     ((induct (memmove-s4-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s4p memmove-s4-sn-t0 movn-lst sub-neg)))

(prove-lemma memmove-s4-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s4-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s4p s i* i str1 n lst1 str2 lst2 nt n_)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((induct (memmove-s4-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s4p memmove-s4-sn-t0 movn-lst sub-neg)))

(disable memmove-s4p-info)

; from s3 to sn: s3 --> sn.
; base case 1: s3 --> sn.
(prove-lemma memmove-s3-sn-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (zerop n))
		(and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8))))))

(prove-lemma memmove-s3-sn-rfile-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (zerop n)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d5-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3 4)
                                   (movem-saved s 4 12 3)))))))

(prove-lemma memmove-s3-sn-mem-base-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
                     (zerop n)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
                     (disjoint x k str1 n_))
                (equal (read-mem x (mc-mem sn) k)
                       (read-mem x (mc-mem s) k)))))		

; base case 2: s3 --> s4 --> sn.
(defn memmove-s3-sn-t0 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 6 (memmove-s4-sn-t (sub 32 1 i*) (sub1 i) str1 n
			    (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1)
			    str2 lst2 (quotient n 4) n_)))

(prove-lemma memmove-s3-sn-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (not (lessp n 4)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-4 (put-nth (get-nth (sub1 i) lst2) 
						  (sub1 i) lst1)
					 lst2 (sub1 i) (quotient n 4) n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s3-s4))
      (disable memmove-s3p memmove-s4p read-dn memmove-4 sub-neg)))

(prove-lemma memmove-s3-sn-rfile-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (lessp n 4))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
				 (movem-saved s 4 12 3))))))
     ((use (memmove-s3-s4))
      (disable memmove-s3p memmove-s4p sub-neg)))     

(prove-lemma memmove-s3-sn-mem-base-2 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (not (lessp n 4))
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s3-s4))
      (disable memmove-s3p memmove-s4p sub-neg)))

; base case 3: s3 --> s5 --> sn.
(defn memmove-s3-sn-t1 (i* i str1 n lst1 str2 lst2 nt n_)
  (splus 9 (memmove-s5-sn-t (sub 32 1 i*) (sub1 i) str1 n
			    (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1)
			    str2 lst2 n n_)))

(prove-lemma memmove-s3-sn-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n)))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (mmov1-lst1 (sub1 i) 
					  (put-nth (get-nth (sub1 i) lst2) 
						   (sub1 i) lst1)
					  lst2 n))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (memmove-s3-s5))
      (disable memmove-s3p memmove-s5p read-dn sub-neg)))

(prove-lemma memmove-s3-sn-rfile-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile sn))
                     (if (d5-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3 4)
				 (movem-saved s 4 12 3))))))
     ((use (memmove-s3-s5))
      (disable memmove-s3p memmove-s5p sub-neg)))

(prove-lemma memmove-s3-sn-mem-base-3 (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (equal (sub1 nt) 0)
		     (lessp n 4)
		     (not (zerop n))		
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (memmove-s3-s5))
      (disable memmove-s3p memmove-s5p sub-neg)))     

; put together: s3 --> sn.
(defn memmove-s3-sn-t (i* i str1 n lst1 str2 lst2 nt n_)
  (if (equal (sub1 nt) 0)
      (if (lessp n 4)
          (if (zerop n) 
	      13 
	    (memmove-s3-sn-t1 i* i str1 n lst1 str2 lst2 nt n_))
	(memmove-s3-sn-t0 i* i str1 n lst1 str2 lst2 nt n_))
    (splus 3 (memmove-s3-sn-t (sub 32 1 i*) (sub1 i) str1 n
			      (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1)
			      str2 lst2 (sub1 nt) n_))))
	   
(prove-lemma memmove-s3p-info (rewrite)
     (implies (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
              (and (numberp nt) (not (equal nt 0)))))

(prove-lemma memmove-s3-sn (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ 
			      (memmove-3 lst1 lst2 i nt n))
                     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s3p memmove-s3-sn-t0 memmove-s3-sn-t1 read-dn 
	       memmove-4 sub-neg)))

(prove-lemma memmove-s3-sn-rfile (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (d2-7a2-5p rn)
                     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		       (if (d5-7a2-5p rn)
			   (read-rn oplen rn (mc-rfile s))
			 (get-vlst oplen 0 rn '(2 3 4)
				   (movem-saved s 4 12 3))))))
     ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s3p memmove-s3-sn-t0 memmove-s3-sn-t1 sub-neg)))

(prove-lemma memmove-s3-sn-mem (rewrite)
     (let ((sn (stepn s (memmove-s3-sn-t i* i str1 n lst1 str2 lst2 nt n_))))
       (implies (and (memmove-s3p s i* i str1 n lst1 str2 lst2 nt n_)
		     (disjoint x k (sub 32 12 (read-an 32 6 s)) 32)
		     (disjoint x k str1 n_))
		(equal (read-mem x (mc-mem sn) k)
		       (read-mem x (mc-mem s) k))))
     ((induct (memmove-s5-sn-induct s i* i lst1 lst2 nt))
      (disable memmove-s3p memmove-s3-sn-t0 memmove-s3-sn-t1 sub-neg)))

(disable memmove-s3p-info)

; the correctness of memmove.
(defn memmove-t (str1 n lst1 str2 lst2)
  (if (zerop n)
      11
    (let ((x1 (nat-to-uint str1))
	  (x2 (nat-to-uint str2)))
      (if (equal x1 x2)
	  13
	(if (lessp x1 x2)
	    (if (and (equal (remainder x1 4) 0)
		     (equal (remainder x2 4) 0))
		(if (lessp n 4)
		    (splus 22 (memmove-s2-sn-t 0 0 str1 n lst1 str2 lst2 n n))
		  (splus 19 (memmove-s1-sn-t 0 0 str1 n lst1 str2 lst2 
					     (quotient n 4) n)))
	      (if (equal (remainder x1 4) (remainder x2 4))
		  (if (lessp 3 n)
		      (splus 29 (memmove-s0-sn-t 
				 0 0 str1 
				 (difference (plus n (remainder x1 4)) 4)
				 lst1 str2 lst2 
				 (difference 4 (remainder x1 4)) n))
		    (splus 27 (memmove-s0-sn-t 0 0 str1 0 lst1 str2 lst2 n n)))
		(splus 24 (memmove-s0-sn-t 0 0 str1 0 lst1 str2 lst2 n n))))
	  (let ((y1 (plus n x1))
		(y2 (plus n x2)))
	    (if (and (equal (remainder y1 4) 0)
		     (equal (remainder y2 4) 0))
		(if (lessp n 4)
		    (splus 24 (memmove-s5-sn-t (uint-to-nat n) n str1 n lst1
					       str2 lst2 n n))
		  (splus 21 (memmove-s4-sn-t (uint-to-nat n) n str1 n lst1
					     str2 lst2 (quotient n 4) n)))
	      (if (equal (remainder y1 4) (remainder y2 4))
		  (if (lessp 4 n)
		      (splus 29 (memmove-s3-sn-t 
				 (uint-to-nat n) n str1 
				 (difference n (remainder y1 4))
				 lst1 str2 lst2 (remainder y1 4) n))
		    (splus 29 (memmove-s3-sn-t (uint-to-nat n) n str1 0 lst1
					       str2 lst2 n n)))
		(splus 26 (memmove-s3-sn-t (uint-to-nat n) n str1 0 lst1 str2
					   lst2 n n))))))))))

(prove-lemma memmove-correctness (rewrite)
     (let ((sn (stepn s (memmove-t str1 n lst1 str2 lst2))))
       (implies (memmove-statep s str1 n lst1 str2 lst2)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (rts-addr s))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (read-rn 32 14 (mc-rfile s)))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-sp s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (and (disjoint x k (sub 32 16 (read-sp s)) 32)
				   (disjoint x k str1 n))
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))     
                     (equal (read-dn 32 0 sn) str1)
                     (mem-lst 1 str1 (mc-mem sn) n 
                              (memmove str1 str2 n lst1 lst2)))))
     ((disable memmove-statep memmove-s0p memmove-s1p memmove-s2p
               memmove-s3p memmove-s4p memmove-s5p memmove-s2-sn-t
               memmove-s1-sn-t memmove-s0-sn-t memmove-s5-sn-t
               memmove-s4-sn-t memmove-s3-sn-t memmove-0 memmove-1
	       memmove-3 memmove-4 read-dn rts-addr linked-rts-addr 
	       linked-a6 remainder plus)))

(disable memmove-t)

; some properties of memmove.
; see file cstring.events.

(make-lib "memmove" t)
