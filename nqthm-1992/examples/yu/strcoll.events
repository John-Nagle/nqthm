#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "strcmp" t)

;          Proof of the Correctness of the STRCOLL Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strcoll function in the Berkeley string library.

/*
 * Compare strings according to LC_COLLATE category of current locale.
 */
strcoll(s1, s2)
        const char *s1, *s2;
{
        /* LC_COLLATE is unimplemented, hence always "C" */
        return (strcmp(s1, s2));
}

The MC68020 assembly code of the C function strcoll on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2388 <strcoll>:       linkw fp,#0
0x238c <strcoll+4>:     movel fp@(12),sp@-
0x2390 <strcoll+8>:     movel fp@(8),sp@-
0x2394 <strcoll+12>:    jsr @#0x2358 <strcmp>
0x239a <strcoll+18>:    unlk fp
0x239c <strcoll+20>:    rts

The machine code of the above program is:

<strcoll>:    0x4e56  0x0000  0x2f2e  0x000c  0x2f2e  0x0008  0x4eb9  0x0000
<strcoll+16>: 0x2358  0x4e5e  0x4e75

'(78     86      0       0       47      46      0       12
  47     46      0       8       78      185     0       0
  35     88      78      94      78      117)
|#

; in the logic, the above program is defined by (strcoll-code).
(defn strcoll-code ()
  '(78     86      0       0       47      46      0       12
    47     46      0       8       78      185     -1      -1
    -1     -1      78      94      78      117))

(constrain strcoll-load (rewrite)
   (equal (strcoll-loadp s)
	  (and (evenp (strcoll-addr))
	       (numberp (strcoll-addr))
	       (nat-rangep (strcoll-addr) 32)
	       (rom-addrp (strcoll-addr) (mc-mem s) 22)
	       (mcode-addrp (strcoll-addr) (mc-mem s) (strcoll-code))
	       (strcmp-loadp s)
	       (equal (pc-read-mem (add 32 (strcoll-addr) 14) (mc-mem s) 4)
                      (strcmp-addr))))
   ((strcoll-loadp (lambda (s) f))
    (strcoll-addr (lambda () 1))))

(prove-lemma stepn-strcoll-loadp (rewrite)
     (equal (strcoll-loadp (stepn s n))
	    (strcoll-loadp s)))

; the computation time of the program.
(defn strcoll-t (n1 lst1 lst2)
  (splus 4 (splus (strcmp-t n1 lst1 lst2) 2)))

; the preconditions of the initial state.
(defn strcoll-statep (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strcoll-loadp s)
       (equal (mc-pc s) (strcoll-addr))
       (ram-addrp (sub 32 24 (read-sp s)) (mc-mem s) 36)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 24 (read-sp s)) 36 str1 n1)
       (disjoint (sub 32 24 (read-sp s)) 36 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (stringp 0 n1 lst1)
       (leq n1 n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n2 32)))

; the intermediate state right before the execution of the subroutine strcmp.
(defn strcoll-s0p (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strcoll-loadp s)
       (equal (mc-pc s) (strcmp-addr))
       (equal (rts-addr s) (add 32 (strcoll-addr) 18))
       (ram-addrp (sub 32 20 (read-an 32 6 s)) (mc-mem s) 36)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 20 (read-an 32 6 s)) 36 str1 n1)
       (disjoint (sub 32 20 (read-an 32 6 s)) 36 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal* (read-sp s) (sub 32 12 (read-an 32 6 s)))
       (stringp 0 n1 lst1)
       (leq n1 n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n2 32)))

; the intermediate state right after the execution of the subroutine strcmp.
(defn strcoll-s1p (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strcoll-loadp s)
       (equal (mc-pc s) (add 32 (strcoll-addr) 18))
       (ram-addrp (sub 32 20 (read-an 32 6 s)) (mc-mem s) 36)
       (equal (iread-dn 32 0 s) (strcmp 0 n1 lst1 lst2))))

; from the initial state s to s0: s --> s0.
(prove-lemma strcoll-s-s0 ()
     (implies (strcoll-statep s str1 n1 lst1 str2 n2 lst2)
              (strcoll-s0p (stepn s 4) str1 n1 lst1 str2 n2 lst2)))

(prove-lemma strcoll-s-s0-else (rewrite)
     (implies (strcoll-statep s str1 n1 lst1 str2 n2 lst2)
	      (and (equal (linked-rts-addr (stepn s 4)) (rts-addr s))
                   (equal (linked-a6 (stepn s 4)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 4)))
                          (sub 32 4 (read-sp s))))))

(prove-lemma strcoll-s-s0-rfile (rewrite)
     (implies (and (strcoll-statep s str1 n1 lst1 str2 n2 lst2)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcoll-s-s0-mem (rewrite)
     (implies (and (strcoll-statep s str1 n1 lst1 str2 n2 lst2)	     
		   (disjoint x k (sub 32 24 (read-sp s)) 36))
	      (equal (read-mem x (mc-mem (stepn s 4)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s1: s0 --> s1. by strcmp.
(prove-lemma strcoll-s0p-strcmp-statep ()
     (implies (strcoll-s0p s str1 n1 lst1 str2 n2 lst2)
	      (strcmp-statep s str1 n1 lst1 str2 n2 lst2)))

(prove-lemma strcoll-s0-s1 ()
     (let ((s1 (stepn s (strcmp-t n1 lst1 lst2))))
       (implies (strcoll-s0p s str1 n1 lst1 str2 n2 lst2)
		(strcoll-s1p s1 str1 n1 lst1 str2 n2 lst2)))
     ((use (strcoll-s0p-strcmp-statep))
      (disable strcmp-statep strcmp-load)))

(prove-lemma strcoll-s0-s1-else (rewrite)
     (let ((s1 (stepn s (strcmp-t n1 lst1 lst2))))
       (implies (strcoll-s0p s str1 n1 lst1 str2 n2 lst2)
		(and (equal (read-rn 32 14 (mc-rfile s1))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-rts-addr s1) (linked-rts-addr s))
		     (equal (linked-a6 s1) (linked-a6 s)))))
     ((use (strcoll-s0p-strcmp-statep))
      (disable strcmp-statep)))

(prove-lemma strcoll-s0-s1-rfile (rewrite)
     (let ((s1 (stepn s (strcmp-t n1 lst1 lst2))))
       (implies (and (strcoll-s0p s str1 n1 lst1 str2 n2 lst2)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile s1))
		       (read-rn oplen rn (mc-rfile s)))))
     ((use (strcoll-s0p-strcmp-statep))
      (disable strcmp-statep)))

(prove-lemma strcoll-s0-s1-mem (rewrite)
     (let ((s1 (stepn s (strcmp-t n1 lst1 lst2))))
       (implies (and (strcoll-s0p s str1 n1 lst1 str2 n2 lst2)
		     (disjoint x k (sub 32 20 (read-an 32 6 s)) 36))
		(equal (read-mem x (mc-mem s1) k)
		       (read-mem x (mc-mem s) k))))
     ((use (strcoll-s0p-strcmp-statep))
      (disable strcmp-statep)))

; from s1 to exit: s1 --> sn.
(prove-lemma strcoll-s1-sn (rewrite)
     (implies (strcoll-s1p s str1 n1 lst1 str2 n2 lst2)
	      (and (equal (mc-status (stepn s 2)) 'running)
		   (equal (mc-pc (stepn s 2)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 2)) 
			  (strcmp 0 n1 lst1 lst2))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 2)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 2)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 2)) k)
			  (read-mem x (mc-mem s) k)))))
		   
(prove-lemma strcoll-s1-sn-rfile (rewrite)
     (implies (and (strcoll-s1p s str1 n1 lst1 str2 n2 lst2)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 2)))
		     (read-rn oplen rn (mc-rfile s)))))

; the correctness of strcoll.
(prove-lemma strcoll-correctness (rewrite)
     (let ((sn (stepn s (strcoll-t n1 lst1 lst2))))
       (implies (strcoll-statep s str1 n1 lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 7 s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 24 (read-sp s)) 36)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (iread-dn 32 0 sn) (strcoll n1 lst1 lst2)))))
     ((use (strcoll-s-s0) (strcoll-s0-s1 (s (stepn s 4))))
      (disable strcoll-statep strcoll-s0p strcoll-s1p)))

(disable strcoll-t)

; some properties of strcoll.
; the same as strcmp. 