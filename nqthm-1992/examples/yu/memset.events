#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the MEMSET Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of memset function in the Berkeley string library.

void *
memset(dst, c, n)
        void *dst;
        register int c;
        register size_t n;
{

        if (n != 0) {
                register char *d = dst;

                do
                        *d++ = c;
                while (--n != 0);
        }
        return (dst);
}

The MC68020 assembly code of the C function memset on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x29d0 <memset>:        linkw fp,#0
0x29d4 <memset+4>:      movel d2,sp@-
0x29d6 <memset+6>:      movel fp@(8),d2
0x29da <memset+10>:     movel fp@(16),d0
0x29de <memset+14>:     beq 0x29ec <memset+28>
0x29e0 <memset+16>:     moveal d2,a0
0x29e2 <memset+18>:     moveb fp@(15),d1
0x29e6 <memset+22>:     moveb d1,a0@+
0x29e8 <memset+24>:     subl #1,d0
0x29ea <memset+26>:     bne 0x29e6 <memset+22>
0x29ec <memset+28>:     movel d2,d0
0x29ee <memset+30>:     movel fp@(-4),d2
0x29f2 <memset+34>:     unlk fp
0x29f4 <memset+36>:     rts

The machine code of the above program is:

<memset>:     0x4e56  0x0000  0x2f02  0x242e  0x0008  0x202e  0x0010  0x670c
<memset+16>:  0x2042  0x122e  0x000f  0x10c1  0x5380  0x66fa  0x2002  0x242e
<memset+32>:  0xfffc  0x4e5e  0x4e75

'(78    86      0       0       47      2       36      46
  0     8       32      46      0       16      103     12
  32    66      18      46      0       15      16      193
  83    128     102     250     32      2       36      46
  255   252     78      94      78      117)
|#
; in the logic, the above program is defined by (memset-code).
(defn memset-code ()
  '(78    86      0       0       47      2       36      46
    0     8       32      46      0       16      103     12
    32    66      18      46      0       15      16      193
    83    128     102     250     32      2       36      46
    255   252     78      94      78      117))

; the computation time of the program.
(defn memset-t1 (n)
  (if (equal (sub1 n) 0)
      7
    (splus 3 (memset-t1 (sub1 n)))))

(defn memset-t (n)
  (if (equal n 0)
      9
    (splus 7 (memset-t1 n))))

; an induction hint.
(defn memset-induct (s i* i n lst ch)
  (if (equal (sub1 n) 0)
      t
    (memset-induct (stepn s 3) (add 32 i* 1) (add1 i) (sub1 n)
		   (put-nth ch i lst) ch)))

; the preconditions of the initial state.
(defn memset-statep (s str n lst ch)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 38)
       (mcode-addrp (mc-pc s) (mc-mem s) (memset-code))
       (ram-addrp (sub 32 8 (read-sp s)) (mc-mem s) 24)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint (sub 32 8 (read-sp s)) 24 str n)
       (equal str (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal ch (uread-mem (add 32 (read-sp s) 11) (mc-mem s) 1))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))))

; an intermediate state.
(defn memset-s0p (s i* i str n lst ch n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 22 (mc-pc s)) (mc-mem s) 38)
       (mcode-addrp (sub 32 22 (mc-pc s)) (mc-mem s) (memset-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str (mc-mem s) n_)
       (mem-lst 1 str (mc-mem s) n_ lst)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str n_)
       (equal* (read-an 32 0 s) (add 32 str i*))
       (equal str (read-dn 32 2 s))
       (equal ch (nat-to-uint (read-dn 8 1 s)))
       (equal i (nat-to-uint i*))
       (equal n (nat-to-uint (read-dn 32 0 s)))
       (leq (plus i n) n_)
       (not (equal n 0))
       (numberp i*)
       (numberp n_)
       (nat-rangep i* 32)
       (uint-rangep n_ 32)))

; from the intial state s to exit: s --> sn.
(prove-lemma memset-s-sn (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (equal n 0))
	      (and (equal (mc-status (stepn s 9)) 'running)
		   (equal (mc-pc (stepn s 9)) (rts-addr s))
		   (equal (read-dn 32 0 (stepn s 9)) str)
		   (mem-lst 1 str (mc-mem (stepn s 9)) n lst)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 9)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 9))) 
			  (read-an 32 6 s)))))

(prove-lemma memset-s-sn-rfile (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (equal n 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memset-s-sn-mem (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (equal n 0)
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 9)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state s to s0: s --> s0.
(prove-lemma memset-s-s0 ()
     (implies (and (memset-statep s str n lst ch)
		   (not (equal n 0)))
	      (memset-s0p (stepn s 7) 0 0 str n lst ch n)))

(prove-lemma memset-s-s0-else (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (not (equal n 0)))
	      (and (equal (linked-rts-addr (stepn s 7)) (rts-addr s))
		   (equal (linked-a6 (stepn s 7)) (read-an 32 6 s))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (sub 32 4 (read-sp s)))
		   (equal (rn-saved (stepn s 7)) 
			  (read-rn 32 2 (mc-rfile s))))))

(prove-lemma memset-s-s0-rfile (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (not (equal n 0))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memset-s-s0-mem (rewrite)
     (implies (and (memset-statep s str n lst ch)
		   (not (equal n 0))
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to exit (base case), from s0 to s0 (induction case).
; base case: s0 --> exit.
(prove-lemma memset-s0-sn-base (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (equal (sub1 n) 0))
	      (and (equal (mc-status (stepn s 7)) 'running)
		   (equal (mc-pc (stepn s 7)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) str)
		   (mem-lst 1 str (mc-mem (stepn s 7)) n_ (put-nth ch i lst))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7))) 
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
			  (add 32 (read-an 32 6 s) 8)))))

(prove-lemma memset-s0-sn-rfile-base (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (equal (sub1 n) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen)))))

(prove-lemma memset-s0-sn-mem-base (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (equal (sub1 n) 0)
		   (disjoint x k str n_))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; induction case: s0 --> s0.
(prove-lemma memset-s0-s0 (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (not (equal (sub1 n) 0)))
	      (and (memset-s0p (stepn s 3) (add 32 i* 1) (add1 i) str (sub1 n)
			       (put-nth ch i lst) ch n_)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 3)) (linked-rts-addr s))
		   (equal (rn-saved (stepn s 3)) (rn-saved s)))))

(prove-lemma memset-s0-s0-rfile (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (not (equal (sub1 n) 0))
		   (d3-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memset-s0-s0-mem (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (not (equal (sub1 n) 0))
		   (disjoint x k str n_))
	      (equal (read-mem x (mc-mem (stepn s 3)) k)
		     (read-mem x (mc-mem s) k))))

; put together (s0 --> exit).
(prove-lemma memset-s0-sn (rewrite)
     (let ((sn (stepn s (memset-t1 n))))
       (implies (memset-s0p s i* i str n lst ch n_)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) str)
		     (mem-lst 1 str (mc-mem sn) n_ (memset1 i n lst ch))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (memset-induct s i* i n lst ch))
      (disable memset-s0p read-dn)))

(prove-lemma memset-s0-sn-rfile (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (memset-t1 n))))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen))))
     ((induct (memset-induct s i* i n lst ch))
      (disable memset-s0p)))

(prove-lemma memset-s0-sn-mem (rewrite)
     (implies (and (memset-s0p s i* i str n lst ch n_)
		   (disjoint x k str n_))
	      (equal (read-mem x (mc-mem (stepn s (memset-t1 n))) k)
		     (read-mem x (mc-mem s) k)))
     ((induct (memset-induct s i* i n lst ch))
      (disable memset-s0p)))

; the correctness of the MEMSET program.
(prove-lemma memset-correctness (rewrite)
     (let ((sn (stepn s (memset-t n))))
       (implies (memset-statep s str n lst ch)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (and (leq oplen 32)
				   (d2-7a2-5p rn))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (and (disjoint x k (sub 32 8 (read-sp s)) 24)
				   (disjoint x k str n))
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn) str)
		     (mem-lst 1 str (mc-mem sn) n (memset n lst ch)))))
     ((use (memset-s-s0))
      (disable memset-statep memset-s0p rts-addr linked-rts-addr linked-a6
	       read-dn)))

(disable memset-t)

; some properties of memset.
; see file cstring.events.
