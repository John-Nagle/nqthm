#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

; ---------------------------------------------------------------------------
; Date:      Jan, 1991
; Modified:  Sep 4, 1992.
; File:      mc20-2.events
; ---------------------------------------------------------------------------
;
;-------------------------------------------------------------------------
;                       PROVING PHASE
;
; we establish basic theory for program proving based upon our MC68020 
; specification.
;-------------------------------------------------------------------------
;
; load and compile the spec.
(note-lib "mc20-1" t)
(compile-uncompiled-defns "tmp")

; a segment of the memory is ROM, iff it is pc-readable(read-only).
(defn rom-addrp (addr mem n)
  (pc-read-memp addr mem n))

; a segment of the memory is RAM, iff it is writable(random).
(defn ram-addrp (addr mem n)
  (write-memp addr mem n))

; x is an element of lst wrt numberp.
(defn n-member (x lst)
  (if (nlistp lst)
      f
    (or (equal (fix x) (fix (car lst)))
        (n-member x (cdr lst)))))

; mod-eq returns t iff x and y are the "same" bit-vector.  It is often 
; used as an induction hint to many lemmas.
(defn mod-eq (n x y)
  (if (zerop n)
      t
    (and (equal (bcar x) (bcar y))
         (mod-eq (sub1 n) (bcdr x) (bcdr y)))))

; mod32-eq is equivalent to mod-eq with n = 32. But we define it as follows.
(defn mod32-eq (x y)
  (equal (head x 32) (head y 32)))

; the equivalence is given by this lemma.
; (prove-lemma mod-eq-lemma (rewrite)
;      (equal (mod-eq 32 x y)
;             (mod32-eq x y)))

; the negation of a bit-vector.
(defn neg (n x)
  (sub n x 0))

; {x, x+1, ..., x+(m-1)} and {y} are disjoint.  We assume all the numbers are
; modulo 2^32.
(defn disjoint0 (x m y)
  (if (zerop m)
      t
    (and (not (mod32-eq (add 32 x (sub1 m)) y))
         (disjoint0 x (sub1 m) y))))

; {x, x+1, ..., x+(m-1)} and {y, y+1, ..., y+(n-1)} are disjoint.
(defn disjoint (x m y n)
  (if (zerop n)
      t
    (and (disjoint0 x m (add 32 y (sub1 n)))
         (disjoint x m y (sub1 n)))))

;                 BIT VECTOR AS LIST OF BIT
; A lower level layer.  This is part of my old spec that specifies the 
; microprocessor at a relatively lower level. 
(defn bit (bv)
  (if (nlistp bv) (b0) (if (b0p (car bv)) (b0) (b1))))

(defn vec (bv)
  (if (nlistp bv) nil (cdr bv)))

(defn fix-bv (bv)
  (if (nlistp bv)
      nil
    (cons (bit bv) (fix-bv (vec bv)))))

(defn bv-len (bv)
  (if (nlistp bv)
      0
    (add1 (bv-len (vec bv)))))

(defn bv-not (bv)
  (if (nlistp bv)
      nil
    (cons (b-not (bit bv)) (bv-not (vec bv)))))

(defn bv-head (bv n)
  (if (zerop n)
      nil
    (cons (bit bv) (bv-head (vec bv) (sub1 n)))))

(defn bv-tail (bv n)
  (if (zerop n)
      (fix-bv bv)
    (bv-tail (vec bv) (sub1 n))))

(defn bv-bitn (bv n)
  (if (zerop n)
      (bit bv)
    (bv-bitn (vec bv) (sub1 n))))

(defn bv-mbit (bv)
  (if (nlistp bv)
      (b0)
    (if (nlistp (vec bv))
        (bit bv)
      (bv-mbit (vec bv)))))

(defn bv-adder (c x y)
  (if (nlistp x) 
      nil
    (cons (b-eor (b-eor (bit x) (bit y)) c)
          (bv-adder (b-or (b-and (bit x) (bit y))
                          (b-or (b-and (bit x) c) (b-and (bit y) c)))
                    (vec x)
                    (vec y)))))

; conversion functions.
(defn bv-to-nat (bv)
  (if (nlistp bv)
      0
    (plus (bit bv) (times 2 (bv-to-nat (vec bv))))))

(defn bv-sized-to-nat (bv size)
  (if (zerop size)
      0
    (plus (bit bv) (times 2 (bv-sized-to-nat (vec bv) (sub1 size))))))

(defn nat-to-bv (n)
  (if (zerop n)
      nil
    (cons (remainder n 2) (nat-to-bv (quotient n 2)))))

(defn nat-to-bv-sized (n size)
  (if (zerop size)
      nil
    (cons (remainder n 2) (nat-to-bv-sized (quotient n 2) (sub1 size)))))

;               LISTP 
(prove-lemma bv-len-listp (rewrite)
     (equal (equal (bv-len x) 0) (nlistp x)))

(prove-lemma bv-head-listp (rewrite)
     (equal (listp (bv-head x n)) (not (zerop n)))
     ((expand (bv-head x 1))))     

(prove-lemma bv-adder-listp (rewrite)
     (equal (listp (bv-adder c x y)) (listp x)))

;               BV-LEN
(prove-lemma bv-head-len (rewrite)
     (equal (bv-len (bv-head x n)) (fix n)))

(prove-lemma nat-to-bv-sized-len (rewrite)
     (equal (bv-len (nat-to-bv-sized x n)) (fix n)))

(prove-lemma bv-adder-len (rewrite)
     (equal (bv-len (bv-adder c x y)) (bv-len x)))

;                 CONVERSION THEOREMS
; nat-to-bv-sized only considers the first k binary digits of natural number n.
(prove-lemma nat-to-bv-sized-la0 (rewrite)
     (equal (nat-to-bv-sized (remainder n (exp 2 k)) k)
            (nat-to-bv-sized n k)))

; rewrite nat-to-bv-sized into nat-to-bv.
(prove-lemma nat-to-bv-sized-head (rewrite)
     (equal (nat-to-bv-sized m n)
            (bv-head (nat-to-bv m) n)))

; rewrite bv-sized-to-nat into bv-to-nat.
(prove-lemma bv-sized-to-nat-head (rewrite)
     (equal (bv-sized-to-nat x n)
            (bv-to-nat (bv-head x n))))

(prove-lemma bv-to-nat-to-bv (rewrite)
     (equal (bv-head (nat-to-bv (bv-to-nat x)) n)
            (bv-head x n))
     ((disable plus-add1)))

(prove-lemma nat-to-bv-to-nat (rewrite)
     (equal (bv-to-nat (nat-to-bv n)) (fix n)))

(prove-lemma bv-head-nat (rewrite)
     (equal (bv-to-nat (bv-head x n)) 
            (if (lessp (bv-to-nat x) (exp 2 n))
                (bv-to-nat x)
              (remainder (bv-to-nat x) (exp 2 n)))))

(prove-lemma bv-to-nat-to-bv-sized (rewrite)
     (equal (nat-to-bv-sized (bv-to-nat x) n)
            (bv-head x n)))

(prove-lemma nat-to-bv-sized-to-nat (rewrite)
     (equal (bv-to-nat (nat-to-bv-sized m n))
            (if (lessp m (exp 2 n))
                (fix m)
              (remainder m (exp 2 n)))))

(prove-lemma bv-sized-to-nat-to-bv-sized (rewrite)
     (equal (nat-to-bv-sized (bv-sized-to-nat x n) n)
            (bv-head x n)))

(prove-lemma nat-to-bv-sized-sized-to-nat (rewrite)
     (equal (bv-sized-to-nat (nat-to-bv-sized m n) n)
            (if (lessp m (exp 2 n))
                (fix m)
              (remainder m (exp 2 n)))))

(disable bv-sized-to-nat-head)
(disable nat-to-bv-sized-head)

;            BV-BITN and BV-NOT
(prove-lemma bv-bitn-not (rewrite)
     (equal (bv-bitn (bv-not x) i)
            (if (lessp i (bv-len x))
                (b-not (bv-bitn x i))
              (b0))))

(prove-lemma bv-to-nat-rangep (rewrite)
     (nat-rangep (bv-to-nat x) (bv-len x)))

;            BV-ADDER
; a bridge function.
(defn bv-adder&carry (c x y)
  (if (nlistp x) 
      (cons (fix-bit c) nil)
    (cons (b-eor c (b-eor (bit x) (bit y)))
          (bv-adder&carry (b-or (b-and (bit x) (bit y))
                                 (b-or (b-and (bit x) c) (b-and (bit y) c)))
                          (vec x)
                          (vec y)))))

(prove-lemma bv-adder&carry-len (rewrite)
     (equal (bv-len (bv-adder&carry c x y)) (add1 (bv-len x))))

(prove-lemma fix-bv-adder&carry (rewrite)
     (equal (fix-bv (bv-adder&carry c x y)) 
            (bv-adder&carry c x y)))

; the relation between bv-adder&carry and bv-adder.  We have successfully 
; constructed the bridge!
(prove-lemma bv-adder-bridge (rewrite)
     (equal (bv-adder c x y)
            (bv-head (bv-adder&carry c x y) (bv-len x))))

;                  lifting lemmas
(prove-lemma bv-not-lognot (rewrite)
     (equal (bv-to-nat (bv-not x))
            (lognot (bv-len x) (bv-to-nat x)))
     ((disable remainder quotient)))

(prove-lemma bv-bitn-bitn (rewrite)
     (equal (bv-bitn x n)
            (bitn (bv-to-nat x) n))
     ((disable remainder quotient)))

(prove-lemma bv-mbit-bitn (rewrite)
     (equal (bv-mbit x)
            (if (equal (bv-len x) 0)
                0
              (bitn (bv-to-nat x) (sub1 (bv-len x)))))
     ((disable remainder quotient)))

(prove-lemma bv-adder&carry-nat (rewrite)
     (implies (equal (bv-len x) (bv-len y))
              (equal (bv-to-nat (bv-adder&carry c x y))
                     (plus (fix-bit c) (bv-to-nat x) (bv-to-nat y)))))

(prove-lemma bv-adder-nat (rewrite)
     (implies (and (equal (bv-len x) (bv-len y))
                   (bitp c))
              (equal (bv-to-nat (bv-adder c x y))
                     (adder (bv-len x) c (bv-to-nat x) (bv-to-nat y))))
     ((disable remainder)))

;                    EVENP
; add-evenp states that the sum of two even numbers is still even.
(prove-lemma add-evenp (rewrite)
     (implies (and (evenp x) (evenp y))
              (evenp (add n x y))))

(disable evenp)

;                     LOGNOT
(prove-lemma lognot-0 (rewrite)
     (implies (not (numberp x))
              (and (equal (lognot x y) (lognot 0 y))
                   (equal (lognot y x) (lognot y 0)))))

(prove-lemma lognot-nat-rangep (rewrite)
     (nat-rangep (lognot n x) n))

(prove-lemma lognot-lognot (rewrite)
     (equal (lognot n (lognot n x))
            (head x n)))

(prove-lemma lognot-cancel (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (equal (lognot n x) (lognot n y))
                     (equal (fix x) (fix y)))))

; the integer interpretation of lognot.
(prove-lemma lognot-int (rewrite)
     (implies (and (nat-rangep x n)
                   (not (zerop n)))
              (equal (nat-to-int (lognot n x) n)
                     (iplus -1 (ineg (nat-to-int x n))))))

(prove-lemma adder-lognot (rewrite)
     (implies (bitp c)
              (equal (lognot n (adder n c x y))
                     (adder n (b-not c) (lognot n x) (lognot n y))))
     ((disable plus difference)))

(disable lognot)

;               BASICS ABOUT HEAD & TAIL
(prove-lemma head-0 (rewrite)
     (equal (head 0 n) 0))

(prove-lemma tail-0 (rewrite)
     (equal (tail 0 n) 0))

(prove-lemma head-of-0 (rewrite)
     (equal (head x 0) 0))

(prove-lemma tail-of-0 (rewrite)
     (equal (tail x 0) (fix x)))

(prove-lemma head-lessp (rewrite)
     (lessp (head x n) (exp 2 n)))

(prove-lemma tail-lessp (rewrite)
     (equal (lessp (tail x n) y)
            (lessp x (times (exp 2 n) y))))

(prove-lemma head-leq (rewrite)
     (not (lessp x (head x n))))

(prove-lemma tail-leq (rewrite)
     (not (lessp x (tail x n))))

(prove-lemma tail-equal-0 (rewrite)
     (equal (equal (tail x n) 0)
            (nat-rangep x n)))

(prove-lemma head-lemma (rewrite)
     (implies (nat-rangep x n)
              (equal (head x n) (fix x))))

(prove-lemma tail-lemma (rewrite)
     (implies (nat-rangep x n)
              (equal (tail x n) 0)))

(prove-lemma replace-0 (rewrite)
     (and (equal (replace 0 x y) (fix y))
          (equal (replace n x 0) (head x n))
          (implies (and (nat-rangep x n)
                        (nat-rangep y n))
                   (equal (replace n x y) (fix x)))))

(prove-lemma app-0 (rewrite)
     (and (equal (app n x 0) (head x n))
          (equal (app n 0 y) (times y (exp 2 n)))
          (equal (app 0 x y) (fix y))))

;                THEOREMS ABOUT SHIFT AND ROTATE
; the key events are LSL-UINT, LSR-UINT, ASL-INT, and ASR-INT.
; ASL-INT and ASR-INT are pretty hard.  It took me a few days to get the
; proofs.  It would be a good challenge to other provers.
(prove-lemma lsl-uint (rewrite)
     (implies (uint-rangep x (difference n cnt))
              (equal (nat-to-uint (lsl n x cnt))
                     (times (nat-to-uint x) (exp 2 cnt)))))

(prove-lemma lsr-uint (rewrite)
     (equal (nat-to-uint (lsr x cnt))
            (quotient (nat-to-uint x) (exp 2 cnt))))

; two lemmas for asl-int.
(prove-lemma remainder-diff-la ()
     (implies (and (equal (remainder x z) 0)
                   (lessp y z))
              (equal (remainder (difference x y) z)
                     (if (leq x y) 
                         0
                       (if (zerop y) 0 (difference z y)))))
     ((use (remainder-plus2 (i (difference x z)) (x (difference z y)) (j z)))))

(prove-lemma asl-int-crock1 (rewrite)
     (implies (lessp x (exp 2 (sub1 (difference n s))))
              (equal (head (times x (exp 2 s)) n)
                     (times x (exp 2 s)))))

(prove-lemma asl-int-crock2 (rewrite)
     (implies (and (leq (times (exp 2 s) (difference (exp 2 n) x))
                        (exp 2 (sub1 n)))
                   (lessp x (exp 2 n)))
              (equal (head (times x (exp 2 s)) n)
                     (difference (exp 2 n) 
                                 (times (exp 2 s) 
                                        (difference (exp 2 n) x)))))
     ((use (remainder-diff-la (x (times (exp 2 n) (exp 2 s)))
                              (y (difference (times (exp 2 n) (exp 2 s))
                                             (times x (exp 2 s))))
                              (z (exp 2 n))))
      (disable exp-plus)))

(prove-lemma asl-int (rewrite)
     (implies (and (nat-rangep x n)
                   (int-rangep (nat-to-int x n) (difference n s)))
              (equal (nat-to-int (asl n x s) n)
                     (itimes (nat-to-int x n) (exp 2 s))))
     ((disable head)))

(disable asl-int-crock1)
(disable asl-int-crock2)

(prove-lemma quotient-diff-la ()
     (implies (and (equal (remainder x z) 0)
                   (lessp y z))
              (equal (quotient (difference x y) z)
                     (if (zerop y) (quotient x z) (sub1 (quotient x z)))))
     ((use (quotient-plus2 (i (difference x z)) (x (difference z y)) (j z)))))

(prove-lemma remainder-diff (rewrite)
     (implies (equal (remainder x z) 0)
              (equal (remainder (difference x y) z)
                     (if (or (leq x y) (equal (remainder y z) 0))
                           0
                         (difference z (remainder y z)))))
     ((use (remainder-diff-la (x (difference x (times z (quotient y z))))
                              (y (remainder y z))))))

(prove-lemma quotient-diff (rewrite)
     (implies (equal (remainder x z) 0)
              (equal (quotient (difference x y) z)
                     (if (equal (remainder y z) 0)
                         (difference (quotient x z) (quotient y z))
                       (sub1 (difference (quotient x z) (quotient y z))))))
     ((use (quotient-diff-la (x (difference x (times z (quotient y z))))
                             (y (remainder y z))))))

(prove-lemma quotient-exp-lessp (rewrite) 
     (implies (leq cnt n)
              (equal (lessp (quotient x (exp 2 cnt)) 
                            (exp 2 (difference n cnt)))
                     (lessp x (exp 2 n)))))

(prove-lemma lessp-times-exp-1s (rewrite)
     (implies (equal (plus m n) (fix k))
              (equal (lessp (plus x (times (exp 2 m) (sub1 (exp 2 n))))
                            (exp 2 (sub1 k)))
                     (if (zerop n) (lessp x (exp 2 (sub1 (plus m n)))) f)))
     ((induct (plus x y))))

(prove-lemma lessp-app-1s (rewrite)
     (implies (equal (plus m n) (fix k))
              (equal (lessp (app m x (sub1 (exp 2 n))) (exp 2 (sub1 k)))
                     (if (zerop n) 
                         (lessp (head x m) (exp 2 (sub1 (plus m n))))
                       f))))

(prove-lemma times-sub1 (rewrite)
     (equal (times (sub1 y) x)
            (difference (times x y) x))
     ((use (times-distributes-difference (z 1)))))

(prove-lemma difference-app-1s (rewrite)
     (implies (equal (plus m n) (fix k))
              (equal (difference (exp 2 k) (app m x (sub1 (exp 2 n))))
                     (difference (exp 2 m) (head x m)))))

(disable times-sub1)

(prove-lemma asr-int-crock (rewrite)
     (implies (and (lessp x (exp 2 n))
                   (not (lessp x (exp 2 (sub1 n))))
                   (leq cnt n))
              (equal (lessp (app (difference n cnt) 
                                 (quotient x (exp 2 cnt))
                                 (sub1 (exp 2 cnt)))
                            (exp 2 (sub1 n)))
                       f))
     ((disable app)))

(prove-lemma asr-int (rewrite)
     (implies (nat-rangep x n)
              (equal (nat-to-int (asr n x i) n)
                     (if (negativep (nat-to-int x n))
                         (if (equal (iremainder (nat-to-int x n) (exp 2 i)) 0)
                             (iquotient (nat-to-int x n) (exp 2 i))
                           (iplus -1 (iquotient (nat-to-int x n) (exp 2 i))))
                       (iquotient (nat-to-int x n) (exp 2 i)))))
     ((disable app exp quotient-times-lessp)))

(disable asr-int-crock)
(disable quotient-exp-lessp)
(disable remainder-diff)
(disable quotient-diff)

(prove-lemma lsl-0 (rewrite)
     (equal (lsl n x 0) (head x n)))

(prove-lemma lsl-nat-rangep (rewrite)
     (nat-rangep (lsl n x cnt) n))

(prove-lemma lsl-lsl (rewrite)
     (equal (lsl n (lsl n x cnt1) cnt2)
            (lsl n x (plus cnt1 cnt2))))

(prove-lemma lsr-0 (rewrite)
     (equal (lsr x 0) (fix x)))

(prove-lemma lsr-nat-rangep (rewrite)
     (implies (nat-rangep x n)
              (nat-rangep (lsr x cnt) n)))

(prove-lemma lsr-lsr (rewrite)
     (equal (lsr (lsr x cnt1) cnt2)
            (lsr x (plus cnt1 cnt2))))

(prove-lemma asl-0 (rewrite)
     (equal (asl n x 0) (head x n)))

(prove-lemma asl-nat-rangep (rewrite)
     (nat-rangep (asl n x cnt) n))

(prove-lemma asl-asl (rewrite)
     (equal (asl n (asl n x cnt1) cnt2)
            (asl n x (plus cnt1 cnt2))))

(prove-lemma asr-0 (rewrite)
     (implies (nat-rangep x n)
              (equal (asr n x 0) (fix x))))

(prove-lemma asr-nat-rangep (rewrite)
     (implies (nat-rangep x n)
              (nat-rangep (asr n x cnt) n))
     ((use (lessp-plus-times-exp2 (x (quotient x (exp 2 cnt)))
                                  (y (sub1 (exp 2 cnt)))
                                  (i (difference n cnt))))))

; unproved!  Not useful yet.
; (prove-lemma asr-asr (rewrite)
;     (implies (and (nat-rangep x n)
;                   (not (zerop n)))       
;              (equal (asr n (asr n x cnt1) cnt2)
;                     (asr n x (plus cnt1 cnt2)))))

; the integer interpretation of ext.
(prove-lemma mbit-means-lessp (rewrite)
     (implies (nat-rangep x n)
              (equal (bitn x (sub1 n))
                     (if (lessp x (exp 2 (sub1 n))) 0 1))))

(prove-lemma exp2-lessp (rewrite)
     (implies (lessp i j)
              (lessp (exp 2 i) (exp 2 j))))
             
; note that ext-lemma takes care of the other aspects about ext.
(prove-lemma ext-int (rewrite)
     (implies (and (nat-rangep x n)
                   (lessp n size))
              (equal (nat-to-int (ext n x size) size)
                     (nat-to-int x n)))
     ((disable app exp plus)))

(disable exp2-lessp)

;                      INTEGERS!
; functions with a postfix `end' will eventually be disabled.  We use them
; to ``tell'' the prover that something unexpected happens.  They can 
; somehow force the prover to stop proving and print out some information.
(defn adder-int-end (n c x y)
  (nat-to-int (remainder (plus (fix-bit c)
                               (int-to-nat x n) 
                               (int-to-nat y n))
                         (exp 2 n))
              n))

(prove-lemma plus-to-iplus (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (equal (adder-int-end n c x y)
                     (if (int-rangep (iplus x (iplus y (fix-bit c))) n)
                         (iplus x (iplus y (fix-bit c)))
                       (if (negativep x)
                           (iplus x (iplus y (iplus (fix-bit c) (exp 2 n))))
                         (iplus x (iplus y (iplus (fix-bit c) 
                                                  (minus (exp 2 n)))))))))
     ((disable times-distributes-plus-new correctness-of-cancel-lessp-plus)
      (enable times-distributes-plus)))

(disable plus-to-iplus)     

(prove-lemma iplus-with-carry-negativep (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (negativep x)
                   (negativep y))
              (negativep (iplus x (iplus y z)))))

(prove-lemma iplus-with-carry-non-negativep (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (not (negativep x))
                   (not (negativep y)))
              (not (negativep (iplus x (iplus y z))))))

; two lemmas for addx-v.  They will be disabled right after we use them.
(prove-lemma addx-v-crock1 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (int-rangep x n)
                   (int-rangep y n))
              (not (negativep (iplus x (iplus y (iplus z (exp 2 n))))))))

(prove-lemma addx-v-crock2 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (not (zerop n))
                   (int-rangep x n)
                   (int-rangep y n))
              (negativep (iplus x (iplus y (iplus z (minus (exp 2 n))))))))

; two lemmas for BMI of add.  They will be disabled right after we 
; use them.
(prove-lemma add-bmi-crock1 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (not (negativep (iplus x (iplus y (exp 2 n)))))))

(prove-lemma add-bmi-crock2 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (negativep (iplus x (iplus y (minus (exp 2 n)))))))

; two lemmas for BMI of sub.  They will be disabled right after we 
; use them.
(prove-lemma ilessp-crock1 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (not (ilessp (iplus y (exp 2 n)) x))))

(prove-lemma ilessp-crock2 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (ilessp (iplus y (minus (exp 2 n))) x)))

; the addition of two opposite sign integers will never overflow, provided
; the two integers are in "good" range.
(prove-lemma iplus-int-rangep1 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (int-rangep x n)
                   (int-rangep y n)
                   (not (negativep x))
                   (negativep y))
              (int-rangep (iplus x (iplus y z)) n)))

(prove-lemma iplus-int-rangep2 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (bitp z)
                   (int-rangep x n)
                   (int-rangep y n)
                   (negativep x)
                   (not (negativep y)))
              (int-rangep (iplus x (iplus y z)) n)))

(prove-lemma idifference-int-rangep1 (rewrite)
     (implies (and (int-rangep x n)
                   (int-rangep y n)
                   (not (ilessp x y))
                   (not (negativep y)))
              (int-rangep (idifference y x) n)))

(prove-lemma idifference-int-rangep2 (rewrite)
     (implies (and (integerp x)
                   (integerp y)
                   (int-rangep x n)
                   (int-rangep y n)
                   (not (ilessp y x))
                   (negativep y))
              (int-rangep (idifference y x) n)))

; two lemmas about uint-rangep and int-rangep. We introduce them before any
; lemmas about uint-rangep and int-rangep.
(prove-lemma uint-rangep-la (rewrite)
     (implies (lessp x (exp 2 n))
              (uint-rangep x n)))

(prove-lemma int-rangep-la (rewrite)
     (implies (and (numberp x)
                   (lessp x (exp 2 (sub1 n))))
              (int-rangep x n)))

;                NAT-TO-UINT & UINT-TO-NAT
(prove-lemma nat-to-uint-to-nat (rewrite)
     (equal (uint-to-nat (nat-to-uint x)) 
            (fix x)))

(prove-lemma uint-to-nat-to-uint (rewrite)
     (equal (nat-to-uint (uint-to-nat x)) 
            (fix x)))

(prove-lemma uint-to-nat-rangep (rewrite)
     (implies (lessp x (exp 2 n))
              (nat-rangep (uint-to-nat x) n))
     ((enable nat-rangep uint-to-nat)))

(prove-lemma nat-to-uint-rangep (rewrite)
     (implies (nat-rangep x n)
              (uint-rangep (nat-to-uint x) n)))

;                NAT-TO-INT & INT-TO-NAT
(prove-lemma nat-to-int-0 (rewrite)
     (equal (nat-to-int 0 n) 0))

(prove-lemma int-to-nat-0 (rewrite)
     (equal (int-to-nat 0 n) 0))

; nat-to-int always returns an integer, provided the input is a "good"
; natural number.
(prove-lemma nat-to-int-integerp (rewrite)
     (equal (integerp (nat-to-int x n))
            (nat-rangep x n)))              

; nat-to-int always returns a "good" integer.
(prove-lemma nat-to-int-rangep (rewrite)
     (int-rangep (nat-to-int x n) n))

; int-to-nat always returns a "good" natural number, provided the input
; is a "good" integer.
(prove-lemma int-to-nat-rangep (rewrite)
     (implies (and (integerp x)
                   (int-rangep x n))
              (nat-rangep (int-to-nat x n) n)))

(prove-lemma nat-to-int-to-nat (rewrite)
     (implies (nat-rangep x n)
              (equal (int-to-nat (nat-to-int x n) n)
                     (fix x))))

(prove-lemma int-to-nat-to-int (rewrite)
     (implies (and (integerp x)
                   (int-rangep x n))
              (equal (nat-to-int (int-to-nat x n) n)
                     (fix-int x))))

(prove-lemma int-to-nat=0 (rewrite)
     (implies (and (int-rangep x n)
                   (integerp x))
              (equal (equal (int-to-nat x n) 0)
                     (equal x 0))))

; /x/ = /y/ --> x = y.
(prove-lemma nat-to-int= (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (equal (nat-to-int x n) (nat-to-int y n))
                     (equal (fix x) (fix y)))))

; nat-to-int and int-to-nat are disabled.
(disable nat-to-int)
(disable int-to-nat)

; theorems about int-rangep.
(prove-lemma abs-lessp-int-rangep (rewrite)
     (implies (and (int-rangep x n)
                   (lessp (abs y) (abs x)))
              (int-rangep y n)))

; 0 is always in "good" integer range.
(prove-lemma int-rangep-of-0 (rewrite)
     (int-rangep 0 n))

(prove-lemma sub1-int-rangep (rewrite)
     (implies (int-rangep x n)
              (int-rangep (sub1 x) n)))

(prove-lemma difference-int-rangep (rewrite)
     (implies (int-rangep x n)
              (int-rangep (difference x y) n)))

(prove-lemma quotient-int-rangep (rewrite)
     (implies (int-rangep x n)
              (int-rangep (quotient x y) n)))

(prove-lemma remainder-int-rangep (rewrite)
     (implies (and (int-rangep y n)
                   (not (zerop y)))
              (int-rangep (remainder x y) n)))

; iquotient is almost always in the integer range.
(prove-lemma iquotient-int-rangep (rewrite)
     (implies (int-rangep x n)
              (equal (int-rangep (iquotient x y) n)
                     (if (equal y -1)
                         (not (equal x (minus (exp 2 (sub1 n)))))
                       t))))

; iremainder is almost always in the integer range.
(prove-lemma iremainder-int-rangep (rewrite)
     (implies (and (int-rangep y n)
                   (integerp y)
                   (not (equal y 0)))
              (int-rangep (iremainder x y) n)))

; lemmas about integerp.
(prove-lemma integerp-fix-int (rewrite)
     (implies (integerp x)
              (equal (fix-int x) x)))

(prove-lemma fix-int-integerp (rewrite)
     (integerp (fix-int x)))

(prove-lemma minus-integerp (rewrite)
     (equal (integerp (minus x))
            (not (zerop x))))

(prove-lemma integerp-minus0 (rewrite)
     (implies (integerp x)
              (not (equal x (minus 0)))))

(prove-lemma negativep-guts0 (rewrite)
     (implies (and (integerp x)
                   (negativep x))
              (not (equal (negative-guts x) 0))))

(prove-lemma numberp-integerp (rewrite)
     (implies (numberp x)
              (integerp x)))

(prove-lemma iplus-integerp (rewrite)
     (integerp (iplus x y)))

(prove-lemma ineg-integerp (rewrite)
     (integerp (ineg x)))

(prove-lemma idifference-integerp (rewrite)
     (integerp (idifference x y)))

(prove-lemma itimes-integerp (rewrite)
     (integerp (itimes x y)))

(prove-lemma iremainder-integerp (rewrite)
     (integerp (iremainder x y)))

(prove-lemma iquotient-integerp (rewrite)
     (integerp (iquotient x y)))

; theorems about iplus, idifference, and ineg.
(prove-lemma iplus-commutativity (rewrite)
     (equal (iplus x y) (iplus y x)))

(prove-lemma iplus-commutativity1 (rewrite)
     (equal (iplus x (iplus y z))
            (iplus y (iplus x z))))

(prove-lemma iplus-associativity (rewrite)
     (equal (iplus (iplus x y) z)
            (iplus x (iplus y z)))
     ((disable iplus)))

(prove-lemma ineg-iplus (rewrite)
     (equal (ineg (iplus x y))
            (iplus (ineg x) (ineg y))))

(prove-lemma iplus-0 (rewrite)
     (implies (izerop x)
              (and (equal (iplus x y) (fix-int y))
                   (equal (iplus y x) (fix-int y)))))

(prove-lemma iplus-1--1 (rewrite)
     (equal (iplus 1 (iplus -1 x))
            (fix-int x)))

(prove-lemma idifference-x-x (rewrite)
     (equal (idifference x x) 0))

(prove-lemma idifference-negativep (rewrite)
     (equal (negativep (idifference x y))
            (ilessp x y)))

; lemmas about ilessp.
(prove-lemma ilessp-reflex (rewrite)
     (not (ilessp x x)))

(prove-lemma ilessp-entails-ileq (rewrite)
     (implies (ilessp x y)
              (not (ilessp y x))))

; lemmas about itimes.
(prove-lemma itimes-0 (rewrite)
     (equal (itimes 0 x) 0))

(prove-lemma itimes-equal-0 (rewrite)
     (equal (equal (itimes x y) 0)
            (or (izerop x) (izerop y))))

(prove-lemma itimes-commutativity (rewrite)
     (equal (itimes x y)
            (itimes y x)))

(prove-lemma itimes-associativity (rewrite)
     (equal (itimes (itimes x y) z)
            (itimes x (itimes y z))))

(prove-lemma itimes-equal-cancellation (rewrite)
     (implies (not (izerop x))  
              (equal (equal (itimes x y) (itimes x z))
                     (equal (fix-int y) (fix-int z)))))

(prove-lemma itimes-sign (rewrite)
     (implies (and (integerp x)
                   (integerp y))
              (equal (negativep (itimes x y))
                     (or (and (numberp x)
                              (not (equal x 0))
                              (negativep y))
                         (and (negativep x)
                              (numberp y)
                              (not (equal y 0)))))))

; lemmas about iremainder and iquotient.
(prove-lemma iremainder-wrt-1 (rewrite)
     (equal (iremainder x 1) 0))

(prove-lemma iquotient-wrt-1 (rewrite)
     (equal (iquotient x 1) (fix-int x)))

(prove-lemma iremainder-wrt--1 (rewrite)
     (equal (iremainder x -1) 0))
                    
(prove-lemma iquotient-wrt--1 (rewrite)
     (equal (iquotient x -1) (ineg x)))

(disable iplus)
(disable itimes)
(disable iremainder)
(disable iquotient)
(disable integerp)

; unsigned interpretation of mulu.
(prove-lemma times-lessp_1 (rewrite)
     (implies (and (lessp x x1)
                   (lessp y y1))
              (lessp (times x y) (times x1 y1))))

; three instances of mulu-nat.
(prove-lemma mulu_1632-nat (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (nat-to-uint (mulu 32 x y 16))
                     (times (nat-to-uint x) (nat-to-uint y))))
     ((use (times-lessp_1 (x1 (exp 2 16)) (y1 (exp 2 16))))))

(prove-lemma mulu_3264-nat (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (nat-to-uint (mulu 64 x y 32))
                     (times (nat-to-uint x) (nat-to-uint y))))
     ((use (times-lessp_1 (x1 (exp 2 32)) (y1 (exp 2 32))))))

(prove-lemma mulu_3232-nat (rewrite)
     (implies (uint-rangep (times (nat-to-uint x) (nat-to-uint y)) 32)
              (equal (nat-to-uint (mulu 32 x y 32))
                     (times (nat-to-uint x) (nat-to-uint y)))))

; signed interpretation of muls.
(prove-lemma exp2-lessp-crock (rewrite)
     (implies (and (not (zerop i))
                   (if (lessp k i) f t))
              (lessp (exp 2 (sub1 i)) (exp 2 k))))

(prove-lemma head-int-crock (rewrite)
     (implies (and (integerp x)
                   (int-rangep x n)
                   (leq n j))
              (equal (head (int-to-nat x j) n)
                     (int-to-nat x n)))
     ((enable remainder-diff integerp int-to-nat)))

(disable exp2-lessp-crock)

(prove-lemma times-lessp_2 (rewrite)
     (implies (and (leq x x1)
                   (leq y y1)
                   (not (zerop x1))
                   (not (zerop y1)))
              (lessp (times x y) (times 2 x1 y1))))

(prove-lemma times-lessp_3 (rewrite)
     (implies (and (leq x (exp 2 (sub1 n)))
                   (leq y (exp 2 (sub1 n)))
                   (not (zerop n)))
              (equal (lessp (times x y) (exp 2 (sub1 (plus n n))))
                     t))
     ((use (times-lessp_2 (x1 (exp 2 (sub1 n))) (y1 (exp 2 (sub1 n)))))))

(prove-lemma times-lessp_4 (rewrite)
     (implies (and (leq x (exp 2 (sub1 n)))
                   (leq y (exp 2 (sub1 n)))
                   (not (zerop n)))
              (equal (lessp (exp 2 (sub1 (plus n n))) (times x y))
                     f))
     ((use (times-lessp_2 (x1 (exp 2 (sub1 n))) (y1 (exp 2 (sub1 n)))))))

(prove-lemma muls-crock (rewrite)
     (implies (and (int-rangep x n)
                   (int-rangep y n)
                   (not (zerop n)))
              (int-rangep (itimes x y) (plus n n)))
     ((enable itimes integerp)))

; three instances of muls-int.
(prove-lemma muls_1632-int (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (nat-to-int (muls 32 x y 16) 32)
                     (itimes (nat-to-int x 16) (nat-to-int y 16))))
     ((use (muls-crock (x (nat-to-int x 16)) (y (nat-to-int y 16)) (n 16)))))

(prove-lemma muls_3264-int (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (nat-to-int (muls 64 x y 32) 64)
                     (itimes (nat-to-int x 32) (nat-to-int y 32))))
     ((use (muls-crock (x (nat-to-int x 32)) (y (nat-to-int y 32)) (n 32)))))

(prove-lemma muls_3232-int (rewrite)
     (implies (int-rangep (itimes (nat-to-int x 32) (nat-to-int y 32)) 32)
              (equal (nat-to-int (muls 32 x y 32) 32)
                     (itimes (nat-to-int x 32) (nat-to-int y 32)))))

(disable times-lessp_1)
(disable times-lessp_2)
(disable times-lessp_3)
(disable times-lessp_4)
(disable muls-crock)

; signed interpretation of irem.  
; notice that we only consider the case that the divisor and the result 
; have the same boundary n.  Since it is enough to cover the situations 
; in the DIVS instructions.
(prove-lemma irem-int (rewrite)
     (implies (and (nat-rangep x n)
                   (not (equal (nat-to-int x n) 0)))
              (equal (nat-to-int (irem n x n y j) n)
                     (iremainder (nat-to-int y j) (nat-to-int x n)))))

; signed interpretation of iquot.
; notice that we only consider the case that the length of the result 
; is at most the length of the dividend.  Since it is enough to cover
; the situations in DIVS instruction.
(prove-lemma iquot-int (rewrite)
     (implies (and (int-rangep (iquotient (nat-to-int y j) (nat-to-int x i))
                               n)
                   (leq n j))
              (equal (nat-to-int (iquot n x i y j) n)
                     (iquotient (nat-to-int y j) (nat-to-int x i)))))

(disable head-int-crock)

; unsigned interpratation of rem.
(prove-lemma rem-nat (rewrite)
     (implies (nat-rangep x n)
              (equal (nat-to-uint (rem n x y))
                     (if (equal (nat-to-uint x) 0)
                         (remainder (nat-to-uint y) (exp 2 n))
                       (remainder (nat-to-uint y) (nat-to-uint x))))))

; unsigned interpretation of quot.
(prove-lemma quot-nat (rewrite)
     (implies (nat-rangep y n)
              (equal (nat-to-uint (quot n x y))
                     (quotient (nat-to-uint y) (nat-to-uint x)))))

(disable int-rangep)

; the only correct execution of DIV is when NO overflow occurs.  We 
; need to pass the guard in the specification.  The following few
; lemmas are introduced for this purpose. 
(prove-lemma divu-overflow (rewrite)
     (equal (divu-v n x y)
            (if (uint-rangep (quotient (nat-to-uint y) (nat-to-uint x)) n)
                0 1)))

(prove-lemma divs-overflow (rewrite)
     (equal (divs-v n x i y j)
            (if (int-rangep (iquotient (nat-to-int y j) 
                                       (nat-to-int x i))
                            n)
                0 1)))
                    
(prove-lemma divs_3232-overflow (rewrite)
     (equal (divs-v 32 x 32 y 32)
            (if (and (equal (nat-to-int y 32) -2147483648)
                     (equal (nat-to-int x 32) -1))
                1 0)))

(disable divu-v)
(disable divs-v)

;          UNSIGNED INTERPRETATION OF ADDITION AND SUBTRACTION
;               
(prove-lemma add-nat-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (add n x y)
                     (if (lessp (plus x y) (exp 2 n))
                         (plus x y)
                       (difference (plus x y) (exp 2 n))))))

(prove-lemma sub-nat-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n) )
              (equal (sub n x y)
                     (if (lessp y x)
                         (difference (plus y (exp 2 n)) x)
                       (difference y x)))))

(prove-lemma adder-nat-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c))
              (equal (adder n c x y)
                     (if (lessp (plus c x y) (exp 2 n))
                         (plus c x y)
                       (difference (plus c x y) (exp 2 n))))))

(prove-lemma subtracter-nat-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n) 
                   (bitp c))
              (equal (subtracter n c x y)
                     (if (lessp y (plus c x))
                         (difference (plus y (exp 2 n)) (plus c x))
                       (difference y (plus c x)))))
     ((enable lognot)))

(prove-lemma plus-numberp (rewrite)
     (implies (not (numberp y))
              (equal (plus x y) (fix x))))

; unsigned interpretation of adder.
(prove-lemma adder-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c))
              (equal (nat-to-uint (adder n c x y))
                     (if (lessp (plus c (nat-to-uint x) (nat-to-uint y))
                                (exp 2 n))
                         (plus c (nat-to-uint x) (nat-to-uint y))
                       (difference (plus c (nat-to-uint x) (nat-to-uint y))
                                   (exp 2 n)))))
     ((disable adder)))

; unsigned interpretation of subtracter.
(prove-lemma subtracter-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n) 
                   (bitp c))
              (equal (nat-to-uint (subtracter n c x y))
                     (if (lessp (nat-to-uint y) (plus c (nat-to-uint x)))
                         (difference (plus (nat-to-uint y) (exp 2 n))
                                     (plus c (nat-to-uint x)))
                       (difference (nat-to-uint y) (plus c (nat-to-uint x))))))
     ((disable subtracter)))

; unsigned interpretation of add.
(prove-lemma add-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (nat-to-uint (add n x y))
                     (if (lessp (plus (nat-to-uint x) (nat-to-uint y))
                                (exp 2 n))
                         (plus (nat-to-uint x) (nat-to-uint y))
                       (difference (plus (nat-to-uint x) (nat-to-uint y))
                                   (exp 2 n))))))

; unsigned interpretation of sub.
(prove-lemma sub-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (nat-to-uint (add n x (neg n y)))
                     (if (lessp (nat-to-uint x) (nat-to-uint y))
                         (difference (plus (nat-to-uint x) (exp 2 n)) 
                                     (nat-to-uint y))
                       (difference (nat-to-uint x) (nat-to-uint y)))))
     ((disable add)))

(disable plus-numberp)
(disable add-nat-la)
(disable sub-nat-la)
(disable adder-nat-la)
(disable subtracter-nat-la)

;                  THEOREMS OF ADDER
;
(prove-lemma adder-shift-carry (rewrite)
     (equal (adder n c x (adder n d y z))
            (adder n d x (adder n c y z)))
     ((disable remainder plus remainder-exit)))

(prove-lemma adder-commutativity (rewrite)
     (equal (adder n c x y) (adder n c y x)))

(prove-lemma adder-associativity (rewrite)
     (equal (adder n d (adder n c x y) z)
            (adder n c x (adder n d y z)))
     ((disable remainder plus remainder-exit)))

; another commutativity theorem about adder.
(prove-lemma adder-commutativity1 (rewrite)
     (equal (adder n c x (adder n d y z))
            (adder n c y (adder n d x z)))
     ((disable remainder plus remainder-exit)))

;               THEOREMS ABOUT ADD AND SUB
;
; trivial!
(prove-lemma add-of-0 (rewrite)
     (equal (add 0 x y) 0))

; x + 0 = x!
(prove-lemma add-0 (rewrite) 
     (and (equal (add n x 0) (head x n))
          (equal (add n 0 x) (head x n))))
             
; x - 0 = x!
(prove-lemma sub-0 (rewrite)
     (equal (sub n 0 x) (head x n)))

; x - x = 0!
(prove-lemma sub-x-x (rewrite)
     (equal (sub n x x) 0))

; commutativity of addition : x + y = y + x.
(prove-lemma add-commutativity (rewrite)
    (equal (add n x y) (add n y x)))

; associativity of addition: (x + y) + z = x + (y + z).
(prove-lemma add-associativity (rewrite)
     (equal (add n (add n x y) z)
            (add n x (add n y z)))
     ((disable remainder plus remainder-exit)))

; another commutativity of addition: x + (y + z) = y + (x + z).
(prove-lemma add-commutativity1 (rewrite)
     (equal (add n x (add n y z))
            (add n y (add n x z)))
     ((disable remainder plus remainder-exit)))

(prove-lemma remainder-leq (rewrite)
        (not (lessp x (remainder x y))))

(prove-lemma add-leq (rewrite)
     (not (lessp (plus x y) (add n x y)))
     ((enable add)))

(prove-lemma sub-leq-la ()
     (implies (leq x y)
              (not (lessp (difference y x) (sub n x y))))
     ((use (remainder-plus2 (i (exp 2 n))
                            (j (exp 2 n)) 
                            (x (difference y x))))
      (disable remainder-exit)))

(disable remainder-leq)

; addition and subtraction are always in "good" range.
(prove-lemma adder-nat-rangep (rewrite)
     (nat-rangep (adder n c x y) n))

(prove-lemma subtracter-nat-rangep (rewrite)
     (nat-rangep (subtracter n c y x) n)
     ((disable adder nat-rangep)))

(prove-lemma add-nat-rangep (rewrite)
     (nat-rangep (add n x y) n))

(prove-lemma sub-nat-rangep (rewrite)
     (nat-rangep (sub n x y) n))

(prove-lemma adder-head (rewrite)
     (and (equal (adder n c (head x n) y)
                 (adder n c x y))
          (equal (adder n c x (head y n))
                 (adder n c x y))))

(prove-lemma add-head (rewrite)
     (and (equal (add n (head x n) y) (add n x y))
          (equal (add n x (head y n)) (add n x y))))
             
; x + y = x - z <==> y + z = 0.
(prove-lemma add-sub-cancel (rewrite)
     (implies (and (nat-rangep y n)
                   (nat-rangep z n))
              (equal (equal (add n x y) (sub n z x))
                     (equal (add n y z) 0)))
     ((enable lognot)))

; x - y = 0 <==> x = y.
(prove-lemma sub-equal-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (equal (sub n x y) 0)
                     (equal (fix x) (fix y))))
     ((enable lognot)))

; a bridge from add to adder.
(prove-lemma add-adder (rewrite)
     (equal (add n x y) (adder n 0 x y)))

(prove-lemma plus-add1-sub1 (rewrite)
     (implies (not (zerop y))
              (equal (add1 (plus x (sub1 y)))
                     (plus x y))))

; a bridge from sub to adder.
(prove-lemma sub-adder (rewrite)
     (equal (sub n y x)
            (adder n 1 x (lognot n y)))
     ((enable lognot)))

(prove-lemma add-neg-adder (rewrite)
     (equal (add n x (neg n y))
            (adder n 1 x (lognot n y)))
     ((enable lognot)))

; plus-add1-sub1 is a very ``dangerous'' event.  To use it,  you need
; to enable it first.
(disable plus-add1-sub1)

(disable add)
(disable sub)

; (x + y) -z = x + (y - z).
(prove-lemma add-sub (rewrite)
     (equal (sub n z (add n x y))
            (add n x (sub n z y)))
     ((disable adder)))

; (x - y) + z = x + (z - y).
(prove-lemma sub-add (rewrite)
     (equal (add n (sub n y x) z)
            (add n x (sub n y z)))
     ((disable adder)))

; (x - y) - z = x - (y + z).
(prove-lemma sub-sub (rewrite)
     (equal (sub n z (sub n y x))
            (sub n (add n y z) x))
     ((disable adder)))

; x - (y - z) = x + (z - y).
(prove-lemma sub-sub1 (rewrite)
     (equal (sub n (sub n z y) x)
            (add n x (sub n y z)))
     ((disable adder head)))
             
; another commutativity of addition: x + (y - z) = y + (x - z).
(prove-lemma add-commutativity2 (rewrite)
     (equal (add n x (sub n z y))
            (add n y (sub n z x)))
     ((disable adder)))

; x + y = x <==> y = 0.
(prove-lemma add-cancel0 (rewrite)
     (equal (equal (add n x y) x)
            (and (numberp x)
                 (nat-rangep x n)
                 (equal (head y n) 0))))

; x - y = x <==> y = 0.
(prove-lemma sub-cancel0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (equal (sub n y x) x)
                     (and (numberp x) (zerop y))))
     ((enable lognot)))

(prove-lemma adder-cancel (rewrite)
     (equal (equal (adder n c x y) (adder n c x z))
            (equal (head y n) (head z n))))

; x + y = x + z <==> y = z.
(prove-lemma add-cancel (rewrite)
     (equal (equal (add n x y) (add n x z))
            (equal (head y n) (head z n))))

; x - y = x - z <==> y = z.
(prove-lemma sub-cancel (rewrite)
     (implies (and (nat-rangep y n)
                   (nat-rangep z n))
              (equal (equal (sub n y x) (sub n z x))
                     (equal (fix y) (fix z))))
     ((disable adder)))      

(disable add-adder)
(disable sub-adder)

; x + (y - y) = x!
(prove-lemma addy-y (rewrite)
     (implies (nat-rangep x n)
              (equal (add n x (sub n y y))
                     (fix x))))

; y + (x - y) = x!
(prove-lemma addy-y1 (rewrite)
     (implies (nat-rangep x n)
              (equal (add n y (sub n y x))
                     (fix x))))

;           INTEGER INTERPRETATION OF ADDITION AND SUBTRACTION

; a bridge for adder-int.
(prove-lemma adder-int-bridge (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c))
              (equal (nat-to-int (adder n c x y) n)
                     (adder-int-end n c (nat-to-int x n) (nat-to-int y n))))
     ((disable remainder remainder-add1)))

(disable adder-int-end)
(disable adder)

; integer interpretation of adder.
(prove-lemma adder-int (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c))
              (equal (nat-to-int (adder n c x y) n)
                     (if (int-rangep (iplus (nat-to-int x n)
                                            (iplus (nat-to-int y n) c))
                                     n)
                         (iplus (nat-to-int x n) (iplus (nat-to-int y n) c))
                       (if (negativep (nat-to-int x n))
                           (iplus (nat-to-int x n)
                                  (iplus (nat-to-int y n) 
                                         (iplus c (exp 2 n))))
                         (iplus (nat-to-int x n)
                                (iplus (nat-to-int y n) 
                                       (iplus c (minus (exp 2 n)))))))))
     ((enable plus-to-iplus)))

; integer interpretation of subtracter.
(prove-lemma subtracter-int (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c)
                   (not (zerop n)))
              (equal (nat-to-int (subtracter n c x y) n)
                     (if (int-rangep (idifference (nat-to-int y n)
                                                  (iplus (nat-to-int x n) c))
                                     n)
                         (idifference (nat-to-int y n) 
                                      (iplus (nat-to-int x n) c))
                       (if (negativep (nat-to-int y n))
                           (idifference (iplus (nat-to-int y n) (exp 2 n))
                                        (iplus (nat-to-int x n) c))
                         (idifference (iplus (nat-to-int y n)
                                             (minus (exp 2 n)))
                                      (iplus (nat-to-int x n) c)))))))

(disable subtracter)

; integer interpretation of add.
(prove-lemma add-int (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (nat-to-int (add n x y) n)
                     (if (int-rangep (iplus (nat-to-int x n) (nat-to-int y n))
                                     n)
                         (iplus (nat-to-int x n) (nat-to-int y n))
                       (if (negativep (nat-to-int x n))
                           (iplus (nat-to-int x n)
                                  (iplus (nat-to-int y n) (exp 2 n)))
                         (iplus (nat-to-int x n)
                                (iplus (nat-to-int y n) 
                                       (minus (exp 2 n))))))))
     ((enable add-adder)))

; integer interpretation of sub.
(prove-lemma sub-int (rewrite)
     (implies (and (nat-rangep x n) 
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (nat-to-int (add n x (neg n y)) n)
                     (if (int-rangep (idifference (nat-to-int x n)
                                                  (nat-to-int y n))
                                     n)
                         (idifference (nat-to-int x n) (nat-to-int y n))
                       (if (negativep (nat-to-int x n))
                           (idifference (iplus (nat-to-int x n) (exp 2 n))
                                        (nat-to-int y n))
                         (idifference (iplus (nat-to-int x n) 
                                             (minus (exp 2 n)))
                                      (nat-to-int y n))))))
     ((disable neg)))

(disable add-neg-adder)

;            THEOREMS ABOUT HEAD, TAIL, APP, AND REPLACE
;
(prove-lemma head-head (rewrite)
     (equal (head (head x m) n)
            (if (lessp n m) (head x n) (head x m))))

(prove-lemma tail-tail (rewrite)
     (equal (tail (tail x m) n)
            (tail x (plus m n))))

(prove-lemma head-plus-cancel0 (rewrite)
     (equal (equal (head (plus i j) n) (head i n))
            (equal (head j n) 0))
     ((use (remainder-plus-cancel (k 0) (n (exp 2 n))))
      (disable remainder-plus-cancel)))

(prove-lemma head-plus-cancel (rewrite)
     (equal (equal (head (plus x y) n) (head (plus x z) n))
            (equal (head y n) (head z n))))

(prove-lemma head-plus-head (rewrite)
     (equal (head (plus x (head y n)) n)
            (head (plus x y) n)))

(prove-lemma remainder-plus-times-exp2-1 (rewrite)
     (implies (leq j i)
              (equal (remainder (plus x (times y (exp 2 i)))
                                (exp 2 j))
                     (remainder x (exp 2 j))))
     ((use (remainder-plus1 (i (times y (exp 2 i))) (j (exp 2 j))))))

(prove-lemma remainder2-plus-times-exp2 (rewrite)
     (implies (not (zerop i))
              (equal (remainder (plus x (times y (exp 2 i))) 2)
                     (remainder x 2)))
     ((use (remainder-plus-times-exp2-1 (j 1)))))

(prove-lemma remainder-plus-times-exp2-2 (rewrite)
     (implies (and (lessp x (exp 2 i))
                   (leq i j))
              (equal (remainder (plus x (times y (exp 2 i)))
                                (exp 2 j))
                     (if (lessp i j)
                         (plus x 
                               (times (remainder y (exp 2 (difference j i)))
                                      (exp 2 i)))
                       (fix x))))
     ((enable times-distributes-plus exp2-lessp)
      (disable plus-commutativity)))

(prove-lemma quotient-plus-times-exp2-1 (rewrite)
     (implies (lessp j i)
              (equal (quotient (plus x (times y (exp 2 i)))
                               (exp 2 j))
                     (plus (quotient x (exp 2 j)) 
                           (times y (exp 2 (difference i j))))))
     ((use (quotient-plus1 (i (times y (exp 2 i))) (j (exp 2 j))))))

(prove-lemma exp2-leq (rewrite)
     (implies (leq i j)
              (not (lessp (exp 2 j) (exp 2 i)))))

(prove-lemma quotient-plus-times-exp2-2 (rewrite)
     (implies (and (leq i j) 
                   (lessp x (exp 2 i)))
              (equal (quotient (plus x (times y (exp 2 i))) (exp 2 j))
                     (quotient y (exp 2 (difference j i)))))
     ((enable times-distributes-plus)))

(prove-lemma remainder-quotient-exp2 (rewrite)
     (equal (quotient (remainder x (exp 2 i)) (exp 2 j))
            (if (lessp j i)
                (remainder (quotient x (exp 2 j)) 
                           (exp 2 (difference i j)))
              0)))

(disable exp2-leq)

(prove-lemma head-replace (rewrite)
     (equal (head (replace m x y) n)
            (if (lessp m n)
                (replace m x (head y n))
              (head x n)))
     ((disable times-commutativity remainder quotient)))

(prove-lemma tail-head (rewrite)
     (equal (tail (head x m) n)
            (head (tail x n) (difference m n)))
     ((disable remainder quotient)))

(prove-lemma tail-app (rewrite)
     (equal (tail (app i x y) j)
            (if (lessp j i)
                (app (difference i j) (tail x j) y)
              (tail y (difference j i))))
     ((disable remainder quotient)))

(prove-lemma tail-replace (rewrite)
     (equal (tail (replace i x y) j)
            (if (lessp j i)
                (replace (difference i j) (tail x j) (tail y j))
              (tail y j)))
     ((disable times-commutativity remainder quotient)))

(prove-lemma replace-reflex (rewrite)
     (equal (replace n x x) (fix x)))

(prove-lemma replace-head (rewrite)
     (implies (leq n m)
              (equal (replace n (head x m) x)
                     (fix x))))

(prove-lemma replace-associativity (rewrite)
     (equal (replace n x (replace n y z))
            (replace n (replace n x y) z)))

(prove-lemma replace-leq1 (rewrite)
     (implies (leq j i)
              (equal (replace i x (replace j y z))
                     (replace i x z)))
     ((disable times-commutativity)))

(prove-lemma replace-leq (rewrite)
     (implies (leq i j)
              (equal (replace i (replace j x y) z)
                     (replace i x z)))
     ((disable times-commutativity)))

(prove-lemma head-app (rewrite)
     (implies (leq i j)
              (equal (head (app j x y) i) (head x i))))

; a few basic lemmas about bcar and bcdr.  They are useful in induction
; proofs with bcar and bcdr disabled.
(prove-lemma bcar-nonnumberp (rewrite)
     (implies (not (numberp x))
              (equal (bcar x) 0)))

(prove-lemma bcdr-nonnumberp (rewrite)
     (implies (not (numberp x))
              (equal (bcdr x) 0)))

(prove-lemma bcar-1 (rewrite)
     (and (equal (bcar (times 2 x)) 0)
          (equal (bcar (add1 (times 2 x))) 1)))

(prove-lemma bcdr-1 (rewrite)
     (and (equal (bcdr (times 2 x)) (fix x))
          (equal (bcdr (add1 (times 2 x))) (fix x))))

(prove-lemma bcar-2 (rewrite)
     (equal (bcar (plus x (times 2 y))) (bcar x)))

(prove-lemma bcdr-2 (rewrite)
     (equal (bcdr (plus x (times 2 y))) (plus (bcdr x) y)))

; the first "bit" of head.
(prove-lemma bcar-head (rewrite)
     (equal (bcar (head x n))
            (if (zerop n) 0 (bcar x))))

; the first "bit" of app.
(prove-lemma bcar-app (rewrite)
     (equal (bcar (app n x y))
            (if (zerop n) (bcar y) (bcar x)))
     ((disable times-commutativity)))

; the first "bit" of replace.
(prove-lemma bcar-replace (rewrite)
     (equal (bcar (replace n x y))
            (if (zerop n) (bcar y) (bcar x)))
     ((disable times-commutativity remainder quotient)))

(prove-lemma bcar-lessp (rewrite)
     (lessp (bcar x) 2))

(prove-lemma bcdr-lessp (rewrite)
     (equal (lessp (bcdr x) y)
            (lessp x (times 2 y))))

(prove-lemma app-associativity (rewrite)
     (equal (app n1 x (app n2 y z))
            (app (plus n1 n2) (app n1 x y) z))
     ((enable times-distributes-plus)))

(prove-lemma app-head-tail (rewrite)
     (equal (app n (head x n) (tail x n))
            (fix x)))

(prove-lemma head-app-head-tail (rewrite)
     (equal (app m (head x m) (head (tail x m) n))
            (head x (plus m n)))
     ((use (app-head-tail (n m) (x (head x (plus m n)))))
      (disable remainder quotient)))

(disable head)
(disable tail)
(disable bcar)
(disable bcdr)

(prove-lemma app-nat-rangep (rewrite)
     (implies (leq m n)
              (equal (nat-rangep (app m x y) n)
                     (nat-rangep y (difference n m))))
     ((enable exp2-leq)))

(prove-lemma replace-nat-rangep (rewrite)
     (implies (leq m n)
              (equal (nat-rangep (replace m x y) n)
                     (nat-rangep y n)))
     ((enable equal-iff exp2-leq)
      (disable times-commutativity)))         

(disable app)
(disable replace)

;                     BITN
(prove-lemma bitn-0 (rewrite)
     (and (equal (bitn 0 n) 0)
          (implies (not (numberp x))
                   (equal (bitn x i) 0))))

(prove-lemma bitn-0-1 (rewrite)
     (lessp (bitn x n) 2))

(prove-lemma bitn-head (rewrite)
     (equal (bitn (head x i) j)
            (if (lessp j i) (bitn x j) 0)))

(prove-lemma bitn-tail (rewrite)
     (equal (bitn (tail x i) j)
            (bitn x (plus i j))))

(prove-lemma bitn-app (rewrite)
     (equal (bitn (app n x y) k)
            (if (lessp k n) 
                (bitn x k) 
              (bitn y (difference k n))))
     ((disable times-commutativity)))

(prove-lemma bitn-replace (rewrite)
     (equal (bitn (replace n x y) k)
            (if (lessp k n) (bitn x k) (bitn y k)))
     ((disable times-commutativity)))

(disable bitn)

(prove-lemma bitn-lognot (rewrite)           
     (implies (nat-rangep x n)
              (equal (bitn (lognot n x) i)
                     (if (lessp i n) (b-not (bitn x i)) 0)))
     ((use (bv-bitn-not (x (nat-to-bv-sized x n)) (n i)))))

;               LOGAND, LOGOR, AND LOGEOR.
(prove-lemma logor-equal-0 (rewrite)
     (equal (equal (logor x y) 0)
            (and (zerop x) (zerop y)))
     ((enable bcar bcdr)))

(prove-lemma logeor-equal-0 (rewrite)
     (equal (equal (logeor x y) 0)
            (equal (fix x) (fix y)))
     ((enable bcar bcdr)
      (disable remainder quotient)))

(prove-lemma logand-commutativity (rewrite)
     (equal (logand x y) (logand y x)))

(prove-lemma logor-commutativity (rewrite)
     (equal (logor x y) (logor y x)))

(prove-lemma logeor-commutativity (rewrite)
     (equal (logeor x y) (logeor y x)))

(prove-lemma logand-logor (rewrite)
     (equal (logand x (logor y z))
            (logor (logand x y) (logand x z))))

(prove-lemma logand-logeor (rewrite)
     (equal (logand x (logeor y z))
            (logeor (logand x y) (logand x z))))

(prove-lemma logand-uint-la (rewrite)
     (equal (nat-to-uint (logand (sub1 (exp 2 i)) y))
            (remainder (nat-to-uint y) (exp 2 i)))
     ((induct (mod-eq i x y))
      (enable bcar bcdr) 
      (disable remainder quotient)))

(prove-lemma logand-uint (rewrite)
     (implies (equal (exp 2 (log 2 (add1 x))) (add1 x))
              (equal (nat-to-uint (logand x y))
                     (remainder (nat-to-uint y) (add1 x))))
     ((use (logand-uint-la (i (log 2 (add1 x)))))
      (disable logand-uint-la)))

;            HEAD WITH READ/WRITE AND READM/WRITEM
(prove-lemma head-readp (rewrite)
     (implies (leq n k)
              (equal (readp (head x k) n map)
                     (readp x n map))))

(prove-lemma head-pc-readp (rewrite)
     (implies (leq n k)
              (equal (pc-readp (head x k) n map)
                     (pc-readp x n map))))

(prove-lemma head-writep (rewrite)
     (implies (leq n k)
              (equal (writep (head x k) n map)
                     (writep x n map))))

(prove-lemma head-read (rewrite)
     (implies (leq n k)
              (equal (read (head x k) n bt)
                     (read x n bt))))

(prove-lemma head-pc-read (rewrite)
     (implies (leq n k)
              (equal (pc-read (head x k) n bt)
                     (pc-read x n bt))))

(prove-lemma head-write (rewrite)
     (implies (leq n k)
              (equal (write value (head x k) n bt)
                     (write value x n bt))))

(prove-lemma head-byte-readp (rewrite)
     (equal (byte-readp (head x 32) mem)
            (byte-readp x mem))
     ((enable byte-readp)))

(prove-lemma head-pc-byte-readp (rewrite)
     (equal (pc-byte-readp (head x 32) mem)
            (pc-byte-readp x mem))
     ((enable pc-byte-readp)))

(prove-lemma head-byte-writep (rewrite)
     (equal (byte-writep (head x 32) mem)
            (byte-writep x mem))
     ((enable byte-writep)))

(prove-lemma head-byte-read (rewrite)
     (equal (byte-read (head x 32) mem)
            (byte-read x mem)))

(prove-lemma head-byte-pc-read (rewrite)
     (equal (pc-byte-read (head x 32) mem)
            (pc-byte-read x mem)))

(prove-lemma head-byte-write (rewrite)
     (equal (byte-write value (head x 32) mem)
            (byte-write value x mem)))

(prove-lemma head-read-memp (rewrite)
     (equal (read-memp (head x 32) mem k)
            (read-memp x mem k)))

(prove-lemma head-pc-read-memp (rewrite)
     (equal (pc-read-memp (head x 32) mem k)
            (pc-read-memp x mem k)))

(prove-lemma head-write-memp (rewrite)
     (equal (write-memp (head x 32) mem k)
            (write-memp x mem k)))

(prove-lemma head-read-mem (rewrite)
     (equal (read-mem (head x 32) mem k)
            (read-mem x mem k)))

(prove-lemma head-pc-read-mem (rewrite)
     (equal (pc-read-mem (head x 32) mem k)
            (pc-read-mem x mem k)))

(prove-lemma head-write-mem (rewrite)
     (equal (write-mem value (head x 32) mem k)
            (write-mem value x mem k)))

(prove-lemma head-readm-mem (rewrite)
     (equal (readm-mem opsz (head x 32) mem n)
            (readm-mem opsz x mem n)))

;                  NAT-RANGEP
(prove-lemma nat-rangep-of-0 (rewrite)
     (nat-rangep 0 n))
                    
(prove-lemma nat-rangep-ub (rewrite)
     (equal (nat-rangep (sub1 (exp 2 k)) n)
            (not (lessp n k))))

(prove-lemma nat-rangep-0 (rewrite)
     (equal (nat-rangep x 0) (zerop x)))

(prove-lemma nat-plus-rangep (rewrite)
     (implies (nat-rangep x k)
              (and (nat-rangep x (plus k j))
                   (nat-rangep x (plus j k)))))

(prove-lemma sub1-nat-rangep (rewrite)
     (implies (nat-rangep x n)
              (nat-rangep (sub1 x) n)))

(prove-lemma sub1-times2-nat-rangep (rewrite)
     (equal (nat-rangep (sub1 (times 2 x)) (add1 n))
            (nat-rangep (sub1 x) n)))

(prove-lemma difference-nat-rangep (rewrite)
     (implies (nat-rangep x n)
              (nat-rangep (difference x y) n)))

(prove-lemma quotient-nat-rangep (rewrite)
     (implies (nat-rangep x n)
              (nat-rangep (quotient x y) n)))

(prove-lemma times-exp2-nat-rangep (rewrite)
     (equal (nat-rangep (times x (exp 2 i)) n)
            (nat-rangep x (difference n i))))

(prove-lemma logand-nat-rangep (rewrite)
     (implies (or (nat-rangep x n)
                  (nat-rangep y n))
              (nat-rangep (logand x y) n))
     ((induct (mod-eq n x y))))

(prove-lemma logor-nat-rangep (rewrite)
     (equal (nat-rangep (logor x y) n)
            (and (nat-rangep x n)
                 (nat-rangep y n)))
     ((induct (mod-eq n x y))))

(prove-lemma logeor-nat-rangep (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (nat-rangep (logeor x y) n))
     ((induct (mod-eq n x y))))

(prove-lemma head-nat-rangep (rewrite)
     (implies (leq m n)
              (nat-rangep (head x m) n)))

(prove-lemma tail-nat-rangep (rewrite)
     (equal (nat-rangep (tail x m) n)
            (nat-rangep x (plus m n))))

(prove-lemma read-rn-nat-rangep (rewrite)
     (nat-rangep (read-rn n rn rfile) n))

(prove-lemma byte-read-nat-rangep (rewrite)
     (implies (leq 8 n)
              (nat-rangep (byte-read x mem) n)))

(prove-lemma pc-byte-read-nat-rangep (rewrite)
     (nat-rangep (pc-byte-read x mem) 8))

(disable nat-rangep)

(prove-lemma mulu-nat-rangep (rewrite)
     (nat-rangep (mulu n x y i) n))

(prove-lemma muls-nat-rangep (rewrite)
     (nat-rangep (muls n x y i) n))

(prove-lemma quot-nat-rangep (rewrite)
     (nat-rangep (quot n x y) n))

(prove-lemma rem-nat-rangep (rewrite)
     (nat-rangep (rem n x y) n))

(prove-lemma iquot-nat-rangep (rewrite)
     (nat-rangep (iquot n x i y j) n))

(prove-lemma irem-nat-rangep (rewrite)
     (nat-rangep (irem n x i y j) n))

(prove-lemma neg-nat-rangep (rewrite)
     (nat-rangep (neg n x) n))

;                         EXT
(prove-lemma ext-0 (rewrite)
     (equal (ext n 0 size) 0))       

(prove-lemma ext-lemma (rewrite)
     (implies (leq size n)
              (equal (ext n x size) (head x size))))

(prove-lemma head-ext (rewrite)
     (implies (and (leq i j) (leq j k))
              (equal (head (ext j x k) i)
                     (head x i))))

(prove-lemma ext-nat-rangep (rewrite)
     (nat-rangep (ext n x size) size)
     ((use (exp2-leq (i n) (j size)))))

(disable ext)

;                      CVZNX-FLAGS
(prove-lemma set-cvznx-c (rewrite)
     (equal (ccr-c (set-cvznx (cvznx c v z n x) ccr))
            (fix-bit c)))

(prove-lemma set-cvznx-v (rewrite)
     (equal (ccr-v (set-cvznx (cvznx c v z n x) ccr))
            (fix-bit v)))

(prove-lemma set-cvznx-z (rewrite)
     (equal (ccr-z (set-cvznx (cvznx c v z n x) ccr))
            (fix-bit z)))

(prove-lemma set-cvznx-n (rewrite)
     (equal (ccr-n (set-cvznx (cvznx c v z n x) ccr))
            (fix-bit n)))

(prove-lemma set-cvznx-x (rewrite)
     (equal (ccr-x (set-cvznx (cvznx c v z n x) ccr))
            (fix-bit x)))

; the new cvznx-flags replaces the old ones.
(prove-lemma set-set-cvznx1 (rewrite)
     (equal (set-cvznx x (set-cvznx y ccr))
            (set-cvznx x ccr)))

(prove-lemma set-cvznx-ccr (rewrite)
     (equal (set-cvznx ccr ccr)
            (fix ccr)))

(prove-lemma set-set-cvznx2 (rewrite)
     (equal (set-cvznx (set-cvznx x ccr) ccr)
            (set-cvznx x ccr)))

(prove-lemma set-cvznx-nat-rangep (rewrite)
     (equal (nat-rangep (set-cvznx x ccr) 8)
            (nat-rangep ccr 8)))

(disable ccr-c)
(disable ccr-v)
(disable ccr-z)
(disable ccr-n)
(disable ccr-x)
(disable cvznx)
(disable set-cvznx)

;                       MC ACCESSORS
(prove-lemma mc-status-rewrite (rewrite)
     (equal (mc-status (mc-state status rfile pc ccr mem))
            status))

(prove-lemma mc-rfile-rewrite (rewrite)
     (equal (mc-rfile (mc-state status rfile pc ccr mem))
            rfile))

(prove-lemma mc-pc-rewrite (rewrite)
     (implies (nat-rangep pc 32)
              (equal (mc-pc (mc-state status rfile pc ccr mem))
                     (fix pc))))

(prove-lemma mc-ccr-rewrite (rewrite)
     (implies (nat-rangep ccr 8)
              (equal (mc-ccr (mc-state status rfile pc ccr mem))
                     (fix ccr))))

(prove-lemma mc-mem-rewrite (rewrite)
     (equal (mc-mem (mc-state status rfile pc ccr mem))
            mem))

; lemmas about those mc accessors. 
(prove-lemma mc-pc-rangep (rewrite)
     (nat-rangep (mc-pc s) 32))

(prove-lemma mc-ccr-rangep (rewrite)
     (nat-rangep (mc-ccr s) 8))

(disable mc-status)
(disable mc-rfile)
(disable mc-pc)
(disable mc-ccr)
(disable mc-mem)
(disable mc-state)

;           THE BASIC GET-NTH/PUT-NTH RELATIONS
;
(prove-lemma get-nth-0 (rewrite)
     (implies (not (numberp i))
              (equal (get-nth i lst) (get-nth 0 lst))))

(prove-lemma put-nth-0 (rewrite)
     (implies (not (numberp i))
              (equal (put-nth v i lst) (put-nth v 0 lst))))

(disable get-nth-0)
(disable put-nth-0)
             
(prove-lemma get-nth-nil (rewrite)
     (and (equal (get-nth n nil) 0)
          (equal (get-nth n 0) 0)))

(prove-lemma get-put (rewrite)
     (equal (get-nth n (put-nth value m lst))
            (if (equal (fix m) (fix n))
                value
              (get-nth n lst))))

(prove-lemma put-put (rewrite)
     (equal (put-nth value1 n (put-nth value n lst))
            (put-nth value1 n lst)))

(prove-lemma put-get (rewrite)
     (implies (lessp n (len lst))
              (equal (put-nth (get-nth n lst) n lst) lst)))

(prove-lemma put-nth-len (rewrite)
     (equal (len (put-nth value n lst))
            (if (lessp n (len lst)) (len lst) (add1 n))))

;            THE BASIC READ-RN/WRITE-RN RELATIONS
;
(prove-lemma head-read-rn (rewrite)
     (implies (leq n1 n2)
              (equal (head (read-rn n2 rn rfile) n1)
                     (read-rn n1 rn rfile))))

; stop proving.
(defn read-write-rn-end (n2 rn n1 value rm rfile)
  (read-rn n2 rn (write-rn n1 value rm rfile)))

(prove-lemma read-write-rn (rewrite)
     (equal (read-rn n2 rn (write-rn n1 value rm rfile))
            (if (equal (fix rm) (fix rn))
                (if (leq n2 n1)
                    (head value n2)
                  (replace n1 value (read-rn n2 rn rfile)))
              (read-rn n2 rn rfile))))

(prove-lemma write-write-rn (rewrite)
     (implies (leq n1 n2)
              (equal (write-rn n2 v2 rn (write-rn n1 v1 rn rfile))
                     (write-rn n2 v2 rn rfile))))

(prove-lemma write-rn-len (rewrite)
     (equal (len (write-rn oplen value rn rfile))
            (if (lessp rn (len rfile)) (len rfile) (add1 rn))))

(disable read-rn)
(disable write-rn)

;             THE BASIC READM-RN/WRITEM-RN EVENTS
;
(prove-lemma readm-rn-len (rewrite)
     (equal (len (readm-rn oplen rnlst rfile))
            (len rnlst)))

(defn get-vlst (oplen value rn rnlst vlst)
  (if (nlistp rnlst)
      value
    (if (equal (fix rn) (fix (car rnlst)))
        (get-vlst oplen (head (car vlst) oplen) rn (cdr rnlst) (cdr vlst))
      (get-vlst oplen value rn (cdr rnlst) (cdr vlst)))))

; we deliberately put on the hypothesis (numberp value) to restrict the use 
; of this lemma.  The dead loop situation is thereby avoided.
(prove-lemma get-vlst-member (rewrite)
     (implies (numberp value)
              (equal (get-vlst oplen value rn rnlst vlst)
                     (if (n-member rn rnlst)
                         (get-vlst oplen nil rn rnlst vlst)
                       value))))

; stop proving.
(defn read-writem-rn-end (n1 rn n2 vlst rnlst rfile)
  (read-rn n1 rn (writem-rn n2 vlst rnlst rfile)))

(prove-lemma read-writem-rn (rewrite)
     (equal (read-rn n1 rn (writem-rn n2 vlst rnlst rfile))
            (if (n-member rn rnlst)
                (if (and (leq n1 n2)
                         (leq n2 32))
                    (get-vlst n1 0 rn rnlst vlst)
                  (read-writem-rn-end n1 rn n2 vlst rnlst rfile))
              (read-rn n1 rn rfile)))
     ((induct (writem-rn n2 vlst rnlst rfile))))

(disable read-writem-rn-end)

(prove-lemma readm-write-rn (rewrite)
     (implies (not (n-member rn rnlst))
              (equal (readm-rn n1 rnlst (write-rn n2 value rn rfile))
                     (readm-rn n1 rnlst rfile))))

(prove-lemma read-rn-0 (rewrite)
     (implies (not (numberp rn))
              (equal (read-rn oplen rn rfile)
                     (read-rn oplen 0 rfile)))
     ((enable read-rn)))

(prove-lemma get-vlst-readm-rn (rewrite)
     (implies (leq n1 n2)
              (equal (get-vlst n1 0 rn rnlst (readm-rn n2 rnlst rfile))
                     (if (n-member rn rnlst)
                         (read-rn n1 rn rfile)
                       0))))

(disable read-rn-0)
(disable get-vlst-member)
(disable get-vlst)

;           THE BASIC READ-MEM/WRITE-MEM EVENTS
;
(prove-lemma pc-readp->readp (rewrite)
     (implies (pc-readp x n map)
              (readp x n map)))

(prove-lemma writep->readp (rewrite)
     (implies (writep x n map)
              (readp x n map)))

; a read right after a write at the same location returns the new value
; just writen.  But a read right after a write at a different location 
; has the same effect as a read made on the original binary tree.
(defn modn-eq (n x y)
  (if (zerop n)
      t
    (and (equal (bitn x (sub1 n)) (bitn y (sub1 n)))
         (modn-eq (sub1 n) x y))))

(prove-lemma read-write (rewrite)
     (equal (read y n (write value x n bt))
            (if (modn-eq n x y)
                value
              (read y n bt))))

; pc should always be able to go through the memory.
(prove-lemma pc-read-write (rewrite)
     (implies (and (writep x n map)
                   (pc-readp y n map))
              (equal (pc-read y n (write value x n bt))
                     (pc-read y n bt))))
 
; write twice at the same location is equivalent to the second write on
; the original binary tree.
(prove-lemma write-write-la ()
     (equal (write v2 y n (write v1 x n bt))
            (if (not (modn-eq n x y))
                (write v1 x n (write v2 y n bt))
              (write v2 y n bt))))

(prove-lemma write-write (rewrite)
     (equal (write v2 x n (write v1 x n bt))
            (write v2 x n bt)))

(disable pc-read)

(prove-lemma plus-times-equal (rewrite)
     (implies (and (lessp a k)
                   (lessp b k))
              (equal (equal (plus a (times i k)) (plus b (times j k)))
                     (and (equal (fix a) (fix b))
                          (equal (fix i) (fix j)))))
     ((induct (difference i j))))

(prove-lemma app-cancel (rewrite)
     (equal (equal (app n x y) (app n x1 y1))
            (and (equal (head x n) (head x1 n))
                 (equal (fix y) (fix y1))))
     ((enable app)))

(disable plus-times-equal)

(prove-lemma head-app-cancel (rewrite)
     (equal (equal (head x n) (app n x1 y1))
            (and (equal (head x n) (head x1 n))
                 (zerop y1)))
     ((use (app-cancel (y 0)))))

(prove-lemma head-recursion (rewrite)
     (equal (head x (add1 n))
            (app n (head x n) (bitn x n)))
     ((enable head bitn app tail bcar)))

(prove-lemma modn-eq-equal (rewrite)
     (equal (modn-eq n x y)
            (equal (head x n) (head y n))))

(prove-lemma ext-equal (rewrite)
     (implies (and (leq n size)
                   (not (zerop n)))
              (equal (equal (ext n x size) (ext n y size))
                     (equal (head x n) (head y n))))
     ((enable ext)))

(prove-lemma ext-equal-0 (rewrite)
     (implies (and (leq n size)
                   (not (zerop n)))
              (equal (equal (ext n x size) 0)
                     (equal (head x n) 0)))
     ((use (ext-equal (y 0)))))

(disable head-recursion)

;               BYTE-READ/BYTE-WRITE
;
; pc-byte-readp --> byte-readp.
(prove-lemma pc-byte-readp->byte-readp (rewrite)
     (implies (pc-byte-readp x mem)
              (byte-readp x mem)))

; byte-writep --> byte-readp.
(prove-lemma byte-writep->readp (rewrite)
     (implies (byte-writep x mem)
              (byte-readp x mem)))

(prove-lemma byte-read-write (rewrite)
     (equal (byte-read x (byte-write v y mem))
            (if (mod32-eq x y)
                (if (nat-rangep v 8) (fix v) (head v 8))
              (byte-read x mem))))

(prove-lemma byte-write-write-la ()
     (equal (byte-write v2 y (byte-write v1 x mem))
            (if (not (mod32-eq x y))
                (byte-write v1 x (byte-write v2 y mem))
              (byte-write v2 y mem)))
     ((use (write-write-la (v1 (head v1 8)) (v2 (head v2 8)) 
                           (n 32) (bt (cdr mem))))))

(prove-lemma byte-write-write (rewrite)
     (equal (byte-write v2 x (byte-write v1 x mem))
            (byte-write v2 x mem)))

(prove-lemma pc-byte-read-write (rewrite)
     (implies (and (byte-writep x mem)
                   (pc-byte-readp y mem))
              (equal (pc-byte-read y (byte-write value x mem))
                     (pc-byte-read y mem))))

; write on memory does not change the properties of the memory.
(prove-lemma byte-write-maintain-pc-byte-readp (rewrite)
     (equal (pc-byte-readp x (byte-write value y mem))
            (pc-byte-readp x mem)))

(prove-lemma byte-write-maintain-byte-readp (rewrite)
     (equal (byte-readp x (byte-write value y mem))
            (byte-readp x mem)))

(prove-lemma byte-write-maintain-byte-writep (rewrite)
     (equal (byte-writep x (byte-write value y mem))
            (byte-writep x mem)))

; a lemma useful to deal with read-mem/write-mem.
(prove-lemma byte-write-app (rewrite)
     (implies (leq 8 n)
              (equal (byte-write (app n x y) addr mem)
                     (byte-write x addr mem))))

(disable pc-byte-readp)
(disable byte-readp)
(disable byte-writep)
(disable pc-byte-read)
(disable byte-read)
(disable byte-write)

;             THE BASIC READ-MEM/WRITE-MEM EVENTS
(defn mem-induct0 (k n)
  (if (zerop k)
      0
    (mem-induct0 (sub1 k) (difference n 8))))

(prove-lemma pc-read-mem-nat-rangep (rewrite)
     (implies (equal n (times 8 k))
              (nat-rangep (pc-read-mem x mem k) n)))

(prove-lemma read-mem-nat-rangep (rewrite)
     (implies (leq (times 8 k) n)
              (nat-rangep (read-mem x mem k) n))
     ((induct (mem-induct0 k n))))

; write on memory does not change the properties of the memory. i.e. RAM is
; still RAM, ROM is still ROM, and UNAVAILABLE is still unavailable.
(prove-lemma write-mem-maintain-pc-byte-readp (rewrite)
     (equal (pc-byte-readp addr (write-mem value x mem k))
            (pc-byte-readp addr mem)))

(prove-lemma write-mem-maintain-byte-readp (rewrite)
     (equal (byte-readp addr (write-mem value x mem k))
            (byte-readp addr mem)))

(prove-lemma write-mem-maintain-byte-writep (rewrite)
     (equal (byte-writep addr (write-mem value x mem k))
            (byte-writep addr mem)))

(prove-lemma byte-write-maintain-pc-read-memp (rewrite)
     (equal (pc-read-memp addr (byte-write value x mem) n)
            (pc-read-memp addr mem n)))

(prove-lemma byte-write-maintain-read-memp (rewrite)
     (equal (read-memp addr (byte-write value x mem) n)
            (read-memp addr mem n)))

(prove-lemma byte-write-maintain-write-memp (rewrite)
     (equal (write-memp addr (byte-write value x mem) n)
            (write-memp addr mem n)))

(prove-lemma write-mem-maintain-pc-read-memp (rewrite)
     (equal (pc-read-memp addr (write-mem value x mem m) n)
            (pc-read-memp addr mem n)))

(prove-lemma write-mem-maintain-read-memp (rewrite)
     (equal (read-memp addr (write-mem value x mem m) n)
            (read-memp addr mem n)))

(prove-lemma write-mem-maintain-write-memp (rewrite)
     (equal (write-memp addr (write-mem value x mem m) n)
            (write-memp addr mem n)))

; if it is pc-readable, then it must be readable.
(prove-lemma pc-read-memp->read-memp (rewrite)
     (implies (pc-read-memp x mem n)
              (read-memp x mem n)))

; if it is writeable, then it must be readable.
(prove-lemma write-memp->read-memp (rewrite)
     (implies (write-memp x mem n)
              (read-memp x mem n)))

; program segments are never changed as the memory are changed.
(prove-lemma pc-byte-read-write-mem (rewrite)
     (implies (and (write-memp x mem n)
                   (pc-byte-readp y mem))
              (equal (pc-byte-read y (write-mem value x mem n))
                     (pc-byte-read y mem)))
     ((induct (write-mem value x mem n))))

(prove-lemma pc-read-mem-byte-write (rewrite)
     (implies (and (byte-writep x mem)
                   (pc-read-memp y mem n))
              (equal (pc-read-mem y (byte-write value x mem) n)
                     (pc-read-mem y mem n))))

(prove-lemma pc-read-mem-write-mem (rewrite)
     (implies (and (write-memp x mem m)
                   (pc-read-memp y mem n))
              (equal (pc-read-mem y (write-mem value x mem m) n)
                     (pc-read-mem y mem n))))

; a byte-read vs a multi-write.
; stop proving.
(defn byte-read-write-mem-end (x value y mem k)
  (byte-read x (write-mem value y mem k)))

(prove-lemma byte-read-write-mem (rewrite)
     (equal (byte-read x (write-mem value y mem k))
            (if (disjoint x 1 y k)
                (byte-read x mem)
              (byte-read-write-mem-end x value y mem k)))
     ((induct (write-mem value y mem k))))

; a multi-read vs a byte-write.
; stop proving.
(defn read-mem-byte-write-end (x n value y mem)
  (read-mem x (byte-write value y mem) n))

(prove-lemma read-mem-byte-write (rewrite)
     (equal (read-mem x (byte-write value y mem) n)
            (if (disjoint0 x n y)
                (read-mem x mem n)
              (read-mem-byte-write-end x n value y mem))))

; a multi-read vs a multi-write.
; stop proving.
(defn read-write-mem-end (x value y mem m n)
  (read-mem x (write-mem value y mem m) n))

(prove-lemma read-write-mem1 (rewrite)
     (equal (read-mem x (write-mem value y mem k) n)
            (if (disjoint x n y k)
                (read-mem x mem n)
              (read-write-mem-end x value y mem k n))))

(prove-lemma head-sub1-lessp (rewrite)
     (equal (lessp (sub1 (head x n)) x)
            (not (zerop x))))

(prove-lemma byte-read-write-mem-lemma (rewrite)
     (implies (and (nat-rangep y 32)
                   (leq n y))
              (equal (byte-read (add 32 x y) (write-mem value x mem n))
                     (byte-read (add 32 x y) mem)))
     ((induct (write-mem value x mem n))
      (enable nat-rangep)))

(prove-lemma read-write-mem2 (rewrite)
     (implies (uint-rangep n 32)
              (equal (read-mem x (write-mem value x mem n) n)
                     (head value (times 8 n))))
     ((induct (write-mem value x mem n))
      (enable nat-rangep) (disable read-write-mem1)))

(disable read-write-mem-end)
(disable read-mem-byte-write-end)
(disable byte-read-write-mem-end)

; write to the same location twice, only the second counts.
(prove-lemma write-mem-byte-write (rewrite)
     (equal (write-mem v2 y (byte-write v1 x mem) n)
            (if (disjoint0 y n x)
                (byte-write v1 x (write-mem v2 y mem n))
              (write-mem v2 y mem n)))
     ((induct (write-mem v2 y mem n))
      (use (byte-write-write-la (y (add 32 y (sub1 n)))))))

(defn write-write-induct (v1 v2 n)
  (if (zerop n)
      t
    (write-write-induct (tail v1 (b)) (tail v2 (b)) (sub1 n))))

(prove-lemma write-write-mem (rewrite)
     (equal (write-mem v2 x (write-mem v1 x mem n) n)
            (write-mem v2 x mem n))
     ((induct (write-write-induct v1 v2 n))))

;                LEMMAS ABOUT BITP
(prove-lemma bitp-fix-bit (rewrite)
     (implies (bitp x)
              (equal (fix-bit x) x)))
                             
(prove-lemma fix-bit-bitp (rewrite)
     (bitp (fix-bit b)))

(prove-lemma bitn-bitp (rewrite)
     (bitp (bitn x n)))

(prove-lemma add-c-bitp (rewrite)
     (bitp (add-c n x y)))

(prove-lemma add-v-bitp (rewrite)
     (bitp (add-v n x y)))

(prove-lemma add-z-bitp (rewrite)
     (bitp (add-z n x y)))
 
(prove-lemma add-n-bitp (rewrite)
     (bitp (add-n n x y)))

(prove-lemma addx-c-bitp (rewrite)
     (bitp (addx-c n x s d)))

(prove-lemma addx-v-bitp (rewrite)
     (bitp (addx-v n x s d)))

(prove-lemma addx-z-bitp (rewrite)
     (bitp (addx-z n z x s d)))

(prove-lemma addx-n-bitp (rewrite)
     (bitp (addx-n n x s d)))

(prove-lemma sub-c-bitp (rewrite)
     (bitp (sub-c n x y)))

(prove-lemma sub-v-bitp (rewrite)
     (bitp (sub-v n x y)))

(prove-lemma sub-z-bitp (rewrite)
     (bitp (sub-z n x y)))

(prove-lemma sub-n-bitp (rewrite)
     (bitp (sub-n n x y)))

(prove-lemma subx-c-bitp (rewrite)
     (bitp (subx-c n x s d)))

(prove-lemma subx-v-bitp (rewrite)
     (bitp (subx-v n x s d)))

(prove-lemma subx-z-bitp (rewrite)
     (bitp (subx-z n z x s d)))

(prove-lemma subx-n-bitp (rewrite)
     (bitp (subx-n n x s d)))

(prove-lemma and-z-bitp (rewrite)
     (bitp (and-z n s d)))

(prove-lemma and-n-bitp (rewrite)
     (bitp (and-n n s d)))

(prove-lemma mulu-v-bitp (rewrite)
     (bitp (mulu-v n s d i)))

(prove-lemma mulu-z-bitp (rewrite)
     (bitp (mulu-z n s d i)))

(prove-lemma mulu-n-bitp (rewrite)
     (bitp (mulu-n n s d i)))

(prove-lemma muls-v-bitp (rewrite)
     (bitp (muls-v n s d i)))

(prove-lemma muls-z-bitp (rewrite)
     (bitp (muls-z n s d i)))

(prove-lemma muls-n-bitp (rewrite)
     (bitp (muls-n n s d i)))

(prove-lemma or-z-bitp (rewrite)
     (bitp (or-z n s d)))

(prove-lemma or-n-bitp (rewrite)
     (bitp (or-n n s d)))

(prove-lemma divs-z-bitp (rewrite)
     (bitp (divs-z n s i d j)))

(prove-lemma divs-n-bitp (rewrite)
     (bitp (divs-n n s i d j)))

(prove-lemma divu-z-bitp (rewrite)
     (bitp (divu-z n s d)))

(prove-lemma divu-n-bitp (rewrite)
     (bitp (divu-n n s d)))

(prove-lemma rol-c-bitp (rewrite)
     (bitp (rol-c len x cnt)))

(prove-lemma rol-z-bitp (rewrite)
     (bitp (rol-z len x cnt)))

(prove-lemma rol-n-bitp (rewrite)
     (bitp (rol-n len x cnt)))

(prove-lemma ror-c-bitp (rewrite)
     (bitp (ror-c len x cnt)))

(prove-lemma ror-z-bitp (rewrite)
     (bitp (ror-z len x cnt)))

(prove-lemma ror-n-bitp (rewrite)
     (bitp (ror-n len x cnt)))

(prove-lemma lsl-c-bitp (rewrite)
     (bitp (lsl-c len x cnt)))

(prove-lemma lsl-z-bitp (rewrite)
     (bitp (lsl-z len x cnt)))

(prove-lemma lsl-n-bitp (rewrite)
     (bitp (lsl-n len x cnt)))

(prove-lemma lsr-c-bitp (rewrite)
     (bitp (lsr-c len x cnt)))

(prove-lemma lsr-z-bitp (rewrite)
     (bitp (lsr-z len x cnt)))

(prove-lemma lsr-n-bitp (rewrite)
     (bitp (lsr-n len x cnt)))

(prove-lemma asl-c-bitp (rewrite)
     (bitp (asl-c len x cnt)))

(prove-lemma asl-v-bitp (rewrite)
     (bitp (asl-v len x cnt)))

(prove-lemma asl-z-bitp (rewrite)
     (bitp (asl-z len x cnt)))

(prove-lemma asl-n-bitp (rewrite)
     (bitp (asl-n len x cnt)))

(prove-lemma asr-c-bitp (rewrite)
     (bitp (asr-c len x cnt)))

(prove-lemma asr-z-bitp (rewrite)
     (bitp (asr-z len x cnt)))

(prove-lemma asr-n-bitp (rewrite)
     (bitp (asr-n len x cnt)))

(prove-lemma roxl-c-bitp (rewrite)
     (bitp (roxl-c len opd cnt x)))

(prove-lemma roxl-z-bitp (rewrite)
     (bitp (roxl-z len opd cnt x))
     ((disable roxl)))

(prove-lemma roxl-n-bitp (rewrite)
     (bitp (roxl-n len opd cnt x))
     ((disable roxl)))

(prove-lemma roxr-c-bitp (rewrite)
     (bitp (roxr-c len opd cnt x)))

(prove-lemma roxr-z-bitp (rewrite)
     (bitp (roxr-z len opd cnt x))
     ((disable roxr)))

(prove-lemma roxr-n-bitp (rewrite)
     (bitp (roxr-n len opd cnt x))
     ((disable roxr)))

(prove-lemma move-z-bitp (rewrite)
     (bitp (move-z oplen sopd)))

(prove-lemma move-n-bitp (rewrite)
     (bitp (move-n oplen sopd)))

(prove-lemma ext-z-bitp (rewrite)
     (bitp (ext-z oplen opd size)))

(prove-lemma ext-n-bitp (rewrite)
     (bitp (ext-n oplen opd size)))

(prove-lemma swap-z-bitp (rewrite)
     (bitp (swap-z opd)))

(prove-lemma swap-n-bitp (rewrite)
     (bitp (swap-n opd)))

(prove-lemma not-z-bitp (rewrite)
     (bitp (not-z oplen opd)))

(prove-lemma not-n-bitp (rewrite)
     (bitp (not-n oplen opd)))

(prove-lemma eor-z-bitp (rewrite)
     (bitp (eor-z n s d)))

(prove-lemma eor-n-bitp (rewrite)
     (bitp (eor-n n s d)))

;                          NEG
; after replacing sub by add and neg.  We can completely get rid of sub.
(prove-lemma neg-head (rewrite)
     (equal (neg n (head x n)) (neg n x))
     ((enable sub)))

(prove-lemma neg-neg (rewrite)
     (equal (neg n (neg n x)) (head x n)))

(prove-lemma neg-cancel (rewrite)
     (equal (add n x (neg n x)) 0))
             
(prove-lemma neg-add (rewrite)
     (equal (neg n (add n x y))
            (add n (neg n x) (neg n y))))

(prove-lemma sub-neg (rewrite)
     (equal (sub n y x)
            (add n x (neg n y))))

(disable neg)

; x - y = 0 <==> x = y.
(prove-lemma add-neg-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (equal (add n y (neg n x)) 0)
                     (equal (fix x) (fix y))))
     ((use (sub-equal-0))))

; y + (x - y) = x.
(prove-lemma add-neg-cancel (rewrite)
     (and (equal (add n y (add n x (neg n y)))
                 (head x n))
          (equal (add n y (add n (neg n y) x))
                 (head x n))))

(prove-lemma sub-leq-1 (rewrite)
     (implies (leq (neg n x) y)
              (and (not (lessp (difference y (neg n x)) (add n y x)))
                   (not (lessp (difference y (neg n x)) (add n x y)))))
     ((use (sub-leq-la (x (neg n x))))))

(prove-lemma sub-leq-2 (rewrite)
     (implies (leq x y)
              (and (not (lessp (difference y x) (add n y (neg n x))))
                   (not (lessp (difference y x) (add n (neg n x) y)))))
     ((use (sub-leq-la))))

(defn add-fringe (n x)
  (if (and (listp x)
           (equal (car x) 'add)
           (equal (cadr x) n))
      (append (add-fringe n (caddr x))
              (add-fringe n (cadddr x)))
    (cons x nil)))
  
(defn add-tree (n l)
  (if (nlistp l)
      ''0
    (if (nlistp (cdr l))
        (list 'head (car l) n)
      (if (nlistp (cddr l))
          (list 'add n (car l) (cadr l))
        (list 'add n (car l) (add-tree n (cdr l)))))))

(prove-lemma numberp-eval$-add (rewrite)
     (implies (equal (car x) 'add)
              (numberp (eval$ t x a))))

(prove-lemma numberp-eval$-add-tree (rewrite)
     (numberp (eval$ t (add-tree n l) a)))

(prove-lemma add-equal-cancel-1 (rewrite) 
       (equal (equal (add n a b) (add n c (add n a d))) 
              (equal (head b n) (add n c d))))

(prove-lemma eval$-add-member (rewrite)
     (implies (member e x)
              (equal (eval$ t (add-tree n x) a)
                     (add (eval$ t n a)
                          (eval$ t e a)
                          (eval$ t (add-tree n (delete e x)) a)))))

(prove-lemma add-tree-nat-rangep (rewrite)
     (nat-rangep (eval$ t (add-tree n x) a) 
                 (eval$ t n a)))

(prove-lemma add-tree-append (rewrite)
     (equal (eval$ t (add-tree n (append x y)) a)
            (add (eval$ t n a)
                 (eval$ t (add-tree n x) a) 
                 (eval$ t (add-tree n y) a))))

(prove-lemma add-tree-add-fringe (rewrite)
     (equal (eval$ t (add-tree n (add-fringe n x)) a) 
            (head (eval$ t x a) (eval$ t n a)))
     ((induct (add-fringe n x))))

(defn add-tree-delete-cond (n x y)
  (list 'and 
        (list 'numberp x)
        (list 'and
              (list 'nat-rangep x n)
              (list 'equal (add-tree n (delete x y)) ''0))))
  
(prove-lemma add-tree-delete-equal (rewrite)
     (implies (member x y)
              (equal (eval$ t (add-tree-delete-cond n x y) a)
                     (equal (eval$ t (add-tree n y) a)
                            (eval$ t x a)))))

(prove-lemma add-tree-bagdiff (rewrite)
     (implies (and (subbagp x y)
                   (subbagp x z))
              (equal (equal (eval$ t (add-tree n (bagdiff y x)) a)
                            (eval$ t (add-tree n (bagdiff z x)) a))
                     (equal (eval$ t (add-tree n y) a)
                            (eval$ t (add-tree n z) a)))))

(defn cancel-equal-add (x)
  (if (and (listp x) (equal (car x) 'equal))
      (if (and (listp (cadr x)) (equal (caadr x) 'add)
               (listp (caddr x)) (equal (caaddr x) 'add))
          (if (equal (cadadr x) (cadaddr x))
              (list 'equal
                    (add-tree 
                     (cadadr x)
                     (bagdiff (add-fringe (cadadr x) (cadr x))
                              (bagint (add-fringe (cadadr x) (cadr x))
                                      (add-fringe (cadadr x) (caddr x)))))
                    (add-tree
                     (cadadr x)
                     (bagdiff (add-fringe (cadadr x) (caddr x))
                              (bagint (add-fringe (cadadr x) (cadr x))
                                      (add-fringe (cadadr x) (caddr x))))))
            x)
        (if (and (listp (cadr x)) (equal (caadr x) 'add)
                 (member (caddr x) (add-fringe (cadadr x) (cadr x))))
            (add-tree-delete-cond (cadadr x) 
                                  (caddr x) 
                                  (add-fringe (cadadr x) (cadr x)))
          (if (and (listp (caddr x)) (equal (caaddr x) 'add)
                   (member (cadr x) (add-fringe (cadaddr x) (caddr x))))
              (add-tree-delete-cond (cadaddr x) 
                                    (cadr x) 
                                    (add-fringe (cadaddr x) (caddr x)))
            x)))
    x))

(prove-lemma correctness-of-cancel-equal-add ((meta equal))
     (equal (eval$ t x a)
            (eval$ t (cancel-equal-add x) a))
     ((disable add-tree-delete-cond)))

(prove-lemma add-tree-delete (rewrite)
     (implies (member x y)
              (equal (eval$ t (add-tree n (delete x y)) a)
                     (sub (eval$ t n a)
                          (eval$ t x a)
                          (eval$ t (add-tree n y) a)))))

(defn cancel-add-neg (x)
  (if (and (listp x) 
           (equal (car x) 'add)
           (listp (cdr x))
           (listp (cddr x)))
      (if (and (listp (caddr x))
               (listp (cdaddr x))
               (listp (cddaddr x))
               (equal (caaddr x) 'neg)
               (equal (cadaddr x) (cadr x))
               (member (caddaddr x) (add-fringe (cadr x) (cadddr x))))
          (add-tree (cadr x) 
                    (delete (caddaddr x) (add-fringe (cadr x) (cadddr x))))
        (if (member (list 'neg (cadr x) (caddr x))
                    (add-fringe (cadr x) (cadddr x)))
            (add-tree (cadr x) 
                      (delete (list 'neg (cadr x) (caddr x))
                               (add-fringe (cadr x) (cadddr x))))
          x))
    x))

(prove-lemma correctness-of-cancel-add-neg ((meta add))
     (equal (eval$ t x a)
            (eval$ t (cancel-add-neg x) a)))

(compile-uncompiled-defns "tmp")

;                  CONDITION CODES
; this section considers the various condition codes in Bcc and Scc
; instructions. The condition codes are specified as follows:
;  CC  carry clear       ~C                 LS  low or same     C+Z
;  CS  carry set         C                  LT  less than       N*~V+~N*V
;  EQ  equal             Z                  MI  minus           N
;  F   never true        0                  NE  not equal       ~Z
;  GE  greater or equal  N*V+~N*~V          PL  plus            ~N
;  GT  greater than      N*V*~Z+~N*~V*~Z    T   always true     1
;  HI  high              ~C*~Z              VC  overflow clear  ~V
;  LE  less or equal     Z+N*~V+~N*V        VS  overflow set    V

;                           BHI/BLS
; two bridge lemmas.
; the relation between add-c and addx-c.
(prove-lemma add-addx-c (rewrite)
     (equal (add-c n x y) (addx-c n 0 x y))
     ((enable add-adder)))

; the relation between sub-c and subx-c.
(prove-lemma sub-subx-c (rewrite)
     (equal (sub-c n x y) (subx-c n 0 x y))
     ((enable add-adder subtracter sub-adder)
      (disable sub-neg)))

; two lemmas for addx-c and subx-c.
(prove-lemma addx-c-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c)
                   (not (zerop n)))
              (equal (addx-c n c x y)
                     (if (lessp (plus c x y) (exp 2 n)) 0 1)))
     ((enable nat-rangep adder-nat-la)))

(prove-lemma subx-c-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c)
                   (not (zerop n)))
              (equal (subx-c n c x y)
                     (if (lessp y (plus c x)) 1 0)))
     ((enable nat-rangep subtracter-nat-la)))

(disable addx-c)
(disable add-c)
(disable subx-c)
(disable sub-c)
(disable mbit-means-lessp)

(prove-lemma sub-z-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (sub-z n x y)
                     (if (equal (fix x) (fix y)) 1 0))))

(defn between-ileq (x y z)
  (and (ileq x y) (ileq y z)))

(prove-lemma sub-bhi-int (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n))
                   (not (negativep (nat-to-int x n))))
              (equal (bhi (sub-c n x y) (sub-z n x y))
                     (if (between-ileq 0 (nat-to-int y n) (nat-to-int x n))
                         0 1)))
     ((enable nat-to-int nat-rangep)))

(prove-lemma sub-bhi-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (lessp (nat-to-uint x) (nat-to-uint y)))
                   (not (zerop n)))
              (equal (bhi (sub-c n x y) (sub-z n x y)) 0)))

(prove-lemma sub-bhi-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (lessp (nat-to-uint x) (nat-to-uint y))
                   (not (zerop n)))
              (equal (bhi (sub-c n x y) (sub-z n x y)) 1)))

(prove-lemma sub-bls (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bls (sub-c n x y) (sub-z n x y))
                     (if (lessp (nat-to-uint x) (nat-to-uint y)) 0 1))))

; the trivial relation between bls and bhi.
(prove-lemma bls-bhi (rewrite)
     (equal (bls c z) (b-not (bhi c z))))
  
(disable bhi)
(disable bls)

;                          BEQ/BNE
; the z-flag of move.  
; the unsigned integer interpretation.
(prove-lemma move-beq-uint (rewrite)
     (implies (nat-rangep x n)
              (equal (beq (move-z n x))
                     (if (equal (nat-to-uint x) 0) 1 0))))

; the signed integer interpretation.
(prove-lemma move-beq-int-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (not (equal (nat-to-int x n) 0)))
              (equal (beq (move-z n x)) 0))
     ((enable nat-to-int)))

(prove-lemma move-beq-int-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (equal (nat-to-int x n) 0))
              (equal (beq (move-z n x)) 1))
     ((enable nat-to-int)))

; zero testing on a sign-extended bit vector is equivalent to 
; testing on the original value.
(prove-lemma move-beq-ext (rewrite)
     (implies (and (nat-rangep x n)
                   (leq n size)
                   (not (zerop n)))
              (equal (move-z size (ext n x size)) (move-z n x))))

; the z-flag of sub.  
; the unsigned integer interpretation.
(prove-lemma sub-beq-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (beq (sub-z n x y))
                     (if (equal (nat-to-uint x) (nat-to-uint y)) 1 0))))

; the signed integer interpretation.
(prove-lemma sub-beq-int-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (equal (nat-to-int x n) (nat-to-int y n))))
              (equal (beq (sub-z n x y)) 0)))

(prove-lemma sub-beq-int-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (equal (nat-to-int x n) (nat-to-int y n)))
              (equal (beq (sub-z n x y)) 1)))

; equality testing on two sign-extended bit vectors is equivalent to 
; testing on their original values.
(prove-lemma sub-beq-ext (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (leq n size)
                   (not (zerop n)))
              (equal (sub-z size (ext n x size) (ext n y size))
                     (sub-z n x y))))

; the z flag of logor.
(prove-lemma logor-beq-uint (rewrite)
     (equal (beq (or-z n x y))
            (if (and (equal (nat-to-uint x) 0) 
                     (equal (nat-to-uint y) 0))
                1 0)))

(prove-lemma logor-beq-int-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (or (not (equal (nat-to-int x n) 0))
                       (not (equal (nat-to-int y n) 0))))
              (equal (beq (or-z n x y)) 0))
     ((enable nat-to-int)))

(prove-lemma logor-beq-int-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (equal (nat-to-int x n) 0)
                   (equal (nat-to-int y n) 0))
              (equal (beq (or-z n x y)) 1))
     ((enable nat-to-int)))

; the z flag of logeor.
(prove-lemma logeor-beq-uint (rewrite)
     (equal (beq (eor-z n x y))
            (if (equal (nat-to-uint x) (nat-to-uint y)) 
                1 0)))

(prove-lemma logeor-beq-int-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (equal (nat-to-int x n) (nat-to-int y n))))
              (equal (beq (eor-z n x y)) 0))
     ((enable nat-to-int)))

(prove-lemma logeor-beq-int-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (equal (nat-to-int x n) (nat-to-int y n)))
              (equal (beq (eor-z n x y)) 1))
     ((enable nat-to-int nat-rangep)))

; the z flag of logand.
(prove-lemma logand-beq-uint (rewrite)
     (implies (equal (exp 2 (log 2 (add1 x))) (add1 x))
              (equal (beq (and-z n x y))
                     (if (equal (remainder (nat-to-uint y) (add1 x)) 0)
                         1 0)))
     ((use (logand-uint))
      (disable logand-uint)))

(prove-lemma logand-or-beq-uint (rewrite)
     (implies (equal (exp 2 (log 2 (add1 x))) (add1 x))
              (equal (beq (and-z n x (logor y z)))
                     (if (and (equal (remainder (nat-to-uint y) (add1 x)) 0)
                              (equal (remainder (nat-to-uint z) (add1 x)) 0))
                         1 0)))
     ((use (logand-uint) (logand-uint (y z)))
      (disable logand-uint)))
            
(prove-lemma logand-eor-beq-uint (rewrite)
     (implies (equal (exp 2 (log 2 (add1 x))) (add1 x))
              (equal (beq (and-z n x (logeor y z)))
                     (if (equal (remainder (nat-to-uint y) (add1 x))
                                (remainder (nat-to-uint z) (add1 x)))
                         1 0)))
     ((use (logand-uint) (logand-uint (y z)))
      (disable logand-uint)))

; the z-flag of mulu.  There are three cases to handle.
(prove-lemma mulu_1632-beq (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (beq (mulu-z 32 x y 16))
                     (if (or (equal (nat-to-uint x) 0)
                             (equal (nat-to-uint y) 0))
                         1 0)))
     ((use (mulu_1632-nat))))

(prove-lemma mulu_3264-beq (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (beq (mulu-z 64 x y 32))
                     (if (or (equal (nat-to-uint x) 0)
                             (equal (nat-to-uint y) 0))
                         1 0)))
     ((use (mulu_3264-nat))))

(prove-lemma mulu_3232-beq (rewrite)
     (implies (uint-rangep (times (nat-to-uint x) (nat-to-uint y)) 32)
              (equal (beq (mulu-z 32 x y 32))
                     (if (or (equal (nat-to-uint x) 0)
                             (equal (nat-to-uint y) 0))
                         1 0)))
     ((enable nat-rangep)))

; the z-flag of muls.  There are three cases to handle.
(prove-lemma muls_1632-beq (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (beq (muls-z 32 x y 16))
                     (if (or (equal (nat-to-int x 16) 0)
                             (equal (nat-to-int y 16) 0))
                         1 0)))
     ((use (muls_1632-int))))

(prove-lemma muls_3264-beq (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (beq (muls-z 64 x y 32))
                     (if (or (equal (nat-to-int x 32) 0)
                             (equal (nat-to-int y 32) 0))
                         1 0)))
     ((use (muls_3264-int))))

(prove-lemma muls_3232-beq (rewrite)
     (implies (and (int-rangep (itimes (nat-to-int x 32) (nat-to-int y 32)) 32)
                   (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (beq (muls-z 32 x y 32))
                     (if (or (equal (nat-to-int x 32) 0)
                             (equal (nat-to-int y 32) 0))
                         1 0)))
     ((use (muls_3232-int))))

; the z-flag of divu.
(prove-lemma divu-beq (rewrite)
     (implies (and (nat-rangep y n)
                   (not (equal (nat-to-uint x) 0)))
              (equal (beq (divu-z n x y))
                     (if (lessp (nat-to-uint y) (nat-to-uint x)) 1 0))))

; the z-flag of divs.
(prove-lemma iquotient=0 (rewrite)
     (implies (and (integerp y)
                   (not (equal y 0)))
              (equal (equal (iquotient x y) 0)
                     (lessp (abs x) (abs y))))
     ((enable integerp iquotient)))

(prove-lemma divs-beq (rewrite)
     (implies (and (int-rangep (iquotient (nat-to-int y j) (nat-to-int x i)) n)
                   (nat-rangep x i)
                   (not (equal (nat-to-int x i) 0))
                   (leq n j))
              (equal (beq (divs-z n x i y j))
                     (if (lessp (abs (nat-to-int y j)) 
                                (abs (nat-to-int x i)))
                         1 0)))
     ((enable head-int-crock)))

; the z-flag of lsl.
(prove-lemma lsl-beq (rewrite)
     (implies (uint-rangep (nat-to-uint x) (difference n cnt))
              (equal (beq (lsl-z n x cnt))
                     (if (equal (nat-to-uint x) 0) 1 0)))
     ((enable nat-rangep)))

; the z-flag of lsr.
(prove-lemma lsr-beq (rewrite)
     (equal (beq (lsr-z n x cnt))
            (if (lessp (nat-to-uint x) (exp 2 cnt)) 1 0))
     ((enable nat-rangep)))

(prove-lemma z-flag-la ()
     (implies (numberp x)
              (equal (equal (nat-to-int x n) 0)
                     (equal x 0)))
     ((enable nat-to-int)))

; the z-flag of asl.
(prove-lemma asl-beq (rewrite)
     (implies (and (nat-rangep x n)
                   (int-rangep (nat-to-int x n) (difference n cnt)))
              (equal (beq (asl-z n x cnt))
                     (if (equal (nat-to-int x n) 0) 1 0)))
     ((use (z-flag-la (x (asl n x cnt))))
      (disable asl)))
                        
; the z-flag of asr.
(prove-lemma asr-beq (rewrite)
     (implies (nat-rangep x n)
              (equal (beq (asr-z n x cnt))
                     (if (negativep (nat-to-int x n))
                         0
                       (if (lessp (nat-to-int x n) (exp 2 cnt))
                           1 0))))
     ((use (z-flag-la (x (asr n x cnt))))
      (enable iplus iquotient iremainder)
      (disable asr)))

; the z-flag of ext.
(prove-lemma ext-beq-uint (rewrite)
     (implies (and (nat-rangep x n)
                   (leq n size))
              (equal (beq (ext-z n x size))
                     (if (equal (nat-to-uint x) 0) 1 0)))
     ((enable app ext nat-rangep mbit-means-lessp)))
     
(prove-lemma ext-beq-int-0 (rewrite)
     (implies (and (nat-rangep x n)
                   (lessp n size)
                   (not (equal (nat-to-int x n) 0)))
              (equal (beq (ext-z n x size)) 0))
     ((use (z-flag-la (x (ext n x size)) (n size)))))

(prove-lemma ext-beq-int-1 (rewrite)
     (implies (and (nat-rangep x n)
                   (lessp n size)
                   (equal (nat-to-int x n) 0))
              (equal (beq (ext-z n x size)) 1))
     ((use (z-flag-la (x (ext n x size)) (n size)))))
      
(disable iquotient=0)
(disable int-to-nat=0)
(disable beq)

;                         BCS/BCC
; BCS/BCC means carry is set/cleared.
; the c-flag of sub.
(prove-lemma sub-bcs&cc (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bcs (sub-c n x y))
                     (if (lessp (nat-to-uint y) (nat-to-uint x)) 1 0))))

; the c-flag of add.
(prove-lemma add-bcs&cc (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bcs (add-c n x y))
                     (if (lessp (plus (nat-to-uint x) (nat-to-uint y))
                                (exp 2 n)) 
                         0 1))))

(prove-lemma tail-mbit (rewrite)
     (implies (lessp x (exp 2 n))
              (equal (tail x (sub1 n))
                     (if (lessp x (exp 2 (sub1 n))) 0 1)))
     ((enable tail)))

; the c-flag of lsl.  But we only consider special cases: cnt = 0 or 1.  
; I don't know what the meaning of c-flag is when cnt > 1. 
(prove-lemma lsl-c-0 (rewrite)
     (equal (lsl-c n x 0) 0))

(prove-lemma lsl-1-bcs&cc (rewrite)
     (implies (and (nat-rangep x n)
                   (lessp 1 n))
              (equal (bcs (lsl-c n x 1))
                     (if (uint-rangep (nat-to-uint x) (sub1 n)) 0 1)))
     ((enable bitn nat-rangep)))

; the c-flag of lsr.  But we only consider special cases: cnt = 0 or 1.
; I don't know what the meaning of c-flag is when cnt > 1.
(prove-lemma lsr-c-0 (rewrite)
     (equal (lsr-c n x 0) 0))

(prove-lemma lsr-1-bcs&cc (rewrite)
     (implies (lessp 1 n)
              (equal (bcs (lsr-c n x 1))
                     (remainder (nat-to-uint x) 2)))
     ((enable bitn bcar)))

(disable tail-mbit)
(disable bcs)

;                       BVS/BVC
; BVS/BVC means overflow is set/cleared.
; three bridge lemmas.
(prove-lemma add-addx-v (rewrite)
     (equal (add-v n x y) (addx-v n 0 x y))
     ((enable add-adder)))

(prove-lemma subx-addx-v (rewrite)
     (implies (and (nat-rangep x n)
                   (not (zerop n)))
              (equal (subx-v n z x y)
                     (addx-v n (b-not z) y (lognot n x))))
     ((enable subtracter)))

(prove-lemma sub-subx-v (rewrite)
     (equal (sub-v n x y) (subx-v n 0 x y))
     ((enable add-adder subtracter sub-adder)
      (disable sub-neg)))

; lemmas for addx-v and subx-v.
(prove-lemma mbit-means-negativep (rewrite)
     (implies (nat-rangep x n)
              (equal (bitn x (sub1 n)) 
                     (if (negativep (nat-to-int x n)) 1 0)))
     ((enable nat-to-int bitn bcar tail nat-rangep)))

(prove-lemma addx-v-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c)
                   (not (zerop n)))
              (equal (addx-v n c x y)
                     (if (int-rangep (iplus (nat-to-int x n)
                                            (iplus (nat-to-int y n) c))
                                     n)
                         0 1)))
     ((disable bitp iplus-commutativity iplus-commutativity1)))

(prove-lemma subx-v-la (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (bitp c)
                   (not (zerop n)))
              (equal (subx-v n c x y)
                     (if (int-rangep (idifference (nat-to-int y n)
                                                  (iplus (nat-to-int x n) c))
                                     n)
                         0 1))))

(disable addx-v-crock1)
(disable addx-v-crock2)

; the v-flag of sub.
(prove-lemma sub-bvs&vc (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bvs (sub-v n x y))
                     (if (int-rangep (idifference (nat-to-int y n)
                                                  (nat-to-int x n))
                                     n)
                         0 1))))

; the v-flag of add.
(prove-lemma add-bvs&vc (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bvs (add-v n x y))
                     (if (int-rangep (iplus (nat-to-int x n) (nat-to-int y n))
                                     n)
                         0 1))))

; three cases for the v-flag of mulu.
(prove-lemma mulu_1632-bvs (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (mulu-v 32 x y 16) 0))
     ((use (times-lessp_1 (x1 (exp 2 16)) (y1 (exp 2 16))))
      (enable nat-rangep)))

(prove-lemma mulu_3264-bvs (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (mulu-v 64 x y 32) 0))
     ((use (times-lessp_1 (x1 (exp 2 32)) (y1 (exp 2 32))))
      (enable nat-rangep)))

(prove-lemma mulu_3232-bvs (rewrite)
     (equal (bvs (mulu-v 32 x y 32))
            (if (lessp (times (nat-to-uint x) (nat-to-uint y)) (exp 2 32))
                0 1)))

; three cases for the v-flag of muls.
(prove-lemma muls_1632-bvs (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (muls-v 32 x y 16) 0))
     ((use (muls-crock (x (nat-to-int x 16)) (y (nat-to-int y 16)) (n 16)))))

(prove-lemma muls_3264-bvs (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (muls-v 64 x y 32) 0))
     ((use (muls-crock (x (nat-to-int x 32)) (y (nat-to-int y 32)) (n 32)))))

(prove-lemma muls_3232-bvs (rewrite)
     (equal (bvs (muls-v 32 x y 32))
            (if (int-rangep (itimes (nat-to-int x 32) (nat-to-int y 32)) 32)
                0 1)))

; the v-flag of asl.  It is an easy copy of the definition of asl-v.
; sometimes, it seems to be better to define those functions directly
; using the intended meaning.  But there are several problems:
; 1. the meaning is not completely clear. It is vague.
; 2. it is impossible to have a clean definition. 
; 3. it is error prone. It does not always work the way you think.
;    Your intended interpretation is just a special case.
; In some sense,  a formal specification should be more syntax-oriented.
; syntax rules are clear and accurate. e.g. M68000 are well-documented.
; But it gives one a hard time to do formal proofs.  We need to assign 
; meanings to these definitions.  To make sure our "intended" meanings
; are consistent with the specification, we need to prove the equivalence.
; this is done formally by a theorem prover, and sometimes, is very hard.
(prove-lemma asl-bvs (rewrite)
     (equal (bvs (asl-v n x cnt))
            (if (int-rangep (nat-to-int x n) (difference n cnt)) 
                0 1)))

(disable bvs)

;                      BMI/BPL
; the n-flag of move.
(prove-lemma move-bmi (rewrite)
     (implies (nat-rangep x n)
              (equal (bmi (move-n n x))
                     (if (negativep (nat-to-int x n))
                         1 0))))

; the n-flag of sub.
(prove-lemma sub-bmi (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bmi (sub-n n x y))
                     (if (int-rangep (idifference (nat-to-int y n)
                                                  (nat-to-int x n))
                                     n)
                         (if (ilessp (nat-to-int y n) (nat-to-int x n)) 1 0)
                       (if (ilessp (nat-to-int y n) (nat-to-int x n)) 0 1))))
     ((disable idifference ilessp iplus-commutativity)))

; the n-flag of add.
(prove-lemma add-bmi (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bmi (add-n n x y))
                     (if (int-rangep (iplus (nat-to-int x n) (nat-to-int y n))
                                     n)
                         (if (negativep (iplus (nat-to-int x n) 
                                               (nat-to-int y n)))
                             1 0)
                       (if (negativep (nat-to-int x n)) 0 1))))
     ((disable iplus-commutativity)))

; the n-flag of muls.  There are three cases to handle.
(prove-lemma muls_1632-bmi (rewrite)
     (implies (and (nat-rangep x 16)
                   (nat-rangep y 16))
              (equal (bmi (muls-n 32 x y 16))
                     (if (or (equal (nat-to-int x 16) 0)
                             (equal (nat-to-int y 16) 0))
                         0
                       (if (negativep (nat-to-int x 16))
                           (if (negativep (nat-to-int y 16))
                               0 1)
                         (if (negativep (nat-to-int y 16))
                             1 0)))))
     ((use (mbit-means-negativep (x (muls 32 x y 16)) (n 32)))
      (disable muls)))

(prove-lemma muls_3264-bmi (rewrite)
     (implies (and (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (bmi (muls-n 64 x y 32))
                     (if (or (equal (nat-to-int x 32) 0)
                             (equal (nat-to-int y 32) 0))
                         0
                       (if (negativep (nat-to-int x 32))
                           (if (negativep (nat-to-int y 32)) 0 1)
                         (if (negativep (nat-to-int y 32)) 1 0)))))
     ((use (mbit-means-negativep (x (muls 64 x y 32)) (n 64)))
      (disable muls)))

(prove-lemma muls_3232-bmi (rewrite)
     (implies (and (int-rangep (itimes (nat-to-int x 32) (nat-to-int y 32)) 32)
                   (nat-rangep x 32)
                   (nat-rangep y 32))
              (equal (bmi (muls-n 32 x y 32))
                     (if (or (equal (nat-to-int x 32) 0)
                             (equal (nat-to-int y 32) 0))
                         0
                       (if (negativep (nat-to-int x 32))
                           (if (negativep (nat-to-int y 32))
                               0 1)
                         (if (negativep (nat-to-int y 32))
                             1 0)))))
     ((use (mbit-means-negativep (x (muls 32 x y 32)) (n 32)))
      (disable muls)))

; the n-flag of asl.                 
(prove-lemma asl-bmi (rewrite)
     (implies (and (nat-rangep x n)
                   (int-rangep (nat-to-int x n) (difference n cnt)))
              (equal (bmi (asl-n n x cnt))
                     (if (negativep (nat-to-int x n)) 1 0)))
     ((disable asl)))

; the n-flag of asr.
(prove-lemma asr-bmi (rewrite)
     (implies (nat-rangep x n)
              (equal (bmi (asr-n n x cnt))
                     (if (negativep (nat-to-int x n))
                         1 0)))
     ((enable iplus iquotient iremainder)
      (disable asr)))

; the n-flag of ext.
(prove-lemma ext-bmi (rewrite)
     (implies (and (nat-rangep x n)
                   (lessp n size))
              (equal (bmi (ext-n n x size))
                     (if (negativep (nat-to-int x n)) 1 0))))
              
;                   BGE/BLT
(prove-lemma bge-v0 (rewrite)
     (equal (bge 0 n) (b-not (bmi n))))

(prove-lemma blt-v0 (rewrite)
     (equal (blt 0 n) (bmi n)))

; bge of sub.
(prove-lemma sub-bge (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bge (sub-v n x y) (sub-n n x y))
                     (if (ilessp (nat-to-int y n) (nat-to-int x n))
                         0 1)))
     ((disable ilessp idifference iplus-commutativity)))

; blt of sub.
(prove-lemma sub-blt (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (blt (sub-v n x y) (sub-n n x y))
                     (if (ilessp (nat-to-int y n) (nat-to-int x n)) 
                         1 0)))
     ((disable ilessp idifference iplus-commutativity)))

; the trivial relation between BGE and BLT.
(prove-lemma blt-bge (rewrite)
     (equal (blt v n) (b-not (bge v n))))

(disable bge)
(disable blt)

;                       BGT/BLE
(prove-lemma sub-z-la1 (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n))
              (equal (sub-z n x y)
                     (if (equal (nat-to-int x n) (nat-to-int y n))
                         1 0))))

(disable sub-z)

; bgt of sub.
(prove-lemma sub-bgt (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (bgt (sub-v n x y) (sub-z n x y) (sub-n n x y))
                     (if (ilessp (nat-to-int x n) (nat-to-int y n))
                         1 0)))
     ((disable idifference iplus-commutativity nat-to-int=)))

; ble of sub.
(prove-lemma sub-ble (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (zerop n)))
              (equal (ble (sub-v n x y) (sub-z n x y) (sub-n n x y))
                     (if (ilessp (nat-to-int x n) (nat-to-int y n))
                         0 1)))
     ((disable idifference iplus-commutativity nat-to-int=)))

; bgt of move.
(prove-lemma move-bgt (rewrite)
     (implies (nat-rangep x n)
              (equal (bgt 0 (move-z n x) (move-n n x))
                     (if (lessp 0 (nat-to-int x n)) 1 0)))
     ((enable nat-to-int)))

; ble of move.
(prove-lemma move-ble (rewrite)
     (implies (nat-rangep x n)
              (equal (ble 0 (move-z n x) (move-n n x))
                     (if (lessp 0 (nat-to-int x n)) 0 1)))
     ((enable nat-to-int)))

; the trivial relation between ble and bgt.
(prove-lemma ble-bgt (rewrite)
     (equal (ble v z n) (b-not (bgt v z n))))

(disable ble)
(disable bgt)

; the end of this subsection.  Some lemmas should be disabled, for we 
; no longer need them.
(disable mbit-means-negativep)
(disable bmi)
(disable add-addx-c)
(disable sub-subx-c)
(disable addx-c-la)
(disable subx-c-la)
(disable add-addx-v)
(disable subx-addx-v)
(disable sub-subx-v)
(disable addx-v-la)
(disable subx-v-la)
(disable sub-z-la)
(disable sub-z-la1)
(disable ilessp-crock1)
(disable ilessp-crock2)
(disable add-bmi-crock1)
(disable add-bmi-crock2)
(disable nat-to-int=)

;                          STEPN
; stepping the state s (m+n) steps is equivalent to stepping s m steps and
; n steps further.
(defn splus (x y) (plus x y))

(prove-lemma stepn-lemma (rewrite)
     (equal (stepn s (splus m n))
            (stepn (stepn s m) n))
     ((disable stepi)))

(prove-lemma stepn-rewriter0 (rewrite)
     (equal (stepn s 0) s))

(prove-lemma stepn-rewriter (rewrite)
     (implies (equal (mc-status s) 'running)
              (equal (stepn s (add1 n))
                     (stepn (stepi s) n)))
     ((disable stepi)))

;                     THEOREMS ABOUT THE MEMORY
; if a portion of memory is ROM, then it still is ROM after a write on memory.
(prove-lemma byte-write-maintain-rom-addrp (rewrite)
     (equal (rom-addrp addr (byte-write value x mem) n)
            (rom-addrp addr mem n)))

(prove-lemma write-mem-maintain-rom-addrp (rewrite)
     (equal (rom-addrp addr (write-mem value x mem m) n)
            (rom-addrp addr mem n)))

; if a portion of memory is RAM, then it still is RAM after a write on memory.
(prove-lemma byte-write-maintain-ram-addrp (rewrite)
     (equal (ram-addrp addr (byte-write value x mem) n)
            (ram-addrp addr mem n)))

(prove-lemma write-mem-maintain-ram-addrp (rewrite)
     (equal (ram-addrp addr (write-mem value x mem m) n)
            (ram-addrp addr mem n)))

; mcode-addrp claims that the machine code program lst is stored in the 
; memory starting at addr.
(defn mcode-addrp (addr mem lst)
  (if (listp lst)
      (if (equal (car lst) -1)
          (mcode-addrp (add 32 addr 1) mem (cdr lst))
        (and (equal (pc-byte-read addr mem) (car lst))
             (mcode-addrp (add 32 addr 1) mem (cdr lst))))
    t))

(prove-lemma add-non-numberp (rewrite)
     (implies (not (numberp i))
              (equal (add n x i) (head x n)))
     ((enable add head)))

(prove-lemma add-plus (rewrite)
     (equal (add n x (add n y z))
            (add n x (plus y z)))
     ((enable add)))

; four lemmas about pc-read-memp.
(prove-lemma pc-read-memp-la0 (rewrite)
     (implies (and (pc-read-memp addr mem k)
                   (not (zerop k)))
              (pc-byte-readp addr mem)))

(prove-lemma pc-read-memp-la1 (rewrite)
     (implies (and (pc-read-memp addr mem k)
                   (lessp j k))
              (pc-byte-readp (add 32 addr j) mem)))

(prove-lemma pc-read-memp-la2 (rewrite)
     (implies (and (pc-read-memp addr mem k)
                   (leq j k))
              (pc-read-memp addr mem j))
     ((use (pc-read-memp-la1 (j (sub1 j))))))

(prove-lemma pc-read-memp-la3 (rewrite)
     (implies (and (pc-read-memp addr mem k)
                   (leq (plus i j) k))
              (pc-read-memp (add 32 addr i) mem j))
     ((induct (pc-read-memp addr mem j))))

(prove-lemma write-memp-la0 (rewrite)
     (implies (and (write-memp addr mem n)
                   (not (zerop n)))
              (byte-writep addr mem)))

(prove-lemma write-memp-la1 (rewrite)
     (implies (and (write-memp addr mem n)
                   (lessp m n))
              (byte-writep (add 32 addr m) mem)))

(prove-lemma write-memp-la2 (rewrite)
     (implies (and (write-memp addr mem n)
                   (leq m n))
              (write-memp addr mem m))
     ((use (write-memp-la1 (m (sub1 m))))))

(prove-lemma write-memp-la3 (rewrite)
     (implies (and (write-memp addr mem n)
                   (leq (plus i j) n))
              (write-memp (add 32 addr i) mem j))
     ((induct (write-memp addr mem j))))

(disable add-plus)

; array index.  There are some good reasons to distinguish this concept
; with add and sub.
(defn index-n (x y)
  (sub 32 y x))

; ROM is pc-readable.
(prove-lemma pc-byte-readp-rom0 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (not (zerop k)))
              (pc-byte-readp addr mem)))

(prove-lemma pc-byte-readp-rom1 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (lessp j k))
              (pc-byte-readp (add 32 addr j) mem)))

(prove-lemma pc-byte-readp-rom2 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (lessp (index-n 0 i) k))
              (pc-byte-readp addr mem)))

(prove-lemma pc-byte-readp-rom3 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (lessp (index-n j i) k))
              (pc-byte-readp (add 32 addr j) mem))
     ((use (pc-byte-readp-rom1 (addr (add 32 addr i)) (j (index-n j i))))))

(prove-lemma pc-read-memp-rom0 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (leq j k))
              (pc-read-memp addr mem j)))

(prove-lemma pc-read-memp-rom1 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (leq (plus i j) k))
              (pc-read-memp (add 32 addr i) mem j)))

(prove-lemma pc-read-memp-rom2 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n 0 i) j) k))
              (pc-read-memp addr mem j))
     ((use (pc-read-memp-rom1 (addr (add 32 addr i)) (i (index-n 0 i))))))

(prove-lemma pc-read-memp-rom3 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n h i) j) k))
              (pc-read-memp (add 32 addr h) mem j))
     ((use (pc-read-memp-rom1 (addr (add 32 addr i)) (i (index-n h i))))))

; starting at the same address, a portion of the memory is ROM if a bigger
; portion of the memory is ROM.
(prove-lemma rom-addrp-la1 (rewrite)
     (implies (and (rom-addrp addr mem n)
                   (leq m n))
              (rom-addrp addr mem m)))

; a portion of the memory is also ROM, if a bigger portion of the memory
; is ROM.
(prove-lemma rom-addrp-la2 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (leq (plus j (index-n x addr)) k))
              (rom-addrp x mem j))
     ((use (pc-read-memp-la3 (i (index-n x addr))))))

(disable rom-addrp)

; ROM is readable.
(prove-lemma byte-readp-rom0 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (not (zerop k)))
              (byte-readp addr mem)))

(prove-lemma byte-readp-rom1 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (lessp j k))
              (byte-readp (add 32 addr j) mem)))

(prove-lemma byte-readp-rom2 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (lessp (index-n 0 i) k))
              (byte-readp addr mem)))

(prove-lemma byte-readp-rom3 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (lessp (index-n j i) k))
              (byte-readp (add 32 addr j) mem)))

(prove-lemma read-memp-rom0 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (leq j k))
              (read-memp addr mem j)))

(prove-lemma read-memp-rom1 (rewrite)
     (implies (and (rom-addrp addr mem k)
                   (leq (plus i j) k))
              (read-memp (add 32 addr i) mem j)))

(prove-lemma read-memp-rom2 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n 0 i) j) k))
              (read-memp addr mem j)))

(prove-lemma read-memp-rom3 (rewrite)
     (implies (and (rom-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n h i) j) k))
              (read-memp (add 32 addr h) mem j)))

; integer view.
(prove-lemma read-memp-rom1-int (rewrite)
     (implies (and (rom-addrp addr mem n)
                   (lessp (plus (nat-to-int x 32) j) n)
                   (numberp (nat-to-int x 32)))
              (read-memp (add 32 addr x) mem j))
     ((enable nat-to-int)))

; RAM is writable.
(prove-lemma byte-writep-ram0 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (not (zerop k)))
              (byte-writep addr mem)))

(prove-lemma byte-writep-ram1 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (lessp j k))
              (byte-writep (add 32 addr j) mem)))

(prove-lemma byte-writep-ram2 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (lessp (index-n 0 i) k))
              (byte-writep addr mem)))

(prove-lemma byte-writep-ram3 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (lessp (index-n j i) k))
              (byte-writep (add 32 addr j) mem))
     ((use (byte-writep-ram1 (addr (add 32 addr i)) (j (index-n j i))))))

(prove-lemma write-memp-ram0 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq j k))
              (write-memp addr mem j)))

(prove-lemma write-memp-ram1 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq (plus i j) k))
              (write-memp (add 32 addr i) mem j)))

(prove-lemma write-memp-ram1-int (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (numberp (nat-to-int i 32))
                   (leq (plus (nat-to-int i 32) j) k))
              (write-memp (add 32 addr i) mem j))
     ((enable nat-to-int)))

(prove-lemma write-memp-ram2 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n 0 i) j) k))
              (write-memp addr mem j))
     ((use (write-memp-ram1 (addr (add 32 addr i)) (i (index-n 0 i))))))

(prove-lemma write-memp-ram3 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n h i) j) k))
              (write-memp (add 32 addr h) mem j))
     ((use (write-memp-ram1 (addr (add 32 addr i)) (i (index-n h i))))))

; a portion of a memory is also RAM, if a "bigger" portion of the memory 
; is RAM.
(prove-lemma ram-addrp-la1 (rewrite)
     (implies (and (ram-addrp addr mem n)
                   (leq m n))
              (ram-addrp addr mem m)))

(prove-lemma ram-addrp-la2 (rewrite)
     (implies (and (ram-addrp addr mem n)
                   (leq (plus j (index-n x addr)) n))
              (ram-addrp x mem j))
     ((use (write-memp-la3 (i (index-n x addr))))))

(disable ram-addrp)

; RAM is readable.
(prove-lemma byte-readp-ram0 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (not (zerop k)))
              (byte-readp addr mem)))

(prove-lemma byte-readp-ram1 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (lessp j k))
              (byte-readp (add 32 addr j) mem)))

(prove-lemma byte-readp-ram2 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (lessp (index-n 0 i) k))
              (byte-readp addr mem)))

(prove-lemma byte-readp-ram3 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (lessp (index-n j i) k))
              (byte-readp (add 32 addr j) mem)))

(prove-lemma read-memp-ram0 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq j k))
              (read-memp addr mem j)))

(prove-lemma read-memp-ram1 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq (plus i j) k))
              (read-memp (add 32 addr i) mem j)))

(prove-lemma read-memp-ram1-int (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (numberp (nat-to-int i 32))
                   (leq (plus (nat-to-int i 32) j) k))
              (read-memp (add 32 addr i) mem j))
     ((enable nat-to-int)))

(prove-lemma read-memp-ram2 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n 0 i) j) k))
              (read-memp addr mem j)))

(prove-lemma read-memp-ram3 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n h i) j) k))
              (read-memp (add 32 addr h) mem j)))

; please use the right induction.
(defn mem-induct1 (i addr lst)
  (if (zerop i)
      t
    (mem-induct1 (sub1 i) (add 32 addr 1) (cdr lst))))

;            OBTAIN MACHINE CODE FROM MEMORY
; please read the right thing.
(prove-lemma pc-byte-read-mcode0 (rewrite)
     (implies (and (mcode-addrp addr mem (cons x lst))
                   (not (equal x -1)))
              (equal (pc-byte-read addr mem) x)))

(prove-lemma pc-byte-read-mcode1 (rewrite)
     (implies (and (mcode-addrp addr mem lst)
                   (lessp i (len lst))
                   (not (equal (get-nth i lst) -1)))
              (equal (pc-byte-read (add 32 addr i) mem)
                     (get-nth i lst)))
     ((induct (mem-induct1 i addr lst))
      (enable add-plus)))

(prove-lemma pc-byte-read-mcode2 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst)
                   (lessp (index-n 0 i) (len lst))
                   (not (equal (get-nth (index-n 0 i) lst) -1)))
              (equal (pc-byte-read addr mem)
                     (get-nth (index-n 0 i) lst)))
     ((use (pc-byte-read-mcode1 (addr (add 32 addr i)) (i (index-n 0 i))))))

(prove-lemma pc-byte-read-mcode3 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst) 
                   (lessp (index-n j i) (len lst))
                   (not (equal (get-nth (index-n j i) lst) -1)))
              (equal (pc-byte-read (add 32 addr j) mem)
                     (get-nth (index-n j i) lst)))
     ((use (pc-byte-read-mcode1 (addr (add 32 addr i)) (i (index-n j i))))))

(defn lst-numberp0 (lst n)
  (if (zerop n)
      0
    (and (numberp (get-nth (sub1 n) lst))
         (lst-numberp0 lst (sub1 n)))))

(defn read-lst0 (lst n)
  (if (zerop n)
      0
    (app (b)
         (get-nth (sub1 n) lst)
         (read-lst0 lst (sub1 n)))))

(defn tail-lst (lst n)
  (if (zerop n)
      lst
    (tail-lst (cdr lst) (sub1 n))))

(defn lst-numberp (m lst n)
  (lst-numberp0 (tail-lst lst m) n))

(defn read-lst (m lst n)
  (read-lst0 (tail-lst lst m) n))

(prove-lemma get-nth-tail-lst (rewrite)
     (equal (get-nth n (tail-lst x m))
            (get-nth (plus m n) x)))

(prove-lemma pc-read-mem-mcode0 (rewrite)
     (implies (and (mcode-addrp addr mem lst)
                   (leq j (len lst))
                   (lst-numberp 0 lst j))
              (equal (pc-read-mem addr mem j)
                     (read-lst 0 lst j))))

(prove-lemma pc-read-mem-mcode1 (rewrite)
     (implies (and (mcode-addrp addr mem lst)
                   (leq (plus i j) (len lst))
                   (lst-numberp i lst j))
              (equal (pc-read-mem (add 32 addr i) mem j)
                     (read-lst i lst j)))
     ((enable add-plus)))

(disable read-lst)
(disable lst-numberp)

(prove-lemma pc-read-mem-mcode2 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst)
                   (leq (plus (index-n 0 i) k) (len lst))
                   (lst-numberp (index-n 0 i) lst k))
              (equal (pc-read-mem addr mem k)
                     (read-lst (index-n 0 i) lst k)))
     ((use (pc-read-mem-mcode1 (addr (add 32 addr i)) 
                               (i (index-n 0 i)) (j k)))))

(prove-lemma pc-read-mem-mcode3 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst)
                   (leq (plus (index-n j i) k) (len lst))
                   (lst-numberp (index-n j i) lst k))
              (equal (pc-read-mem (add 32 addr j) mem k)
                     (read-lst (index-n j i) lst k)))
     ((use (pc-read-mem-mcode1 (addr (add 32 addr i)) 
                               (i (index-n j i)) (j k)))))

; sometimes,  we obtain machine code by read-mem.
(prove-lemma read->pc-read-mem (rewrite)
     (equal (read-mem x mem k)
            (pc-read-mem x mem k))
     ((enable read-mem pc-read-mem pc-byte-read byte-read pc-read)))

(prove-lemma read-mem-mcode1-int (rewrite)
     (implies (and (mcode-addrp addr mem lst)
                   (leq (plus (nat-to-int i 32) j) (len lst))
                   (numberp (nat-to-int i 32))
                   (lst-numberp (nat-to-int i 32) lst j))
              (equal (read-mem (add 32 addr i) mem j)
                     (read-lst (nat-to-int i 32) lst j)))
     ((enable nat-to-int)))

(prove-lemma read-mem-mcode2 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst)
                   (leq (plus (index-n 0 i) k) (len lst))
                   (lst-numberp (index-n 0 i) lst k))
              (equal (read-mem addr mem k)
                     (read-lst (index-n 0 i) lst k))))

(prove-lemma read-mem-mcode3 (rewrite)
     (implies (and (mcode-addrp (add 32 addr i) mem lst)
                   (leq (plus (index-n j i) k) (len lst))
                   (lst-numberp (index-n j i) lst k))
              (equal (read-mem (add 32 addr j) mem k)
                     (read-lst (index-n j i) lst k))))

(disable read->pc-read-mem)

; program segment remains unchanged after any write on memory,  because 
; program is in ROM.
(prove-lemma byte-write-mcode-addrp (rewrite)
     (implies (and (pc-read-memp pc mem (len lst))
                   (byte-writep x mem))
              (equal (mcode-addrp pc (byte-write value x mem) lst)
                     (mcode-addrp pc mem lst)))
     ((induct (mcode-addrp pc mem lst))
      (use (pc-byte-read-write (y pc)))
      (disable add-commutativity)))

(prove-lemma write-mem-mcode-addrp (rewrite)
     (implies (and (pc-read-memp pc mem (len lst))
                   (write-memp x mem n))
              (equal (mcode-addrp pc (write-mem value x mem n) lst)
                     (mcode-addrp pc mem lst)))
     ((induct (mcode-addrp pc mem lst))
      (use (pc-byte-read-write-mem (y pc)))
      (disable add-commutativity)))

;               DISJOINT0 AND DISJOINT

(prove-lemma disjoint0-head (rewrite)
     (and (equal (disjoint0 (head x 32) m y)
                 (disjoint0 x m y))
          (equal (disjoint0 x m (head y 32))
                 (disjoint0 x m y))))

(prove-lemma disjoint-head (rewrite)
     (and (equal (disjoint (head x 32) m y n)
                 (disjoint x m y n))
          (equal (disjoint x m (head y 32) n)
                 (disjoint x m y n))))

(prove-lemma disjoint0-la0 (rewrite)
     (implies (and (disjoint0 a m b)
                   (lessp i m))
              (not (mod32-eq (add 32 a i) b))))

(prove-lemma disjoint0-la1 (rewrite)
     (implies (and (disjoint0 a m b)
                   (lessp i m))
              (disjoint0 a i b)))

(prove-lemma disjoint0-la2 (rewrite)
     (implies (and (disjoint0 a m b)
                   (leq (plus i j) m))
              (disjoint0 (add 32 a i) j b))
     ((induct (disjoint0 a j b))
      (enable add-plus)))

(prove-lemma disjoint-la0 (rewrite)
     (implies (and (disjoint a m b n)
                   (lessp j n))
              (disjoint0 a m (add 32 b j))))

(prove-lemma disjoint-la1 (rewrite)
     (implies (and (disjoint a m b n)
                   (lessp i m)
                   (lessp j n))
              (not (mod32-eq (add 32 a i) (add 32 b j))))
     ((use (disjoint0-la0 (b (add 32 b j))))))

(prove-lemma disjoint-la2 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (lessp k n))
              (disjoint0 (add 32 a i) j (add 32 b k)))
     ((induct (disjoint0 a j b))
      (enable add-plus)))

(prove-lemma disjoint-la3 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (leq (plus k l) n))
              (disjoint (add 32 a i) j (add 32 b k) l))
     ((induct (disjoint x j y l))
      (enable add-plus)))

; 
(prove-lemma disjoint-0 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq l n))
              (disjoint a j b l))
     ((use (disjoint-la3 (i 0) (k 0)))))

(prove-lemma disjoint-1 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq (plus k l) n))
              (disjoint a j (add 32 b k) l))
     ((use (disjoint-la3 (i 0)))))

(prove-lemma disjoint-2 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (leq l n))
              (disjoint (add 32 a i) j b l))
     ((use (disjoint-la3 (k 0)))))

(prove-lemma disjoint-3 (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (leq (plus k l) n))
              (disjoint (add 32 a i) j (add 32 b k) l)))

;
(prove-lemma disjoint-4 (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq l n))
              (disjoint a j b l))
     ((use (disjoint-2 (a (add 32 a i)) (i (index-n 0 i))))))

(prove-lemma disjoint-5 (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus k l) n))
              (disjoint a j (add 32 b k) l))
     ((use (disjoint-3 (a (add 32 a i)) (i (index-n 0 i))))))
                      
(prove-lemma disjoint-6 (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq l n))
              (disjoint (add 32 a i1) j b l))
     ((use (disjoint-2 (a (add 32 a i)) (i (index-n i1 i))))))

(prove-lemma disjoint-7 (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus k l) n))
              (disjoint (add 32 a i1) j (add 32 b k) l))
     ((use (disjoint-3 (a (add 32 a i)) (i (index-n i1 i))))))

;
(prove-lemma disjoint-8 (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq j m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint a j b l))
     ((use (disjoint-1 (b (add 32 b k)) (k (index-n 0 k))))))

(prove-lemma disjoint-9 (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq (plus i j) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint (add 32 a i) j b l))
     ((use (disjoint-3 (b (add 32 b k)) (k (index-n 0 k))))))
                      
(prove-lemma disjoint-10 (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq j m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint a j (add 32 b k1) l))
     ((use (disjoint-1 (b (add 32 b k)) (k (index-n k1 k))))))

(prove-lemma disjoint-11 (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq (plus i j) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 a i) j (add 32 b k1) l))
     ((use (disjoint-3 (b (add 32 b k)) (k (index-n k1 k))))))

;
(prove-lemma disjoint-12 (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint a j b l))
     ((use (disjoint-9 (a (add 32 a i)) (i (index-n 0 i))))))

(prove-lemma disjoint-13 (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint (add 32 a i1) j b l))
     ((use (disjoint-9 (a (add 32 a i)) (i (index-n i1 i))))))
                      
(prove-lemma disjoint-14 (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint a j (add 32 b k1) l))
     ((use (disjoint-11 (a (add 32 a i)) (i (index-n 0 i))))))

(prove-lemma disjoint-15 (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 a i1) j (add 32 b k1) l))
     ((use (disjoint-11 (a (add 32 a i)) (i (index-n i1 i))))))

; the commutativity of disjoint.
(prove-lemma disjoint-commutativity (rewrite)
     (equal (disjoint x m y n)
            (disjoint y n x m)))

; the dual events of the above 16 events.
(prove-lemma disjoint-0~ (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq l n))
              (disjoint b l a j)))

(prove-lemma disjoint-1~ (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq (plus k l) n))
              (disjoint (add 32 b k) l a j)))

(prove-lemma disjoint-2~ (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (leq l n))
              (disjoint b l (add 32 a i) j))
     ((use (disjoint-2))
      (disable disjoint-2)))

(prove-lemma disjoint-3~ (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus i j) m)
                   (leq (plus k l) n))
              (disjoint (add 32 b k) l (add 32 a i) j)))

;
(prove-lemma disjoint-4~ (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq l n))
              (disjoint b l a j)))

(prove-lemma disjoint-5~ (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus k l) n))
              (disjoint (add 32 b k) l a j)))
                      
(prove-lemma disjoint-6~ (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq l n))
              (disjoint b l (add 32 a i1) j))
     ((use (disjoint-6))
      (disable disjoint-6)))

(prove-lemma disjoint-7~ (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus k l) n))
              (disjoint (add 32 b k) l (add 32 a i1) j)))
;
(prove-lemma disjoint-8~ (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq j m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint b l a j)))

(prove-lemma disjoint-9~ (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq (plus i j) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint b l (add 32 a i) j))
     ((use (disjoint-9))
      (disable disjoint-9)))
                      
(prove-lemma disjoint-10~ (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq j m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 b k1) l a j)))

(prove-lemma disjoint-11~ (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (leq (plus i j) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 b k1) l (add 32 a i) j)))
;
(prove-lemma disjoint-12~ (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint b l a j)))

(prove-lemma disjoint-13~ (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus l (index-n 0 k)) n))
              (disjoint b l (add 32 a i1) j))
     ((use (disjoint-13))
      (disable disjoint-13)))
                      
(prove-lemma disjoint-14~ (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 b k1) l a j)))

(prove-lemma disjoint-15~ (rewrite)
     (implies (and (disjoint (add 32 a i) m (add 32 b k) n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 b k1) l (add 32 a i1) j)))

; disjoint with asl.
(prove-lemma times-plus-lessp-cancel (rewrite)
     (implies (and (leq a k)
                   (leq b k)
                   (lessp a b))
              (equal (lessp (plus a (times i k)) (plus b (times j k)))
                     (leq i j)))
     ((induct (difference i j))))

(prove-lemma disjoint-2-asl (rewrite)
     (implies (and (disjoint a m b n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq l n))
              (disjoint (add 32 a (asl 32 x cnt)) opsz b l))
     ((enable nat-to-int)))

(prove-lemma disjoint-2~-asl (rewrite)
     (implies (and (disjoint a m b n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq l n))
              (disjoint b l (add 32 a (asl 32 x cnt)) opsz))
     ((enable nat-to-int)))

(prove-lemma disjoint-3-asl (rewrite)
     (implies (and (disjoint a m b n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus k l) n))
              (disjoint (add 32 a (asl 32 x cnt)) opsz (add 32 b k) l))
     ((enable nat-to-int)))

(prove-lemma disjoint-3~-asl (rewrite)
     (implies (and (disjoint a m b n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus k l) n))
              (disjoint (add 32 b k) l (add 32 a (asl 32 x cnt)) opsz))
     ((enable nat-to-int)))

(prove-lemma disjoint-9-asl (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus l (index-n 0 k)) n))
              (disjoint (add 32 a (asl 32 x cnt)) opsz b l))
     ((enable nat-to-int)))

(prove-lemma disjoint-9~-asl (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus l (index-n 0 k)) n))
              (disjoint b l (add 32 a (asl 32 x cnt)) opsz))
     ((enable nat-to-int)))

(prove-lemma disjoint-11-asl (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 a (asl 32 x cnt)) opsz (add 32 b k1) l))
     ((enable nat-to-int)))

(prove-lemma disjoint-11~-asl (rewrite)
     (implies (and (disjoint a m (add 32 b k) n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient m opsz))
                   (numberp (nat-to-int x 32))
                   (leq (plus l (index-n k1 k)) n))
              (disjoint (add 32 b k1) l (add 32 a (asl 32 x cnt)) opsz))
     ((enable nat-to-int)))

(disable times-plus-lessp-cancel)

; a set of rewrite rules for disjoint0 and disjoint.
(prove-lemma disjoint0-x-x (rewrite)
     (equal (disjoint0 x m x)
            (zerop m)))

(prove-lemma disjoint0-deduction0 (rewrite)
     (disjoint0 x 0 y))

(prove-lemma disjoint0-deduction1 (rewrite)
     (and (equal (disjoint0 x m (add 32 x y))
                 (disjoint0 0 m y))
          (equal (disjoint0 (add 32 x y) m x)
                 (disjoint0 y m 0)))
     ((enable add)))

(prove-lemma disjoint0-deduction2 (rewrite)
     (equal (disjoint0 (add 32 x y) m (add 32 x z))
            (disjoint0 y m z))
     ((induct (disjoint0 y m z))
      (enable add)))

(prove-lemma disjoint-x-x (rewrite)
     (equal (disjoint x m x n)
            (or (zerop m) (zerop n))))

(prove-lemma disjoint-deduction0 (rewrite)
     (and (disjoint x m y 0)
          (disjoint x 0 y n)))

(prove-lemma disjoint-deduction1 (rewrite)
     (and (equal (disjoint x m (add 32 x y) n)
                 (disjoint 0 m y n))
          (equal (disjoint (add 32 x y) m x n)
                 (disjoint y m 0 n))))

(prove-lemma disjoint-deduction2 (rewrite)
     (equal (disjoint (add 32 x y) m (add 32 x z) n)
            (disjoint y m z n)))

;                     INDEX-N
(prove-lemma index-n-0 (rewrite)
     (and (equal (index-n x 0) (head x 32))
          (equal (index-n 0 x) (neg 32 x))))

(prove-lemma index-n-x-x (rewrite)
     (equal (index-n x x) 0))

(prove-lemma index-n-deduction0 (rewrite)
     (and (equal (index-n x (neg 32 y))
                 (index-n (add 32 x y) 0))
          (equal (index-n (neg 32 x) y)
                 (index-n 0 (add 32 x y)))))

(prove-lemma index-n-deduction1 (rewrite)
     (and (equal (index-n (add 32 x y) x) 
                 (index-n y 0))
          (equal (index-n y (add 32 y x)) 
                 (index-n 0 x))))

(prove-lemma index-n-deduction2 (rewrite)
     (equal (index-n (add 32 z x) (add 32 z y))
            (index-n x y)))

(prove-lemma disjoint-deduction3 (rewrite)
     (equal (disjoint (add 32 y x) m (add 32 z x) n)
            (disjoint y m z n))
     ((enable add-commutativity)))

(disable index-n)

;           READ-MEM/WRITE-MEM WITH MEM-LST/MEM-ILST
;
; starting at address a, the contents of the memory are equal to the elements 
; of lst.
(defn mem-lst (opsz a mem n lst)
  (if (zerop n)
      (nlistp lst)
    (and (equal (read-mem a mem opsz) (car lst))
         (mem-lst opsz (add (l) a opsz) mem (sub1 n) (cdr lst)))))

(defn mem-ilst (opsz a mem n lst)
  (if (zerop n)
      (nlistp lst)
    (and (equal (nat-to-int (read-mem a mem opsz) (times 8 opsz)) (car lst))
         (mem-ilst opsz (add (l) a opsz) mem (sub1 n) (cdr lst)))))

; every element in lst is in "good" range.
(prove-lemma mem-lst-nat-rangep (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (leq (times 8 opsz) k))
              (nat-rangep (get-nth i lst) k)))

(prove-lemma mem-ilst-int-rangep (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (equal oplen (times 8 opsz)))
              (int-rangep (get-nth i lst) oplen)))

; every element in lst is a natural number.
(prove-lemma mem-lst-numberp (rewrite)
     (implies (mem-lst opsz a mem n lst)
              (numberp (get-nth i lst))))

; every element in lst is bounded by 2^(8*opsz).
(prove-lemma mem-lst-lessp (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal k (exp 2 (times 8 opsz))))
              (lessp (get-nth i lst) k))
     ((use (mem-lst-nat-rangep (k (times 8 opsz))))
      (enable nat-rangep)))

; every element in lst is an integer. 
(prove-lemma mem-ilst-integerp (rewrite)
     (implies (mem-ilst opsz a mem n lst)
              (integerp (get-nth i lst))))

; a trivial, but useful, instantiation!
(prove-lemma readm-mem-lst (rewrite)
     (mem-lst opsz a mem n (readm-mem opsz a mem n)))

; head with mem-lst/mem-ilst.
(prove-lemma head-mem-lst (rewrite)
     (equal (mem-lst opsz (head x 32) mem n lst)
            (mem-lst opsz x mem n lst)))

(prove-lemma head-mem-ilst (rewrite)
     (equal (mem-ilst opsz (head x 32) mem n lst)
            (mem-ilst opsz x mem n lst)))

(prove-lemma read-mem-non-numberp (rewrite)
     (implies (not (numberp x))
              (equal (read-mem x mem k) (read-mem 0 mem k)))
     ((enable add)))
                     
(prove-lemma mem-lst-non-numberp (rewrite)
     (implies (not (numberp x))
              (equal (mem-lst opsz x mem n lst)
                     (mem-lst opsz 0 mem n lst))))

(prove-lemma mem-lst-same (rewrite)
     (implies (and (mem-lst opsz x mem n lst)
                   (equal (nat-to-uint x) (nat-to-uint y)))
              (mem-lst opsz y mem n lst))
     ((enable nat-to-uint)))

(disable read-mem-non-numberp)
(disable mem-lst-non-numberp)
(disable mem-lst-same)

;                    CANONICAL FORMS
; Sometimes,  it is possible to have more than one representation
; for one concept.  We have to tell the prover only to use the canonical
; representations.
(prove-lemma pc-byte-read=pc-read-mem-1 (rewrite)
     (equal (pc-byte-read addr mem)
            (pc-read-mem addr mem 1))
     ((expand (pc-read-mem addr mem 1))))

(prove-lemma byte-read=read-mem-1 (rewrite)
     (equal (byte-read addr mem)
            (read-mem addr mem 1))                  
     ((expand (read-mem addr mem 1))))

(prove-lemma byte-write=write-mem-1 (rewrite)
     (equal (byte-write value addr mem)
            (write-mem value addr mem 1))
     ((expand (write-mem value addr mem 1))))

(prove-lemma byte-writep=write-memp-1 (rewrite)
     (equal (byte-writep x mem)
            (write-memp x mem 1))
     ((expand (write-memp x mem 1))))

;        GET-LST, PUT-LST, GET-VALS, PUT-VALS, MCAR, and MCDR
(defn get-lst (opsz m lst n)
  (if (zerop n)
      0
    (app (times 8 opsz)
         (get-nth (plus m (sub1 n)) lst)
         (get-lst opsz m lst (sub1 n)))))

(defn put-lst (opsz v n lst k)
  (if (zerop k)
      lst
    (put-lst opsz (tail v (times 8 opsz)) n 
             (put-nth (head v (times 8 opsz)) (plus n (sub1 k)) lst)
             (sub1 k))))

(defn get-vals (m lst n)
  (if (zerop n)
      nil
    (append (get-vals m lst (sub1 n))
            (list (get-nth (plus m (sub1 n)) lst)))))

(defn put-vals (vals m lst n)
  (if (zerop n)
      lst
    (put-vals vals m (put-nth (get-nth (sub1 n) vals) (plus m (sub1 n)) lst)
              (sub1 n))))

(defn bv-to-lst (opsz bv n)
  (if (zerop n)
      nil
    (append (bv-to-lst opsz (tail bv (times 8 opsz)) (sub1 n))
            (list (head bv (times 8 opsz))))))
     
(defn lst-to-bv (opsz lst n)
  (if (zerop n)
      0
    (app (times 8 opsz)
         (get-nth (sub1 n) lst)
         (lst-to-bv opsz lst (sub1 n)))))

; mcar returns the list consisting of the first n elements of lst.
(defn mcar (n lst)
  (if (zerop n)
      nil
    (cons (car lst) (mcar (sub1 n) (cdr lst)))))

; mcdr returns the list discarding the first n elements of lst.
(defn mcdr (n lst)
  (if (zerop n)
      lst
    (mcdr (sub1 n) (cdr lst))))

; a predicate to recognize proper list.
(defn proper-lstp (lst)
  (if (nlistp lst)
      (equal lst nil)
    (proper-lstp (cdr lst))))

(prove-lemma append-len (rewrite)
     (equal (len (append x y)) (plus (len x) (len y))))

(prove-lemma get-vals-len (rewrite)
     (equal (len (get-vals m lst n)) (fix n)))

(prove-lemma bv-to-lst-len (rewrite)
     (equal (len (bv-to-lst opsz bv n)) (fix n)))

(prove-lemma get-vals-proper-lstp (rewrite)
     (proper-lstp (get-vals m lst n)))

(prove-lemma bv-to-lst-proper-lstp (rewrite)
     (proper-lstp (bv-to-lst opsz bv n)))

(prove-lemma mcdr-listp-len (rewrite)
     (equal (listp (mcdr n lst))
            (lessp n (len lst))))

(prove-lemma cdr-mcdr (rewrite)
     (equal (cdr (mcdr n lst))
            (mcdr (add1 n) lst)))

(prove-lemma mcar-mcar (rewrite)
     (implies (leq m n)
              (equal (mcar m (mcar n lst))
                     (mcar m lst))))

(prove-lemma mcdr-mcdr (rewrite)
     (equal (mcdr n (mcdr m lst))
            (mcdr (plus m n) lst)))

(prove-lemma mcar-nth (rewrite)
     (equal (get-nth n (mcar m lst))
            (if (lessp n m) (get-nth n lst) 0))
     ((enable get-nth)))

(prove-lemma mcdr-nth (rewrite)
     (equal (get-nth n (mcdr m lst))
            (get-nth (plus m n) lst)))

(prove-lemma get-lst-cdr (rewrite)
     (equal (get-lst opsz m (cdr lst) n)
            (get-lst opsz (add1 m) lst n))
     ((enable get-nth)))

(prove-lemma get-lst-mcdr (rewrite)
     (equal (get-lst opsz m (mcdr j lst) n)
            (get-lst opsz (plus m j) lst n)))

(prove-lemma get-lst-mcar (rewrite)
     (implies (leq (plus m n) j)
              (equal (get-lst opsz m (mcar j lst) n)
                     (get-lst opsz m lst n)))
     ((induct (get-lst opsz m lst n))))

(prove-lemma get-vals-cdr (rewrite)
     (equal (get-vals m (cdr lst) n)
            (get-vals (add1 m) lst n))
     ((enable get-nth)))

(prove-lemma get-vals-mcdr (rewrite)
     (equal (get-vals m (mcdr j lst) n)
            (get-vals (plus m j) lst n)))

(prove-lemma get-vals-mcar (rewrite)
     (implies (leq (plus m n) j)
              (equal (get-vals m (mcar j lst) n)
                     (get-vals m lst n)))
     ((induct (get-vals m lst n))))

(prove-lemma get-nth-append (rewrite)
     (equal (get-nth i (append x y))
            (if (lessp i (len x))
                (get-nth i x)
              (get-nth (difference i (len x)) y)))
     ((enable get-nth)))

(prove-lemma get-vals-append (rewrite)
     (implies (leq n (len x))
              (equal (get-vals 0 (append x y) n)
                     (get-vals 0 x n))))

(prove-lemma put-vals-append (rewrite)
     (implies (leq n (len x))
              (equal (put-vals (append x y) m lst n)
                     (put-vals x m lst n)))
     ((induct (put-vals x m lst n))))

; another induction hint for many theorems about memory.
(defn mem-induct2 (opsz addr i n lst j)
  (if (zerop n)
      t
    (mem-induct2 opsz
                 (add 32 addr opsz)
                 (sub1 i)
                 (sub1 n) 
                 (cdr lst)
                 (difference j opsz))))

(prove-lemma read-mem-lst-la (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal (remainder j opsz) 0)
                   (lessp (quotient j opsz) n))
              (equal (read-mem (add 32 a j) mem opsz)
                     (get-nth (quotient j opsz) lst)))
     ((induct (mem-induct2 opsz a i n lst j))
      (enable add-plus)))

(prove-lemma mem-lst-get-lst0 (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (leq k n))
              (equal (nat-to-uint (read-mem a mem k))
                     (get-lst 1 0 lst k)))
     ((induct (read-mem a mem k))))

(prove-lemma mem-lst-get-lst (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (leq (plus (nat-to-uint j) k) n))
              (equal (nat-to-uint (read-mem (add 32 a j) mem k))
                     (get-lst 1 (nat-to-uint j) lst k)))
     ((induct (read-mem a mem k)) 
      (enable add-plus plus-add1-1)))

(prove-lemma mem-lst-get-vals0 (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (leq k n))
              (equal (bv-to-lst 1 (read-mem a mem k) k)
                     (get-vals 0 lst k)))
     ((induct (read-mem a mem k))))

(prove-lemma mem-lst-get-vals (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (leq (plus (nat-to-uint j) k) n))
              (equal (bv-to-lst 1 (read-mem (add 32 a j) mem k) k)
                     (get-vals (nat-to-uint j) lst k)))
     ((induct (read-mem a mem k)) 
      (enable add-plus plus-add1-1)))

; read is equivalent to get-nth.
(prove-lemma read-mem-lst0 (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (not (zerop n)))
              (equal (nat-to-uint (read-mem a mem opsz))
                     (get-nth 0 lst))))

(prove-lemma iread-mem-get0 (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (not (zerop n))
                   (equal oplen (times 8 opsz)))
              (equal (nat-to-int (read-mem a mem opsz) oplen)
                     (get-nth 0 lst))))

(prove-lemma read-mem-lst (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal (remainder (nat-to-uint j) opsz) 0)
                   (lessp (quotient (nat-to-uint j) opsz) n))
              (equal (nat-to-uint (read-mem (add 32 a j) mem opsz))
                     (get-nth (quotient (nat-to-uint j) opsz) lst))))

(prove-lemma read-mem-lst-int (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal (remainder (nat-to-int j 32) opsz) 0)
                   (lessp (quotient (nat-to-int j 32) opsz) n)
                   (numberp (nat-to-int j 32)))
              (equal (nat-to-uint (read-mem (add 32 a j) mem opsz))
                     (get-nth (quotient (nat-to-int j 32) opsz) lst)))
     ((enable nat-to-int)))

(prove-lemma read-mem-ilst (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (equal oplen (times 8 opsz))
                   (equal (remainder (nat-to-uint j) opsz) 0)
                   (lessp (quotient (nat-to-uint j) opsz) n))
              (equal (nat-to-int (read-mem (add 32 a j) mem opsz) oplen)
                     (get-nth (quotient (nat-to-uint j) opsz) lst)))
     ((induct (mem-induct2 opsz a i n lst j))
      (enable add-plus)))

(prove-lemma read-mem-ilst-int (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (equal oplen (times 8 opsz))
                   (equal (remainder (nat-to-uint j) opsz) 0)
                   (lessp (quotient (nat-to-uint j) opsz) n)
                   (numberp (nat-to-int j 32)))       
              (equal (nat-to-int (read-mem (add 32 a j) mem opsz) oplen)
                     (get-nth (quotient (nat-to-uint j) opsz) lst)))
     ((induct (mem-induct2 opsz a i n lst j))
      (enable add-plus nat-to-int)))

; write to some location else does not affect mem-lst.
(prove-lemma write-else-mem-lst (rewrite)
     (implies (disjoint a (times opsz n) x m)
              (equal (mem-lst opsz a (write-mem value x mem m) n lst)
                     (mem-lst opsz a mem n lst)))
     ((enable times)))

(prove-lemma write-else-mem-ilst (rewrite)
     (implies (disjoint a (times opsz n) x m)
              (equal (mem-ilst opsz a (write-mem value x mem m) n lst)
                     (mem-ilst opsz a mem n lst)))
     ((enable times)))

; some conditions that makes disjoint true.
(prove-lemma disjoint0-leq (rewrite)
     (implies (and (leq (plus a m) 4294967296)
                   (lessp b a))
              (disjoint0 a m b))
     ((induct (disjoint0 a m b))
      (enable add nat-rangep)))

(prove-lemma disjoint-leq (rewrite)
     (implies (and (leq (plus a m) 4294967296)
                   (leq (plus b n) a))
              (disjoint a m b n))
     ((induct (disjoint a m b n))
      (enable add nat-rangep)))

(prove-lemma disjoint-leq1 (rewrite)
     (implies (and (leq (plus a m) 4294967296)
                   (leq (plus b n) a))
              (disjoint b n a m)))

(prove-lemma plus-times-lessp (rewrite)
     (implies (and (lessp (plus x (times y z)) w)
                   (lessp z1 z))
              (lessp (plus x y (times y z1)) w))
     ((induct (plus z a))))

(prove-lemma write-mem-lst-la (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal v1 (head v (times 8 opsz)))
                   (equal j (times opsz i))
                   (lessp i n)
                   (numberp v))
              (mem-lst opsz
                       a
                       (write-mem v (add 32 a j) mem opsz)
                       n
                       (put-nth v1 i lst)))
     ((induct (mem-induct2 opsz a i n lst j))
      (enable times add-plus) (disable plus)))

(defn mem-induct3 (v v1 a mem i lst k)
  (if (zerop k)
      t
    (mem-induct3 (tail v 8) (tail v1 8)
                a (byte-write v (add 32 a (plus i (sub1 k))) mem)
                i (put-nth (head v 8) (plus i (sub1 k)) lst)
                (sub1 k))))

(prove-lemma mem-lst-put-lst (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (uint-rangep n 32)
                   (nat-rangep v (times 8 k))
                   (equal (nat-to-uint j) i)
                   (equal v1 (nat-to-uint v))
                   (leq (plus i k) n)
                   (numberp j)
                   (numberp v))
              (mem-lst 1 a (write-mem v (add 32 a j) mem k)
                       n (put-lst 1 v1 i lst k)))
     ((induct (mem-induct3 v v1 a mem i lst k))
      (enable add-plus)))

(defn mem-induct4 (v vals a mem i lst k)
  (if (zerop k)
      t
    (mem-induct4 (tail v 8) (get-vals 0 vals (sub1 k))
                a (byte-write v (add 32 a (plus i (sub1 k))) mem)
                i (put-nth (head v 8) (plus i (sub1 k)) lst)
                (sub1 k))))

(prove-lemma get-vals-0 (rewrite)
     (implies (and (equal (len lst) n)
                   (proper-lstp lst))
              (equal (get-vals 0 lst n) lst)))        

(prove-lemma mem-lst-put-vals (rewrite)
     (implies (and (mem-lst 1 a mem n lst)
                   (uint-rangep n 32)
                   (nat-rangep v (times 8 k))
                   (equal (nat-to-uint j) i)
                   (equal vals (bv-to-lst 1 v k))
                   (leq (plus i k) n)
                   (numberp j)
                   (numberp v))
              (mem-lst 1 a (write-mem v (add 32 a j) mem k)
                       n (put-vals vals i lst k)))
     ((induct (mem-induct4 v vals a mem i lst k))
      (enable add-plus)))

(disable get-vals-0)

(prove-lemma write-mem-lst (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (nat-rangep v (times 8 opsz))
                   (equal (nat-to-uint j) (times opsz i))
                   (equal v1 (nat-to-uint v))
                   (lessp i n)
                   (numberp j)
                   (numberp v))
              (mem-lst opsz a
                       (write-mem v (add 32 a j) mem opsz)
                       n (put-nth v1 i lst))))

(prove-lemma write-mem-ilst (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal (nat-to-uint j) (times opsz i))
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-int v (times 8 opsz)))
                   (lessp i n)
                   (numberp j)
                   (numberp v))            
              (mem-ilst opsz a
                        (write-mem v (add 32 a j) mem opsz)
                        n (put-nth v1 i lst)))
     ((induct (mem-induct2 opsz a i n lst j))
      (enable times add-plus) (disable plus)))

(prove-lemma write-mem-lst0 (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-uint v))
                   (not (zerop n))
                   (numberp v))            
              (mem-lst opsz a (write-mem v a mem opsz) n (put-nth v1 0 lst)))
     ((use (write-mem-lst (i 0) (j 0)))))

(prove-lemma write-mem-ilst0 (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-int v (times 8 opsz)))
                   (not (zerop n))
                   (numberp v))            
              (mem-ilst opsz a (write-mem v a mem opsz) n (put-nth v1 0 lst)))
     ((use (write-mem-ilst (i 0) (j 0)))))

(prove-lemma write-mem-lst-int (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal (times opsz i) (nat-to-int j 32))
                   (numberp (nat-to-int j 32))
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-uint v))
                   (lessp i n)
                   (not (zerop opsz))
                   (numberp v))
              (mem-lst opsz a
                       (write-mem v (add 32 a j) mem opsz)
                       n (put-nth v1 i lst)))
     ((enable put-nth-0 nat-to-int nat-rangep)
      (disable put-nth)))

(prove-lemma write-mem-ilst-int (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal (times opsz i) (nat-to-int j 32))
                   (numberp (nat-to-int j 32))
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-int v (times 8 opsz)))
                   (lessp i n)
                   (not (zerop opsz))
                   (numberp v))
              (mem-ilst opsz a
                        (write-mem v (add 32 a j) mem opsz)
                        n (put-nth v1 i lst)))
     ((enable put-nth-0 nat-to-int nat-rangep)
      (disable put-nth)))

;                    INTEGER VIEWS
;                    A + OPSZ * I
; to deal with the address calculation a+2*i or a+4*i, we introduce 
; the following set of lemmas.
(prove-lemma read-mem-lst-asl (rewrite)
     (implies 
      (and (mem-lst opsz a mem n lst)
           (equal opsz (exp 2 cnt))
           (lessp (nat-to-int i 32) n)
           (numberp (nat-to-int i 32)))
      (equal (nat-to-uint (read-mem (add 32 a (asl 32 i cnt)) mem opsz))
             (get-nth (nat-to-int i 32) lst)))
     ((use (read-mem-lst (opsz (exp 2 cnt)) (j (times (exp 2 cnt) i))))
      (enable nat-to-int)))

(prove-lemma read-mem-ilst-asl (rewrite)
     (implies 
      (and (mem-ilst opsz a mem n lst)
           (equal opsz (exp 2 cnt))
           (equal oplen (times 8 opsz))
           (lessp (nat-to-int i 32) n)
           (numberp (nat-to-int i 32)))
      (equal (nat-to-int (read-mem (add 32 a (asl 32 i cnt)) mem opsz) oplen)
             (get-nth (nat-to-int i 32) lst)))
     ((use (read-mem-ilst (opsz (exp 2 cnt)) (j (times (exp 2 cnt) i))))
      (enable nat-to-int)))

(prove-lemma write-mem-lst-asl (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal opsz (exp 2 cnt))
                   (nat-rangep v (times 8 opsz))
                   (equal j (nat-to-int i 32))
                   (equal v1 (nat-to-uint v))
                   (lessp j n)
                   (numberp j)
                   (numberp v))
              (mem-lst opsz a
                       (write-mem v (add 32 a (asl 32 i cnt)) mem opsz)
                       n (put-nth v1 j lst)))
     ((use (write-mem-lst (opsz (exp 2 cnt)) (j (times (exp 2 cnt) i))))
      (enable nat-to-int)))

(prove-lemma write-mem-ilst-asl (rewrite)
     (implies (and (mem-ilst opsz a mem n lst)
                   (uint-rangep (times opsz n) 32)
                   (equal opsz (exp 2 cnt))
                   (nat-rangep v (times 8 opsz))
                   (equal v1 (nat-to-int v (times 8 opsz)))
                   (equal j (nat-to-int i 32))
                   (lessp j n)
                   (numberp v)
                   (numberp j))
              (mem-ilst opsz a
                        (write-mem v (add 32 a (asl 32 i cnt)) mem opsz)
                        n (put-nth v1 j lst)))
     ((use (write-mem-ilst (opsz (exp 2 cnt)) (j (times (exp 2 cnt) i))))
      (enable nat-to-int)))

(prove-lemma times-lessp-cancel1 (rewrite)
     (equal (lessp (times y x) (plus x (times z x)))
            (and (not (zerop x)) (leq y z)))
     ((use (times-lessp-cancel (z (add1 z))))))

(prove-lemma read-memp-ram1-asl (rewrite)
     (implies (and (ram-addrp addr mem n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient n opsz))
                   (numberp (nat-to-int x 32)))
              (read-memp (add 32 addr (asl 32 x cnt)) mem opsz))
     ((use (ram-addrp-la1 (m (times opsz (quotient n opsz))))
           (read-memp-ram1 (k (times opsz (quotient n opsz)))
                           (i (times x (exp 2 cnt)))
                           (j opsz)))
      (enable nat-to-int)
      (disable ram-addrp-la1 ram-addrp-la2 read-memp-ram1)))

(prove-lemma read-memp-rom1-asl (rewrite)
     (implies (and (rom-addrp addr mem n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient n opsz))
                   (numberp (nat-to-int x 32)))
              (read-memp (add 32 addr (asl 32 x cnt)) mem opsz))
     ((use (rom-addrp-la1 (m (times opsz (quotient n opsz))))
           (read-memp-rom1 (k (times opsz (quotient n opsz)))
                           (i (times x (exp 2 cnt)))
                           (j opsz)))
      (enable nat-to-int)
      (disable rom-addrp-la1 rom-addrp-la2 read-memp-rom1)))

(prove-lemma write-memp-ram1-asl (rewrite)
     (implies (and (ram-addrp addr mem n)
                   (equal opsz (exp 2 cnt))
                   (lessp (nat-to-int x 32) (quotient n opsz))
                   (numberp (nat-to-int x 32)))
              (write-memp (add 32 addr (asl 32 x cnt)) mem opsz))
     ((use (ram-addrp-la1 (m (times opsz (quotient n opsz))))
           (write-memp-ram1 (k (times opsz (quotient n opsz)))
                            (i (times x (exp 2 cnt)))
                            (j opsz)))
      (enable nat-to-int)
      (disable ram-addrp-la1 ram-addrp-la2 write-memp-ram1)))

;             BASIC READM-MEM/WRITEM-MEM EVENTS
;
(prove-lemma writem-mem-maintain-pc-byte-readp (rewrite)
     (equal (pc-byte-readp x (writem-mem opsz vlst addr mem))
            (pc-byte-readp x mem)))

(prove-lemma writem-mem-maintain-pc-read-memp (rewrite)
     (equal (pc-read-memp x (writem-mem opsz vlst addr mem) n)
            (pc-read-memp x mem n)))

(prove-lemma writem-mem-maintain-byte-readp (rewrite)
     (equal (byte-readp x (writem-mem opsz vlst addr mem))
            (byte-readp x mem)))

(prove-lemma writem-mem-maintain-read-memp (rewrite)
     (equal (read-memp x (writem-mem opsz vlst addr mem) n)
            (read-memp x mem n)))

(prove-lemma writem-mem-maintain-byte-writep (rewrite)
     (equal (byte-writep x (writem-mem opsz vlst addr mem))
            (byte-writep x mem)))

(prove-lemma writem-mem-maintain-write-memp (rewrite)
     (equal (write-memp x (writem-mem opsz vlst addr mem) n)
            (write-memp x mem n)))

(prove-lemma writem-mem-maintain-rom-addrp (rewrite)
     (equal (rom-addrp x (writem-mem opsz vlst addr mem) n)
            (rom-addrp x mem n)))

(prove-lemma writem-mem-maintain-ram-addrp (rewrite)
     (equal (ram-addrp x (writem-mem opsz vlst addr mem) n)
            (ram-addrp x mem n)))

(prove-lemma pc-read-mem-writem-mem (rewrite)
     (implies (and (write-memp addr mem (times opsz (len vlst)))
                   (pc-read-memp x mem n))
              (equal (pc-read-mem x (writem-mem opsz vlst addr mem) n)
                     (pc-read-mem x mem n)))
     ((induct (writem-mem opsz vlst addr mem))))

(prove-lemma writem-mem-mcode-addrp (rewrite)
     (implies (and (pc-read-memp pc mem (len lst))
                   (write-memp addr mem (times opsz (len vlst))))
              (equal (mcode-addrp pc (writem-mem opsz vlst addr mem) lst)
                     (mcode-addrp pc mem lst)))
     ((induct (writem-mem opsz vlst addr mem))))

(prove-lemma writem-else-mem-lst (rewrite)
     (implies (disjoint addr (times opsz1 (len vlst)) a (times opsz n))
              (equal (mem-lst opsz a (writem-mem opsz1 vlst addr mem) n lst)
                     (mem-lst opsz a mem n lst)))
     ((induct (writem-mem opsz1 vlst addr mem))))

(prove-lemma writem-else-mem-ilst (rewrite)
     (implies (disjoint a (times opsz n) addr (times opsz1 (len vlst)))
              (equal (mem-ilst opsz a (writem-mem opsz1 vlst addr mem) n lst)
                     (mem-ilst opsz a mem n lst)))
     ((induct (writem-mem opsz1 vlst addr mem))))

(prove-lemma read-writem-mem (rewrite)
     (implies (disjoint addr n addr1 (times opsz (len vlst)))
              (equal (read-mem addr (writem-mem opsz vlst addr1 mem) n)
                     (read-mem addr mem n)))
     ((induct (writem-mem opsz vlst addr1 mem))))

(prove-lemma readm-write-mem (rewrite)
     (implies (disjoint addr (times opsz n) addr1 k)
              (equal (readm-mem opsz addr (write-mem value addr1 mem k) n)
                     (readm-mem opsz addr mem n)))
     ((enable times)))

(defn modn-lst (n lst)
  (if (nlistp lst)
      nil
    (cons (head (car lst) n)
          (modn-lst n (cdr lst)))))
          
(prove-lemma modn-readm-rn (rewrite)
     (equal (modn-lst oplen (readm-rn oplen rnlst rfile))
            (readm-rn oplen rnlst rfile)))           

(prove-lemma readm-writem-mem (rewrite)
     (implies (and (uint-rangep (times opsz n) 32)
                   (equal n (len vlst)))                   
              (equal (readm-mem opsz addr (writem-mem opsz vlst addr mem) n)
                     (modn-lst (times 8 opsz) vlst)))
     ((disable plus)))

(prove-lemma disjoint-leq-uint (rewrite)
     (implies (and (leq (plus (nat-to-uint a) m) 4294967296)
                   (leq (plus (nat-to-uint b) n) (nat-to-uint a)))
              (disjoint a m b n)))

(prove-lemma disjoint-leq1-uint (rewrite)
     (implies (and (leq (plus (nat-to-uint a) m) 4294967296)
                   (leq (plus (nat-to-uint b) n) (nat-to-uint a)))
              (disjoint b n a m)))

(disable disjoint-leq)
(disable disjoint-leq1)
(disable disjoint0-leq)
(disable disjoint-commutativity)
(disable disjoint-leq-uint)
(disable disjoint-leq1-uint)

;              MEM-LST WITH MCAR AND MCDR
(prove-lemma mem-lst-plus (rewrite)
     (equal (mem-lst opsz a mem (plus m n) lst)
            (and (mem-lst opsz a mem m (mcar m lst))
                 (mem-lst opsz (add 32 a (times opsz m)) mem n (mcdr m lst))))
     ((induct (mem-lst opsz a mem m lst))
      (enable add-plus)))

(prove-lemma mem-lst-mcar (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (leq k n))
              (mem-lst opsz a mem k (mcar k lst))))

(prove-lemma mem-lst-mcar-1 (rewrite)
     (implies (mem-lst opsz a mem n (mcar n lst))
              (mem-lst opsz a mem (sub1 n) (mcar (sub1 n) lst)))
     ((use (mem-lst-plus (lst (mcar n lst)) (m (sub1 n)) (n 1)))))

(prove-lemma mem-lst-mcar-2 (rewrite)
     (implies 
      (and (mem-lst opsz a mem n (mcar n lst))
           (leq k n))
      (mem-lst opsz a mem (difference n k) (mcar (difference n k) lst)))
     ((use (mem-lst-plus (lst (mcar n lst)) (m (difference n k)) (n k)))))

(prove-lemma plus-difference (rewrite)
        (equal (plus m (difference n m))
               (if (lessp n m) (fix m) (fix n))))

(prove-lemma mem-lst-len (rewrite)
     (implies (mem-lst opsz a mem n lst)
              (not (lessp n (len lst)))))

(prove-lemma mem-lst-mcdr (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal i (times opsz m)))
              (mem-lst opsz (add 32 a i) mem (difference n m) (mcdr m lst)))
     ((use (mem-lst-plus (n (difference n m))))))

(prove-lemma mem-lst-mcdr-0 (rewrite)
     (implies (mem-lst opsz a mem n lst)
              (mem-lst opsz (add 32 a opsz) mem (sub1 n) (mcdr 1 lst))))

(prove-lemma mem-lst-mcdr-uint (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal (nat-to-uint i) (times opsz m))
                   (not (zerop opsz)))
              (mem-lst opsz (add 32 a i) mem (difference n m) (mcdr m lst))))

(prove-lemma mem-lst-mcdr-1 (rewrite)
     (implies (mem-lst 1 (add 32 x i) mem (difference n j) (mcdr k lst))
              (mem-lst 1
                       (add 32 x (add 32 i 1))
                       mem
                       (difference (sub1 n) j)
                       (mcdr (add1 k) lst))))

(prove-lemma mem-lst-mcdr-uint-1 (rewrite)
     (implies 
      (and (mem-lst opsz (add 32 a b) mem (difference n j) (mcdr k lst))
           (equal (nat-to-uint i) (times opsz m))
           (not (zerop opsz)))
      (mem-lst opsz
               (add 32 a (add 32 b i))
               mem
               (difference n (plus m j))
               (mcdr (plus m k) lst)))
     ((use (mem-lst-mcdr-uint (a (add 32 a b))
                              (n (difference n j))
                              (lst (mcdr k lst))))))

(disable mem-lst-len)
(disable plus-difference)

;                 LSTCPY AND LSTMCPY
(defn lstcpy (i1 lst1 i2 lst2 n)
  (if (zerop n)
      lst1
    (lstcpy (add1 i1) (put-nth (get-nth i2 lst2) i1 lst1) 
            (add1 i2) lst2 (sub1 n))))

(prove-lemma lstcpy-0 (rewrite)
     (equal (lstcpy i1 lst1 i2 lst2 0) lst1))

(prove-lemma lstcpy-lstcpy (rewrite)
     (implies (and (equal j1 (plus h1 i1))
                   (equal j2 (plus h1 i2)))
              (equal (lstcpy j1 (lstcpy i1 lst1 i2 lst2 h1) j2 lst2 h2)
                     (lstcpy i1 lst1 i2 lst2 (plus h1 h2))))
     ((induct (lstcpy i1 lst1 i2 lst2 h1))
      (enable put-nth-0 get-nth-0)))

(defn lstmcpy (opsz i1 lst1 i2 lst2 n)
  (if (zerop n)
      lst1
    (lstmcpy opsz (plus opsz i1) (lstcpy i1 lst1 i2 lst2 opsz) 
             (plus opsz i2) lst2 (sub1 n))))

(prove-lemma lstmcpy-cpy (rewrite)
     (equal (lstmcpy h i1 lst1 i2 lst2 n)
            (lstcpy i1 lst1 i2 lst2 (times h n))))
  
(prove-lemma put-commutativity (rewrite)
     (implies (lessp j i)
              (equal (put-nth v1 i (put-nth v2 j lst))
                     (put-nth v2 j (put-nth v1 i lst))))
     ((enable put-nth)))

(prove-lemma lstcpy-put-nth (rewrite)
     (implies (lessp i j1)
              (equal (put-nth v i (lstcpy j1 lst1 j2 lst2 n))
                     (lstcpy j1 (put-nth v i lst1) j2 lst2 n)))
     ((induct (lstcpy j1 lst1 j2 lst2 n))
      (enable put-nth-0)))

; a variant for lstcpy.       
(defn lstcpy1 (i1 lst1 i2 lst2 n)
  (if (zerop n)
      lst1
    (lstcpy1 i1 
             (put-nth (get-nth (plus i2 (sub1 n)) lst2) 
                      (plus i1 (sub1 n)) 
                      lst1)
             i2 lst2 (sub1 n))))

(prove-lemma lstcpy-add1 (rewrite)
     (equal (lstcpy i1 (put-nth (get-nth (plus i2 h) lst2) (plus i1 h) lst1)
                    i2 lst2 h)
            (lstcpy i1 lst1 i2 lst2 (add1 h)))
     ((induct (lstcpy i1 lst1 i2 lst2 h))
      (enable get-nth-0 put-nth-0)))

(prove-lemma lstcpy-cpy1 (rewrite)
     (equal (lstcpy i1 lst1 i2 lst2 n)
            (lstcpy1 i1 lst1 i2 lst2 n)))

(prove-lemma put-get-lst-is-cpy (rewrite)
     (implies (mem-lst opsz x mem n2 lst2)
              (equal (put-lst opsz (get-lst opsz i2 lst2 n) i1 lst1 n)
                     (lstcpy i1 lst1 i2 lst2 n)))
     ((induct (lstcpy1 i1 lst1 i2 lst2 n))))

(prove-lemma put-get-vals-is-cpy (rewrite)
     (equal (put-vals (get-vals i2 lst2 n) i1 lst1 n)
            (lstcpy i1 lst1 i2 lst2 n))
     ((induct (lstcpy1 i1 lst1 i2 lst2 n))))

(disable lstcpy-cpy1)

;            MMOV1-LST, MMOV-LST1, MMOVN-LST AND MMOVN-LST1
(defn mmov1-lst (i lst1 lst2 n)
  (if (zerop n)
      lst1
    (mmov1-lst (add1 i) (put-nth (get-nth i lst2) i lst1) lst2 (sub1 n))))

; the same as mov1-lst.
(defn mmov1-lst1 (i lst1 lst2 n)
  (if (zerop n)
      lst1
    (mmov1-lst1 (sub1 i) (put-nth (get-nth (sub1 i) lst2) (sub1 i) lst1) 
               lst2 (sub1 n))))

(defn movn-lst (n lst1 lst2 i)
  (put-vals (get-vals i lst2 n) i lst1 n))

(defn mmovn-lst (h lst1 lst2 i nt)
  (if (zerop nt)
      lst1
    (mmovn-lst h (movn-lst h lst1 lst2 i) lst2 (plus h i) (sub1 nt))))

(defn mmovn-lst1 (h lst1 lst2 i nt)
  (if (zerop nt)
      lst1
    (mmovn-lst1 h (movn-lst h lst1 lst2 (difference i h)) lst2 
                (difference i h) (sub1 nt))))

(prove-lemma mmov1-lst-0 (rewrite)
     (equal (mmov1-lst i lst1 lst2 0) lst1))

(prove-lemma mmov1-lst1-0 (rewrite)
     (equal (mmov1-lst1 i lst1 lst2 0) lst1))

(prove-lemma mmovn-lst-0 (rewrite)
     (equal (mmovn-lst n lst1 lst2 i 0) lst1))
            
(prove-lemma mmovn-lst1-0 (rewrite)
     (equal (mmovn-lst1 n lst1 lst2 i 0) lst1))

;                     MOD32-EQ
(prove-lemma mod32-eq-deduction0 (rewrite)
     (mod32-eq x x))

(prove-lemma mod32-eq-deduction1 (rewrite)
     (and (equal (mod32-eq 0 (neg 32 x))
                 (mod32-eq x 0))
          (equal (mod32-eq (neg 32 x) 0)
                 (mod32-eq x 0)))
     ((use (sub-cancel0 (x 0) (y (head x 32)) (n 32)))))

(prove-lemma mod32-eq-deduction2 (rewrite)
     (and (equal (mod32-eq x (add 32 x y))
                 (mod32-eq 0 y))
          (equal (mod32-eq (add 32 x y) x)
                 (mod32-eq y 0)))
     ((use (add-cancel0 (x (head x 32)) (y (head y 32)) (n 32)))))

(prove-lemma mod32-eq-deduction3 (rewrite)
     (equal (mod32-eq (add 32 x y) (add 32 x z))
            (mod32-eq y z))
     ((use (add-cancel (y (head y 32)) (z (head z 32)) (n 32)))))

(disable mod32-eq)

; generate all the cases from between-ileq.
(prove-lemma between-ileq-la (rewrite)
     (implies (and (integerp x) 
                   (integerp y)
                   (integerp z))
              (equal (between-ileq x y z)
                     (if (ilessp z x)
                         f
                       (or (equal x y)
                           (between-ileq (iplus x 1) y z)))))
     ((enable iplus integerp)))

(disable between-ileq)

; readm-mem, mem-lst, and mem-ilst is not changed if read-mem is not
; changed.
(prove-lemma read-mem-plus (rewrite)
     (equal (read-mem addr mem (plus m k))
            (app (times 8 k)
                 (read-mem (add 32 addr m) mem k)
                 (read-mem addr mem m)))
     ((induct (read-mem addr mem k))
      (enable add-plus)))

(prove-lemma stepn-readm-mem (rewrite)
     (implies (equal (read-mem x (mc-mem (stepn s n)) (times opsz k))
                     (read-mem x (mc-mem s) (times opsz k)))
              (equal (readm-mem opsz x (mc-mem (stepn s n)) k)
                     (readm-mem opsz x (mc-mem s) k)))
     ((disable stepn)))

(prove-lemma stepn-mem-lst (rewrite)
     (implies (equal (readm-mem opsz x (mc-mem (stepn s n)) k)
                     (readm-mem opsz x (mc-mem s) k))
              (equal (mem-lst opsz x (mc-mem (stepn s n)) k lst)
                     (mem-lst opsz x (mc-mem s) k lst)))
     ((disable stepn)))

(prove-lemma stepn-mem-ilst (rewrite)
     (implies (equal (readm-mem opsz x (mc-mem (stepn s n)) k)
                     (readm-mem opsz x (mc-mem s) k))
              (equal (mem-ilst opsz x (mc-mem (stepn s n)) k lst)
                     (mem-ilst opsz x (mc-mem s) k lst)))
     ((disable stepn)))

(disable read-mem-plus)

;                   DISABLE EVENTS
; many events are no longer useful upon the completion of this system.
; before we enter the verification phase, we simply disable them.

;;;;;;;; disable arithmetic events.
(disable plus-add1-1)
(disable remainder-exit)
(disable quotient-exit)

;;;;;;; disable definitions in the specification.
; operations:  The semantics of these operations has been established as 
; rewrite rules in the library, which will be triggered to apply when
; nat-to-uint or nat-to-int are presented.
(disable mulu)
(disable muls)
(disable quot)
(disable rem)
(disable iquot)
(disable irem)
(disable lsl)
(disable lsr)
(disable asl)
(disable asr)

; condition codes:  To avoid to open up these flag definitions is one of the 
; several efforts to keep the proving space managable.  Another point is
; that one flag might have different semantics in different situations.
(disable fix-bit)
(disable add-v)
(disable add-z)
(disable add-n)
(disable addx-v)
(disable addx-z)
(disable addx-n)
(disable sub-v)
(disable sub-n)
(disable subx-v)
(disable subx-z)
(disable subx-n)
(disable and-z)
(disable and-n)
(disable mulu-v)
(disable mulu-z)
(disable mulu-n)
(disable muls-v)
(disable muls-z)
(disable muls-n)
(disable or-z)
(disable or-n)
(disable divs-z)
(disable divs-n)
(disable divu-z)
(disable divu-n)
(disable rol-c)
(disable rol-z)
(disable rol-n)
(disable ror-c)
(disable ror-z)
(disable ror-n)
(disable lsl-c)
(disable lsl-z)
(disable lsl-n)
(disable lsr-c)
(disable lsr-z)
(disable lsr-n)
(disable asl-c)
(disable asl-v)
(disable asl-z)
(disable asl-n)
(disable asr-c)
(disable asr-z)
(disable asr-n)
(disable roxl-c)
(disable roxl-z)
(disable roxl-n)
(disable roxr-c)
(disable roxr-z)
(disable roxr-n)
(disable move-z)
(disable move-n)
(disable ext-z)
(disable ext-n)
(disable swap-z)
(disable swap-n)
(disable not-z)
(disable not-n)
(disable eor-z)
(disable eor-n)

; read/write defns:  for each of them, we have had a set of rewrite rules. 
; their definitions are not needed to open up.
(disable pc-read-memp)
(disable pc-read-mem)
(disable read-memp)
(disable read-mem)
(disable write-memp)
(disable write-mem)
(disable readm-rn)
(disable writem-rn)

;;;;;;;; disable intermediate lemmas for read/write events:  to prove 
; some important theorems about read/write,  we proved many intermediate
; lemmas.  It is time to discard them.
(disable pc-read-memp-la0)
(disable pc-read-memp-la1)
(disable pc-read-memp-la2)
(disable pc-read-memp-la3)
(disable write-memp-la0)
(disable write-memp-la1)
(disable write-memp-la2)
(disable write-memp-la3)

;;;;;;;; disable intermediate lemmas for disjoint0/disjoint events.
(disable disjoint0)
(disable disjoint)
(disable disjoint0-la0)
(disable disjoint0-la1)
(disable disjoint0-la2)
(disable disjoint-la0)
(disable disjoint-la1)
(disable disjoint-la2)
(disable disjoint-la3)

;;;;;;;; disable intermediate lemmas for add/sub/neg events.
(disable add-non-numberp)
(disable add-commutativity)
(disable add-commutativity1)

;;;;;;;;  disable mapping functions.
(disable nat-to-uint)
(disable uint-to-nat)

;;;;;;;;  disable miscellaneous lemmas.
(disable stepn)

; addressing mode checking for each instruction.  Their arguments are 
; always "concrete" values.  For all the instructions, the oplen and ins 
; have to become known at the execution time.  Theoretically,  it would
; be nice to disable them.  But we do not want disabling to slow down
; the prover.  Therefore, we only disable them when we feel necessary.
(deftheory mode-guards 
  (add-addr-modep1 add-addr-modep2 adda-addr-modep sub-addr-modep1
   sub-addr-modep2 suba-addr-modep and-addr-modep1 and-addr-modep2
   mul&div-addr-modep or-addr-modep1 or-addr-modep2 s&r-addr-modep
   move-addr-modep movea-addr-modep lea-addr-modep clr-addr-modep
   move-from-ccr-addr-modep negx-addr-modep neg-addr-modep 
   move-to-ccr-addr-modep pea-addr-modep movem-rn-ea-addr-modep 
   movem-ea-rn-addr-modep tst-addr-modep tas-addr-modep jmp-addr-modep 
   jsr-addr-modep not-addr-modep scc-addr-modep addq-addr-modep 
   subq-addr-modep cmp-addr-modep cmpa-addr-modep eor&eori-addr-modep 
   bchg-addr-modep bclr-addr-modep bset-addr-modep btst-addr-modep 
   ori-addr-modep andi-addr-modep subi-addr-modep addi-addr-modep 
   cmpi-addr-modep))

; the classification of instructions, according to the opcode.
(deftheory groups 
  (bit-group move-ins move-group misc-group scc-group bcc-group 
   or-group sub-group cmp-group and-group add-group s&r-group))

;             INVARIANTS OF THE SPEC
(constrain h-invariant (rewrite)
   (and (equal (p x (write-mem value y mem m) k)
               (p x mem k))
        (implies (and (p x mem k) (write-memp y mem m))
                 (equal (h x (write-mem value y mem m) k)
                        (h x mem k))))
   ((p rom-addrp)
    (h rom-addrp)))

(prove-lemma addr-index2-mem (rewrite)
     (equal (mc-mem (car (addr-index2 pc addr indexwd s)))
            (mc-mem s))
     ((disable index-register bits ir-scaled)))

(prove-lemma immediate-mem (rewrite)
     (equal (mc-mem (car (immediate oplen pc s)))
            (mc-mem s)))

(prove-lemma effec-addr-mem (rewrite)
     (equal (mc-mem (car (effec-addr oplen mode rn s)))
            (mc-mem s))
     ((disable addr-index2 immediate)))

(prove-lemma mc-instate-mem (rewrite)
     (equal (mc-mem (car (mc-instate oplen ins s)))
            (mc-mem s))
     ((disable effec-addr)))

(prove-lemma mapping-h (rewrite)
     (implies (p x (mc-mem (car s&addr)) k)
              (equal (h x (mc-mem (mapping oplen v&cvznx s&addr)) k)
                     (h x (mc-mem (car s&addr)) k))))

(defn t3 (x y z) t)
  
; add-group.
(prove-lemma add-group-h (rewrite)
     (implies (p x (mc-mem s) k)
              (equal (h x (mc-mem (add-group opmode ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate bits op-len pre-effect)
      (disable-theory mode-guards)))

; sub-group.
(prove-lemma sub-group-h (rewrite)
     (implies (p x (mc-mem s) k)
              (equal (h x (mc-mem (sub-group opmode ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable mapping mc-instate bits op-len pre-effect)
      (disable-theory mode-guards)))
     
; and-group.
(prove-lemma and-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (and-group oplen ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate)
      (disable-theory mode-guards)))

; or-group.
(prove-lemma or-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (or-group oplen ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate)
      (disable-theory mode-guards)))

; scc-group.
(prove-lemma scc-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (scc-group ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate branch-cc bits op-len)
      (disable-theory mode-guards)))

; cmp-group.
(prove-lemma cmp-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (cmp-group oplen ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate bits post-effect)
      (disable-theory mode-guards)))

; bcc-group.
(prove-lemma bcc-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (bcc-group disp ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mc-instate mapping branch-cc bits)
      (disable-theory mode-guards)))

; bit-group.
(prove-lemma write-mem-maintain-movep-writep (rewrite)
     (equal (movep-writep addr (write-mem value x mem m) n)
            (movep-writep addr mem n))
     ((induct (movep-writep addr mem n))))

(prove-lemma movep-write-h (rewrite)
     (implies (and (p x mem k) (movep-writep addr mem n))
              (equal (h x (movep-write value addr mem n) k)
                     (h x mem k)))
     ((induct (movep-write value addr mem n))))

(prove-lemma bit-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (bit-group ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mc-instate mapping immediate op-len bits)
      (disable-theory mode-guards)))

; move-group.
(prove-lemma move-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (move-ins oplen ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping effec-addr mc-instate)
      (disable-theory mode-guards)))

(prove-lemma move-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (move-group oplen ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mapping mc-instate move-ins)
      (disable-theory mode-guards)))

; s&r-group.
(prove-lemma s&r-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (s&r-group ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand mc-instate mapping op-len bits sr-cnt)
      (disable-theory mode-guards)))

; misc-group.
(prove-lemma writem-mem-h (rewrite)
     (implies (and (p x mem k) 
                   (write-memp addr mem (times opsz (len vlst))))
              (equal (h x (writem-mem opsz vlst addr mem) k)
                     (h x mem k)))
     ((induct (writem-mem opsz vlst addr mem))
      (enable write-memp-la2 write-memp-la3)))

(prove-lemma movem-rnlst-len (rewrite)
     (equal (len (movem-rnlst mask i))
            (movem-len mask)))

(prove-lemma movem-pre-rnlst-len (rewrite)
     (equal (len (movem-pre-rnlst mask i lst))
            (plus (movem-len mask) (len lst))))          

(prove-lemma misc-group-h (rewrite)
     (implies (p x (mc-mem s) k)             
              (equal (h x (mc-mem (misc-group ins s)) k)
                     (h x (mc-mem s) k)))
     ((disable operand effec-addr mc-instate mapping op-len bits op-sz)
      (disable-theory mode-guards)))
             
(prove-lemma stepi-h (rewrite)
     (implies (p x (mc-mem s) k)
              (equal (h x (mc-mem (stepi s)) k)
                     (h x (mc-mem s) k)))
     ((disable-theory groups)))

(functionally-instantiate stepi-p (rewrite)
    (implies (t3 x (mc-mem s) k)
             (equal (p x (mc-mem (stepi s)) k)
                    (p x (mc-mem s) k)))
    stepi-h
    ((h p)
     (p t3)))

(prove-lemma stepn-h (rewrite)
     (implies (p x (mc-mem s) k)
              (equal (h x (mc-mem (stepn s n)) k)
                     (h x (mc-mem s) k)))
     ((disable stepi) (enable stepn)))

; the instantiations.
(functionally-instantiate stepn-pc-read-memp (rewrite)
    (implies (t3 x (mc-mem s) k)                          
             (equal (pc-read-memp x (mc-mem (stepn s n)) k)
                    (pc-read-memp x (mc-mem s) k)))
    stepn-h
    ((h pc-read-memp)
     (p t3)))

(functionally-instantiate stepn-read-memp (rewrite)
    (implies (t3 x (mc-mem s) k)                          
             (equal (read-memp x (mc-mem (stepn s n)) k)
                    (read-memp x (mc-mem s) k)))
    stepn-h
    ((h read-memp)
     (p t3)))

(functionally-instantiate stepn-write-memp (rewrite)
    (implies (t3 x (mc-mem s) k)                          
             (equal (write-memp x (mc-mem (stepn s n)) k)
                    (write-memp x (mc-mem s) k)))
    stepn-h
    ((h write-memp)
     (p t3)))

; after the execution of n arbitrary instructions, ROM is still ROM.
(prove-lemma stepn-rom-addrp (rewrite)
     (equal (rom-addrp x (mc-mem (stepn s n)) k)
            (rom-addrp x (mc-mem s) k))
     ((enable rom-addrp)))

; after the execution of n arbitrary instructions, RAM is still RAM.
(prove-lemma stepn-ram-addrp (rewrite)
     (equal (ram-addrp x (mc-mem (stepn s n)) k)
            (ram-addrp x (mc-mem s) k))
     ((enable ram-addrp)))

; after the execution of n arbitrary instructions, the contents of 
; the memory are not modified if that portion of the memory is ROM. 
(functionally-instantiate stepn-pc-read-mem (rewrite)
    (implies (rom-addrp x (mc-mem s) k)                   
             (equal (pc-read-mem x (mc-mem (stepn s n)) k)
                    (pc-read-mem x (mc-mem s) k)))
    stepn-h
    ((h pc-read-mem)
     (p rom-addrp)))

(prove-lemma stepn-read-mem (rewrite)
    (implies (rom-addrp x (mc-mem s) k)                   
             (equal (read-mem x (mc-mem (stepn s n)) k)
                    (read-mem x (mc-mem s) k)))
    ((enable read->pc-read-mem)))

; after the execution of n arbitrary instructions, the program segment 
; maintains the same.  Since we always require programs in ROM.
(prove-lemma stepn-mcode-addrp (rewrite)
     (implies (rom-addrp x (mc-mem s) (len lst))
              (equal (mcode-addrp x (mc-mem (stepn s n)) lst)
                     (mcode-addrp x (mc-mem s) lst)))
     ((induct (mcode-addrp x mem lst))))

(disable splus)
(disable mcode-addrp)

; end of the proving phase. ****************

;-------------------------------------------------------------------------
;                  VERIFICATION PHASE
;-------------------------------------------------------------------------
; our goal is to verify programs at machine code level. Before we go to 
; specific programs, we introduce some conventions of machine code program
; constructs.  This section provides some useful concepts for us to specify
; and verify machine code programs.
;
; look up as unsigned integers.
(defn uread-mem (x mem n)
  (nat-to-uint (read-mem x mem n)))

(defn uread-dn (oplen dn s)
  (nat-to-uint (read-dn oplen dn s)))

(defn uread-an (oplen an s)
  (nat-to-uint (read-an oplen an s)))

; look up as signed integers.
(defn iread-mem (x mem n)
  (nat-to-int (read-mem x mem n) (times 8 n)))

(defn iread-dn (oplen dn s)
  (nat-to-int (read-dn oplen dn s) oplen))

(defn iread-an (oplen an s)
  (nat-to-int (read-an oplen an s) oplen))

; the return address of subroutine call.
(defn rts-addr (s)
  (read-mem (read-an 32 7 s) (mc-mem s) 4))

(defn linked-rts-addr (s)
  (read-mem (add 32 (read-an 32 6 s) 4) (mc-mem s) 4))

; the saved A6 on the stack.
(defn linked-a6 (s)
  (read-mem (read-an 32 6 s) (mc-mem s) 4))

; for MOVEM instruction.  After the link, A6 points to some place
; on the stack.  s is the current machine state, opsz is the 
; operation size of the MOVEM,  i is the offset relative to a6,
; and n is the number of registers moved.  
(defn movem-saved (s opsz i n)
  (readm-mem opsz (sub 32 i (read-an 32 6 s)) (mc-mem s) n))

; when only one register is saved,  we use MOVE instead of MOVEM.
(defn rn-saved (s)
  (read-mem (sub 32 4 (read-an 32 6 s)) (mc-mem s) 4))

; We do not want to deal with nat-to-int and int-to-nat in the logic 
; level.  In the logic level, the proof concerns purely the algorithmic
; correctness in the problem.  It is hoped to be machine independent.
(defn lst-int (n lst)
  (if (nlistp lst)
      lst
    (cons (nat-to-int (car lst) n)
          (lst-int n (cdr lst)))))

(prove-lemma get-lst-int (rewrite)
     (equal (get-nth i (lst-int n lst))
            (nat-to-int (get-nth i lst) n)))

(prove-lemma put-lst-int (rewrite)
     (equal (put-nth (nat-to-int value n) i (lst-int n lst))
            (lst-int n (put-nth value i lst))))

(defn lst-integerp (lst)
  (if (nlistp lst)
      t
    (and (integerp (car lst))
         (lst-integerp (cdr lst)))))

(prove-lemma get-lst-integerp (rewrite)
     (implies (lst-integerp lst)
              (integerp (get-nth n lst))))

(prove-lemma mem-lst-integerp (rewrite)
     (implies (and (mem-lst opsz a mem n lst)
                   (equal oplen (times 8 opsz)))
              (lst-integerp (lst-int oplen lst))))

(prove-lemma mem-ilst-lst-integerp (rewrite)
     (implies (mem-ilst opsz a mem n lst)
              (lst-integerp lst)))

(disable mem-lst)
(disable mem-ilst)

; a trick to get all the appearances of a term replaced by another 
; term. For example, in subroutines, a6 is used as the addresss register
; for LINK. It is often relative to sp(a7).  We'd like to have a6 
; replaced by a7.
(defn equal* (x y)
  (equal x y))

(prove-lemma equal*-reflex (rewrite)
     (equal* x x))

(prove-lemma read-rn-equal* (rewrite)
     (implies (equal* (read-rn oplen rn rfile) x)
              (equal (read-rn oplen rn rfile) x)))

(disable equal*)

; the registers d0, d1, a0, and a1 are available for any subroutines.  
; There is no obligation for subroutines to restore their previous values.
; Therefore, we do not need to keep track of them.  We handle a7
; (the stack pointer) separately to make sure it is set correctly.  
; a6 (the frame pointer) perhaps also deserves special treatment.
(defn d2-7a2-5p (rn)
  (and (not (zerop rn))
       (not (equal rn 1))
       (not (equal rn 8))
       (not (equal rn 9))
       (not (equal rn 14))
       (not (equal rn 15))))

; d2 will be used for some purpose.
(defn d3-7a2-5p (rn)
  (and (d2-7a2-5p rn)
       (not (equal rn 2))))

; d2 and d3 will be used for some purpose.
(defn d4-7a2-5p (rn)
  (and (d2-7a2-5p rn)
       (not (equal rn 2))
       (not (equal rn 3))))

; d2, d3, and d4 will be used for some purpose.
(defn d5-7a2-5p (rn)
  (and (d2-7a2-5p rn)
       (not (equal rn 2))
       (not (equal rn 3))
       (not (equal rn 4))))

; a2 will be used for some purpose.
(defn d2-7a3-5p (rn)
  (and (d2-7a2-5p rn)
       (not (equal rn 10))))

(defn d4-7a4-5p (rn)
  (and (d4-7a2-5p rn)
       (not (equal rn 10))
       (not (equal rn 11))))

(defn d4-7a5p (rn)
  (and (d4-7a2-5p rn)
       (not (equal rn 10))
       (not (equal rn 11))
       (not (equal rn 12))))

(defn d5-7a4-5p (rn)
  (and (d4-7a2-5p rn)
       (not (equal rn 4))
       (not (equal rn 10))
       (not (equal rn 11))))
            
(defn d6-7a2-5p (rn)
  (and (d4-7a2-5p rn)
       (not (equal rn 4))
       (not (equal rn 5))))
            
; something I don't know where to put yet.
; the mean (i+j)/2 < j iff i < j.
(prove-lemma mean-lessp-lemma (rewrite)
        (equal (lessp (plus i j) (times 2 j))
               (lessp i j))
        ((induct (difference j i))))

(prove-lemma mean-lessp (rewrite)        
     (and (equal (lessp (quotient (plus i j) 2) j)
                 (lessp i j))
          (equal (lessp (quotient (plus j i) 2) j)
                 (lessp i j))))

; swap the ith and jth elements of the list.
(defn swap (i j lst)
  (put-nth (get-nth i lst) j (put-nth (get-nth j lst) i lst)))

(prove-lemma get-swap (rewrite)
     (equal (get-nth k (swap i j lst))
            (if (equal (fix k) (fix i))
                (get-nth j lst)
              (if (equal (fix k) (fix j))
                  (get-nth i lst)
                (get-nth k lst)))))

(disable get-nth)
(disable put-nth)

; C conventions.
(defn null () 0)

(defn eof () -1)

; the Nqthm counterparts of the Berkeley C string functions.
; memchr.
(defn memchr1 (i n lst ch)
  (if (equal (get-nth i lst) ch)
      (fix i)
    (if (equal (sub1 n) 0)
        f
      (memchr1 (add1 i) (sub1 n) lst ch))))

(defn memchr (n lst ch)
  (if (equal n 0) f (memchr1 0 n lst ch)))      

; memcmp.
(defn memcmp1 (i n lst1 lst2)
  (if (equal (get-nth i lst1) (get-nth i lst2))
      (if (equal (sub1 n) 0)
          0
        (memcmp1 (add1 i) (sub1 n) lst1 lst2))
    (idifference (get-nth i lst1) (get-nth i lst2))))

(defn memcmp (n lst1 lst2)
  (if (equal n 0) 0 (memcmp1 0 n lst1 lst2)))

; memset.
(defn memset1 (i n lst ch)
  (if (equal (sub1 n) 0)
      (put-nth ch i lst)
    (memset1 (add1 i) (sub1 n) (put-nth ch i lst) ch)))

(defn memset (n lst ch)
  (if (equal n 0) lst (memset1 0 n lst ch)))

; strlen.
(defn strlen (i n lst)
  (if (lessp i n)
      (if (equal (get-nth i lst) (null))
          i
        (strlen (add1 i) n lst))
    i)
  ((lessp (difference n i))))

; strcpy.
(defn strcpy (i lst1 n2 lst2)
  (if (lessp i n2)
      (if (equal (get-nth i lst2) (null))
          (put-nth (null) i lst1)
        (strcpy (add1 i) (put-nth (get-nth i lst2) i lst1) n2 lst2))
    lst1)
  ((lessp (difference n2 i))))

; strcmp.
(defn strcmp (i n1 lst1 lst2)
  (if (lessp i n1)
      (if (equal (get-nth i lst1) (get-nth i lst2))
          (if (equal (get-nth i lst1) (null))
              0
            (strcmp (add1 i) n1 lst1 lst2))
        (idifference (get-nth i lst1) (get-nth i lst2)))
    0)
  ((lessp (difference n1 i))))

; strcoll.
(defn strcoll (n1 lst1 lst2)
  (strcmp 0 n1 lst1 lst2))

; strcat.
(defn strcpy1 (i lst1 j n2 lst2)
  (if (lessp j n2)
      (if (equal (get-nth j lst2) (null))
          (put-nth (null) i lst1)
        (strcpy1 (add1 i) (put-nth (get-nth j lst2) i lst1) (add1 j) n2 lst2))
    lst1)
  ((lessp (difference n2 j))))

(defn strcat (n1 lst1 n2 lst2)
  (if (equal (get-nth 0 lst1) (null))
      (strcpy1 0 lst1 0 n2 lst2)
    (strcpy1 (strlen 1 n1 lst1) lst1 0 n2 lst2)))

; strncat.
(defn strcpy2 (i lst1 j n lst2)
  (if (equal (get-nth j lst2) (null))
      (put-nth (null) i lst1)
    (if (equal (sub1 n) 0)
        (put-nth (null) (add1 i) (put-nth (get-nth j lst2) i lst1))
      (strcpy2 (add1 i) (put-nth (get-nth j lst2) i lst1) (add1 j) 
               (sub1 n) lst2))))

(defn strncat (n1 lst1 n lst2)
  (if (equal n 0)
      lst1
    (if (equal (get-nth 0 lst1) (null))
        (strcpy2 0 lst1 0 n lst2)
      (strcpy2 (strlen 1 n1 lst1) lst1 0 n lst2))))

; strncmp.
(defn strncmp1 (i n lst1 lst2)
  (if (equal (get-nth i lst1) (get-nth i lst2))
      (if (equal (get-nth i lst1) 0)
          0
        (if (equal (sub1 n) 0)
            0
          (strncmp1 (add1 i) (sub1 n) lst1 lst2)))
    (idifference (get-nth i lst1) (get-nth i lst2))))

(defn strncmp (n lst1 lst2)
  (if (zerop n) 0 (strncmp1 0 n lst1 lst2)))

; strncpy.      
(defn zero-list1 (i n lst)
  (if (equal (sub1 n) 0)
      lst
    (zero-list1 (add1 i) (sub1 n) (put-nth 0 i lst))))

(defn zero-list (i n lst)
  (zero-list1 (add1 i) n (put-nth 0 i lst)))

(defn strncpy1 (i n lst1 lst2)
  (if (equal (get-nth i lst2) 0)
      (zero-list i n lst1)
    (if (equal (sub1 n) 0)
        (put-nth (get-nth i lst2) i lst1)
      (strncpy1 (add1 i) (sub1 n) (put-nth (get-nth i lst2) i lst1) lst2))))

(defn strncpy (n lst1 lst2)
  (if (zerop n)
      lst1
    (strncpy1 0 n lst1 lst2)))

; strchr.
(defn strchr (i n lst ch)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
          (fix i)
        (if (equal (get-nth i lst) 0)
            f
          (strchr (add1 i) n lst ch)))
    f)
  ((lessp (difference n i))))

; strcspn.
(defn strcspn (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
          (fix i1)
        (strcspn (add1 i1) n1 lst1 n2 lst2))
    f)
  ((lessp (difference n1 i1))))

; strrchr.
(defn strrchr (i n lst ch j)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
          (if (equal (get-nth i lst) 0)
              (fix i)
            (strrchr (add1 i) n lst ch (fix i)))
        (if (equal (get-nth i lst) 0)
            j
          (strrchr (add1 i) n lst ch j)))
    j)
  ((lessp (difference n i))))       

; strspn.
(defn strchr1 (i n lst ch)
  (if (lessp i n)
      (if (equal (get-nth i lst) 0)
          f
        (if (equal (get-nth i lst) ch)
            (fix i)
          (strchr1 (add1 i) n lst ch)))
    f)
  ((lessp (difference n i))))

(prove-lemma strchr1-bounds (rewrite)
     (and (not (lessp n (strchr1 i n lst ch)))
          (implies (strchr1 i n lst ch)
                   (not (lessp (strchr1 i n lst ch) i)))))

(prove-lemma strchr1-false-0 (rewrite)
     (not (strchr1 i n lst 0)))

(defn strspn (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
          (strspn (add1 i1) n1 lst1 n2 lst2)
        (fix i1))
    f)
  ((lessp (difference n1 i1))))

; strpbrk.
(defn strpbrk (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (equal (get-nth i1 lst1) 0)
          f
        (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
            (fix i1)
          (strpbrk (add1 i1) n1 lst1 n2 lst2)))
    f)
  ((lessp (difference n1 i1))))

; strstr.
(defn strstr1 (i n1 lst1 n2 lst2 len)
  (if (lessp i n1)
      (let ((j (strchr1 i n1 lst1 (get-nth 0 lst2))))
        (if (numberp j)
            (if (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
                j
              (strstr1 (add1 j) n1 lst1 n2 lst2 len))
          f))
    f)
  ((lessp (difference n1 i))))

(defn strstr (n1 lst1 n2 lst2)
  (if (equal (get-nth 0 lst2) 0)
      0
    (strstr1 0 n1 lst1 n2 lst2 (strlen 0 (sub1 n2) (mcdr 1 lst2)))))

; memmove.
(defn memmove-1 (lst1 lst2 i nt n)
  (if (equal (remainder n 4) 0)
      (mmovn-lst 4 lst1 lst2 i nt)
    (mmov1-lst (plus i (times 4 nt)) (mmovn-lst 4 lst1 lst2 i nt)
               lst2 (remainder n 4))))

(defn memmove-0 (lst1 lst2 i nt n)
  (if (lessp n 4)
      (mmov1-lst (plus i nt) (mmov1-lst i lst1 lst2 nt) lst2 n)
    (memmove-1 (mmov1-lst i lst1 lst2 nt) lst2 (plus i nt) (quotient n 4) n)))

(defn memmove-4 (lst1 lst2 i nt n)
  (if (equal (remainder n 4) 0)
      (mmovn-lst1 4 lst1 lst2 i nt)
    (mmov1-lst1 (difference i (times 4 nt)) (mmovn-lst1 4 lst1 lst2 i nt)
                lst2 (remainder n 4))))

(defn memmove-3 (lst1 lst2 i nt n)
  (if (lessp n 4)
      (mmov1-lst1 (difference i nt) (mmov1-lst1 i lst1 lst2 nt) lst2 n)
    (memmove-4 (mmov1-lst1 i lst1 lst2 nt) lst2 (difference i nt) 
               (quotient n 4) n)))

(defn memmove (str1 str2 n lst1 lst2)
  (if (zerop n)
      lst1
    (if (equal (nat-to-uint str1) (nat-to-uint str2))
        lst2
      (let ((x1 (nat-to-uint str1))
            (x2 (nat-to-uint str2)))
        (if (lessp x1 x2)
            (if (and (equal (remainder x1 4) 0)
                     (equal (remainder x2 4) 0))
                (if (lessp n 4)
                    (mmov1-lst 0 lst1 lst2 n)
                  (memmove-1 lst1 lst2 0 (quotient n 4) n))
              (if (and (equal (remainder x1 4) (remainder x2 4))
                       (lessp 3 n))
                  (memmove-0 lst1 lst2 0 (difference 4 (remainder x1 4))
                             (difference (plus n (remainder x1 4)) 4))
                (memmove-0 lst1 lst2 0 n 0)))
          (let ((y1 (plus n x1))
                (y2 (plus n x2)))
            (if (and (equal (remainder y1 4) 0)
                     (equal (remainder y2 4) 0))
                (if (lessp n 4)
                    (mmov1-lst1 n lst1 lst2 n)
                  (memmove-4 lst1 lst2 n (quotient n 4) n))
              (if (and (equal (remainder y1 4) (remainder y2 4))
                       (lessp 4 n))
                  (memmove-3 lst1 lst2 n (remainder y1 4)
                             (difference n (remainder y1 4)))
                (memmove-3 lst1 lst2 n n 0)))))))))

; dual events of string functions.  They are for internal use only and
; hardly visible for users.
(defn strlen* (i* i n lst)
  (if (lessp i n)
      (if (equal (get-nth i lst) (null))
          i*
        (strlen* (add 32 i* 1) (add1 i) n lst))
    i*)
  ((lessp (difference n i))))

(defn memchr* (i* i n lst ch)
  (if (equal (get-nth i lst) ch)
      i*
    (if (equal (sub1 n) 0)
        f
      (memchr* (add 32 i* 1) (add1 i) (sub1 n) lst ch))))

(defn strchr* (i* i n lst ch)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
          i*
        (if (equal (get-nth i lst) 0)
            f
          (strchr* (add 32 i* 1) (add1 i) n lst ch)))
    f)
  ((lessp (difference n i))))

(defn strchr1* (i* i n lst ch)
  (if (lessp i n)
      (if (equal (get-nth i lst) 0)
          f
        (if (equal (get-nth i lst) ch)
            i*
          (strchr1* (add 32 i* 1) (add1 i) n lst ch)))
    f)
  ((lessp (difference n i))))

(defn strcspn* (i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
          i1*
        (strcspn* (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2))
    f)
  ((lessp (difference n1 i1))))

(defn strrchr* (i* i n lst ch j*)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
          (if (equal (get-nth i lst) 0)
              i*
            (strrchr* (add 32 i* 1) (add1 i) n lst ch i*))
        (if (equal (get-nth i lst) 0)
            j*
          (strrchr* (add 32 i* 1) (add1 i) n lst ch j*)))
    j*)
  ((lessp (difference n i))))

(defn strpbrk* (i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (equal (get-nth i1 lst1) 0)
          f
        (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
            i1*
          (strpbrk* (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2)))
    f)
  ((lessp (difference n1 i1))))

(defn strspn* (i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
          (strspn* (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2)
        i1*)
    f)
  ((lessp (difference n1 i1))))

(defn strstr1* (i* i n1 lst1 n2 lst2 len)
  (if (lessp i n1)
      (let ((j* (strchr1* i* i n1 lst1 (get-nth 0 lst2)))
            (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
        (if (numberp j)
            (if (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
                j*
              (strstr1* (add 32 j* 1) (add1 j) n1 lst1 n2 lst2 len))
          f))
    f)
  ((lessp (difference n1 i))))

(defn strstr* (n1 lst1 n2 lst2)
  (if (equal (get-nth 0 lst2) 0)
      0
    (strstr1* 0 0 n1 lst1 n2 lst2 (strlen 0 (sub1 n2) (mcdr 1 lst2)))))

; strtok.
; the location of the token.
(defn strtok-tok (str1 last n1 lst1 n2 lst2)
  (let ((i* (strspn* 0 0 n1 lst1 n2 lst2))
        (i (strspn 0 n1 lst1 n2 lst2)))
    (if (equal (nat-to-uint str1) 0)
        (if (equal (nat-to-uint last) 0)
            0
          (if (equal (get-nth i lst1) 0)
              0
            (add 32 last i*)))
      (if (equal (get-nth i lst1) 0)
          0
        (add 32 str1 i*)))))

; the new lst1.
(defn strtok-lst0 (i1 lst1 ch)
  (if (equal ch 0) lst1 (put-nth 0 i1 lst1)))

(defn strtok-lst1 (i1 n1 lst1 n2 lst2)
  (let ((i (strcspn i1 n1 lst1 n2 lst2)))
    (strtok-lst0 i lst1 (get-nth i lst1))))

(defn strtok-lst2 (i1 n1 lst1 n2 lst2)
  (if (equal (get-nth i1 lst1) 0)
      lst1
    (strtok-lst1 (add1 i1) n1 lst1 n2 lst2)))

(defn strtok-lst (n1 lst1 n2 lst2)
  (strtok-lst2 (strspn 0 n1 lst1 n2 lst2) n1 lst1 n2 lst2))

; the new value of the static variable.
(defn strtok-last0 (str1 i1* i1 n1 lst1 n2 lst2)
  (let ((i* (strcspn* i1* i1 n1 lst1 n2 lst2))
        (i (strcspn i1 n1 lst1 n2 lst2)))
    (if (equal (get-nth i lst1) 0)
        0
      (add 32 str1 (add 32 i* 1)))))

(defn strtok-last1 (str1 i1* i1 n1 lst1 n2 lst2)
  (if (equal (get-nth i1 lst1) 0)
      0
    (strtok-last0 str1 (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2)))

(defn strtok-last (str1 last n1 lst1 n2 lst2)
  (let ((i* (strspn* 0 0 n1 lst1 n2 lst2))
        (i (strspn 0 n1 lst1 n2 lst2)))
    (if (equal (nat-to-uint str1) 0)
        (if (equal (nat-to-uint last) 0)
            last
          (strtok-last1 last i* i n1 lst1 n2 lst2))
      (strtok-last1 str1 i* i n1 lst1 n2 lst2))))

; strxfrm.
(defn strxfrm1 (i lst1 lst2 n)
  (if (equal (get-nth i lst2) 0)
      (put-nth 0 i lst1)
    (if (equal (sub1 n) 0)
        (put-nth 0 i lst1)
      (strxfrm1 (add1 i) (put-nth (get-nth i lst2) i lst1) lst2 (sub1 n)))))

(defn strxfrm (lst1 lst2 n)
  (if (zerop n)
      lst1
    (strxfrm1 0 lst1 lst2 n)))

; a list of characters.
(defn lst-of-chrp (lst)
  (if (listp lst)
      (and (numberp (car lst))
           (lessp (car lst) 256)
           (lst-of-chrp (cdr lst)))
    t))

; theorems about lst-of-chrp.
(prove-lemma get-lst-of-chrp (rewrite)
     (implies (lst-of-chrp lst)
              (and (lessp (get-nth i lst) 256)
                   (numberp (get-nth i lst))))
     ((enable get-nth)))

(prove-lemma put-lst-of-chrp (rewrite)
     (implies (lst-of-chrp lst)
              (equal (lst-of-chrp (put-nth x i lst))
                     (and (numberp x) (lessp x 256))))
     ((enable put-nth)))

#|
(prove-lemma lessp-read-mem-1 (rewrite)
     (lessp (read-mem x mem 1) 256)
     ((use (byte-read-nat-rangep (n 8)))
      (enable nat-rangep)))

(prove-lemma mem-lst-of-chrp (rewrite)
     (implies (mem-lst 1 x mem n lst)
              (lst-of-chrp lst))
     ((enable mem-lst)))
|#

(disable lst-of-chrp)

; the predicate stringp.
(defn slen (i n lst)
  (if (lessp i n)
      (if (equal (get-nth i lst) (null))
          (fix i)
        (slen (add1 i) n lst))
    (fix i))
  ((lessp (difference n i))))

(defn stringp (i n lst)
  (lessp (slen i n lst) n))

; events for slen, which is part of stringp.
(prove-lemma slen-ubound (rewrite)
     (implies (leq i n)
              (not (lessp n (slen i n lst)))))

(prove-lemma slen-lbound (rewrite)
     (not (lessp (slen i n lst) i)))

(prove-lemma slen-01 (rewrite)
     (and (equal (slen i 0 lst) (fix i))
          (equal (slen i 1 lst) 
                 (if (and (lessp i 1)
                          (not (equal (get-nth 0 lst) 0)))
                     1 (fix i))))
     ((enable get-nth-0)))

(prove-lemma slen-add1 (rewrite)
     (equal (slen i (add1 i) lst)
            (if (equal (get-nth i lst) 0) (fix i) (add1 i))))

(prove-lemma slen-put0 (rewrite)
     (equal (slen i n (put-nth 0 i lst))
            (fix i)))
              
(prove-lemma slen-put (rewrite)
     (implies (lessp j i)
              (equal (slen i n (put-nth v j lst))
                     (slen i n lst))))

(prove-lemma lessp-slen-mcdr (rewrite)
     (implies (lessp (slen (plus i k) n1 lst1) n1)
              (equal (lessp (slen i n (mcdr k lst1)) (difference n1 k)) t))
     ((enable plus-add1-1)))

(prove-lemma lessp-slen-mcdr-0 (rewrite)
     (implies (lessp (slen (add1 i) n1 lst1) n1)
              (equal (lessp (slen i n (mcdr 1 lst1)) (sub1 n1)) t))
     ((use (lessp-slen-mcdr (k 1)))))

(prove-lemma slen-rec (rewrite)
     (implies (and (not (equal (get-nth i lst) 0))
                   (lessp i n))
              (equal (slen (add1 i) n lst)
                     (slen i n lst))))

(disable slen)

; theorems about stringp.
(prove-lemma stringp-la (rewrite)
     (implies (and (stringp i n lst)
                   (int-rangep n nn)
                   (not (equal (get-nth i lst) 0)))
              (int-rangep (add1 i) nn))
     ((enable int-rangep integerp)))

; theorems about strchr.
(prove-lemma strchr-bounds (rewrite)
     (and (not (lessp n (strchr i n lst ch)))
          (implies (strchr i n lst ch)
                   (not (lessp (strchr i n lst ch) i)))))

(prove-lemma memchr-bounds (rewrite)
     (and (not (lessp (plus i n) (memchr1 i n lst ch)))
          (implies (memchr1 i n lst ch)
                   (not (lessp (memchr1 i n lst ch) i))))
     ((induct (memchr1 i n lst ch))))

(prove-lemma strpbrk-bounds (rewrite)
     (and (not (lessp n1 (strpbrk i1 n1 lst1 n2 lst2)))
          (implies (strpbrk i1 n1 lst1 n2 lst2)
                   (not (lessp (strpbrk i1 n1 lst1 n2 lst2) i1)))))

(prove-lemma strrchr-bounds (rewrite)
     (implies (leq j n) 
              (not (lessp n (strrchr i n lst ch j)))))

(prove-lemma strstr-bounds (rewrite)
     (and (not (lessp n1 (strstr1 i n1 lst1 n2 lst2 len)))
          (implies (strstr1 i n1 lst1 n2 lst2 len)
                   (not (lessp (strstr1 i n1 lst1 n2 lst2 len) i)))))

(prove-lemma strspn-ubound (rewrite)
     (implies (not (zerop n1))
              (lessp (strspn i n1 lst1 n2 lst2) n1)))

(prove-lemma strspn-bounds (rewrite)
     (and (not (lessp n1 (strspn i n1 lst1 n2 lst2)))
          (implies (strspn i n1 lst1 n2 lst2)
                   (not (lessp (strspn i n1 lst1 n2 lst2) i)))))

(prove-lemma strcspn-bounds (rewrite)
     (and (not (lessp n1 (strcspn i n1 lst1 n2 lst2)))
          (implies (strcspn i n1 lst1 n2 lst2)
                   (not (lessp (strcspn i n1 lst1 n2 lst2) i)))))

; a lemma to establish nat-rangep.
(prove-lemma nat-rangep-la (rewrite)
     (implies (lessp (nat-to-uint x) (exp 2 n))
              (nat-rangep x n))
     ((enable nat-rangep nat-to-uint)))

(disable nat-rangep-la)

; some useful lemmas.  I do not know where to put them yet.
; I will put them in the right place.
(prove-lemma disjoint-1-int (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq (plus (nat-to-int k 32) l) n)
                   (numberp (nat-to-int k 32)))
              (disjoint a j (add 32 b k) l))
     ((enable nat-to-int)))

(prove-lemma disjoint-2-int (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-int i 32) j) m)
                   (leq l n)
                   (numberp (nat-to-int i 32)))
              (disjoint (add 32 a i) j b l))
     ((enable nat-to-int)))

(prove-lemma disjoint-2~-int (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-int i 32) j) m)
                   (leq l n)
                   (numberp (nat-to-int i 32)))
              (disjoint b l (add 32 a i) j))
     ((enable nat-to-int)))

(prove-lemma disjoint-3-int (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-int i 32) j) m)
                   (leq (plus (nat-to-int k 32) l) n)
                   (numberp (nat-to-int i 32))
                   (numberp (nat-to-int k 32)))
              (disjoint (add 32 a i) j (add 32 b k) l))
     ((enable nat-to-int)))

(prove-lemma read-memp-ram1-uint (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq (plus (nat-to-uint i) j) k))
              (read-memp (add 32 addr i) mem j))
     ((enable nat-to-uint)))

(prove-lemma write-memp-ram1-uint (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq (plus (nat-to-uint i) j) k))
              (write-memp (add 32 addr i) mem j))
     ((enable nat-to-uint)))

(prove-lemma disjoint-1-uint (rewrite)
     (implies (and (disjoint a m b n)
                   (leq j m)
                   (leq (plus (nat-to-uint k) l) n))
              (disjoint a j (add 32 b k) l))
     ((enable nat-to-uint)))

(prove-lemma disjoint-2-uint (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-uint i) j) m)
                   (leq l n))
              (disjoint (add 32 a i) j b l))
     ((enable nat-to-uint)))

(prove-lemma disjoint-2~-uint (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-uint i) j) m)
                   (leq l n))
              (disjoint b l (add 32 a i) j))
     ((enable nat-to-uint)))

(prove-lemma disjoint-3-uint (rewrite)
     (implies (and (disjoint a m b n)
                   (leq (plus (nat-to-uint i) j) m)
                   (leq (plus (nat-to-uint k) l) n))
              (disjoint (add 32 a i) j (add 32 b k) l))
     ((enable nat-to-uint)))

(prove-lemma disjoint-5-uint (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n 0 i)) m)
                   (leq (plus (nat-to-uint k) l) n))
              (disjoint a j (add 32 b k) l))
     ((enable nat-to-uint)))     

(prove-lemma disjoint-6-uint (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq l n))
              (disjoint (add 32 a i1) j b l))
     ((enable nat-to-uint)))

(prove-lemma disjoint-7-uint (rewrite)
     (implies (and (disjoint (add 32 a i) m b n)
                   (leq (plus j (index-n i1 i)) m)
                   (leq (plus (nat-to-uint k) l) n))
              (disjoint (add 32 a i1) j (add 32 b k) l))
     ((enable nat-to-uint)))

(prove-lemma read-rn-int-8_32 (rewrite)
     (equal (nat-to-int (read-rn 8 rn rfile) 32) 
            (nat-to-uint (read-rn 8 rn rfile)))
     ((enable read-rn nat-to-int nat-to-uint)))

(prove-lemma read-rn-int-16_32 (rewrite)
     (equal (nat-to-int (read-rn 16 rn rfile) 32) 
            (nat-to-uint (read-rn 16 rn rfile)))
     ((enable read-rn nat-to-int nat-to-uint)))

(prove-lemma read-rn-int-8_16 (rewrite)
     (equal (nat-to-int (read-rn 8 rn rfile) 16) 
            (nat-to-uint (read-rn 8 rn rfile)))
     ((enable read-rn nat-to-int nat-to-uint)))

(prove-lemma read-mem-int-8_32 (rewrite)
     (equal (nat-to-int (read-mem x mem 1) 32) 
            (nat-to-uint (read-mem x mem 1)))
     ((use (read-mem-nat-rangep (n 31) (k 1)))
      (enable nat-to-int nat-to-uint nat-rangep)))

(prove-lemma read-mem-int-16_32 (rewrite)
     (equal (nat-to-int (read-mem x mem 2) 32) 
            (nat-to-uint (read-mem x mem 2)))
     ((use (read-mem-nat-rangep (n 31) (k 2)))
      (enable nat-to-int nat-to-uint nat-rangep)))

(prove-lemma read-mem-int-8_16 (rewrite)
     (equal (nat-to-int (read-mem x mem 1) 16) 
            (nat-to-uint (read-mem x mem 1)))
     ((use (read-mem-nat-rangep (n 15) (k 1)))
      (enable nat-to-int nat-to-uint nat-rangep)))

(prove-lemma idifference-int-rangep (rewrite)
     (implies (and (numberp x) 
                   (numberp y)
                   (int-rangep x n)
                   (int-rangep y n))
              (int-rangep (idifference x y) n))
     ((enable int-rangep iplus idifference)))

(disable idifference)

; some more arithmetic.
(prove-lemma difference-cancel-1 (rewrite)
     (implies (leq i j)
              (and (equal (difference (plus i j) (times 2 i))
                          (difference j i))
                   (equal (difference (times 2 j) (plus i j))
                          (difference j i))))
     ((enable times)))

(prove-lemma difference-is-1 (rewrite)
     (equal (equal (difference x y) 1)
            (equal x (add1 y))))

(prove-lemma mean-difference-1 (rewrite)
     (implies (leq i j)
              (equal (difference (quotient (plus i j) 2) i)
                     (quotient (difference j i) 2)))
     ((use (quotient-difference (x (plus i j)) (y (times 2 i)) (z 2)))))

(prove-lemma mean-difference-2 (rewrite)
     (implies (leq i j)
              (not (lessp (quotient (difference j i) 2)
                          (difference (sub1 j) (quotient (plus i j) 2)))))
     ((use (quotient-diff (x (times 2 j)) (y (plus i j)) (z 2)))
      (disable quotient-times-lessp quotient remainder)))

(prove-lemma plus-0 (rewrite)
     (equal (plus 0 x) (fix x)))

(prove-lemma plus-times-sub1 (rewrite)
     (equal (plus x (times x (sub1 y)))
            (if (zerop y) (fix x) (times x y))))

(disable plus-times-sub1)

(prove-lemma plus2-times-sub1 (rewrite)
     (equal (plus x y (times x (sub1 z)))
            (if (zerop z)
                (plus x y)
              (plus y (times x z)))))

(prove-lemma plus3-times-sub1 (rewrite)
     (equal (plus x y z (times x (sub1 z1)))
            (if (zerop z1)
                (plus x y z)
              (plus y z (times x z1)))))

(prove-lemma lessp-cancel-4294967295 (rewrite)
     (equal (lessp (plus 4294967295 x) 4294967296)
            (zerop x))
     ((use (plus-lessp-cancel-add1 (y 4294967295)))))

(prove-lemma difference-cancel-4294967295 (rewrite)
     (equal (difference (plus 4294967295 x) 4294967296)
            (sub1 x))
     ((use (difference-plus-cancel-add1 (y 4294967295)))))

(prove-lemma lessp-cancel-4294967292 (rewrite)
     (equal (lessp (plus 4294967292 x) 4294967296)
            (lessp x 4))
     ((use (plus-lessp-cancel-1 (x 4294967292) (y x) (z 4)))
      (disable plus-lessp-cancel-1)))

(prove-lemma difference-cancel-4294967292 (rewrite)
     (equal (difference (plus 4294967292 x) 4294967296)
            (difference x 4)))

(prove-lemma difference-lessp-cancel-1 (rewrite)
     (equal (lessp (difference a c) (times c (sub1 b)))
            (if (leq c a) (lessp a (times c b)) (lessp 1 b)))
     ((use (difference-lessp-cancel (b (times c b))))
      (disable difference-lessp-cancel)))

(prove-lemma difference-lessp-cancel-2 (rewrite)
     (implies (leq c a)
              (equal (lessp (difference a c) (plus d (times c (sub1 b))))
                     (if (zerop b)
                         (lessp (difference a c) d)
                       (lessp a (plus d (times c b))))))
     ((use (difference-lessp-cancel (b (plus d (times c b)))))
      (disable difference-lessp-cancel)))

; two funny lemmas.  But seems more useful than add-uint!
(prove-lemma add-uintxx (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (lessp (plus (nat-to-uint x) (nat-to-uint y))
                          (exp 2 n)))
              (equal (nat-to-uint (add n x y))
                     (plus (nat-to-uint x) (nat-to-uint y)))))

(prove-lemma add-uintxxx (rewrite)
     (implies (and (nat-rangep x n)
                   (nat-rangep y n)
                   (not (lessp (plus (nat-to-uint x) (nat-to-uint y))
                               (exp 2 n))))
              (equal (nat-to-uint (add n x y))
                     (difference (plus (nat-to-uint x) (nat-to-uint y))
                                 (exp 2 n)))))

(disable add-uintxxx)

(prove-lemma ram-addrp-3 (rewrite)
     (implies (and (ram-addrp (add 32 addr i) mem k)
                   (leq (plus (index-n h i) j) k))
              (ram-addrp (add 32 addr h) mem j)))

(prove-lemma ram-addrp-4 (rewrite)
     (implies (and (ram-addrp addr mem k)
                   (leq (plus (nat-to-uint h) j) k))
              (ram-addrp (add 32 addr h) mem j))
     ((enable nat-to-uint)))

(prove-lemma and-z-commutativity (rewrite)
     (equal (and-z n x y) (and-z n y x))
     ((enable and-z)))

; finally, establish the database.
(make-lib "mc20-2" t)
