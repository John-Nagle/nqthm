#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRXFRM Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strxfrm function in the Berkeley string library.

/*
 * Transform src, storing the result in dst, such that
 * strcmp() on transformed strings returns what strcoll()
 * on the original untransformed strings would return.
 */
size_t
strxfrm(dst, src, n)
        register char *dst;
        register const char *src;
        register size_t n;
{
        register size_t r = 0;
        register int c;

        /*
         * Since locales are unimplemented, this is just a copy.
         */
        if (n != 0) {
                while ((c = *src++) != 0) {
                        r++;
                        if (--n == 0) {
                                while (*src++ != 0)
                                        r++;
                                break;
                        }
                        *dst++ = c;
                }
                *dst = 0;
        }
        return (r);
}

The MC68020 assembly code of the C function strxfrm on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x23a0 <strxfrm>:       linkw fp,#0
0x23a4 <strxfrm+4>:     movel d2,sp@-
0x23a6 <strxfrm+6>:     moveal fp@(8),a1
0x23aa <strxfrm+10>:    moveal fp@(12),a0
0x23ae <strxfrm+14>:    movel fp@(16),d0
0x23b2 <strxfrm+18>:    clrl d1
0x23b4 <strxfrm+20>:    tstl d0
0x23b6 <strxfrm+22>:    beq 0x23d4 <strxfrm+52>
0x23b8 <strxfrm+24>:    bra 0x23cc <strxfrm+44>
0x23ba <strxfrm+26>:    addql #1,d1
0x23bc <strxfrm+28>:    subl #1,d0
0x23be <strxfrm+30>:    bne 0x23ca <strxfrm+42>
0x23c0 <strxfrm+32>:    bra 0x23c4 <strxfrm+36>
0x23c2 <strxfrm+34>:    addql #1,d1
0x23c4 <strxfrm+36>:    tstb a0@+
0x23c6 <strxfrm+38>:    bne 0x23c2 <strxfrm+34>
0x23c8 <strxfrm+40>:    bra 0x23d2 <strxfrm+50>
0x23ca <strxfrm+42>:    moveb d2,a1@+
0x23cc <strxfrm+44>:    moveb a0@+,d2
0x23ce <strxfrm+46>:    extbl d2
0x23d0 <strxfrm+48>:    bne 0x23ba <strxfrm+26>
0x23d2 <strxfrm+50>:    clrb a1@
0x23d4 <strxfrm+52>:    movel d1,d0
0x23d6 <strxfrm+54>:    movel fp@(-4),d2
0x23da <strxfrm+58>:    unlk fp
0x23dc <strxfrm+60>:    rts

The machine code of the above program is:

<strxfrm>:     0x4e56  0x0000  0x2f02  0x226e  0x0008  0x206e  0x000c  0x202e
<strxfrm+16>:  0x0010  0x4281  0x4a80  0x671c  0x6012  0x5281  0x5380  0x660a
<strxfrm+32>:  0x6002  0x5281  0x4a18  0x66fa  0x6008  0x12c2  0x1418  0x49c2
<strxfrm+48>:  0x66e8  0x4211  0x2001  0x242e  0xfffc  0x4e5e  0x4e75

'(78      86      0       0       47      2       34      110
  0       8       32      110     0       12      32      46
  0       16      66      129     74      128     103     28
  96      18      82      129     83      128     102     10
  96      2       82      129     74      24      102     250
  96      8       18      194     20      24      73      194
  102     232     66      17      32      1       36      46
  255     252     78      94      78      117)
|#

; in the logic, the above program is defined by (strxfrm-code).
(defn strxfrm-code ()
  '(78      86      0       0       47      2       34      110
    0       8       32      110     0       12      32      46
    0       16      66      129     74      128     103     28
    96      18      82      129     83      128     102     10
    96      2       82      129     74      24      102     250
    96      8       18      194     20      24      73      194
    102     232     66      17      32      1       36      46
    255     252     78      94      78      117))

; the Berkeley strxfrm returns the following value.  It seems a bug!
(defn strxfrm-n (n2 lst2 n)
  (if (zerop n)
      0
    (strlen 0 n2 lst2)))
  
; the computation time of the program.
(defn strxfrm-t2 (j n2 lst2)
  (if (lessp j n2)
      (if (equal (get-nth j lst2) 0)
	  8
	(splus 3 (strxfrm-t2 (add1 j) n2 lst2)))
    0)
  ((lessp (difference n2 j))))

(defn strxfrm-t1 (i n2 lst2)
  (splus 7 (strxfrm-t2 (add1 i) n2 lst2)))

(defn strxfrm-t0 (i n2 lst2 n)
  (if (equal (get-nth i lst2) 0)
      8
    (if (equal (sub1 n) 0)
	(strxfrm-t1 i n2 lst2)
      (splus 7 (strxfrm-t0 (add1 i) n2 lst2 (sub1 n))))))

(defn strxfrm-t (n2 lst2 n)
  (if (zerop n)
      12
    (splus 9 (strxfrm-t0 0 n2 lst2 n))))

; two induction hints.
(defn strxfrm-induct2 (s j* j n2 lst2)
  (if (lessp j n2)
      (if (equal (get-nth j lst2) 0)
	  t
	(strxfrm-induct2 (stepn s 3) (add 32 j* 1) (add1 j) n2 lst2))
    t)
  ((lessp (difference n2 j))))

(defn strxfrm-induct1 (s i* i lst1 lst2 n)
  (if (equal (get-nth i lst2) 0)
      t
    (if (equal (sub1 n) 0)
	t
      (strxfrm-induct1 (stepn s 7) (add 32 i* 1) (add1 i) 
		       (put-nth (get-nth i lst2) i lst1) lst2 (sub1 n)))))

; the preconditions of the initial state.
(defn strxfrm-statep (s str1 n1 lst1 str2 n2 lst2 n)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 62)
       (mcode-addrp (mc-pc s) (mc-mem s) (strxfrm-code))
       (ram-addrp (sub 32 8 (read-sp s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 8 (read-sp s)) 24 str1 n1)
       (disjoint (sub 32 8 (read-sp s)) 24 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (lessp (slen 0 n2 lst2) n2)
       (leq n2 n1)
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)
       (uint-rangep n2 32)))

; an intermediate state s0.
(defn strxfrm-s0p (s i* i str1 n1 lst1 str2 n2 lst2 n)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 44 (mc-pc s)) (mc-mem s) 62)
       (mcode-addrp (sub 32 44 (mc-pc s)) (mc-mem s) (strxfrm-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str1 n1)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 i*))
       (equal n (nat-to-uint (read-dn 32 0 s)))
       (equal i* (read-dn 32 1 s))
       (equal i (nat-to-uint i*))
       (not (equal n 0))
       (lessp (slen i n2 lst2) n2)
       (leq n2 n1)
       (lessp i n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)
       (uint-rangep n2 32)))

; an intermediate state s1.
(defn strxfrm-s1p (s i* i str1 n1 lst1 j* j str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 36 (mc-pc s)) (mc-mem s) 62)
       (mcode-addrp (sub 32 36 (mc-pc s)) (mc-mem s) (strxfrm-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str1 n1)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str2 n2)
       (disjoint str1 n1 str2 n2)
       (equal* (read-an 32 1 s) (add 32 str1 i*))
       (equal* (read-an 32 0 s) (add 32 str2 j*))
       (equal j* (read-dn 32 1 s))
       (equal j (nat-to-uint j*))
       (lessp i n1)
       (lessp (slen j n2 lst2) n2)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)
       (uint-rangep n2 32)))

; from the initial state s to exit: s --> sn, when n = 0.
(prove-lemma strxfrm-s-sn (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n))
	      (and (equal (mc-status (stepn s 12)) 'running)
		   (equal (mc-pc (stepn s 12)) (rts-addr s))
		   (mem-lst 1 str1 (mc-mem (stepn s 12)) n1 lst1)
		   (equal (uread-dn 32 0 (stepn s 12)) 0)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 12)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 12))) 
			  (read-an 32 6 s)))))

(prove-lemma strxfrm-s-sn-rfile (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n)
		   (leq oplen 32)
		   (d2-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 12)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strxfrm-s-sn-mem (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n)
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 12)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state to s0: s --> s0, when n =\= 0.
(prove-lemma strxfrm-s-s0 ()
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n)))
              (strxfrm-s0p (stepn s 9) 0 0 str1 n1 lst1 str2 n2 lst2 n)))

(prove-lemma strxfrm-s-s0-else (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n)))
              (and (equal (linked-rts-addr (stepn s 9)) (rts-addr s))
                   (equal (linked-a6 (stepn s 9)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 9)))
                          (sub 32 4 (read-sp s)))
		   (equal (rn-saved (stepn s 9)) (read-dn 32 2 s)))))

(prove-lemma strxfrm-s-s0-rfile (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strxfrm-s-s0-mem (rewrite)
     (implies (and (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n))
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 9)) k)
		     (read-mem x (mc-mem s) k))))

; from s1 to exit: s1 --> sn.  By induction.
; base case:  s1 --> sn, when lst2[i] == 0.
(prove-lemma strxfrm-s1-sn-base (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (equal (get-nth j lst2) 0))
	      (and (equal (mc-status (stepn s 8)) 'running)
		   (equal (mc-pc (stepn s 8)) (linked-rts-addr s))
		   (mem-lst 1 str1 (mc-mem (stepn s 8)) n1 (put-nth 0 i lst1))
		   (equal (uread-dn 32 0 (stepn s 8)) j)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 8)))
			  (add 32 (read-an 32 6 s) 8)))))

(prove-lemma strxfrm-s1-sn-rfile-base (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (equal (get-nth j lst2) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen)))))

(prove-lemma strxfrm-s1-sn-mem-base (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (equal (get-nth j lst2) 0)
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

; induction case:  s1 --> s1.
(prove-lemma strxfrm-s1-s1 (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (not (equal (get-nth j lst2) 0)))
	      (and (strxfrm-s1p (stepn s 3) i* i str1 n1 lst1 
				(add 32 j* 1) (add1 j) str2 n2 lst2)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 3)) (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 3)) k)
			  (read-mem x (mc-mem s) k))
		   (equal (rn-saved (stepn s 3)) (rn-saved s)))))

(prove-lemma strxfrm-s1-s1-rfile (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (not (equal (get-nth j lst2) 0))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

; put together: s1 --> sn.
(prove-lemma strxfrm-s1p-info (rewrite)
     (implies (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
	      (equal (lessp j n2) t)))

(prove-lemma strxfrm-s1-sn (rewrite)
     (let ((sn (stepn s (strxfrm-t2 j n2 lst2))))
       (implies (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (mem-lst 1 str1 (mc-mem sn) n1 (put-nth 0 i lst1))
		     (equal (uread-dn 32 0 sn) (strlen j n2 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strxfrm-induct2 s j* j n2 lst2))
      (disable strxfrm-s1p uread-dn)))

(prove-lemma strxfrm-s1-sn-rfile (rewrite)
     (implies 
      (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
	   (leq oplen 32)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strxfrm-t2 j n2 lst2))))
	     (if (d3-7a2-5p rn)
		 (read-rn oplen rn (mc-rfile s))
	       (head (rn-saved s) oplen))))
      ((induct (strxfrm-induct2 s j* j n2 lst2))
       (disable strxfrm-s1p)))

(prove-lemma strxfrm-s1-sn-mem (rewrite)
     (implies (and (strxfrm-s1p s i* i str1 n1 lst1 j* j str2 n2 lst2)
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s (strxfrm-t2 j n2 lst2))) k)
		     (read-mem x (mc-mem s) k)))
     ((induct (strxfrm-induct2 s j* j n2 lst2))
      (disable strxfrm-s1p)))

(disable strxfrm-s1p-info)

; from s0 to exit: s0 --> sn.  By induction.
; base case 1. s0 --> sn, when lst2[i] = 0.  
(prove-lemma strxfrm-s0-sn-base1 (rewrite)
     (let ((sn (stepn s 8)))
       (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		     (equal (get-nth i lst2) 0))
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (mem-lst 1 str1 (mc-mem sn) n1 (put-nth 0 i lst1))
		     (equal (uread-dn 32 0 sn) i)
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))))))
		   
(prove-lemma strxfrm-s0-sn-rfile-base1 (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen)))))

(prove-lemma strxfrm-s0-sn-mem-base1 (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (disjoint x k str1 n1))
	   (equal (read-mem x (mc-mem (stepn s 8)) k)
		  (read-mem x (mc-mem s) k))))

; base case 2:  s0 --> s1 --> sn, when lst2[i] =\= 0 and n-1 == 0.
; s0 --> s1.
(prove-lemma strxfrm-s0-s1 ()
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0))
	      (strxfrm-s1p (stepn s 7) i* i str1 n1 lst1 
			   (add 32 i* 1) (add1 i) str2 n2 lst2)))

(prove-lemma strxfrm-s0-s1-else (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0))
	      (and (equal (linked-rts-addr (stepn s 7))
			  (linked-rts-addr s))
                   (equal (linked-a6 (stepn s 7)) (linked-a6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (rn-saved (stepn s 7)) (rn-saved s)))))

(prove-lemma strxfrm-s0-s1-rfile (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strxfrm-s0-s1-mem (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0)
		   (disjoint x k str1 n1))				   
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; s0 --> sn.
(prove-lemma strxfrm-s0-sn-base2 (rewrite)
     (let ((sn (stepn s (strxfrm-t1 i n2 lst2))))
       (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		     (not (equal (get-nth i lst2) 0))
		     (equal (sub1 n) 0))
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (mem-lst 1 str1 (mc-mem sn) n1 (put-nth 0 i lst1))
		     (equal (uread-dn 32 0 sn) (strlen (add1 i) n2 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((use (strxfrm-s0-s1))
      (disable strxfrm-s0p strxfrm-s1p uread-dn)))
		   
(prove-lemma strxfrm-s0-sn-rfile-base2 (rewrite)
     (implies 
      (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
	   (not (equal (get-nth i lst2) 0))
	   (equal (sub1 n) 0)
	   (leq oplen 32)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strxfrm-t1 i n2 lst2))))
	     (if (d3-7a2-5p rn)
		 (read-rn oplen rn (mc-rfile s))
	       (head (rn-saved s) oplen))))
     ((use (strxfrm-s0-s1))
      (disable strxfrm-s0p strxfrm-s1p)))     

(prove-lemma strxfrm-s0-sn-mem-base2 (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0)
		   (disjoint x k str1 n1))
	   (equal (read-mem x (mc-mem (stepn s (strxfrm-t1 i n2 lst2))) k)
		  (read-mem x (mc-mem s) k)))
     ((use (strxfrm-s0-s1))
      (disable strxfrm-s0p strxfrm-s1p)))

; induction case: s0 --> s0, when lst2[i] =\= 0 and n-1 =\= 0.
(prove-lemma strxfrm-s0-s0 (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0)))
	      (and (strxfrm-s0p (stepn s 7) (add 32 i* 1) (add1 i) str1 
				n1 (put-nth (get-nth i lst2) i lst1)
				str2 n2 lst2 (sub1 n))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 7)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 7)) (linked-rts-addr s))
		   (equal (rn-saved (stepn s 7)) (rn-saved s)))))

(prove-lemma strxfrm-s0-s0-rfile (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strxfrm-s0-s0-mem (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0))
		   (disjoint x k str1 n1))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; put together: s0 --> sn.
(prove-lemma strxfrm-s0p-info (rewrite)
     (implies (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
	      (equal (lessp i n2) t)))

(prove-lemma strxfrm-s0-sn (rewrite)
     (let ((sn (stepn s (strxfrm-t0 i n2 lst2 n))))
       (implies (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (mem-lst 1 str1 (mc-mem sn) n1 (strxfrm1 i lst1 lst2 n))
		     (equal (uread-dn 32 0 sn) (strlen i n2 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strxfrm-induct1 s i* i lst1 lst2 n))
      (disable strxfrm-s0p strxfrm-t1 uread-dn)))
		   
(prove-lemma strxfrm-s0-sn-rfile (rewrite)
     (implies 
      (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
	   (leq oplen 32)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strxfrm-t0 i n2 lst2 n))))
	     (if (d3-7a2-5p rn)
		 (read-rn oplen rn (mc-rfile s))
	       (head (rn-saved s) oplen))))
     ((induct (strxfrm-induct1 s i* i lst1 lst2 n))
      (disable strxfrm-s0p strxfrm-t1)))

(prove-lemma strxfrm-s0-sn-mem (rewrite)
     (implies (and (strxfrm-s0p s i* i str1 n1 lst1 str2 n2 lst2 n)
		   (disjoint x k str1 n1))
	   (equal (read-mem x (mc-mem (stepn s (strxfrm-t0 i n2 lst2 n))) k)
		  (read-mem x (mc-mem s) k)))
     ((induct (strxfrm-induct1 s i* i lst1 lst2 n))
      (disable strxfrm-s0p strxfrm-t1)))

(disable strxfrm-s0p-info)

; the correctness of strxfrm.
(prove-lemma strxfrm-correctness (rewrite)
     (let ((sn (stepn s (strxfrm-t n2 lst2 n))))
       (implies (strxfrm-statep s str1 n1 lst1 str2 n2 lst2 n)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 7 s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (and (disjoint x k str1 n1)
				   (disjoint x k (sub 32 8 (read-sp s)) 24))
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (uread-dn 32 0 sn) (strxfrm-n n2 lst2 n))
		     (mem-lst 1 str1 (mc-mem sn) n1 (strxfrm lst1 lst2 n)))))
     ((use (strxfrm-s-s0))
      (disable strxfrm-statep strxfrm-s0p linked-rts-addr linked-a6 
	       uread-dn strxfrm-t0)))

(disable strxfrm-t)

; some properties of strxfrm.
; see file cstring.events.
