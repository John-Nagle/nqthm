#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "strlen" t)

;          Proof of the Correctness of the STRNCMP Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strncmp function in the Berkeley string library.

/* compare at most char s1[] to char s2[] */
int
strncmp(s1, s2, n)
	register const char *s1, *s2;
	register size_t n;
{

	if (n == 0)
		return (0);
	do {
		if (*s1 != *s2++)
			return (*(unsigned char *)s1 - *(unsigned char *)--s2);
		if (*s1++ == 0)
			break;
	} while (--n != 0);
	return (0);
}

The MC68020 assembly code of the C function strncmp on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2608 <strncmp>:       linkw fp,#0
0x260c <strncmp+4>:     moveml d2-d3,sp@-
0x2610 <strncmp+8>:     moveal fp@(8),a0
0x2614 <strncmp+12>:    moveal fp@(12),a1
0x2618 <strncmp+16>:    movel fp@(16),d0
0x261c <strncmp+20>:    beq 0x2642 <strncmp+58>
0x261e <strncmp+22>:    andil #255,d1
0x2624 <strncmp+28>:    andil #255,d2
0x262a <strncmp+34>:    moveb a0@,d3
0x262c <strncmp+36>:    cmpb a1@+,d3
0x262e <strncmp+38>:    beq 0x263a <strncmp+50>
0x2630 <strncmp+40>:    moveb a0@,d1
0x2632 <strncmp+42>:    moveb a1@-,d2
0x2634 <strncmp+44>:    movel d1,d0
0x2636 <strncmp+46>:    subl d2,d0
0x2638 <strncmp+48>:    bra 0x2644 <strncmp+60>
0x263a <strncmp+50>:    tstb a0@+
0x263c <strncmp+52>:    beq 0x2642 <strncmp+58>
0x263e <strncmp+54>:    subl #1,d0
0x2640 <strncmp+56>:    bne 0x262a <strncmp+34>
0x2642 <strncmp+58>:    clrl d0
0x2644 <strncmp+60>:    moveml fp@(-8),d2-d3
0x264a <strncmp+66>:    unlk fp
0x264c <strncmp+68>:    rts

The machine code of the above program is:

<strncmp>:     0x4e56  0x0000  0x48e7  0x3000  0x206e  0x0008  0x226e  0x000c
<strncmp+16>:  0x202e  0x0010  0x6724  0x0281  0x0000  0x00ff  0x0282  0x0000
<strncmp+32>:  0x00ff  0x1610  0xb619  0x670a  0x1210  0x1421  0x2001  0x9082
<strncmp+48>:  0x600a  0x4a18  0x6704  0x5380  0x66e8  0x4280  0x4cee  0x000c
<strncmp+64>:  0xfff8  0x4e5e  0x4e75

'(78      86      0       0       72      231     48      0
  32      110     0       8       34      110     0       12
  32      46      0       16      103     36      2       129
  0       0       0       255     2       130     0       0
  0       255     22      16      182     25      103     10
  18      16      20      33      32      1       144     130
  96      10      74      24      103     4       83      128
  102     232     66      128     76      238     0       12
  255     248     78      94      78      117)
|#

; in the logic, the above program is defined by (strncmp-code).
(defn strncmp-code ()
  '(78      86      0       0       72      231     48      0
    32      110     0       8       34      110     0       12
    32      46      0       16      103     36      2       129
    0       0       0       255     2       130     0       0
    0       255     22      16      182     25      103     10
    18      16      20      33      32      1       144     130
    96      10      74      24      103     4       83      128
    102     232     66      128     76      238     0       12
    255     248     78      94      78      117))

(constrain strncmp-load (rewrite)
   (equal (strncmp-loadp s)
	  (and (evenp (strncmp-addr))
	       (numberp (strncmp-addr))
	       (nat-rangep (strncmp-addr) 32)
	       (rom-addrp (strncmp-addr) (mc-mem s) 70)
	       (mcode-addrp (strncmp-addr) (mc-mem s) (strncmp-code))))
   ((strncmp-loadp (lambda (s) f))
    (strncmp-addr (lambda () 1))))

(prove-lemma stepn-strncmp-loadp (rewrite)
     (equal (strncmp-loadp (stepn s n))
	    (strncmp-loadp s)))

; the computation time of the program.
(defn strncmp1-t (i n lst1 lst2)
  (if (equal (get-nth i lst1) (get-nth i lst2))
      (if (equal (get-nth i lst1) 0)
	  9
	(if (equal (sub1 n) 0)
	    11
	  (splus 7 (strncmp1-t (add1 i) (sub1 n) lst1 lst2))))
    11))

(defn strncmp-t (n lst1 lst2)
  (if (zerop n)
      10
    (splus 8 (strncmp1-t 0 n lst1 lst2))))

; an induction hint.
(defn strncmp-induct (s i* i n lst1 lst2)
  (if (equal (get-nth i lst1) (get-nth i lst2))
      (if (equal (get-nth i lst1) 0)
	  t
	(if (equal (sub1 n) 0)
	    t
	  (strncmp-induct (stepn s 7) (add 32 i* 1) (add1 i) (sub1 n)
			  lst1 lst2)))
    t))

; the preconditions of the initial state.
(defn strncmp-statep (s str1 n1 lst1 str2 n2 lst2 n)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 70)
       (mcode-addrp (mc-pc s) (mc-mem s) (strncmp-code))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 28)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (lessp (slen 0 n lst1) n1)
       (lessp (slen 0 n lst2) n2)
       (disjoint (sub 32 12 (read-sp s)) 28 str1 n1)
       (disjoint (sub 32 12 (read-sp s)) 28 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (numberp n1)
       (numberp n2)))

; an intermediate state.
(defn strncmp-s0p (s i* i str1 n1 lst1 str2 n2 lst2 n n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 34 (mc-pc s)) (mc-mem s) 70)
       (mcode-addrp (sub 32 34 (mc-pc s)) (mc-mem s) (strncmp-code))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 28)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (lessp (slen i n_ lst1) n1)
       (lessp (slen i n_ lst2) n2)
       (disjoint (sub 32 8 (read-an 32 6 s)) 28 str1 n1)
       (disjoint (sub 32 8 (read-an 32 6 s)) 28 str2 n2)
       (equal* (read-an 32 0 s) (add 32 str1 i*))
       (equal* (read-an 32 1 s) (add 32 str2 i*))
       (nat-rangep (read-rn 32 1 (mc-rfile s)) 8)
       (nat-rangep (read-rn 32 2 (mc-rfile s)) 8)
       (equal n (nat-to-uint (read-dn 32 0 s)))
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp n_)
       (leq (plus i n) n_)
       (not (equal n 0))
       (uint-rangep n_ 32)))

; from the initial state s to exit: s --> sn, when n = 0.
(prove-lemma strncmp-s-sn (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n))
	      (and (equal (mc-status (stepn s 10)) 'running)
		   (equal (mc-pc (stepn s 10)) (rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 10)) 0)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 10)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 10))) 
			  (read-an 32 6 s)))))

(prove-lemma strncmp-s-sn-rfile (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n)
		   (leq oplen 32)
		   (d2-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 10)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncmp-s-sn-mem (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (zerop n)
		   (disjoint x k (sub 32 12 (read-sp s)) 28))
	      (equal (read-mem x (mc-mem (stepn s 10)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state s to s0: s --> s0.
(prove-lemma strncmp-s-s0 ()
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n)))
              (strncmp-s0p (stepn s 8) 0 0 str1 n1 lst1 str2 n2 lst2 n n)))

(prove-lemma strncmp-s-s0-else (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n)))
              (and (equal (linked-rts-addr (stepn s 8)) (rts-addr s))
                   (equal (linked-a6 (stepn s 8)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
                          (sub 32 4 (read-sp s)))
		   (equal (movem-saved (stepn s 8) 4 8 2)
                          (readm-rn 32 '(2 3) (mc-rfile s))))))

(prove-lemma strncmp-s-s0-rfile (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n))
		   (d4-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncmp-s-s0-mem (rewrite)
     (implies (and (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		   (not (zerop n))
		   (disjoint x k (sub 32 12 (read-sp s)) 28))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to exit: s0 --> sn.
; base case 1:  s0 --> sn, when lst1[i] =\= lst2[i].
(prove-lemma strncmp-s0-sn-base1 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (not (equal (get-nth i lst1) (get-nth i lst2))))
	      (and (equal (mc-status (stepn s 11)) 'running)
		   (equal (mc-pc (stepn s 11)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 11)) 
			  (idifference (get-nth i lst1) (get-nth i lst2)))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 11)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 11)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 11)) k)
			  (read-mem x (mc-mem s) k)))))
		   
(prove-lemma strncmp-s0-sn-rfile-base1 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (not (equal (get-nth i lst1) (get-nth i lst2)))
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 11)))
		     (if (d4-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

; base case 2: s0 --> sn, when lst[i] = lst2[i] and lst[i] = 0.
(prove-lemma strncmp-s0-sn-base2 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (equal (get-nth i lst1) 0))
	      (and (equal (mc-status (stepn s 9)) 'running)
		   (equal (mc-pc (stepn s 9)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 9)) 0)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 9)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 9)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 9)) k)
			  (read-mem x (mc-mem s) k)))))			  

(prove-lemma strncmp-s0-sn-rfile-base2 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (equal (get-nth i lst1) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (if (d4-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

; base case 3: s0 --> sn, when lst[i] = lst2[i], lst[i] =\= 0, and n-1 = 0.
(prove-lemma strncmp-s0-sn-base3 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (not (equal (get-nth i lst1) 0))
		   (equal (sub1 n) 0))
	      (and (equal (mc-status (stepn s 11)) 'running)
		   (equal (mc-pc (stepn s 11)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 11)) 0)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 11)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 11)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 11)) k)
			  (read-mem x (mc-mem s) k)))))			  

(prove-lemma strncmp-s0-sn-rfile-base3 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (not (equal (get-nth i lst1) 0))
		   (equal (sub1 n) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 11)))
		     (if (d4-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

; induction case: s0 --> s0, lst[i] = lst2[i], lst[i] =\= 0 and n-1 =\= 0.
(prove-lemma strncmp-s0-s0 (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (not (equal (get-nth i lst1) 0))
		   (not (equal (sub1 n) 0)))
	      (and (strncmp-s0p (stepn s 7) (add 32 i* 1) (add1 i)
				str1 n1 lst1 str2 n2 lst2 (sub1 n) n_)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 7)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 7)) (linked-rts-addr s))
		   (equal (movem-saved (stepn s 7) 4 8 2)
			  (movem-saved s 4 8 2))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k)))))			  

(prove-lemma strncmp-s0-s0-rfile (rewrite)
     (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		   (equal (get-nth i lst1) (get-nth i lst2))
		   (not (equal (get-nth i lst1) 0))
		   (not (equal (sub1 n) 0))
		   (d4-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

; put together. s0 --> exit.
(prove-lemma strncmp-s0-sn (rewrite)
     (let ((sn (stepn s (strncmp1-t i n lst1 lst2))))
       (implies (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (iread-dn 32 0 sn) (strncmp1 i n lst1 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strncmp-induct s i* i n lst1 lst2))
      (disable strncmp-s0p iread-dn)))

(prove-lemma strncmp-s0-sn-rfile (rewrite)
     (let ((sn (stepn s (strncmp1-t i n lst1 lst2))))	     
       (implies (and (strncmp-s0p s i* i str1 n1 lst1 str2 n2 lst2 n n_)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		       (if (d4-7a2-5p rn)
			   (read-rn oplen rn (mc-rfile s))
			 (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((induct (strncmp-induct s i* i n lst1 lst2))
      (disable strncmp-s0p)))

; the correctness of strncmp.
(prove-lemma strncmp-correctness (rewrite)
     (let ((sn (stepn s (strncmp-t n lst1 lst2))))
       (implies (strncmp-statep s str1 n1 lst1 str2 n2 lst2 n)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 7 s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 12 (read-sp s)) 28)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (iread-dn 32 0 sn) (strncmp n lst1 lst2)))))
     ((use (strncmp-s-s0))
      (disable strncmp-statep strncmp-s0p linked-rts-addr linked-a6 iread-dn)))

(disable strncmp-t)

; some properties of strncmp.
; see file cstring.events.

(make-lib "strncmp" t)
