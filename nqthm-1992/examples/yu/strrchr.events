#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRRCHR Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strrchr function in the Berkeley string library.

char *
strrchr(p, ch)
	register const char *p;
        register char ch;
{
	register const char *save;

	for (save = NULL;; ++p) {
		if (*p == ch)
			save = p;
		if (!*p)
			return((char *)save);
	}
	/* NOTREACHED */
}

The MC68020 assembly code of the C function strrchr on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x26c8 <strrchr>:       linkw fp,#0
0x26cc <strrchr+4>:     moveal fp@(8),a0
0x26d0 <strrchr+8>:     moveb fp@(15),d1
0x26d4 <strrchr+12>:    clrl d0
0x26d6 <strrchr+14>:    cmpb a0@,d1
0x26d8 <strrchr+16>:    bne 0x26dc <strrchr+20>
0x26da <strrchr+18>:    movel a0,d0
0x26dc <strrchr+20>:    tstb a0@
0x26de <strrchr+22>:    beq 0x26e4 <strrchr+28>
0x26e0 <strrchr+24>:    addqw #1,a0
0x26e2 <strrchr+26>:    bra 0x26d6 <strrchr+14>
0x26e4 <strrchr+28>:    unlk fp
0x26e6 <strrchr+30>:    rts

The machine code of the above program is:

<strrchr>:     0x4e56  0x0000  0x206e  0x0008  0x122e  0x000f  0x4280  0xb210
<strrchr+16>:  0x6602  0x2008  0x4a10  0x6704  0x5248  0x60f2  0x4e5e  0x4e75

'(78      86      0       0       32      110     0       8
  18      46      0       15      66      128     178     16
  102     2       32      8       74      16      103     4
  82      72      96      242     78      94      78      117)
|#

; in the logic, the above program is defined by (strrchr-code).
(defn strrchr-code ()
  '(78      86      0       0       32      110     0       8
    18      46      0       15      66      128     178     16
    102     2       32      8       74      16      103     4
    82      72      96      242     78      94      78      117))

; the computation time of the program.
(defn strrchr-t1 (i n lst ch)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
	  (if (equal (get-nth i lst) 0)
	      7
	    (splus 7 (strrchr-t1 (add1 i) n lst ch)))
	(if (equal (get-nth i lst) 0)
	    6
	  (splus 6 (strrchr-t1 (add1 i) n lst ch))))
    0)
  ((lessp (difference n i))))

(defn strrchr-t (n lst ch)
  (splus 4 (strrchr-t1 0 n lst ch)))

; an induction hint.
(defn strrchr-induct (s i* i n lst ch j* j)
  (if (lessp i n)
      (if (equal (get-nth i lst) ch)
	  (if (equal (get-nth i lst) 0)
	      t
	    (strrchr-induct (stepn s 7) (add 32 i* 1) (add1 i) n lst ch
			    i* i))
	(if (equal (get-nth i lst) 0)
	    t
	  (strrchr-induct (stepn s 6) (add 32 i* 1) (add1 i) n lst ch j* j)))
    t)
  ((lessp (difference n i))))

; the preconditions of the initial state.
(defn strrchr-statep (s str n lst ch)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 32)
       (mcode-addrp (mc-pc s) (mc-mem s) (strrchr-code))
       (ram-addrp (sub 32 4 (read-sp s)) (mc-mem s) 16)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint (sub 32 4 (read-sp s)) 16 str n)
       (equal str (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal ch (uread-mem (add 32 (read-sp s) 11) (mc-mem s) 1))
       (stringp 0 n lst)
       (numberp n)
       (uint-rangep n 32)
       (not (equal (nat-to-uint str) 0))
       (uint-rangep (plus (nat-to-uint str) n) 32)))       
       
; an intermediate state.
(defn index-j (str j* j)
  (if j (add 32 str j*) 0))

(defn strrchr-s0p (s i* i str n lst ch j* j)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 14 (mc-pc s)) (mc-mem s) 32)
       (mcode-addrp (sub 32 14 (mc-pc s)) (mc-mem s) (strrchr-code))
       (ram-addrp (read-an 32 6 s) (mc-mem s) 16)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint (read-an 32 6 s) 16 str n)
       (equal* (read-an 32 0 s) (add 32 str i*))
       (equal ch (nat-to-uint (read-dn 8 1 s)))
       (equal* (read-dn 32 0 s) (index-j str j* j))
       (stringp i n lst)
       (lessp i n)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp n)
       (uint-rangep n 32)))

; from the initial state s to s0: s --> s0;
(prove-lemma strrchr-s-s0 ()
     (implies (strrchr-statep s str n lst ch)
              (strrchr-s0p (stepn s 4) 0 0 str n lst ch f f)))

(prove-lemma strrchr-s-s0-else (rewrite)
     (implies (strrchr-statep s str n lst ch)
              (and (equal (linked-rts-addr (stepn s 4)) (rts-addr s))
                   (equal (linked-a6 (stepn s 4)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 4)))
                          (sub 32 4 (read-sp s))))))

(prove-lemma strrchr-s-s0-rfile (rewrite)
     (implies (and (strrchr-statep s str n lst ch)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strrchr-s-s0-mem (rewrite)
     (implies (and (strrchr-statep s str n lst ch)
		   (disjoint x k (sub 32 4 (read-sp s)) 16))
	      (equal (read-mem x (mc-mem (stepn s 4)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to exit: s0 --> sn.
; base case 1. s0 --> sn, when lst[i] = ch and lst[i] = 0.
(prove-lemma strrchr-s0-sn-base1 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (not (equal (get-nth i lst) ch))
		   (equal (get-nth i lst) 0))
	      (and (equal (mc-status (stepn s 6)) 'running)
		   (equal (mc-pc (stepn s 6)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 6))
			  (index-j str j* j))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 6)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 6)) k)
			  (read-mem x (mc-mem s) k))))
     ((disable index-j)))
		   
(prove-lemma strrchr-s0-sn-rfile-base1 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (not (equal (get-nth i lst) ch))
		   (equal (get-nth i lst) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s))))
     ((disable index-j)))

; base case 2: s0 --> sn, when lst[i] =\= ch and lst[i] = 0.
(prove-lemma strrchr-s0-sn-base2 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (equal (get-nth i lst) ch)
		   (equal (get-nth i lst) 0))
	      (and (equal (mc-status (stepn s 7)) 'running)
		   (equal (mc-pc (stepn s 7)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) (add 32 str i*))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k))))
     ((disable index-j)))

(prove-lemma strrchr-s0-sn-rfile-base2 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (equal (get-nth i lst) ch)
		   (equal (get-nth i lst) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s))))
     ((disable index-j)))

; induction case 1: s0 --> s0, when lst[i] = ch and lst[i] =\= 0.
(prove-lemma index-j-la (rewrite)
     (implies j
	      (equal (index-j str j* j) (add 32 str j*))))

(prove-lemma strrchr-s0-s0-1 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (equal (get-nth i lst) ch)
		   (not (equal (get-nth i lst) 0)))
	      (and (strrchr-s0p (stepn s 7) (add 32 i* 1) (add1 i)
				str n lst ch i* i)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 7)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 7)) (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k))))
     ((disable index-j)))

(prove-lemma strrchr-s0-s0-rfile-1 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
		   (equal (get-nth i lst) ch)
		   (not (equal (get-nth i lst) 0))
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s))))
     ((disable index-j)))

; induction case 2: s0 --> s0, when lst[i] =\= ch and lst[i] =\= 0.
(prove-lemma strrchr-s0-s0-2 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
                   (not (equal (get-nth i lst) ch))
                   (not (equal (get-nth i lst) 0)))
              (and (strrchr-s0p (stepn s 6) (add 32 i* 1) (add1 i)
                                str n lst ch j* j)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 6)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 6)) (linked-rts-addr s))
                   (equal (read-mem x (mc-mem (stepn s 6)) k)
                          (read-mem x (mc-mem s) k))))
     ((disable index-j)))

(prove-lemma strrchr-s0-s0-rfile-2 (rewrite)
     (implies (and (strrchr-s0p s i* i str n lst ch j* j)
                   (not (equal (get-nth i lst) ch))
                   (not (equal (get-nth i lst) 0))
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s))))
     ((disable index-j)))

; put together. s0 --> exit.
(prove-lemma strrchr-s0p-info (rewrite)
     (implies (strrchr-s0p s i* i str n lst ch j* j)
	      (and (equal (lessp i n) t)
		   (numberp i))))

(prove-lemma strrchr-s0p-la (rewrite)
     (not (strrchr-s0p s i* f str n lst ch j* j)))

(prove-lemma strrchr-s0-sn (rewrite)
     (let ((sn (stepn s (strrchr-t1 i n lst ch))))
       (implies (strrchr-s0p s i* i str n lst ch j* j)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn)
			    (if (strrchr i n lst ch j)
				(add 32 str (strrchr* i* i n lst ch j*))
			      0))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strrchr-induct s i* i n lst ch j* j))
      (disable strrchr-s0p read-dn)))

(disable strrchr-s0p-info)

(prove-lemma strrchr-s0-sn-rfile (rewrite)
     (implies 
      (and (strrchr-s0p s i* i str n lst ch j* j)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strrchr-t1 i n lst ch))))
	     (read-rn oplen rn (mc-rfile s))))
     ((induct (strrchr-induct s i* i n lst ch j* j))
      (disable strrchr-s0p)))

; the correctness of strrchr.
(prove-lemma strrchr-correctness (rewrite)
     (let ((sn (stepn s (strrchr-t n lst ch))))
       (implies (strrchr-statep s str n lst ch)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (d2-7a2-5p rn)
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 4 (read-sp s)) 16)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn)
			    (if (strrchr 0 n lst ch f)
				(add 32 str (strrchr* 0 0 n lst ch f))
			      0)))))
     ((use (strrchr-s-s0))
      (disable strrchr-statep strrchr-s0p read-dn linked-rts-addr linked-a6)))

(disable strrchr-t)

; strrchr* --> strrchr.
(prove-lemma strrchr*-strrchr (rewrite)
     (implies (and (strrchr i n lst ch j)
		   (equal i (nat-to-uint i*))
		   (nat-rangep i* 32)
		   (uint-rangep n 32))
	      (equal (nat-to-uint (strrchr* i* i n lst ch j*))
		     (if (equal j f)
			 (strrchr i n lst ch f)
		       (strrchr i n lst ch (nat-to-uint j*)))))
     ((induct (strrchr-induct s i* i n lst ch j* j))))

(prove-lemma strrchr-non-zerop-la ()
     (let ((sn (stepn s (strrchr-t n lst ch))))
       (implies (and (strrchr-statep s str n lst ch)
		     (nat-rangep str 32)
		     (not (equal (nat-to-uint str) 0))
		     (uint-rangep (plus (nat-to-uint str) n) 32)
		     (strrchr 0 n lst ch f))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((enable nat-rangep-la)
      (disable strrchr-statep read-dn)))

(prove-lemma strrchr-non-zerop (rewrite)
     (let ((sn (stepn s (strrchr-t n lst ch))))
       (implies (and (strrchr-statep s str n lst ch)
		     (strrchr 0 n lst ch f))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((use (strrchr-non-zerop-la))))

(disable strrchr*)

; some properties of the function strrchr.
; see file cstring.events.