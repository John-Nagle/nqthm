\documentstyle[makeidx]{article}
\makeindex
%\setlength{\oddsidemargin}{.5in}
%\setlength{\evensidemargin}{.5in}
%\setlength{\textwidth}{5.8in}
\begin{document}
%\setlength{\parindent}{0pt}
%\newcounter{bean}
%\begin{list}{\arabic{bean}.}{\usecounter{bean}\setlength{\leftmargin}{0pt}\setlength{\rightmargin}{0pt}\setlength{\listparindent}{20pt}\setlength{\parsep}{5pt}}
%\item[]

\begin{verbatim}#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

\end{verbatim}
%---------------------------------------------------------------------------
% Date:      Jan, 1991
% File:      mc20-1.events
% Last modified on Mon Jan 18 15:50:27 PST 1993 by yuanyu
%---------------------------------------------------------------------------
%
% Although this is an event file suitable for running through Nqthm, it
% also can be used to produce a technical report in Latex.  The peculiar
% use of ! below is an instruction to the infix preprocessor to replace certain
% Nqthm forms with their infix equivalent. 
\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\begin{center}
\Large
\vspace*{2in}
A Formal Specification of\\
Some User Mode Instructions for the \\
Motorola 68020\\[.25in]

{\em Robert S. Boyer {\em and} Yuan Yu}\\[.25in]

\large
Technical Report  \\
Computer Sciences Department \\
University of Texas at Austin\\
Austin, Texas 78712\\[.25in]

December, 1992\\[.25in]
\end{center}
\newpage
\tableofcontents

\newpage
\pagenumbering{arabic}

\begin{center}
\Large

A Formal Specification of\\
Some User Mode Instructions for the \\
Motorola 68020{\normalsize \footnotemark} \\[.25in]

{\em Robert S. Boyer {\em and} Yuan Yu}\\[.25in]

\large
Computer Sciences and Mathematics Departments \\
University of Texas at Austin\\
Austin, Texas 78712\\[.25in]

December, 1992\\[.25in]

\normalsize
telephone: (512) 471-9745\\
email: boyer@cs.utexas.edu or yuan@cs.utexas.edu\\[.25in]
Technical Report  TR-92-04 (rev. 2.3 - dissertation version)\\
\end{center}

\footnotetext{The work described here was supported in part by
NSF Grant MIP-9017499.}

\vspace{.10in}
\noindent {\bf Abstract.}
We present a formal specification of approximately 80\% of the `user
mode' instructions of the Motorola MC68020 microprocessor.  The
specification is given in the form of definitions in the logic of
Nqthm, the Boyer-Moore system.  The definitions are displayed in a
conventional mathematical syntax.  The specification has been used in
the mechanical verification of several dozen machine code programs,
whose binary was generated by `industrial strength' C and Ada
compilers.

\section{Introduction}

This report contains a formal specification of
approximately 80\% of the `user mode' instructions of the Motorola MC68020
microprocessor.  An earlier report \cite{Boyer-Yu-91} describes how we have
used this specification to prove mechanically the correctness of several dozen
machine code programs, most of them generated by `industrial strength'
compilers for C or Ada.  Our specification is based upon the user's manual
for the MC68020 \cite{m20}.

The function definitions below are ordered so that a function is defined before
it is referenced by another function.  One of the very last functions defined,
`stepn', p.~\pageref{stepn}, emulates the MC68020.  Like all the functions in
this specification, `stepn' is a recursive and hence computable function.
Approximately speaking, if we are given an MC68020 state {\it{s\/}} and a positive
integer {\it{n\/}}, we can compute the state {\em s'} that results from executing an
MC68020 for {\it{n\/}} instructions, starting in state {\it{s\/}}, by applying `stepn' to {\it{s\/}}
and {\it{n\/}}.  If an illegal instruction or an instruction not among those covered
in this specification is encountered during execution, then {\em s'} will
exhibit an indication of the error.  If no such error indication is exhibited,
then the returned state correctly represents the state that a `real' MC68020
would have after running {\it{n\/}} instructions provided that (i) the caches are
initially consistent with memory, (ii) no interrupts happen during execution,
and, of course, (iii) no externally caused changes to the state occur during
execution.  In Section \ref{example} is a theorem that illustrates the use of
`stepn' to emulate an MC68020 on a specific state, one that contains machine
code for Euclid's GCD algorithm.

{\bf Disclaimer}: The development of this formal specification is part of a
small scientific project aimed at examining the feasibility of mechanically
checking the correctness of machine code programs that run on widely-used
microprocessors.  The accuracy with which the specification presented here
represents a `real' MC68020 is something we do not know how to ascertain with
the certainty of a mathematical proof.  One can only become increasingly
confident by such activities as critical reading, testing, and bug fixing.  It
is in a spirit of scientific cooperation that we distribute this specification,
but we distribute it without any warranty of any kind, on an `as is' basis.

The definitions below were written in the logic described in {\em A
Computational Logic Handbook,} \cite{BM-88}, with syntactic extensions
for `let' and `cond'.  The definitions have been admitted under the
definitional principle described in that book, using the mechanical
theorem prover also described in that book.  Although the logic and
prover use the prefix, parenthesized notation of Church's lambda
calculus and McCarthy's Lisp, in this report, we use a notation that
is conventional.  This new syntax is summarized in Section \ref{syntax}.

Our principal purpose in writing this technical report is to
communicate precisely the formal, mathematical definitions of our
specification of the MC68020.  This report is decidedly not a tutorial
on the MC68020 or on our specification of it.  The reader will find it
easier to read this specification after having read
\cite{Boyer-Yu-91}.  The reader will also find it invaluable to have a
copy of \cite{m20} handy.  Readers in search of a less stark
introduction to this specification will find it in the Ph.~D.
dissertation of Yuan Yu.  There also will be found a review of the
related scientific literature.

\section{A Few Basic Functions}

The objects we use in this specification are truth values, integers, ordered
pairs, and symbols.  The precise axioms and notations for these objects and the
built-in functions that operate on these objects may be found in \cite{BM-88}.
Here are a few brief remarks about some of these objects and functions.

\begin{itemize}

\item The constant `true', abbreviated {\bf{t}}, is the true truth value.

\item The constant `false', abbreviated {\bf{f}}, is the false truth value.

\item `if' is a function of three arguments.  {\bf if }{\it{x\/}}$\;${\bf then }{\it{y\/}} {\bf else }{\it{z\/}}$\;${\bf  endif} returns {\it{z\/}} if {\it{x\/}} is
equal to {\bf{f}}, and {\it{y\/}} otherwise.

\item `cons' is a function of two arguments.  {\rm{cons}}\,({\it{x\/}}, {\it{y\/}}) returns an ordered
pair whose first component is {\it{x\/}} and whose second is {\it{y\/}}.

\item `car' is a function of one argument.  {\rm{car}}\,({\it{x\/}}) returns the first component
if {\it{x\/}} is an ordered pair;  otherwise, it returns 0.

\item `cdr' is a function of one argument.  {\rm{cdr}}\,({\it{x\/}}) returns the second component
if {\it{x\/}} is an ordered pair;  otherwise, it returns 0.

\item `list' is a function of any number of arguments. {\rm{list}}\,({\it{x\/}}, {\it{y\/}}, {\it{z\/}}) is {\rm{cons}}\,({\it{x\/}}, {\rm{cons}}\,({\it{y\/}}, {\rm{cons}}\,({\it{z\/}}, {\bf{nil}}))).  {\bf{nil}} is a symbol, and is used to denote the empty
list.

\end{itemize}

Except for {\bf{nil}}, symbols are printed in a typewriter font, preceded by a single
quotation mark, e.g., {\tt{'}}{\tt{running}} and {\tt{'}}{\tt{read\_unavailable\_memory}}.

% The instructions we have done: (75)

% ADD, ADDA, ADDI, ADDQ, ADDX, AND, ANDI, ANDI to CCR, ASL, ASR, Bcc,
% BCHG, BCLR, BSET, BTST, BRA, BSR, CLR, CMP, CMPA, CMPI, CMPM, DBcc,
% DIVS, DIVSL, DIVU, DIVUL, EOR, EORI, EORI to CCR, EXG, EXT, EXTB, 
% JMP, JSR, LEA, LINK, LSL, LSR, MOVE, MOVEA, MOVE from CCR, MOVE to CCR, 
% MOVEM, MOVEP, MOVEQ, MULS, MULSL, MULU, MULUL, NEG, NEGX, NOP, NOT, OR, 
% ORI, ORI to CCR, PEA, ROL, ROR, ROXL, ROXR, RTD, RTR, RTS, SCC, SUB, 
% SUBA, SUBI, SUBQ, SUBX, SWAP, TAS, TST, UNLK.
%
% The instructions we have included, but not yet finished: (8)
%
% BFCHG, BFCLR, BFEXTS, BFEXTU, BFFFO, BFINS, BFSET, BFTST.
%
% The instructions we are not going to consider: (21)
%
% ABCD, BKPT, CALLM, CAS and CAS2, CHK, CHK2, CMP2, CPBCC, CPDBcc,
% CPGEN, CPSCC, CPTRAPCC, ILLEGAL, NBCD, PACK, RTM, SBCD, TRAP, TRAPcc,
% TRAPV, UNPK.
%
% The privileged instructions: (13)
%
% ANDI to SR, CPRESTORE, CPSAVE, EORI to SR, MOVE from SR, MOVE to SR,
% MOVE USP, MOVEC, MOVES, ORI to SR, RESET, RTE, STOP.
%
% The final specification will cover 80% of the user available instructions.

\section{Start Up}




\noindent{\sc Event}:   Start with the library {\tt{"mc20-0"}} using the compiled version.

\addvspace{18pt}



Our initial library {\tt mc20-0} contains (i) the basic axioms and definitions
of Nqthm, which are described in Chapter 4 of \cite{BM-88}, (ii) some proved
arithmetic lemmas that are used to help in the admission of the following
definitions, and (iii) a definition of the nonnegative integer exponentiation
function `exp', which is defined as: {\rm{exp}}\,({\it{x\/}}, {\it{y\/}})\index{exp} $=$$\;${\bf if }{\it{y\/}} $\simeq {\tt{0}}$ {\bf then }{\tt{1}} {\bf else }{\it{x\/}} $*$ {\rm{exp}}\,({\it{x\/}}, {\it{y\/}} $-\;1$)\index{exp}$\;${\bf  endif}.  \index{exp}

\section{Some Constants}

We first define a few constants.



 In the MC68020, a ``byte'' is 8 bits long.  A ``word'' is 16 bits long. 
 A ``long word'' is 32 bits long.  A ``quad word'' is 64 bits long.

\begin{tabbing}{\sc Definition}:\index{b}$\;\;$
{\sc{b}}\index{b} $=$ {\tt{8}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{w}$\;\;$
{\sc{w}}\index{w} $=$ {\tt{16}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{l}$\;\;$
{\sc{l}}\index{l} $=$ {\tt{32}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{q}$\;\;$
{\sc{q}}\index{q} $=$ {\tt{64}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bsz}$\;\;$
{\sc{bsz}}\index{bsz} $=$ {\tt{1}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{wsz}$\;\;$
{\sc{wsz}}\index{wsz} $=$ {\tt{2}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{lsz}$\;\;$
{\sc{lsz}}\index{lsz} $=$ {\tt{4}}
\end{tabbing}
\begin{tabbing}{\sc Definition}:\index{qsz}$\;\;$
{\sc{qsz}}\index{qsz} $=$ {\tt{8}}
\end{tabbing}

 Some error signals.
\begin{tabbing}{\sc Definition}:\index{read-signal}$\;\;$
{\sc{read-signal}}\index{read-signal} $=$ {\tt{'}}{\tt{read\_unavailable\_memory}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{write-signal}$\;\;$
{\sc{write-signal}}\index{write-signal} $=$ {\tt{'}}{\tt{write\_rom\_or\_unavailable\_memory}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{reserved-signal} \\  
{\sc{reserved-signal}}\index{reserved-signal} $=$ {\tt{'}}{\tt{motorola\_reserved\_for\_future\_development}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-signal}$\;\;$
{\sc{pc-signal}}\index{pc-signal} $=$ {\tt{'}}{\tt{pc\_outside\_rom}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-odd-signal}$\;\;$
{\sc{pc-odd-signal}}\index{pc-odd-signal} $=$ {\tt{'}}{\tt{pc\_at\_odd\_address}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mode-signal} \\  
\=\+{\sc{mode-signal}}\index{mode-signal} \\ 
$=$$\;\;\;\;${\tt{'}}{\tt{illegal\_addressing\_mode\_in\_current\_instruction}}\-
\end{tabbing}

 Throughout our specification, we have frequent need to refer to bits and
 bit-vectors.  In our model, bit ::= 0 {\tt |} 1, and bit-vectors ::= nonnegative
 integers.  If the operation is signed, we use the two conversion functions
 `nat-to-int' and `int-to-nat'.

 `bitp' is a function of one argument, {\it{x\/}}.  `bitp' returns {\bf{t}} or {\bf{f}}
 according to whether {\it{x\/}} is a bit or not.
\begin{tabbing}{\sc Definition}:\index{bitp}$\;\;$
{\rm{bitp}}\,({\it{x\/}})\index{bitp} $=$ (({\it{x\/}} $=$ {\tt{0}}) $\vee$ ({\it{x\/}} $=$ {\tt{1}}))
\end{tabbing}

 We frequently use the bits 0 and 1.  For clarity, to identify informally
 when we are using these integers as bits, we use the two constants `b1'
 and `b0'.

\begin{tabbing}{\sc Definition}:\index{b1}$\;\;$
{\sc{b1}}\index{b1} $=$ {\tt{1}}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{b0}$\;\;$
{\sc{b0}}\index{b0} $=$ {\tt{0}}
\end{tabbing}

 We frequently test a bit to see whether it is 0 or 1.  We define
 the functions `b1p' and `b0p' to return {\bf{t}} or {\bf{f}} according to whether
 their arguments are 0 or non-0 respectively.
\begin{tabbing}{\sc Definition}:\index{b0p}$\;\;$
{\rm{b0p}}\,({\it{x\/}})\index{b0p} $=$ ({\it{x\/}} $=$ {\sc{b0}}\index{b0})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{b1p}$\;\;$
{\rm{b1p}}\,({\it{x\/}})\index{b1p} $=$ ({\it{x\/}} $\not=$ {\sc{b0}}\index{b0})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{fix-bit} \\  
\=\+{\rm{fix-bit}}\,({\it{c\/}})\index{fix-bit} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{c\/}})\index{b0p}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

 Here are the definitions of some operators for logical arithmetic on bits.

 `b-not' returns the complement of its argument.
\begin{tabbing}{\sc Definition}:\index{b-not} \\  
\=\+{\rm{b-not}}\,({\it{x\/}})\index{b-not} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-and' returns the logical and of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-and} \\  
\=\+{\rm{b-and}}\,({\it{x\/}}, {\it{y\/}})\index{b-and} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf elseif }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-or' returns the logical or of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-or} \\  
\=\+{\rm{b-or}}\,({\it{x\/}}, {\it{y\/}})\index{b-or} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\- \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-nor' returns the logical nor of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-nor} \\  
\=\+{\rm{b-nor}}\,({\it{x\/}}, {\it{y\/}})\index{b-nor} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\- \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-nand' returns the logical nand of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-nand} \\  
\=\+{\rm{b-nand}}\,({\it{x\/}}, {\it{y\/}})\index{b-nand} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf elseif }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-eor' returns the exclusive or of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-eor} \\  
\=\+{\rm{b-eor}}\,({\it{x\/}}, {\it{y\/}})\index{b-eor} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\it{y\/}})\index{b0p}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

 `b-equal' returns the logical equal of its two arguments.
\begin{tabbing}{\sc Definition}:\index{b-equal} \\  
\=\+{\rm{b-equal}}\,({\it{x\/}}, {\it{y\/}})\index{b-equal} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\it{x\/}})\index{b0p}$\;\;${\bf then }{\rm{b0p}}\,({\it{y\/}})\index{b0p} \\ 
{\bf else }{\rm{b1p}}\,({\it{y\/}})\index{b1p}$\;${\bf  endif}\-\-
\end{tabbing}

 \section{Bit Vector Arithmetic}

 `bcar' returns the first bit of {\it{x\/}}.
\begin{tabbing}{\sc Definition}:\index{bcar}$\;\;$
{\rm{bcar}}\,({\it{x\/}})\index{bcar} $=$ ({\it{x\/}} ${}${\bf{mod}}${}$ {\tt{2}})
\end{tabbing}

 `bcdr' returns a natural number by cutting off the first bit of {\it{x\/}}.
 For any natural number {\it{x\/}}, ({\rm{bcar}}\,({\it{x\/}})\index{bcar} $+$$\;$({\it{x\/}} $*$ {\rm{bcdr}}\,({\it{x\/}})\index{bcdr})) $=$$\;${\it{x\/}}.

\begin{tabbing}{\sc Definition}:\index{bcdr}$\;\;$
{\rm{bcdr}}\,({\it{x\/}})\index{bcdr} $=$ ({\it{x\/}} $\div$ {\tt{2}})
\end{tabbing}

 `head' is a function of two arguments, {\it{x\/}} and {\it{n\/}}.  {\it{x\/}} and {\it{n\/}} should be
 nonnegative integers.  `head' returns the remainder of {\it{x\/}} divided by
 $2^n$.
\begin{tabbing}{\sc Definition}:\index{head}$\;\;$
{\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head} $=$ ({\it{x\/}} ${}${\bf{mod}}${}$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp})
\end{tabbing}

 `tail' is a function of two arguments, {\it{x\/}} and {\it{n\/}}.  {\it{x\/}} and {\it{n\/}} should be
 nonnegative integers.  `tail' returns the quotient of {\it{x\/}} divided by
 $2^n$.
\begin{tabbing}{\sc Definition}:\index{tail}$\;\;$
{\rm{tail}}\,({\it{x\/}}, {\it{n\/}})\index{tail} $=$ ({\it{x\/}} $\div$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp})
\end{tabbing}

 We next define some logical operations on bit-vectors.  `lognot' takes
 two naturals as its arguments and returns the logical complement of its
 second argument.
\begin{tabbing}{\sc Definition}:\index{lognot}$\;\;$
{\rm{lognot}}\,({\it{n\/}}, {\it{x\/}})\index{lognot} $=$ (({\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp} $-$ {\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head}) $-\;1$)
\end{tabbing}

 `logand' takes two naturals as arguments and returns their logical and.
\begin{tabbing}{\sc Definition}:\index{logand} \\  
\=\+{\rm{logand}}\,({\it{x\/}}, {\it{y\/}})\index{logand} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{x\/}} $\simeq {\tt{0}}$) $\vee$ ({\it{y\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }\=\+{\rm{b-and}}\,({\rm{bcar}}\,({\it{x\/}})\index{bcar}, {\rm{bcar}}\,({\it{y\/}})\index{bcar})\index{b-and} \\ 
$+$$\;\;\;\;$({\tt{2}} $*$ {\rm{logand}}\,({\rm{bcdr}}\,({\it{x\/}})\index{bcdr}, {\rm{bcdr}}\,({\it{y\/}})\index{bcdr})\index{logand})\-$\;${\bf  endif}\-\-
\end{tabbing}

 `logor' takes two naturals as arguments and returns the logical
 (inclusive) or of the two arguments.
\begin{tabbing}{\sc Definition}:\index{logor} \\  
\=\+{\rm{logor}}\,({\it{x\/}}, {\it{y\/}})\index{logor} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{x\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{fix}}\,({\it{y\/}}) \\ 
{\bf elseif }{\it{y\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{fix}}\,({\it{x\/}}) \\ 
{\bf else }{\rm{b-or}}\,({\rm{bcar}}\,({\it{x\/}})\index{bcar}, {\rm{bcar}}\,({\it{y\/}})\index{bcar})\index{b-or} $+$ ({\tt{2}} $*$ {\rm{logor}}\,({\rm{bcdr}}\,({\it{x\/}})\index{bcdr}, {\rm{bcdr}}\,({\it{y\/}})\index{bcdr})\index{logor})$\;${\bf  endif}\-\-
\end{tabbing}

 `logeor' takes two naturals as arguments and returns the logical
 exclusive or of the two arguments.
\begin{tabbing}{\sc Definition}:\index{logeor} \\  
\=\+{\rm{logeor}}\,({\it{x\/}}, {\it{y\/}})\index{logeor} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{x\/}} $\simeq {\tt{0}}$) $\wedge$ ({\it{y\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }\=\+{\rm{b-eor}}\,({\rm{bcar}}\,({\it{x\/}})\index{bcar}, {\rm{bcar}}\,({\it{y\/}})\index{bcar})\index{b-eor} \\ 
$+$$\;\;\;\;$({\tt{2}} $*$ {\rm{logeor}}\,({\rm{bcdr}}\,({\it{x\/}})\index{bcdr}, {\rm{bcdr}}\,({\it{y\/}})\index{bcdr})\index{logeor})\-$\;${\bf  endif}\-\-
\end{tabbing}

 `bitn' retrieves the nth bit of {\it{x\/}}.  Indexing is 0-based.
\begin{tabbing}{\sc Definition}:\index{bitn}$\;\;$
{\rm{bitn}}\,({\it{x\/}}, {\it{n\/}})\index{bitn} $=$ {\rm{bcar}}\,({\rm{tail}}\,({\it{x\/}}, {\it{n\/}})\index{tail})\index{bcar}
\end{tabbing}

 `mbit' returns the most significant bit of {\it{x\/}}, assuming that {\it{x\/}} is a 
 bit vector of {\it{n\/}} bits.
\begin{tabbing}{\sc Definition}:\index{mbit}$\;\;$
{\rm{mbit}}\,({\it{x\/}}, {\it{n\/}})\index{mbit} $=$ {\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn}
\end{tabbing}

 `bits' returns bits {\it{i\/}} through {\it{j\/}} as a natural number.  `bits' is a function
 of three arguments, {\it{x\/}}, {\it{i\/}}, and {\it{j\/}}.  {\it{x\/}}, {\it{i\/}}, and {\it{j\/}} should be natural numbers.
 Intuitively, bits extracts bits of {\it{x\/}} from bit {\it{i\/}} to bit {\it{j\/}}.  Normally, {\it{i\/}}
 should be less than or equal to {\it{j\/}}.
\begin{tabbing}{\sc Definition}:\index{bits}$\;\;$
{\rm{bits}}\,({\it{x\/}}, {\it{i\/}}, {\it{j\/}})\index{bits} $=$ {\rm{head}}\,({\rm{tail}}\,({\it{x\/}}, {\it{i\/}})\index{tail}, $1\;+$ ({\it{j\/}} $-$ {\it{i\/}}))\index{head}
\end{tabbing}

 `setn' updates the $n^{\rm th}$ bit of {\it{x\/}} by the given value {\it{c\/}}.  Indexing is 0-based.
\begin{tabbing}{\sc Definition}:\index{setn} \\  
\=\+{\rm{setn}}\,({\it{x\/}}, {\it{n\/}}, {\it{c\/}})\index{setn} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{fix-bit}}\,({\it{c\/}})\index{fix-bit} $+$ ({\tt{2}} $*$ {\rm{bcdr}}\,({\it{x\/}})\index{bcdr}) \\ 
{\bf else }{\rm{bcar}}\,({\it{x\/}})\index{bcar} $+$ ({\tt{2}} $*$ {\rm{setn}}\,({\rm{bcdr}}\,({\it{x\/}})\index{bcdr}, {\it{n\/}} $-\;1$, {\it{c\/}})\index{setn})$\;${\bf  endif}\-\-
\end{tabbing}

 `adder' takes four arguments and returns the addition of {\it{x\/}}, {\it{y\/}}, and {\it{c\/}} modulo
 $2^n$.  That is, ({\it{x\/}} $+$$\;${\it{y\/}} $+$$\;${\it{c\/}}) ${}${\bf{mod}}${}$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}.  Typically,  {\it{c\/}} is either 0 or 1.
\begin{tabbing}{\sc Definition}:\index{adder}$\;\;$
{\rm{adder}}\,({\it{n\/}}, {\it{c\/}}, {\it{x\/}}, {\it{y\/}})\index{adder} $=$ {\rm{head}}\,({\it{c\/}} $+$ {\it{x\/}} $+$ {\it{y\/}}, {\it{n\/}})\index{head}
\end{tabbing}

 `add' takes three arguments and returns the addition of {\it{x\/}} and {\it{y\/}} modulo
 $2^n$.  That is, ({\it{x\/}} $+$ {\it{y\/}}) ${}${\bf{mod}}${}$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}.
\begin{tabbing}{\sc Definition}:\index{add}$\;\;$
{\rm{add}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{add} $=$ {\rm{head}}\,({\it{x\/}} $+$ {\it{y\/}}, {\it{n\/}})\index{head}
\end{tabbing}

 `subtracter' takes four arguments and returns the subtraction of {\it{y\/}} and
 ({\it{x\/}} $+$ {\it{c\/}}) ${}${\bf{mod}}${}$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}.  That is, ({\it{y\/}} $-$ ({\it{x\/}} $+$ {\it{c\/}})) ${}${\bf{mod}}${}$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}.  Typically,  {\it{c\/}} is
 either 0 or 1.
\begin{tabbing}{\sc Definition}:\index{subtracter} \\  
{\rm{subtracter}}\,({\it{n\/}}, {\it{c\/}}, {\it{x\/}}, {\it{y\/}})\index{subtracter} $=$ {\rm{adder}}\,({\it{n\/}}, {\rm{b-not}}\,({\it{c\/}})\index{b-not}, {\it{y\/}}, {\rm{lognot}}\,({\it{n\/}}, {\it{x\/}})\index{lognot})\index{adder}
\end{tabbing}

 `sub' takes three arguments and returns, in the form of 2's complement,
 the subtraction of y and x.  That is, ({\it{y\/}} $-$ {\it{x\/}}) ${}${\bf{mod}}${}$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}.
\begin{tabbing}{\sc Definition}:\index{sub} \\  
{\rm{sub}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{sub} $=$ {\rm{head}}\,({\it{y\/}} $+$ ({\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp} $-$ {\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head}), {\it{n\/}})\index{head}
\end{tabbing}

 `app' ``appends'' two naturals.  `app' takes three arguments, {\it{n\/}}, {\it{x\/}}, and {\it{y\/}}.
\begin{tabbing}{\sc Definition}:\index{app}$\;\;$
{\rm{app}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{app} $=$ ({\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head} $+$ ({\it{y\/}} $*$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp}))
\end{tabbing}

 `replace' replaces {\it{x\/}} partially by {\it{y\/}} in the head. `replace' is a function
 of three arguments, {\it{n\/}}, {\it{x\/}} and {\it{y\/}}, all of which should be naturals. `replace'
 is frequently used when updating only one byte or one word in a register,
 leaving the other bytes alone.
\begin{tabbing}{\sc Definition}:\index{replace}$\;\;$
{\rm{replace}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{replace} $=$ {\rm{app}}\,({\it{n\/}}, {\it{x\/}}, {\rm{tail}}\,({\it{y\/}}, {\it{n\/}})\index{tail})\index{app}
\end{tabbing}

 `ext' is a function of three arguments, {\it{n\/}}, {\it{x\/}} and {\it{size\/}}.  `ext' is used
 frequently to do ``sign-extension''.  For instance, in the MC68020,
 we often extract a byte or word and wish to add it into a 32-bit sum,
 but we first sign-extend the extracted quantity to obtain a meaningful
 sum.
\begin{tabbing}{\sc Definition}:\index{ext} \\  
\=\+{\rm{ext}}\,({\it{n\/}}, {\it{x\/}}, {\it{size\/}})\index{ext} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $<$ {\it{size\/}} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head} \\ 
{\bf else }{\rm{app}}\,({\it{n\/}}, {\it{x\/}}, {\rm{exp}}\,({\tt{2}}, {\it{size\/}} $-$ {\it{n\/}})\index{exp} $-\;1$)\index{app}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{head}}\,({\it{x\/}}, {\it{size\/}})\index{head}$\;${\bf  endif}\-\-
\end{tabbing}

 Shift operations.

 Logical shift left.
\begin{tabbing}{\sc Definition}:\index{lsl}$\;\;$
{\rm{lsl}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{lsl} $=$ {\rm{head}}\,({\it{x\/}} $*$ {\rm{exp}}\,({\tt{2}}, {\it{cnt\/}})\index{exp}, {\it{len\/}})\index{head}
\end{tabbing}

 Arithmetic shift left.
\begin{tabbing}{\sc Definition}:\index{asl}$\;\;$
{\rm{asl}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{asl} $=$ {\rm{head}}\,({\it{x\/}} $*$ {\rm{exp}}\,({\tt{2}}, {\it{cnt\/}})\index{exp}, {\it{len\/}})\index{head}
\end{tabbing}

 Logical shift right.
\begin{tabbing}{\sc Definition}:\index{lsr}$\;\;$
{\rm{lsr}}\,({\it{x\/}}, {\it{cnt\/}})\index{lsr} $=$ {\rm{tail}}\,({\it{x\/}}, {\it{cnt\/}})\index{tail}
\end{tabbing}

 Arithmetic shift right.
\begin{tabbing}{\sc Definition}:\index{asr} \\  
\=\+{\rm{asr}}\,({\it{n\/}}, {\it{x\/}}, {\it{cnt\/}})\index{asr} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{x\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp}$\;\;${\bf then }{\rm{tail}}\,({\it{x\/}}, {\it{cnt\/}})\index{tail} \\ 
{\bf elseif }{\it{n\/}} $<$ {\it{cnt\/}}$\;\;${\bf then }{\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp} $-\;1$ \\ 
{\bf else }{\rm{app}}\,({\it{n\/}} $-$ {\it{cnt\/}}, {\rm{tail}}\,({\it{x\/}}, {\it{cnt\/}})\index{tail}, {\rm{exp}}\,({\tt{2}}, {\it{cnt\/}})\index{exp} $-\;1$)\index{app}$\;${\bf  endif}\-\-
\end{tabbing}

 \section{Integer Arithmetic}

 Throughout most of this MC68020 specification, we restrict our attention to
 arithmetic on the nonnegative integers.  However, in the definition of two
 machine instructions, those for signed multiplication and division, we also
 consider all of the integers, both nonnegative and negative.  The Nqthm
 logic adds the negative integers almost as an afterthought, and the basic,
 built-in arithmetic operations of the Nqthm logic work only for nonnegative
 integers.  To do arithmetic on all the integers, we must define appropriate
 operations explicitly, as we do below.
 
 The Nqthm logic has the peculiarity that $-$ {\tt{0}} is not the same as {\tt{0}} .
 However, we will restrict our domain so that $-$ {\tt{0}} is not considered.
 A negative integer is defined to be of the form $-$ {\it{x\/}} with {\it{x\/}} nonzero.
\begin{tabbing}{\sc Definition}:\index{negp}$\;\;$
{\rm{negp}}\,({\it{i\/}})\index{negp} $=$ ({\rm{negativep}}\,({\it{i\/}}) $\wedge$ ({\it{i\/}} $\not=$ ($-$ {\tt{0}})))
\end{tabbing}

 {\it{x\/}} is an integer iff {\it{x\/}} is either a nonnegative number or a negative number.
\begin{tabbing}{\sc Definition}:\index{integerp}$\;\;$
{\rm{integerp}}\,({\it{x\/}})\index{integerp} $=$ (({\it{x\/}} $\in\;${\bf{N}}${}$) $\vee$ {\rm{negp}}\,({\it{x\/}})\index{negp})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{fix-int} \\  
\=\+{\rm{fix-int}}\,({\it{x\/}})\index{fix-int} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{integerp}}\,({\it{x\/}})\index{integerp}$\;\;${\bf then }{\it{x\/}} \\ 
{\bf else }{\tt{0}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{izerop}$\;\;$
{\rm{izerop}}\,({\it{x\/}})\index{izerop} $=$ ({\rm{fix-int}}\,({\it{x\/}})\index{fix-int} $=$ {\tt{0}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{abs} \\  
\=\+{\rm{abs}}\,({\it{x\/}})\index{abs} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{x\/}})\index{negp}$\;\;${\bf then }{\rm{negative-guts}}\,({\it{x\/}}) \\ 
{\bf else }{\rm{fix}}\,({\it{x\/}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ilessp} \\  
\=\+{\rm{ilessp}}\,({\it{i\/}}, {\it{j\/}})\index{ilessp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{i\/}})\index{negp} \\ 
{\bf then }\=\+{\bf if }{\rm{negp}}\,({\it{j\/}})\index{negp}$\;\;${\bf then }{\rm{negative-guts}}\,({\it{j\/}}) $<$ {\rm{negative-guts}}\,({\it{i\/}}) \\ 
{\bf else }{\bf{t}}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{negp}}\,({\it{j\/}})\index{negp}$\;\;${\bf then }{\bf{f}} \\ 
{\bf else }{\it{i\/}} $<$ {\it{j\/}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ileq}$\;\;$
{\rm{ileq}}\,({\it{i\/}}, {\it{j\/}})\index{ileq} $=$ ($\neg$ {\rm{ilessp}}\,({\it{j\/}}, {\it{i\/}})\index{ilessp})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{iplus} \\  
\=\+{\rm{iplus}}\,({\it{x\/}}, {\it{y\/}})\index{iplus} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{x\/}})\index{negp} \\ 
{\bf then }\=\+{\bf if }{\rm{negp}}\,({\it{y\/}})\index{negp}$\;\;${\bf then }$-$ ({\rm{negative-guts}}\,({\it{x\/}}) $+$ {\rm{negative-guts}}\,({\it{y\/}})) \\ 
{\bf elseif }{\it{y\/}} $<$ {\rm{negative-guts}}\,({\it{x\/}})$\;\;${\bf then }$-$ ({\rm{negative-guts}}\,({\it{x\/}}) $-$ {\it{y\/}}) \\ 
{\bf else }{\it{y\/}} $-$ {\rm{negative-guts}}\,({\it{x\/}})$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{negp}}\,({\it{y\/}})\index{negp} \\ 
{\bf then }\=\+{\bf if }{\it{x\/}} $<$ {\rm{negative-guts}}\,({\it{y\/}})$\;\;${\bf then }$-$ ({\rm{negative-guts}}\,({\it{y\/}}) $-$ {\it{x\/}}) \\ 
{\bf else }{\it{x\/}} $-$ {\rm{negative-guts}}\,({\it{y\/}})$\;${\bf  endif}\- \\ 
{\bf else }{\it{x\/}} $+$ {\it{y\/}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ineg} \\  
\=\+{\rm{ineg}}\,({\it{x\/}})\index{ineg} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{izerop}}\,({\it{x\/}})\index{izerop}$\;\;${\bf then }{\tt{0}} \\ 
{\bf elseif }{\rm{negp}}\,({\it{x\/}})\index{negp}$\;\;${\bf then }{\rm{negative-guts}}\,({\it{x\/}}) \\ 
{\bf else }$-$ {\it{x\/}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{idifference}$\;\;$
{\rm{idifference}}\,({\it{x\/}}, {\it{y\/}})\index{idifference} $=$ {\rm{iplus}}\,({\it{x\/}}, {\rm{ineg}}\,({\it{y\/}})\index{ineg})\index{iplus}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{itimes} \\  
\=\+{\rm{itimes}}\,({\it{x\/}}, {\it{y\/}})\index{itimes} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{x\/}})\index{negp} \\ 
{\bf then }\=\+{\bf if }{\rm{negp}}\,({\it{y\/}})\index{negp}$\;\;${\bf then }{\rm{negative-guts}}\,({\it{x\/}}) $*$ {\rm{negative-guts}}\,({\it{y\/}}) \\ 
{\bf else }{\rm{fix-int}}\,($-$ ({\rm{negative-guts}}\,({\it{x\/}}) $*$ {\it{y\/}}))\index{fix-int}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{negp}}\,({\it{y\/}})\index{negp}$\;\;${\bf then }{\rm{fix-int}}\,($-$ ({\it{x\/}} $*$ {\rm{negative-guts}}\,({\it{y\/}})))\index{fix-int} \\ 
{\bf else }{\it{x\/}} $*$ {\it{y\/}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{iremainder} \\  
\=\+{\rm{iremainder}}\,({\it{x\/}}, {\it{y\/}})\index{iremainder} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{x\/}})\index{negp}$\;\;${\bf then }{\rm{fix-int}}\,($-$ ({\rm{negative-guts}}\,({\it{x\/}}) ${}${\bf{mod}}${}$ {\rm{abs}}\,({\it{y\/}})\index{abs}))\index{fix-int} \\ 
{\bf else }{\it{x\/}} ${}${\bf{mod}}${}$ {\rm{abs}}\,({\it{y\/}})\index{abs}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{iquotient} \\  
\=\+{\rm{iquotient}}\,({\it{x\/}}, {\it{y\/}})\index{iquotient} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negp}}\,({\it{x\/}})\index{negp} \\ 
{\bf then }\=\+{\bf if }{\rm{negp}}\,({\it{y\/}})\index{negp}$\;\;${\bf then }{\rm{negative-guts}}\,({\it{x\/}}) $\div$ {\rm{negative-guts}}\,({\it{y\/}}) \\ 
{\bf else }{\rm{fix-int}}\,($-$ ({\rm{negative-guts}}\,({\it{x\/}}) $\div$ {\it{y\/}}))\index{fix-int}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{negp}}\,({\it{y\/}})\index{negp}$\;\;${\bf then }{\rm{fix-int}}\,($-$ ({\it{x\/}} $\div$ {\rm{negative-guts}}\,({\it{y\/}})))\index{fix-int} \\ 
{\bf else }{\it{x\/}} $\div$ {\it{y\/}}$\;${\bf  endif}\-\-
\end{tabbing}

 The size of bit vectors.
 `nat-rangep' returns {\bf{t}}, if {\it{nat\/}} $<$ {\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}, but returns {\bf{f}}, otherwise.
\begin{tabbing}{\sc Definition}:\index{nat-rangep}$\;\;$
{\rm{nat-rangep}}\,({\it{nat\/}}, {\it{n\/}})\index{nat-rangep} $=$ ({\it{nat\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp})
\end{tabbing}

 The size of an unsigned integer.
 `uint-rangep' returns {\bf{t}}, if {\tt{0}} $\leq$$\;${\it{x\/}} $\leq$$\;${\rm{exp}}\,({\it{n\/}}, {\tt{2}})\index{exp}, and returns {\bf{f}}, otherwise.
\begin{tabbing}{\sc Definition}:\index{uint-rangep}$\;\;$
{\rm{uint-rangep}}\,({\it{x\/}}, {\it{n\/}})\index{uint-rangep} $=$ ({\it{x\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp})
\end{tabbing}

 Two conversion functions for unsigned integer interpretation.
\begin{tabbing}{\sc Definition}:\index{nat-to-uint}$\;\;$
{\rm{nat-to-uint}}\,({\it{x\/}})\index{nat-to-uint} $=$ {\rm{fix}}\,({\it{x\/}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{uint-to-nat}$\;\;$
{\rm{uint-to-nat}}\,({\it{x\/}})\index{uint-to-nat} $=$ {\rm{fix}}\,({\it{x\/}})
\end{tabbing}

 The size of an integer.
 `int-rangep' returns {\bf{t}}, if (($-$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp}) $\leq$$\;${\it{int\/}}) $\wedge$$\;$({\it{int\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp}), and returns {\bf{f}}, otherwise.
\begin{tabbing}{\sc Definition}:\index{int-rangep} \\  
\=\+{\rm{int-rangep}}\,({\it{int\/}}, {\it{n\/}})\index{int-rangep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{fix-int}}\,({\it{int\/}})\index{fix-int} $=$ {\tt{0}} \\ 
{\bf elseif }{\rm{negativep}}\,({\it{int\/}})$\;\;${\bf then }{\rm{negative-guts}}\,({\it{int\/}}) $\leq$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp} \\ 
{\bf else }{\it{int\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp}$\;${\bf  endif}\-\-
\end{tabbing}

 Two conversion functions for signed integer interpretation. `nat-to-int' 
 converts natural numbers to integers, `int-to-nat' converts integers to 
 natural numbers.
\begin{tabbing}{\sc Definition}:\index{nat-to-int} \\  
\=\+{\rm{nat-to-int}}\,({\it{x\/}}, {\it{n\/}})\index{nat-to-int} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{x\/}} $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}} $-\;1$)\index{exp}$\;\;${\bf then }{\rm{fix}}\,({\it{x\/}}) \\ 
{\bf else }$-$ ({\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp} $-$ {\it{x\/}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{int-to-nat} \\  
\=\+{\rm{int-to-nat}}\,({\it{x\/}}, {\it{size\/}})\index{int-to-nat} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negativep}}\,({\it{x\/}})$\;\;${\bf then }{\rm{exp}}\,({\tt{2}}, {\it{size\/}})\index{exp} $-$ {\rm{negative-guts}}\,({\it{x\/}}) \\ 
{\bf else }{\rm{fix}}\,({\it{x\/}})$\;${\bf  endif}\-\-
\end{tabbing}

  \section{Binary Trees for Memory}

 A binary tree is either {\bf{nil}} or an object of the form ({\it{value\/}} {\it{bt0\/}} . {\it{bt1\/}}),
 where {\it{bt0\/}} and {\it{bt1\/}} are binary trees and {\it{value\/}} is any object stored at
 that node.

 `value-field' is a function of one argument.  `value-field' returns the
 object stored at the current node, i.e., the `car'.
\begin{tabbing}{\sc Definition}:\index{value-field} \\  
\=\+{\rm{value-field}}\,({\it{bt\/}})\index{value-field} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{bt\/}})$\;\;${\bf then }{\rm{car}}\,({\it{bt\/}}) \\ 
{\bf else }{\tt{0}}$\;${\bf  endif}\-\-
\end{tabbing}

 `branch0' is a function of one argument, which should be a non-{\bf{nil}} binary
 tree. `branch0' returns the left branch, i.e., the `cadr'.
\begin{tabbing}{\sc Definition}:\index{branch0} \\  
\=\+{\rm{branch0}}\,({\it{bt\/}})\index{branch0} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{bt\/}})$\;\;${\bf then }{\rm{cadr}}\,({\it{bt\/}}) \\ 
{\bf else }{\bf{nil}}$\;${\bf  endif}\-\-
\end{tabbing}

 `branch1' is a function of one argument, which should be a non-{\bf{nil}} bin-tree.
 `branch1' returns the right branch, i.e., the `cddr'.
\begin{tabbing}{\sc Definition}:\index{branch1} \\  
\=\+{\rm{branch1}}\,({\it{bt\/}})\index{branch1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{bt\/}}) $\wedge$ {\rm{listp}}\,({\rm{cdr}}\,({\it{bt\/}}))$\;\;${\bf then }{\rm{cddr}}\,({\it{bt\/}}) \\ 
{\bf else }{\bf{nil}}$\;${\bf  endif}\-\-
\end{tabbing}

 Construct a binary tree ({\it{value\/}} {\it{br0\/}} . {\it{br1\/}}).
\begin{tabbing}{\sc Definition}:\index{make-bt}$\;\;$
{\rm{make-bt}}\,({\it{value\/}}, {\it{br0\/}}, {\it{br1\/}})\index{make-bt} $=$ {\rm{cons}}\,({\it{value\/}}, {\rm{cons}}\,({\it{br0\/}}, {\it{br1\/}}))
\end{tabbing}

 In order to execute MC68020 instructions reasonably efficiently in an
 applicative programming language, we implement memory using binary trees
 rather than simple linear lists or association lists.  Binary trees give us
 logarithmic access and change times.

 A memory state in this specification is actually given by a `cons' of two
 binary trees, one that tells us `protection' information about each byte of
 the memory and one that is the `physical' memory, i.e., the byte of data
 stored at each 32-bit address.

 A completely `full' binary tree would contain $2^{32}$ tips, and the explicit
 representation of such a tree would vastly exceed the memory capacity of any
 known implementation of Nqthm.  Therefore, we assign meaning to non-full,
 i.e., partially full, binary trees, both for protection and for data.

 To characterize, informally, the content and protection of an address in
 memory, let us momentarily view an address as a sequence of 32 bits, most
 significant bit on the left.  By an `initial sequence' of an address {\it{x\/}}, we mean a
 sequence to which one can append another possibly empty sequence on the
 right to obtain {\it{x\/}}.  Thus {\tt 001} is an initial sequence of {\tt
 0010011}.  For a given memory data tree {\it{bt\/}} and address {\it{x\/}}, what is the
 content of {\it{bt\/}} at {\it{x\/}}?  Answer: if the subtree of {\it{bt\/}} obtained by taking
 the path through {\it{bt\/}} determined by any initial sequence of {\it{x\/}} is {\bf{nil}},
 then the content of {\it{bt\/}} at {\it{x\/}} is {\tt 0}.  Otherwise, the content is the
 value field at the subtree of {\it{bt\/}} determined by {\it{x\/}}.  In other words, if
 {\it{bt\/}} is not sufficiently deep along the path {\it{x\/}}, then the content of
 {\it{bt\/}} at {\it{x\/}} is {\tt 0}.

 A memory protection tree {\it{map\/}} is a binary tree which has stored at each
 node, in the value cell, either {\bf{nil}}, {\tt{'}}{\tt{(}}{\tt{unavailable}}{\tt{)}}, {\tt{'}}{\tt{(}}{\tt{rom}}{\tt{)}}, or
 {\tt{'}}{\tt{(}}{\tt{unavailable}} {\tt{rom}}{\tt{)}}.  (The last of these has the same meaning as
 {\tt{'}}{\tt{(}}{\tt{unavailable}}{\tt{)}}.) For a given memory protection tree {\it{map\/}} and address {\it{x\/}},
 what is the protection status of {\it{map\/}} at {\it{x\/}}?  Answer: if {\tt{'}}{\tt{unavailable}} is
 a member of the value cell at any subtree of {\it{map\/}} obtained by taking the
 path through {\it{map\/}} determined by any initial subsequence of {\it{x\/}}, then the
 address {\it{x\/}} is said to be unavailable, and it may not be read or written
 (even as part of a word or long word operation) by any instruction.
 Moreover, if an address {\it{x\/}} is not unavailable by the preceding rule, but
 {\tt{'}}{\tt{rom}} is a member of any such value cell, then the address is said to be
 ROM and may not be written by any instruction.  Instructions must come
 entirely from such ROM addresses.  Finally, if an address is not unavailable
 or ROM by the preceding rules, we say that it is RAM, and it may be read or
 written by any instruction.  \index{RAM}\index{ROM}\index{unavailable}
 \index{memory}\index{protection}\index{binary tree}

 `readp' is a function of three arguments, {\it{x\/}}, {\it{map\/}}, and {\it{n\/}}.  {\it{map\/}} should
 be a memory protection binary tree.  {\it{x\/}} should be a natural number.  {\it{n\/}} is
 the index of the `next bit' to select upon in {\it{x\/}} while walking the {\it{x\/}} path
 through {\it{map\/}}.  Typically `readp' is called with {\it{n\/}} initially equal to 32
 and {\it{map\/}} equal to the current memory protection map.  `readp' returns
 {\bf{f}} if it encounters an {\tt{'}}{\tt{unavailable}} at a node on the {\it{x\/}} path through
 {\it{map\/}} (considering only the least {\it{n\/}} significant bits of {\it{x\/}}), and otherwise
 {\it{readp\/}} returns {\bf{t}} .
\begin{tabbing}{\sc Definition}:\index{readp} \\  
\=\+{\rm{readp}}\,({\it{x\/}}, {\it{n\/}}, {\it{map\/}})\index{readp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\tt{'}}{\tt{unavailable}} $\in$ {\rm{value-field}}\,({\it{map\/}})\index{value-field}$\;\;${\bf then }{\bf{f}} \\ 
{\bf elseif }({\it{map\/}} $\simeq\;${{\bf{nil}}}${}$) $\vee$ ({\it{n\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\bf{t}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{readp}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{map\/}})\index{branch0})\index{readp} \\ 
{\bf else }{\rm{readp}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{map\/}})\index{branch1})\index{readp}$\;${\bf  endif}\-\-
\end{tabbing}

 In our specification, programs can only be stored in ROM.  The function
 `pc-readp' returns {\bf{t}} only when it hits a {\tt{'}}{\tt{rom}} at a node on the path {\it{x\/}}
 through {\it{map\/}} and only if there is no {\tt{'}}{\tt{unavailable}} at each node on the
 path {\it{x\/}}.  {\it{n\/}} serves the same role it does in `readp', as an index into
 {\it{x\/}}.
\begin{tabbing}{\sc Definition}:\index{pc-readp} \\  
\=\+{\rm{pc-readp}}\,({\it{x\/}}, {\it{n\/}}, {\it{map\/}})\index{pc-readp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\tt{'}}{\tt{unavailable}} $\in$ {\rm{value-field}}\,({\it{map\/}})\index{value-field}$\;\;${\bf then }{\bf{f}} \\ 
{\bf elseif }{\tt{'}}{\tt{rom}} $\in$ {\rm{value-field}}\,({\it{map\/}})\index{value-field}$\;\;${\bf then }{\rm{readp}}\,({\it{x\/}}, {\it{n\/}}, {\it{map\/}})\index{readp} \\ 
{\bf elseif }({\it{map\/}} $\simeq\;${{\bf{nil}}}${}$) $\vee$ ({\it{n\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\bf{f}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{pc-readp}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{map\/}})\index{branch0})\index{pc-readp} \\ 
{\bf else }{\rm{pc-readp}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{map\/}})\index{branch1})\index{pc-readp}$\;${\bf  endif}\-\-
\end{tabbing}

 `writep' is a function of three arguments, {\it{x\/}}, {\it{n\/}}, and {\it{map\/}}.  `map'
 should be a memory protection binary tree.  {\it{x\/}} should be a natural number.
 `writep' returns {\bf{t}} if it never encounters {\tt{'}}{\tt{unavailable}} or {\tt{'}}{\tt{rom}} at a
 node on the path {\it{x\/}} through {\it{map\/}}, otherwise {\bf{f}} .  {\it{n\/}} serves the same role
 it does in `readp', as an index into {\it{x\/}}.
\begin{tabbing}{\sc Definition}:\index{writep} \\  
\=\+{\rm{writep}}\,({\it{x\/}}, {\it{n\/}}, {\it{map\/}})\index{writep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }\=\+({\tt{'}}{\tt{unavailable}} $\in$ {\rm{value-field}}\,({\it{map\/}})\index{value-field}) \\ 
$\vee$$\;\;\;\;$({\tt{'}}{\tt{rom}} $\in$ {\rm{value-field}}\,({\it{map\/}})\index{value-field})\-$\;\;${\bf then }{\bf{f}} \\ 
{\bf elseif }({\it{map\/}} $\simeq\;${{\bf{nil}}}${}$) $\vee$ ({\it{n\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\bf{t}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{writep}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{map\/}})\index{branch0})\index{writep} \\ 
{\bf else }{\rm{writep}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{map\/}})\index{branch1})\index{writep}$\;${\bf  endif}\-\-
\end{tabbing}

 `read' is a function of three arguments, {\it{x\/}}, {\it{n\/}}, and {\it{bt\/}}.  {\it{bt\/}} should be
 a binary tree, {\it{x\/}} and {\it{n\/}} should be natural numbers.  `read' returns the
 value component at the node reached by taking the path {\it{x\/}} through {\it{bt\/}}. {\it{n\/}}
 serves the same role it does in `readp', as an index into {\it{x\/}}.

\begin{tabbing}{\sc Definition}:\index{read} \\  
\=\+{\rm{read}}\,({\it{x\/}}, {\it{n\/}}, {\it{bt\/}})\index{read} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{value-field}}\,({\it{bt\/}})\index{value-field} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{read}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{bt\/}})\index{branch0})\index{read} \\ 
{\bf else }{\rm{read}}\,({\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{bt\/}})\index{branch1})\index{read}$\;${\bf  endif}\-\-
\end{tabbing}

 `pc-read' acts the same as read. But it is used in a  quite different
 sense.  So we introduce this dummy function.
\begin{tabbing}{\sc Definition}:\index{pc-read}$\;\;$
{\rm{pc-read}}\,({\it{x\/}}, {\it{n\/}}, {\it{bt\/}})\index{pc-read} $=$ {\rm{read}}\,({\it{x\/}}, {\it{n\/}}, {\it{bt\/}})\index{read}
\end{tabbing}

 `write' is a function of four arguments, {\it{value\/}}, {\it{x\/}}, {\it{n\/}}, and {\it{bt\/}}.
 {\it{value\/}}, {\it{x\/}}, and {\it{n\/}} should be nonnegative integers, and {\it{bt\/}} should be a
 binary tree.  `write' returns the binary tree obtained by updating {\it{bt\/}} at
 the address {\it{x\/}}.  {\it{n\/}} serves the same role it does in `readp', as an index
 into {\it{x\/}}.

\begin{tabbing}{\sc Definition}:\index{write} \\  
\=\+{\rm{write}}\,({\it{value\/}}, {\it{x\/}}, {\it{n\/}}, {\it{bt\/}})\index{write} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{make-bt}}\,({\it{value\/}}, {\rm{branch0}}\,({\it{bt\/}})\index{branch0}, {\rm{branch1}}\,({\it{bt\/}})\index{branch1})\index{make-bt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{make-bt}}\,(\=\+{\rm{value-field}}\,({\it{bt\/}})\index{value-field}, \\ 
{\rm{write}}\,({\it{value\/}}, {\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{bt\/}})\index{branch0})\index{write}, \\ 
{\rm{branch1}}\,({\it{bt\/}})\index{branch1})\-\index{make-bt} \\ 
{\bf else }{\rm{make-bt}}\,(\=\+{\rm{value-field}}\,({\it{bt\/}})\index{value-field}, \\ 
{\rm{branch0}}\,({\it{bt\/}})\index{branch0}, \\ 
{\rm{write}}\,({\it{value\/}}, {\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{bt\/}})\index{branch1})\index{write})\-\index{make-bt}$\;${\bf  endif}\-\-
\end{tabbing}

 `get-nth' is a function of two arguments.  The first should be a
 nonnegative integer and the second should be a list.  `get-nth'
 returns the $n^{\rm{th}}$ element of {\it{lst\/}}.  Indexing is 0-based.
 For example, {\rm{get-nth}}\,({\tt{0}}, {\rm{list}}\,({\it{a\/}}, {\it{b\/}}, {\it{c\/}}))\index{get-nth} $=$$\;${\it{a\/}}.
\begin{tabbing}{\sc Definition}:\index{get-nth} \\  
\=\+{\rm{get-nth}}\,({\it{n\/}}, {\it{lst\/}})\index{get-nth} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{car}}\,({\it{lst\/}}) \\ 
{\bf else }{\rm{get-nth}}\,({\it{n\/}} $-\;1$, {\rm{cdr}}\,({\it{lst\/}}))\index{get-nth}$\;${\bf  endif}\-\-
\end{tabbing}

 `put-nth' is a function of three arguments: {\it{value\/}}, {\it{n\/}}, and {\it{lst\/}}.
 {\it{value\/}} and {\it{n\/}} should be natural numbers, and {\it{lst\/}} should be
 a list.  `put-nth' returns a list like {\it{lst\/}} except that the $n^{\rm th}$
 element has been changed to be {\it{value\/}}.  Indexing is 0-based,
 e.g., {\rm{put-nth}}\,({\it{d\/}}, {\tt{1}}, {\rm{list}}\,({\it{a\/}}, {\it{b\/}}, {\it{c\/}}))\index{put-nth} $=$$\;${\rm{list}}\,({\it{a\/}}, {\it{d\/}}, {\it{c\/}}).
\begin{tabbing}{\sc Definition}:\index{put-nth} \\  
\=\+{\rm{put-nth}}\,({\it{value\/}}, {\it{n\/}}, {\it{lst\/}})\index{put-nth} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{cons}}\,({\it{value\/}}, {\rm{cdr}}\,({\it{lst\/}})) \\ 
{\bf else }{\rm{cons}}\,({\rm{car}}\,({\it{lst\/}}), {\rm{put-nth}}\,({\it{value\/}}, {\it{n\/}} $-\;1$, {\rm{cdr}}\,({\it{lst\/}}))\index{put-nth})$\;${\bf  endif}\-\-
\end{tabbing}

 The size of the operand, given the operation length.
\begin{tabbing}{\sc Definition}:\index{op-sz}$\;\;$
{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz} $=$ ({\it{oplen\/}} $\div$ {\sc{b}}\index{b})
\end{tabbing}

 `read-rn' and `write-rn' are two functions used to fetch and modify
 the register {\it{rn\/}} in the register file {\it{regs\/}}.
\begin{tabbing}{\sc Definition}:\index{read-rn} \\  
{\rm{read-rn}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{regs\/}})\index{read-rn} $=$ {\rm{head}}\,({\rm{get-nth}}\,({\it{rn\/}}, {\it{regs\/}})\index{get-nth}, {\it{oplen\/}})\index{head}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{write-rn} \\  
\=\+{\rm{write-rn}}\,({\it{oplen\/}}, {\it{value\/}}, {\it{rn\/}}, {\it{regs\/}})\index{write-rn} \\ 
$=$$\;\;\;\;${\rm{put-nth}}\,({\rm{replace}}\,({\it{oplen\/}}, {\it{value\/}}, {\rm{get-nth}}\,({\it{rn\/}}, {\it{regs\/}})\index{get-nth})\index{replace}, {\it{rn\/}}, {\it{regs\/}})\index{put-nth}\-
\end{tabbing}

 A machine state is defined to be a list of length 5, say ({\it{status\/}} {\it{regs\/}} {\it{pc\/}} {\it{ccr\/}}
 {\it{mem\/}}), whose components have the following purposes: {\it{status\/}}, if it is not
 {\tt{'}}{\tt{running}}, is the reason that execution was stopped; {\it{regs\/}} holds the data
 registers and the address registers; {\it{pc\/}} is the program counter; {\it{ccr\/}} is the
 16-bit condition code register; and {\it{mem\/}} is the memory, including protection information.
 The status field is
 set when we encounter an instruction which we do not choose to handle for
 some reason.  Among the many reasons that might arise for setting the
 status field are (1) an illegal instruction, (2) a legal MC68020 instruction (e.g., CALLM)
 that this specification does not handle, and (3) an illegal addressing mode.  To construct a
 state one uses the 5 argument function `mc-state', giving it as arguments, in
 order, the halt-reason, the data and address registers, the pc, the ccr, and
 the memory.  The five fields of a state can be accessed with the five
 accessor functions `mc-status', `mc-rfile', `mc-pc', `mc-ccr', and `mc-mem'.

\begin{tabbing}{\sc Definition}:\index{mc-state} \\  
{\rm{mc-state}}\,({\it{status\/}}, {\it{regs\/}}, {\it{pc\/}}, {\it{ccr\/}}, {\it{mem\/}})\index{mc-state} $=$ {\rm{list}}\,({\it{status\/}}, {\it{regs\/}}, {\it{pc\/}}, {\it{ccr\/}}, {\it{mem\/}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mc-status}$\;\;$
{\rm{mc-status}}\,({\it{s\/}})\index{mc-status} $=$ {\rm{car}}\,({\it{s\/}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mc-rfile}$\;\;$
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile} $=$ {\rm{cadr}}\,({\it{s\/}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mc-pc}$\;\;$
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc} $=$ {\rm{head}}\,({\rm{caddr}}\,({\it{s\/}}), {\sc{l}}\index{l})\index{head}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mc-ccr}$\;\;$
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr} $=$ {\rm{head}}\,({\rm{cadddr}}\,({\it{s\/}}), {\sc{b}}\index{b})\index{head}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mc-mem}$\;\;$
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem} $=$ {\rm{caddddr}}\,({\it{s\/}})
\end{tabbing}

 `len' is a function of one argument, {\it{lst\/}}, which should be a proper list.
 `len' returns the length of {\it{lst\/}}, i.e., the number of elements in {\it{lst\/}}.
\begin{tabbing}{\sc Definition}:\index{len} \\  
\=\+{\rm{len}}\,({\it{lst\/}})\index{len} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{lst\/}} $\simeq\;${{\bf{nil}}}${}$$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }$1\;+$ {\rm{len}}\,({\rm{cdr}}\,({\it{lst\/}}))\index{len}$\;${\bf  endif}\-\-
\end{tabbing}

 `mc-haltp' returns {\bf{t}} if some halting condition has been satisfied.
\begin{tabbing}{\sc Definition}:\index{mc-haltp}$\;\;$
{\rm{mc-haltp}}\,({\it{s\/}})\index{mc-haltp} $=$ ({\rm{mc-status}}\,({\it{s\/}})\index{mc-status} $\not=$ {\tt{'}}{\tt{running}})
\end{tabbing}


 \section{Operands from Memory}

 Everything in this section is machine dependent.  We assume the memory
 capacity is $2^{32}$.  In our specification, the memory is a binary tree
 with depth 32.
\begin{tabbing}{\sc Definition}:\index{byte-readp}$\;\;$
{\rm{byte-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{byte-readp} $=$ {\rm{readp}}\,({\it{x\/}}, {\tt{32}}, {\rm{car}}\,({\it{mem\/}}))\index{readp}
\end{tabbing}

 `read-memp' returns {\bf{t}} if the {\it{k\/}} consecutive bytes in memory starting
 at {\it{x\/}} are readable, but returns {\bf{f}} otherwise.
\begin{tabbing}{\sc Definition}:\index{read-memp} \\  
\=\+{\rm{read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}})\index{read-memp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{t}} \\ 
{\bf else }\=\+{\rm{byte-readp}}\,({\rm{add}}\,({\tt{32}}, {\it{x\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{byte-readp} \\ 
$\wedge$$\;\;\;\;${\rm{read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}} $-\;1$)\index{read-memp}\-$\;${\bf  endif}\-\-
\end{tabbing}

 `word-readp' determines whether both bytes of the word at the memory address {\it{x\/}} are readable.
\begin{tabbing}{\sc Definition}:\index{word-readp}$\;\;$
{\rm{word-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{word-readp} $=$ {\rm{read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{wsz}}\index{wsz})\index{read-memp}
\end{tabbing}

 `long-readp' determines whether all four bytes of the longword at the memory address {\it{x\/}} are readable.
\begin{tabbing}{\sc Definition}:\index{long-readp}$\;\;$
{\rm{long-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{long-readp} $=$ {\rm{read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{lsz}}\index{lsz})\index{read-memp}
\end{tabbing}

 Programs can only be stored in ROM.  Assume that {\it{x\/}} is a pointer
 in some program segment.  `pc-read-memp' returns {\bf{t}} if the next {\it{k\/}}
 consecutive bytes are ROM.
\begin{tabbing}{\sc Definition}:\index{pc-byte-readp}$\;\;$
{\rm{pc-byte-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{pc-byte-readp} $=$ {\rm{pc-readp}}\,({\it{x\/}}, {\tt{32}}, {\rm{car}}\,({\it{mem\/}}))\index{pc-readp}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-read-memp} \\  
\=\+{\rm{pc-read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}})\index{pc-read-memp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{t}} \\ 
{\bf else }\=\+{\rm{pc-byte-readp}}\,({\rm{add}}\,({\tt{32}}, {\it{x\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{pc-byte-readp} \\ 
$\wedge$$\;\;\;\;${\rm{pc-read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}} $-\;1$)\index{pc-read-memp}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-word-readp}$\;\;$
{\rm{pc-word-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{pc-word-readp} $=$ {\rm{pc-read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{wsz}}\index{wsz})\index{pc-read-memp}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-long-readp}$\;\;$
{\rm{pc-long-readp}}\,({\it{x\/}}, {\it{mem\/}})\index{pc-long-readp} $=$ {\rm{pc-read-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{lsz}}\index{lsz})\index{pc-read-memp}
\end{tabbing}

 Read from the memory.
 `byte-read' reads a byte from the memory.
\begin{tabbing}{\sc Definition}:\index{byte-read}$\;\;$
{\rm{byte-read}}\,({\it{x\/}}, {\it{mem\/}})\index{byte-read} $=$ {\rm{head}}\,({\rm{read}}\,({\it{x\/}}, {\tt{32}}, {\rm{cdr}}\,({\it{mem\/}}))\index{read}, {\sc{b}}\index{b})\index{head}
\end{tabbing}

 Read {\it{k\/}} consecutive bytes from the memory at {\it{x\/}} to form a natural number.
 `read-mem' is a function of three arguments, {\it{x\/}}, {\it{mem\/}}, and {\it{k\/}}.  
 `read-mem'
 returns the natural number obtained by `appending' together the {\it{n\/}} bytes
 that are obtained by reading from {\it{mem\/}} at locations {\it{addr\/}}, \ldots, 
 $addr+n-1$.  The most significant byte is the one with the lowest
 memory address, and conversely, the least significant byte is the
 one with the highest memory address.  This is known as the `Big Endian'
 scheme of memory.\index{Big Endian} \index{Endian} \index{reading memory}
\begin{tabbing}{\sc Definition}:\index{read-mem} \\  
\=\+{\rm{read-mem}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}})\index{read-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }{\rm{app}}\,(\=\+{\sc{b}}\index{b}, \\ 
{\rm{byte-read}}\,({\rm{add}}\,({\tt{32}}, {\it{x\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{byte-read}, \\ 
{\rm{read-mem}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}} $-\;1$)\index{read-mem})\-\index{app}$\;${\bf  endif}\-\-
\end{tabbing}

 The two functions `word-read' and `long-read' use the function
 `read-mem' to obtain a word or a long word from the memory.
\begin{tabbing}{\sc Definition}:\index{word-read}$\;\;$
{\rm{word-read}}\,({\it{x\/}}, {\it{mem\/}})\index{word-read} $=$ {\rm{read-mem}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{wsz}}\index{wsz})\index{read-mem}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{long-read}$\;\;$
{\rm{long-read}}\,({\it{x\/}}, {\it{mem\/}})\index{long-read} $=$ {\rm{read-mem}}\,({\it{x\/}}, {\it{mem\/}}, {\sc{lsz}}\index{lsz})\index{read-mem}
\end{tabbing}

 Fetch instructions, by fetching bytes pointed to by the pc.  This is
 the same as reading from memory.  But we define a separate set of functions
 because we use them in a very different sense in our specification.
 `pc-byte-read' reads a byte from the memory at pc.
\begin{tabbing}{\sc Definition}:\index{pc-byte-read} \\  
{\rm{pc-byte-read}}\,({\it{pc\/}}, {\it{mem\/}})\index{pc-byte-read} $=$ {\rm{head}}\,({\rm{pc-read}}\,({\it{pc\/}}, {\tt{32}}, {\rm{cdr}}\,({\it{mem\/}}))\index{pc-read}, {\sc{b}}\index{b})\index{head}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-read-mem} \\  
\=\+{\rm{pc-read-mem}}\,({\it{pc\/}}, {\it{mem\/}}, {\it{k\/}})\index{pc-read-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }{\rm{app}}\,(\=\+{\sc{b}}\index{b}, \\ 
{\rm{pc-byte-read}}\,({\rm{add}}\,({\tt{32}}, {\it{pc\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{pc-byte-read}, \\ 
{\rm{pc-read-mem}}\,({\it{pc\/}}, {\it{mem\/}}, {\it{k\/}} $-\;1$)\index{pc-read-mem})\-\index{app}$\;${\bf  endif}\-\-
\end{tabbing}

 `pc-word-read' reads a word from the memory at pc.
\begin{tabbing}{\sc Definition}:\index{pc-word-read}$\;\;$
{\rm{pc-word-read}}\,({\it{pc\/}}, {\it{mem\/}})\index{pc-word-read} $=$ {\rm{pc-read-mem}}\,({\it{pc\/}}, {\it{mem\/}}, {\sc{wsz}}\index{wsz})\index{pc-read-mem}
\end{tabbing}

 `pc-long-read' reads a longword from the memory at pc.
\begin{tabbing}{\sc Definition}:\index{pc-long-read}$\;\;$
{\rm{pc-long-read}}\,({\it{pc\/}}, {\it{mem\/}})\index{pc-long-read} $=$ {\rm{pc-read-mem}}\,({\it{pc\/}}, {\it{mem\/}}, {\sc{lsz}}\index{lsz})\index{pc-read-mem}
\end{tabbing}

 We define some bit field extractors.  The function names reflect the
 meanings of the fields for MC68020 instructions.

 The source register field.  `s\_rn' is a function of one argument, {\it{ins\/}},
 which should be a word, i.e., a 16-bit bit-vector.
 Nonnegative integer value of bits 0..2 of ins.
\begin{tabbing}{\sc Definition}:\index{s\_rn}$\;\;$
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{0}}, {\tt{2}})\index{bits}
\end{tabbing}

 The source mode field.  Integer value of bits 3..5 of ins.
\begin{tabbing}{\sc Definition}:\index{s\_mode}$\;\;$
{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{3}}, {\tt{5}})\index{bits}
\end{tabbing}

 The destination mode field.  Integer value of bits 6..8 of ins.
\begin{tabbing}{\sc Definition}:\index{d\_mode}$\;\;$
{\rm{d\_mode}}\,({\it{ins\/}})\index{d\_mode} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{6}}, {\tt{8}})\index{bits}
\end{tabbing}

 The destination register field.  Integer value of bits 9..11 of ins.
\begin{tabbing}{\sc Definition}:\index{d\_rn}$\;\;$
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{9}}, {\tt{11}})\index{bits}
\end{tabbing}

 The op-mode field.  Integer value of bits 6..8 of ins.
\begin{tabbing}{\sc Definition}:\index{opmode-field}$\;\;$
{\rm{opmode-field}}\,({\it{ins\/}})\index{opmode-field} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{6}}, {\tt{8}})\index{bits}
\end{tabbing}

 The condition field.  Integer value of bits 8..11 of ins.
\begin{tabbing}{\sc Definition}:\index{cond-field}$\;\;$
{\rm{cond-field}}\,({\it{ins\/}})\index{cond-field} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{8}}, {\tt{11}})\index{bits}
\end{tabbing}

 By the ``oplen'' of an instruction we mean whether an instruction
 deals with a byte, word, long word, or quad word operation.

 The oplen of the operation is normally determined by bits 6 and 7.
 `op-len' is a function of one argument, {\it{ins\/}}, which normally is the
 first word of an instruction.

 \begin{tabular}{ll}
  67 & (common bit numbers)  \\
  00 & byte \\
  10 & word \\
  01 & long word \\
  11 & illegal, but we return (qsz).
 \end{tabular}
 
\begin{tabbing}{\sc Definition}:\index{op-len}$\;\;$
{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ ({\sc{b}}\index{b} $*$ {\rm{exp}}\,({\tt{2}}, {\rm{bits}}\,({\it{ins\/}}, {\tt{6}}, {\tt{7}})\index{bits})\index{exp})
\end{tabbing}

 \section{Storing the Result}

 `byte-writep' determines whether the location {\it{x\/}} is writable with respect to the current memory.
\begin{tabbing}{\sc Definition}:\index{byte-writep}$\;\;$
{\rm{byte-writep}}\,({\it{x\/}}, {\it{mem\/}})\index{byte-writep} $=$ {\rm{writep}}\,({\it{x\/}}, {\tt{32}}, {\rm{car}}\,({\it{mem\/}}))\index{writep}
\end{tabbing}

 `write-memp' determines whether the k consecutive bytes starting at address x in the memory are writable.
\begin{tabbing}{\sc Definition}:\index{write-memp} \\  
\=\+{\rm{write-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}})\index{write-memp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{t}} \\ 
{\bf else }\=\+{\rm{byte-writep}}\,({\rm{add}}\,({\tt{32}}, {\it{x\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{byte-writep} \\ 
$\wedge$$\;\;\;\;${\rm{write-memp}}\,({\it{x\/}}, {\it{mem\/}}, {\it{k\/}} $-\;1$)\index{write-memp}\-$\;${\bf  endif}\-\-
\end{tabbing}
  
 `write-mem' is a function of four arguments, {\it{value\/}}, {\it{x\/}}, {\it{mem\/}}, and {\it{k\/}}.
 {\it{value\/}} should be a natural number, namely the thing we are storing;
 {\it{x\/}} should be a natural number, namely the address at which to store
 {\it{value\/}};  {\it{mem\/}} is the memory;  {\it{k\/}} is the number of bytes to store.  We
 store the bytes one byte at a time, storing the most significant
 byte of {\it{value\/}} first, at location {\it{x\/}}, and storing subsequently,
 decreasingly significant bytes at increasing addresses.
\begin{tabbing}{\sc Definition}:\index{byte-write} \\  
\=\+{\rm{byte-write}}\,({\it{value\/}}, {\it{x\/}}, {\it{mem\/}})\index{byte-write} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{car}}\,({\it{mem\/}}), {\rm{write}}\,({\rm{head}}\,({\it{value\/}}, {\sc{b}}\index{b})\index{head}, {\it{x\/}}, {\tt{32}}, {\rm{cdr}}\,({\it{mem\/}}))\index{write})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{write-mem} \\  
\=\+{\rm{write-mem}}\,({\it{value\/}}, {\it{x\/}}, {\it{mem\/}}, {\it{k\/}})\index{write-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{k\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\it{mem\/}} \\ 
{\bf else }{\rm{write-mem}}\,(\=\+{\rm{tail}}\,({\it{value\/}}, {\sc{b}}\index{b})\index{tail}, \\ 
{\it{x\/}}, \\ 
{\rm{byte-write}}\,({\it{value\/}}, {\rm{add}}\,({\tt{32}}, {\it{x\/}}, {\it{k\/}} $-\;1$)\index{add}, {\it{mem\/}})\index{byte-write}, \\ 
{\it{k\/}} $-\;1$)\-\index{write-mem}$\;${\bf  endif}\-\-
\end{tabbing}

 Obtain c, v, z, n, and x from CCR.  The following five functions `ccr-c',
 `ccr-v', `ccr-z', `ccr-n', and `ccr-x' simply access the five
 correspondingly named bits of the CCR.  We use them to
 specify the condition cc in the bcc instruction.
\begin{tabbing}{\sc Definition}:\index{ccr-c}$\;\;$
{\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c} $=$ {\rm{bitn}}\,({\it{ccr\/}}, {\tt{0}})\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ccr-v}$\;\;$
{\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v} $=$ {\rm{bitn}}\,({\it{ccr\/}}, {\tt{1}})\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ccr-z}$\;\;$
{\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z} $=$ {\rm{bitn}}\,({\it{ccr\/}}, {\tt{2}})\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ccr-n}$\;\;$
{\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n} $=$ {\rm{bitn}}\,({\it{ccr\/}}, {\tt{3}})\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ccr-x}$\;\;$
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x} $=$ {\rm{bitn}}\,({\it{ccr\/}}, {\tt{4}})\index{bitn}
\end{tabbing}

 Whenever instructions update the CCR, `cvznx' simply generates a new partial
 CCR consisting of the new cvznx-flags.
\begin{tabbing}{\sc Definition}:\index{cvznx} \\  
\=\+{\rm{cvznx}}\,({\it{c\/}}, {\it{v\/}}, {\it{z\/}}, {\it{n\/}}, {\it{x\/}})\index{cvznx} \\ 
$=$$\;\;\;\;$(\=\+{\rm{fix-bit}}\,({\it{c\/}})\index{fix-bit} \\ 
$+$$\;\;\;\;$(\=\+({\tt{2}} $*$ {\rm{fix-bit}}\,({\it{v\/}})\index{fix-bit}) \\ 
$+$$\;\;\;\;$(\=\+({\tt{4}} $*$ {\rm{fix-bit}}\,({\it{z\/}})\index{fix-bit}) \\ 
$+$$\;\;\;\;$(({\tt{8}} $*$ {\rm{fix-bit}}\,({\it{n\/}})\index{fix-bit}) $+$ ({\tt{16}} $*$ {\rm{fix-bit}}\,({\it{x\/}})\index{fix-bit})))\-)\-)\-\-
\end{tabbing}

 `set-cvznx' replaces the old flags in CCR by the given flags.
\begin{tabbing}{\sc Definition}:\index{set-cvznx}$\;\;$
{\rm{set-cvznx}}\,({\it{cvznx\/}}, {\it{ccr\/}})\index{set-cvznx} $=$ {\rm{replace}}\,({\tt{5}}, {\it{cvznx\/}}, {\it{ccr\/}})\index{replace}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{set-c} \\  
\=\+{\rm{set-c}}\,({\it{c\/}}, {\it{ccr\/}})\index{set-c} \\ 
$=$$\;\;\;\;${\rm{set-cvznx}}\,({\rm{cvznx}}\,({\it{c\/}}, {\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}, {\it{ccr\/}})\index{set-cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{set-v} \\  
\=\+{\rm{set-v}}\,({\it{v\/}}, {\it{ccr\/}})\index{set-v} \\ 
$=$$\;\;\;\;${\rm{set-cvznx}}\,({\rm{cvznx}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\it{v\/}}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}, {\it{ccr\/}})\index{set-cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{set-z} \\  
\=\+{\rm{set-z}}\,({\it{z\/}}, {\it{ccr\/}})\index{set-z} \\ 
$=$$\;\;\;\;${\rm{set-cvznx}}\,({\rm{cvznx}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\it{z\/}}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}, {\it{ccr\/}})\index{set-cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{set-n} \\  
\=\+{\rm{set-n}}\,({\it{n\/}}, {\it{ccr\/}})\index{set-n} \\ 
$=$$\;\;\;\;${\rm{set-cvznx}}\,({\rm{cvznx}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\it{n\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}, {\it{ccr\/}})\index{set-cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{set-x} \\  
\=\+{\rm{set-x}}\,({\it{x\/}}, {\it{ccr\/}})\index{set-x} \\ 
$=$$\;\;\;\;${\rm{set-cvznx}}\,({\rm{cvznx}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n}, {\it{x\/}})\index{cvznx}, {\it{ccr\/}})\index{set-cvznx}\-
\end{tabbing}

 To halt the machine, we simply put the halting reason ``signal'' in
 the machine state.
\begin{tabbing}{\sc Definition}:\index{halt} \\  
\=\+{\rm{halt}}\,({\it{signal\/}}, {\it{s\/}})\index{halt} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,({\it{signal\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{mc-state}\-
\end{tabbing}

 To update the register file in the state {\it{s\/}}.
\begin{tabbing}{\sc Definition}:\index{update-rfile} \\  
\=\+{\rm{update-rfile}}\,({\it{new-rfile\/}}, {\it{s\/}})\index{update-rfile} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,({\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, {\it{new-rfile\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{mc-state}\-
\end{tabbing}

 To update the program counter in the state {\it{s\/}}.
\begin{tabbing}{\sc Definition}:\index{update-pc} \\  
\=\+{\rm{update-pc}}\,({\it{new-pc\/}}, {\it{s\/}})\index{update-pc} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,({\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile}, {\it{new-pc\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{mc-state}\-
\end{tabbing}

 To update the condition code in the state {\it{s\/}}.
\begin{tabbing}{\sc Definition}:\index{update-ccr} \\  
\=\+{\rm{update-ccr}}\,({\it{new-ccr\/}}, {\it{s\/}})\index{update-ccr} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,(\=\+{\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, \\ 
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile}, \\ 
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, \\ 
{\rm{set-cvznx}}\,({\it{new-ccr\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-cvznx}, \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\-\index{mc-state}\-
\end{tabbing}

 To update the memory in the state {\it{s\/}}.
\begin{tabbing}{\sc Definition}:\index{update-mem} \\  
\=\+{\rm{update-mem}}\,({\it{new-mem\/}}, {\it{s\/}})\index{update-mem} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,({\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr}, {\it{new-mem\/}})\index{mc-state}\-
\end{tabbing}

 `read-dn' and `read-an' are used to fetch data and address registers in the machine state {\it{s\/}}.
\begin{tabbing}{\sc Definition}:\index{read-dn}$\;\;$
{\rm{read-dn}}\,({\it{oplen\/}}, {\it{dn\/}}, {\it{s\/}})\index{read-dn} $=$ {\rm{read-rn}}\,({\it{oplen\/}}, {\it{dn\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{read-rn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{read-an} \\  
{\rm{read-an}}\,({\it{oplen\/}}, {\it{an\/}}, {\it{s\/}})\index{read-an} $=$ {\rm{read-rn}}\,({\it{oplen\/}}, {\tt{8}} $+$ {\it{an\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{read-rn}
\end{tabbing}

 `write-dn' and `write-an' are used to modify data and address registers in the machine state {\it{s\/}}.
 They return the modified machine state.
\begin{tabbing}{\sc Definition}:\index{write-dn} \\  
\=\+{\rm{write-dn}}\,({\it{oplen\/}}, {\it{value\/}}, {\it{dn\/}}, {\it{s\/}})\index{write-dn} \\ 
$=$$\;\;\;\;${\rm{update-rfile}}\,({\rm{write-rn}}\,({\it{oplen\/}}, {\it{value\/}}, {\it{dn\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{write-rn}, {\it{s\/}})\index{update-rfile}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{write-an} \\  
\=\+{\rm{write-an}}\,({\it{oplen\/}}, {\it{value\/}}, {\it{an\/}}, {\it{s\/}})\index{write-an} \\ 
$=$$\;\;\;\;${\rm{update-rfile}}\,({\rm{write-rn}}\,({\it{oplen\/}}, {\it{value\/}}, {\tt{8}} $+$ {\it{an\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{write-rn}, {\it{s\/}})\index{update-rfile}\-
\end{tabbing}

 `sp' is the constant 7, which refers to the stack pointer sp(a7) in the 
 address register file.
\begin{tabbing}{\sc Definition}:\index{sp}$\;\;$
{\sc{sp}}\index{sp} $=$ {\tt{7}}
\end{tabbing}

 `read-sp' is a function that fetches the stack pointer in the given
 state s.
\begin{tabbing}{\sc Definition}:\index{read-sp}$\;\;$
{\rm{read-sp}}\,({\it{s\/}})\index{read-sp} $=$ {\rm{read-an}}\,({\sc{l}}\index{l}, {\sc{sp}}\index{sp}, {\it{s\/}})\index{read-an}
\end{tabbing}

 `write-sp' is a function of two arguments, {\it{value\/}} and {\it{s\/}}.  It returns
 a new machine state with the stack pointer updated to value.
\begin{tabbing}{\sc Definition}:\index{write-sp}$\;\;$
{\rm{write-sp}}\,({\it{value\/}}, {\it{s\/}})\index{write-sp} $=$ {\rm{write-an}}\,({\sc{l}}\index{l}, {\it{value\/}}, {\sc{sp}}\index{sp}, {\it{s\/}})\index{write-an}
\end{tabbing}

 `push-up' pushes {\it{value\/}} onto the sp stack and increments sp.
\begin{tabbing}{\sc Definition}:\index{push-sp} \\  
\=\+{\rm{push-sp}}\,({\it{opsz\/}}, {\it{value\/}}, {\it{s\/}})\index{push-sp} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{sp\/}}{\bf $\;$ be$\;\;$}{\rm{sub}}\,({\sc{l}}\index{l}, {\it{opsz\/}}, {\rm{read-sp}}\,({\it{s\/}})\index{read-sp})\index{sub}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{write-memp}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\it{opsz\/}})\index{write-memp} \\ 
{\bf then }{\rm{update-mem}}\,(\=\+{\rm{write-mem}}\,({\it{value\/}}, {\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\it{opsz\/}})\index{write-mem}, \\ 
{\rm{write-sp}}\,({\it{sp\/}}, {\it{s\/}})\index{write-sp})\-\index{update-mem} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 \section{Retrieving the Operand According to Oplen}

 The function `operand' returns the operand based on the given addr.
 {\it{addr\/}} should be a cons; the `car' tells us where to retrieve the operand,
 the `cdr' provides the real address.
\begin{tabbing}{\sc Definition}:\index{operand} \\  
\=\+{\rm{operand}}\,({\it{oplen\/}}, {\it{addr\/}}, {\it{s\/}})\index{operand} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{car}}\,({\it{addr\/}}) $=$ {\tt{'}}{\tt{d}}$\;\;${\bf then }{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{addr\/}}), {\it{s\/}})\index{read-dn} \\ 
{\bf elseif }{\rm{car}}\,({\it{addr\/}}) $=$ {\tt{'}}{\tt{a}}$\;\;${\bf then }{\rm{read-an}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{addr\/}}), {\it{s\/}})\index{read-an} \\ 
{\bf elseif }{\rm{car}}\,({\it{addr\/}}) $=$ {\tt{'}}{\tt{m}} \\ 
{\bf then }{\rm{read-mem}}\,({\rm{cdr}}\,({\it{addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-mem} \\ 
{\bf else }{\rm{cdr}}\,({\it{addr\/}})$\;${\bf  endif}\-\-
\end{tabbing}

 \section{Effective Address Calculation}

 We now begin the definition of a collection of functions culminating
 in the function `effec-addr', which computes ``the effective
 address'' for MC68020 instructions.  (Actually, some instructions,
 e.g., the MOVE instruction, compute two effective addresses.)

 In his Ph.~D.\ thesis, Warren Hunt specified the FM8502 microprocessor in
 the Nqthm logic \cite{m:stack}.  In Hunt's FM8502 there is only one instruction
 format.  Therefore in the FM8502 ``soft-machine'' specification one
 can compute the effective addresses before looking at the op-code.
 But in the MC68020, there are several instruction formats, and the
 algorithm for computing effective addresses depends upon what the
 op-code is.  So we cannot handle instructions as uniformly as in
 FM8502.  We have to know what the op-code is at a very early stage
 in the implementation.

 Pre-effect and post-effect are two functions used in address
 register predecrement and postincrement.
\begin{tabbing}{\sc Definition}:\index{post-effect} \\  
\=\+{\rm{post-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{post-effect} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{rn\/}} $=$ {\sc{sp}}\index{sp}) $\wedge$ ({\it{oplen\/}} $=$ {\sc{b}}\index{b})$\;\;${\bf then }{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\sc{wsz}}\index{wsz})\index{add} \\ 
{\bf else }{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{add}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pre-effect} \\  
\=\+{\rm{pre-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{pre-effect} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{rn\/}} $=$ {\sc{sp}}\index{sp}) $\wedge$ ({\it{oplen\/}} $=$ {\sc{b}}\index{b})$\;\;${\bf then }{\rm{sub}}\,({\sc{l}}\index{l}, {\sc{wsz}}\index{wsz}, {\it{addr\/}})\index{sub} \\ 
{\bf else }{\rm{sub}}\,({\sc{l}}\index{l}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz}, {\it{addr\/}})\index{sub}$\;${\bf  endif}\-\-
\end{tabbing}

 For each of the different effective addressing modes, we define a
 function that ``does the work.''  In each case, the function takes
 as its argument the current value of the state, {\it{s\/}}.  Some may
 take other parameters.  In each case a `cons' is returned, consisting
 of (a) an internal state with possible an and pc updates after the
 effective address calculation; (b) the effective address, normally
 another cons indicating where to look and where to get the operands.

 \bigskip
 Register direct modes.  Data register direct (000) and address
 register direct (001).
 Number of extension words: 0.

 `dn-direct' is a function of two arguments, {\it{rn\/}} and {\it{s\/}}.  {\it{rn\/}} should be
 a natural number and {\it{s\/}} should be an mc-state.  Mode 000.
\begin{tabbing}{\sc Definition}:\index{dn-direct}$\;\;$
{\rm{dn-direct}}\,({\it{rn\/}}, {\it{s\/}})\index{dn-direct} $=$ {\rm{cons}}\,({\it{s\/}}, {\rm{cons}}\,({\tt{'}}{\tt{d}}, {\it{rn\/}}))
\end{tabbing}

 `an-direct' is a function of two arguments, {\it{rn\/}} and {\it{s\/}}.  {\it{rn\/}} should be
 a natural number and {\it{s\/}} should be an mc-state.  Mode 001.
\begin{tabbing}{\sc Definition}:\index{an-direct}$\;\;$
{\rm{an-direct}}\,({\it{rn\/}}, {\it{s\/}})\index{an-direct} $=$ {\rm{cons}}\,({\it{s\/}}, {\rm{cons}}\,({\tt{'}}{\tt{a}}, {\it{rn\/}}))
\end{tabbing}

 Memory address modes.
 The pc argument to these effective address subroutines need not be
 the actual pc of the instruction.  In the case of the MOVE instruction,
 which involves two effective address calculations, the pc will point
 to the word before the ``next'' possible byte in the
 memory which is to be used as an extension word.  For example, the
 instruction
   \begin{quotation}i:    move (1,a0) (2,a2)\end{quotation}
 i.e., move the word at 1 + (a0) to 2 + (a2), requires altogether 3
 words because two extension words are required, one for each of the
 displacements (1 and 2).  When we invoke the function `addr-disp' for
 the calculation of the first effective address, the pc will be i.
 But when we again invoke the function `addr-disp' for the calculation
 of the second effective address, the pc will be i+2.

 A subtlety about pc displacement.  The one MC68020 instruction that
 involves two effective address calculations, the MOVE instruction,
 will have its second effective address calculation performed by us
 with the pc not pointing necessarily to the MOVE instruction but
 rather (possibly) pointing to the next word after the calculation
 of the first effective address.  However, this discrepancy does not
 cause a problem with pc relative addressing because pc relative
 addressing is prohibited in the second effective address calculation.

 \bigskip

 Address register indirect, mode 010.
 Number of extension words: 0.
 `addr-indirect' is a function of two arguments, {\it{rn\/}} and {\it{s\/}}.  {\it{rn\/}} should
 be a natural number and {\it{s\/}} should be a machine state.  It returns the
 contents of the {\it{rn\/}} element of the address register file.
\begin{tabbing}{\sc Definition}:\index{addr-indirect} \\  
{\rm{addr-indirect}}\,({\it{rn\/}}, {\it{s\/}})\index{addr-indirect} $=$ {\rm{cons}}\,({\it{s\/}}, {\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}))
\end{tabbing}

 Address register indirect with postincrement, mode 011.
 Number of extension words: 0.
\begin{tabbing}{\sc Definition}:\index{addr-postinc} \\  
\=\+{\rm{addr-postinc}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-postinc} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{addr\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
{\rm{cons}}\,(\=\+{\rm{write-an}}\,({\sc{l}}\index{l}, {\rm{post-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{post-effect}, {\it{rn\/}}, {\it{s\/}})\index{write-an}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\it{addr\/}}))\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Address register indirect with predecrement, mode 100.
 Number of extension words: 0.
 The function `addr-predec' returns a cons of the given state {\it{s\/}} and
 the contents of the {\it{rn\/}} element of the register file after
 the register has been predecremented.
\begin{tabbing}{\sc Definition}:\index{addr-predec} \\  
\=\+{\rm{addr-predec}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-predec} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{addr\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
{\rm{cons}}\,(\=\+{\rm{write-an}}\,({\sc{l}}\index{l}, {\rm{pre-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{pre-effect}, {\it{rn\/}}, {\it{s\/}})\index{write-an}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{pre-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{pre-effect}))\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Address register indirect with index, mode 101.
 Number of extension words: 1.
 We now begin handling an effective address calculation which involves
 an extension word.  In this mode, we add in the sign-extended 16-bit
 quantity in the word after the pc.  We return a cons with (a) the
 state with pc incremented and (b) the sum of the address register {\it{rn\/}}
 and the sign-extended contents of the next word.
\begin{tabbing}{\sc Definition}:\index{addr-disp} \\  
\=\+{\rm{addr-disp}}\,({\it{pc\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-disp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,(\=\+{\tt{'}}{\tt{m}}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}, \\ 
{\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext})\-\index{add})\-)\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Address register indirect with index (8-bit displacement), mode 110.
 Number of extension words: 1.
\begin{tabbing}{\sc Definition}:\index{index-rn}$\;\;$
{\rm{index-rn}}\,({\it{indexwd\/}})\index{index-rn} $=$ {\rm{bits}}\,({\it{indexwd\/}}, {\tt{12}}, {\tt{14}})\index{bits}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{index-register} \\  
\=\+{\rm{index-register}}\,({\it{indexwd\/}}, {\it{s\/}})\index{index-register} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{15}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{ext}}\,({\sc{w}}\index{w}, {\rm{read-dn}}\,({\sc{w}}\index{w}, {\rm{index-rn}}\,({\it{indexwd\/}})\index{index-rn}, {\it{s\/}})\index{read-dn}, {\sc{l}}\index{l})\index{ext} \\ 
{\bf else }{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{index-rn}}\,({\it{indexwd\/}})\index{index-rn}, {\it{s\/}})\index{read-dn}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{ext}}\,({\sc{w}}\index{w}, {\rm{read-an}}\,({\sc{w}}\index{w}, {\rm{index-rn}}\,({\it{indexwd\/}})\index{index-rn}, {\it{s\/}})\index{read-an}, {\sc{l}}\index{l})\index{ext} \\ 
{\bf else }{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{index-rn}}\,({\it{indexwd\/}})\index{index-rn}, {\it{s\/}})\index{read-an}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ir-scaled} \\  
\=\+{\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled} \\ 
$=$$\;\;\;\;${\rm{asl}}\,({\sc{l}}\index{l}, {\rm{index-register}}\,({\it{indexwd\/}}, {\it{s\/}})\index{index-register}, {\rm{bits}}\,({\it{indexwd\/}}, {\tt{9}}, {\tt{10}})\index{bits})\index{asl}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addr-index-disp} \\  
\=\+{\rm{addr-index-disp}}\,({\it{pc\/}}, {\it{rn\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index-disp} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\it{pc\/}}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,(\=\+{\tt{'}}{\tt{m}}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}, {\rm{ext}}\,({\sc{b}}\index{b}, {\rm{head}}\,({\it{indexwd\/}}, {\sc{b}}\index{b})\index{head}, {\sc{l}}\index{l})\index{ext})\index{add}, \\ 
{\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled})\-\index{add})\-)\-\-
\end{tabbing}

 Address register indirect with index (base displacement), mode 110.
 Number of extension words: 1, 2, or 3.
\begin{tabbing}{\sc Definition}:\index{addr-index-bd} \\  
\=\+{\rm{addr-index-bd}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index-bd} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{update-pc}}\,({\it{pc\/}}, {\it{s\/}})\index{update-pc}, {\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled})\index{add}))\-
\end{tabbing}

 Memory indirect without index, mode 110.
 Number of extension words: 1, 2, 3, 4, or 5.
\begin{tabbing}{\sc Definition}:\index{mem-indirect} \\  
\=\+{\rm{mem-indirect}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{olen\/}}, {\it{s\/}})\index{mem-indirect} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{long-readp}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-read-memp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{pc-read-memp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,(\=\+{\tt{'}}{\tt{m}}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{long-read}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-read}, \\ 
{\rm{ext}}\,(\=\+{\it{olen\/}}, \\ 
{\rm{pc-read-mem}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{pc-read-mem}, \\ 
{\sc{l}}\index{l})\-\index{ext})\-\index{add})\-)\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Memory indirect postindexed mode.
\begin{tabbing}{\sc Definition}:\index{mem-postindex} \\  
\=\+{\rm{mem-postindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{olen\/}}, {\it{s\/}})\index{mem-postindex} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{long-readp}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-read-memp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{pc-read-memp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,(\=\+{\tt{'}}{\tt{m}}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{long-read}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-read}, \\ 
{\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled})\-\index{add}, \\ 
{\rm{ext}}\,(\=\+{\it{olen\/}}, \\ 
{\rm{pc-read-mem}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{olen\/}})\index{op-sz})\index{pc-read-mem}, \\ 
{\sc{l}}\index{l})\-\index{ext})\-\index{add})\-)\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Memory indirect preindexed mode.
\begin{tabbing}{\sc Definition}:\index{mem-preindex} \\  
\=\+{\rm{mem-preindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{olen\/}}, {\it{s\/}})\index{mem-preindex} \\ 
$=$$\;\;\;\;${\rm{mem-indirect}}\,({\it{pc\/}}, {\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled})\index{add}, {\it{olen\/}}, {\it{s\/}})\index{mem-indirect}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{i-is}$\;\;$
{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\rm{bits}}\,({\it{indexwd\/}}, {\tt{0}}, {\tt{2}})\index{bits}
\end{tabbing}

 The base displacement has been added to {\it{addr\/}}, if necessary.  `addr-index3'
 is to consider the index register and index/indirect selection.
\begin{tabbing}{\sc Definition}:\index{addr-index3} \\  
\=\+{\rm{addr-index3}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index3} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{6}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{0}} \\ 
{\bf then }{\rm{addr-index-bd}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index-bd} \\ 
{\bf else }{\rm{mem-preindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\tt{0}}, {\it{s\/}})\index{mem-preindex}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{2}} \\ 
{\bf then }{\rm{mem-preindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\sc{w}}\index{w}, {\it{s\/}})\index{mem-preindex} \\ 
{\bf else }{\rm{mem-preindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\sc{l}}\index{l}, {\it{s\/}})\index{mem-preindex}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $<$ {\tt{6}} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{4}} \\ 
{\bf then }{\rm{cons}}\,({\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}, {\bf{nil}}) \\ 
{\bf else }{\rm{mem-postindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\tt{0}}, {\it{s\/}})\index{mem-postindex}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{6}} \\ 
{\bf then }{\rm{mem-postindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\sc{w}}\index{w}, {\it{s\/}})\index{mem-postindex} \\ 
{\bf else }{\rm{mem-postindex}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\sc{l}}\index{l}, {\it{s\/}})\index{mem-postindex}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{0}} \\ 
{\bf then }{\rm{cons}}\,({\rm{update-pc}}\,({\it{pc\/}}, {\it{s\/}})\index{update-pc}, {\rm{cons}}\,({\tt{'}}{\tt{m}}, {\it{addr\/}})) \\ 
{\bf else }{\rm{mem-indirect}}\,({\it{pc\/}}, {\it{addr\/}}, {\tt{0}}, {\it{s\/}})\index{mem-indirect}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{i-is}}\,({\it{indexwd\/}})\index{i-is} $=$ {\tt{2}}$\;\;${\bf then }{\rm{mem-indirect}}\,({\it{pc\/}}, {\it{addr\/}}, {\sc{w}}\index{w}, {\it{s\/}})\index{mem-indirect} \\ 
{\bf else }{\rm{mem-indirect}}\,({\it{pc\/}}, {\it{addr\/}}, {\sc{l}}\index{l}, {\it{s\/}})\index{mem-indirect}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bd-sz}$\;\;$
{\rm{bd-sz}}\,({\it{indexwd\/}})\index{bd-sz} $=$ {\rm{bits}}\,({\it{indexwd\/}}, {\tt{4}}, {\tt{5}})\index{bits}
\end{tabbing}

 The address register (base register) has been added to addr, if necessary.
 `addr-index2' is to consider the base displacement.
\begin{tabbing}{\sc Definition}:\index{addr-index2} \\  
\=\+{\rm{addr-index2}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index2} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{bd-sz}}\,({\it{indexwd\/}})\index{bd-sz} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\rm{bd-sz}}\,({\it{indexwd\/}})\index{bd-sz} $=$ {\tt{0}}$\;\;${\bf then }{\rm{cons}}\,({\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}, {\bf{nil}}) \\ 
{\bf else }{\rm{addr-index3}}\,({\it{pc\/}}, {\it{addr\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index3}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{bd-sz}}\,({\it{indexwd\/}})\index{bd-sz} $=$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{addr-index3}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext})\index{add}, \\ 
{\it{indexwd\/}}, \\ 
{\it{s\/}})\-\index{addr-index3} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{pc-long-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-readp} \\ 
{\bf then }{\rm{addr-index3}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{lsz}}\index{lsz})\index{add}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\rm{pc-long-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-read})\index{add}, \\ 
{\it{indexwd\/}}, \\ 
{\it{s\/}})\-\index{addr-index3} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bs-register} \\  
\=\+{\rm{bs-register}}\,({\it{rn\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{bs-register} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{7}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an} \\ 
{\bf else }{\tt{0}}$\;${\bf  endif}\-\-
\end{tabbing}

 `addr-index1' is to consider the address register (base register).
\begin{tabbing}{\sc Definition}:\index{addr-index1} \\  
\=\+{\rm{addr-index1}}\,({\it{pc\/}}, {\it{rn\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{addr-index-disp}}\,({\it{pc\/}}, {\it{rn\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index-disp} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{3}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{addr-index2}}\,({\it{pc\/}}, {\rm{bs-register}}\,({\it{rn\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{bs-register}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index2} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addr-index} \\  
\=\+{\rm{addr-index}}\,({\it{pc\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-index} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{addr-index1}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{rn\/}}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\it{s\/}})\index{addr-index1} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Absolute short address.   Mode 111, rn 000.
\begin{tabbing}{\sc Definition}:\index{absolute-short} \\  
\=\+{\rm{absolute-short}}\,({\it{pc\/}}, {\it{s\/}})\index{absolute-short} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext}))\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Absolute long address.  Mode 111, rn 001.
\begin{tabbing}{\sc Definition}:\index{absolute-long} \\  
\=\+{\rm{absolute-long}}\,({\it{pc\/}}, {\it{s\/}})\index{absolute-long} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-long-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-readp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{lsz}}\index{lsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{pc-long-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-read}))\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Surprisingly, the design of the MC68020 deliberately avoids having
 two program counter addressing modes.  This specification here
 relies on this very fact.

 Program counter indirect with displacement.  Mode 111, rn 010.
 Number of extension words: 1.
\begin{tabbing}{\sc Definition}:\index{pc-disp} \\  
\=\+{\rm{pc-disp}}\,({\it{pc\/}}, {\it{s\/}})\index{pc-disp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext})\index{add}))\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Program counter indirect with index (8-bit displacement). mode 111, rn 011.
\begin{tabbing}{\sc Definition}:\index{pc-index-disp} \\  
\=\+{\rm{pc-index-disp}}\,({\it{pc\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{pc-index-disp} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,(\=\+{\tt{'}}{\tt{m}}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\rm{ext}}\,({\sc{b}}\index{b}, {\rm{head}}\,({\it{indexwd\/}}, {\sc{b}}\index{b})\index{head}, {\sc{l}}\index{l})\index{ext})\index{add}, \\ 
{\rm{ir-scaled}}\,({\it{indexwd\/}}, {\it{s\/}})\index{ir-scaled})\-\index{add})\-)\-\-
\end{tabbing}

 \noindent Program counter indirect with index (base displacement) mode. \\
 Program counter memory indirect postindexed mode. \\
 Program counter memory indirect preindexed mode.
\begin{tabbing}{\sc Definition}:\index{bs-pc} \\  
\=\+{\rm{bs-pc}}\,({\it{pc\/}}, {\it{indexwd\/}})\index{bs-pc} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{7}})\index{bitn})\index{b0p}$\;\;${\bf then }{\it{pc\/}} \\ 
{\bf else }{\tt{0}}$\;${\bf  endif}\-\-
\end{tabbing}
 
\begin{tabbing}{\sc Definition}:\index{pc-index1} \\  
\=\+{\rm{pc-index1}}\,({\it{pc\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{pc-index1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{pc-index-disp}}\,({\it{pc\/}}, {\it{indexwd\/}}, {\it{s\/}})\index{pc-index-disp} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{indexwd\/}}, {\tt{3}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{addr-index2}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\rm{bs-pc}}\,({\it{pc\/}}, {\it{indexwd\/}})\index{bs-pc}, {\it{indexwd\/}}, {\it{s\/}})\index{addr-index2} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pc-index} \\  
\=\+{\rm{pc-index}}\,({\it{pc\/}}, {\it{s\/}})\index{pc-index} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{pc-index1}}\,({\it{pc\/}}, {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\it{s\/}})\index{pc-index1} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Immediate data. Mode 111, rn 100.
 Number of extension words: 1 or 2.
\begin{tabbing}{\sc Definition}:\index{immediate} \\  
\=\+{\rm{immediate}}\,({\it{oplen\/}}, {\it{pc\/}}, {\it{s\/}})\index{immediate} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{i}}, {\rm{pc-byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{bsz}}\index{bsz})\index{add}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read}))\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{pc-read-memp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{pc-read-memp} \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{add}, {\it{s\/}})\index{update-pc}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{i}}, {\rm{pc-read-mem}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{pc-read-mem}))\- \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\-\-
\end{tabbing}

 Effective address calculation.  `effec-addr' is a function of
 four arguments, {\it{oplen\/}}, {\it{mode\/}}, {\it{rn\/}}, and {\it{s\/}}.  `oplen' should be {\sc{b}}\index{b},
 {\sc{w}}\index{w}, or {\sc{l}}\index{l}; it is the size of the datum we are computing the
 effective address of.  {\it{mode\/}} is a natural number extracted from
 the first word of the instruction;  {\it{mode\/}} indicates pre-decrement,
 post-increment, etc.  {\it{rn\/}} is a natural number extracted from the
 first word of the instruction; {\it{rn\/}} designates a register. {\it{s\/}} the
 current machine state.  `effec-addr' returns a pair, or `cons' as it
 is called in Lisp and Nqthm.  The first element (or `car') of this
 pair is an internal state after this effective address calculation.
 The second element (or cdr) is another `cons' consisting of the
 direction ('d, 'a, 'm, or 'i),  and the effective address (a
 nonnegative integer).  Because MC68020 instructions can be as
 many as 11 words long, the calculation of the next pc is intimately
 tied to the effective address calculation.
\begin{tabbing}{\sc Definition}:\index{effec-addr} \\  
\=\+{\rm{effec-addr}}\,({\it{oplen\/}}, {\it{mode\/}}, {\it{rn\/}}, {\it{s\/}})\index{effec-addr} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mode\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{mode\/}} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{mode\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{dn-direct}}\,({\it{rn\/}}, {\it{s\/}})\index{dn-direct} \\ 
{\bf else }{\rm{an-direct}}\,({\it{rn\/}}, {\it{s\/}})\index{an-direct}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{mode\/}} $=$ {\tt{2}}$\;\;${\bf then }{\rm{addr-indirect}}\,({\it{rn\/}}, {\it{s\/}})\index{addr-indirect} \\ 
{\bf else }{\rm{addr-postinc}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-postinc}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{mode\/}} $<$ {\tt{6}} \\ 
{\bf then }\=\+{\bf if }{\it{mode\/}} $=$ {\tt{4}}$\;\;${\bf then }{\rm{addr-predec}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{s\/}})\index{addr-predec} \\ 
{\bf else }{\rm{addr-disp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{rn\/}}, {\it{s\/}})\index{addr-disp}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{mode\/}} $=$ {\tt{6}}$\;\;${\bf then }{\rm{addr-index}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{rn\/}}, {\it{s\/}})\index{addr-index} \\ 
{\bf elseif }{\it{rn\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{rn\/}} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{rn\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{absolute-short}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{absolute-short} \\ 
{\bf else }{\rm{absolute-long}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{absolute-long}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{rn\/}} $=$ {\tt{2}}$\;\;${\bf then }{\rm{pc-disp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{pc-disp} \\ 
{\bf else }{\rm{pc-index}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{pc-index}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}$\;${\bf  endif}\-\-
\end{tabbing}

 Given an effective address field, test if it is one of the existing
 addressing modes.
\begin{tabbing}{\sc Definition}:\index{addr-modep} \\  
\=\+{\rm{addr-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{addr-modep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\it{rn\/}} $\leq$ {\tt{4}} \\ 
{\bf else }{\bf{t}}$\;${\bf  endif}\-\-
\end{tabbing}
                   
 Given an effective address field, test if it is a data addressing mode.
\begin{tabbing}{\sc Definition}:\index{data-addr-modep} \\  
\=\+{\rm{data-addr-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{data-addr-modep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\it{rn\/}} $\leq$ {\tt{4}} \\ 
{\bf else }{\it{mode\/}} $\not=$ {\tt{1}}$\;${\bf  endif}\-\-
\end{tabbing}

 Given an effective address field, test if it is a memory addressing mode.
\begin{tabbing}{\sc Definition}:\index{memory-addr-modep} \\  
\=\+{\rm{memory-addr-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{memory-addr-modep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\it{rn\/}} $\leq$ {\tt{4}} \\ 
{\bf else }{\it{mode\/}} $\geq$ {\tt{2}}$\;${\bf  endif}\-\-
\end{tabbing}

 Given an effective address field, test if it is a control addressing mode.
\begin{tabbing}{\sc Definition}:\index{control-addr-modep} \\  
\=\+{\rm{control-addr-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{control-addr-modep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\it{rn\/}} $\leq$ {\tt{3}} \\ 
{\bf else }({\it{mode\/}} $=$ {\tt{2}}) $\vee$ ({\it{mode\/}} $\geq$ {\tt{5}})$\;${\bf  endif}\-\-
\end{tabbing}

 Given an effective address field, test if it is an alterable addressing mode.
\begin{tabbing}{\sc Definition}:\index{alterable-addr-modep} \\  
\=\+{\rm{alterable-addr-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{alterable-addr-modep} \\ 
$=$$\;\;\;\;$(({\it{mode\/}} $\not=$ {\tt{7}}) $\vee$ ({\it{rn\/}} $=$ {\tt{0}}) $\vee$ ({\it{rn\/}} $=$ {\tt{1}}))\-
\end{tabbing}

 `dn-direct-modep' returns {\bf{t}} if the addressing mode is a data register direct.
 Returns {\bf{f}} otherwise.
\begin{tabbing}{\sc Definition}:\index{dn-direct-modep}$\;\;$
{\rm{dn-direct-modep}}\,({\it{mode\/}})\index{dn-direct-modep} $=$ ({\it{mode\/}} $=$ {\tt{0}})
\end{tabbing}

 `an-direct-modep' returns {\bf{t}} if the addressing mode is an address register direct,
 and returns {\bf{f}} otherwise.
\begin{tabbing}{\sc Definition}:\index{an-direct-modep}$\;\;$
{\rm{an-direct-modep}}\,({\it{mode\/}})\index{an-direct-modep} $=$ ({\it{mode\/}} $=$ {\tt{1}})
\end{tabbing}

 Postincrement.
\begin{tabbing}{\sc Definition}:\index{postinc-modep}$\;\;$
{\rm{postinc-modep}}\,({\it{mode\/}})\index{postinc-modep} $=$ ({\it{mode\/}} $=$ {\tt{3}})
\end{tabbing}

 Predecrement.
\begin{tabbing}{\sc Definition}:\index{predec-modep}$\;\;$
{\rm{predec-modep}}\,({\it{mode\/}})\index{predec-modep} $=$ ({\it{mode\/}} $=$ {\tt{4}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{idata-modep} \\  
{\rm{idata-modep}}\,({\it{mode\/}}, {\it{rn\/}})\index{idata-modep} $=$ (({\it{mode\/}} $=$ {\tt{7}}) $\wedge$ ({\it{rn\/}} $=$ {\tt{4}}))
\end{tabbing}

 In address register direct (001), a byte size operation is not allowed.
\begin{tabbing}{\sc Definition}:\index{byte-an-direct-modep} \\  
\=\+{\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\it{mode\/}})\index{byte-an-direct-modep} \\ 
$=$$\;\;\;\;$(({\it{oplen\/}} $=$ {\sc{b}}\index{b}) $\wedge$ {\rm{an-direct-modep}}\,({\it{mode\/}})\index{an-direct-modep})\-
\end{tabbing}

 An internal state in the execution of one instruction.
\begin{tabbing}{\sc Definition}:\index{mc-instate} \\  
\=\+{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{cadr}}\,({\it{s\&addr\/}}) $=$ {\tt{'}}{\tt{m}} \\ 
{\bf then }\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }{\it{s\&addr\/}} \\ 
{\bf else }{\rm{cons}}\,({\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}, {\bf{nil}})$\;${\bf  endif}\- \\ 
{\bf else }{\it{s\&addr\/}}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Mapping functions.  `mapping' finishes the execution of instructions.
 `mapping' maps a machine state into the next state.
\begin{tabbing}{\sc Definition}:\index{d-mapping} \\  
\=\+{\rm{d-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\it{addr\/}}, {\it{s\/}})\index{d-mapping} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,(\=\+{\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, \\ 
{\rm{write-rn}}\,({\it{oplen\/}}, {\rm{car}}\,({\it{v\&cvznx\/}}), {\it{addr\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{write-rn}, \\ 
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, \\ 
{\rm{set-cvznx}}\,({\rm{cdr}}\,({\it{v\&cvznx\/}}), {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-cvznx}, \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\-\index{mc-state}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{a-mapping} \\  
\=\+{\rm{a-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\it{addr\/}}, {\it{s\/}})\index{a-mapping} \\ 
$=$$\;\;\;\;${\rm{mc-state}}\,(\=\+{\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, \\ 
{\rm{write-rn}}\,({\it{oplen\/}}, {\rm{car}}\,({\it{v\&cvznx\/}}), {\tt{8}} $+$ {\it{addr\/}}, {\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\index{write-rn}, \\ 
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, \\ 
{\rm{set-cvznx}}\,({\rm{cdr}}\,({\it{v\&cvznx\/}}), {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-cvznx}, \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\-\index{mc-state}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{m-mapping} \\  
\=\+{\rm{m-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\it{addr\/}}, {\it{s\/}})\index{m-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{write-memp}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{write-memp} \\ 
{\bf then }{\rm{mc-state}}\,(\=\+{\rm{mc-status}}\,({\it{s\/}})\index{mc-status}, \\ 
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile}, \\ 
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, \\ 
{\rm{set-cvznx}}\,({\rm{cdr}}\,({\it{v\&cvznx\/}}), {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-cvznx}, \\ 
{\rm{write-mem}}\,({\rm{car}}\,({\it{v\&cvznx\/}}), {\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{write-mem})\-\index{mc-state} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mapping} \\  
\=\+{\rm{mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\it{s\&addr\/}})\index{mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{cadr}}\,({\it{s\&addr\/}}) $=$ {\tt{'}}{\tt{d}} \\ 
{\bf then }{\rm{d-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{d-mapping} \\ 
{\bf elseif }{\rm{cadr}}\,({\it{s\&addr\/}}) $=$ {\tt{'}}{\tt{a}} \\ 
{\bf then }{\rm{a-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{a-mapping} \\ 
{\bf else }{\rm{m-mapping}}\,({\it{oplen\/}}, {\it{v\&cvznx\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{m-mapping}$\;${\bf  endif}\-\-
\end{tabbing}


 \section{The Individual Instructions}

 ADD instruction.
 The computation of the condition code register(CCR).
\begin{tabbing}{\sc Definition}:\index{add-c} \\  
\=\+{\rm{add-c}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{add}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-or}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and})\-\index{b-or}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-v} \\  
\=\+{\rm{add-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-v} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{add}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\-\index{b-and}, \\ 
{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\-\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-z} \\  
\=\+{\rm{add-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{add}}\,({\it{oplen\/}}, {\it{dopd\/}}, {\it{sopd\/}})\index{add} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-n} \\  
{\rm{add-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-n} $=$ {\rm{mbit}}\,({\rm{add}}\,({\it{oplen\/}}, {\it{dopd\/}}, {\it{sopd\/}})\index{add}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-cvznx} \\  
\=\+{\rm{add-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{add-c}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-c}, \\ 
{\rm{add-v}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-v}, \\ 
{\rm{add-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-z}, \\ 
{\rm{add-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-n}, \\ 
{\rm{add-c}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-c})\-\index{cvznx}\-
\end{tabbing}

 The effects of the execution of an ADD instruction are given as follows.
\begin{tabbing}{\sc Definition}:\index{add-effect} \\  
\=\+{\rm{add-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{add}}\,({\it{oplen\/}}, {\it{dopd\/}}, {\it{sopd\/}})\index{add}, {\rm{add-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{add-cvznx})\-
\end{tabbing}

 Test if the addressing mode is legal.
\begin{tabbing}{\sc Definition}:\index{add-addr-modep1} \\  
\=\+{\rm{add-addr-modep1}}\,({\it{oplen\/}}, {\it{ins\/}})\index{add-addr-modep1} \\ 
$=$$\;\;\;\;$(\=\+{\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-addr-modep2} \\  
\=\+{\rm{add-addr-modep2}}\,({\it{ins\/}})\index{add-addr-modep2} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{memory-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{memory-addr-modep})\-\-
\end{tabbing}

 An execution of an ADD instruction.
\begin{tabbing}{\sc Definition}:\index{add-ins1} \\  
\=\+{\rm{add-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-ins1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{add-addr-modep1}}\,({\it{oplen\/}}, {\it{ins\/}})\index{add-addr-modep1} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{add-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn})\-\index{add-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{d-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{add-mapping} \\  
\=\+{\rm{add-mapping}}\,({\it{opd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{add-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{opd\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand})\-\index{add-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}
                  
\begin{tabbing}{\sc Definition}:\index{add-ins2} \\  
\=\+{\rm{add-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{add-addr-modep2}}\,({\it{ins\/}})\index{add-addr-modep2} \\ 
{\bf then }{\rm{add-mapping}}\,({\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ADDA instruction.
\begin{tabbing}{\sc Definition}:\index{adda-addr-modep} \\  
{\rm{adda-addr-modep}}\,({\it{ins\/}})\index{adda-addr-modep} $=$ {\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep}
\end{tabbing}

 Notice that the ADDA instruction does not affect CCR.
\begin{tabbing}{\sc Definition}:\index{adda-ins} \\  
\=\+{\rm{adda-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{adda-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{adda-addr-modep}}\,({\it{ins\/}})\index{adda-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{car}}\,({\it{s\&addr\/}}))\index{read-an}, \\ 
{\rm{ext}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\sc{l}}\index{l})\-\index{ext})\-\index{add}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{write-an}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ADDX instruction.
\begin{tabbing}{\sc Definition}:\index{addx-c} \\  
\=\+{\rm{addx-c}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{adder}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{adder}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-or}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and})\-\index{b-or}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-v} \\  
\=\+{\rm{addx-v}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-v} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{adder}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{adder}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\-\index{b-and}, \\ 
{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\-\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-z} \\  
\=\+{\rm{addx-z}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-z} \\ 
$=$$\;\;\;\;${\rm{b-and}}\,(\=\+{\it{z\/}}, \\ 
\=\+{\bf if }{\rm{adder}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{dopd\/}}, {\it{sopd\/}})\index{adder} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-)\-\index{b-and}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-n} \\  
{\rm{addx-n}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-n} $=$ {\rm{mbit}}\,({\rm{adder}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{dopd\/}}, {\it{sopd\/}})\index{adder}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-cvznx} \\  
\=\+{\rm{addx-cvznx}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{addx-c}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-c}, \\ 
{\rm{addx-v}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-v}, \\ 
{\rm{addx-z}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-z}, \\ 
{\rm{addx-n}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-n}, \\ 
{\rm{addx-c}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-c})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-effect} \\  
\=\+{\rm{addx-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{addx-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+{\rm{adder}}\,({\it{oplen\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x}, {\it{dopd\/}}, {\it{sopd\/}})\index{adder}, \\ 
{\rm{addx-cvznx}}\,({\it{oplen\/}}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x}, {\it{sopd\/}}, {\it{dopd\/}})\index{addx-cvznx})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-ins1} \\  
\=\+{\rm{addx-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addx-ins1} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{addx-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{addx-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addx-ins2} \\  
\=\+{\rm{addx-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addx-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr0\/}}{\bf $\;$ be$\;\;$}{\rm{addr-predec}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{addr-predec}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr0\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{addr-predec}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{car}}\,({\it{s\&addr0\/}}))\index{addr-predec}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{addx-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr0\/}}), \\ 
{\rm{car}}\,({\it{s\&addr0\/}}))\-\index{operand}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{addx-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Opcode 1101.
 The ADD instruction group includes three instructions ADD, ADDA, and ADDX.
\begin{tabbing}{\sc Definition}:\index{add-group} \\  
\=\+{\rm{add-group}}\,({\it{opmode\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{opmode\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{opmode\/}} $=$ {\tt{3}}$\;\;${\bf then }{\rm{adda-ins}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{adda-ins} \\ 
{\bf else }{\rm{add-ins1}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{add-ins1}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opmode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\rm{adda-ins}}\,({\sc{l}}\index{l}, {\it{ins\/}}, {\it{s\/}})\index{adda-ins} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{addx-ins1}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{addx-ins1} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{addx-ins2}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{addx-ins2} \\ 
{\bf else }{\rm{add-ins2}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{add-ins2}$\;${\bf  endif}\-\-
\end{tabbing}

 SUB instruction.
 The computation of the condition code register (ccr).
\begin{tabbing}{\sc Definition}:\index{sub-c} \\  
\=\+{\rm{sub-c}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{sub}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-or}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and})\-\index{b-or}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-v} \\  
\=\+{\rm{sub-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-v} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{sub}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\-\index{b-and}, \\ 
{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\-\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-z} \\  
\=\+{\rm{sub-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{sub}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-n} \\  
{\rm{sub-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-n} $=$ {\rm{mbit}}\,({\rm{sub}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-cvznx} \\  
\=\+{\rm{sub-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{sub-c}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-c}, \\ 
{\rm{sub-v}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-v}, \\ 
{\rm{sub-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-z}, \\ 
{\rm{sub-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-n}, \\ 
{\rm{sub-c}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-c})\-\index{cvznx}\-
\end{tabbing}

 The effect of an execution of a SUB instruction.
\begin{tabbing}{\sc Definition}:\index{sub-effect} \\  
\=\+{\rm{sub-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{sub}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub}, {\rm{sub-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-cvznx})\-
\end{tabbing}

 Test if the addressing mode is illegal.
\begin{tabbing}{\sc Definition}:\index{sub-addr-modep1} \\  
\=\+{\rm{sub-addr-modep1}}\,({\it{oplen\/}}, {\it{ins\/}})\index{sub-addr-modep1} \\ 
$=$$\;\;\;\;$(\=\+{\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-addr-modep2} \\  
\=\+{\rm{sub-addr-modep2}}\,({\it{ins\/}})\index{sub-addr-modep2} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{memory-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{memory-addr-modep})\-\-
\end{tabbing}

 The execution of the SUB instruction.
\begin{tabbing}{\sc Definition}:\index{sub-ins1} \\  
\=\+{\rm{sub-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-ins1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{sub-addr-modep1}}\,({\it{oplen\/}}, {\it{ins\/}})\index{sub-addr-modep1} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{sub-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn})\-\index{sub-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{d-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-mapping} \\  
\=\+{\rm{sub-mapping}}\,({\it{opd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{sub-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{opd\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand})\-\index{sub-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sub-ins2} \\  
\=\+{\rm{sub-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{sub-addr-modep2}}\,({\it{ins\/}})\index{sub-addr-modep2} \\ 
{\bf then }{\rm{sub-mapping}}\,({\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}
                      
 SUBA instruction.
\begin{tabbing}{\sc Definition}:\index{suba-addr-modep} \\  
{\rm{suba-addr-modep}}\,({\it{ins\/}})\index{suba-addr-modep} $=$ {\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{suba-ins} \\  
\=\+{\rm{suba-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{suba-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{suba-addr-modep}}\,({\it{ins\/}})\index{suba-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{sub}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{ext}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\sc{l}}\index{l})\-\index{ext}, \\ 
{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{car}}\,({\it{s\&addr\/}}))\index{read-an})\-\index{sub}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{write-an}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 SUBX instruction.
\begin{tabbing}{\sc Definition}:\index{subx-c} \\  
\=\+{\rm{subx-c}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{subtracter}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subtracter}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-or}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and})\-\index{b-or}, \\ 
{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-v} \\  
\=\+{\rm{subx-v}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-v} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{result\/}}{\bf $\;$ be$\;\;$}{\rm{subtracter}}\,({\it{n\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subtracter}\- \\ 
{\bf in} \\ 
{\rm{b-or}}\,(\=\+{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{b-not}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit})\index{b-not}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-and}, \\ 
{\rm{b-not}}\,({\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\index{b-not})\-\index{b-and}, \\ 
{\rm{b-and}}\,(\=\+{\rm{b-and}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{n\/}})\index{mbit}, {\rm{b-not}}\,({\rm{mbit}}\,({\it{dopd\/}}, {\it{n\/}})\index{mbit})\index{b-not})\index{b-and}, \\ 
{\rm{mbit}}\,({\it{result\/}}, {\it{n\/}})\index{mbit})\-\index{b-and})\-\index{b-or}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-z} \\  
\=\+{\rm{subx-z}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-z} \\ 
$=$$\;\;\;\;${\rm{b-and}}\,(\=\+{\it{z\/}}, \\ 
\=\+{\bf if }{\rm{subtracter}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subtracter} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-)\-\index{b-and}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-n} \\  
{\rm{subx-n}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-n} $=$ {\rm{mbit}}\,({\rm{subtracter}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subtracter}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-cvznx} \\  
\=\+{\rm{subx-cvznx}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{subx-c}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-c}, \\ 
{\rm{subx-v}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-v}, \\ 
{\rm{subx-z}}\,({\it{oplen\/}}, {\it{z\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-z}, \\ 
{\rm{subx-n}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-n}, \\ 
{\rm{subx-c}}\,({\it{oplen\/}}, {\it{x\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-c})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-effect} \\  
\=\+{\rm{subx-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{subx-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+{\rm{subtracter}}\,({\it{oplen\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x}, {\it{sopd\/}}, {\it{dopd\/}})\index{subtracter}, \\ 
{\rm{subx-cvznx}}\,({\it{oplen\/}}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x}, {\it{sopd\/}}, {\it{dopd\/}})\index{subx-cvznx})\-\-
\end{tabbing}
 
\begin{tabbing}{\sc Definition}:\index{subx-ins1} \\  
\=\+{\rm{subx-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subx-ins1} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{subx-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{subx-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subx-ins2} \\  
\=\+{\rm{subx-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subx-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr0\/}}{\bf $\;$ be$\;\;$}{\rm{addr-predec}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{addr-predec}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr0\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{addr-predec}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{car}}\,({\it{s\&addr0\/}}))\index{addr-predec}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{subx-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr0\/}}), \\ 
{\rm{car}}\,({\it{s\&addr0\/}}))\-\index{operand}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{subx-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Opcode 1001.
 The SUB instruction group includes three instructions SUB, SUBA, and SUBX.
\begin{tabbing}{\sc Definition}:\index{sub-group} \\  
\=\+{\rm{sub-group}}\,({\it{opmode\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{opmode\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{opmode\/}} $=$ {\tt{3}}$\;\;${\bf then }{\rm{suba-ins}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{suba-ins} \\ 
{\bf else }{\rm{sub-ins1}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{sub-ins1}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opmode\/}} $=$ {\tt{7}}$\;\;${\bf then }{\rm{suba-ins}}\,({\sc{l}}\index{l}, {\it{ins\/}}, {\it{s\/}})\index{suba-ins} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{subx-ins1}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{subx-ins1} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{subx-ins2}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{subx-ins2} \\ 
{\bf else }{\rm{sub-ins2}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{sub-ins2}$\;${\bf  endif}\-\-
\end{tabbing}

 AND instruction.
 The computation of the condition code register(CCR).
\begin{tabbing}{\sc Definition}:\index{and-z} \\  
\=\+{\rm{and-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{and-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{logand}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logand} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{and-n} \\  
{\rm{and-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{and-n} $=$ {\rm{mbit}}\,({\rm{logand}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logand}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{and-cvznx} \\  
\=\+{\rm{and-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{and-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{and-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{and-z}, {\rm{and-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{and-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

 The effect of the execution of the AND instruction.
\begin{tabbing}{\sc Definition}:\index{and-effect} \\  
\=\+{\rm{and-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{and-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{logand}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logand}, {\rm{and-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{and-cvznx})\-
\end{tabbing}

 Test if the addressing mode is legal.
\begin{tabbing}{\sc Definition}:\index{and-addr-modep1} \\  
{\rm{and-addr-modep1}}\,({\it{ins\/}})\index{and-addr-modep1} $=$ {\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{and-addr-modep2} \\  
\=\+{\rm{and-addr-modep2}}\,({\it{ins\/}})\index{and-addr-modep2} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{memory-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{memory-addr-modep})\-\-
\end{tabbing}

 The execution of the AND instruction.
\begin{tabbing}{\sc Definition}:\index{and-ins1} \\  
\=\+{\rm{and-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-ins1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{and-addr-modep1}}\,({\it{ins\/}})\index{and-addr-modep1} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{and-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{and-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{d-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{and-mapping} \\  
\=\+{\rm{and-mapping}}\,({\it{sopd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{and-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{sopd\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{and-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{and-ins2} \\  
\=\+{\rm{and-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{and-addr-modep2}}\,({\it{ins\/}})\index{and-addr-modep2} \\ 
{\bf then }{\rm{and-mapping}}\,({\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MULU.W/MULS.W instruction.  S * D $\rightarrow$ D.
 MULU expects {\it{x\/}} and {\it{y\/}} to be two natural numbers.
\begin{tabbing}{\sc Definition}:\index{mulu}$\;\;$
{\rm{mulu}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}}, {\it{i\/}})\index{mulu} $=$ {\rm{head}}\,({\it{x\/}} $*$ {\it{y\/}}, {\it{n\/}})\index{head}
\end{tabbing}

 MULS expects {\it{x\/}} and {\it{y\/}} to be two natural numbers.
\begin{tabbing}{\sc Definition}:\index{muls} \\  
\=\+{\rm{muls}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}}, {\it{i\/}})\index{muls} \\ 
$=$$\;\;\;\;${\rm{head}}\,({\rm{int-to-nat}}\,({\rm{itimes}}\,({\rm{nat-to-int}}\,({\it{x\/}}, {\it{i\/}})\index{nat-to-int}, {\rm{nat-to-int}}\,({\it{y\/}}, {\it{i\/}})\index{nat-to-int})\index{itimes}, {\tt{2}} $*$ {\it{i\/}})\index{int-to-nat}, {\it{n\/}})\index{head}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mul\&div-addr-modep} \\  
{\rm{mul\&div-addr-modep}}\,({\it{ins\/}})\index{mul\&div-addr-modep} $=$ {\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep}
\end{tabbing}

 The condition codes for MULU.
\begin{tabbing}{\sc Definition}:\index{mulu-v} \\  
\=\+{\rm{mulu-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-v} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{sopd\/}} $*$ {\it{dopd\/}}) $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mulu-z} \\  
\=\+{\rm{mulu-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{mulu}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mulu-n}$\;\;$
{\rm{mulu-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-n} $=$ {\rm{mbit}}\,({\rm{mulu}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu}, {\it{n\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mulu-cvznx} \\  
\=\+{\rm{mulu-cvznx}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}}, {\it{ccr\/}})\index{mulu-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\sc{b0}}\index{b0}, \\ 
{\rm{mulu-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-v}, \\ 
{\rm{mulu-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-z}, \\ 
{\rm{mulu-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{mulu-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mulu\_w-ins} \\  
\=\+{\rm{mulu\_w-ins}}\,({\it{sopd\/}}, {\it{dn\/}}, {\it{s\/}})\index{mulu\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{w}}\index{w}, {\it{dn\/}}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{mulu-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{w}}\index{w}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{mulu-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\rm{mulu}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{w}}\index{w})\index{mulu}, {\it{dn\/}}, {\it{s\/}})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\-\-
\end{tabbing}

 The condition codes for MULS.
\begin{tabbing}{\sc Definition}:\index{muls-v} \\  
\=\+{\rm{muls-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-v} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{int-rangep}}\,({\rm{itimes}}\,({\rm{nat-to-int}}\,({\it{sopd\/}}, {\it{i\/}})\index{nat-to-int}, {\rm{nat-to-int}}\,({\it{dopd\/}}, {\it{i\/}})\index{nat-to-int})\index{itimes}, {\it{n\/}})\index{int-rangep} \\ 
{\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls-z} \\  
\=\+{\rm{muls-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{muls}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls-n}$\;\;$
{\rm{muls-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-n} $=$ {\rm{mbit}}\,({\rm{muls}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls}, {\it{n\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls-cvznx} \\  
\=\+{\rm{muls-cvznx}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}}, {\it{ccr\/}})\index{muls-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\sc{b0}}\index{b0}, \\ 
{\rm{muls-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-v}, \\ 
{\rm{muls-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-z}, \\ 
{\rm{muls-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{i\/}})\index{muls-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls\_w-ins} \\  
\=\+{\rm{muls\_w-ins}}\,({\it{sopd\/}}, {\it{dn\/}}, {\it{s\/}})\index{muls\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{w}}\index{w}, {\it{dn\/}}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{muls-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{w}}\index{w}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{muls-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\rm{muls}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{w}}\index{w})\index{muls}, {\it{dn\/}}, {\it{s\/}})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\-\-
\end{tabbing}

 EXG instruction.
 Exchange the contents of two data registers.
\begin{tabbing}{\sc Definition}:\index{exg-drdr-ins} \\  
\=\+{\rm{exg-drdr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-drdr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dx\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\it{dy\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{dy\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{dx\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{write-dn})\index{write-dn}$\;${\bf  endlet}\-\-
\end{tabbing}

 Exchange the contents of two address registers.
\begin{tabbing}{\sc Definition}:\index{exg-arar-ins} \\  
\=\+{\rm{exg-arar-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-arar-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{ax\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-an}, \\ 
{\it{ay\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
{\rm{write-an}}\,({\sc{l}}\index{l}, {\it{ay\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{write-an}}\,({\sc{l}}\index{l}, {\it{ax\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{write-an})\index{write-an}$\;${\bf  endlet}\-\-
\end{tabbing}

 Exchange the contents of data and address registers.
\begin{tabbing}{\sc Definition}:\index{exg-drar-ins} \\  
\=\+{\rm{exg-drar-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-drar-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dx\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\it{ay\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{ay\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{write-an}}\,({\sc{l}}\index{l}, {\it{dx\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{write-an})\index{write-dn}$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mul\_w-ins} \\  
\=\+{\rm{mul\_w-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mul\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{mul\&div-addr-modep}}\,({\it{ins\/}})\index{mul\&div-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }\=\+{\bf let }\=\+{\it{sopd\/}}{\bf $\;$ be$\;\;$}{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{mulu\_w-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{mulu\_w-ins} \\ 
{\bf else }{\rm{muls\_w-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{muls\_w-ins}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 1100.
 The AND instruction group includes three instructions AND, MULS.W/MULU.W,
 and EXG.  Detect ABCD.
\begin{tabbing}{\sc Definition}:\index{and-group} \\  
\=\+{\rm{and-group}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{mul\_w-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mul\_w-ins} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{and-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-ins1} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{abcd-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\it{oplen\/}} $=$ {\sc{w}}\index{w} \\ 
{\bf then }\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{exg-drdr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-drdr-ins} \\ 
{\bf else }{\rm{exg-arar-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-arar-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{exg-drar-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{exg-drar-ins}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{and-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{and-ins2}$\;${\bf  endif}\-\-
\end{tabbing}

 OR instruction.
 The computation of the condition code register.
\begin{tabbing}{\sc Definition}:\index{or-z} \\  
\=\+{\rm{or-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{or-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{logor}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logor} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{or-n} \\  
{\rm{or-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{or-n} $=$ {\rm{b-or}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{oplen\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{oplen\/}})\index{mbit})\index{b-or}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{or-cvznx} \\  
\=\+{\rm{or-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{or-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{or-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{or-z}, {\rm{or-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{or-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

 The effect of an execution of an  OR instruction.
\begin{tabbing}{\sc Definition}:\index{or-effect} \\  
\=\+{\rm{or-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{or-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{logor}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logor}, {\rm{or-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{or-cvznx})\-
\end{tabbing}

 Test if the addressing mode is illegal.
\begin{tabbing}{\sc Definition}:\index{or-addr-modep1} \\  
{\rm{or-addr-modep1}}\,({\it{ins\/}})\index{or-addr-modep1} $=$ {\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{or-addr-modep2} \\  
\=\+{\rm{or-addr-modep2}}\,({\it{ins\/}})\index{or-addr-modep2} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{memory-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{memory-addr-modep})\-\-
\end{tabbing}

 The execution of the OR instruction.
\begin{tabbing}{\sc Definition}:\index{or-ins1} \\  
\=\+{\rm{or-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-ins1} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{or-addr-modep1}}\,({\it{ins\/}})\index{or-addr-modep1} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{or-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{or-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{d-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{or-mapping} \\  
\=\+{\rm{or-mapping}}\,({\it{sopd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{or-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{sopd\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{or-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{or-ins2} \\  
\=\+{\rm{or-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-ins2} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{or-addr-modep2}}\,({\it{ins\/}})\index{or-addr-modep2} \\ 
{\bf then }{\rm{or-mapping}}\,({\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 DIVU.W/DIVS.W instructions.  D(32)/S(16) $\rightarrow$ D(16r:16q).
 `iquot' and `irem' expect that {\it{s\/}} and {\it{d\/}} are unsigned integers.  They are
 used in the DIV instruction.
\begin{tabbing}{\sc Definition}:\index{iquot} \\  
\=\+{\rm{iquot}}\,({\it{n\/}}, {\it{s\/}}, {\it{i\/}}, {\it{d\/}}, {\it{j\/}})\index{iquot} \\ 
$=$$\;\;\;\;${\rm{head}}\,({\rm{int-to-nat}}\,({\rm{iquotient}}\,({\rm{nat-to-int}}\,({\it{d\/}}, {\it{j\/}})\index{nat-to-int}, {\rm{nat-to-int}}\,({\it{s\/}}, {\it{i\/}})\index{nat-to-int})\index{iquotient}, {\it{j\/}})\index{int-to-nat}, {\it{n\/}})\index{head}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{irem} \\  
\=\+{\rm{irem}}\,({\it{n\/}}, {\it{s\/}}, {\it{i\/}}, {\it{d\/}}, {\it{j\/}})\index{irem} \\ 
$=$$\;\;\;\;${\rm{head}}\,({\rm{int-to-nat}}\,({\rm{iremainder}}\,({\rm{nat-to-int}}\,({\it{d\/}}, {\it{j\/}})\index{nat-to-int}, {\rm{nat-to-int}}\,({\it{s\/}}, {\it{i\/}})\index{nat-to-int})\index{iremainder}, {\it{i\/}})\index{int-to-nat}, {\it{n\/}})\index{head}\-
\end{tabbing}

 DIVS.W instruction.
\begin{tabbing}{\sc Definition}:\index{divs-v} \\  
\=\+{\rm{divs-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{divs-v} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{int-rangep}}\,({\rm{iquotient}}\,({\rm{nat-to-int}}\,({\it{dopd\/}}, {\it{j\/}})\index{nat-to-int}, {\rm{nat-to-int}}\,({\it{sopd\/}}, {\it{i\/}})\index{nat-to-int})\index{iquotient}, {\it{n\/}})\index{int-rangep} \\ 
{\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{divs-z} \\  
\=\+{\rm{divs-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{divs-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{iquot}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{iquot} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{divs-n} \\  
{\rm{divs-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{divs-n} $=$ {\rm{mbit}}\,({\rm{iquot}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{iquot}, {\it{n\/}})\index{mbit}
\end{tabbing}

 In our specification of DIV,  we only make sure that the N and Z bits 
 are set correctly when there is NO overflow.
 Since we test for overflow before this instruction is fully completed,
 the setting of CCR is actually the same as AND's if NO overflow occurs.
 When an overflow is detected, we simply halt the machine with an
 error signal.

 If overflow or divide by zero happens during the DIV instructions, then
 the MC68020 manual states that values of N, Z, and V are undefined.
 Thus one should not count on the validity of these values in the
 error state returned by `stepi'.

\begin{tabbing}{\sc Definition}:\index{divs-cvznx} \\  
\=\+{\rm{divs-cvznx}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}}, {\it{ccr\/}})\index{divs-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\sc{b0}}\index{b0}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{divs-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{divs-z}, \\ 
{\rm{divs-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{i\/}}, {\it{dopd\/}}, {\it{j\/}})\index{divs-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}

 32/16 $\rightarrow$ 16r:16q.
\begin{tabbing}{\sc Definition}:\index{divs\_w-ins} \\  
\=\+{\rm{divs\_w-ins}}\,({\it{sopd\/}}, {\it{dn\/}}, {\it{s\/}})\index{divs\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{nat-to-int}}\,({\it{sopd\/}}, {\sc{w}}\index{w})\index{nat-to-int} $=$ {\tt{0}}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trap-exception}}, {\it{s\/}})\index{halt} \\ 
{\bf else }\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\it{dn\/}}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{divs-v}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\sc{w}}\index{w}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{divs-v})\index{b0p} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{divs-cvznx}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\it{sopd\/}}, \\ 
{\sc{w}}\index{w}, \\ 
{\it{dopd\/}}, \\ 
{\sc{l}}\index{l}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{divs-cvznx}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{app}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{iquot}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\sc{w}}\index{w}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{iquot}, \\ 
{\rm{irem}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\sc{w}}\index{w}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{irem})\-\index{app}, \\ 
{\it{dn\/}}, \\ 
{\it{s\/}})\-\index{write-dn})\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,(\=\+{\tt{'}}{\tt{divs-overflow}}, \\ 
{\rm{update-ccr}}\,({\rm{set-v}}\,({\sc{b1}}\index{b1}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-v}, {\it{s\/}})\index{update-ccr})\-\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-\-
\end{tabbing}

 DIVU.W instruction.
\begin{tabbing}{\sc Definition}:\index{quot}$\;\;$
{\rm{quot}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{quot} $=$ {\rm{head}}\,({\it{y\/}} $\div$ {\it{x\/}}, {\it{n\/}})\index{head}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rem}$\;\;$
{\rm{rem}}\,({\it{n\/}}, {\it{x\/}}, {\it{y\/}})\index{rem} $=$ {\rm{head}}\,({\it{y\/}} ${}${\bf{mod}}${}$ {\it{x\/}}, {\it{n\/}})\index{head}
\end{tabbing}

 The condition codes for DIVU.
\begin{tabbing}{\sc Definition}:\index{divu-v} \\  
\=\+{\rm{divu-v}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-v} \\ 
$=$$\;\;\;\;$\=\+{\bf if }({\it{dopd\/}} $\div$ {\it{sopd\/}}) $<$ {\rm{exp}}\,({\tt{2}}, {\it{n\/}})\index{exp}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{divu-z} \\  
\=\+{\rm{divu-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{quot}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{quot} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{divu-n}$\;\;$
{\rm{divu-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-n} $=$ {\rm{mbit}}\,({\rm{quot}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{quot}, {\it{n\/}})\index{mbit}
\end{tabbing}

 Same treatment as divs-cvznx.
\begin{tabbing}{\sc Definition}:\index{divu-cvznx} \\  
\=\+{\rm{divu-cvznx}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{divu-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{divu-z}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-z}, {\rm{divu-n}}\,({\it{n\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

 32/16 $\rightarrow$ 16r:16q.
\begin{tabbing}{\sc Definition}:\index{divu\_w-ins} \\  
\=\+{\rm{divu\_w-ins}}\,({\it{sopd\/}}, {\it{dn\/}}, {\it{s\/}})\index{divu\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{nat-to-uint}}\,({\it{sopd\/}})\index{nat-to-uint} $=$ {\tt{0}}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trap-exception}}, {\it{s\/}})\index{halt} \\ 
{\bf else }\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\it{dn\/}}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{divu-v}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-v})\index{b0p} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{divu-cvznx}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\it{dopd\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{divu-cvznx}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{app}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{quot}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\it{dopd\/}})\index{quot}, \\ 
{\rm{rem}}\,({\sc{w}}\index{w}, {\it{sopd\/}}, {\it{dopd\/}})\index{rem})\-\index{app}, \\ 
{\it{dn\/}}, \\ 
{\it{s\/}})\-\index{write-dn})\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,(\=\+{\tt{'}}{\tt{divu-overflow}}, \\ 
{\rm{update-ccr}}\,({\rm{set-v}}\,({\sc{b1}}\index{b1}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-v}, {\it{s\/}})\index{update-ccr})\-\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{div\_w-ins} \\  
\=\+{\rm{div\_w-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{div\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{mul\&div-addr-modep}}\,({\it{ins\/}})\index{mul\&div-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }\=\+{\bf let }\=\+{\it{sopd\/}}{\bf $\;$ be$\;\;$}{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{divu\_w-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{divu\_w-ins} \\ 
{\bf else }{\rm{divs\_w-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{divs\_w-ins}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 1000.
 The OR instruction group includes two instructions OR and DIVU.W/DIVS.W.
\begin{tabbing}{\sc Definition}:\index{or-group} \\  
\=\+{\rm{or-group}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{div\_w-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{div\_w-ins} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{or-ins1}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-ins1} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $<$ {\tt{2}} \\ 
{\bf then }{\rm{halt}}\,({\tt{'}}{\tt{sbcd-pack-unpk-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{or-ins2}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{or-ins2}$\;${\bf  endif}\-\-
\end{tabbing}

 Rotate operations.
 Rotate left {\it{cnt\/}} times.  {\it{len\/}} is supposed to be the length of {\it{x\/}}.
\begin{tabbing}{\sc Definition}:\index{rol} \\  
\=\+{\rm{rol}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{rol} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{n\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}}\- \\ 
{\bf in} \\ 
{\rm{app}}\,({\it{n\/}}, {\rm{tail}}\,({\it{x\/}}, {\it{len\/}} $-$ {\it{n\/}})\index{tail}, {\rm{head}}\,({\it{x\/}}, {\it{len\/}} $-$ {\it{n\/}})\index{head})\index{app}$\;${\bf  endlet}\-\-
\end{tabbing}

 Rotate right {\it{cnt\/}} times.  {\it{len\/}} is supposed to be the length of {\it{x\/}}.
\begin{tabbing}{\sc Definition}:\index{ror} \\  
\=\+{\rm{ror}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{ror} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{n\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}}\- \\ 
{\bf in} \\ 
{\rm{app}}\,({\it{len\/}} $-$ {\it{n\/}}, {\rm{tail}}\,({\it{x\/}}, {\it{n\/}})\index{tail}, {\rm{head}}\,({\it{x\/}}, {\it{n\/}})\index{head})\index{app}$\;${\bf  endlet}\-\-
\end{tabbing}

 For memory shift/rotate, only memory alterable addressing modes are allowed.
\begin{tabbing}{\sc Definition}:\index{s\&r-addr-modep} \\  
\=\+{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{memory-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{memory-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

 `i-data' returns a nonnegative integer.  In register shift/rotate, it is
 the shift/rotate cnt.  In ADDQ and SUBQ, it is the immediate data.
\begin{tabbing}{\sc Definition}:\index{i-data} \\  
\=\+{\rm{i-data}}\,({\it{n\/}})\index{i-data} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\tt{8}} \\ 
{\bf else }{\it{n\/}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{sr-cnt} \\  
\=\+{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{5}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{i-data}}\,({\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{i-data} \\ 
{\bf else }{\rm{read-dn}}\,({\sc{b}}\index{b}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn} ${}${\bf{mod}}${}$ {\tt{64}}$\;${\bf  endif}\-\-
\end{tabbing}

 ROL and ROR instructions.
 We divide the ROL/ROR instruction into a few subinstructions.

 Register ROL instruction.
 The setting of cvznx-flags for ROL.
\begin{tabbing}{\sc Definition}:\index{rol-c} \\  
\=\+{\rm{rol-c}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{rol-c} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }\=\+{\bf let }\=\+{\it{n\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{bcar}}\,({\it{x\/}})\index{bcar} \\ 
{\bf else }{\rm{bitn}}\,({\it{x\/}}, {\it{len\/}} $-$ {\it{n\/}})\index{bitn}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rol-z} \\  
\=\+{\rm{rol-z}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{rol-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{x\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rol-n} \\  
{\rm{rol-n}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{rol-n} $=$ {\rm{bitn}}\,({\it{x\/}}, ({\it{len\/}} $-$ ({\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}})) $-\;1$)\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rol-cvznx} \\  
\=\+{\rm{rol-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{rol-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{rol-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{rol-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{rol-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{rol-z}, \\ 
{\rm{rol-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{rol-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rol-effect} \\  
\=\+{\rm{rol-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{rol-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{rol}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{rol}, {\rm{rol-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{rol-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-rol-ins} \\  
\=\+{\rm{register-rol-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-rol-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{rol-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{rol-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Register ROR instruction.
\begin{tabbing}{\sc Definition}:\index{ror-c} \\  
\=\+{\rm{ror-c}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{ror-c} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }\=\+{\bf let }\=\+{\it{n\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{n\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{bitn}}\,({\it{x\/}}, {\it{len\/}} $-\;1$)\index{bitn} \\ 
{\bf else }{\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ror-z} \\  
\=\+{\rm{ror-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{ror-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{opd\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ror-n} \\  
\=\+{\rm{ror-n}}\,({\it{len\/}}, {\it{x\/}}, {\it{cnt\/}})\index{ror-n} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{n\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ {\it{len\/}}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{bitn}}\,({\it{x\/}}, {\it{len\/}} $-\;1$)\index{bitn} \\ 
{\bf else }{\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ror-cvznx} \\  
\=\+{\rm{ror-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{ror-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{ror-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{ror-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{ror-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{ror-z}, \\ 
{\rm{ror-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{ror-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ror-effect} \\  
\=\+{\rm{ror-effect}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{ror-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{ror}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{ror}, {\rm{ror-cvznx}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{ror-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-ror-ins} \\  
\=\+{\rm{register-ror-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-ror-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{ror-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{ror-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Memory ROL instruction.
 The operand size should be word, and the shift operation is one bit only.
\begin{tabbing}{\sc Definition}:\index{mem-rol-effect}$\;\;$
{\rm{mem-rol-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-rol-effect} $=$ {\rm{rol-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{rol-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-rol-ins} \\  
\=\+{\rm{mem-rol-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-rol-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-rol-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-rol-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Memory ROR instruction.
 The operand size should be word, and the shift operation is one bit only.
\begin{tabbing}{\sc Definition}:\index{mem-ror-effect}$\;\;$
{\rm{mem-ror-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-ror-effect} $=$ {\rm{ror-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{ror-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-ror-ins} \\  
\=\+{\rm{mem-ror-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-ror-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-ror-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-ror-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 LSL and LSR instructions.
 We divided the LSL/LSR instruction into several subinstructions.

 Register LSL instruction.
\begin{tabbing}{\sc Definition}:\index{lsl-c} \\  
\=\+{\rm{lsl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-c} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf elseif }{\it{len\/}} $<$ {\it{cnt\/}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\rm{bitn}}\,({\it{opd\/}}, {\it{len\/}} $-$ {\it{cnt\/}})\index{bitn}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsl-z} \\  
\=\+{\rm{lsl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{lsl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsl-n}$\;\;$
{\rm{lsl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-n} $=$ {\rm{mbit}}\,({\rm{lsl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl}, {\it{len\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsl-x} \\  
\=\+{\rm{lsl-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsl-x} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x} \\ 
{\bf else }{\rm{lsl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-c}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsl-cvznx} \\  
\=\+{\rm{lsl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsl-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{lsl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{lsl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-z}, \\ 
{\rm{lsl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-n}, \\ 
{\rm{lsl-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsl-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsl-effect} \\  
\=\+{\rm{lsl-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsl-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{lsl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl}, {\rm{lsl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsl-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-lsl-ins} \\  
\=\+{\rm{register-lsl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-lsl-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{lsl-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{lsl-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Register LSR instruction.
\begin{tabbing}{\sc Definition}:\index{lsr-c} \\  
\=\+{\rm{lsr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-c} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf elseif }{\it{len\/}} $<$ {\it{cnt\/}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\rm{bitn}}\,({\it{opd\/}}, {\it{cnt\/}} $-\;1$)\index{bitn}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsr-z} \\  
\=\+{\rm{lsr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{lsr}}\,({\it{opd\/}}, {\it{cnt\/}})\index{lsr} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsr-n}$\;\;$
{\rm{lsr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-n} $=$ {\rm{mbit}}\,({\rm{lsr}}\,({\it{opd\/}}, {\it{cnt\/}})\index{lsr}, {\it{len\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsr-x} \\  
\=\+{\rm{lsr-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsr-x} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x} \\ 
{\bf else }{\rm{lsr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-c}$\;${\bf  endif}\-\-
\end{tabbing}
   
\begin{tabbing}{\sc Definition}:\index{lsr-cvznx} \\  
\=\+{\rm{lsr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsr-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{lsr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{lsr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-z}, \\ 
{\rm{lsr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsr-n}, \\ 
{\rm{lsr-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{lsr-effect} \\  
\=\+{\rm{lsr-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsr-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{lsr}}\,({\it{opd\/}}, {\it{cnt\/}})\index{lsr}, {\rm{lsr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{lsr-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-lsr-ins} \\  
\=\+{\rm{register-lsr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-lsr-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{lsr-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{lsr-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Memory LSL instruction.
\begin{tabbing}{\sc Definition}:\index{mem-lsl-effect}$\;\;$
{\rm{mem-lsl-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-lsl-effect} $=$ {\rm{lsl-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{lsl-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-lsl-ins} \\  
\=\+{\rm{mem-lsl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-lsl-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-lsl-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-lsl-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Memory LSR instruction.
\begin{tabbing}{\sc Definition}:\index{mem-lsr-effect}$\;\;$
{\rm{mem-lsr-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-lsr-effect} $=$ {\rm{lsr-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{lsr-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-lsr-ins} \\  
\=\+{\rm{mem-lsr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-lsr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-lsr-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-lsr-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}
                
 ASL and ASR instructions.

 Register ASL instruction.
\begin{tabbing}{\sc Definition}:\index{asl-c}$\;\;$
{\rm{asl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-c} $=$ {\rm{lsl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{lsl-c}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-v} \\  
\=\+{\rm{asl-v}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-v} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{int-rangep}}\,({\rm{nat-to-int}}\,({\it{opd\/}}, {\it{len\/}})\index{nat-to-int}, {\it{len\/}} $-$ {\it{cnt\/}})\index{int-rangep}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf else }{\sc{b1}}\index{b1}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-z} \\  
\=\+{\rm{asl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{asl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-n}$\;\;$
{\rm{asl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-n} $=$ {\rm{mbit}}\,({\rm{asl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl}, {\it{len\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-x} \\  
\=\+{\rm{asl-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asl-x} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x} \\ 
{\bf else }{\rm{asl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-c}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-cvznx} \\  
\=\+{\rm{asl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asl-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{asl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-c}, \\ 
{\rm{asl-v}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-v}, \\ 
{\rm{asl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-z}, \\ 
{\rm{asl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl-n}, \\ 
{\rm{asl-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asl-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asl-effect} \\  
\=\+{\rm{asl-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asl-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{asl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asl}, {\rm{asl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asl-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-asl-ins} \\  
\=\+{\rm{register-asl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-asl-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{asl-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{asl-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Register ASR instruction.
\begin{tabbing}{\sc Definition}:\index{asr-c} \\  
\=\+{\rm{asr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-c} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b0}}\index{b0} \\ 
{\bf elseif }{\it{cnt\/}} $<$ {\it{len\/}}$\;\;${\bf then }{\rm{bitn}}\,({\it{opd\/}}, {\it{cnt\/}} $-\;1$)\index{bitn} \\ 
{\bf else }{\rm{bitn}}\,({\it{opd\/}}, {\it{len\/}} $-\;1$)\index{bitn}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asr-z} \\  
\=\+{\rm{asr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{asr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asr-n}$\;\;$
{\rm{asr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-n} $=$ {\rm{mbit}}\,({\rm{asr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr}, {\it{len\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asr-x} \\  
\=\+{\rm{asr-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asr-x} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cnt\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x} \\ 
{\bf else }{\rm{asr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-c}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asr-cvznx} \\  
\=\+{\rm{asr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asr-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{asr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{asr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-z}, \\ 
{\rm{asr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr-n}, \\ 
{\rm{asr-x}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asr-x})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{asr-effect} \\  
\=\+{\rm{asr-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asr-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{asr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}})\index{asr}, {\rm{asr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{asr-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-asr-ins} \\  
\=\+{\rm{register-asr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-asr-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{asr-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{asr-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Memory ASL instruction.
\begin{tabbing}{\sc Definition}:\index{mem-asl-effect}$\;\;$
{\rm{mem-asl-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-asl-effect} $=$ {\rm{asl-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{asl-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-asl-ins} \\  
\=\+{\rm{mem-asl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-asl-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-asl-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-asl-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Memory ASR instruction.
\begin{tabbing}{\sc Definition}:\index{mem-asr-effect}$\;\;$
{\rm{mem-asr-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-asr-effect} $=$ {\rm{asr-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{asr-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-asr-ins} \\  
\=\+{\rm{mem-asr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-asr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-asr-effect}}\,(\=\+{\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-asr-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ROXL and ROXR instructions.

 `roxl' defines the rotate left with extend operation.
\begin{tabbing}{\sc Definition}:\index{roxl} \\  
\=\+{\rm{roxl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{temp\/}}{\bf $\;$ be$\;\;$}{\it{x\/}} $+$ ({\tt{2}} $*$ {\it{opd\/}})\- \\ 
{\bf in} \\ 
{\rm{bcdr}}\,({\rm{rol}}\,($1\;+$ {\it{len\/}}, {\it{temp\/}}, {\it{cnt\/}})\index{rol})\index{bcdr}$\;${\bf  endlet}\-\-
\end{tabbing}

 `roxr' defines the rotate right with extend operation.
\begin{tabbing}{\sc Definition}:\index{roxr} \\  
\=\+{\rm{roxr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{temp\/}}{\bf $\;$ be$\;\;$}{\it{opd\/}} $+$ ({\it{x\/}} $*$ {\rm{exp}}\,({\tt{2}}, {\it{len\/}})\index{exp})\- \\ 
{\bf in} \\ 
{\rm{head}}\,({\rm{ror}}\,($1\;+$ {\it{len\/}}, {\it{temp\/}}, {\it{cnt\/}})\index{ror}, {\it{len\/}})\index{head}$\;${\bf  endlet}\-\-
\end{tabbing}

 Register ROXL instruction.
\begin{tabbing}{\sc Definition}:\index{roxl-c} \\  
\=\+{\rm{roxl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{tmp\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ ($1\;+$ {\it{len\/}})\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{tmp\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{fix-bit}}\,({\it{x\/}})\index{fix-bit} \\ 
{\bf else }{\rm{bitn}}\,({\it{opd\/}}, {\it{len\/}} $-$ {\it{tmp\/}})\index{bitn}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxl-z} \\  
\=\+{\rm{roxl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{roxl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxl-n} \\  
{\rm{roxl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-n} $=$ {\rm{bitn}}\,({\rm{roxl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl}, {\it{len\/}} $-\;1$)\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxl-cvznx} \\  
\=\+{\rm{roxl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{roxl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{roxl-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-z}, \\ 
{\rm{roxl-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-n}, \\ 
{\rm{roxl-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxl-c})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxl-effect} \\  
\=\+{\rm{roxl-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{roxl-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{roxl}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{roxl}, {\rm{roxl-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{roxl-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-roxl-ins} \\  
\=\+{\rm{register-roxl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-roxl-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{roxl-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{roxl-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Register ROXR instruction.
\begin{tabbing}{\sc Definition}:\index{roxr-c} \\  
\=\+{\rm{roxr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-c} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{tmp\/}}{\bf $\;$ be$\;\;$}{\it{cnt\/}} ${}${\bf{mod}}${}$ ($1\;+$ {\it{len\/}})\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{tmp\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{fix-bit}}\,({\it{x\/}})\index{fix-bit} \\ 
{\bf else }{\rm{bitn}}\,({\it{opd\/}}, {\it{tmp\/}} $-\;1$)\index{bitn}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxr-z} \\  
\=\+{\rm{roxr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{roxr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxr-n} \\  
{\rm{roxr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-n} $=$ {\rm{bitn}}\,({\rm{roxr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr}, {\it{len\/}} $-\;1$)\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxr-cvznx} \\  
\=\+{\rm{roxr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{roxr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-c}, \\ 
{\sc{b0}}\index{b0}, \\ 
{\rm{roxr-z}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-z}, \\ 
{\rm{roxr-n}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-n}, \\ 
{\rm{roxr-c}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{x\/}})\index{roxr-c})\-\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{roxr-effect} \\  
\=\+{\rm{roxr-effect}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\it{ccr\/}})\index{roxr-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{roxr}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{roxr}, {\rm{roxr-cvznx}}\,({\it{len\/}}, {\it{opd\/}}, {\it{cnt\/}}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{roxr-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{register-roxr-ins} \\  
\=\+{\rm{register-roxr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-roxr-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{roxr-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{sr-cnt}}\,({\it{ins\/}}, {\it{s\/}})\index{sr-cnt}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{roxr-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 Memory ROXL instruction.
\begin{tabbing}{\sc Definition}:\index{mem-roxl-effect} \\  
{\rm{mem-roxl-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-roxl-effect} $=$ {\rm{roxl-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{roxl-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-roxl-ins} \\  
\=\+{\rm{mem-roxl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-roxl-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-roxl-effect}}\,(\=\+{\rm{operand}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-roxl-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Memory ROXR instruction.
\begin{tabbing}{\sc Definition}:\index{mem-roxr-effect} \\  
{\rm{mem-roxr-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{mem-roxr-effect} $=$ {\rm{roxr-effect}}\,({\sc{w}}\index{w}, {\it{opd\/}}, {\tt{1}}, {\it{ccr\/}})\index{roxr-effect}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mem-roxr-ins} \\  
\=\+{\rm{mem-roxr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-roxr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\&r-addr-modep}}\,({\it{ins\/}})\index{s\&r-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{mem-roxr-effect}}\,(\=\+{\rm{operand}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{mem-roxr-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Memory shift/rotate.
\begin{tabbing}{\sc Definition}:\index{memory-shift-rotate} \\  
\=\+{\rm{memory-shift-rotate}}\,({\it{ins\/}}, {\it{s\/}})\index{memory-shift-rotate} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{mem-asr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-asr-ins} \\ 
{\bf else }{\rm{mem-asl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-asl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{mem-lsr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-lsr-ins} \\ 
{\bf else }{\rm{mem-lsl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-lsl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{mem-roxr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-roxr-ins} \\ 
{\bf else }{\rm{mem-roxl-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-roxl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{mem-ror-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-ror-ins} \\ 
{\bf else }{\rm{mem-rol-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{mem-rol-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 Register shift/rotate.
\begin{tabbing}{\sc Definition}:\index{register-shift-rotate} \\  
\=\+{\rm{register-shift-rotate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-shift-rotate} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{4}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{3}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{register-asr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-asr-ins} \\ 
{\bf else }{\rm{register-asl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-asl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{register-lsr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-lsr-ins} \\ 
{\bf else }{\rm{register-lsl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-lsl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{3}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{register-roxr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-roxr-ins} \\ 
{\bf else }{\rm{register-roxl-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-roxl-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{register-ror-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-ror-ins} \\ 
{\bf else }{\rm{register-rol-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{register-rol-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 The bit field instruction group consists of BFxxx instructions. All of
 these instructions are new in the MC68020.  Note that bit 15 in the 
 extension word has to be 0!
\begin{tabbing}{\sc Definition}:\index{bf-subgroup} \\  
{\rm{bf-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{bf-subgroup} $=$ {\rm{halt}}\,({\tt{'}}{\tt{i-will-do-it-later}}, {\it{s\/}})\index{halt}
\end{tabbing}

 Opcode 1110.
 The shift/rotate instruction group includes the ASL/ASR, LSL/LSR, ROL/ROR,
 ROXL/RORL, BFTST, BFEXTU, BFCHG, BFEXTS, BFCLR, BFFFO, BFSET, and BFINS
 instructions.  But it actually divides into many varieties of these
 instructions.
\begin{tabbing}{\sc Definition}:\index{s\&r-group} \\  
\=\+{\rm{s\&r-group}}\,({\it{ins\/}}, {\it{s\/}})\index{s\&r-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{11}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{memory-shift-rotate}}\,({\it{ins\/}}, {\it{s\/}})\index{memory-shift-rotate} \\ 
{\bf else }{\rm{bf-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{bf-subgroup}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{register-shift-rotate}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{register-shift-rotate}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVE instruction.
\begin{tabbing}{\sc Definition}:\index{move-addr-modep} \\  
\=\+{\rm{move-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{move-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{data-addr-modep}}\,({\rm{d\_mode}}\,({\it{ins\/}})\index{d\_mode}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{d\_mode}}\,({\it{ins\/}})\index{d\_mode}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-z} \\  
\=\+{\rm{move-z}}\,({\it{oplen\/}}, {\it{sopd\/}})\index{move-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{head}}\,({\it{sopd\/}}, {\it{oplen\/}})\index{head} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-n}$\;\;$
{\rm{move-n}}\,({\it{oplen\/}}, {\it{sopd\/}})\index{move-n} $=$ {\rm{mbit}}\,({\it{sopd\/}}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

 The definition of cvznx-flags of MOVE instruction.  It is also used in
 TST and TAS instructions.
\begin{tabbing}{\sc Definition}:\index{move-cvznx} \\  
\=\+{\rm{move-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{ccr\/}})\index{move-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{move-z}}\,({\it{oplen\/}}, {\it{sopd\/}})\index{move-z}, {\rm{move-n}}\,({\it{oplen\/}}, {\it{sopd\/}})\index{move-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-effect} \\  
{\rm{move-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{ccr\/}})\index{move-effect} $=$ {\rm{cons}}\,({\it{sopd\/}}, {\rm{move-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{ccr\/}})\index{move-cvznx})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-mapping} \\  
\=\+{\rm{move-mapping}}\,({\it{sopd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{move-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\it{oplen\/}}, {\rm{d\_mode}}\,({\it{ins\/}})\index{d\_mode}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{move-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{move-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}
      
\begin{tabbing}{\sc Definition}:\index{move-ins} \\  
\=\+{\rm{move-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{move-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{move-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{move-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{move-mapping}}\,(\=\+{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\it{oplen\/}}, \\ 
{\it{ins\/}}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{move-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVEA instruction.
 MOVEA differs from MOVE in several ways:  ccr is not affected and word
 operation is sign-extended.  Therefore, we define it separately.
\begin{tabbing}{\sc Definition}:\index{movea-addr-modep} \\  
{\rm{movea-addr-modep}}\,({\it{ins\/}})\index{movea-addr-modep} $=$ {\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movea-ins} \\  
\=\+{\rm{movea-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movea-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{movea-addr-modep}}\,({\it{ins\/}})\index{movea-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{ext}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\sc{l}}\index{l})\-\index{ext}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{write-an}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0010 and 0011.
 The following definition is defined to distinguish MOVE and MOVEA
 instructions.  This definition is only for word and long operations.
\begin{tabbing}{\sc Definition}:\index{move-group} \\  
\=\+{\rm{move-group}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{move-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{d\_mode}}\,({\it{ins\/}})\index{d\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{movea-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movea-ins} \\ 
{\bf else }{\rm{move-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{move-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 LEA instruction.
\begin{tabbing}{\sc Definition}:\index{lea-addr-modep} \\  
{\rm{lea-addr-modep}}\,({\it{ins\/}})\index{lea-addr-modep} $=$ {\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep}
\end{tabbing}

 `lea-ins' calls `effec-addr', instead of `mc-instate', since the effective
 address is JUST what we need.  Notice that LEA and PEA only deal with
 memory address.  The address direct modes are not allowed.
 Operation size: long.
\begin{tabbing}{\sc Definition}:\index{lea-ins} \\  
\=\+{\rm{lea-ins}}\,({\it{smode\/}}, {\it{ins\/}}, {\it{s\/}})\index{lea-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{lea-addr-modep}}\,({\it{ins\/}})\index{lea-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\sc{l}}\index{l}, {\it{smode\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{write-an}}\,({\sc{l}}\index{l}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\rm{car}}\,({\it{s\&addr\/}}))\index{write-an}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 EXTB instruction.
 Sign-extend a byte to a longword.  It is new in the MC68020.
\begin{tabbing}{\sc Definition}:\index{ext-z} \\  
\=\+{\rm{ext-z}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{ext}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ext-n} \\  
{\rm{ext-n}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext-n} $=$ {\rm{mbit}}\,({\rm{ext}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext}, {\it{size\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ext-cvznx} \\  
\=\+{\rm{ext-cvznx}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}}, {\it{ccr\/}})\index{ext-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{ext-z}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext-z}, {\rm{ext-n}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ext-effect} \\  
\=\+{\rm{ext-effect}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}}, {\it{ccr\/}})\index{ext-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{ext}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}})\index{ext}, {\rm{ext-cvznx}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{size\/}}, {\it{ccr\/}})\index{ext-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{extb-ins} \\  
\=\+{\rm{extb-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{extb-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{ext-effect}}\,({\sc{b}}\index{b}, {\rm{read-dn}}\,({\sc{b}}\index{b}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{ext-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}\-
\end{tabbing}

 The LEA instruction subgroup includes LEA and EXTB instructions.
\begin{tabbing}{\sc Definition}:\index{lea-subgroup} \\  
\=\+{\rm{lea-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{lea-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}} \\ 
{\bf then }\=\+{\bf if }{\rm{bits}}\,({\it{ins\/}}, {\tt{9}}, {\tt{11}})\index{bits} $=$ {\tt{4}}$\;\;${\bf then }{\rm{extb-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{extb-ins} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{lea-ins}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\it{ins\/}}, {\it{s\/}})\index{lea-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 CLR instruction.
\begin{tabbing}{\sc Definition}:\index{clr-addr-modep} \\  
\=\+{\rm{clr-addr-modep}}\,({\it{ins\/}})\index{clr-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{clr-cvznx}$\;\;$
{\rm{clr-cvznx}}\,({\it{ccr\/}})\index{clr-cvznx} $=$ {\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\sc{b1}}\index{b1}, {\sc{b0}}\index{b0}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{clr-effect}$\;\;$
{\rm{clr-effect}}\,({\it{ccr\/}})\index{clr-effect} $=$ {\rm{cons}}\,({\tt{0}}, {\rm{clr-cvznx}}\,({\it{ccr\/}})\index{clr-cvznx})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{clr-ins} \\  
\=\+{\rm{clr-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{clr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{clr-addr-modep}}\,({\it{ins\/}})\index{clr-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,({\it{oplen\/}}, {\rm{clr-effect}}\,({\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{clr-effect}, {\it{s\&addr\/}})\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVE from CCR instruction.
\begin{tabbing}{\sc Definition}:\index{move-from-ccr-addr-modep} \\  
\=\+{\rm{move-from-ccr-addr-modep}}\,({\it{ins\/}})\index{move-from-ccr-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

 This instruction has no effect on CCR. Therefore, the original CCR is
 copied for the updating.  This is intended to have a uniform treatment
 for cvznx-flags.  It makes it possible to use one theorem to characterize
 the action.
\begin{tabbing}{\sc Definition}:\index{move-from-ccr-effect}$\;\;$
{\rm{move-from-ccr-effect}}\,({\it{ccr\/}})\index{move-from-ccr-effect} $=$ {\rm{cons}}\,({\it{ccr\/}}, {\it{ccr\/}})
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-from-ccr-ins} \\  
\=\+{\rm{move-from-ccr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{move-from-ccr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{move-from-ccr-addr-modep}}\,({\it{ins\/}})\index{move-from-ccr-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{move-from-ccr-effect}}\,({\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{move-from-ccr-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The CLR instruction subgroup includes CLR and MOVE from CCR instructions.
\begin{tabbing}{\sc Definition}:\index{clr-subgroup} \\  
\=\+{\rm{clr-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{clr-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{move-from-ccr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{move-from-ccr-ins} \\ 
{\bf else }{\rm{clr-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{clr-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 NEGX instruction.
\begin{tabbing}{\sc Definition}:\index{negx-addr-modep} \\  
\=\+{\rm{negx-addr-modep}}\,({\it{ins\/}})\index{negx-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{negx-ins} \\  
\=\+{\rm{negx-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{negx-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{negx-addr-modep}}\,({\it{ins\/}})\index{negx-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{subx-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\tt{0}}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{subx-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The NEGX instruction subgroup includes the NEGX instruction.
 Detect MOVE from SR.
\begin{tabbing}{\sc Definition}:\index{negx-subgroup} \\  
\=\+{\rm{negx-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{negx-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{move-from-sr-privileged}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{negx-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{negx-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 NEG instruction.
\begin{tabbing}{\sc Definition}:\index{neg-addr-modep} \\  
\=\+{\rm{neg-addr-modep}}\,({\it{ins\/}})\index{neg-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{neg-ins} \\  
\=\+{\rm{neg-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{neg-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{neg-addr-modep}}\,({\it{ins\/}})\index{neg-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{sub-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\tt{0}})\-\index{sub-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVE to CCR instruction.
\begin{tabbing}{\sc Definition}:\index{move-to-ccr-addr-modep} \\  
{\rm{move-to-ccr-addr-modep}}\,({\it{ins\/}})\index{move-to-ccr-addr-modep} $=$ {\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{move-to-ccr-ins} \\  
\=\+{\rm{move-to-ccr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{move-to-ccr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{move-to-ccr-addr-modep}}\,({\it{ins\/}})\index{move-to-ccr-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{head}}\,({\rm{operand}}\,({\sc{w}}\index{w}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, {\sc{b}}\index{b})\index{head}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The NEG instruction subgroup includes NEG and MOVE to CCR instructions.
\begin{tabbing}{\sc Definition}:\index{neg-subgroup} \\  
\=\+{\rm{neg-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{neg-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{move-to-ccr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{move-to-ccr-ins} \\ 
{\bf else }{\rm{neg-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{neg-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 PEA instruction.
\begin{tabbing}{\sc Definition}:\index{pea-addr-modep} \\  
{\rm{pea-addr-modep}}\,({\it{ins\/}})\index{pea-addr-modep} $=$ {\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{pea-ins} \\  
\=\+{\rm{pea-ins}}\,({\it{smode\/}}, {\it{ins\/}}, {\it{s\/}})\index{pea-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pea-addr-modep}}\,({\it{ins\/}})\index{pea-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\sc{l}}\index{l}, {\it{smode\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{push-sp}}\,({\sc{lsz}}\index{lsz}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{push-sp}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 SWAP instruction.
\begin{tabbing}{\sc Definition}:\index{swap-z} \\  
\=\+{\rm{swap-z}}\,({\it{opd\/}})\index{swap-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{fix}}\,({\it{opd\/}}) $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{swap-n}$\;\;$
{\rm{swap-n}}\,({\it{opd\/}})\index{swap-n} $=$ {\rm{bitn}}\,({\it{opd\/}}, {\tt{15}})\index{bitn}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{swap-cvznx} \\  
{\rm{swap-cvznx}}\,({\it{opd\/}}, {\it{ccr\/}})\index{swap-cvznx} $=$ {\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{swap-z}}\,({\it{opd\/}})\index{swap-z}, {\rm{swap-n}}\,({\it{opd\/}})\index{swap-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{swap-effect} \\  
\=\+{\rm{swap-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{swap-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{app}}\,({\sc{w}}\index{w}, {\rm{tail}}\,({\it{opd\/}}, {\sc{w}}\index{w})\index{tail}, {\rm{head}}\,({\it{opd\/}}, {\sc{w}}\index{w})\index{head})\index{app}, {\rm{swap-cvznx}}\,({\it{opd\/}}, {\it{ccr\/}})\index{swap-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{swap-ins} \\  
\=\+{\rm{swap-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{swap-ins} \\ 
$=$$\;\;\;\;${\rm{d-mapping}}\,({\sc{l}}\index{l}, {\rm{swap-effect}}\,({\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{swap-effect}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{d-mapping}\-
\end{tabbing}

 The PEA instruction subgroup includes PEA and SWAP.
 Detect BKPT.
\begin{tabbing}{\sc Definition}:\index{pea-subgroup} \\  
\=\+{\rm{pea-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{pea-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{swap-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{swap-ins} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{bkpt-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{pea-ins}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\it{ins\/}}, {\it{s\/}})\index{pea-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 EXT instruction.
\begin{tabbing}{\sc Definition}:\index{ext-ins} \\  
\=\+{\rm{ext-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{ext-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{d-mapping}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{ext-effect}}\,({\sc{b}}\index{b}, {\rm{read-dn}}\,({\sc{b}}\index{b}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, {\sc{w}}\index{w}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{ext-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping} \\ 
{\bf else }{\rm{d-mapping}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{ext-effect}}\,({\sc{w}}\index{w}, {\rm{read-dn}}\,({\sc{w}}\index{w}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-dn}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{ext-effect}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVEM Rn to EA instruction.
 A pair of functions for multiple read/write on memory.
\begin{tabbing}{\sc Definition}:\index{readm-mem} \\  
\=\+{\rm{readm-mem}}\,({\it{opsz\/}}, {\it{addr\/}}, {\it{mem\/}}, {\it{n\/}})\index{readm-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{nil}} \\ 
{\bf else }{\rm{cons}}\,(\=\+{\rm{read-mem}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{opsz\/}})\index{read-mem}, \\ 
{\rm{readm-mem}}\,({\it{opsz\/}}, {\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\it{opsz\/}})\index{add}, {\it{mem\/}}, {\it{n\/}} $-\;1$)\index{readm-mem})\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{writem-mem} \\  
\=\+{\rm{writem-mem}}\,({\it{opsz\/}}, {\it{vlst\/}}, {\it{addr\/}}, {\it{mem\/}})\index{writem-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{vlst\/}}) \\ 
{\bf then }{\rm{writem-mem}}\,(\=\+{\it{opsz\/}}, \\ 
{\rm{cdr}}\,({\it{vlst\/}}), \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\it{opsz\/}})\index{add}, \\ 
{\rm{write-mem}}\,({\rm{car}}\,({\it{vlst\/}}), {\it{addr\/}}, {\it{mem\/}}, {\it{opsz\/}})\index{write-mem})\-\index{writem-mem} \\ 
{\bf else }{\it{mem\/}}$\;${\bf  endif}\-\-
\end{tabbing}

 A pair of functions for multiple read/write on the register file.
\begin{tabbing}{\sc Definition}:\index{readm-rn} \\  
\=\+{\rm{readm-rn}}\,({\it{oplen\/}}, {\it{rnlst\/}}, {\it{rfile\/}})\index{readm-rn} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{rnlst\/}}) \\ 
{\bf then }{\rm{cons}}\,(\=\+{\rm{read-rn}}\,({\it{oplen\/}}, {\rm{car}}\,({\it{rnlst\/}}), {\it{rfile\/}})\index{read-rn}, \\ 
{\rm{readm-rn}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{rnlst\/}}), {\it{rfile\/}})\index{readm-rn})\- \\ 
{\bf else }{\bf{nil}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{writem-rn} \\  
\=\+{\rm{writem-rn}}\,({\it{oplen\/}}, {\it{vlst\/}}, {\it{rnlst\/}}, {\it{rfile\/}})\index{writem-rn} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{rnlst\/}}) \\ 
{\bf then }{\rm{writem-rn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{vlst\/}}), \\ 
{\rm{cdr}}\,({\it{rnlst\/}}), \\ 
{\rm{write-rn}}\,({\sc{l}}\index{l}, {\rm{ext}}\,({\it{oplen\/}}, {\rm{car}}\,({\it{vlst\/}}), {\sc{l}}\index{l})\index{ext}, {\rm{car}}\,({\it{rnlst\/}}), {\it{rfile\/}})\index{write-rn})\-\index{writem-rn} \\ 
{\bf else }{\it{rfile\/}}$\;${\bf  endif}\-\-
\end{tabbing}

 A list of the number of registers to be moved.
\begin{tabbing}{\sc Definition}:\index{movem-rnlst} \\  
\=\+{\rm{movem-rnlst}}\,({\it{mask\/}}, {\it{i\/}})\index{movem-rnlst} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mask\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{nil}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bcar}}\,({\it{mask\/}})\index{bcar})\index{b0p}$\;\;${\bf then }{\rm{movem-rnlst}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr}, $1\;+$ {\it{i\/}})\index{movem-rnlst} \\ 
{\bf else }{\rm{cons}}\,({\it{i\/}}, {\rm{movem-rnlst}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr}, $1\;+$ {\it{i\/}})\index{movem-rnlst})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movem-len} \\  
\=\+{\rm{movem-len}}\,({\it{mask\/}})\index{movem-len} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mask\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\tt{0}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bcar}}\,({\it{mask\/}})\index{bcar})\index{b0p}$\;\;${\bf then }{\rm{movem-len}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr})\index{movem-len} \\ 
{\bf else }$1\;+$ {\rm{movem-len}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr})\index{movem-len}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{writemp} \\  
\=\+{\rm{writemp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{addr\/}}, {\it{mem\/}})\index{writemp} \\ 
$=$$\;\;\;\;${\rm{write-memp}}\,({\it{addr\/}}, {\it{mem\/}}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz} $*$ {\rm{movem-len}}\,({\it{mask\/}})\index{movem-len})\index{write-memp}\-
\end{tabbing}

 In the case of predecrement, there are a few things we have to treat
 separately.
 The order of the mask is the reverse of the other cases.
\begin{tabbing}{\sc Definition}:\index{movem-pre-rnlst} \\  
\=\+{\rm{movem-pre-rnlst}}\,({\it{mask\/}}, {\it{i\/}}, {\it{lst\/}})\index{movem-pre-rnlst} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{mask\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\it{lst\/}} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bcar}}\,({\it{mask\/}})\index{bcar})\index{b0p}$\;\;${\bf then }{\rm{movem-pre-rnlst}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr}, {\it{i\/}} $-\;1$, {\it{lst\/}})\index{movem-pre-rnlst} \\ 
{\bf else }{\rm{movem-pre-rnlst}}\,({\rm{bcdr}}\,({\it{mask\/}})\index{bcdr}, {\it{i\/}} $-\;1$, {\rm{cons}}\,({\it{i\/}}, {\it{lst\/}}))\index{movem-pre-rnlst}$\;${\bf  endif}\-\-
\end{tabbing}

 The reason we modify the address register {\it{rn\/}} here is that if it is also moved to memory, it
 is changed before it is moved.  This function returns a `cons':  the
 first element is an intermediate state with the address register {\it{rn\/}} changed, the second
 element is the starting memory address to move those registers.
\begin{tabbing}{\sc Definition}:\index{movem-predec} \\  
\=\+{\rm{movem-predec}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{rn\/}}, {\it{s\/}})\index{movem-predec} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{addr\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{rn\/}}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
{\rm{cons}}\,(\=\+{\rm{write-an}}\,({\sc{l}}\index{l}, {\rm{pre-effect}}\,({\it{oplen\/}}, {\it{rn\/}}, {\it{addr\/}})\index{pre-effect}, {\it{rn\/}}, {\it{s\/}})\index{write-an}, \\ 
{\rm{cons}}\,({\tt{'}}{\tt{m}}, {\rm{sub}}\,({\sc{l}}\index{l}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz} $*$ {\rm{movem-len}}\,({\it{mask\/}})\index{movem-len}, {\it{addr\/}})\index{sub}))\-$\;${\bf  endlet}\-\-
\end{tabbing}

 The addressing modes are control alterable plus predecrement.  We
 deal with -(An) separately.
\begin{tabbing}{\sc Definition}:\index{movem-rn-ea-addr-modep} \\  
\=\+{\rm{movem-rn-ea-addr-modep}}\,({\it{ins\/}})\index{movem-rn-ea-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep})\-\-
\end{tabbing}

 Note in the predecrement mode, if mask = 0, there is no action on An.
\begin{tabbing}{\sc Definition}:\index{movem-rn-ea-ins} \\  
\=\+{\rm{movem-rn-ea-ins}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movem-rn-ea-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{predec-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{predec-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{movem-predec}}\,({\it{mask\/}}, {\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{movem-predec}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{writemp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{writemp} \\ 
{\bf then }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{cddr}}\,({\it{s\&addr\/}}), \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\rm{update-mem}}\,(\=\+{\rm{writem-mem}}\,(\=\+{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz}, \\ 
{\rm{readm-rn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{movem-pre-rnlst}}\,(\=\+{\it{mask\/}}, \\ 
{\tt{15}}, \\ 
{\bf{nil}})\-\index{movem-pre-rnlst}, \\ 
{\rm{mc-rfile}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-rfile})\-\index{readm-rn}, \\ 
{\rm{cddr}}\,({\it{s\&addr\/}}), \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\-\index{writem-mem}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-mem})\-\index{write-an} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf elseif }{\rm{movem-rn-ea-addr-modep}}\,({\it{ins\/}})\index{movem-rn-ea-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf elseif }{\rm{writemp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{writemp} \\ 
{\bf then }{\rm{update-mem}}\,(\=\+{\rm{writem-mem}}\,(\=\+{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz}, \\ 
{\rm{readm-rn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{movem-rnlst}}\,({\it{mask\/}}, {\tt{0}})\index{movem-rnlst}, \\ 
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\-\index{readm-rn}, \\ 
{\rm{cddr}}\,({\it{s\&addr\/}}), \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\-\index{writem-mem}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-mem} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The EXT instruction subgroup includes EXT and MOVEM Rn to EA.
\begin{tabbing}{\sc Definition}:\index{ext-subgroup} \\  
\=\+{\rm{ext-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{ext-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{0}}$\;\;${\bf then }{\rm{ext-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{ext-ins} \\ 
{\bf elseif }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{movem-rn-ea-ins}}\,(\=\+{\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p}$\;\;${\bf then }{\sc{w}}\index{w} \\ 
{\bf else }{\sc{l}}\index{l}$\;${\bf  endif}\-, \\ 
{\it{ins\/}}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{movem-rn-ea-ins} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 TST instruction.
 MC68020 and MC68000 differ about addressing modes.
\begin{tabbing}{\sc Definition}:\index{tst-addr-modep} \\  
\=\+{\rm{tst-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{tst-addr-modep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b}$\;\;${\bf then }{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
{\bf else }{\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{tst-ins} \\  
\=\+{\rm{tst-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{tst-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{tst-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{tst-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{move-cvznx}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{move-cvznx}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 TAS instruction.
 It is usually used as a multiprocessor operation. 
\begin{tabbing}{\sc Definition}:\index{tas-addr-modep} \\  
\=\+{\rm{tas-addr-modep}}\,({\it{ins\/}})\index{tas-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{tas-effect} \\  
{\rm{tas-effect}}\,({\it{opd\/}}, {\it{ccr\/}})\index{tas-effect} $=$ {\rm{cons}}\,({\rm{setn}}\,({\it{opd\/}}, {\tt{7}}, {\sc{b1}}\index{b1})\index{setn}, {\rm{move-cvznx}}\,({\sc{b}}\index{b}, {\it{opd\/}}, {\it{ccr\/}})\index{move-cvznx})
\end{tabbing}

 The opsize of the TAS instruction is byte.
\begin{tabbing}{\sc Definition}:\index{tas-ins} \\  
\=\+{\rm{tas-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{tas-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{tas-addr-modep}}\,({\it{ins\/}})\index{tas-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{b}}\index{b}, \\ 
{\rm{tas-effect}}\,(\=\+{\rm{operand}}\,({\sc{b}}\index{b}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{tas-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The TST instruction subgroup includes TAS and TST.
 Detect ILLEGAL instruction.
\begin{tabbing}{\sc Definition}:\index{tst-subgroup} \\  
\=\+{\rm{tst-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{tst-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q} \\ 
{\bf then }\=\+{\bf if }{\rm{head}}\,({\it{ins\/}}, {\tt{6}})\index{head} $=$ {\tt{60}}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{illegal-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{tas-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{tas-ins}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{tst-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{tst-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 DIVS\_L instructions.  D / S $\rightarrow$ D.
 32/32 $\rightarrow$ 32q,  32/32 $\rightarrow$ 32r:32q.  The order of 
 write-dn:  remainder first, and then quotient.  The overflow happens 
 only when the {\it{dopd\/}} is $-2^{31}$ and {\it{sopd\/}} is $-1$.
\begin{tabbing}{\sc Definition}:\index{divsl\_l} \\  
\=\+{\rm{divsl\_l}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dq\/}}, {\it{dr\/}}, {\it{s\/}})\index{divsl\_l} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{divs-v}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{divs-v})\index{b0p} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{q\/}}{\bf $\;$ be$\;\;$}{\rm{iquot}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{iquot}, \\ 
{\it{r\/}}{\bf $\;$ be$\;\;$}{\rm{irem}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{irem}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{divs-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{divs-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{q\/}}, {\it{dq\/}}, {\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{r\/}}, {\it{dr\/}}, {\it{s\/}})\index{write-dn})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{divs-overflow}}, {\rm{update-ccr}}\,({\rm{set-v}}\,({\sc{b1}}\index{b1}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-v}, {\it{s\/}})\index{update-ccr})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 64/32 $\rightarrow$ 32r:32q.
\begin{tabbing}{\sc Definition}:\index{divs\_l} \\  
\=\+{\rm{divs\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\it{dq\/}}, {\it{dr\/}}, {\it{s\/}})\index{divs\_l} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{app}}\,({\sc{l}}\index{l}, {\it{dopd\_low\/}}, {\rm{read-dn}}\,({\sc{l}}\index{l}, {\it{dr\/}}, {\it{s\/}})\index{read-dn})\index{app}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{divs-v}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{q}}\index{q})\index{divs-v})\index{b0p} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{q\/}}{\bf $\;$ be$\;\;$}{\rm{iquot}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{q}}\index{q})\index{iquot}, \\ 
{\it{r\/}}{\bf $\;$ be$\;\;$}{\rm{irem}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{q}}\index{q})\index{irem}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{divs-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\sc{l}}\index{l}, {\it{dopd\/}}, {\sc{q}}\index{q}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{divs-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{q\/}}, {\it{dq\/}}, {\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{r\/}}, {\it{dr\/}}, {\it{s\/}})\index{write-dn})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,(\=\+{\tt{'}}{\tt{divs-overflow}}, \\ 
{\rm{update-ccr}}\,({\rm{set-v}}\,({\sc{b1}}\index{b1}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-v}, {\it{s\/}})\index{update-ccr})\-\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 DIVU\_L instructions.  D / S $\rightarrow$ D.
 32/32 $\rightarrow$ 32q,  32/32 $\rightarrow$ 32r:32q.  In this case, 
 overflow never happens!  It is justified by the event quotient-nat-rangep.
\begin{tabbing}{\sc Definition}:\index{divul\_l} \\  
\=\+{\rm{divul\_l}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dq\/}}, {\it{dr\/}}, {\it{s\/}})\index{divul\_l} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{q\/}}{\bf $\;$ be$\;\;$}{\rm{quot}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}})\index{quot}, \\ 
{\it{r\/}}{\bf $\;$ be$\;\;$}{\rm{rem}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}})\index{rem}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{divu-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{divu-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{q\/}}, {\it{dq\/}}, {\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{r\/}}, {\it{dr\/}}, {\it{s\/}})\index{write-dn})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\-\-
\end{tabbing}

 64/32 $\rightarrow$ 32r:32q.
\begin{tabbing}{\sc Definition}:\index{divu\_l} \\  
\=\+{\rm{divu\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\it{dq\/}}, {\it{dr\/}}, {\it{s\/}})\index{divu\_l} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{app}}\,({\sc{l}}\index{l}, {\it{dopd\_low\/}}, {\rm{read-dn}}\,({\sc{l}}\index{l}, {\it{dr\/}}, {\it{s\/}})\index{read-dn})\index{app}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{divu-v}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}})\index{divu-v})\index{b0p} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{q\/}}{\bf $\;$ be$\;\;$}{\rm{quot}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}})\index{quot}, \\ 
{\it{r\/}}{\bf $\;$ be$\;\;$}{\rm{rem}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}})\index{rem}\- \\ 
{\bf in} \\ 
{\rm{update-ccr}}\,(\=\+{\rm{divu-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{divu-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{q\/}}, {\it{dq\/}}, {\rm{write-dn}}\,({\sc{l}}\index{l}, {\it{r\/}}, {\it{dr\/}}, {\it{s\/}})\index{write-dn})\index{write-dn})\-\index{update-ccr}$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,(\=\+{\tt{'}}{\tt{divu-overflow}}, \\ 
{\rm{update-ccr}}\,({\rm{set-v}}\,({\sc{b1}}\index{b1}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{set-v}, {\it{s\/}})\index{update-ccr})\-\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{dq}$\;\;$
{\rm{dq}}\,({\it{word\/}})\index{dq} $=$ {\rm{bits}}\,({\it{word\/}}, {\tt{12}}, {\tt{14}})\index{bits}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{dr}$\;\;$
{\rm{dr}}\,({\it{word\/}})\index{dr} $=$ {\rm{bits}}\,({\it{word\/}}, {\tt{0}}, {\tt{2}})\index{bits}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{div\_l-ins} \\  
\=\+{\rm{div\_l-ins}}\,({\it{sopd\/}}, {\it{word\/}}, {\it{s\/}})\index{div\_l-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\_low\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{dq}}\,({\it{word\/}})\index{dq}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{nat-to-uint}}\,({\it{sopd\/}})\index{nat-to-uint} $=$ {\tt{0}} \\ 
{\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trap-exception}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{divul\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\rm{dq}}\,({\it{word\/}})\index{dq}, {\rm{dr}}\,({\it{word\/}})\index{dr}, {\it{s\/}})\index{divul\_l} \\ 
{\bf else }{\rm{divu\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\rm{dq}}\,({\it{word\/}})\index{dq}, {\rm{dr}}\,({\it{word\/}})\index{dr}, {\it{s\/}})\index{divu\_l}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{nat-to-int}}\,({\it{sopd\/}}, {\sc{l}}\index{l})\index{nat-to-int} $=$ {\tt{0}} \\ 
{\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trap-exception}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{divsl\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\rm{dq}}\,({\it{word\/}})\index{dq}, {\rm{dr}}\,({\it{word\/}})\index{dr}, {\it{s\/}})\index{divsl\_l} \\ 
{\bf else }{\rm{divs\_l}}\,({\it{sopd\/}}, {\it{dopd\_low\/}}, {\rm{dq}}\,({\it{word\/}})\index{dq}, {\rm{dr}}\,({\it{word\/}})\index{dr}, {\it{s\/}})\index{divs\_l}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}
     
 MULS/MULU-long instructions.  S * D $\rightarrow$ D.
\begin{tabbing}{\sc Definition}:\index{mulu\_l\_dl} \\  
\=\+{\rm{mulu\_l\_dl}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dl\/}}, {\it{s\/}})\index{mulu\_l\_dl} \\ 
$=$$\;\;\;\;${\rm{update-ccr}}\,(\=\+{\rm{mulu-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{mulu-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\rm{mulu}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{mulu}, {\it{dl\/}}, {\it{s\/}})\index{write-dn})\-\index{update-ccr}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mulu\_l\_dldh} \\  
\=\+{\rm{mulu\_l\_dldh}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dl\/}}, {\it{dh\/}}, {\it{s\/}})\index{mulu\_l\_dldh} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{dl\/}} $=$ {\it{dh\/}}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{mc-undefined}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{mulu-cvznx}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{mulu-cvznx}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{tail}}\,({\rm{mulu}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{mulu}, {\sc{l}}\index{l})\index{tail}, \\ 
{\it{dh\/}}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{head}}\,({\rm{mulu}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{mulu}, {\sc{l}}\index{l})\index{head}, \\ 
{\it{dl\/}}, \\ 
{\it{s\/}})\-\index{write-dn})\-\index{write-dn})\-\index{update-ccr}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls\_l\_dl} \\  
\=\+{\rm{muls\_l\_dl}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dl\/}}, {\it{s\/}})\index{muls\_l\_dl} \\ 
$=$$\;\;\;\;${\rm{update-ccr}}\,(\=\+{\rm{muls-cvznx}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{muls-cvznx}, \\ 
{\rm{write-dn}}\,({\sc{l}}\index{l}, {\rm{muls}}\,({\sc{l}}\index{l}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{muls}, {\it{dl\/}}, {\it{s\/}})\index{write-dn})\-\index{update-ccr}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{muls\_l\_dldh} \\  
\=\+{\rm{muls\_l\_dldh}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\it{dl\/}}, {\it{dh\/}}, {\it{s\/}})\index{muls\_l\_dldh} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{dl\/}} $=$ {\it{dh\/}}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{mc-undefined}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{muls-cvznx}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{muls-cvznx}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{tail}}\,({\rm{muls}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{muls}, {\sc{l}}\index{l})\index{tail}, \\ 
{\it{dh\/}}, \\ 
{\rm{write-dn}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{head}}\,({\rm{muls}}\,({\sc{q}}\index{q}, {\it{sopd\/}}, {\it{dopd\/}}, {\sc{l}}\index{l})\index{muls}, {\sc{l}}\index{l})\index{head}, \\ 
{\it{dl\/}}, \\ 
{\it{s\/}})\-\index{write-dn})\-\index{write-dn})\-\index{update-ccr}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{dl}$\;\;$
{\rm{dl}}\,({\it{word\/}})\index{dl} $=$ {\rm{bits}}\,({\it{word\/}}, {\tt{12}}, {\tt{14}})\index{bits}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{dh}$\;\;$
{\rm{dh}}\,({\it{word\/}})\index{dh} $=$ {\rm{bits}}\,({\it{word\/}}, {\tt{0}}, {\tt{2}})\index{bits}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mul\_l-ins} \\  
\=\+{\rm{mul\_l-ins}}\,({\it{sopd\/}}, {\it{word\/}}, {\it{s\/}})\index{mul\_l-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{dopd\/}}{\bf $\;$ be$\;\;$}{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{dl}}\,({\it{word\/}})\index{dl}, {\it{s\/}})\index{read-dn}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{mulu\_l\_dl}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\rm{dl}}\,({\it{word\/}})\index{dl}, {\it{s\/}})\index{mulu\_l\_dl} \\ 
{\bf else }{\rm{mulu\_l\_dldh}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\rm{dl}}\,({\it{word\/}})\index{dl}, {\rm{dh}}\,({\it{word\/}})\index{dh}, {\it{s\/}})\index{mulu\_l\_dldh}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{muls\_l\_dl}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\rm{dl}}\,({\it{word\/}})\index{dl}, {\it{s\/}})\index{muls\_l\_dl} \\ 
{\bf else }{\rm{muls\_l\_dldh}}\,({\it{sopd\/}}, {\it{dopd\/}}, {\rm{dl}}\,({\it{word\/}})\index{dl}, {\rm{dh}}\,({\it{word\/}})\index{dh}, {\it{s\/}})\index{muls\_l\_dldh}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{mul-div\_l-ins} \\  
\=\+{\rm{mul-div\_l-ins}}\,({\it{word\/}}, {\it{ins\/}}, {\it{s\/}})\index{mul-div\_l-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{word\/}}, {\tt{15}})\index{bitn})\index{b0p} $\wedge$ ({\rm{bits}}\,({\it{word\/}}, {\tt{3}}, {\tt{9}})\index{bits} $=$ {\tt{0}}) \\ 
{\bf then }\=\+{\bf if }{\rm{mul\&div-addr-modep}}\,({\it{ins\/}})\index{mul\&div-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{l}}\index{l}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }\=\+{\bf let }\=\+{\it{sopd\/}}{\bf $\;$ be$\;\;$}{\rm{operand}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{operand}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{mul\_l-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\it{word\/}}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{mul\_l-ins} \\ 
{\bf else }{\rm{div\_l-ins}}\,(\=\+{\it{sopd\/}}, \\ 
{\it{word\/}}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{div\_l-ins}$\;${\bf  endif}\-$\;${\bf  endlet}\-$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVEM EA to RN instruction.
 The addressing modes are control plus postincrement.  We deal with
 (An)+ separately.
\begin{tabbing}{\sc Definition}:\index{movem-ea-rn-addr-modep} \\  
{\rm{movem-ea-rn-addr-modep}}\,({\it{ins\/}})\index{movem-ea-rn-addr-modep} $=$ {\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{readmp} \\  
\=\+{\rm{readmp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{addr\/}}, {\it{mem\/}})\index{readmp} \\ 
$=$$\;\;\;\;${\rm{read-memp}}\,({\it{addr\/}}, {\it{mem\/}}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz} $*$ {\rm{movem-len}}\,({\it{mask\/}})\index{movem-len})\index{read-memp}\-
\end{tabbing}

 In the mode of postincrement, if the address register is also loaded
 from the memory, the value of it upon completion of this instruction
 has no difference from the other modes.
\begin{tabbing}{\sc Definition}:\index{movem-ea-rn-ins} \\  
\=\+{\rm{movem-ea-rn-ins}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movem-ea-rn-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{postinc-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{postinc-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{addr\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{readmp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{readmp} \\ 
{\bf then }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, \=\+{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz} \\ 
$*$$\;\;\;\;${\rm{movem-len}}\,({\it{mask\/}})\index{movem-len}\-)\index{add}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\rm{update-rfile}}\,(\=\+{\rm{writem-rn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{readm-mem}}\,(\=\+{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz}, \\ 
{\it{addr\/}}, \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, \\ 
{\rm{movem-len}}\,({\it{mask\/}})\index{movem-len})\-\index{readm-mem}, \\ 
{\rm{movem-rnlst}}\,({\it{mask\/}}, {\tt{0}})\index{movem-rnlst}, \\ 
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\-\index{writem-rn}, \\ 
{\it{s\/}})\-\index{update-rfile})\-\index{write-an} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf elseif }{\rm{movem-ea-rn-addr-modep}}\,({\it{ins\/}})\index{movem-ea-rn-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf elseif }{\rm{readmp}}\,({\it{mask\/}}, {\it{oplen\/}}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{readmp} \\ 
{\bf then }{\rm{update-rfile}}\,(\=\+{\rm{writem-rn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{readm-mem}}\,(\=\+{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz}, \\ 
{\rm{cddr}}\,({\it{s\&addr\/}}), \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, \\ 
{\rm{movem-len}}\,({\it{mask\/}})\index{movem-len})\-\index{readm-mem}, \\ 
{\rm{movem-rnlst}}\,({\it{mask\/}}, {\tt{0}})\index{movem-rnlst}, \\ 
{\rm{mc-rfile}}\,({\it{s\/}})\index{mc-rfile})\-\index{writem-rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-rfile} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 The MOVEM-EA-RN-SUBGROUP includes MOVEM, DIVS/U and MULS/U instructions.
\begin{tabbing}{\sc Definition}:\index{movem-ea-rn-subgroup} \\  
\=\+{\rm{movem-ea-rn-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{movem-ea-rn-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{word\/}}{\bf $\;$ be$\;\;$}{\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{7}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{mul-div\_l-ins}}\,(\=\+{\it{word\/}}, \\ 
{\it{ins\/}}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{mul-div\_l-ins} \\ 
{\bf else }{\rm{movem-ea-rn-ins}}\,(\=\+{\it{word\/}}, \\ 
\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p}$\;\;${\bf then }{\sc{w}}\index{w} \\ 
{\bf else }{\sc{l}}\index{l}$\;${\bf  endif}\-, \\ 
{\it{ins\/}}, \\ 
{\rm{update-pc}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, \\ 
{\it{s\/}})\-\index{update-pc})\-\index{movem-ea-rn-ins}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 LINK-long instruction.
 LINK and UNLK are somewhat complicated.  When sp is used as an,  the
 execution order seems different from a simple instantiation.
\begin{tabbing}{\sc Definition}:\index{link-mapping} \\  
\=\+{\rm{link-mapping}}\,({\it{an\/}}, {\it{disp\/}}, {\it{s\/}})\index{link-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{sp\/}}{\bf $\;$ be$\;\;$}{\rm{sub}}\,({\sc{l}}\index{l}, {\sc{lsz}}\index{lsz}, {\rm{read-sp}}\,({\it{s\/}})\index{read-sp})\index{sub}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{write-memp}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\sc{lsz}}\index{lsz})\index{write-memp} \\ 
{\bf then }{\rm{update-mem}}\,(\=\+{\rm{write-mem}}\,({\rm{read-an}}\,({\sc{l}}\index{l}, {\it{an\/}}, {\it{s\/}})\index{read-an}, {\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\sc{lsz}}\index{lsz})\index{write-mem}, \\ 
{\rm{write-sp}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{sp\/}}, {\it{disp\/}})\index{add}, {\rm{write-an}}\,({\sc{l}}\index{l}, {\it{sp\/}}, {\it{an\/}}, {\it{s\/}})\index{write-an})\index{write-sp})\-\index{update-mem} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{link\_l-ins} \\  
\=\+{\rm{link\_l-ins}}\,({\it{an\/}}, {\it{s\/}})\index{link\_l-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-long-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-readp} \\ 
{\bf then }{\rm{link-mapping}}\,(\=\+{\it{an\/}}, \\ 
{\rm{pc-long-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-read}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{lsz}}\index{lsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{link-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 LINK-word instruction.
\begin{tabbing}{\sc Definition}:\index{link\_w-ins} \\  
\=\+{\rm{link\_w-ins}}\,({\it{an\/}}, {\it{s\/}})\index{link\_w-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{link-mapping}}\,(\=\+{\it{an\/}}, \\ 
{\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{link-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 UNLK instruction.
\begin{tabbing}{\sc Definition}:\index{unlk-ins} \\  
\=\+{\rm{unlk-ins}}\,({\it{an\/}}, {\it{s\/}})\index{unlk-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{sp\/}}{\bf $\;$ be$\;\;$}{\rm{read-an}}\,({\sc{l}}\index{l}, {\it{an\/}}, {\it{s\/}})\index{read-an}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{long-readp}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-readp} \\ 
{\bf then }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{long-read}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-read}, \\ 
{\it{an\/}}, \\ 
{\rm{write-sp}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{sp\/}}, {\sc{lsz}}\index{lsz})\index{add}, {\it{s\/}})\index{write-sp})\-\index{write-an} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 The unlk instruction subgroup includes UNLK and LINK-word instructions.
 detect trap instruction.
\begin{tabbing}{\sc Definition}:\index{unlk-subgroup} \\  
\=\+{\rm{unlk-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{unlk-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{4}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trap-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{3}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{link\_w-ins}}\,({\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{link\_w-ins} \\ 
{\bf else }{\rm{unlk-ins}}\,({\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{unlk-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 NOP instruction.
 The machine state, except the program counter, is not affected.  But
 we have already incremented pc when we read the first word of the
 current instruction.  Therefore, we simply return s.
\begin{tabbing}{\sc Definition}:\index{nop-ins}$\;\;$
{\rm{nop-ins}}\,({\it{s\/}})\index{nop-ins} $=$ {\it{s\/}}
\end{tabbing}

 RTD instruction.
\begin{tabbing}{\sc Definition}:\index{rtd-mapping} \\  
\=\+{\rm{rtd-mapping}}\,({\it{sp\/}}, {\it{disp\/}}, {\it{s\/}})\index{rtd-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{long-readp}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-readp} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{new-sp\/}}{\bf $\;$ be$\;\;$}{\rm{add}}\,({\sc{l}}\index{l}, {\rm{add}}\,({\sc{l}}\index{l}, {\it{sp\/}}, {\sc{lsz}}\index{lsz})\index{add}, {\rm{ext}}\,({\sc{w}}\index{w}, {\it{disp\/}}, {\sc{l}}\index{l})\index{ext})\index{add}\- \\ 
{\bf in} \\ 
{\rm{update-pc}}\,({\rm{long-read}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{long-read}, {\rm{write-sp}}\,({\it{new-sp\/}}, {\it{s\/}})\index{write-sp})\index{update-pc}$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{rtd-ins} \\  
\=\+{\rm{rtd-ins}}\,({\it{s\/}})\index{rtd-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{rtd-mapping}}\,({\rm{read-sp}}\,({\it{s\/}})\index{read-sp}, {\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\it{s\/}})\index{rtd-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 RTS instruction.
 Notice that disp is 0.
\begin{tabbing}{\sc Definition}:\index{rts-ins}$\;\;$
{\rm{rts-ins}}\,({\it{s\/}})\index{rts-ins} $=$ {\rm{rtd-mapping}}\,({\rm{read-sp}}\,({\it{s\/}})\index{read-sp}, {\tt{0}}, {\it{s\/}})\index{rtd-mapping}
\end{tabbing}

 RTR instruction.
 Notice that disp is 0.
\begin{tabbing}{\sc Definition}:\index{rtr-ins} \\  
\=\+{\rm{rtr-ins}}\,({\it{s\/}})\index{rtr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{sp\/}}{\bf $\;$ be$\;\;$}{\rm{read-sp}}\,({\it{s\/}})\index{read-sp}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{word-readp}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{word-readp} \\ 
{\bf then }{\rm{rtd-mapping}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\it{sp\/}}, {\sc{wsz}}\index{wsz})\index{add}, \\ 
{\tt{0}}, \\ 
{\rm{update-ccr}}\,({\rm{word-read}}\,({\it{sp\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{word-read}, {\it{s\/}})\index{update-ccr})\-\index{rtd-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 TRAPV instruction.
 If the overflow is set, we simply halt the machine.  Otherwise, nop.
 To handle this instruction in verifications, we intend to prove the
 overflow is not set, and hence the machine performs nop.
\begin{tabbing}{\sc Definition}:\index{bvs}$\;\;$
{\rm{bvs}}\,({\it{v\/}})\index{bvs} $=$ {\rm{fix-bit}}\,({\it{v\/}})\index{fix-bit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{trapv-ins} \\  
\=\+{\rm{trapv-ins}}\,({\it{s\/}})\index{trapv-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b1p}}\,({\rm{bvs}}\,({\rm{ccr-v}}\,({\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{ccr-v})\index{bvs})\index{b1p}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trapv-exception}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\it{s\/}}$\;${\bf  endif}\-\-
\end{tabbing}

 The NOP instruction subgroup includes NOP, RTD, RTS, and RTR instructions.
 Detect RESET, STOP, RTE, and TRAPV.
\begin{tabbing}{\sc Definition}:\index{nop-subgroup} \\  
\=\+{\rm{nop-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{nop-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{2}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{1}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{0}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{reset-privileged}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{nop-ins}}\,({\it{s\/}})\index{nop-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{0}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{stop-privileged}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{rte-privileged}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{1}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{0}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{rtd-ins}}\,({\it{s\/}})\index{rtd-ins} \\ 
{\bf else }{\rm{rts-ins}}\,({\it{s\/}})\index{rts-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{0}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{trapv-ins}}\,({\it{s\/}})\index{trapv-ins} \\ 
{\bf else }{\rm{rtr-ins}}\,({\it{s\/}})\index{rtr-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 JMP instruction.
 The JMP instruction is unsized. To calculate the effective address by
 effec-addr,  one can arbitrarily supply the operand length.  Note
 that the addr-predec, addr-postinc and immediate are not allowed.
\begin{tabbing}{\sc Definition}:\index{jmp-addr-modep} \\  
{\rm{jmp-addr-modep}}\,({\it{ins\/}})\index{jmp-addr-modep} $=$ {\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep}
\end{tabbing}

 JMP does not affect CCR!
\begin{tabbing}{\sc Definition}:\index{jmp-mapping} \\  
\=\+{\rm{jmp-mapping}}\,({\it{addr\/}}, {\it{s\/}})\index{jmp-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{mc-haltp}}\,({\it{s\/}})\index{mc-haltp}$\;\;${\bf then }{\it{s\/}} \\ 
{\bf else }{\rm{update-pc}}\,({\it{addr\/}}, {\it{s\/}})\index{update-pc}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{jmp-ins} \\  
\=\+{\rm{jmp-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{jmp-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{jmp-addr-modep}}\,({\it{ins\/}})\index{jmp-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\sc{l}}\index{l}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
{\rm{jmp-mapping}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{jmp-mapping}$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 JSR instruction.
 JSR does not affect CCR!
\begin{tabbing}{\sc Definition}:\index{jsr-addr-modep} \\  
{\rm{jsr-addr-modep}}\,({\it{ins\/}})\index{jsr-addr-modep} $=$ {\rm{control-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{control-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{jsr-ins} \\  
\=\+{\rm{jsr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{jsr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{jsr-addr-modep}}\,({\it{ins\/}})\index{jsr-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{effec-addr}}\,({\sc{l}}\index{l}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{effec-addr}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{jmp-mapping}}\,(\=\+{\rm{cddr}}\,({\it{s\&addr\/}}), \\ 
{\rm{push-sp}}\,(\=\+{\sc{lsz}}\index{lsz}, \\ 
{\rm{mc-pc}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-pc}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{push-sp})\-\index{jmp-mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 NOT instruction.
\begin{tabbing}{\sc Definition}:\index{not-addr-modep} \\  
\=\+{\rm{not-addr-modep}}\,({\it{ins\/}})\index{not-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-z} \\  
\=\+{\rm{not-z}}\,({\it{oplen\/}}, {\it{opd\/}})\index{not-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{lognot}}\,({\it{oplen\/}}, {\it{opd\/}})\index{lognot} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-n}$\;\;$
{\rm{not-n}}\,({\it{oplen\/}}, {\it{opd\/}})\index{not-n} $=$ {\rm{mbit}}\,({\rm{lognot}}\,({\it{oplen\/}}, {\it{opd\/}})\index{lognot}, {\it{oplen\/}})\index{mbit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-cvznx} \\  
\=\+{\rm{not-cvznx}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{not-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{not-z}}\,({\it{oplen\/}}, {\it{opd\/}})\index{not-z}, {\rm{not-n}}\,({\it{oplen\/}}, {\it{opd\/}})\index{not-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-effect} \\  
\=\+{\rm{not-effect}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{not-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{lognot}}\,({\it{oplen\/}}, {\it{opd\/}})\index{lognot}, {\rm{not-cvznx}}\,({\it{oplen\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{not-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-ins} \\  
\=\+{\rm{not-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{not-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{not-addr-modep}}\,({\it{ins\/}})\index{not-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{not-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{not-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{not-subgroup} \\  
\=\+{\rm{not-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{not-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{move-to-sr-privileged}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{not-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{not-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0100.
 The miscellaneous instruction group includes LEA, CLR, MOVE from CCR,
 NEG, MOVE to CCR, NOT, SWAP, PEA, EXT-word, MOVEM to EA, TST, TAS,
 MOVEM to RN, LINK, UNLK, NOP, RTD, RTS, RTR, JSR, JMP.
\begin{tabbing}{\sc Definition}:\index{misc-group} \\  
\=\+{\rm{misc-group}}\,({\it{ins\/}}, {\it{s\/}})\index{misc-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{negx-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{negx-subgroup} \\ 
{\bf else }{\rm{clr-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{clr-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{neg-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{neg-subgroup} \\ 
{\bf else }{\rm{not-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{not-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{7}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }\=\+{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{5}})\index{bitn})\index{b0p} \\ 
$\wedge$$\;\;\;\;${\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{4}})\index{bitn})\index{b0p} \\ 
$\wedge$$\;\;\;\;${\rm{b1p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{3}})\index{bitn})\index{b1p}\- \\ 
{\bf then }{\rm{link\_l-ins}}\,({\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{link\_l-ins} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{nbcd-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{pea-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{pea-subgroup}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{ext-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{ext-subgroup}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{tst-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{tst-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{movem-ea-rn-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{movem-ea-rn-subgroup} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{7}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{5}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{unlk-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{unlk-subgroup} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{4}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{halt}}\,({\tt{'}}{\tt{move-usp-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{3}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{nop-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{nop-subgroup} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{movec-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{jsr-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{jsr-ins} \\ 
{\bf else }{\rm{jmp-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{jmp-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b1p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{6}})\index{bitn})\index{b1p} $\wedge$ {\rm{b1p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{7}})\index{bitn})\index{b1p} \\ 
{\bf then }{\rm{lea-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{lea-subgroup} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{chk-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Some useful definitions for Bcc and Scc instruction groups.  Notice that
 bvs has been defined in TRAPV.
\begin{tabbing}{\sc Definition}:\index{bcs}$\;\;$
{\rm{bcs}}\,({\it{c\/}})\index{bcs} $=$ {\rm{fix-bit}}\,({\it{c\/}})\index{fix-bit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{beq}$\;\;$
{\rm{beq}}\,({\it{z\/}})\index{beq} $=$ {\rm{fix-bit}}\,({\it{z\/}})\index{fix-bit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bmi}$\;\;$
{\rm{bmi}}\,({\it{n\/}})\index{bmi} $=$ {\rm{fix-bit}}\,({\it{n\/}})\index{fix-bit}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ble} \\  
{\rm{ble}}\,({\it{v\/}}, {\it{z\/}}, {\it{n\/}})\index{ble} $=$ {\rm{b-or}}\,({\it{z\/}}, {\rm{b-or}}\,({\rm{b-and}}\,({\it{n\/}}, {\rm{b-not}}\,({\it{v\/}})\index{b-not})\index{b-and}, {\rm{b-and}}\,({\rm{b-not}}\,({\it{n\/}})\index{b-not}, {\it{v\/}})\index{b-and})\index{b-or})\index{b-or}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bgt} \\  
{\rm{bgt}}\,({\it{v\/}}, {\it{z\/}}, {\it{n\/}})\index{bgt} $=$ {\rm{b-and}}\,({\rm{b-or}}\,({\rm{b-and}}\,({\it{n\/}}, {\it{v\/}})\index{b-and}, {\rm{b-and}}\,({\rm{b-not}}\,({\it{n\/}})\index{b-not}, {\rm{b-not}}\,({\it{v\/}})\index{b-not})\index{b-and})\index{b-or}, {\rm{b-not}}\,({\it{z\/}})\index{b-not})\index{b-and}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{blt} \\  
{\rm{blt}}\,({\it{v\/}}, {\it{n\/}})\index{blt} $=$ {\rm{b-or}}\,({\rm{b-and}}\,({\it{n\/}}, {\rm{b-not}}\,({\it{v\/}})\index{b-not})\index{b-and}, {\rm{b-and}}\,({\rm{b-not}}\,({\it{n\/}})\index{b-not}, {\it{v\/}})\index{b-and})\index{b-or}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bge} \\  
{\rm{bge}}\,({\it{v\/}}, {\it{n\/}})\index{bge} $=$ {\rm{b-or}}\,({\rm{b-and}}\,({\it{n\/}}, {\it{v\/}})\index{b-and}, {\rm{b-and}}\,({\rm{b-not}}\,({\it{n\/}})\index{b-not}, {\rm{b-not}}\,({\it{v\/}})\index{b-not})\index{b-and})\index{b-or}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bls}$\;\;$
{\rm{bls}}\,({\it{c\/}}, {\it{z\/}})\index{bls} $=$ {\rm{b-or}}\,({\it{c\/}}, {\it{z\/}})\index{b-or}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bhi}$\;\;$
{\rm{bhi}}\,({\it{c\/}}, {\it{z\/}})\index{bhi} $=$ {\rm{b-and}}\,({\rm{b-not}}\,({\it{c\/}})\index{b-not}, {\rm{b-not}}\,({\it{z\/}})\index{b-not})\index{b-and}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{branch-cc} \\  
\=\+{\rm{branch-cc}}\,({\it{cond\/}}, {\it{ccr\/}})\index{branch-cc} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cond\/}} $<$ {\tt{8}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $=$ {\tt{2}}$\;\;${\bf then }{\rm{bhi}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z})\index{bhi} \\ 
{\bf else }{\rm{bls}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z})\index{bls}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $<$ {\tt{6}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $=$ {\tt{4}}$\;\;${\bf then }{\rm{b-not}}\,({\rm{bcs}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c})\index{bcs})\index{b-not} \\ 
{\bf else }{\rm{bcs}}\,({\rm{ccr-c}}\,({\it{ccr\/}})\index{ccr-c})\index{bcs}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $=$ {\tt{6}}$\;\;${\bf then }{\rm{b-not}}\,({\rm{beq}}\,({\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z})\index{beq})\index{b-not} \\ 
{\bf else }{\rm{beq}}\,({\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z})\index{beq}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $<$ {\tt{12}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $<$ {\tt{10}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $=$ {\tt{8}}$\;\;${\bf then }{\rm{b-not}}\,({\rm{bvs}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v})\index{bvs})\index{b-not} \\ 
{\bf else }{\rm{bvs}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v})\index{bvs}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $=$ {\tt{10}}$\;\;${\bf then }{\rm{b-not}}\,({\rm{bmi}}\,({\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{bmi})\index{b-not} \\ 
{\bf else }{\rm{bmi}}\,({\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{bmi}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $<$ {\tt{14}} \\ 
{\bf then }\=\+{\bf if }{\it{cond\/}} $=$ {\tt{12}}$\;\;${\bf then }{\rm{bge}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{bge} \\ 
{\bf else }{\rm{blt}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{blt}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{cond\/}} $=$ {\tt{14}}$\;\;${\bf then }{\rm{bgt}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{bgt} \\ 
{\bf else }{\rm{ble}}\,({\rm{ccr-v}}\,({\it{ccr\/}})\index{ccr-v}, {\rm{ccr-z}}\,({\it{ccr\/}})\index{ccr-z}, {\rm{ccr-n}}\,({\it{ccr\/}})\index{ccr-n})\index{ble}$\;${\bf  endif}\-\-
\end{tabbing}
 BSR instruction.
\begin{tabbing}{\sc Definition}:\index{bsr-ins} \\  
{\rm{bsr-ins}}\,({\it{pc\/}}, {\it{disp\/}}, {\it{s\/}})\index{bsr-ins} $=$ {\rm{push-sp}}\,({\sc{lsz}}\index{lsz}, {\it{pc\/}}, {\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{disp\/}})\index{add}, {\it{s\/}})\index{update-pc})\index{push-sp}
\end{tabbing}

 Bcc and BRA instructions are specified as follows.  The BSR
 instruction needs
 some auxiliary functions to specify it.
 We define BRA and Bcc together.
 Since 0000 is always true.
\begin{tabbing}{\sc Definition}:\index{bcc-ra-sr} \\  
\=\+{\rm{bcc-ra-sr}}\,({\it{pc\/}}, {\it{cond\/}}, {\it{disp\/}}, {\it{s\/}})\index{bcc-ra-sr} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{cond\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{disp\/}})\index{add}, {\it{s\/}})\index{update-pc} \\ 
{\bf elseif }{\it{cond\/}} $=$ {\tt{1}}$\;\;${\bf then }{\rm{bsr-ins}}\,({\it{pc\/}}, {\it{disp\/}}, {\it{s\/}})\index{bsr-ins} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{branch-cc}}\,({\it{cond\/}}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{branch-cc})\index{b0p}$\;\;${\bf then }{\rm{update-pc}}\,({\it{pc\/}}, {\it{s\/}})\index{update-pc} \\ 
{\bf else }{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{disp\/}})\index{add}, {\it{s\/}})\index{update-pc}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0110.
 The Bcc instruction group includes Bcc, BRA and BSR instructions.
\begin{tabbing}{\sc Definition}:\index{bcc-group} \\  
\=\+{\rm{bcc-group}}\,({\it{disp\/}}, {\it{ins\/}}, {\it{s\/}})\index{bcc-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{disp\/}} $=$ {\tt{0}} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{bcc-ra-sr}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, \\ 
{\rm{cond-field}}\,({\it{ins\/}})\index{cond-field}, \\ 
{\rm{ext}}\,({\sc{w}}\index{w}, {\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, {\sc{l}}\index{l})\index{ext}, \\ 
{\it{s\/}})\-\index{bcc-ra-sr} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{disp\/}} $=$ {\tt{255}} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-long-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-readp} \\ 
{\bf then }{\rm{bcc-ra-sr}}\,(\=\+{\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{lsz}}\index{lsz})\index{add}, \\ 
{\rm{cond-field}}\,({\it{ins\/}})\index{cond-field}, \\ 
{\rm{pc-long-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-long-read}, \\ 
{\it{s\/}})\-\index{bcc-ra-sr} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{bcc-ra-sr}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{cond-field}}\,({\it{ins\/}})\index{cond-field}, {\rm{ext}}\,({\sc{b}}\index{b}, {\it{disp\/}}, {\sc{l}}\index{l})\index{ext}, {\it{s\/}})\index{bcc-ra-sr}$\;${\bf  endif}\-\-
\end{tabbing}

 Scc instruction.
\begin{tabbing}{\sc Definition}:\index{scc-addr-modep} \\  
\=\+{\rm{scc-addr-modep}}\,({\it{ins\/}})\index{scc-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

 CCR is not affected by Scc.
\begin{tabbing}{\sc Definition}:\index{scc-effect} \\  
\=\+{\rm{scc-effect}}\,({\it{cond\/}}, {\it{ccr\/}})\index{scc-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+\=\+{\bf if }{\rm{b0p}}\,({\rm{branch-cc}}\,({\it{cond\/}}, {\it{ccr\/}})\index{branch-cc})\index{b0p}$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }{\tt{255}}$\;${\bf  endif}\-, \\ 
{\it{ccr\/}})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{scc-ins} \\  
\=\+{\rm{scc-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{scc-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{scc-addr-modep}}\,({\it{ins\/}})\index{scc-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\sc{b}}\index{b}, \\ 
{\rm{scc-effect}}\,({\rm{cond-field}}\,({\it{ins\/}})\index{cond-field}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{scc-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 DBcc instruction.
\begin{tabbing}{\sc Definition}:\index{dbcc-loop} \\  
\=\+{\rm{dbcc-loop}}\,({\it{rn\/}}, {\it{s\/}})\index{dbcc-loop} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{cnt\/}}{\bf $\;$ be$\;\;$}{\rm{sub}}\,({\sc{w}}\index{w}, {\tt{1}}, {\rm{read-dn}}\,({\sc{w}}\index{w}, {\it{rn\/}}, {\it{s\/}})\index{read-dn})\index{sub}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{nat-to-int}}\,({\it{cnt\/}}, {\sc{w}}\index{w})\index{nat-to-int} $=$ {\tt{-1}} \\ 
{\bf then }{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\rm{write-dn}}\,({\sc{w}}\index{w}, {\it{cnt\/}}, {\it{rn\/}}, {\it{s\/}})\index{write-dn})\index{update-pc} \\ 
{\bf else }{\rm{update-pc}}\,(\=\+{\rm{add}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, \\ 
{\rm{ext}}\,(\=\+{\sc{w}}\index{w}, \\ 
{\rm{pc-word-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}, \\ 
{\sc{l}}\index{l})\-\index{ext})\-\index{add}, \\ 
{\rm{write-dn}}\,({\sc{w}}\index{w}, {\it{cnt\/}}, {\it{rn\/}}, {\it{s\/}})\index{write-dn})\-\index{update-pc}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{dbcc-ins} \\  
\=\+{\rm{dbcc-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{dbcc-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{branch-cc}}\,({\rm{cond-field}}\,({\it{ins\/}})\index{cond-field}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{branch-cc})\index{b0p} \\ 
{\bf then }{\rm{dbcc-loop}}\,({\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{dbcc-loop} \\ 
{\bf else }{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ADDQ instruction.
\begin{tabbing}{\sc Definition}:\index{addq-addr-modep} \\  
\=\+{\rm{addq-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{addq-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}

 It seems to us that there is no
 difference between word and long word operations for the
 ADDQ instruction in the address register direct mode.

\begin{tabbing}{\sc Definition}:\index{addq-ins} \\  
\=\+{\rm{addq-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addq-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{addq-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{addq-addr-modep} \\ 
{\bf then }\=\+{\bf if }{\rm{an-direct-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{an-direct-modep} \\ 
{\bf then }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-an}, {\rm{i-data}}\,({\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{i-data})\index{add}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{write-an} \\ 
{\bf else }{\rm{add-mapping}}\,({\rm{i-data}}\,({\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{i-data}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{add-mapping}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 SUBQ instruction.
 Same remark as for ADDQ.
\begin{tabbing}{\sc Definition}:\index{subq-addr-modep} \\  
\=\+{\rm{subq-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{subq-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subq-ins} \\  
\=\+{\rm{subq-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subq-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{subq-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{subq-addr-modep} \\ 
{\bf then }\=\+{\bf if }{\rm{an-direct-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{an-direct-modep} \\ 
{\bf then }{\rm{write-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{sub}}\,({\sc{l}}\index{l}, {\rm{i-data}}\,({\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{i-data}, {\rm{read-an}}\,({\sc{l}}\index{l}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{read-an})\index{sub}, \\ 
{\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, \\ 
{\it{s\/}})\-\index{write-an} \\ 
{\bf else }{\rm{sub-mapping}}\,({\rm{i-data}}\,({\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn})\index{i-data}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{sub-mapping}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0101.
 The Scc instruction group includes Scc, DBcc, ADDQ, and SUBQ instructions.
\begin{tabbing}{\sc Definition}:\index{scc-group} \\  
\=\+{\rm{scc-group}}\,({\it{ins\/}}, {\it{s\/}})\index{scc-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{op-len}}\,({\it{ins\/}})\index{op-len} $=$ {\sc{q}}\index{q} \\ 
{\bf then }\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{dbcc-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{dbcc-ins} \\ 
{\bf elseif }({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{7}}) $\wedge$ ({\tt{1}} $<$ {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}) \\ 
{\bf then }{\rm{halt}}\,({\tt{'}}{\tt{trapcc-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{scc-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{scc-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{addq-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{addq-ins} \\ 
{\bf else }{\rm{subq-ins}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{subq-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0111.
 MOVEQ instruction.
\begin{tabbing}{\sc Definition}:\index{moveq-ins} \\  
\=\+{\rm{moveq-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{moveq-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{d-mapping}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{move-effect}}\,({\sc{l}}\index{l}, {\rm{ext}}\,({\sc{b}}\index{b}, {\rm{head}}\,({\it{ins\/}}, {\sc{b}}\index{b})\index{head}, {\sc{l}}\index{l})\index{ext}, {\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\index{move-effect}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\it{s\/}})\-\index{d-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 CMP instruction.
\begin{tabbing}{\sc Definition}:\index{cmp-cvznx} \\  
\=\+{\rm{cmp-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{cmp-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,(\=\+{\rm{sub-c}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-c}, \\ 
{\rm{sub-v}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-v}, \\ 
{\rm{sub-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-z}, \\ 
{\rm{sub-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{sub-n}, \\ 
{\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\-\index{cvznx}\-
\end{tabbing}                \begin{verbatim}; it is different from sub-x.  

\end{verbatim}\begin{tabbing}{\sc Definition}:\index{cmp-addr-modep} \\  
\=\+{\rm{cmp-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{cmp-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{byte-an-direct-modep}}\,({\it{oplen\/}}, {\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{byte-an-direct-modep}))\-\-
\end{tabbing}
        
 The execution of the CMP instruction.
\begin{tabbing}{\sc Definition}:\index{cmp-ins} \\  
\=\+{\rm{cmp-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmp-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{cmp-addr-modep}}\,({\it{oplen\/}}, {\it{ins\/}})\index{cmp-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{cmp-cvznx}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{operand}, \\ 
{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{cmp-cvznx}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 CMPA instruction.
\begin{tabbing}{\sc Definition}:\index{cmpa-addr-modep} \\  
{\rm{cmpa-addr-modep}}\,({\it{ins\/}})\index{cmpa-addr-modep} $=$ {\rm{addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{addr-modep}
\end{tabbing}

 The cvznx-flag setting is the same as the CMP instruction.
 The only difference is that word operation is sign-extended to longword
 operation.
\begin{tabbing}{\sc Definition}:\index{cmpa-ins} \\  
\=\+{\rm{cmpa-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpa-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{cmpa-addr-modep}}\,({\it{ins\/}})\index{cmpa-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{cmp-cvznx}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{ext}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{cdr}}\,({\it{s\&addr\/}}), \\ 
{\it{s\/}})\-\index{operand}, \\ 
{\sc{l}}\index{l})\-\index{ext}, \\ 
{\rm{read-an}}\,(\=\+{\sc{l}}\index{l}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{read-an}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{cmp-cvznx}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 EOR instruction.
\begin{tabbing}{\sc Definition}:\index{eor-z} \\  
\=\+{\rm{eor-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{eor-z} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{logeor}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logeor} $=$ {\tt{0}}$\;\;${\bf then }{\sc{b1}}\index{b1} \\ 
{\bf else }{\sc{b0}}\index{b0}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor-n} \\  
{\rm{eor-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{eor-n} $=$ {\rm{b-eor}}\,({\rm{mbit}}\,({\it{sopd\/}}, {\it{oplen\/}})\index{mbit}, {\rm{mbit}}\,({\it{dopd\/}}, {\it{oplen\/}})\index{mbit})\index{b-eor}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor-cvznx} \\  
\=\+{\rm{eor-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{eor-cvznx} \\ 
$=$$\;\;\;\;${\rm{cvznx}}\,({\sc{b0}}\index{b0}, {\sc{b0}}\index{b0}, {\rm{eor-z}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{eor-z}, {\rm{eor-n}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}})\index{eor-n}, {\rm{ccr-x}}\,({\it{ccr\/}})\index{ccr-x})\index{cvznx}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor-effect} \\  
\=\+{\rm{eor-effect}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{eor-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{logeor}}\,({\it{sopd\/}}, {\it{dopd\/}})\index{logeor}, {\rm{eor-cvznx}}\,({\it{oplen\/}}, {\it{sopd\/}}, {\it{dopd\/}}, {\it{ccr\/}})\index{eor-cvznx})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor\&eori-addr-modep} \\  
\=\+{\rm{eor\&eori-addr-modep}}\,({\it{ins\/}})\index{eor\&eori-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor-mapping} \\  
\=\+{\rm{eor-mapping}}\,({\it{sopd\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eor-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{eor-effect}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{sopd\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{eor-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{eor-ins} \\  
\=\+{\rm{eor-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eor-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{eor\&eori-addr-modep}}\,({\it{ins\/}})\index{eor\&eori-addr-modep} \\ 
{\bf then }{\rm{eor-mapping}}\,({\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eor-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 CMPM instruction.
\begin{tabbing}{\sc Definition}:\index{cmpm-mapping} \\  
\=\+{\rm{cmpm-mapping}}\,({\it{addr\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpm-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{addr-postinc}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{addr-postinc}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{cmp-cvznx}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\it{addr\/}}, {\it{s\/}})\index{operand}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{cmp-cvznx}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{cmpm-ins} \\  
\=\+{\rm{cmpm-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpm-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{addr-postinc}}\,({\it{oplen\/}}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{addr-postinc}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{read-memp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{read-memp} \\ 
{\bf then }{\rm{cmpm-mapping}}\,({\rm{cdr}}\,({\it{s\&addr\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&addr\/}}))\index{cmpm-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Opcode 1011.
 The CMP instruction group includes instructions CMP, CMPA, EOR, and CMPM.
\begin{tabbing}{\sc Definition}:\index{cmp-group} \\  
\=\+{\rm{cmp-group}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmp-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{cmpa-ins}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{cmpa-ins} \\ 
{\bf else }{\rm{cmp-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmp-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{cmpa-ins}}\,({\sc{l}}\index{l}, {\it{ins\/}}, {\it{s\/}})\index{cmpa-ins} \\ 
{\bf elseif }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{cmpm-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpm-ins} \\ 
{\bf else }{\rm{eor-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eor-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVEP instruction.
 MOVEP moves a data register into alternate bytes of memory.
\begin{tabbing}{\sc Definition}:\index{movep-writep} \\  
\=\+{\rm{movep-writep}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{n\/}})\index{movep-writep} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{t}} \\ 
{\bf else }\=\+{\rm{byte-writep}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\tt{2}} $*$ ({\it{n\/}} $-\;1$))\index{add}, {\it{mem\/}})\index{byte-writep} \\ 
$\wedge$$\;\;\;\;${\rm{movep-writep}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{n\/}} $-\;1$)\index{movep-writep}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-write} \\  
\=\+{\rm{movep-write}}\,({\it{value\/}}, {\it{addr\/}}, {\it{mem\/}}, {\it{n\/}})\index{movep-write} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\it{mem\/}} \\ 
{\bf else }{\rm{movep-write}}\,(\=\+{\rm{tail}}\,({\it{value\/}}, {\sc{b}}\index{b})\index{tail}, \\ 
{\it{addr\/}}, \\ 
{\rm{byte-write}}\,(\=\+{\it{value\/}}, \\ 
{\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\tt{2}} $*$ ({\it{n\/}} $-\;1$))\index{add}, \\ 
{\it{mem\/}})\-\index{byte-write}, \\ 
{\it{n\/}} $-\;1$)\-\index{movep-write}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-to-mem} \\  
\=\+{\rm{movep-to-mem}}\,({\it{addr\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movep-to-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{movep-writep}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{movep-writep} \\ 
{\bf then }{\rm{update-mem}}\,(\=\+{\rm{movep-write}}\,(\=\+{\rm{read-dn}}\,({\it{oplen\/}}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, \\ 
{\it{addr\/}}, \\ 
{\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, \\ 
{\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\-\index{movep-write}, \\ 
{\it{s\/}})\-\index{update-mem} \\ 
{\bf else }{\rm{halt}}\,({\sc{write-signal}}\index{write-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 MOVEP moves alternate bytes in memory into a data register.
\begin{tabbing}{\sc Definition}:\index{movep-readp} \\  
\=\+{\rm{movep-readp}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{n\/}})\index{movep-readp} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\bf{t}} \\ 
{\bf else }\=\+{\rm{byte-readp}}\,({\it{addr\/}}, {\it{mem\/}})\index{byte-readp} \\ 
$\wedge$$\;\;\;\;${\rm{movep-readp}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{mem\/}}, {\it{n\/}} $-\;1$)\index{movep-readp}\-$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-read} \\  
\=\+{\rm{movep-read}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{n\/}})\index{movep-read} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\tt{0}} \\ 
{\bf else }{\rm{app}}\,(\=\+{\sc{b}}\index{b}, \\ 
{\rm{byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{addr\/}}, {\tt{2}} $*$ ({\it{n\/}} $-\;1$))\index{add}, {\it{mem\/}})\index{byte-read}, \\ 
{\rm{movep-read}}\,({\it{addr\/}}, {\it{mem\/}}, {\it{n\/}} $-\;1$)\index{movep-read})\-\index{app}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-to-reg} \\  
\=\+{\rm{movep-to-reg}}\,({\it{addr\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{movep-to-reg} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{movep-readp}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{movep-readp} \\ 
{\bf then }{\rm{write-dn}}\,(\=\+{\it{oplen\/}}, \\ 
{\rm{movep-read}}\,({\it{addr\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem}, {\rm{op-sz}}\,({\it{oplen\/}})\index{op-sz})\index{movep-read}, \\ 
{\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, \\ 
{\it{s\/}})\-\index{write-dn} \\ 
{\bf else }{\rm{halt}}\,({\sc{read-signal}}\index{read-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{evenp}$\;\;$
{\rm{evenp}}\,({\it{x\/}})\index{evenp} $=$ {\rm{b0p}}\,({\rm{bcar}}\,({\it{x\/}})\index{bcar})\index{b0p}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-addr} \\  
\=\+{\rm{movep-addr}}\,({\it{s\&addr\/}})\index{movep-addr} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{evenp}}\,({\rm{cddr}}\,({\it{s\&addr\/}}))\index{evenp}$\;\;${\bf then }{\rm{cddr}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{add}}\,({\sc{l}}\index{l}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\sc{bsz}}\index{bsz})\index{add}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{movep-ins} \\  
\=\+{\rm{movep-ins}}\,({\it{opmode\/}}, {\it{ins\/}}, {\it{s\/}})\index{movep-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{addr-disp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn}, {\it{s\/}})\index{addr-disp}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf elseif }{\it{opmode\/}} $<$ {\tt{6}} \\ 
{\bf then }\=\+{\bf if }{\it{opmode\/}} $=$ {\tt{4}} \\ 
{\bf then }{\rm{movep-to-reg}}\,({\rm{movep-addr}}\,({\it{s\&addr\/}})\index{movep-addr}, {\sc{w}}\index{w}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&addr\/}}))\index{movep-to-reg} \\ 
{\bf else }{\rm{movep-to-reg}}\,(\=\+{\rm{movep-addr}}\,({\it{s\&addr\/}})\index{movep-addr}, \\ 
{\sc{l}}\index{l}, \\ 
{\it{ins\/}}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{movep-to-reg}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opmode\/}} $=$ {\tt{6}} \\ 
{\bf then }{\rm{movep-to-mem}}\,({\rm{movep-addr}}\,({\it{s\&addr\/}})\index{movep-addr}, {\sc{w}}\index{w}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&addr\/}}))\index{movep-to-mem} \\ 
{\bf else }{\rm{movep-to-mem}}\,({\rm{movep-addr}}\,({\it{s\&addr\/}})\index{movep-addr}, {\sc{l}}\index{l}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&addr\/}}))\index{movep-to-mem}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Some functions for bit operations.
\begin{tabbing}{\sc Definition}:\index{bxxx-oplen} \\  
\=\+{\rm{bxxx-oplen}}\,({\it{smode\/}})\index{bxxx-oplen} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{dn-direct-modep}}\,({\it{smode\/}})\index{dn-direct-modep}$\;\;${\bf then }{\sc{l}}\index{l} \\ 
{\bf else }{\sc{b}}\index{b}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bxxx-num} \\  
\=\+{\rm{bxxx-num}}\,({\it{smode\/}}, {\it{bnum\/}})\index{bxxx-num} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{dn-direct-modep}}\,({\it{smode\/}})\index{dn-direct-modep}$\;\;${\bf then }{\rm{head}}\,({\it{bnum\/}}, {\tt{5}})\index{head} \\ 
{\bf else }{\rm{head}}\,({\it{bnum\/}}, {\tt{3}})\index{head}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bxxx-opd} \\  
\=\+{\rm{bxxx-opd}}\,({\it{smode\/}}, {\it{s\&addr\/}})\index{bxxx-opd} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{dn-direct-modep}}\,({\it{smode\/}})\index{dn-direct-modep}$\;\;${\bf then }{\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{cddr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{read-dn} \\ 
{\bf else }{\rm{operand}}\,({\sc{b}}\index{b}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\rm{car}}\,({\it{s\&addr\/}}))\index{operand}$\;${\bf  endif}\-\-
\end{tabbing}

 BCHG instruction.
\begin{tabbing}{\sc Definition}:\index{bchg-addr-modep} \\  
\=\+{\rm{bchg-addr-modep}}\,({\it{ins\/}})\index{bchg-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bchg-effect} \\  
\=\+{\rm{bchg-effect}}\,({\it{bnum\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{bchg-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,(\=\+{\rm{setn}}\,({\it{opd\/}}, {\it{bnum\/}}, {\rm{b-not}}\,({\rm{bitn}}\,({\it{opd\/}}, {\it{bnum\/}})\index{bitn})\index{b-not})\index{setn}, \\ 
{\rm{set-z}}\,({\rm{b-not}}\,({\rm{bitn}}\,({\it{opd\/}}, {\it{bnum\/}})\index{bitn})\index{b-not}, {\it{ccr\/}})\index{set-z})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bchg-ins} \\  
\=\+{\rm{bchg-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bchg-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{bchg-addr-modep}}\,({\it{ins\/}})\index{bchg-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\rm{bxxx-oplen}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{bxxx-oplen}, \\ 
{\rm{bchg-effect}}\,(\=\+{\rm{bxxx-num}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\it{bnum\/}})\index{bxxx-num}, \\ 
{\rm{bxxx-opd}}\,(\=\+{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, \\ 
{\it{s\&addr\/}})\-\index{bxxx-opd}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{bchg-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 BCLR instruction.
\begin{tabbing}{\sc Definition}:\index{bclr-addr-modep} \\  
\=\+{\rm{bclr-addr-modep}}\,({\it{ins\/}})\index{bclr-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bclr-effect} \\  
\=\+{\rm{bclr-effect}}\,({\it{bnum\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{bclr-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{setn}}\,({\it{opd\/}}, {\it{bnum\/}}, {\sc{b0}}\index{b0})\index{setn}, {\rm{set-z}}\,({\rm{b-not}}\,({\rm{bitn}}\,({\it{opd\/}}, {\it{bnum\/}})\index{bitn})\index{b-not}, {\it{ccr\/}})\index{set-z})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bclr-ins} \\  
\=\+{\rm{bclr-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bclr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{bclr-addr-modep}}\,({\it{ins\/}})\index{bclr-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\rm{bxxx-oplen}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{bxxx-oplen}, \\ 
{\rm{bclr-effect}}\,(\=\+{\rm{bxxx-num}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\it{bnum\/}})\index{bxxx-num}, \\ 
{\rm{bxxx-opd}}\,(\=\+{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, \\ 
{\it{s\&addr\/}})\-\index{bxxx-opd}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{bclr-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 BSET instruction.
\begin{tabbing}{\sc Definition}:\index{bset-addr-modep} \\  
\=\+{\rm{bset-addr-modep}}\,({\it{ins\/}})\index{bset-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bset-effect} \\  
\=\+{\rm{bset-effect}}\,({\it{bnum\/}}, {\it{opd\/}}, {\it{ccr\/}})\index{bset-effect} \\ 
$=$$\;\;\;\;${\rm{cons}}\,({\rm{setn}}\,({\it{opd\/}}, {\it{bnum\/}}, {\sc{b1}}\index{b1})\index{setn}, {\rm{set-z}}\,({\rm{b-not}}\,({\rm{bitn}}\,({\it{opd\/}}, {\it{bnum\/}})\index{bitn})\index{b-not}, {\it{ccr\/}})\index{set-z})\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{bset-ins} \\  
\=\+{\rm{bset-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bset-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{bset-addr-modep}}\,({\it{ins\/}})\index{bset-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{mapping}}\,(\=\+{\rm{bxxx-oplen}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode})\index{bxxx-oplen}, \\ 
{\rm{bset-effect}}\,(\=\+{\rm{bxxx-num}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\it{bnum\/}})\index{bxxx-num}, \\ 
{\rm{bxxx-opd}}\,(\=\+{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, \\ 
{\it{s\&addr\/}})\-\index{bxxx-opd}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{bset-effect}, \\ 
{\it{s\&addr\/}})\-\index{mapping}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 BTST instruction.
\begin{tabbing}{\sc Definition}:\index{btst-addr-modep} \\  
{\rm{btst-addr-modep}}\,({\it{ins\/}})\index{btst-addr-modep} $=$ {\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep}
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{btst-ins} \\  
\=\+{\rm{btst-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{btst-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{btst-addr-modep}}\,({\it{ins\/}})\index{btst-addr-modep} \\ 
{\bf then }\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{set-z}}\,(\=\+{\rm{b-not}}\,({\rm{bitn}}\,(\=\+{\rm{bxxx-opd}}\,(\=\+{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, \\ 
{\it{s\&addr\/}})\-\index{bxxx-opd}, \\ 
{\rm{bxxx-num}}\,(\=\+{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, \\ 
{\it{bnum\/}})\-\index{bxxx-num})\-\index{bitn})\index{b-not}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{set-z}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 `bit-ins' includes the BTST, BCLR, BCHG, and BSET instructions.
\begin{tabbing}{\sc Definition}:\index{bit-ins} \\  
\=\+{\rm{bit-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bit-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{type\/}}{\bf $\;$ be$\;\;$}{\rm{bits}}\,({\it{ins\/}}, {\tt{6}}, {\tt{7}})\index{bits}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{type\/}} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{type\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{btst-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{btst-ins} \\ 
{\bf else }{\rm{bchg-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bchg-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{type\/}} $=$ {\tt{2}}$\;\;${\bf then }{\rm{bclr-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bclr-ins} \\ 
{\bf else }{\rm{bset-ins}}\,({\it{bnum\/}}, {\it{ins\/}}, {\it{s\/}})\index{bset-ins}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 Dynamic bit operation.  BTST, BCLR, BCHG, and BSET instructions.
\begin{tabbing}{\sc Definition}:\index{d-bit-subgroup} \\  
\=\+{\rm{d-bit-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{d-bit-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode} $=$ {\tt{1}}$\;\;${\bf then }{\rm{movep-ins}}\,({\rm{opmode-field}}\,({\it{ins\/}})\index{opmode-field}, {\it{ins\/}}, {\it{s\/}})\index{movep-ins} \\ 
{\bf else }{\rm{bit-ins}}\,({\rm{read-dn}}\,({\sc{l}}\index{l}, {\rm{d\_rn}}\,({\it{ins\/}})\index{d\_rn}, {\it{s\/}})\index{read-dn}, {\it{ins\/}}, {\it{s\/}})\index{bit-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 Static bit operation.  BTST, BCLR, BCHG, and BSET instructions.
\begin{tabbing}{\sc Definition}:\index{s-bit-subgroup} \\  
\=\+{\rm{s-bit-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{s-bit-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-byte-read}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read} $=$ {\tt{0}} \\ 
{\bf then }{\rm{bit-ins}}\,(\=\+{\rm{pc-byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{bsz}}\index{bsz})\index{add}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read}, \\ 
{\it{ins\/}}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{bit-ins} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ORI instruction.
\begin{tabbing}{\sc Definition}:\index{ori-addr-modep} \\  
\=\+{\rm{ori-addr-modep}}\,({\it{ins\/}})\index{ori-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{ori-ins} \\  
\=\+{\rm{ori-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{ori-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&idata\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{ori-addr-modep}}\,({\it{ins\/}})\index{ori-addr-modep} \\ 
{\bf then }{\rm{or-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{or-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 ORI to CCR instruction.
\begin{tabbing}{\sc Definition}:\index{ori-to-ccr-ins} \\  
\=\+{\rm{ori-to-ccr-ins}}\,({\it{pc\/}}, {\it{s\/}})\index{ori-to-ccr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-byte-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read} $=$ {\tt{0}} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{logor}}\,(\=\+{\rm{pc-byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{bsz}}\index{bsz})\index{add}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{logor}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ORI and ORI to CCR instructions.
 Detect ORI to SR, CMP2, and CHK2.
\begin{tabbing}{\sc Definition}:\index{ori-subgroup} \\  
\=\+{\rm{ori-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{ori-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{cmp2-chk2-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{head}}\,({\it{ins\/}}, {\tt{6}})\index{head} $=$ {\tt{60}} \\ 
{\bf then }\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b}$\;\;${\bf then }{\rm{ori-to-ccr-ins}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{ori-to-ccr-ins} \\ 
{\bf elseif }{\it{oplen\/}} $=$ {\sc{w}}\index{w}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{ori-to-sr-privileged}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{ori-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{ori-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 ANDI instruction.
\begin{tabbing}{\sc Definition}:\index{andi-addr-modep} \\  
\=\+{\rm{andi-addr-modep}}\,({\it{ins\/}})\index{andi-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{andi-ins} \\  
\=\+{\rm{andi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{andi-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\it{s\/}})\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{andi-addr-modep}}\,({\it{ins\/}})\index{andi-addr-modep} \\ 
{\bf then }{\rm{and-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{and-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 ANDI to CCR instruction.
\begin{tabbing}{\sc Definition}:\index{andi-to-ccr-ins} \\  
\=\+{\rm{andi-to-ccr-ins}}\,({\it{pc\/}}, {\it{s\/}})\index{andi-to-ccr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-byte-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read} $=$ {\tt{0}} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{logand}}\,(\=\+{\rm{pc-byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{bsz}}\index{bsz})\index{add}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{logand}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 ANDI and ANDI to CCR instructions.
 Detect ANDI to SR, CMP2 and CHK2.
\begin{tabbing}{\sc Definition}:\index{andi-subgroup} \\  
\=\+{\rm{andi-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{andi-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{cmp2-chk2-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{head}}\,({\it{ins\/}}, {\tt{6}})\index{head} $=$ {\tt{60}} \\ 
{\bf then }\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b}$\;\;${\bf then }{\rm{andi-to-ccr-ins}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{andi-to-ccr-ins} \\ 
{\bf elseif }{\it{oplen\/}} $=$ {\sc{w}}\index{w}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{andi-to-sr-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{andi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{andi-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 SUBI instruction. Detect CMP2 and CHK2.
\begin{tabbing}{\sc Definition}:\index{subi-addr-modep} \\  
\=\+{\rm{subi-addr-modep}}\,({\it{ins\/}})\index{subi-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subi-ins} \\  
\=\+{\rm{subi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subi-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&idata\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{subi-addr-modep}}\,({\it{ins\/}})\index{subi-addr-modep} \\ 
{\bf then }{\rm{sub-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{sub-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{subi-subgroup} \\  
\=\+{\rm{subi-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subi-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{cmp2-chk2-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{subi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{subi-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 ADDI instruction.  Detect RTM and CALLM.
\begin{tabbing}{\sc Definition}:\index{addi-addr-modep} \\  
\=\+{\rm{addi-addr-modep}}\,({\it{ins\/}})\index{addi-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;${\rm{alterable-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{alterable-addr-modep})\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addi-ins} \\  
\=\+{\rm{addi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addi-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&idata\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{addi-addr-modep}}\,({\it{ins\/}})\index{addi-addr-modep} \\ 
{\bf then }{\rm{add-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{add-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{addi-subgroup} \\  
\=\+{\rm{addi-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addi-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{rtm-callm-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{addi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{addi-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 EORI instruction.
\begin{tabbing}{\sc Definition}:\index{eori-ins} \\  
\=\+{\rm{eori-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eori-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&idata\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{eor\&eori-addr-modep}}\,({\it{ins\/}})\index{eor\&eori-addr-modep} \\ 
{\bf then }{\rm{eor-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{eor-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 EORI to CCR instruction.
\begin{tabbing}{\sc Definition}:\index{eori-to-ccr-ins} \\  
\=\+{\rm{eori-to-ccr-ins}}\,({\it{pc\/}}, {\it{s\/}})\index{eori-to-ccr-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{pc-word-readp}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-byte-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read} $=$ {\tt{0}} \\ 
{\bf then }{\rm{update-ccr}}\,(\=\+{\rm{logeor}}\,(\=\+{\rm{pc-byte-read}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{bsz}}\index{bsz})\index{add}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-byte-read}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{logeor}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\it{pc\/}}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{update-ccr} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 EORI and EORI to CCR instructions.
 Detect EORI to SR, CAS and CAS2 instructions!
\begin{tabbing}{\sc Definition}:\index{eori-subgroup} \\  
\=\+{\rm{eori-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eori-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{cas-cas2-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf elseif }{\rm{head}}\,({\it{ins\/}}, {\tt{6}})\index{head} $=$ {\tt{60}} \\ 
{\bf then }\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{b}}\index{b}$\;\;${\bf then }{\rm{eori-to-ccr-ins}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{eori-to-ccr-ins} \\ 
{\bf elseif }{\it{oplen\/}} $=$ {\sc{w}}\index{w}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{eori-to-sr-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{eori-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{eori-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 CMPI instruction.
\begin{tabbing}{\sc Definition}:\index{cmpi-addr-modep} \\  
\=\+{\rm{cmpi-addr-modep}}\,({\it{ins\/}})\index{cmpi-addr-modep} \\ 
$=$$\;\;\;\;$(\=\+{\rm{data-addr-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{data-addr-modep} \\ 
$\wedge$$\;\;\;\;$($\neg$ {\rm{idata-modep}}\,({\rm{s\_mode}}\,({\it{ins\/}})\index{s\_mode}, {\rm{s\_rn}}\,({\it{ins\/}})\index{s\_rn})\index{idata-modep}))\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{cmpi-mapping} \\  
\=\+{\rm{cmpi-mapping}}\,({\it{idata\/}}, {\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpi-mapping} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&addr\/}}{\bf $\;$ be$\;\;$}{\rm{mc-instate}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{mc-instate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&addr\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&addr\/}}) \\ 
{\bf else }{\rm{update-ccr}}\,(\=\+{\rm{cmp-cvznx}}\,(\=\+{\it{oplen\/}}, \\ 
{\it{idata\/}}, \\ 
{\rm{operand}}\,({\it{oplen\/}}, {\rm{cdr}}\,({\it{s\&addr\/}}), {\it{s\/}})\index{operand}, \\ 
{\rm{mc-ccr}}\,({\it{s\/}})\index{mc-ccr})\-\index{cmp-cvznx}, \\ 
{\rm{car}}\,({\it{s\&addr\/}}))\-\index{update-ccr}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}
          
\begin{tabbing}{\sc Definition}:\index{cmpi-ins} \\  
\=\+{\rm{cmpi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpi-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{s\&idata\/}}{\bf $\;$ be$\;\;$}{\rm{immediate}}\,({\it{oplen\/}}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{immediate}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\rm{mc-haltp}}\,({\rm{car}}\,({\it{s\&idata\/}}))\index{mc-haltp}$\;\;${\bf then }{\rm{car}}\,({\it{s\&idata\/}}) \\ 
{\bf elseif }{\rm{cmpi-addr-modep}}\,({\it{ins\/}})\index{cmpi-addr-modep} \\ 
{\bf then }{\rm{cmpi-mapping}}\,({\rm{cddr}}\,({\it{s\&idata\/}}), {\it{oplen\/}}, {\it{ins\/}}, {\rm{car}}\,({\it{s\&idata\/}}))\index{cmpi-mapping} \\ 
{\bf else }{\rm{halt}}\,({\sc{mode-signal}}\index{mode-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 The CMPI subgroup includes only the CMPI instruction.
 Detect CAS and CAS2 instructions!
\begin{tabbing}{\sc Definition}:\index{cmpi-subgroup} \\  
\=\+{\rm{cmpi-subgroup}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpi-subgroup} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{oplen\/}} $=$ {\sc{q}}\index{q}$\;\;${\bf then }{\rm{halt}}\,({\tt{'}}{\tt{cas-cas2-unspecified}}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{cmpi-ins}}\,({\it{oplen\/}}, {\it{ins\/}}, {\it{s\/}})\index{cmpi-ins}$\;${\bf  endif}\-\-
\end{tabbing}

 Opcode 0000.
 This instruction group includes instructions ORI, ORI to CCR, BTST, BCLR,
 BCHG, BSET, MOVEP, ANDI, ANDI to CCR, SUBI, ADDI, EORI, EORI to CCR, CMPI.
\begin{tabbing}{\sc Definition}:\index{bit-group} \\  
\=\+{\rm{bit-group}}\,({\it{ins\/}}, {\it{s\/}})\index{bit-group} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{8}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{11}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{ori-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{ori-subgroup} \\ 
{\bf else }{\rm{andi-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{andi-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{subi-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{subi-subgroup} \\ 
{\bf else }{\rm{addi-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{addi-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{10}})\index{bitn})\index{b0p} \\ 
{\bf then }\=\+{\bf if }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{s-bit-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{s-bit-subgroup} \\ 
{\bf else }{\rm{eori-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{eori-subgroup}$\;${\bf  endif}\- \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{ins\/}}, {\tt{9}})\index{bitn})\index{b0p}$\;\;${\bf then }{\rm{cmpi-subgroup}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{cmpi-subgroup} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{moves-cas-cas2-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{d-bit-subgroup}}\,({\it{ins\/}}, {\it{s\/}})\index{d-bit-subgroup}$\;${\bf  endif}\-\-
\end{tabbing}

 The opcode field.
\begin{tabbing}{\sc Definition}:\index{opcode-field}$\;\;$
{\rm{opcode-field}}\,({\it{ins\/}})\index{opcode-field} $=$ {\rm{bits}}\,({\it{ins\/}}, {\tt{12}}, {\tt{15}})\index{bits}
\end{tabbing}

 Execute the current instruction.  See Table 3-14 of \cite{m20}
 for this classification.
\begin{tabbing}{\sc Definition}:\index{execute-ins} \\  
\=\+{\rm{execute-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{execute-ins} \\ 
$=$$\;\;\;\;$\=\+{\bf let }\=\+{\it{opcode\/}}{\bf $\;$ be$\;\;$}{\rm{opcode-field}}\,({\it{ins\/}})\index{opcode-field}\- \\ 
{\bf in} \\ 
\=\+{\bf if }{\it{opcode\/}} $<$ {\tt{8}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $<$ {\tt{4}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $<$ {\tt{2}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $=$ {\tt{0}}$\;\;${\bf then }{\rm{bit-group}}\,({\it{ins\/}}, {\it{s\/}})\index{bit-group} \\ 
{\bf else }{\rm{move-ins}}\,({\sc{b}}\index{b}, {\it{ins\/}}, {\it{s\/}})\index{move-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $=$ {\tt{2}}$\;\;${\bf then }{\rm{move-group}}\,({\sc{l}}\index{l}, {\it{ins\/}}, {\it{s\/}})\index{move-group} \\ 
{\bf else }{\rm{move-group}}\,({\sc{w}}\index{w}, {\it{ins\/}}, {\it{s\/}})\index{move-group}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $<$ {\tt{6}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $=$ {\tt{4}}$\;\;${\bf then }{\rm{misc-group}}\,({\it{ins\/}}, {\it{s\/}})\index{misc-group} \\ 
{\bf else }{\rm{scc-group}}\,({\it{ins\/}}, {\it{s\/}})\index{scc-group}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $=$ {\tt{6}}$\;\;${\bf then }{\rm{bcc-group}}\,({\rm{head}}\,({\it{ins\/}}, {\sc{b}}\index{b})\index{head}, {\it{ins\/}}, {\it{s\/}})\index{bcc-group} \\ 
{\bf else }{\rm{moveq-ins}}\,({\it{ins\/}}, {\it{s\/}})\index{moveq-ins}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $<$ {\tt{12}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $<$ {\tt{10}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $=$ {\tt{8}}$\;\;${\bf then }{\rm{or-group}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{or-group} \\ 
{\bf else }{\rm{sub-group}}\,({\rm{opmode-field}}\,({\it{ins\/}})\index{opmode-field}, {\it{ins\/}}, {\it{s\/}})\index{sub-group}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $=$ {\tt{10}}$\;\;${\bf then }{\rm{halt}}\,({\sc{reserved-signal}}\index{reserved-signal}, {\it{s\/}})\index{halt} \\ 
{\bf else }{\rm{cmp-group}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{cmp-group}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $<$ {\tt{14}} \\ 
{\bf then }\=\+{\bf if }{\it{opcode\/}} $=$ {\tt{12}}$\;\;${\bf then }{\rm{and-group}}\,({\rm{op-len}}\,({\it{ins\/}})\index{op-len}, {\it{ins\/}}, {\it{s\/}})\index{and-group} \\ 
{\bf else }{\rm{add-group}}\,({\rm{opmode-field}}\,({\it{ins\/}})\index{opmode-field}, {\it{ins\/}}, {\it{s\/}})\index{add-group}$\;${\bf  endif}\- \\ 
{\bf elseif }{\it{opcode\/}} $=$ {\tt{14}}$\;\;${\bf then }{\rm{s\&r-group}}\,({\it{ins\/}}, {\it{s\/}})\index{s\&r-group} \\ 
{\bf else }{\rm{halt}}\,({\tt{'}}{\tt{coprocessor-unspecified}}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-$\;${\bf  endlet}\-\-
\end{tabbing}

 `current-ins' is a function of two arguments, {\it{pc\/}} and {\it{s\/}}.  {\it{pc\/}} is the
 current value of the program counter, and {\it{s\/}} is the current state.
 `current-ins' returns the current instruction (a word, not including
 any possible extension words), that is, the word pointed to by pc.
 To determine what instruction we are to execute, this word may only
 provide partial information.  Many instructions require that we
 examine subsequent words to determine what to do.  But to figure out
 how many words we need, we must start with the first word.
\begin{tabbing}{\sc Definition}:\index{current-ins}$\;\;$
{\rm{current-ins}}\,({\it{pc\/}}, {\it{s\/}})\index{current-ins} $=$ {\rm{pc-word-read}}\,({\it{pc\/}}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-read}
\end{tabbing}

 \newpage \section{Stepi and Stepn}
 `stepi' maps a machine state to the next machine state by executing
 the current instruction.
\begin{tabbing}{\sc Definition}:\index{stepi} \\  
\=\+{\rm{stepi}}\,({\it{s\/}})\index{stepi} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{evenp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc})\index{evenp} \\ 
{\bf then }\=\+{\bf if }{\rm{pc-word-readp}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\rm{mc-mem}}\,({\it{s\/}})\index{mc-mem})\index{pc-word-readp} \\ 
{\bf then }{\rm{execute-ins}}\,(\=\+{\rm{current-ins}}\,({\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\it{s\/}})\index{current-ins}, \\ 
{\rm{update-pc}}\,({\rm{add}}\,({\sc{l}}\index{l}, {\rm{mc-pc}}\,({\it{s\/}})\index{mc-pc}, {\sc{wsz}}\index{wsz})\index{add}, {\it{s\/}})\index{update-pc})\-\index{execute-ins} \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-signal}}\index{pc-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\- \\ 
{\bf else }{\rm{halt}}\,({\sc{pc-odd-signal}}\index{pc-odd-signal}, {\it{s\/}})\index{halt}$\;${\bf  endif}\-\-
\end{tabbing}

 \label{stepn}`stepn' is a function of two arguments: {\it{s\/}} is the current state of the
 machine, and {\it{n\/}} is the number of instructions to execute.
\begin{tabbing}{\sc Definition}:\index{stepn} \\  
\=\+{\rm{stepn}}\,({\it{s\/}}, {\it{n\/}})\index{stepn} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{mc-haltp}}\,({\it{s\/}})\index{mc-haltp} $\vee$ ({\it{n\/}} $\simeq {\tt{0}}$)$\;\;${\bf then }{\it{s\/}} \\ 
{\bf else }{\rm{stepn}}\,({\rm{stepi}}\,({\it{s\/}})\index{stepi}, {\it{n\/}} $-\;1$)\index{stepn}$\;${\bf  endif}\-\-
\end{tabbing}

 \section{Auxiliary Functions}
 This section contains some auxiliary functions which are not needed
 to define `stepn' but are used only in the example of the next section.
 `map-update' updates the map in the memory.  The {\it{map\/}} is a binary tree
 with a list of keys in the key field.  By updating the map we assign 
 new properties to the memory.
\begin{tabbing}{\sc Definition}:\index{cons-key-lst} \\  
\=\+{\rm{cons-key-lst}}\,({\it{key\/}}, {\it{lst\/}})\index{cons-key-lst} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{key\/}} $\in$ {\it{lst\/}}$\;\;${\bf then }{\it{lst\/}} \\ 
{\bf else }{\rm{cons}}\,({\it{key\/}}, {\it{lst\/}})$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{key-field} \\  
\=\+{\rm{key-field}}\,({\it{map\/}})\index{key-field} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{map\/}})$\;\;${\bf then }{\rm{car}}\,({\it{map\/}}) \\ 
{\bf else }{\bf{nil}}$\;${\bf  endif}\-\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{make-map} \\  
\=\+{\rm{make-map}}\,({\it{key\/}}, {\it{map\/}})\index{make-map} \\ 
$=$$\;\;\;\;${\rm{make-bt}}\,({\rm{cons-key-lst}}\,({\it{key\/}}, {\rm{key-field}}\,({\it{map\/}})\index{key-field})\index{cons-key-lst}, {\rm{branch0}}\,({\it{map\/}})\index{branch0}, {\rm{branch1}}\,({\it{map\/}})\index{branch1})\index{make-bt}\-
\end{tabbing}

\begin{tabbing}{\sc Definition}:\index{map-update} \\  
\=\+{\rm{map-update}}\,({\it{key\/}}, {\it{x\/}}, {\it{n\/}}, {\it{map\/}})\index{map-update} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\it{n\/}} $\simeq {\tt{0}}$$\;\;${\bf then }{\rm{make-map}}\,({\it{key\/}}, {\it{map\/}})\index{make-map} \\ 
{\bf elseif }{\rm{b0p}}\,({\rm{bitn}}\,({\it{x\/}}, {\it{n\/}} $-\;1$)\index{bitn})\index{b0p} \\ 
{\bf then }{\rm{make-bt}}\,(\=\+{\rm{key-field}}\,({\it{map\/}})\index{key-field}, \\ 
{\rm{map-update}}\,({\it{key\/}}, {\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch0}}\,({\it{map\/}})\index{branch0})\index{map-update}, \\ 
{\rm{branch1}}\,({\it{map\/}})\index{branch1})\-\index{make-bt} \\ 
{\bf else }{\rm{make-bt}}\,(\=\+{\rm{key-field}}\,({\it{map\/}})\index{key-field}, \\ 
{\rm{branch0}}\,({\it{map\/}})\index{branch0}, \\ 
{\rm{map-update}}\,({\it{key\/}}, {\it{x\/}}, {\it{n\/}} $-\;1$, {\rm{branch1}}\,({\it{map\/}})\index{branch1})\index{map-update})\-\index{make-bt}$\;${\bf  endif}\-\-
\end{tabbing}

 Load the values in the list into the memory starting from location {\it{addr\/}}.
\begin{tabbing}{\sc Definition}:\index{load-lst-mem} \\  
\=\+{\rm{load-lst-mem}}\,({\it{opsz\/}}, {\it{lst\/}}, {\it{addr\/}}, {\it{mem\/}})\index{load-lst-mem} \\ 
$=$$\;\;\;\;$\=\+{\bf if }{\rm{listp}}\,({\it{lst\/}}) \\ 
{\bf then }{\rm{load-lst-mem}}\,(\=\+{\it{opsz\/}}, \\ 
{\rm{cdr}}\,({\it{lst\/}}), \\ 
{\rm{add}}\,({\tt{32}}, {\it{addr\/}}, {\it{opsz\/}})\index{add}, \\ 
{\rm{write-mem}}\,({\rm{car}}\,({\it{lst\/}}), {\it{addr\/}}, {\it{mem\/}}, {\it{opsz\/}})\index{write-mem})\-\index{load-lst-mem} \\ 
{\bf else }{\it{mem\/}}$\;${\bf  endif}\-\-
\end{tabbing}


\noindent{\sc Event}:   For efficiency, compile those definitions not yet compiled.

\addvspace{18pt}

 \newpage \section{An Example of Simulation}
 \label{example}

 Here is an utterly concrete theorem about `stepn'.  Roughly speaking, the
 theorem states that if `stepn' executes 37 instructions starting in a state
 that contains machine code instructions for Euclid's GCD algorithm in ROM and
 the integers 54 and 42 on the stack, then the correct answer, 6, is the value of
 data register d0 in the resulting state.  This theorem has, of course, an
 utterly trivial proof: we just run `stepn' .  We present this trivial theorem
 here only to illustrate setting up `stepn' to run.

\begin{tabbing}{\sc Theorem}:  gcd-example \\ \index{gcd-example}
\=\+(\=\+({\it{stack-pointer\/}} $=$ ${\tt{EFFFE40}_{16}}$) \\ 
$\wedge$$\;\;\;\;$({\it{rfile\/}} $=$ {\tt{'}}{\tt{(}}\=\+{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}${\tt{EFFFE4C}_{16}}$ \\ 
${\tt{EFFFE40}_{16}}${\tt{)}}\-) \\ 
$\wedge$$\;\;\;\;$({\it{pc\/}} $=$ ${\tt{22B6}_{16}}$) \\ 
$\wedge$$\;\;\;\;$({\it{ccr\/}} $=$ {\tt{0}}) \\ 
$\wedge$$\;\;\;\;$({\it{gcd-code\/}} $=$ {\tt{'}}{\tt{(}}\=\+{\tt{78}}{\tt{ }}{\tt{86}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{72}}{\tt{ }}{\tt{231}}{\tt{ }}{\tt{48}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{36}}{\tt{ }}{\tt{46}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{8}}{\tt{ }}{\tt{38}}{\tt{ }}{\tt{46}}{\tt{ }}{\tt{0}} \\ 
{\tt{12}}{\tt{ }}{\tt{74}}{\tt{ }}{\tt{130}}{\tt{ }}{\tt{103}}{\tt{ }}{\tt{28}}{\tt{ }}{\tt{74}}{\tt{ }}{\tt{131}}{\tt{ }}{\tt{102}}{\tt{ }}{\tt{4}}{\tt{ }}{\tt{32}}{\tt{ }}{\tt{2}}{\tt{ }}{\tt{96}}{\tt{ }}{\tt{22}} \\ 
{\tt{182}}{\tt{ }}{\tt{130}}{\tt{ }}{\tt{108}}{\tt{ }}{\tt{8}}{\tt{ }}{\tt{76}}{\tt{ }}{\tt{67}}{\tt{ }}{\tt{40}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{36}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{96}}{\tt{ }}{\tt{232}}{\tt{ }}{\tt{76}} \\ 
{\tt{66}}{\tt{ }}{\tt{56}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{38}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{96}}{\tt{ }}{\tt{224}}{\tt{ }}{\tt{32}}{\tt{ }}{\tt{3}}{\tt{ }}{\tt{76}}{\tt{ }}{\tt{238}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{12}}{\tt{ }}{\tt{255}} \\ 
{\tt{248}}{\tt{ }}{\tt{78}}{\tt{ }}{\tt{94}}{\tt{ }}{\tt{78}}{\tt{ }}{\tt{117}}{\tt{)}}\-) \\ 
$\wedge$$\;\;\;\;$({\it{empty-memory\/}} $=$ {\tt{'}}{\tt{(}}\=\+{\tt{(}}\=\+{\tt{nil}} \\ 
{\tt{(}}{\tt{nil}}{\tt{ }}{\tt{(}}{\tt{nil}}{\tt{ }}{\tt{(}}{\tt{nil}}{\tt{ }}{\tt{(}}{\tt{nil}}{\tt{ }}{\tt{(}}{\tt{(}}{\tt{rom}}{\tt{)}}{\tt{ }}{\tt{nil}}{\tt{)}}{\tt{)}}{\tt{)}}{\tt{)}}{\tt{)}}{\tt{)}}\-{\tt{)}}\-) \\ 
$\wedge$$\;\;\;\;$({\it{mem\/}} $=$ {\rm{load-lst-mem}}\,(\=\+{\tt{4}}, \\ 
{\tt{'}}{\tt{(}}${\tt{22B2}_{16}}${\tt{ }}{\tt{54}}{\tt{ }}{\tt{42}}{\tt{)}}, \\ 
{\it{stack-pointer\/}}, \\ 
{\rm{load-lst-mem}}\,({\tt{1}}, {\it{gcd-code\/}}, {\it{pc\/}}, {\it{empty-memory\/}})\index{load-lst-mem})\-\index{load-lst-mem}) \\ 
$\wedge$$\;\;\;\;$({\it{initial-state\/}} $=$ {\rm{mc-state}}\,({\tt{'}}{\tt{running}}, {\it{rfile\/}}, {\it{pc\/}}, {\it{ccr\/}}, {\it{mem\/}})\index{mc-state}) \\ 
$\wedge$$\;\;\;\;$({\it{final-state\/}} $=$ {\rm{stepn}}\,({\it{initial-state\/}}, {\tt{37}})\index{stepn}))\- \\ 
$\rightarrow$$\;\;\;\;$(\=\+({\rm{mc-status}}\,({\it{final-state\/}})\index{mc-status} $=$ {\tt{'}}{\tt{running}}) \\ 
$\wedge$$\;\;\;\;$(\=\+{\rm{mc-rfile}}\,({\it{final-state\/}})\index{mc-rfile} \\ 
$=$$\;\;\;\;${\tt{'}}{\tt{(}}\=\+{\tt{6}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}}{\tt{ }}{\tt{0}} \\ 
${\tt{EFFFE4C}_{16}}${\tt{ }}${\tt{EFFFE44}_{16}}${\tt{)}}\-)\- \\ 
$\wedge$$\;\;\;\;$({\rm{mc-pc}}\,({\it{final-state\/}})\index{mc-pc} $=$ ${\tt{22B2}_{16}}$))\-\-
\end{tabbing}

 \bigskip Here is a paraphrase of the foregoing theorem.  The
 specific numbers in the theorem are derived from the compilation of
 a C program for GCD and from the result of loading that program on
 a Sun-3.
 \begin{itemize}
 \item If \begin{enumerate}
 \item {\it{stack-pointer\/}} = ${\tt{EFFFE40}_{16}}$,
 \item the register file {\it{rfile\/}} is all {\tt{0}}'s excepting for A6 and SP,
 which are ${\tt{EFFFE4C}_{16}}$ and {\it{stack-pointer\/}}, respectively,
 \item   the program counter {\it{pc\/}} = ${\tt{22B6}_{16}}$ and the condition code register {\it{ccr\/}} = {\tt{0}},
 \item  {\it{gcd-code\/}} is the long list of integers above beginning with {\tt{78}}
 and ending with {\tt{117}},
 \item {\it{empty-memory\/}} is a pair representing a 32-bit wide memory
 which has a {\tt{0}} byte at every address, which is of type ROM from
 address ${\tt{0}_{16}}$ to address ${\tt{07FFFFFF}_{16}}$, and which is of type RAM at
 all other addresses,
 \item  {\it{mem\/}} is the result of first loading
 {\it{gcd-code\/}} into an empty memory at {\it{pc\/}} and then further loading the
 two natural numbers {\tt{54}} and {\tt{42}} and the return address of the
 caller (${\tt{22B2}_{16}}$) at the location pointed to by
 {\it{stack-pointer\/}},
 \item  {\it{initial-state\/}} is an mc-state whose five fields
 are {\tt{'}}{\tt{running}}, {\it{rfile\/}}, {\it{pc\/}}, {\it{ccr\/}}, and {\it{mem\/}}, respectively, and finally
 \item  {\it{final-state\/}} is the result of running `stepn' for
 {\tt{37}} instructions starting with {\it{initial-state\/}}, \end{enumerate}
 \item then, if we examine {\it{final-state\/}}, we
 find:
 \begin{enumerate}
 \item the machine is still {\tt{'}}{\tt{running}},
 \item the register file is {\tt{'}}{\tt{(}}{\tt{6}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} {\tt{0}} ${\tt{EFFFE4C}_{16}}$ ${\tt{EFFFE44}_{16}}${\tt{)}}, observing that d0 is
 equal to {\tt{6}}, the GCD of {\tt{54}} and {\tt{42}}, and
 \item  the program counter is set to
 ${\tt{22B2}_{16}}$, the return address to the caller. \end{enumerate} \end{itemize}

 This
 theorem should not be confused with the much more general theorem
 stating the correctness of the same GCD program on {\em all} input, a theorem
 whose mechanical proof is described in \cite{Boyer-Yu-91}.


\noindent{\sc Event}:   Make the library {\tt{"mc20-1"}} and compile it.

\addvspace{18pt}

 
\newpage\section{Acknowledgements}

We would like to thank Bill Bevier, Don Good, Warren Hunt, Matt
Kaufmann, J Moore, and Bill Schelter for their many constructive
suggestions and discussions.  Special thanks to Fay Goytowski for her
meticulous reading of the MC68020 specification, which revealed a
dozen or so errors, and to Ken Albin for setting up a test suite for
our MC68020 model, which further revealed ??? errors. The general
style of Nqthm formalization used in this MC68020 specification is the
product of over a decade of study by the authors of Nqthm and their
students.  Especially influential was the FM8502 and Piton work
\cite{m:stack}.  The development of Nqthm was primarily supported by
NSF, ONR, and DARPA.

\newpage
\section{Syntax Summary}
\label{syntax}
        Here is a summary of the conventional syntax used in this report in terms of the official syntax
        of the Nqthm logic described in \cite{BM-88}.  (`cond' and `let' are recent extensions not
        described in \cite{BM-88}.)

        \begin{enumerate}
        \item Variables.  {\it{x\/}}, {\it{y\/}}, {\it{z\/}}, etc. are printed in italics.

        \item Function application.  For any function symbol for which special
        syntax is not given below, an application of the symbol is printed with
        the usual notation; e.g., the term {\tt{(}}{\tt{fn}} {\tt{x}} {\tt{y}} {\tt{z}}{\tt{)}} is
        printed as {\rm{fn}}\,({\it{x\/}}, {\it{y\/}}, {\it{z\/}}).  Note that the function symbol is printed in
        Roman.  In the special case that `c' is a function symbol of no
        arguments, i.e., it is a constant, the term {\tt{(}}{\tt{c}}{\tt{)}} is printed merely as
        {\sc{c}}, in small caps, with no trailing parentheses.  Because variables are printed in
        italics, there is no confusion between the printing of variables and
        constants.

        \item Other constants.  {\bf{t}}, {\bf{f}}, and {\bf{nil}} are printed in bold.
        Quoted constants are printed in the ordinary fashion of the Nqthm logic,
        e.g., {\tt '(a b c)} is still printed just that way.  \verb+#b001+ is printed
        as ${\tt{001_{2}}}$, \verb+#o765+ is printed as ${\tt{765_{8}}}$, and \verb+#xA9+ is printed as
        ${\tt{A9_{16}}}$ .\item {\tt{(}}{\tt{if}} {\tt{x}} {\tt{y}} {\tt{z}}{\tt{)}} is printed as 

{\bf if }{\it{x\/}} {\bf then }{\it{y\/}} {\bf else }{\it{z\/}}$\;${\bf  endif}.

\item {\tt{(}}{\tt{cond}} {\tt{(}}{\tt{test1}} {\tt{value1}}{\tt{)}} {\tt{(}}{\tt{test2}} {\tt{value2}}{\tt{)}} {\tt{(}}{\tt{t}} {\tt{value3}}{\tt{)}}{\tt{)}} is printed as 

{\bf if }{\it{test1\/}} {\bf then }{\it{value1\/}} {\bf elseif }{\it{test2\/}} {\bf then }{\it{value2\/}} {\bf else }{\it{value3\/}}$\;${\bf  endif}.

\item {\tt{(}}{\tt{let}} {\tt{(}}{\tt{(}}{\tt{var1}} {\tt{val1}}{\tt{)}} {\tt{(}}{\tt{var2}} {\tt{val2}}{\tt{)}}{\tt{)}} {\tt{form}}{\tt{)}} is printed as 

{\bf let }{\it{var1\/}}{\bf $\;$ be$\;$}{\it{val1\/}}, {\it{var2\/}}{\bf $\;$ be$\;$}{\it{val2\/}} {\bf in} {\it{form\/}}$\;${\bf  endlet}.

\item  The remaining function symbols that are printed specially are
               described in the following table.

\end{enumerate}

\begin{tabular}{|c|c|}\hline
Nqthm Syntax &  Conventional Syntax \\ \hline \hline{\tt{(}}{\tt{or}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\vee$ {\it{y\/}} \\  
{\tt{(}}{\tt{and}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\wedge$ {\it{y\/}} \\  
{\tt{(}}{\tt{times}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $*$ {\it{y\/}} \\  
{\tt{(}}{\tt{plus}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $+$ {\it{y\/}} \\  
{\tt{(}}{\tt{remainder}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} ${\rm\bf{mod}}$ {\it{y\/}} \\  
{\tt{(}}{\tt{quotient}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\div$ {\it{y\/}} \\  
{\tt{(}}{\tt{difference}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $-$ {\it{y\/}} \\  
{\tt{(}}{\tt{implies}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\rightarrow$ {\it{y\/}} \\  
{\tt{(}}{\tt{member}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\in$ {\it{y\/}} \\  
{\tt{(}}{\tt{geq}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\geq$ {\it{y\/}} \\  
{\tt{(}}{\tt{greaterp}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $>$ {\it{y\/}} \\  
{\tt{(}}{\tt{leq}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\leq$ {\it{y\/}} \\  
{\tt{(}}{\tt{lessp}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $<$ {\it{y\/}} \\  
{\tt{(}}{\tt{equal}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $=$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{member}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\in$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{geq}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\geq$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{greaterp}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not>$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{leq}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\leq$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{lessp}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not<$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{equal}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not=$ {\it{y\/}} \\  
{\tt{(}}{\tt{minus}} {\tt{x}}{\tt{)}}&$-$ {\it{x\/}} \\  
{\tt{(}}{\tt{add1}} {\tt{x}}{\tt{)}}&$1\;+$ {\it{x\/}} \\  
{\tt{(}}{\tt{nlistp}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\simeq {\rm{\bf{nil}}}$ \\  
{\tt{(}}{\tt{zerop}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\simeq 0$ \\  
{\tt{(}}{\tt{numberp}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\in {\rm\bf{N}}$ \\  
{\tt{(}}{\tt{sub1}} {\tt{x}}{\tt{)}}&{\it{x\/}} $-\;1$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{nlistp}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\simeq {\rm{\bf{nil}}}$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{zerop}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\simeq 0$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{numberp}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\in {\rm\bf{N}}$ \\  
  \hline \end{tabular}

\newpage

\begin{thebibliography}{99}

\bibitem{m:stack} William~Bevier, J~Strother~Moore, Warren~Hunt, and William
Young.  Special issue on system verification.  {\em Journal of Automated
Reasoning}, 5(4), 1989.

\bibitem{BM-88} Robert S. Boyer and J Strother Moore. {\em A Computational
Logic Handbook}. Academic Press, 1988.

\bibitem{Boyer-Yu-91} Robert S. Boyer and Yuan Yu.  Automated Correctness
Proofs of Machine Code Programs for a Commercial Microprocessor, Technical
Report TR-91-33, University of Texas at Austin, to appear in the proceedings of
the 11th International Conference on Automated Deduction, Lecture Notes in
Computer Science, Springer-Verlag, 1992.

\bibitem{m20} Motorola, Inc.  {\em MC68020 32-bit Microprocessor User's
Manual}.  Prentice Hall, New Jersey, 1989.

\end{thebibliography}

\newpage
\addcontentsline{toc}{section}{Index}


%\end{list}
\printindex
\end{document}
