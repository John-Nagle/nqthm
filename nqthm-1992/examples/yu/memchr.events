#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the MEMCHR Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of memchr function in the Berkeley string library.

void *
memchr(s, c, n)
	const void *s;
	register unsigned char c;
	register size_t n;
{
	if (n != 0) {
		register const unsigned char *p = s;

		do {
			if (*p++ == c)
				return ((void *)(p - 1));
		} while (--n != 0);
	}
	return (NULL);
}

The MC68020 assembly code of the C function memchr on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x27e8 <memchr>:        linkw fp,#0
0x27ec <memchr+4>:      moveb fp@(15),d1
0x27f0 <memchr+8>:      movel fp@(16),d0
0x27f4 <memchr+12>:     beq 0x2808 <memchr+32>
0x27f6 <memchr+14>:     moveal fp@(8),a0
0x27fa <memchr+18>:     cmpb a0@+,d1
0x27fc <memchr+20>:     bne 0x2804 <memchr+28>
0x27fe <memchr+22>:     movel a0,d0
0x2800 <memchr+24>:     subl #1,d0
0x2802 <memchr+26>:     bra 0x280a <memchr+34>
0x2804 <memchr+28>:     subl #1,d0
0x2806 <memchr+30>:     bne 0x27fa <memchr+18>
0x2808 <memchr+32>:     clrl d0
0x280a <memchr+34>:     unlk fp
0x280c <memchr+36>:     rts

The machine code of the above program is:

<memchr>:        0x4e56  0x0000  0x122e  0x000f  0x202e  0x0010  0x6712  0x206e
<memchr+16>:     0x0008  0xb218  0x6606  0x2008  0x5380  0x6006  0x5380  0x66f2
<memchr+32>:     0x4280  0x4e5e  0x4e75

'(78      86      0       0       18      46      0       15
  32      46      0       16      103     18      32      110
  0       8       178     24      102     6       32      8
  83      128     96      6       83      128     102     242
  66      128     78      94      78      117)
|#

; in the logic, the above program is defined by (memchr-code).
(defn memchr-code ()
  '(78      86      0       0       18      46      0       15
    32      46      0       16      103     18      32      110
    0       8       178     24      102     6       32      8
    83      128     96      6       83      128     102     242
    66      128     78      94      78      117))

; the computation time of the program.
(defn memchr-t1 (i n lst ch)
  (if (equal (get-nth i lst) ch)
      7
    (if (equal (sub1 n) 0)
	7
      (splus 4 (memchr-t1 (add1 i) (sub1 n) lst ch)))))

(defn memchr-t (n lst ch)
  (if (equal n 0)
      7
    (splus 5 (memchr-t1 0 n lst ch))))

; an induction hint.
(defn memchr-induct (s i* i n lst ch)
  (if (equal (get-nth i lst) ch)
      t
    (if (equal (sub1 n) 0)
	t
      (memchr-induct (stepn s 4) (add 32 i* 1) (add1 i) (sub1 n) lst ch))))

; the preconditions of the initial state.
(defn memchr-statep (s str n lst ch)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 38)
       (mcode-addrp (mc-pc s) (mc-mem s) (memchr-code))
       (ram-addrp (sub 32 4 (read-sp s)) (mc-mem s) 20)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint (sub 32 4 (read-sp s)) 20 str n)
       (equal str (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal ch (uread-mem (add 32 (read-sp s) 11) (mc-mem s) 1))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (not (equal (nat-to-uint str) 0))
       (uint-rangep (plus (nat-to-uint str) n) 32)))

; an intermediate state.
(defn memchr-s0p (s i* i str n lst ch n_)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 18 (mc-pc s)) (mc-mem s) 38)
       (mcode-addrp (sub 32 18 (mc-pc s)) (mc-mem s) (memchr-code))
       (ram-addrp (read-an 32 6 s) (mc-mem s) 20)
       (ram-addrp str (mc-mem s) n_)
       (mem-lst 1 str (mc-mem s) n_ lst)
       (disjoint (read-an 32 6 s) 20 str n_)
       (equal* (read-an 32 0 s) (add 32 str i*))
       (equal ch (nat-to-uint (read-dn 8 1 s)))
       (equal n (nat-to-uint (read-dn 32 0 s)))
       (equal i (nat-to-uint i*))
       (leq (plus i n) n_)
       (not (equal n 0))
       (numberp i*)
       (numberp n_)
       (nat-rangep i* 32)
       (uint-rangep n_ 32)))

; from the intial state s to exit: s --> sn.
(prove-lemma memchr-s-sn (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (equal n 0))
              (and (equal (mc-status (stepn s 7)) 'running)
                   (equal (mc-pc (stepn s 7)) (rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) 0)
                   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
                          (add 32 (read-an 32 7 s) 4))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (read-an 32 6 s)))))

(prove-lemma memchr-s-sn-rfile (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (equal n 0)
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memchr-s-sn-mem (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (equal n 0)
                   (disjoint x k (sub 32 4 (read-sp s)) 20))
              (equal (read-mem x (mc-mem (stepn s 7)) k)
                     (read-mem x (mc-mem s) k))))

; from the initial state s to s0: s --> s0.
(prove-lemma memchr-s-s0 ()
     (implies (and (memchr-statep s str n lst ch)
                   (not (equal n 0)))
              (memchr-s0p (stepn s 5) 0 0 str n lst ch n)))

(prove-lemma memchr-s-s0-else (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (not (equal n 0)))
	      (and (equal (linked-rts-addr (stepn s 5)) (rts-addr s))
                   (equal (linked-a6 (stepn s 5)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 5)))
                          (sub 32 4 (read-sp s))))))

(prove-lemma memchr-s-s0-rfile (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (not (equal n 0))
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 5)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma memchr-s-s0-mem (rewrite)
     (implies (and (memchr-statep s str n lst ch)
                   (not (equal n 0))
                   (disjoint x k (sub 32 4 (read-sp s)) 20))
              (equal (read-mem x (mc-mem (stepn s 5)) k)
                     (read-mem x (mc-mem s) k))))

; from s0 to exit: s0 --> sn.
; base case 1: s0 --> sn, when lst[i] = ch.
(prove-lemma memchr-s0-sn-base1 (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
                   (equal (get-nth i lst) ch))
              (and (equal (mc-status (stepn s 7)) 'running)
                   (equal (mc-pc (stepn s 7)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) (add 32 str i*))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (linked-a6 s))
                   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
                          (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma memchr-s0-sn-rfile-base1 (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
                   (equal (get-nth i lst) ch)
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

; base case 2: s0 --> sn, when lst[i] =\= ch, n-1 = 0.
(prove-lemma memchr-s0-sn-base2 (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
                   (not (equal (get-nth i lst) ch))
		   (equal (sub1 n) 0))
              (and (equal (mc-status (stepn s 7)) 'running)
                   (equal (mc-pc (stepn s 7)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) 0)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (linked-a6 s))
                   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
                          (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma memchr-s0-sn-rfile-base2 (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
                   (not (equal (get-nth i lst) ch))
		   (equal (sub1 n) 0)
		   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
                     (read-rn oplen rn (mc-rfile s)))))

; induction case: s0 --> s0.
(prove-lemma memchr-s0-s0 (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
		   (not (equal (get-nth i lst) ch))
                   (not (equal (sub1 n) 0)))
              (and (memchr-s0p (stepn s 4) (add 32 i* 1) (add1 i) str (sub1 n)
                               lst ch n_)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 4)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 4)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 4)) 
			  (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 4)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma memchr-s0-s0-rfile (rewrite)
     (implies (and (memchr-s0p s i* i str n lst ch n_)
		   (not (equal (get-nth i lst) ch))
                   (not (equal (sub1 n) 0))
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
                     (read-rn oplen rn (mc-rfile s)))))

; put together (s0 --> exit).
(prove-lemma memchr-s0-sn (rewrite)
     (let ((sn (stepn s (memchr-t1 i n lst ch))))
       (implies (memchr-s0p s i* i str n lst ch n_)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn)
			    (if (memchr1 i n lst ch) 
				(add 32 str (memchr* i* i n lst ch))
			      0))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (memchr-induct s i* i n lst ch))
      (disable memchr-s0p read-dn)))

(prove-lemma memchr-s0-sn-rfile (rewrite)
     (implies 
      (and (memchr-s0p s i* i str n lst ch n_)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (memchr-t1 i n lst ch))))
	     (read-rn oplen rn (mc-rfile s))))
     ((induct (memchr-induct s i* i n lst ch))
      (disable memchr-s0p)))

; the correctness of the MEMCHR program.
(prove-lemma memchr-correctness (rewrite)
     (let ((sn (stepn s (memchr-t n lst ch))))
       (implies (memchr-statep s str n lst ch)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (d2-7a2-5p rn)
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 4 (read-sp s)) 20)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn)
			    (if (memchr n lst ch)
				(add 32 str (memchr* 0 0 n lst ch))
			      0)))))
     ((use (memchr-s-s0))
      (disable memchr-statep memchr-s0p linked-rts-addr linked-a6 read-dn)))

(disable memchr-t)

; memchr* --> memchr.
(prove-lemma memchr*-memchr1 (rewrite)
     (implies (and (memchr1 i n lst ch)
		   (equal i (nat-to-uint i*))
		   (nat-rangep i* 32)
		   (uint-rangep (plus i n) 32))
	      (equal (nat-to-uint (memchr* i* i n lst ch))
		     (memchr1 i n lst ch)))
     ((induct (memchr* i* i n lst ch))))

(prove-lemma memchr-non-zerop-la ()
     (let ((sn (stepn s (memchr-t n lst ch))))
       (implies (and (memchr-statep s str n lst ch)
		     (numberp n)
		     (nat-rangep str 32)
		     (not (equal (nat-to-uint str) 0))
		     (uint-rangep (plus (nat-to-uint str) n) 32)
		     (memchr n lst ch))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((enable nat-rangep-la)
      (disable memchr-statep memchr-t read-dn)))

(prove-lemma memchr-non-zerop (rewrite)
     (let ((sn (stepn s (memchr-t n lst ch))))
       (implies (and (memchr-statep s str n lst ch)
		     (memchr n lst ch))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((use (memchr-non-zerop-la))))

(disable memchr*)

; some properties of memchr.
; see file cstring.events.