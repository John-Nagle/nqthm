#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRNCPY Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strncpy function in the Berkeley string library.

char *
strncpy(dst, src, n)
	char *dst;
	const char *src;
	register size_t n;
{
	if (n != 0) {
		register char *d = dst;
		register const char *s = src;

		do {
			if ((*d++ = *s++) == 0) {
				/* NUL pad the remaining n-1 bytes */
				while (--n != 0)
					*d++ = 0;
				break;
			}
		} while (--n != 0);
	}
	return (dst);
}

The MC68020 assembly code of the C function strncpy on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2650 <strncpy>:       linkw fp,#0
0x2654 <strncpy+4>:     movel d2,sp@-
0x2656 <strncpy+6>:     movel fp@(8),d2
0x265a <strncpy+10>:    movel fp@(16),d1
0x265e <strncpy+14>:    beq 0x267a <strncpy+42>
0x2660 <strncpy+16>:    moveal d2,a0
0x2662 <strncpy+18>:    moveal fp@(12),a1
0x2666 <strncpy+22>:    moveb a1@+,d0
0x2668 <strncpy+24>:    moveb d0,a0@+
0x266a <strncpy+26>:    bne 0x2676 <strncpy+38>
0x266c <strncpy+28>:    bra 0x2670 <strncpy+32>
0x266e <strncpy+30>:    clrb a0@+
0x2670 <strncpy+32>:    subl #1,d1
0x2672 <strncpy+34>:    bne 0x266e <strncpy+30>
0x2674 <strncpy+36>:    bra 0x267a <strncpy+42>
0x2676 <strncpy+38>:    subl #1,d1
0x2678 <strncpy+40>:    bne 0x2666 <strncpy+22>
0x267a <strncpy+42>:    movel d2,d0
0x267c <strncpy+44>:    movel fp@(-4),d2
0x2680 <strncpy+48>:    unlk fp
0x2682 <strncpy+50>:    rts

The machine code of the above program is:

<strncpy>:     0x4e56  0x0000  0x2f02  0x242e  0x0008  0x222e  0x0010  0x671a
<strncpy+16>:  0x2042  0x226e  0x000c  0x1019  0x10c0  0x660a  0x6002  0x4218
<strncpy+32>:  0x5381  0x66fa  0x6004  0x5381  0x66ec  0x2002  0x242e  0xfffc
<strncpy+48>:  0x4e5e  0x4e75

'(78      86      0       0       47      2       36      46
  0       8       34      46      0       16      103     26
  32      66      34      110     0       12      16      25
  16      192     102     10      96      2       66      24
  83      129     102     250     96      4       83      129
  102     236     32      2       36      46      255     252
  78      94      78      117)
|#
; in the logic, the above program is defined by (strncpy-code).
(defn strncpy-code ()
  '(78      86      0       0       47      2       36      46
    0       8       34      46      0       16      103     26
    32      66      34      110     0       12      16      25
    16      192     102     10      96      2       66      24
    83      129     102     250     96      4       83      129
    102     236     32      2       36      46      255     252
    78      94      78      117))

; the computation time of the program.
(defn strncpy-t0 (i n)
  (if (equal (sub1 n) 0)
      7
    (splus 3 (strncpy-t0 (add1 i) (sub1 n)))))

(defn strncpy-t1 (i n)
  (splus 4 (strncpy-t0 (add1 i) n)))

(defn strncpy-t2 (i n lst2)
  (if (equal (get-nth i lst2) 0)
      (strncpy-t1 i n)
    (if (equal (sub1 n) 0)
	9
      (splus 5 (strncpy-t2 (add1 i) (sub1 n) lst2)))))

(defn strncpy-t (n lst2)
  (if (zerop n)
      9
    (splus 7 (strncpy-t2 0 n lst2))))

; two induction hints.
(defn strncpy-induct1 (s i* i n lst1)
  (if (equal (sub1 n) 0)
      t
    (strncpy-induct1 (stepn s 3) (add 32 i* 1) (add1 i) (sub1 n)
		     (put-nth 0 i lst1))))

(defn strncpy-induct2 (s i* i n lst1 lst2)
  (if (equal (get-nth i lst2) 0)
      t
    (if (equal (sub1 n) 0)
	t
      (strncpy-induct2 (stepn s 5) (add 32 i* 1) (add1 i) (sub1 n)
		       (put-nth (get-nth i lst2) i lst1) lst2))))
	
; the preconditions of the initial state.
(defn strncpy-statep (s str1 n lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 52)
       (mcode-addrp (mc-pc s) (mc-mem s) (strncpy-code))
       (ram-addrp (sub 32 8 (read-sp s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n)
       (mem-lst 1 str1 (mc-mem s) n lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 8 (read-sp s)) 24 str1 n)
       (disjoint (sub 32 8 (read-sp s)) 24 str2 n2)
       (disjoint str1 n str2 n2)
       (lessp (slen 0 n lst2) n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal n (uread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (numberp n2)))  

; an intermediate state s0.
(defn strncpy-s0p (s i* i str1 n_ lst1 str2 n2 lst2 n)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 22 (mc-pc s)) (mc-mem s) 52)
       (mcode-addrp (sub 32 22 (mc-pc s)) (mc-mem s) (strncpy-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str1 n_)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str2 n2)
       (disjoint str1 n_ str2 n2)
       (lessp (slen i n_ lst2) n2)
       (equal* (read-an 32 0 s) (add 32 str1 i*))
       (equal* (read-an 32 1 s) (add 32 str2 i*))
       (equal str1 (read-dn 32 2 s))
       (equal n (nat-to-uint (read-dn 32 1 s)))
       (leq (plus i n) n_)
       (not (equal n 0))
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (numberp n2)
       (numberp n_)
       (uint-rangep n_ 32)))

; an intermediate state s1.
(defn strncpy-s1p (s i* i str1 n_ lst1 str2 n2 lst2 n)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 32 (mc-pc s)) (mc-mem s) 52)
       (mcode-addrp (sub 32 32 (mc-pc s)) (mc-mem s) (strncpy-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n_)
       (mem-lst 1 str1 (mc-mem s) n_ lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str1 n_)
       (disjoint (sub 32 4 (read-an 32 6 s)) 24 str2 n2)
       (disjoint str1 n_ str2 n2)
       (equal* (read-an 32 0 s) (add 32 str1 i*))
       (equal str1 (read-dn 32 2 s))
       (equal n (nat-to-uint (read-dn 32 1 s)))
       (equal i (nat-to-uint i*))
       (leq (plus i (sub1 n)) n_)
       (not (equal n 0))
       (numberp i*)
       (nat-rangep i* 32)
       (numberp n2)
       (numberp n_)
       (uint-rangep n_ 32)))

; from the initial state s to exit: s --> sn, when n = 0.
(prove-lemma strncpy-s-sn (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (zerop n))
	      (and (equal (mc-status (stepn s 9)) 'running)
		   (equal (mc-pc (stepn s 9)) (rts-addr s))
		   (equal (read-dn 32 0 (stepn s 9)) str1)
		   (mem-lst 1 str1 (mc-mem (stepn s 9)) n lst1)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 9)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 9))) 
			  (read-an 32 6 s)))))

(prove-lemma strncpy-s-sn-rfile (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (zerop n)
		   (leq oplen 32)
		   (d2-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncpy-s-sn-mem (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (zerop n)
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 9)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state s to s0: s --> s0.
(prove-lemma strncpy-s-s0 ()
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (not (zerop n)))
              (strncpy-s0p (stepn s 7) 0 0 str1 n lst1 str2 n2 lst2 n)))

(prove-lemma strncpy-s-s0-else (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (not (zerop n)))
              (and (equal (linked-rts-addr (stepn s 7)) (rts-addr s))
                   (equal (linked-a6 (stepn s 7)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (sub 32 4 (read-sp s)))
		   (equal (rn-saved (stepn s 7)) 
			  (read-rn 32 2 (mc-rfile s))))))

(prove-lemma strncpy-s-s0-rfile (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (not (zerop n))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncpy-s-s0-mem (rewrite)
     (implies (and (strncpy-statep s str1 n lst1 str2 n2 lst2)
		   (not (zerop n))
		   (disjoint x k (sub 32 8 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to exit: s0 --> sn.  By induction.
; base case 1:  s0 --> sn, when lst1[i] = 0.  
; s0 --> s1.
(prove-lemma strncpy-s0-s1 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0))
	      (and (strncpy-s1p (stepn s 4) (add 32 i* 1) (add1 i) str1 n_
				(put-nth (get-nth i lst2) i lst1) str2 n2 
				lst2 n)
                   (equal (linked-rts-addr (stepn s 4))
			  (linked-rts-addr s))
                   (equal (linked-a6 (stepn s 4)) (linked-a6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 4)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (rn-saved (stepn s 4)) (rn-saved s)))))

(prove-lemma strncpy-s0-s1-rfile (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncpy-s0-s1-mem (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (disjoint x k str1 n_))				   
	      (equal (read-mem x (mc-mem (stepn s 4)) k)
		     (read-mem x (mc-mem s) k))))

; s1 --> sn.  By induction.
; base case: s1 --> exit, when n-1 = 0.
(prove-lemma strncpy-s1-sn-base (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (sub1 n) 0))
	      (and (equal (mc-status (stepn s 7)) 'running)
		   (equal (mc-pc (stepn s 7)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 7)) str1)
		   (mem-lst 1 str1 (mc-mem (stepn s 7)) n_ lst1)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 7)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strncpy-s1-sn-rfile-base (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (sub1 n) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen)))))

; induction case: s1 --> s1, when n-1 =\= 0.
(prove-lemma strncpy-s1-s1 (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (sub1 n) 0)))
	      (and (strncpy-s1p (stepn s 3) (add 32 i* 1) (add1 i) str1 
				n_ (put-nth 0 i lst1) str2 n2 lst2 (sub1 n))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 3)) (linked-rts-addr s))
		   (equal (rn-saved (stepn s 3)) (rn-saved s)))))

(prove-lemma strncpy-s1-s1-rfile (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (sub1 n) 0))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncpy-s1-s1-mem (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (disjoint x k str1 n_)
		   (not (equal (sub1 n) 0)))
	      (equal (read-mem x (mc-mem (stepn s 3)) k)
		     (read-mem x (mc-mem s) k))))

; put together. s1 --> exit.
(prove-lemma strncpy-s1-sn (rewrite)
     (let ((sn (stepn s (strncpy-t0 i n))))
       (implies (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ (zero-list1 i n lst1))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strncpy-induct1 s i* i n lst1))
      (disable strncpy-s1p read-dn)))
		   
(prove-lemma strncpy-s1-sn-rfile (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (strncpy-t0 i n))))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen))))
     ((induct (strncpy-induct1 s i* i n lst1))
      (disable strncpy-s1p)))

(prove-lemma strncpy-s1-sn-mem (rewrite)
     (implies (and (strncpy-s1p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (disjoint x k str1 n_))
	      (equal (read-mem x (mc-mem (stepn s (strncpy-t0 i n))) k)
		     (read-mem x (mc-mem s) k)))
     ((induct (strncpy-induct1 s i* i n lst1))
      (disable strncpy-s1p)))

; put together (base case 1). s0 --> exit.
(prove-lemma strncpy-s0-sn-base1 (rewrite)
     (let ((sn (stepn s (strncpy-t1 i n))))
       (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		     (equal (get-nth i lst2) 0))
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ (zero-list i n lst1))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((use (strncpy-s0-s1))
      (disable strncpy-s0p strncpy-s1p read-dn)))
		   
(prove-lemma strncpy-s0-sn-rfile-base1 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (strncpy-t1 i n))))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen))))
     ((use (strncpy-s0-s1))
      (disable strncpy-s0p strncpy-s1p)))

(prove-lemma strncpy-s0-sn-mem-base1 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (equal (get-nth i lst2) 0)
		   (disjoint x k str1 n_))
	   (equal (read-mem x (mc-mem (stepn s (strncpy-t1 i n))) k)
		  (read-mem x (mc-mem s) k)))
     ((use (strncpy-s0-s1))
      (disable strncpy-s0p strncpy-s1p)))

; base case 2: s0 --> sn, when lst2[i] =\= 0, n-1 = 0.
(prove-lemma strncpy-s0-sn-base2 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0))
	      (and (equal (mc-status (stepn s 9)) 'running)
		   (equal (mc-pc (stepn s 9)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 9)) str1)
		   (mem-lst 1 str1 (mc-mem (stepn s 9)) n_ 
			    (put-nth (get-nth i lst2) i lst1))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 9)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 9)))
			  (add 32 (read-an 32 6 s) 8)))))

(prove-lemma strncpy-s0-sn-rfile-base2 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (if (d3-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (head (rn-saved s) oplen)))))

(prove-lemma strncpy-s0-sn-mem-base2 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (disjoint x k str1 n_)
		   (not (equal (get-nth i lst2) 0))
		   (equal (sub1 n) 0))
	      (equal (read-mem x (mc-mem (stepn s 9)) k)
		     (read-mem x (mc-mem s) k))))

; induction case:  s0 --> s0, when lst[i] =\= 0, n-1 =\= 0.
(prove-lemma strncpy-s0-s0 (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0)))
	      (and (strncpy-s0p (stepn s 5) (add 32 i* 1) (add1 i) str1 
				n_ (put-nth (get-nth i lst2) i lst1)
				str2 n2 lst2 (sub1 n))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 5)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 5)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 5)) (linked-rts-addr s))
		   (equal (rn-saved (stepn s 5)) (rn-saved s)))))

(prove-lemma strncpy-s0-s0-rfile (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 5)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strncpy-s0-s0-mem (rewrite)
     (implies (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		   (disjoint x k str1 n_)
		   (not (equal (get-nth i lst2) 0))
		   (not (equal (sub1 n) 0)))
	      (equal (read-mem x (mc-mem (stepn s 5)) k)
		     (read-mem x (mc-mem s) k))))

; put together. s0 --> exit.
(prove-lemma strncpy-s0-sn (rewrite)
     (let ((sn (stepn s (strncpy-t2 i n lst2))))
       (implies (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n_ (strncpy1 i n lst1 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strncpy-induct2 s i* i n lst1 lst2))
      (disable strncpy-s0p strncpy-t1 read-dn zero-list)))

(prove-lemma strncpy-s0-sn-rfile (rewrite)
     (implies 
      (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
	   (d2-7a2-5p rn)
	   (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strncpy-t2 i n lst2))))
	     (if (d3-7a2-5p rn)
		 (read-rn oplen rn (mc-rfile s))
	       (head (rn-saved s) oplen))))
     ((induct (strncpy-induct2 s i* i n lst1 lst2))
      (disable strncpy-s0p strncpy-t1)))

(prove-lemma strncpy-s0-sn-mem (rewrite)
     (implies 
      (and (strncpy-s0p s i* i str1 n_ lst1 str2 n2 lst2 n)
	   (disjoint x k str1 n_))
      (equal (read-mem x (mc-mem (stepn s (strncpy-t2 i n lst2))) k)
	     (read-mem x (mc-mem s) k)))
     ((induct (strncpy-induct2 s i* i n lst1 lst2))
      (disable strncpy-s0p strncpy-t1)))

; the correctness of strncpy.
(prove-lemma strncpy-correctness (rewrite)
     (let ((sn (stepn s (strncpy-t n lst2))))
       (implies (strncpy-statep s str1 n lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 7 s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (and (disjoint x k str1 n)
				   (disjoint x k (sub 32 8 (read-sp s)) 24))
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn) str1)
		     (mem-lst 1 str1 (mc-mem sn) n (strncpy n lst1 lst2)))))
     ((use (strncpy-s-s0))
      (disable strncpy-statep strncpy-s0p read-dn linked-rts-addr linked-a6)))

(disable strncpy-t)

; some properties of strncpy.
; see file cstring.events.