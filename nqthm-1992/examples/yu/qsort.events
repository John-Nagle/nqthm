#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;           Proof of the Correctness of a Quicksort Program
;
#|
The following C function QSORT sorts a[left], ..., a[right] into increasing 
order.  The program is a slightly modified version of K&R. 

/* qsort: sort a[left]...a[right] into increasing order.  We use the middle */
/* element of each subarray for partitioning.   */
void qsort (int a[], int left, int right)
{
  int i, last, temp;

  if (left >= right)
    return;
  last = (left + right) / 2;
  temp = a[left];
  a[left] = a[last];
  a[last] = temp;
  last = left;
  for (i = left + 1; i<= right; i++)
    if (a[i] < a[left]){
      temp = a[++last];
      a[last] = a[i];
      a[i] = temp;
    };
  temp = a[left];
  a[left] = a[last];
  a[last] = temp;
  qsort(a, left, last-1);
  qsort(a, last+1, right);
}

Here is the MC68020 assembly code of the above QSORT program.  The code is
generated by "gcc -O".

0x22b8 <qsort>:         linkw fp,#0
0x22bc <qsort+4>:       moveml d2-d4/a2-a3,sp@-
0x22c0 <qsort+8>:       moveal fp@(8),a3
0x22c4 <qsort+12>:      movel fp@(12),d3
0x22c8 <qsort+16>:      movel fp@(16),d4
0x22cc <qsort+20>:      cmpl d3,d4
0x22ce <qsort+22>:      ble 0x2338 <qsort+128>
0x22d0 <qsort+24>:      movel d3,d2
0x22d2 <qsort+26>:      addl d4,d2
0x22d4 <qsort+28>:      bpl 0x22d8 <qsort+32>
0x22d6 <qsort+30>:      addql #1,d2
0x22d8 <qsort+32>:      asrl #1,d2
0x22da <qsort+34>:      movel 0(a3)[d3.l*4],d1
0x22de <qsort+38>:      movel 0(a3)[d2.l*4],0(a3)[d3.l*4]
0x22e4 <qsort+44>:      movel d1,0(a3)[d2.l*4]
0x22e8 <qsort+48>:      movel d3,d2
0x22ea <qsort+50>:      movel d2,d0
0x22ec <qsort+52>:      bra 0x2308 <qsort+80>
0x22ee <qsort+54>:      moveal 0(a3)[d0.l*4],a0
0x22f2 <qsort+58>:      cmpal 0(a3)[d3.l*4],a0
0x22f6 <qsort+62>:      bge 0x2308 <qsort+80>
0x22f8 <qsort+64>:      addql #1,d2
0x22fa <qsort+66>:      movel 0(a3)[d2.l*4],d1
0x22fe <qsort+70>:      movel 0(a3)[d0.l*4],0(a3)[d2.l*4]
0x2304 <qsort+76>:      movel d1,0(a3)[d0.l*4]
0x2308 <qsort+80>:      addql #1,d0
0x230a <qsort+82>:      cmpl d0,d4
0x230c <qsort+84>:      bge 0x22ee <qsort+54>
0x230e <qsort+86>:      movel 0(a3)[d3.l*4],d1
0x2312 <qsort+90>:      movel 0(a3)[d2.l*4],0(a3)[d3.l*4]
0x2318 <qsort+96>:      movel d1,0(a3)[d2.l*4]
0x231c <qsort+100>:     moveal d2,a0
0x231e <qsort+102>:     pea a0@(-1)
0x2322 <qsort+106>:     movel d3,sp@-
0x2324 <qsort+108>:     movel a3,sp@-
0x2326 <qsort+110>:     lea 0x22b8 <qsort>,a2
0x232a <qsort+114>:     jsr a2@
0x232c <qsort+116>:     movel d4,sp@-
0x232e <qsort+118>:     moveal d2,a0
0x2330 <qsort+120>:     pea a0@(1)
0x2334 <qsort+124>:     movel a3,sp@-
0x2336 <qsort+126>:     jsr a2@
0x2338 <qsort+128>:     moveml fp@(-20),d2-d4/a2-a3
0x233e <qsort+134>:     unlk fp
0x2340 <qsort+136>:     rts

The machine code of the above program is:

<qsort>:      0x4e56  0x0000  0x48e7  0x3830  0x266e  0x0008  0x262e  0x000c
<qsort+16>:   0x282e  0x0010  0xb883  0x6f68  0x2403  0xd484  0x6a02  0x5282
<qsort+32>:   0xe282  0x2233  0x3c00  0x27b3  0x2c00  0x3c00  0x2781  0x2c00
<qsort+48>:   0x2403  0x2002  0x601a  0x2073  0x0c00  0xb1f3  0x3c00  0x6c10
<qsort+64>:   0x5282  0x2233  0x2c00  0x27b3  0x0c00  0x2c00  0x2781  0x0c00
<qsort+80>:   0x5280  0xb880  0x6ce0  0x2233  0x3c00  0x27b3  0x2c00  0x3c00
<qsort+96>:   0x2781  0x2c00  0x2042  0x4868  0xffff  0x2f03  0x2f0b  0x45fa
<qsort+112>:  0xff90  0x4e92  0x2f04  0x2042  0x4868  0x0001  0x2f0b  0x4e92
<qsort+128>:  0x4cee  0x0c1c  0xffec  0x4e5e  0x4e75

In the Logic, it looks like:

'(78      86      0       0       72      231     56      48
  38      110     0       8       38      46      0       12
  40      46      0       16      184     131     111     104
  36      3       212     132     106     2       82      130
  226     130     34      51      60      0       39      179
  44      0       60      0       39      129     44      0
  36      3       32      2       96      26      32      115
  12      0       177     243     60      0       108     16
  82      130     34      51      44      0       39      179
  12      0       44      0       39      129     12      0
  82      128     184     128     108     224     34      51
  60      0       39      179     44      0       60      0
  39      129     44      0       32      66      72      104
  255     255     47      3       47      11      69      250
  255     144     78      146     47      4       32      66
  72      104     0       1       47      11      78      146
  76      238     12      28      255     236     78      94
  78      117)
|#

; in the Logic, the above program is defined by (qsort-code).
(defn qsort-code ()
  '(78      86      0       0       72      231     56      48
    38      110     0       8       38      46      0       12
    40      46      0       16      184     131     111     104
    36      3       212     132     106     2       82      130
    226     130     34      51      60      0       39      179
    44      0       60      0       39      129     44      0
    36      3       32      2       96      26      32      115
    12      0       177     243     60      0       108     16
    82      130     34      51      44      0       39      179
    12      0       44      0       39      129     12      0
    82      128     184     128     108     224     34      51
    60      0       39      179     44      0       60      0
    39      129     44      0       32      66      72      104
    255     255     47      3       47      11      69      250
    255     144     78      146     47      4       32      66
    72      104     0       1       47      11      78      146
    76      238     12      28      255     236     78      94
    78      117))

(prove-lemma ilessp-lessp (rewrite)
     (implies (numberp x)
              (equal (ilessp x y) (lessp x y))))

(disable ilessp)
(enable iplus)
(enable idifference)
(enable iquotient)

; qsort is a function in Nqthm that characterizes the functional semantics of 
; the program (qsort-code).
(defn qpart-aux (l r lst last i)
  (if (lessp r i)
      (swap l last lst)
    (if (ilessp (get-nth i lst) (get-nth l lst))
        (qpart-aux l r (swap (add1 last) i lst) (add1 last) (add1 i))
      (qpart-aux l r lst last (add1 i))))
  ((lessp (difference (add1 r) i))))

(defn qpart (l r lst)
  (qpart-aux l r (swap l (quotient (plus l r) 2) lst) l (add1 l)))

(defn qlast-aux (l r lst last i)
  (if (lessp r i)
      (fix last)
    (if (ilessp (get-nth i lst) (get-nth l lst))
        (qlast-aux l r (swap (add1 last) i lst) (add1 last) (add1 i))
      (qlast-aux l r lst last (add1 i))))
  ((lessp (difference (add1 r) i))))

(defn qlast (l r lst)
  (qlast-aux l r (swap l (quotient (plus l r) 2) lst) l (add1 l)))

(prove-lemma qlast-aux-lb (rewrite)
     (implies (leq left last)
              (not (lessp (qlast-aux left right lst last i) left))))

(prove-lemma qlast-lb (rewrite)
     (not (lessp (qlast left right lst) left)))

(prove-lemma qlast-aux-ub (rewrite)
     (implies (and (lessp last i)
                   (leq i right))
              (not (lessp right (qlast-aux left right lst last i))))
     ((expand (qlast-aux left i lst last i)
              (qlast-aux left i lst last (add1 i))
              (qlast-aux left i lst (add1 last) (add1 i)))))

(prove-lemma qlast-ub (rewrite)
     (implies (lessp left right)
              (not (lessp right (qlast left right lst)))))

(disable qlast)
(disable qpart)

(defn qsort (l r lst)
  (if (lessp l r)
      (qsort (add1 (qlast l r lst))
             r
             (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
    lst)
  ((lessp (difference r l))))

; the computation time of the program.
(defn qpart-aux-t (a l r n lst last i)
  (if (lessp r i)
      11
    (if (ilessp (get-nth i lst) (get-nth l lst))
        (splus 10 
               (qpart-aux-t a l r n (swap (add1 last) i lst) 
                            (add1 last) (add1 i)))
      (splus 6 (qpart-aux-t a l r n lst last (add1 i)))))
  ((lessp (difference (add1 r) i))))

(defn qpart-t (a l r n lst)
  (let ((lst1 (swap l (quotient (plus l r) 2) lst)))
    (splus 18 (qpart-aux-t a l r n lst1 l (add1 l)))))

(defn qsort-10 (a l r n lst) 10)

(defn qsort-5 (a l r n lst) 5)

(defn qsort-3 (a l r n lst) 3)

(defn qsort-t (a l r n lst)
  (let ((last (qlast l r lst))
        (qlst (qpart l r lst)))
    (if (lessp l r)
        (splus (qpart-t a l r n lst)
               (splus (qsort-t a l (sub1 last) n qlst)
                      (splus (qsort-5 a l r n lst)
                             (splus (qsort-t a (add1 last) r n
                                             (qsort l (sub1 last) qlst))
                                    (qsort-3 a l r n lst)))))
      (qsort-10 a l r n lst)))
  ((lessp (difference r l))))

; an induction hint.
(defn qsort-induct (s a l r n lst)
  (let ((last (qlast l r lst))
        (qlst (qpart l r lst)))
    (if (lessp l r)
        (and (qsort-induct (stepn s (qpart-t a l r n lst))
                           a l (idifference last 1) n qlst)
             (qsort-induct 
              (stepn s (splus (qpart-t a l r n lst)
                              (splus (qsort-t a l (sub1 last) n qlst)
                                     (qsort-5 a l r n lst))))
              a (add1 last) r n (qsort l (sub1 last) qlst)))
      t))
  ((lessp (difference r l))))

; the preconditions of the initial state.
(defn qstack (l r lst)
  (let ((last (qlast l r lst))
        (lst1 (qpart l r lst)))
    (if (lessp l r)
        (max (plus 40 (qstack l (sub1 last) lst1))
             (plus 52 (qstack (add1 last) r (qsort l (sub1 last) lst1))))
      68))
  ((lessp (difference r l))))

(prove-lemma qstack-la0 (rewrite)
     (not (lessp (qstack l r lst) 68)))

(prove-lemma qstack-la1 (rewrite)
     (let ((last (qlast l r lst))
           (lst1 (qpart l r lst)))
       (implies (lessp l r)
                (not (lessp (qstack l r lst)
                            (plus 40 (qstack l (sub1 last) lst1)))))))

(prove-lemma qstack-la2 (rewrite)
     (let ((last (qlast l r lst))
           (lst1 (qpart l r lst)))
       (implies (lessp l r)
                (not (lessp (qstack l r lst)
                            (plus 52 (qstack (add1 last) 
                                             r 
                                             (qsort l (sub1 last) lst1))))))))

; an upper bound of stack space.
(prove-lemma qstack-ubound-la-1 (rewrite)
     (implies 
      (lessp l r)
      (not (lessp 
            (times 52 (difference r l))
            (plus 52 (times 52 (difference (sub1 (qlast l r lst)) l)))))))

(prove-lemma qstack-ubound-la-2 (rewrite)
     (implies 
      (lessp l r)
      (not (lessp 
            (times 52 (difference r l))
            (plus 52 (times 52 (difference r (add1 (qlast l r lst)))))))))

(prove-lemma qstack-ubound ()
     (leq (qstack l r lst)
          (plus 68 (times 52 (difference r l))))
     ((disable difference)))

(disable qstack)

; the initial state.
(defn qsort-statep (s a l r n lst)
  (let ((sp (sub 32 (difference (qstack l r lst) 16) (read-sp s))))
    (and (equal (mc-status s) 'running)
         (evenp (mc-pc s))
         (rom-addrp (mc-pc s) (mc-mem s) 138)
         (mcode-addrp (mc-pc s) (mc-mem s) (qsort-code))
         (ram-addrp a (mc-mem s) (times 4 n))
         (mem-ilst 4 a (mc-mem s) n lst)
         (ram-addrp sp (mc-mem s) (qstack l r lst))
         (disjoint a (times 4 n) sp (qstack l r lst))
         (equal a (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
         (equal l (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
         (equal r (iread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
         (lessp (qstack l r lst) (exp 2 32))
         (numberp l)
         (lessp r n)
         (uint-rangep (times 4 n) 32))))

(defn qsort-sp (s a l r n lst)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 138)
       (mcode-addrp (mc-pc s) (mc-mem s) (qsort-code))
       (ram-addrp a (mc-mem s) (times 4 n))
       (mem-ilst 4 a (mc-mem s) n lst)
       (equal a (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal l (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal r (iread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (numberp l)
       (numberp n)
       (lessp r n)
       (int-rangep n 32)
       (int-rangep (times 2 r) 32)
       (uint-rangep (times 4 n) 32)
       (ram-addrp (sub 32 52 (read-sp s)) (mc-mem s) 68)
       (disjoint a (times 4 n) (sub 32 52 (read-sp s)) 68)))

(prove-lemma qsort-statep-sp (rewrite)
     (implies (qsort-statep s a l r n lst)
              (qsort-sp s a l r n lst))
     ((enable int-rangep)))

; the conditions of the intermediate state s0.  s0 is the state of the 
; machine right before the for statement in the corresponding C program.
(defn qsort-s0p (s s0 a l r n lst last i)
  (and (equal (linked-rts-addr s0) (rts-addr s))
       (equal (linked-a6 s0) (read-an 32 6 s))
       (equal* (read-rn 32 14 (mc-rfile s0)) (sub 32 4 (read-sp s)))
       (equal* (read-rn 32 15 (mc-rfile s0)) (sub 32 24 (read-sp s)))
       (equal (movem-saved s0 4 20 5)
              (readm-rn 32 '(2 3 4 10 11) (mc-rfile s)))
       (equal (mc-status s0) 'running)
       (evenp (mc-pc s0))
       (rom-addrp (sub 32 82 (mc-pc s0)) (mc-mem s0) 138)
       (mcode-addrp (sub 32 82 (mc-pc s0)) (mc-mem s0) (qsort-code))
       (ram-addrp (sub 32 52 (read-sp s)) (mc-mem s0) 68)
       (ram-addrp a (mc-mem s0) (times 4 n))
       (mem-ilst 4 a (mc-mem s0) n lst)
       (disjoint a (times 4 n) (sub 32 52 (read-sp s)) 68)
       (equal a (read-an 32 3 s0))
       (equal l (nat-to-int (read-rn 32 3 (mc-rfile s0)) 32))
       (equal r (nat-to-int (read-rn 32 4 (mc-rfile s0)) 32))
       (equal last (nat-to-int (read-rn 32 2 (mc-rfile s0)) 32))
       (equal i (nat-to-int (read-rn 32 0 (mc-rfile s0)) 32))
       (numberp l)
       (numberp r)
       (numberp n)
       (numberp last)
       (numberp i)
       (lessp l r)
       (lessp last i)
       (leq i (add1 r))
       (lessp r n)
       (int-rangep n 32)
       (uint-rangep (times 4 n) 32)))

; the conditions of the intermediate state s1.  s1 is the machine 
; state after the execution of the first JSR instruction, but before
; the recursive execution of QSORT.
(defn qsort-s1p (s s1 a l r n lst last)
  (and (equal (linked-rts-addr s1) (rts-addr s))
       (equal (linked-a6 s1) (read-an 32 6 s))
       (equal* (read-rn 32 14 (mc-rfile s1)) (sub 32 4 (read-sp s)))
       (equal* (read-rn 32 15 (mc-rfile s1)) (sub 32 40 (read-sp s)))
       (equal (movem-saved s1 4 20 5)
              (readm-rn 32 '(2 3 4 10 11) (mc-rfile s)))
       (equal (mc-status s1) 'running)
       (equal (mc-pc s1) (read-an 32 2 s1))
       (evenp (read-an 32 2 s1))
       (evenp (rts-addr s1))
       (rom-addrp (read-an 32 2 s1) (mc-mem s1) 138)
       (mcode-addrp (read-an 32 2 s1) (mc-mem s1) (qsort-code))
       (rom-addrp (sub 32 116 (rts-addr s1)) (mc-mem s1) 138)
       (mcode-addrp (sub 32 116 (rts-addr s1)) (mc-mem s1) (qsort-code))
       (ram-addrp (sub 32 52 (read-sp s)) (mc-mem s1) 68)
       (ram-addrp a (mc-mem s1) (times 4 n))
       (mem-ilst 4 a (mc-mem s1) n lst)
       (disjoint a (times 4 n) (sub 32 52 (read-sp s)) 68)
       (equal a (read-an 32 3 s1))
       (equal l (nat-to-int (read-rn 32 3 (mc-rfile s1)) 32))
       (equal r (nat-to-int (read-rn 32 4 (mc-rfile s1)) 32))
       (equal last (nat-to-int (read-rn 32 2 (mc-rfile s1)) 32))
       (equal a (read-mem (add 32 (read-sp s1) 4) (mc-mem s1) 4))
       (equal l (iread-mem (add 32 (read-sp s1) 8) (mc-mem s1) 4))
       (equal (iread-mem (add 32 (read-sp s1) 12) (mc-mem s1) 4)
              (idifference last 1))
       (numberp l)
       (numberp r)
       (numberp last)
       (lessp l r)
       (leq last r)
       (lessp r n)
       (int-rangep n 32)
       (uint-rangep (times 4 n) 32)))

; the conditions of the intermediate state s2.  s2 is the machine 
; state right after the first recursive call to QSORT.
(defn qsort-s2p (s s2 a l r n lst last)
  (and (equal (linked-rts-addr s2) (rts-addr s))
       (equal (linked-a6 s2) (read-an 32 6 s))
       (equal* (read-rn 32 14 (mc-rfile s2)) (sub 32 4 (read-sp s)))
       (equal* (read-rn 32 15 (mc-rfile s2)) (sub 32 36 (read-sp s)))
       (equal (movem-saved s2 4 20 5)
              (readm-rn 32 '(2 3 4 10 11) (mc-rfile s)))
       (equal (mc-status s2) 'running)
       (evenp (mc-pc s2))
       (evenp (read-an 32 2 s2))
       (rom-addrp (read-an 32 2 s2) (mc-mem s2) 138)
       (mcode-addrp (read-an 32 2 s2) (mc-mem s2) (qsort-code))
       (rom-addrp (sub 32 116 (mc-pc s2)) (mc-mem s2) 138)
       (mcode-addrp (sub 32 116 (mc-pc s2)) (mc-mem s2) (qsort-code))
       (ram-addrp (sub 32 16 (read-sp s2)) (mc-mem s2) 68)
       (ram-addrp a (mc-mem s2) (times 4 n))
       (mem-ilst 4 a (mc-mem s2) n lst)
       (disjoint a (times 4 n) (sub 32 16 (read-sp s2)) 68)
       (equal a (read-an 32 3 s2))
       (equal l (nat-to-int (read-rn 32 3 (mc-rfile s2)) 32))
       (equal r (nat-to-int (read-rn 32 4 (mc-rfile s2)) 32))
       (equal last (nat-to-int (read-rn 32 2 (mc-rfile s2)) 32))
       (numberp l)
       (numberp r)
       (numberp last)
       (lessp l r)
       (leq last r)
       (lessp r n)
       (int-rangep n 32)
       (uint-rangep (times 4 n) 32)))

; the conditions of the intermediate state s3.  s3 is the machine 
; state right after the execution of the second JSR instruction, but 
; before the execution of QSORT.
(defn qsort-s3p (s s3 a l r n lst last)
  (and (equal (linked-rts-addr s3) (rts-addr s))
       (equal (linked-a6 s3) (read-an 32 6 s))
       (equal* (read-rn 32 14 (mc-rfile s3)) (sub 32 4 (read-sp s)))
       (equal* (read-rn 32 15 (mc-rfile s3)) (sub 32 52 (read-sp s)))
       (equal (movem-saved s3 4 20 5)
              (readm-rn 32 '(2 3 4 10 11) (mc-rfile s)))
       (equal (mc-status s3) 'running)
       (equal (mc-pc s3) (read-an 32 2 s3))
       (evenp (read-an 32 2 s3))
       (evenp (rts-addr s3))
       (rom-addrp (read-an 32 2 s3) (mc-mem s3) 138)
       (mcode-addrp (read-an 32 2 s3) (mc-mem s3) (qsort-code))
       (rom-addrp (sub 32 128 (rts-addr s3)) (mc-mem s3) 138)
       (mcode-addrp (sub 32 128 (rts-addr s3)) (mc-mem s3) (qsort-code))
       (ram-addrp (read-sp s3) (mc-mem s3) 68)
       (ram-addrp a (mc-mem s3) (times 4 n))
       (mem-ilst 4 a (mc-mem s3) n lst)
       (disjoint a (times 4 n) (read-sp s3) 68)
       (equal a (read-an 32 3 s3))
       (equal l (nat-to-int (read-rn 32 3 (mc-rfile s3)) 32))
       (equal r (nat-to-int (read-rn 32 4 (mc-rfile s3)) 32))
       (equal last (nat-to-int (read-rn 32 2 (mc-rfile s3)) 32))
       (equal a (read-mem (add 32 (read-sp s3) 4) (mc-mem s3) 4))
       (equal (iread-mem (add 32 (read-sp s3) 8) (mc-mem s3) 4) (add1 last))
       (equal r (iread-mem (add 32 (read-sp s3) 12) (mc-mem s3) 4))
       (numberp l)
       (numberp r)
       (numberp last)
       (lessp l r)
       (leq last r)
       (lessp r n)
       (int-rangep n 32)
       (uint-rangep (times 4 n) 32)))

; the conditions of the intermediate state s4.  s4 is the machine
; state right after the second recursive call to QSORT.
(defn qsort-s4p (s s4 a l r n lst)
  (and (equal (linked-rts-addr s4) (rts-addr s))
       (equal (linked-a6 s4) (read-an 32 6 s))
       (equal* (read-rn 32 14 (mc-rfile s4)) (sub 32 4 (read-sp s)))
       (equal* (read-rn 32 15 (mc-rfile s4)) (sub 32 48 (read-sp s)))
       (equal (movem-saved s4 4 20 5)
              (readm-rn 32 '(2 3 4 10 11) (mc-rfile s)))
       (equal (mc-status s4) 'running)
       (evenp (mc-pc s4))
       (rom-addrp (sub 32 128 (mc-pc s4)) (mc-mem s4) 138)
       (mcode-addrp (sub 32 128 (mc-pc s4)) (mc-mem s4) (qsort-code))
       (ram-addrp (sub 32 48 (read-an 32 6 s4)) (mc-mem s4) 68)
       (ram-addrp a (mc-mem s4) (times 4 n))
       (mem-ilst 4 a (mc-mem s4) n lst)
       (disjoint a (times 4 n) (sub 32 48 (read-an 32 6 s4)) 68)))

; the conditions of the final state.  s5 is the machine state after
; the execution of this QSORT program.
(defn qsort-s5p (s s5 a l r n lst)
  (and (equal (mc-status s5) 'running)
       (equal (mc-pc s5) (rts-addr s))
       (equal (read-rn 32 14 (mc-rfile s5)) (read-rn 32 14 (mc-rfile s)))
       (equal (read-rn 32 15 (mc-rfile s5)) (add 32 (read-sp s) 4))
       (mem-ilst 4 a (mc-mem s5) n lst)
       (equal (read-dn 32 2 s5) (read-dn 32 2 s))
       (equal (read-dn 32 3 s5) (read-dn 32 3 s))
       (equal (read-dn 32 4 s5) (read-dn 32 4 s))
       (equal (read-an 32 2 s5) (read-an 32 2 s))
       (equal (read-an 32 3 s5) (read-an 32 3 s))))

(defn-sk qsort-sk (s s5 a l r n lst)
  (forall 
   (x k)
   (let ((sp (sub 32 (difference (qstack l r lst) 16) (read-sp s))))
     (implies 
      (and (disjoint sp (qstack l r lst) x k)
           (disjoint a (times 4 n) x k))
      (equal (read-mem x (mc-mem s5) k)
             (read-mem x (mc-mem s) k))))))

(disable qsort-sk)

(prove-lemma qsort-sk-1 (rewrite)
  (let ((sp (sub 32 (difference (qstack l r lst) 16) (read-sp s))))
    (implies (and (qsort-sk s s5 a l r n lst)
                  (disjoint sp (qstack l r lst) x k)
                  (disjoint a (times 4 n) x k))
              (equal (read-mem x (mc-mem s5) k)
                     (read-mem x (mc-mem s) k))))
  ((use (qsort-sk))))

(prove-lemma qsort-sk-2 (rewrite)
  (let ((sp (sub 32 (difference (qstack l r lst) 16) (read-sp s))))
    (implies (and (qsort-sk s s5 a l r n lst)
                  (disjoint sp (qstack l r lst) x (times opsz k))
                  (disjoint a (times 4 n) x (times opsz k)))
             (equal (readm-mem opsz x (mc-mem s5) k)
                    (readm-mem opsz x (mc-mem s) k))))
  ((induct (readm-mem opsz x mem k))))

(disable qsort-sk-1)
(disable qsort-sk-2)

; base case: from the initial state to exit (s --> exit).
(prove-lemma qsort-base (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (not (lessp l r)))
              (qsort-s5p s (stepn s (qsort-10 a l r n lst)) a l r n lst)))

(prove-lemma qsort-base-rfile (rewrite)
     (implies 
      (and (qsort-sp s a l r n lst)
           (not (lessp l r))
           (d2-7a2-5p rn)
           (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s (qsort-10 a l r n lst))))
             (read-rn oplen rn (mc-rfile s)))))

(prove-lemma qsort-base-mem (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (not (lessp l r))
                   (disjoint (sub 32 24 (read-sp s)) 40 x k))
              (equal (read-mem x (mc-mem (stepn s 10)) k)
                     (read-mem x (mc-mem s) k))))

(prove-lemma qsort-base-mem-sk (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (not (lessp l r)))
              (qsort-sk s (stepn s (qsort-10 a l r n lst)) a l r n lst))
     ((use (qsort-sk (s5 (stepn s 10))))
      (disable qsort-sp)))

; induction case: s --> s0 --> s1 --> s2 --> s3 --> s4 --> exit.
; s --> s0:
(prove-lemma add1-int-rangep (rewrite)
             (implies (lessp x (nat-to-int y n))
                      (int-rangep (add1 x) n))
             ((enable int-rangep nat-to-int)))

(prove-lemma mean-bounds (rewrite)
     (implies (lessp i j)
              (and (lessp (quotient (plus i j) 2) j)
                   (not (lessp (quotient (plus i j) 2) i)))))

(prove-lemma int-rangep-plus-1 (rewrite)
     (implies (and (int-rangep (times 2 j) n)
                   (lessp i j))
              (int-rangep (plus i j) n)))

(prove-lemma qsort-s-s0 (rewrite)
     (let ((lst1 (swap l (quotient (plus l r) 2) lst)))
       (implies (and (qsort-sp s a l r n lst)
                     (lessp l r))
                (qsort-s0p s (stepn s 18) a l r n lst1 l (add1 l))))
     ((disable times quotient)))

(prove-lemma qsort-s-s0-rfile (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (lessp l r)
                   (d5-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 18)))
                     (read-rn oplen rn (mc-rfile s))))
     ((disable times quotient)))

(prove-lemma qsort-s-s0-mem (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (lessp l r)
                   (disjoint (sub 32 52 (read-sp s)) 68 x k)
                   (disjoint a (times 4 n) x k))
              (equal (read-mem x (mc-mem (stepn s 18)) k)
                     (read-mem x (mc-mem s) k)))
     ((disable times quotient)))

; s0 --> s1:
; base case (s0 --> s1):
(prove-lemma qsort-s0-s1 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (lessp r i)
                   (equal last1 (fix last)))
              (qsort-s1p s (stepn s0 11) a l r n (swap l last lst) last1))
     ((disable times lessp)))

(prove-lemma qsort-s0-s1-rfile (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (lessp r i)
                   (d5-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s0 11)))
                     (read-rn oplen rn (mc-rfile s0))))
     ((disable times lessp)))

(prove-lemma qsort-s0-s1-mem (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (lessp r i)
                   (disjoint (sub 32 52 (read-sp s)) 68 x k)
                   (disjoint a (times 4 n) x k))
              (equal (read-mem x (mc-mem (stepn s0 11)) k)
                     (read-mem x (mc-mem s0) k)))
     ((disable times lessp)))

; induction case (s0 --> s0):
(prove-lemma add1-int-rangepxx (rewrite)
             (implies (and (leq i r)
                           (lessp r n)
                           (int-rangep n 32))
                      (int-rangep (add1 i) 32))
             ((enable int-rangep nat-to-int)))

(prove-lemma qsort-s0-s0-1 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i))
                   (not (ilessp (get-nth i lst) (get-nth l lst))))
              (qsort-s0p s (stepn s0 6) a l r n lst last (add1 i)))
     ((disable times lessp)))     

(prove-lemma qsort-s0-s0-2 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i)) 
                   (ilessp (get-nth i lst) (get-nth l lst)))
              (qsort-s0p s (stepn s0 10) a l r n (swap (add1 last) i lst)
                         (add1 last) (add1 i)))
     ((disable times lessp)))

(prove-lemma qsort-s0-s0-rfile-1 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i)) 
                   (not (ilessp (get-nth i lst) (get-nth l lst)))
                   (d5-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s0 6)))
                     (read-rn oplen rn (mc-rfile s0))))
     ((disable times lessp)))

(prove-lemma qsort-s0-s0-rfile-2 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i)) 
                   (ilessp (get-nth i lst) (get-nth l lst))
                   (d5-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s0 10)))
                     (read-rn oplen rn (mc-rfile s0))))
     ((disable times lessp)))

(prove-lemma qsort-s0-s0-mem-1 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i)) 
                   (not (ilessp (get-nth i lst) (get-nth l lst))))
              (equal (read-mem x (mc-mem (stepn s0 6)) k)
                     (read-mem x (mc-mem s0) k)))
     ((disable times lessp)))

(prove-lemma qsort-s0-s0-mem-2 (rewrite)
     (implies (and (qsort-s0p s s0 a l r n lst last i)
                   (not (lessp r i)) 
                   (ilessp (get-nth i lst) (get-nth l lst))
                   (disjoint a (times 4 n) x k))
              (equal (read-mem x (mc-mem (stepn s0 10)) k)
                     (read-mem x (mc-mem s0) k)))
     ((disable times lessp)))

; induction hint for the partition.
(defn qpart-induct (s l r lst last i)
  (if (lessp r i)
      t
    (if (ilessp (get-nth i lst) (get-nth l lst))
        (qpart-induct (stepn s 10) l r (swap (add1 last) i lst) 
                      (add1 last) (add1 i))
      (qpart-induct (stepn s 6) l r lst last (add1 i))))
  ((lessp (difference (add1 r) i))))

(prove-lemma qpart-aux-ct (rewrite)
     (implies (qsort-s0p s s0 a l r n lst last i)
              (qsort-s1p s (stepn s0 (qpart-aux-t a l r n lst last i)) 
                         a l r n (qpart-aux l r lst last i) 
                         (qlast-aux l r lst last i)))
     ((induct (qpart-induct s0 l r lst last i))
      (disable qsort-s0p qsort-s1p swap)))

(prove-lemma qsort-s-s1 (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (lessp l r))
              (qsort-s1p s (stepn s (qpart-t a l r n lst)) a l r n
                         (qpart l r lst) (qlast l r lst)))
     ((enable qpart qlast)
      (disable swap qsort-sp qsort-s0p qsort-s1p)))      
              
(prove-lemma qpart-aux-rfile (rewrite)
     (let ((s1 (stepn s0 (qpart-aux-t a l r n lst last i))))
       (implies (and (qsort-s0p s s0 a l r n lst last i)
                     (d5-7a4-5p rn))
                (equal (read-rn oplen rn (mc-rfile s1))
                       (read-rn oplen rn (mc-rfile s0)))))
     ((induct (qpart-induct s0 l r lst last i))
      (disable swap qsort-s0p)))

(prove-lemma qsort-s-s1-rfile (rewrite)
     (implies 
      (and (qsort-sp s a l r n lst)
           (lessp l r)
           (d5-7a4-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (qpart-t a l r n lst))))
             (read-rn oplen rn (mc-rfile s))))
     ((use (qsort-s-s0))
      (disable qsort-sp qsort-s0p)))

(prove-lemma qpart-aux-mem (rewrite)
     (let ((s1 (stepn s0 (qpart-aux-t a l r n lst last i))))
       (implies (and (qsort-s0p s s0 a l r n lst last i)
                     (disjoint (sub 32 52 (read-sp s)) 68 x k)
                     (disjoint a (times 4 n) x k))
                (equal (read-mem x (mc-mem s1) k)
                       (read-mem x (mc-mem s0) k))))
     ((induct (qpart-induct s0 l r lst last i))
      (disable swap qsort-s0p)))

(prove-lemma qsort-sk-s-s1 (rewrite)
     (implies (and (qsort-sp s a l r n lst)
                   (lessp l r))
              (qsort-sk s (stepn s (qpart-t a l r n lst)) a l r n lst))
     ((use (qsort-sk (s5 (stepn s (qpart-t a l r n lst))))
           (qsort-s-s0))
      (disable swap qsort-sp qsort-s0p qsort-s-s0)))

(disable qpart-t)

; s2 --> s3:
(prove-lemma qsort-s2-s3 (rewrite)
     (let ((qlst (qpart l r lst))
           (last (qlast l r lst)))
       (implies (qsort-s2p s s2 a l r n (qsort l (sub1 last) qlst) last)
                (qsort-s3p s (stepn s2 (qsort-5 a l r n lst)) 
                           a l r n (qsort l (sub1 last) qlst) last))))

(prove-lemma qsort-s2-s3-rfile-la (rewrite)
     (implies (and (qsort-s2p s s2 a l r n lst1 last)
                   (d5-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s2 5)))
                     (read-rn oplen rn (mc-rfile s2)))))

(prove-lemma qsort-s2-s3-rfile (rewrite)
     (let ((qlst (qpart l r lst))
           (last (qlast l r lst))
           (s2 (stepn (stepn s k1) k2)))
       (implies (and (qsort-s2p s s2 a l r n (qsort l (sub1 last) qlst) last)
                     (d5-7a4-5p rn))
                (equal (read-rn oplen rn 
                                (mc-rfile (stepn s2 (qsort-5 a l r n lst))))
                       (read-rn oplen rn (mc-rfile s2)))))
     ((disable qsort-s2p stepn-rewriter)))

(prove-lemma qsort-s2-s3-mem (rewrite)
     (implies (and (qsort-s2p s s2 a l r n lst last)
                   (disjoint (sub 32 52 (read-sp s)) 68 x k))
              (equal (read-mem x (mc-mem (stepn s2 5)) k)
                     (read-mem x (mc-mem s2) k))))

(prove-lemma qsort-sk-s-s3 (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies (and (qsort-s2p s s2 a l r n (qsort l (sub1 last) lst1) last)
                     (qsort-sk s s2 a l r n lst))
                (qsort-sk s (stepn s2 (qsort-5 a l r n lst)) a l r n lst)))
     ((use (qsort-sk (s5 (stepn s2 5))))
      (enable qsort-sk-1) (disable qsort-s2p)))

; s4 --> exit:
(prove-lemma qsort-s4-s5 (rewrite)
     (let ((qlst (qpart l r lst))
           (last (qlast l r lst)))
       (implies (qsort-s4p s s4 a l r n 
                           (qsort (add1 last) r (qsort l (sub1 last) qlst)))
                (qsort-s5p s (stepn s4 (qsort-3 a l r n lst)) a l r n 
                           (qsort (add1 last) r (qsort l (sub1 last) qlst))))))

(prove-lemma qsort-s4-s5-rfile-la (rewrite)
     (implies (and (qsort-s4p s s4 a l r n (qsort l r lst))
                   (leq oplen 32)
                   (d2-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s4 3)))
                     (if (d5-7a4-5p rn)
                         (read-rn oplen rn (mc-rfile s4))
                       (read-rn oplen rn (mc-rfile s))))))

(prove-lemma qsort-s4-s5-rfile (rewrite)
     (let ((s4 (stepn (stepn (stepn (stepn s k1) k2) k3) k4)))
       (implies 
        (and (qsort-s4p s s4 a l r n (qsort l r lst))
             (leq oplen 32)
             (d2-7a2-5p rn))
        (equal (read-rn oplen rn (mc-rfile (stepn s4 (qsort-3 a l r n lst))))
               (if (d5-7a4-5p rn)
                 (read-rn oplen rn (mc-rfile s4))
               (read-rn oplen rn (mc-rfile s))))))
     ((disable qsort-s4p)))
       
(prove-lemma qsort-s4-s5-mem (rewrite)
     (implies (and (qsort-s4p s s4 a l r n lst)
                   (disjoint (sub 32 52 (read-sp s)) 68 x k))
              (equal (read-mem x (mc-mem (stepn s4 3)) k)
                     (read-mem x (mc-mem s4) k))))

(prove-lemma qsort-sk-s-s5 (rewrite)
     (implies (and (qsort-s4p s s4 a l r n (qsort l r lst))
                   (qsort-sk s s4 a l r n lst))
              (qsort-sk s (stepn s4 (qsort-3 a l r n lst)) a l r n lst))
     ((use (qsort-sk (s5 (stepn s4 3))))
      (enable qsort-sk-1) (disable qsort-s4p)))

; some auxiliary lemmas.
(prove-lemma qlast-aux-0 (rewrite)
     (implies (lessp r i)
              (equal (qlast-aux l r lst last i) (fix last))))

(prove-lemma qlast-0 (rewrite)
     (implies (leq r l)
              (equal (qlast l r lst) (fix l)))
     ((enable qlast)))

(prove-lemma qstack-la3 (rewrite)
     (implies (not (lessp l r))
              (equal (qstack l r lst) 68))
     ((enable qstack)))

(prove-lemma qstack-0 (rewrite)
     (and (equal (qstack l -1 lst) 68)
          (equal (qstack l 0 lst) 68)
          (equal (qstack l l lst) 68))
     ((enable qstack)))

(prove-lemma qstack-la4 (rewrite)
     (let ((last (qlast l r lst))
           (lst1 (qpart l r lst)))
       (not (lessp (qstack l r lst)
                   (qstack l (sub1 last) lst1))))
     ((expand (qstack l r lst))))

; s1 --> s2:  the first recursive call.
(prove-lemma qsort-s1-crock (rewrite)
     (implies (and (leq (plus q1 40) q)
                   (leq 68 q1)
                   (lessp q (exp 2 32)))
              (not (lessp q (plus q1 (add 32 4294967256 
                                          (add 32 
                                               (neg 32 (difference q1 16)) 
                                               (difference q 16)))))))
     ((enable neg nat-rangep add-nat-la sub-nat-la)
      (disable sub-neg)))

(prove-lemma qstack-la1~ (rewrite)
     (implies (and (equal last (qlast l r lst))
                   (equal lst1 (qpart l r lst))
                   (lessp l r))
              (not (lessp (qstack l r lst)
                          (plus 40 (qstack l (sub1 last) lst1))))))

(prove-lemma qsort-s1-s (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies (and (qsort-s1p s (stepn s k) a l r n lst1 last)
                     (qsort-statep s a l r n lst))
                (qsort-statep (stepn s k) a l (idifference last 1) n lst1)))
     ((disable add-commutativity1 qstack-la3)))

(prove-lemma qsort-s1-crock1 (rewrite)
   (implies (and (leq 68 q1)
                 (lessp (plus 40 q1) 4294967296)
                 (leq (plus x k) 4294967296)
                 (leq 4294967272 x))
            (disjoint
             (add 32 4294967256 (neg 32 (difference q1 16))) q1 x k))
   ((enable disjoint-leq disjoint-leq1)))

(prove-lemma qsort-s1-crock2-crock (rewrite)
     (implies (and (leq 68 q1)
                   (lessp q1 4294967256))
              (not (lessp (add 32 4294967256
                                     (neg 32 (difference q1 16)))
                          16)))
     ((enable neg nat-rangep add-nat-la sub-nat-la)
      (disable sub-neg)))

(prove-lemma qsort-s1-crock2 (rewrite)
   (implies (and (leq 68 q1)
                 (lessp (plus 40 q1) 4294967296)
                 (leq (plus x k) 16))
            (disjoint
             (add 32 4294967256 (neg 32 (difference q1 16))) q1 x k))
   ((enable disjoint-leq disjoint-leq1)))

(disable qsort-s1-crock2-crock)

(prove-lemma qsort-s1-s2 (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies
        (and (qsort-s1p s s1 a l r n lst1 last)
             (qsort-statep s a l r n lst)
             (qsort-s5p s1 (stepn s1 k) a l (idifference last 1) n
                        (qsort l (sub1 last) lst1))
             (qsort-sk s1 (stepn s1 k) a l (idifference last 1) n lst1))
        (qsort-s2p s (stepn s1 k) a l r n (qsort l (sub1 last) lst1) last)))
     ((enable qsort-sk-1 qsort-sk-2)
      (disable add-commutativity1)))

(disable qsort-s1-crock1)
(disable qsort-s1-crock2)

(prove-lemma qsort-s1-s2-mem (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies (and (qsort-s1p s s1 a l r n lst1 last)
                     (qsort-statep s a l r n lst)
                     (qsort-sk s s1 a l r n lst)
                     (qsort-sk s1 (stepn s1 k) a l (idifference last 1) n lst1)
                     (disjoint a (times 4 n) x k1)
                     (disjoint (sub 32 (difference (qstack l r lst) 16) 
                                    (read-sp s)) 
                               (qstack l r lst) x k1))
                (equal (read-mem x (mc-mem (stepn s1 k)) k1)
                       (read-mem x (mc-mem s) k1))))
     ((enable qsort-sk-1)
      (disable add-commutativity1 qstack-la3)))

(disable qstack-la1~)

(prove-lemma qsort-sk-s-s2 (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies 
        (and (qsort-s1p s s1 a l r n lst1 last)
             (qsort-statep s a l r n lst)
             (qsort-sk s s1 a l r n lst)
             (qsort-sk s1 (stepn s1 k) a l (idifference last 1) n lst1))
        (qsort-sk s (stepn s1 k) a l r n lst)))
     ((use (qsort-sk (s5 (stepn s1 k))))
      (disable qsort-s1p qsort-statep idifference)))

(disable qsort-s1-s2-mem)

; s3 --> s4:  the second recursive call.
(prove-lemma qsort-s3-crock (rewrite)
     (implies (and (leq (plus q1 52) q)
                   (leq 68 q1)
                   (lessp q (exp 2 32)))
              (not (lessp q (plus q1 (add 32 4294967244
                                          (add 32 
                                               (neg 32 (difference q1 16)) 
                                               (difference q 16)))))))
     ((enable neg nat-rangep add-nat-la sub-nat-la)
      (disable sub-neg)))

(prove-lemma qstack-la2~ (rewrite)
     (implies (and (equal last (qlast l r lst))
                   (equal lst1 (qpart l r lst))
                   (lessp l r))
              (not (lessp (qstack l r lst)
                          (plus 52 (qstack (add1 last) 
                                           r 
                                           (qsort l (sub1 last) lst1)))))))

(prove-lemma qsort-s3-s-la (rewrite)
     (let ((lst1 (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
           (last (qlast l r lst)))
       (implies (and (qsort-s3p s (stepn s k) a l r n lst1 last)
                     (qsort-statep s a l r n lst))
                (qsort-statep (stepn s k) a (add1 last) r n lst1)))
     ((disable add-commutativity1 qstack-la3)))

(prove-lemma qsort-s3-s (rewrite)
     (let ((lst1 (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
           (last (qlast l r lst)))
       (implies (and (qsort-s3p s (stepn (stepn (stepn s k1) k2) k3)
                                a l r n lst1 last)
                     (qsort-statep s a l r n lst))
                (qsort-statep (stepn (stepn (stepn s k1) k2) k3)
                              a (add1 last) r n lst1)))
     ((use (qsort-s3-s-la (k (splus k1 (splus k2 k3)))))
      (disable qsort-s3p qsort-statep)))

(prove-lemma qsort-s3-crock1 (rewrite)
   (implies (and (leq 68 q1)
                 (lessp (plus 52 q1) 4294967296)
                 (leq (plus x k) 4294967296)
                 (leq 4294967260 x))
            (disjoint
             (add 32 4294967244 (neg 32 (difference q1 16))) q1 x k))
   ((enable disjoint-leq disjoint-leq1)))

(prove-lemma qsort-s3-crock2-crock (rewrite)
     (implies (and (leq 68 q1)
                   (lessp q1 4294967244))
              (not (lessp (add 32 4294967244
                                     (neg 32 (difference q1 16)))
                          16)))
     ((enable neg nat-rangep add-nat-la sub-nat-la)
      (disable sub-neg)))

(prove-lemma qsort-s3-crock2 (rewrite)
   (implies (and (leq 68 q1)
                 (lessp (plus 52 q1) 4294967296)
                 (leq (plus x k) 16))
            (disjoint
             (add 32 4294967244 (neg 32 (difference q1 16))) q1 x k))
   ((enable disjoint-leq disjoint-leq1)))

(disable qsort-s3-crock2-crock)

(prove-lemma qsort-s3-s4 (rewrite)
    (let ((lst1 (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
          (last (qlast l r lst)))
      (implies (and (qsort-s3p s s3 a l r n lst1 last)
                    (qsort-statep s a l r n lst)
                    (qsort-s5p s3 (stepn s3 k) a (add1 last) r n 
                               (qsort (add1 last) r lst1))
                    (qsort-sk s3 (stepn s3 k) a (add1 last) r n lst1))
               (qsort-s4p s (stepn s3 k) a l r n (qsort (add1 last) r lst1))))
    ((enable qsort-sk-1 qsort-sk-2)
     (disable add-commutativity1)))

(disable qsort-s3-crock1)
(disable qsort-s3-crock2)

(prove-lemma qsort-s3-s4-mem (rewrite)
     (let ((lst1 (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
           (last (qlast l r lst)))
       (implies (and (qsort-s3p s s3 a l r n lst1 last)
                     (qsort-statep s a l r n lst)
                     (qsort-sk s s3 a l r n lst)
                     (qsort-sk s3 (stepn s3 k) a (add1 last) r n lst1)
                     (disjoint a (times 4 n) x k1)
                     (disjoint (sub 32 (difference (qstack l r lst) 16) 
                                    (read-sp s)) 
                               (qstack l r lst) x k1))
                (equal (read-mem x (mc-mem (stepn s3 k)) k1)
                       (read-mem x (mc-mem s) k1))))
     ((enable qsort-sk-1)
      (disable add-commutativity1 qstack-la3)))

(disable qstack-la2~)

(prove-lemma qsort-sk-s-s4 (rewrite)
     (let ((lst1 (qsort l (sub1 (qlast l r lst)) (qpart l r lst)))
           (last (qlast l r lst)))
       (implies (and (qsort-s3p s s3 a l r n lst1 last)
                     (qsort-statep s a l r n lst)
                     (qsort-sk s s3 a l r n lst)
                     (qsort-sk s3 (stepn s3 k) a (add1 last) r n lst1))
                (qsort-sk s (stepn s3 k) a l r n lst)))
     ((use (qsort-sk (s5 (stepn s3 k))))
      (disable qsort-s3p qsort-statep)))

(disable qsort-s3-s4-mem)

; the correctness of the QSORT program.
(prove-lemma qsort-t--1 (rewrite)
     (equal (qsort-t a l (idifference r 1) n lst) 
            (qsort-t a l (sub1 r) n lst))
     ((enable qsort-t)))

(prove-lemma qsort--1 (rewrite)
     (equal (qsort l (idifference r 1) lst) 
            (qsort l (sub1 r) lst))
     ((enable qsort)))

(disable qsort-10)
(disable qsort-5)
(disable qsort-3)

(prove-lemma qsort-correctness-la (rewrite)
     (implies
      (and (qsort-statep s a l r n lst)
           (leq oplen 32)
           (d2-7a2-5p rn))
      (and (qsort-s5p s (stepn s (qsort-t a l r n lst)) a l r n
                      (qsort l r lst))
           (qsort-sk s (stepn s (qsort-t a l r n lst)) a l r n lst)
           (equal (read-rn oplen rn (mc-rfile (stepn s (qsort-t a l r n lst))))
                  (read-rn oplen rn (mc-rfile s)))))
     ((induct (qsort-induct s a l r n lst))
      (disable qsort-statep qsort-sp qsort-s0p qsort-s1p qsort-s2p
               qsort-s3p qsort-s4p qsort-s5p idifference qlast-0
               qlast-ub qlast-lb)))

(prove-lemma qsort-correctness (rewrite)
     (let ((sn (stepn s (qsort-t a l r n lst)))
           (sp (sub 32 (difference (qstack l r lst) 16) (read-sp s))))
       (implies (qsort-statep s a l r n lst)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (rts-addr s))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (read-rn 32 14 (mc-rfile s)))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-rn 32 15 (mc-rfile s)) 4))
                     (implies (and (leq oplen 32)
                                   (d2-7a2-5p rn))
                              (equal (read-rn oplen rn (mc-rfile sn))
                                     (read-rn oplen rn (mc-rfile s))))
                     (implies (and (disjoint sp (qstack l r lst) x k)
                                   (disjoint a (times 4 n) x k))
                              (equal (read-mem x (mc-mem sn) k)
                                     (read-mem x (mc-mem s) k)))
                     (mem-ilst 4 a (mc-mem sn) n (qsort l r lst)))))
    ((use (qsort-correctness-la (oplen 32) (rn 2)))
     (enable qsort-sk-1)
     (disable qsort-statep)))

; in the logic, qsort is correct:
;       1. if left <= i <= j <= right,  lst'[i] <= lst'[j].
;       2. for all x,  (count-lst x l r lst) = (count-lst x l r lst').
(prove-lemma put-commute (rewrite)
     (implies (not (equal (fix i) (fix j)))
              (equal (put-nth v1 i (put-nth v2 j lst))
                     (put-nth v2 j (put-nth v1 i lst))))
     ((enable put-nth)))

(prove-lemma swap-put-commute (rewrite)
     (implies (and (lessp i l)
                   (lessp i r))
              (equal (swap l r (put-nth v i lst))
                     (put-nth v i (swap l r lst)))))

(prove-lemma swap-commute (rewrite)
     (implies (and (lessp i l)
                   (lessp i r)
                   (lessp j l)
                   (lessp j r))
              (equal (swap l r (swap i j lst))
                     (swap i j (swap l r lst)))))

(defn sublst-ileq (x l r lst)
  (if (lessp r l)
      t
    (and (ileq x (get-nth l lst))
         (sublst-ileq x (add1 l) r lst)))
  ((lessp (difference (add1 r) l))))

(defn sublsts-ileq (l r lst l1 r1 lst1)
  (if (lessp r l)
      t
    (and (sublst-ileq (get-nth l lst) l1 r1 lst1)
         (sublsts-ileq (add1 l) r lst l1 r1 lst1)))
  ((lessp (difference (add1 r) l))))

(prove-lemma sublst-ileq-lemma (rewrite)
     (implies (and (sublst-ileq x l r lst)
                   (leq l j)
                   (leq j r))
              (not (ilessp (get-nth j lst) x)))
     ((enable get-nth-0)))

(prove-lemma sublsts-ileq-la1 (rewrite)
     (implies (and (sublsts-ileq l r lst l1 r1 lst1)
                   (leq l i)
                   (leq i r))
              (sublst-ileq (get-nth i lst) l1 r1 lst1))
     ((enable get-nth-0)))

(prove-lemma sublst-ileq-put (rewrite)
     (implies (and (ileq x y)
                   (ileq x (get-nth j lst)))
              (equal (sublst-ileq x l r (put-nth y j lst))
                     (sublst-ileq x l r lst)))
     ((enable get-nth-0)))

(prove-lemma sublsts-ileq-put (rewrite)
     (implies (and (sublst-ileq y l1 r1 lst1)
                   (sublst-ileq (get-nth j lst) l1 r1 lst1))
              (equal (sublsts-ileq l r (put-nth y j lst) l1 r1 lst1)
                     (sublsts-ileq l r lst l1 r1 lst1)))
     ((enable get-nth-0)))

(prove-lemma sublst-ileq-swap-la ()
     (implies (and (sublst-ileq x l r lst)
                   (leq l i)
                   (leq i r)
                   (leq l j)
                   (leq j r))
              (sublst-ileq x l r (swap i j lst))))

(prove-lemma sublsts-ileq-swap-la ()
     (implies (and (sublsts-ileq l r lst l1 r1 lst1)
                   (leq l i)
                   (leq i r)
                   (leq l j)
                   (leq j r))
              (sublsts-ileq l r (swap i j lst) l1 r1 lst1)))

(disable swap)

(prove-lemma sublst-ileq-swap-swap (rewrite)
     (equal (sublst-ileq x l r (swap i j (swap i j lst)))
            (sublst-ileq x l r lst))
     ((enable get-nth-0)))

(prove-lemma sublst-ileq-swap (rewrite)
     (implies (and (leq l i)
                   (leq i r)
                   (leq l j)
                   (leq j r))        
              (equal (sublst-ileq x l r (swap i j lst))
                     (sublst-ileq x l r lst)))
     ((use (sublst-ileq-swap-la (lst (swap i j lst)))
           (sublst-ileq-swap-la))))

(prove-lemma sublsts-ileq-swap-swap (rewrite)
     (equal (sublsts-ileq l r (swap i j (swap i j lst)) l1 r1 lst1)
            (sublsts-ileq l r lst l1 r1 lst1))
     ((enable get-nth-0)))

(prove-lemma sublsts-ileq-swap (rewrite)
     (implies (and (leq l i)
                   (leq i r)
                   (leq l j)
                   (leq j r))        
              (equal (sublsts-ileq l r (swap i j lst) l1 r1 lst1)
                     (sublsts-ileq l r lst l1 r1 lst1)))
     ((use (sublsts-ileq-swap-la (lst (swap i j lst)))
           (sublsts-ileq-swap-la))))

(prove-lemma sublst-ileq-qpart-aux (rewrite)
     (implies (and (leq l last)
                   (lessp last i)
                   (leq last r)
                   (leq l l1)
                   (leq l1 r)
                   (leq r1 r))
              (equal (sublst-ileq x l r (qpart-aux l1 r1 lst last i))
                     (sublst-ileq x l r lst)))
     ((induct (qpart-aux l1 r1 lst last i))))

(prove-lemma sublsts-ileq-qpart-aux (rewrite)
     (implies (and (leq l last)
                   (lessp last i)
                   (leq last r2)
                   (leq l l2)
                   (leq l2 r)
                   (leq r2 r))
              (equal (sublsts-ileq l r (qpart-aux l2 r2 lst last i) l1 r1 lst1)
                     (sublsts-ileq l r lst l1 r1 lst1)))
     ((induct (qpart-aux l2 r2 lst last i))))

(prove-lemma sublst-ileq-qsort (rewrite)
     (implies (and (leq l l1)
                   (leq r1 r))
              (equal (sublst-ileq x l r (qsort l1 r1 lst))
                     (sublst-ileq x l r lst)))
     ((enable qpart)
      (disable sublst-ileq)))

(prove-lemma sublsts-ileq-qsort1 (rewrite)
     (implies (and (leq l l2)
                   (leq r2 r))
              (equal (sublsts-ileq l r (qsort l2 r2 lst) l1 r1 lst1)
                     (sublsts-ileq l r lst l1 r1 lst1)))
     ((enable qpart)
      (disable sublsts-ileq)))

(prove-lemma sublsts-ileq-qsort2 (rewrite)
     (implies (and (leq l1 l2)
                   (leq r2 r1))
              (equal (sublsts-ileq l r lst l1 r1 (qsort l2 r2 lst1))
                     (sublsts-ileq l r lst l1 r1 lst1)))
     ((disable qsort)))

(defn qpartx (l r lst last i)
  (if (lessp r i)
      lst
    (if (ilessp (get-nth i lst) (get-nth l lst))
        (qpartx l r (swap (add1 last) i lst) (add1 last) (add1 i))
      (qpartx l r lst last (add1 i))))
  ((lessp (difference (add1 r) i))))

(prove-lemma qpart-aux-qpartx (rewrite)
     (equal (qpart-aux l r lst last i)
            (swap l (qlast-aux l r lst last i) (qpartx l r lst last i)))
     ((enable swap get-nth put-nth)))

(prove-lemma qpartx-get-1 (rewrite)
     (implies (and (lessp last i)
                   (lessp right j))
              (equal (get-nth j (qpartx left right lst last i))
                     (get-nth j lst)))
     ((induct (qpartx left right lst last i))))

(prove-lemma qpartx-get-2 (rewrite)
     (implies (and (lessp last i)
                   (leq j last))
              (equal (get-nth j (qpartx left right lst last i))
                     (get-nth j lst)))
     ((induct (qpartx left right lst last i))))

(prove-lemma qpartx-ilessp-1 (rewrite)
     (implies (and (leq l last)
                   (lessp last i)
                   (lessp last j)
                   (leq j (qlast-aux l r lst last i)))
              (ilessp (get-nth j (qpartx l r lst last i))
                      (get-nth l lst)))
     ((induct (qpartx l r lst last i))))

(defn open-sublst-ileq (x l r lst)
  (if (lessp (add1 l) r)
      (and (ileq x (get-nth (add1 l) lst))
           (open-sublst-ileq x (add1 l) r lst))
    t)
  ((lessp (difference r l))))

(prove-lemma open-sublst-ileq-la0 (rewrite)
     (implies (not (lessp (add1 l) r))
              (open-sublst-ileq x l r lst)))

(prove-lemma open-sublst-ileq-la1 (rewrite)
     (implies (and (open-sublst-ileq x last i lst)
                   (lessp last j)
                   (lessp j i))
              (not (ilessp (get-nth j lst) x))))

(prove-lemma open-sublst-ileq-la2 (rewrite)
     (equal (open-sublst-ileq x last (add1 i) lst)
            (if (ileq x (get-nth i lst))
                (open-sublst-ileq x last i lst)
              (not (lessp (add1 last) (add1 i))))))

(prove-lemma open-sublst-ileq-la3 (rewrite)
     (implies (leq j l)
              (equal (open-sublst-ileq x l r (put-nth v j lst))
                     (open-sublst-ileq x l r lst))))

(prove-lemma open-sublst-ileq-la4 (rewrite)
     (implies (leq r j)
              (equal (open-sublst-ileq x l r (put-nth v j lst))
                     (open-sublst-ileq x l r lst))))

(prove-lemma open-sublst-ileq-la5 (rewrite)
     (equal (open-sublst-ileq x (add1 last) (add1 i) (swap (add1 last) i lst))
            (open-sublst-ileq x last i lst))
     ((enable swap)))

(prove-lemma qpartx-ilessp-2 (rewrite)
     (implies (and (open-sublst-ileq (get-nth l lst) last i lst)
                   (leq l last)
                   (lessp last i)
                   (lessp (qlast-aux l r lst last i) j)
                   (leq j r))
              (not (ilessp (get-nth j (qpartx l r lst last i))
                           (get-nth l lst))))
     ((induct (qpartx l r lst last i))))

(prove-lemma open-sublst-ileq-la6 (rewrite)
     (open-sublst-ileq (get-nth l lst) l (add1 l) lst))

(prove-lemma qpart-ilessp-la1-la ()
     (implies (and (leq l j)
                   (lessp j (qlast-aux l r lst l (add1 l))))
              (not (ilessp (get-nth l lst)
                           (get-nth j (qpart-aux l r lst l (add1 l)))))))

(prove-lemma qpart-ilessp-la1 (rewrite)
     (implies (and (leq l j)
                   (leq j (sub1 (qlast-aux l r lst l (add1 l)))))
              (not (ilessp (get-nth l lst)
                           (get-nth j (qpart-aux l r lst l (add1 l))))))
     ((use (qpart-ilessp-la1-la))
      (enable get-nth-0)))     

(prove-lemma qpart-ilessp-la2 (rewrite)
     (implies (and (leq (qlast-aux l r lst l (add1 l)) j)
                   (leq j r))
              (not (ilessp (get-nth j (qpart-aux l r lst l (add1 l)))
                           (get-nth l lst))))
     ((use (qpartx-ilessp-2 (last l) (i (add1 l))))
      (enable get-nth-0)))

(prove-lemma qpart-equal (rewrite)
     (implies (and (leq l last)
                   (lessp last i))
              (equal (get-nth (qlast-aux l r lst last i)
                              (qpart-aux l r lst last i))
                     (get-nth l lst)))
     ((enable get-nth-0)))

(prove-lemma qsort-get-1 (rewrite)
     (implies (lessp j left) 
              (equal (get-nth j (qsort left right lst))
                     (get-nth j lst)))
     ((enable qpart qlast)))

(prove-lemma get-swap-1 (rewrite)
     (implies (and (lessp j i)
                   (lessp k i))
              (equal (get-nth i (swap j k lst))
                     (get-nth i lst))))
     
(prove-lemma qlast-aux-swap (rewrite)
     (implies (and (leq l last)
                   (lessp last i)
                   (lessp a l)
                   (lessp b l))
              (equal (qlast-aux l r (swap a b lst) last i)
                     (qlast-aux l r lst last i)))
     ((induct (qlast-aux l r lst last i))))

(prove-lemma qlast-swap (rewrite)
     (implies (and (lessp l r)
                   (lessp a l)
                   (lessp b l))
              (equal (qlast l r (swap a b lst))
                     (qlast l r lst)))
     ((enable qlast) (disable qlast-aux)))

(prove-lemma qpart-aux-swap (rewrite)
     (implies (and (leq l last)
                   (lessp last i)
                   (lessp a l)
                   (lessp b l))
              (equal (qpart-aux l r (swap a b lst) last i)
                     (swap a b (qpart-aux l r lst last i))))
     ((induct (qpart-aux l r lst last i))))

(prove-lemma qpart-swap (rewrite)
     (implies (and (lessp l r)
                   (lessp a l)
                   (lessp b l))
              (equal (qpart l r (swap a b lst))
                     (swap a b (qpart l r lst))))
     ((enable qpart) (disable qpart-aux)))

(prove-lemma qsort-swap (rewrite)
     (implies (and (lessp i l)
                   (lessp j l))
              (equal (qsort l r (swap i j lst))
                     (swap i j (qsort l r lst))))
     ((induct (qsort l r lst))))

(prove-lemma qsort-qpartx (rewrite)
     (implies (and (leq l r)
                   (leq l last)
                   (lessp last i)
                   (leq last r)
                   (lessp r l1))
              (equal (qsort l1 r1 (qpartx l r lst last i))
                     (qpartx l r (qsort l1 r1 lst) last i)))
     ((induct (qpartx l r lst last i))))

(prove-lemma qsort-get-2 (rewrite)
     (implies (lessp r l1)
              (equal (get-nth j (qsort l1 r1 (qsort l r lst)))
                     (if (lessp r j)
                         (get-nth j (qsort l1 r1 lst))
                       (get-nth j (qsort l r lst)))))
     ((enable qpart)
      (disable quotient plus qlast-aux qpart-aux qpartx)))

(disable qpart-aux-qpartx)

(prove-lemma ilessp-trans (rewrite)
     (implies (and (ilessp a b) (ileq b c))
              (ilessp a c))
     ((enable ilessp)))

(prove-lemma qpart-ilessp (rewrite)
     (implies (and (leq l i)
                   (leq i (qlast l r lst))
                   (leq (qlast l r lst) j)
                   (leq j r))
              (not (ilessp (get-nth j (qpart l r lst))
                           (get-nth i (qpart l r lst)))))
     ((use (qpart-ilessp-la1 (j i) (lst (swap l (quotient (plus l r) 2) lst)))
           (qpart-ilessp-la2 (lst (swap l (quotient (plus l r) 2) lst))))
      (enable qpart qlast) (disable quotient plus qlast-aux qpart-aux)))

(prove-lemma qsort-get3 (rewrite)
     (equal (get-nth j (qsort (add1 last) r (qsort l (sub1 last) lst)))
            (if (leq j (sub1 last))
                (get-nth j (qsort l (sub1 last) lst))
              (get-nth j (qsort (add1 last) r lst)))))

(prove-lemma sublsts-ileq-la2 (rewrite)
     (implies (and (sublsts-ileq l r lst l1 r1 lst1)
                   (leq l i)
                   (leq i r)
                   (leq l1 j)
                   (leq j r1))
              (not (ilessp (get-nth j lst1) (get-nth i lst))))
     ((expand (sublsts-ileq i r lst l1 r1 lst1)
              (sublsts-ileq 0 r lst l1 r1 lst1))
      (enable get-nth-0)))

(prove-lemma qpart-ilessp-closed-1 (rewrite)
     (implies (leq (qlast l r lst) last)
              (sublst-ileq (get-nth (qlast l r lst) (qpart l r lst))
                           last r (qpart l r lst)))
     ((induct (sublst-ileq x last r lst1))))
             
(prove-lemma qsort-ilessp-1 (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies (and (leq last j)
                     (leq j r))
                (not (ilessp (get-nth j (qsort (add1 last) r lst1))
                             (get-nth last lst1)))))
     ((use (sublst-ileq-lemma (x (get-nth (qlast l r lst) (qpart l r lst)))
                              (l (qlast l r lst))
                              (lst (qsort (add1 (qlast l r lst))
                                          r
                                          (qpart l r lst)))))))     

(prove-lemma qpart-ilessp-closed-2 (rewrite)
     (let ((lst1 (qpart l r lst)))
       (implies (and (leq (qlast l r lst) last)
                     (leq l j)
                     (leq j (sub1 (qlast l r lst))))
                (sublst-ileq (get-nth j lst1) last r lst1)))
     ((induct (sublst-ileq x last r lst1))))

(prove-lemma qpart-ilessp-closed-3 (rewrite)
     (let ((last (qlast l r lst))
           (lst1 (qpart l r lst)))
       (implies (leq l l1)
                (sublsts-ileq l1 (sub1 last) lst1 last r lst1))))

(prove-lemma qsort-ilessp-2 (rewrite)
     (let ((lst1 (qpart l r lst))
           (last (qlast l r lst)))
       (implies (and (leq l i)
                     (leq i (sub1 last))
                     (leq last j)
                     (leq j r))
                (not (ilessp (get-nth j (qsort (add1 last) r lst1))
                             (get-nth i (qsort l (sub1 last) lst1))))))
     ((use (sublsts-ileq-la2 (r (sub1 (qlast l r lst)))
                             (lst (qsort l 
                                         (sub1 (qlast l r lst))
                                         (qpart l r lst)))
                             (l1 (qlast l r lst))
                             (r1 r)
                             (lst1 (qsort (add1 (qlast l r lst))
                                          r 
                                          (qpart l r lst))))
           (qpart-ilessp-closed-3 (l1 l)))))

(prove-lemma qsort-ordered (rewrite)
     (implies (and (leq left i)
                   (leq i j)
                   (leq j right))
              (not (ilessp (get-nth j (qsort left right lst))
                           (get-nth i (qsort left right lst)))))
     ((expand (qsort 0 right lst) 
              (qsort left right lst))
      (enable get-nth-0)))

(defn orderedp1 (l r lst)
  (if (leq r l)
      t
    (and (ileq (get-nth l lst) (get-nth (add1 l) lst))
         (orderedp1 (add1 l) r lst)))
  ((lessp (difference r l))))

(prove-lemma qsort-orderedp1-la (rewrite)
     (implies (leq left left1)
              (orderedp1 left1 right (qsort left right lst))))

(prove-lemma qsort-orderedp1 (rewrite)
     (orderedp1 left right (qsort left right lst)))

(defn transwap (i lst)
  (swap i (add1 i) lst))

(defn lst-eq (l r lst lst1)
  (if (lessp r l)
      t
    (and (equal (get-nth l lst) (get-nth l lst1))
         (lst-eq (add1 l) r lst lst1)))
  ((lessp (difference (add1 r) l))))

(defn count-lst (x l r lst)
  (if (lessp r l)
      0
    (if (equal x (get-nth l lst))
        (add1 (count-lst x (add1 l) r lst))
      (count-lst x (add1 l) r lst)))
  ((lessp (difference (add1 r) l))))

(prove-lemma count-lst-0 (rewrite)
     (implies (not (numberp l))
              (equal (count-lst x l r lst)
                     (count-lst x 0 r lst)))
     ((expand (count-lst x l r lst))
      (enable get-nth-0)))

(prove-lemma count-swapii (rewrite)
     (equal (count-lst x l r (swap i i lst))
            (count-lst x l r lst))
     ((enable get-nth-0)))

(prove-lemma count-lst-put-1 (rewrite)
     (implies (lessp i l)
              (equal (count-lst x l r (put-nth v i lst))
                     (count-lst x l r lst))))

(prove-lemma count-lst-swap-1 (rewrite)
     (implies (and (lessp i l)
                   (lessp j l))
              (equal (count-lst x l r (swap i j lst))
                     (count-lst x l r lst)))
     ((enable swap)))

(prove-lemma count-transwap-0 (rewrite)
    (implies (lessp l r)
             (equal (count-lst x l r (swap l (add1 l) lst))
                    (count-lst x l r lst)))
     ((expand (count-lst x l r (swap l (add1 l) lst))
              (count-lst x (add1 l) r (swap l (add1 l) lst))
              (count-lst x l r lst)
              (count-lst x (add1 l) r lst))))

(prove-lemma swap-0 (rewrite)
     (implies (not (numberp i))
              (and (equal (swap i j lst) (swap 0 j lst))
                   (equal (swap j i lst) (swap j 0 lst))))
     ((enable swap put-nth get-nth)))

(prove-lemma count-transwap (rewrite)
     (implies (and (leq l i)
                   (lessp i r))
              (equal (count-lst x l r (transwap i lst))
                     (count-lst x l r lst)))
     ((enable get-nth-0)))

(prove-lemma swap-rec-la (rewrite)
     (implies (leq i j)
              (lst-eq l
                      r 
                      (swap i (add1 j) lst) 
                      (swap i j (swap j (add1 j) (swap i j lst)))))
     ((enable get-nth-0)))

(prove-lemma count-lst-eq ()
     (implies (lst-eq l r lst lst1)
              (equal (count-lst x l r lst)
                     (count-lst x l r lst1))))

(prove-lemma count-lst-swap-rec (rewrite)
     (implies (leq i j)
              (equal (count-lst x l r (swap i (add1 j) lst))
                     (count-lst x l r (swap i j (transwap j (swap i j lst))))))
     ((use (count-lst-eq (lst (swap i (add1 j) lst))
                         (lst1 (swap i j (transwap j (swap i j lst))))))))

(defn swap-induct (i j lst)
  (if (leq j i)
      t
    (and (swap-induct i (sub1 j) (transwap (sub1 j) (swap i (sub1 j) lst)))
         (swap-induct i (sub1 j) lst)))
  ((lessp (difference j i))))

(prove-lemma count-lst-swap (rewrite)
     (implies (and (leq l i)
                   (leq i j)
                   (leq j r))
              (equal (count-lst x l r (swap i j lst))
                     (count-lst x l r lst)))
     ((induct (swap-induct i j lst))
      (disable transwap)))

(prove-lemma count-lst-qpart-aux (rewrite)
     (implies (and (leq l1 last)
                   (lessp last i)
                   (leq last r1)
                   (leq l l1)
                   (leq l1 r)
                   (leq r1 r))
              (equal (count-lst x l r (qpart-aux l1 r1 lst last i))
                     (count-lst x l r lst)))
     ((induct (qpart-aux l1 r1 lst last i))))

(prove-lemma count-lst-qsort-la (rewrite)
     (implies (and (leq l l1)
                   (leq r1 r))
              (equal (count-lst x l r (qsort l1 r1 lst))
                     (count-lst x l r lst)))
     ((enable qpart)
      (disable count-lst quotient plus)))

(prove-lemma count-lst-qsort (rewrite)
     (equal (count-lst x l r (qsort l r lst))
            (count-lst x l r lst)))
