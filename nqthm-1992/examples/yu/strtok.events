#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

;          Proof of the Correctness of the STRTOK Function
(note-lib "mc20-2" t)
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strtok function in the Berkeley string library.

char *
strtok(s, delim)
        register char *s;
        register const char *delim;
{
        register const char *spanp;
        register int c, sc;
        char *tok;
        static char *last;


        if (s == NULL && (s = last) == NULL)
                return (NULL);

        /*
         * Skip (span) leading delimiters (s += strspn(s, delim), sort of).
         */
cont:
        c = *s++;
        for (spanp = delim; (sc = *spanp++) != 0;) {
                if (c == sc)
                        goto cont;
        }

        if (c == 0) {           /* no non-delimiter characters */
                last = NULL;
                return (NULL);
        }
        tok = s - 1;

        /*
         * Scan token (scan for delimiters: s += strcspn(s, delim), sort of).
         * Note that delim must have one NUL; we stop if we see that, too.
         */
        for (;;) {
                c = *s++;
                spanp = delim;
                do {
                        if ((sc = *spanp++) == c) {
                                if (c == 0)
                                        s = NULL;
                                else
                                        s[-1] = 0;
                                last = s;
                                return (tok);
                        }
                } while (sc != 0);
        }
        /* NOTREACHED */
}

The MC68020 assembly code of the C function strtok on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2768 <strtok>:        linkw fp,#0
0x276c <strtok+4>:      moveml d2-d3,sp@-
0x2770 <strtok+8>:      moveal fp@(8),a1
0x2774 <strtok+12>:     movel fp@(12),d3
0x2778 <strtok+16>:     tstl a1
0x277a <strtok+18>:     bne 0x278a <strtok+34>
0x277c <strtok+20>:     moveal @#0x20098 <edata>,a1
0x2782 <strtok+26>:     tstl a1
0x2784 <strtok+28>:     bne 0x278a <strtok+34>
0x2786 <strtok+30>:     clrl d0
0x2788 <strtok+32>:     bra 0x27d8 <strtok+112>
0x278a <strtok+34>:     moveb a1@+,d1
0x278c <strtok+36>:     extbl d1
0x278e <strtok+38>:     moveal d3,a0
0x2790 <strtok+40>:     bra 0x2796 <strtok+46>
0x2792 <strtok+42>:     cmpl d1,d0
0x2794 <strtok+44>:     beq 0x278a <strtok+34>
0x2796 <strtok+46>:     moveb a0@+,d0
0x2798 <strtok+48>:     extbl d0
0x279a <strtok+50>:     bne 0x2792 <strtok+42>
0x279c <strtok+52>:     tstl d1
0x279e <strtok+54>:     bne 0x27aa <strtok+66>
0x27a0 <strtok+56>:     clrl @#0x20098 <edata>
0x27a6 <strtok+62>:     clrl d0
0x27a8 <strtok+64>:     bra 0x27d8 <strtok+112>
0x27aa <strtok+66>:     movel a1,d2
0x27ac <strtok+68>:     subl #1,d2
0x27ae <strtok+70>:     moveb a1@+,d1
0x27b0 <strtok+72>:     extbl d1
0x27b2 <strtok+74>:     moveal d3,a0
0x27b4 <strtok+76>:     moveb a0@+,d0
0x27b6 <strtok+78>:     extbl d0
0x27b8 <strtok+80>:     cmpl d0,d1
0x27ba <strtok+82>:     bne 0x27d2 <strtok+106>
0x27bc <strtok+84>:     tstl d1
0x27be <strtok+86>:     bne 0x27c4 <strtok+92>
0x27c0 <strtok+88>:     subal a1,a1
0x27c2 <strtok+90>:     bra 0x27c8 <strtok+96>
0x27c4 <strtok+92>:     clrb a1@(-1)
0x27c8 <strtok+96>:     movel a1,@#0x20098 <edata>
0x27ce <strtok+102>:    movel d2,d0
0x27d0 <strtok+104>:    bra 0x27d8 <strtok+112>
0x27d2 <strtok+106>:    tstl d0
0x27d4 <strtok+108>:    bne 0x27b4 <strtok+76>
0x27d6 <strtok+110>:    bra 0x27ae <strtok+70>
0x27d8 <strtok+112>:    moveml fp@(-8),d2-d3
0x27de <strtok+118>:    unlk fp
0x27e0 <strtok+120>:    rts

The machine code of the above program is:

<strtok>:      0x4e56  0x0000  0x48e7  0x3000  0x226e  0x0008  0x262e  0x000c
<strtok+16>:   0x4a89  0x660e  0x2279  0x0002  0x0098  0x4a89  0x6604  0x4280
<strtok+32>:   0x604e  0x1219  0x49c1  0x2043  0x6004  0xb081  0x67f4  0x1018
<strtok+48>:   0x49c0  0x66f6  0x4a81  0x660a  0x42b9  0x0002  0x0098  0x4280
<strtok+64>:   0x602e  0x2409  0x5382  0x1219  0x49c1  0x2043  0x1018  0x49c0
<strtok+80>:   0xb280  0x6616  0x4a81  0x6604  0x93c9  0x6004  0x4229  0xffff
<strtok+96>:   0x23c9  0x0002  0x0098  0x2002  0x6006  0x4a80  0x66de  0x60d6
<strtok+112>:  0x4cee  0x000c  0xfff8  0x4e5e  0x4e75

'(78      86      0       0       72      231     48      0
  34      110     0       8       38      46      0       12
  74      137     102     14      34      121     0       2
  0       152     74      137     102     4       66      128
  96      78      18      25      73      193     32      67
  96      4       176     129     103     244     16      24
  73      192     102     246     74      129     102     10
  66      185     0       2       0       152     66      128
  96      46      36      9       83      130     18      25
  73      193     32      67      16      24      73      192
  178     128     102     22      74      129     102     4
  147     201     96      4       66      41      255     255
  35      201     0       2       0       152     32      2
  96      6       74      128     102     222     96      214
  76      238     0       12      255     248     78      94
  78      117)
|#

;  in the logic, the above program is defined by (strtok-code).
(defn strtok-code ()
  '(78      86      0       0       72      231     48      0
    34      110     0       8       38      46      0       12
    74      137     102     14      34      121     -1      -1
    -1      -1      74      137     102     4       66      128
    96      78      18      25      73      193     32      67
    96      4       176     129     103     244     16      24
    73      192     102     246     74      129     102     10
    66      185     -1      -1      -1      -1      66      128
    96      46      36      9       83      130     18      25
    73      193     32      67      16      24      73      192
    178     128     102     22      74      129     102     4
    147     201     96      4       66      41      255     255
    35      201     -1      -1      -1      -1      32      2
    96      6       74      128     102     222     96      214
    76      238     0       12      255     248     78      94
    78      117))

(constrain strtok-load (rewrite)
   (equal (strtok-loadp s)
          (and (evenp (strtok-addr))
               (numberp (strtok-addr))
               (nat-rangep (strtok-addr) 32)
               (numberp (strtok-last-addr))
               (nat-rangep (strtok-last-addr) 32)
               (ram-addrp (strtok-last-addr) (mc-mem s) 4)
               (rom-addrp (strtok-addr) (mc-mem s) 122)
               (mcode-addrp (strtok-addr) (mc-mem s) (strtok-code))
               (equal (pc-read-mem (add 32 (strtok-addr) 22) (mc-mem s) 4)
                      (strtok-last-addr))
               (equal (pc-read-mem (add 32 (strtok-addr) 58) (mc-mem s) 4)
                      (strtok-last-addr))
               (equal (pc-read-mem (add 32 (strtok-addr) 98) (mc-mem s) 4)
                      (strtok-last-addr))))
   ((strtok-loadp (lambda (s) f))
    (strtok-addr (lambda () 1))
    (strtok-last-addr (lambda () 10))))

(prove-lemma stepn-strtok-loadp (rewrite)
     (equal (strtok-loadp (stepn s n))
            (strtok-loadp s)))

; the computation time of the program.
(defn strtok-t0 (i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal (get-nth i2 lst2) 0)
          3
        (if (equal (get-nth i2 lst2) ch)
            5
          (splus 5 (strtok-t0 (add1 i2) n2 lst2 ch))))
    0)
  ((lessp (difference n2 i2))))

(defn strtok-t1 (n2 lst2 ch)
  (splus 4 (strtok-t0 0 n2 lst2 ch)))

(defn strtok-t2 (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
          (splus (strtok-t1 n2 lst2 (get-nth i1 lst1))
                 (strtok-t2 (add1 i1) n1 lst1 n2 lst2))
        (strtok-t1 n2 lst2 (get-nth i1 lst1)))
    0)
  ((lessp (difference n1 i1))))

(defn strtok-t3 (i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal ch (get-nth i2 lst2))
          (if (equal ch 0) 14 13)
        (if (equal (get-nth i2 lst2) 0)
            7
          (splus 6 (strtok-t3 (add1 i2) n2 lst2 ch))))
    0)
  ((lessp (difference n2 i2))))

(defn strtok-t4 (n2 lst2 ch)
  (splus 3 (strtok-t3 0 n2 lst2 ch)))

(defn strtok-t5 (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
          (strtok-t4 n2 lst2 (get-nth i1 lst1))
        (splus (strtok-t4 n2 lst2 (get-nth i1 lst1))
               (strtok-t5 (add1 i1) n1 lst1 n2 lst2)))
    0)
  ((lessp (difference n1 i1))))

(defn strtok-t6 (i1 n1 lst1 n2 lst2)
  (if (equal (get-nth i1 lst1) 0)
      8
    (splus 4 (strtok-t5 (add1 i1) n1 lst1 n2 lst2))))

(defn strtok-t (str1 last n1 lst1 n2 lst2)
  (if (equal (nat-to-uint str1) 0)
      (if (equal (nat-to-uint last) 0)
          14
        (splus 9 
               (splus (strtok-t2 0 n1 lst1 n2 lst2)
                      (strtok-t6 (strspn 0 n1 lst1 n2 lst2) n1 lst1 n2 lst2))))
    (splus 6 
           (splus (strtok-t2 0 n1 lst1 n2 lst2)
                  (strtok-t6 (strspn 0 n1 lst1 n2 lst2) n1 lst1 n2 lst2)))))
    
; two induction hints.
(defn strtok-induct0 (s i2* i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal (get-nth i2 lst2) 0)
          t
        (if (equal (get-nth i2 lst2) ch)
            t
          (strtok-induct0 (stepn s 5) (add 32 i2* 1) (add1 i2) n2 lst2 ch)))
    t)
  ((lessp (difference n2 i2))))

(defn strtok-induct1 (s i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr1 0 n2 lst2 (get-nth i1 lst1))
          (strtok-induct1 (stepn s (strtok-t1 n2 lst2 (get-nth i1 lst1)))
                          (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2)
        t)
    t)
  ((lessp (difference n1 i1))))

(defn strtok-induct2 (s i2* i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal ch (get-nth i2 lst2))
          t
        (if (equal (get-nth i2 lst2) 0)
            t
          (strtok-induct2 (stepn s 6) (add 32 i2* 1) (add1 i2) n2 lst2 ch)))
    t)
  ((lessp (difference n2 i2))))

(defn strtok-induct3 (s i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
          t
        (strtok-induct3 (stepn s (strtok-t4 n2 lst2 (get-nth i1 lst1)))
                        (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2))
    t)
  ((lessp (difference n1 i1))))

; the preconditions of the initial state.
(defn strtok-statep (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (strtok-addr))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 24)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str2 n2 (sub 32 12 (read-sp s)) 24)
       (disjoint (strtok-last-addr) 4 (sub 32 12 (read-sp s)) 24)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (if (equal (nat-to-uint str1) 0)
           (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
             (if (equal (nat-to-uint last) 0)
                 t
               (and (ram-addrp last (mc-mem s) n1)
                    (mem-lst 1 last (mc-mem s) n1 lst1)
                    (disjoint last n1 (sub 32 12 (read-sp s)) 24)
                    (disjoint last n1 (strtok-last-addr) 4))))
         (and (ram-addrp str1 (mc-mem s) n1)
              (mem-lst 1 str1 (mc-mem s) n1 lst1)
              (disjoint str1 n1 (sub 32 12 (read-sp s)) 24)
              (disjoint str1 n1 (strtok-last-addr) 4)))
       (lessp (slen 0 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))  

; intermediate states.
(defn strtok-s0p (s i1* i1 str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (add 32 (strtok-addr) 34))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (strtok-last-addr) 4 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str1 n1 (strtok-last-addr) 4)
       (disjoint str1 n1 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str2 n2 (sub 32 8 (read-an 32 6 s)) 24)
       (equal* (read-an 32 1 s) (add 32 str1 i1*))
       (equal str2 (read-dn 32 3 s))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))

(defn strtok-s1p (s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (add 32 (strtok-addr) 46))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (strtok-last-addr) 4 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str1 n1 (strtok-last-addr) 4)
       (disjoint str1 n1 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str2 n2 (sub 32 8 (read-an 32 6 s)) 24)
       (equal str2 (read-dn 32 3 s))
       (equal ch (uread-dn 8 1 s))
       (equal* (read-dn 32 1 s) (ext 8 (read-dn 8 1 s) 32))
       (equal* (read-an 32 1 s) (add 32 str1 (add 32 i1* 1)))
       (equal* (read-an 32 0 s) (add 32 str2 i2*))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (numberp i2*)
       (nat-rangep i2* 32)
       (equal i2 (nat-to-uint i2*))
       (lessp (slen 0 n2 lst2) n2)
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen i2 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))

(defn strtok-s2p (s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (add 32 (strtok-addr) 52))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (strtok-last-addr) 4 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str1 n1 (strtok-last-addr) 4)
       (disjoint str1 n1 (sub 32 8 (read-an 32 6 s)) 24)
       (equal* (read-dn 32 1 s) (ext 8 (read-dn 8 1 s) 32))
       (equal* (read-an 32 1 s) (add 32 str1 (add 32 i1* 1)))
       (equal str2 (read-dn 32 3 s))
       (equal ch (uread-dn 8 1 s))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))

(defn strtok-s3p (s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (add 32 (strtok-addr) 70))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (strtok-last-addr) 4 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str1 n1 (strtok-last-addr) 4)
       (disjoint str1 n1 (sub 32 8 (read-an 32 6 s)) 24)
       (equal str2 (read-dn 32 3 s))
       (equal tok (read-dn 32 2 s))
       (equal* (read-an 32 1 s) (add 32 str1 i1*))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))

(defn strtok-s4p (s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
  (and (equal (mc-status s) 'running)
       (strtok-loadp s)
       (equal (mc-pc s) (add 32 (strtok-addr) 76))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (strtok-last-addr) 4 (sub 32 8 (read-an 32 6 s)) 24)
       (disjoint str1 n1 (strtok-last-addr) 4)
       (disjoint (sub 32 8 (read-an 32 6 s)) 24 str1 n1)
       (equal* (read-an 32 1 s) (add 32 str1 (add 32 i1* 1)))
       (equal* (read-an 32 0 s) (add 32 str2 i2*))
       (equal str2 (read-dn 32 3 s))
       (equal ch (uread-dn 8 1 s))
       (equal tok (read-dn 32 2 s))
       (equal* (read-dn 32 1 s) (ext 8 (read-dn 8 1 s) 32))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (numberp i2*)
       (nat-rangep i2* 32)
       (equal i2 (nat-to-uint i2*))
       (lessp (slen 0 n2 lst2) n2)
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen i2 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))          

; from the initial state to exit.  s --> sn, when str1 == NULL & last == NULL.
(prove-lemma strtok-s-sn (rewrite)
     (let ((sn (stepn s 14)))
       (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                     (equal (nat-to-uint str1) 0)
                     (equal (uread-mem (strtok-last-addr) (mc-mem s) 4) 0))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (rts-addr s))
                     (equal (read-dn 32 0 sn) 0)
                     (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                            (read-mem (strtok-last-addr) (mc-mem s) 4))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 7 s) 4))
                     (equal (read-rn 32 14 (mc-rfile sn)) 
                            (read-an 32 6 s))))))

(prove-lemma strtok-s-sn-rfile (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (equal (nat-to-uint str1) 0)
                   (equal (uread-mem (strtok-last-addr) (mc-mem s) 4) 0)
                   (leq oplen 32)
                   (d2-7a2-5p rn))                 
              (equal (read-rn oplen rn (mc-rfile (stepn s 14)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strtok-s-sn-mem (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (equal (nat-to-uint str1) 0)
                   (equal (uread-mem (strtok-last-addr) (mc-mem s) 4) 0)
                   (disjoint x k (sub 32 12 (read-sp s)) 24))
              (equal (read-mem x (mc-mem (stepn s 14)) k)
                     (read-mem x (mc-mem s) k))))

; from the initial state to s0.  s --> s0, when str1 =\= NULL.
(prove-lemma strtok-s-s0-1 ()
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (not (equal (nat-to-uint str1) 0)))
              (strtok-s0p (stepn s 6) 0 0 str1 n1 lst1 str2 n2 lst2)))

(prove-lemma strtok-s-s0-else-1 (rewrite)
     (let ((s0 (stepn s 6)))
       (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                     (not (equal (nat-to-uint str1) 0)))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 8 2)
                            (readm-rn 32 '(2 3) (mc-rfile s)))))))

(prove-lemma strtok-s-s0-rfile-1 (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (not (equal (nat-to-uint str1) 0))
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strtok-s-s0-mem-1 (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (not (equal (nat-to-uint str1) 0))
                   (disjoint x k (sub 32 12 (read-sp s)) 24))
              (equal (read-mem x (mc-mem (stepn s 6)) k)
                     (read-mem x (mc-mem s) k))))

; from s to s0.  s -> s0, when str1 == NULL and last =\= NULL.
(prove-lemma strtok-s-s0-2 ()
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                     (equal (nat-to-uint str1) 0)
                     (not (equal (nat-to-uint last) 0)))
                (strtok-s0p (stepn s 9) 0 0 last n1 lst1 str2 n2 lst2))))

(prove-lemma strtok-s-s0-else-2 (rewrite)
     (let ((s0 (stepn s 9))
           (last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                     (equal (nat-to-uint str1) 0)
                     (not (equal (nat-to-uint last) 0)))
                (and (equal (linked-rts-addr s0) (rts-addr s))
                     (equal (linked-a6 s0) (read-an 32 6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (sub 32 4 (read-sp s)))
                     (equal (movem-saved s0 4 8 2)
                            (readm-rn 32 '(2 3) (mc-rfile s)))))))

(prove-lemma strtok-s-s0-rfile-2 (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (equal (nat-to-uint str1) 0)
                   (not (equal (uread-mem (strtok-last-addr) (mc-mem s) 4) 0))
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
                     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strtok-s-s0-mem-2 (rewrite)
     (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                   (equal (nat-to-uint str1) 0)
                   (not (equal (uread-mem (strtok-last-addr) (mc-mem s) 4) 0))
                   (disjoint x k (sub 32 12 (read-sp s)) 24))
              (equal (read-mem x (mc-mem (stepn s 9)) k)
                     (read-mem x (mc-mem s) k))))

; from s0 to s1.  s0 --> s1.
; s0 --> s1.
(prove-lemma strtok-s0-s1 ()
     (implies (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
              (strtok-s1p (stepn s 4) i1* i1 str1 n1 lst1 
                          0 0 str2 n2 lst2 (get-nth i1 lst1))))

(prove-lemma strtok-s0-s1-else (rewrite)
     (let ((s1 (stepn s 4)))
       (implies (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                (and (equal (linked-rts-addr s1) (linked-rts-addr s))
                     (equal (linked-a6 s1) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s1))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s1 4 16 4)
                            (movem-saved s 4 16 4))
                     (equal (read-mem x (mc-mem s1) k)
                            (read-mem x (mc-mem s) k))))))

(prove-lemma strtok-s0-s1-rfile (rewrite)
     (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
                     (read-rn oplen rn (mc-rfile s)))))

; loop: s1 --> s1.
; base case: s1 --> s2, when lst2[i] == 0.
(prove-lemma strtok-s1-s2-base (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (equal (get-nth i2 lst2) 0))
              (and (strtok-s2p (stepn s 3) i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
                          (read-an 32 6 s))
                   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 3))
                          (linked-rts-addr s))
                   (equal (read-mem x (mc-mem (stepn s 3)) k)
                          (read-mem x (mc-mem s) k)))))

(prove-lemma strtok-s1-s2-rfile-base (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (equal (get-nth i2 lst2) 0)
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

; base case: s1 --> s0.
(prove-lemma strtok-s1-s0-base (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (equal ch (get-nth i1 lst1))
                   (not (equal (get-nth i2 lst2) 0))
                   (equal (get-nth i2 lst2) ch))
              (and (strtok-s0p (stepn s 5) (add 32 i1* 1) (add1 i1) str1 n1 
                               lst1 str2 n2 lst2)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 5)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 5)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 5)) 
                          (linked-rts-addr s))
                   (equal (read-mem x (mc-mem (stepn s 5)) k)
                          (read-mem x (mc-mem s) k)))))

(prove-lemma strtok-s1-s0-rfile-base (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (not (equal (get-nth i2 lst2) 0))
                   (equal (get-nth i2 lst2) ch)
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 5)))
                     (read-rn oplen rn (mc-rfile s)))))

; induction case: s1 --> s1.
(prove-lemma strtok-s1-s1 (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (not (equal (get-nth i2 lst2) 0))
                   (not (equal (get-nth i2 lst2) ch)))
              (and (strtok-s1p (stepn s 5) i1* i1 str1 n1 lst1 (add 32 i2* 1)
                               (add1 i2) str2 n2 lst2 ch)
                   (equal (read-rn 32 14 (mc-rfile (stepn s 5)))
                          (read-rn 32 14 (mc-rfile s)))
                   (equal (linked-a6 (stepn s 5)) (linked-a6 s))
                   (equal (linked-rts-addr (stepn s 5)) 
                          (linked-rts-addr s))
                   (equal (rn-saved (stepn s 5)) (rn-saved s))
                   (equal (read-mem x (mc-mem (stepn s 5)) k)
                          (read-mem x (mc-mem s) k)))))

(prove-lemma strtok-s1-s1-rfile (rewrite)
     (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (not (equal (get-nth i2 lst2) 0))
                   (not (equal (get-nth i2 lst2) ch))
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 5)))
                     (read-rn oplen rn (mc-rfile s)))))

; put together:  s1 --> s0, when (strchr1 i2 n2 lst2 ch).
(prove-lemma strtok-s1p-info (rewrite)
     (implies (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
              (equal (lessp i2 n2) t)))

(prove-lemma strtok-s1-s0 (rewrite)
     (let ((s0 (stepn s (strtok-t0 i2 n2 lst2 ch))))
       (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                     (equal ch (get-nth i1 lst1))
                     (strchr1 i2 n2 lst2 ch))
                (and (strtok-s0p s0 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                                 str2 n2 lst2)
                     (equal (read-rn 32 14 (mc-rfile s0)) (read-an 32 6 s))
                     (equal (linked-a6 s0) (linked-a6 s))
                     (equal (linked-rts-addr s0) (linked-rts-addr s))
                     (equal (movem-saved s0 4 8 2) (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s0) k)
                            (read-mem x (mc-mem s) k)))))
     ((induct (strtok-induct0 s i2* i2 n2 lst2 ch))
      (disable strtok-s0p strtok-s1p)))

(prove-lemma strtok-s1-s0-rfile (rewrite)
     (implies 
      (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
           (strchr1 i2 n2 lst2 ch)
           (d4-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strtok-t0 i2 n2 lst2 ch))))
             (read-rn oplen rn (mc-rfile s))))
     ((induct (strtok-induct0 s i2* i2 n2 lst2 ch))
      (disable strtok-s1p)))

; put together:  s1 --> s2, when (strchr1 i2 n2 lst2 ch).
(prove-lemma strtok-s1-s2 (rewrite)
     (let ((s2 (stepn s (strtok-t0 i2 n2 lst2 ch))))
       (implies (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                     (not (strchr1 i2 n2 lst2 ch)))
                (and (strtok-s2p s2 i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                     (equal (read-rn 32 14 (mc-rfile s2)) (read-an 32 6 s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (movem-saved s2 4 8 2) (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s2) k)
                            (read-mem x (mc-mem s) k)))))
     ((induct (strtok-induct0 s i2* i2 n2 lst2 ch))
      (disable strtok-s2p strtok-s1p)))

(prove-lemma strtok-s1-s2-rfile (rewrite)
     (implies 
      (and (strtok-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
           (not (strchr1 i2 n2 lst2 ch))
           (d4-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strtok-t0 i2 n2 lst2 ch))))
             (read-rn oplen rn (mc-rfile s))))
     ((induct (strtok-induct0 s i2* i2 n2 lst2 ch))
      (disable strtok-s1p)))

(disable strtok-s1p-info)

; from s0 to s2:  s0 --> s2.
; base case: s0 --> s2.
(prove-lemma strtok-s0-s2-base (rewrite)
     (let ((s2 (stepn s (strtok-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                     (not (strchr1 0 n2 lst2 (get-nth i1 lst1))))
                (and (strtok-s2p s2 i1* i1 str1 n1 lst1 str2 n2 lst2
                                 (get-nth i1 lst1))
                     (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (read-rn 32 14 (mc-rfile s2))
                            (read-rn 32 14 (mc-rfile s)))
                     (equal (movem-saved s2 4 8 2) (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s2) k)
                            (read-mem x (mc-mem s) k)))))
     ((use (strtok-s0-s1))
      (disable strtok-s0p strtok-s1p strtok-s2p)))

(prove-lemma strtok-s0-s2-rfile-base (rewrite)
     (let ((s2 (stepn s (strtok-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                     (not (strchr1 0 n2 lst2 (get-nth i1 lst1)))
                     (d4-7a2-5p rn))
                (equal (read-rn oplen rn (mc-rfile s2))
                       (read-rn oplen rn (mc-rfile s)))))
     ((use (strtok-s0-s1))
      (disable strtok-s0p strtok-s1p strtok-s2p strtok-t0)))

; induction case: s0 --> s0.
(prove-lemma strtok-s0-s0 (rewrite)
     (let ((s0 (stepn s (strtok-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                     (strchr1 0 n2 lst2 (get-nth i1 lst1)))
                (and (strtok-s0p s0 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                                 str2 n2 lst2)
                     (equal (linked-rts-addr s0) (linked-rts-addr s))
                     (equal (linked-a6 s0) (linked-a6 s))
                     (equal (read-rn 32 14 (mc-rfile s0))
                            (read-rn 32 14 (mc-rfile s)))
                     (equal (movem-saved s0 4 8 2) (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s0) k)
                            (read-mem x (mc-mem s) k)))))
     ((use (strtok-s0-s1))
      (disable strtok-s0p strtok-s1p strtok-s2p strtok-t0 strchr1)))

(prove-lemma strtok-s0-s0-rfile (rewrite)
     (let ((s0 (stepn s (strtok-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                     (strchr1 0 n2 lst2 (get-nth i1 lst1))
                     (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile s0))
                     (read-rn oplen rn (mc-rfile s)))))
      ((use (strtok-s0-s1))
       (disable strtok-s0p strtok-s1p strtok-s2p strtok-t0 strchr1)))

; put together: s0 --> s2.
(prove-lemma strtok-s0p-info (rewrite)
     (implies (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
              (and (numberp i1)
                   (equal (lessp i1 n1) t))))
  
(prove-lemma strtok-s0-s2 ()
     (let ((s2 (stepn s (strtok-t2 i1 n1 lst1 n2 lst2))))
       (implies (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                (strtok-s2p s2 (strspn* i1* i1 n1 lst1 n2 lst2) 
                            (strspn i1 n1 lst1 n2 lst2) str1 n1 lst1 
                            str2 n2 lst2 
                            (get-nth (strspn i1 n1 lst1 n2 lst2) lst1))))
     ((induct (strtok-induct1 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s0p strtok-s2p strtok-t1 strchr1)))

(disable strtok-s0p-info)

(prove-lemma strtok-s0-s2-else (rewrite)
     (let ((s2 (stepn s (strtok-t2 i1 n1 lst1 n2 lst2))))
       (implies (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                (and (equal (linked-rts-addr s2) (linked-rts-addr s))
                     (equal (linked-a6 s2) (linked-a6 s))
                     (equal (read-rn 32 14 (mc-rfile s2))
                            (read-rn 32 14 (mc-rfile s)))
                     (equal (movem-saved s2 4 8 2) (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s2) k)
                            (read-mem x (mc-mem s) k)))))
     ((induct (strtok-induct1 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s0p strtok-s2p strtok-t1 strchr1)))

(prove-lemma strtok-s0-s2-rfile (rewrite)
     (let ((s2 (stepn s (strtok-t2 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
                     (d4-7a2-5p rn))
                (equal (read-rn oplen rn (mc-rfile s2))
                       (read-rn oplen rn (mc-rfile s)))))
     ((induct (strtok-induct1 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s0p strtok-s2p strtok-t1 strchr1)))       

; from s2 to exit:  s2 --> sn.
(prove-lemma strtok-s2-sn-1 (rewrite)
     (let ((sn (stepn s 8)))
       (implies (and (strtok-s2p s i* i str1 n1 lst1 str2 n2 lst2 ch)
                     (equal ch 0))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) 0)
                     (equal (read-mem (strtok-last-addr) (mc-mem sn) 4) 0)
                     (mem-lst 1 str1 (mc-mem sn) n1 lst1)
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8))))))

(prove-lemma strtok-s2-sn-rfile-1 (rewrite)
     (implies (and (strtok-s2p s i* i str1 n1 lst1 str2 n2 lst2 ch)
                   (equal ch 0)
                   (d2-7a2-5p rn)
                   (leq oplen 32))
              (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
                     (if (d4-7a2-5p rn)
                         (read-rn oplen rn (mc-rfile s))
                       (get-vlst oplen 0 rn '(2 3)
                                 (movem-saved s 4 8 2))))))

(prove-lemma strtok-s2-sn-mem-1 (rewrite)
     (implies (and (strtok-s2p s i* i str1 n1 lst1 str2 n2 lst2 ch)
                   (equal ch 0)
                   (disjoint x k (strtok-last-addr) 4))
              (equal (read-mem x (mc-mem (stepn s 8)) k)
                     (read-mem x (mc-mem s) k))))

; from s2 to s3:  s2 --> s3.
(prove-lemma strtok-s2-s3 ()
     (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                   (equal ch (get-nth i1 lst1))
                   (not (equal ch 0)))
              (strtok-s3p (stepn s 4) (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                          str2 n2 lst2 (add 32 str1 i1*))))

(prove-lemma strtok-s2-s3-else (rewrite)
     (let ((s3 (stepn s 4)))
       (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                     (not (equal ch 0)))
                (and (equal (linked-rts-addr s3) (linked-rts-addr s))
                     (equal (linked-a6 s3) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s3))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s3 4 8 2)
                            (movem-saved s 4 8 2))
                     (equal (read-mem x (mc-mem s3) k)
                            (read-mem x (mc-mem s) k))))))       

(prove-lemma strtok-s2-s3-rfile (rewrite)
     (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                   (not (equal ch 0))
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
                     (read-rn oplen rn (mc-rfile s)))))

; from s3 to s4:  s3 --> s4.
(prove-lemma strtok-s3-s4 ()
     (implies (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
              (strtok-s4p (stepn s 3) i1* i1 str1 n1 lst1 
                          0 0 str2 n2 lst2 (get-nth i1 lst1) tok)))

(prove-lemma strtok-s3-s4-else (rewrite)
     (let ((s4 (stepn s 3)))
       (implies (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                (and (equal (linked-rts-addr s4) (linked-rts-addr s))
                     (equal (linked-a6 s4) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s4))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s4 4 16 4)
                            (movem-saved s 4 16 4))
                     (equal (read-mem x (mc-mem s4) k)
                            (read-mem x (mc-mem s) k))))))

(prove-lemma strtok-s3-s4-rfile (rewrite)
     (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
                     (read-rn oplen rn (mc-rfile s)))))

; from s4 to exit: s4 --> sn.
; case 1.
(prove-lemma strtok-s4-sn-1 (rewrite)
     (let ((sn (stepn s 13)))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (equal (get-nth i2 lst2) ch)
             (not (equal ch 0)))
        (and (equal (mc-status sn) 'running)
             (equal (mc-pc sn) (linked-rts-addr s))
             (equal (read-dn 32 0 sn) tok)
             (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                    (add 32 str1 (add 32 i1* 1)))
             (mem-lst 1 str1 (mc-mem sn) n1 (put-nth 0 i1 lst1))
             (equal (read-rn 32 14 (mc-rfile sn))
                    (linked-a6 s))
             (equal (read-rn 32 15 (mc-rfile sn))
                    (add 32 (read-an 32 6 s) 8))))))

(prove-lemma strtok-s4-sn-rfile-1 (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (equal (get-nth i2 lst2) ch)
           (not (equal ch 0))
           (d2-7a2-5p rn)
           (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s 13)))
             (if (d4-7a2-5p rn)
                 (read-rn oplen rn (mc-rfile s))
               (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

(prove-lemma strtok-s4-sn-mem-1 (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (equal (get-nth i2 lst2) ch)
           (not (equal ch 0))
           (disjoint x k (strtok-last-addr) 4)
           (disjoint x k str1 n1))
      (equal (read-mem x (mc-mem (stepn s 13)) k)
             (read-mem x (mc-mem s) k))))

; case 2.
(prove-lemma strtok-s4-sn-2 (rewrite)
     (let ((sn (stepn s 14)))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (equal (get-nth i2 lst2) ch)
             (equal ch 0))
        (and (equal (mc-status sn) 'running)
             (equal (mc-pc sn) (linked-rts-addr s))
             (equal (read-dn 32 0 sn) tok)
             (equal (read-mem (strtok-last-addr) (mc-mem sn) 4) 0)
             (mem-lst 1 str1 (mc-mem sn) n1 lst1)
             (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
             (equal (read-rn 32 15 (mc-rfile sn))
                    (add 32 (read-an 32 6 s) 8))))))

(prove-lemma strtok-s4-sn-rfile-2 (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (equal (get-nth i2 lst2) ch)
           (equal ch 0)
           (d2-7a2-5p rn)
           (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s 14)))
             (if (d4-7a2-5p rn)
                 (read-rn oplen rn (mc-rfile s))
               (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

(prove-lemma strtok-s4-sn-mem-2 (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (equal (get-nth i2 lst2) ch)
           (equal ch 0)
           (disjoint x k (strtok-last-addr) 4)
           (disjoint x k str1 n1))
      (equal (read-mem x (mc-mem (stepn s 14)) k)
             (read-mem x (mc-mem s) k))))

; from s4 to s3:  s4 --> s3.
(prove-lemma strtok-s4-s3-base (rewrite)
     (let ((s3 (stepn s 7)))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (equal ch (get-nth i1 lst1))
             (not (equal (get-nth i2 lst2) ch))
             (equal (get-nth i2 lst2) 0))
        (and (strtok-s3p s3 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                         str2 n2 lst2 tok)
             (equal (linked-rts-addr s3) (linked-rts-addr s))
             (equal (linked-a6 s3) (linked-a6 s))
             (equal (read-rn oplen 14 (mc-rfile s3))
                    (read-rn oplen 14 (mc-rfile s)))
             (equal (movem-saved s3 4 8 2) (movem-saved s 4 8 2))
             (equal (read-mem x (mc-mem s3) k)
                    (read-mem x (mc-mem s) k))))))

(prove-lemma strtok-s4-s3-rfile-base (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (not (equal (get-nth i2 lst2) ch))
           (equal (get-nth i2 lst2) 0)
           (d4-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
             (read-rn oplen rn (mc-rfile s)))))

; from s4 to s4:  s4 --> s4.
(prove-lemma strtok-s4-s4 (rewrite)
     (let ((s4 (stepn s 6)))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (not (equal (get-nth i2 lst2) ch))
             (not (equal (get-nth i2 lst2) 0)))
        (and (strtok-s4p s4 i1* i1 str1 n1 lst1 (add 32 i2* 1) 
                         (add1 i2) str2 n2 lst2 ch tok)
             (equal (linked-rts-addr s4) (linked-rts-addr s))
             (equal (linked-a6 s4) (linked-a6 s))
             (equal (read-rn oplen 14 (mc-rfile s4))
                    (read-rn oplen 14 (mc-rfile s)))
             (equal (movem-saved s4 4 8 2) (movem-saved s 4 8 2))
             (equal (read-mem x (mc-mem s4) k)
                    (read-mem x (mc-mem s) k))))))

(prove-lemma strtok-s4-s4-rfile (rewrite)
     (implies 
      (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
           (not (equal (get-nth i2 lst2) ch))
           (not (equal (get-nth i2 lst2) 0))
           (d4-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
             (read-rn oplen rn (mc-rfile s)))))

; put together: s4 --> sn.
(prove-lemma strtok-s4-sn (rewrite)
     (let ((sn (stepn s (strtok-t3 i2 n2 lst2 ch))))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (strchr i2 n2 lst2 ch))
        (and (equal (mc-status sn) 'running)
             (equal (mc-pc sn) (linked-rts-addr s))
             (equal (read-dn 32 0 sn) tok)
             (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                    (if (equal ch 0) 0 (add 32 str1 (add 32 i1* 1))))
             (mem-lst 1 str1 (mc-mem sn) n1 (strtok-lst0 i1 lst1 ch))
             (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
             (equal (read-rn 32 15 (mc-rfile sn))
                    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strtok-induct2 s i2* i2 n2 lst2 ch))
      (disable strtok-s4p read-dn)))

(prove-lemma strtok-s4-sn-rfile (rewrite)
     (let ((sn (stepn s (strtok-t3 i2 n2 lst2 ch))))
       (implies 
        (and (strtok-s4p s i* i str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (strchr i2 n2 lst2 ch)
             (d2-7a2-5p rn)
             (leq oplen 32))
        (equal (read-rn oplen rn (mc-rfile sn))
               (if (d4-7a2-5p rn)
                   (read-rn oplen rn (mc-rfile s))
                 (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((induct (strtok-induct2 s i2* i2 n2 lst2 ch))
      (disable strtok-s4p)))

(prove-lemma strtok-s4-sn-mem (rewrite)
     (let ((sn (stepn s (strtok-t3 i2 n2 lst2 ch))))
       (implies 
        (and (strtok-s4p s i* i str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (strchr i2 n2 lst2 ch)
             (disjoint x k (strtok-last-addr) 4)
             (disjoint x k str1 n1))
        (equal (read-mem x (mc-mem sn) k)
               (read-mem x (mc-mem s) k))))
     ((induct (strtok-induct2 s i2* i2 n2 lst2 ch))
      (disable strtok-s4p)))       

; put together: s4 --> s3.
(prove-lemma strtok-s4p-info (rewrite)
     (implies (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
              (equal (lessp i2 n2) t)))

(prove-lemma strtok-s4-s3 (rewrite)
     (let ((s3 (stepn s (strtok-t3 i2 n2 lst2 ch))))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (equal ch (get-nth i1 lst1))
             (not (strchr i2 n2 lst2 ch)))
        (and (strtok-s3p s3 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                         str2 n2 lst2 tok)
             (equal (linked-rts-addr s3) (linked-rts-addr s))
             (equal (linked-a6 s3) (linked-a6 s))
             (equal (read-rn oplen 14 (mc-rfile s3))
                    (read-rn oplen 14 (mc-rfile s)))
             (equal (movem-saved s3 4 8 2) (movem-saved s 4 8 2))
             (equal (read-mem x (mc-mem s3) k)
                    (read-mem x (mc-mem s) k)))))
     ((induct (strtok-induct2 s i2* i2 n2 lst2 ch))
      (disable strtok-s4p strtok-s3p)))       

(disable strtok-s4p-info)

(prove-lemma strtok-s4-s3-rfile (rewrite)
     (let ((s3 (stepn s (strtok-t3 i2 n2 lst2 ch))))
       (implies 
        (and (strtok-s4p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch tok)
             (not (strchr i2 n2 lst2 ch))
             (d4-7a2-5p rn))
        (equal (read-rn oplen rn (mc-rfile s3))
               (read-rn oplen rn (mc-rfile s)))))
     ((induct (strtok-induct2 s i2* i2 n2 lst2 ch))
      (disable strtok-s4p)))

; from s3 to exit:  s3 --> sn.
(prove-lemma strtok-s3-sn-base (rewrite)
     (let ((ch (get-nth i1 lst1)))
       (let ((sn (stepn s (strtok-t4 n2 lst2 ch))))
         (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (strchr 0 n2 lst2 ch))
                  (and (equal (mc-status sn) 'running)
                       (equal (mc-pc sn) (linked-rts-addr s))
                       (equal (read-dn 32 0 sn) tok)
                       (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                              (if (equal ch 0) 0 (add 32 str1 (add 32 i1* 1))))
                       (mem-lst 1 str1 (mc-mem sn) n1 (strtok-lst0 i1 lst1 ch))
                       (equal (read-rn 32 14 (mc-rfile sn))
                              (linked-a6 s))
                       (equal (read-rn 32 15 (mc-rfile sn))
                              (add 32 (read-an 32 6 s) 8))))))
     ((use (strtok-s3-s4))
      (disable strtok-s3p strtok-s4p read-dn strtok-t3 strtok-lst0)))

(prove-lemma strtok-s3-sn-rfile-base (rewrite)
     (let ((sn (stepn s (strtok-t4 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (strchr 0 n2 lst2 (get-nth i1 lst1))
                     (d2-7a2-5p rn)
                     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d4-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((use (strtok-s3-s4))
      (disable strtok-s3p strtok-s4p strchr strtok-t3)))

(prove-lemma strtok-s3-sn-mem-base (rewrite)
     (let ((sn (stepn s (strtok-t4 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (strchr 0 n2 lst2 (get-nth i1 lst1))
                     (disjoint x k (strtok-last-addr) 4)
                     (disjoint x k str1 n1))
              (equal (read-mem x (mc-mem sn) k)
                     (read-mem x (mc-mem s) k))))
     ((use (strtok-s3-s4))
      (disable strtok-s3p strtok-s4p)))

; from s3 to s3:  s3 --> s3.
(prove-lemma strtok-s3-s3 (rewrite)
     (let ((s3 (stepn s (strtok-t4 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (not (strchr 0 n2 lst2 (get-nth i1 lst1))))
                (and (strtok-s3p s3 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
                                 str2 n2 lst2 tok)
                     (equal (linked-rts-addr s3) (linked-rts-addr s))
                     (equal (linked-a6 s3) (linked-a6 s))
                     (equal (read-rn oplen 14 (mc-rfile s3))
                            (read-rn oplen 14 (mc-rfile s)))
                     (equal (movem-saved s3 4 16 4)
                            (movem-saved s 4 16 4))
                     (equal (read-mem x (mc-mem s3) k)
                            (read-mem x (mc-mem s) k)))))
     ((use (strtok-s3-s4))
      (disable strtok-s3p strtok-s4p strchr strtok-t3)))

(prove-lemma strtok-s3-s3-rfile (rewrite)
     (let ((s3 (stepn s (strtok-t4 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (not (strchr 0 n2 lst2 (get-nth i1 lst1)))
                     (d4-7a2-5p rn))
                (equal (read-rn oplen rn (mc-rfile s3))
                       (read-rn oplen rn (mc-rfile s)))))
     ((use (strtok-s3-s4))
      (disable strtok-s3p strtok-s4p strchr strtok-t3)))

; put together: s3 --> sn.
(prove-lemma strtok-s3p-info (rewrite)
     (implies (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
              (and (numberp i1)
                   (equal (lessp i1 n1) t))))
          
(prove-lemma strtok-s3-sn (rewrite)
     (let ((sn (stepn s (strtok-t5 i1 n1 lst1 n2 lst2))))
       (implies (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) tok)
                     (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                            (strtok-last0 str1 i1* i1 n1 lst1 n2 lst2))
                     (mem-lst 1 str1 (mc-mem sn) n1 
                              (strtok-lst1 i1 n1 lst1 n2 lst2))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((induct (strtok-induct3 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s3p strtok-t4 strchr read-dn strtok-lst0)))

(prove-lemma strtok-s3-sn-rfile (rewrite)
     (let ((sn (stepn s (strtok-t5 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (d2-7a2-5p rn)
                     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d4-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((induct (strtok-induct3 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s3p strtok-t4 strchr)))

(prove-lemma strtok-s3-sn-mem (rewrite)
     (let ((sn (stepn s (strtok-t5 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s3p s i1* i1 str1 n1 lst1 str2 n2 lst2 tok)
                     (disjoint x k (strtok-last-addr) 4)
                     (disjoint x k str1 n1))
                (equal (read-mem x (mc-mem sn) k)
                       (read-mem x (mc-mem s) k))))
     ((induct (strtok-induct3 s i1* i1 n1 lst1 n2 lst2))
      (disable strtok-s3p strtok-t4 strchr)))

(disable strtok-s3p-info)

; from s2 to exit:  s2 --> sn.
(prove-lemma strtok-s2-sn (rewrite)
     (let ((sn (stepn s (strtok-t6 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                     (equal (get-nth i1 lst1) ch))
                (and (equal (mc-status sn) 'running)
                     (equal (mc-pc sn) (linked-rts-addr s))
                     (equal (read-dn 32 0 sn) 
                            (if (equal ch 0) 0 (add 32 str1 i1*)))
                     (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                            (strtok-last1 str1 i1* i1 n1 lst1 n2 lst2))
                     (mem-lst 1 str1 (mc-mem sn) n1 
                              (strtok-lst2 i1 n1 lst1 n2 lst2))
                     (equal (read-rn 32 14 (mc-rfile sn))
                            (linked-a6 s))
                     (equal (read-rn 32 15 (mc-rfile sn))
                            (add 32 (read-an 32 6 s) 8)))))
     ((use (strtok-s2-s3 (ch (get-nth i1 lst1))))
      (disable strtok-s2p strtok-s3p strtok-t5 read-dn strtok-last0
               strtok-lst1)))

(prove-lemma strtok-s2-sn-rfile (rewrite)
     (let ((ch (get-nth i1 lst1))
           (sn (stepn s (strtok-t6 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                     (d2-7a2-5p rn)
                     (leq oplen 32))
                (equal (read-rn oplen rn (mc-rfile sn))
                       (if (d4-7a2-5p rn)
                           (read-rn oplen rn (mc-rfile s))
                         (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((use (strtok-s2-s3 (ch (get-nth i1 lst1))))
      (disable strtok-s2p strtok-s3p strtok-t5)))

(prove-lemma strtok-s2-sn-mem (rewrite)
     (let ((ch (get-nth i1 lst1))
           (sn (stepn s (strtok-t6 i1 n1 lst1 n2 lst2))))
       (implies (and (strtok-s2p s i1* i1 str1 n1 lst1 str2 n2 lst2 ch)
                     (disjoint x k (strtok-last-addr) 4)
                     (disjoint x k str1 n1))
                (equal (read-mem x (mc-mem sn) k)
                       (read-mem x (mc-mem s) k))))
     ((use (strtok-s2-s3 (ch (get-nth i1 lst1))))
      (disable strtok-s2p strtok-s3p)))

; the correctness of strtok.
(prove-lemma strtok-correctness (rewrite)
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (let ((sn (stepn s (strtok-t str1 last n1 lst1 n2 lst2))))
         (implies (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                  (and (equal (mc-status sn) 'running)
                       (equal (mc-pc sn) (rts-addr s))
                       (equal (read-dn 32 0 sn)
                              (strtok-tok str1 last n1 lst1 n2 lst2))
                       (equal (read-mem (strtok-last-addr) (mc-mem sn) 4)
                              (strtok-last str1 last n1 lst1 n2 lst2))
                       (equal (read-rn 32 14 (mc-rfile sn))
                              (read-rn 32 14 (mc-rfile s)))
                       (equal (read-rn 32 15 (mc-rfile sn))
                              (add 32 (read-sp s) 4))))))
     ((use (strtok-s-s0-1)
           (strtok-s-s0-2)
           (strtok-s0-s2 (s (stepn s 6)) (i1* 0) (i1 0))
           (strtok-s0-s2 (s (stepn s 9)) 
                         (str1 (read-mem (strtok-last-addr) (mc-mem s) 4))
                         (i1* 0) (i1 0)))
     (disable strtok-statep strtok-s0p strtok-s2p strspn* strspn strtok-t2
              strtok-t6 linked-rts-addr linked-a6 read-dn strtok-last1)))

(prove-lemma strtok-lst-1 (rewrite)
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (let ((sn (stepn s (strtok-t str1 last n1 lst1 n2 lst2))))
         (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                       (not (equal (nat-to-uint str1) 0)))
                  (mem-lst 1 str1 (mc-mem sn) n1 
                           (strtok-lst n1 lst1 n2 lst2)))))
     ((use (strtok-s-s0-1)
           (strtok-s0-s2 (s (stepn s 6)) (i1* 0) (i1 0))
           (strtok-s0-s2 (s (stepn s 9)) 
                         (str1 (read-mem (strtok-last-addr) (mc-mem s) 4))
                         (i1* 0) (i1 0)))
      (disable strtok-statep strtok-s0p strtok-s2p strspn* strspn
               strtok-t2 strtok-t6 strtok-lst2)))

(prove-lemma strtok-lst-2 (rewrite)
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (let ((sn (stepn s (strtok-t str1 last n1 lst1 n2 lst2))))
         (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                       (equal (nat-to-uint str1) 0)
                       (not (equal (nat-to-uint last) 0)))
                  (mem-lst 1 last (mc-mem sn) n1 
                           (strtok-lst n1 lst1 n2 lst2)))))
     ((use (strtok-s-s0-2)
           (strtok-s0-s2 (s (stepn s 6)) (i1* 0) (i1 0))
           (strtok-s0-s2 (s (stepn s 9)) 
                         (str1 (read-mem (strtok-last-addr) (mc-mem s) 4))
                         (i1* 0) (i1 0)))
      (disable strtok-statep strtok-s0p strtok-s2p strspn* strspn
               strtok-t2 strtok-t6 strtok-lst2)))

(prove-lemma strtok-rfile (rewrite)
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (let ((sn (stepn s (strtok-t str1 last n1 lst1 n2 lst2))))
         (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                       (d2-7a2-5p rn)
                       (leq oplen 32))
                  (equal (read-rn oplen rn (mc-rfile sn))
                         (read-rn oplen rn (mc-rfile s))))))
     ((use (strtok-s-s0-1)
           (strtok-s-s0-2)
           (strtok-s0-s2 (s (stepn s 6)) (i1* 0) (i1 0))
           (strtok-s0-s2 (s (stepn s 9)) 
                         (str1 (read-mem (strtok-last-addr) (mc-mem s) 4))
                         (i1* 0) (i1 0)))
      (disable strtok-statep strtok-s0p strtok-s2p strspn* strspn
               strtok-t2 strtok-t6)))

(prove-lemma strtok-mem (rewrite)
     (let ((last (read-mem (strtok-last-addr) (mc-mem s) 4)))
       (let ((sn (stepn s (strtok-t str1 last n1 lst1 n2 lst2))))
         (implies (and (strtok-statep s str1 n1 lst1 str2 n2 lst2)
                       (disjoint x k (sub 32 12 (read-sp s)) 24)
                       (disjoint x k (strtok-last-addr) 4)
                       (if (equal (nat-to-uint str1) 0)
                           (disjoint x k last n1)
                         (disjoint x k str1 n1)))
                  (equal (read-mem x (mc-mem sn) k)
                         (read-mem x (mc-mem s) k)))))
     ((use (strtok-s-s0-1)
           (strtok-s-s0-2)
           (strtok-s0-s2 (s (stepn s 6)) (i1* 0) (i1 0))
           (strtok-s0-s2 (s (stepn s 9)) 
                         (str1 (read-mem (strtok-last-addr) (mc-mem s) 4))
                         (i1* 0) (i1 0)))
      (disable strtok-statep strtok-s0p strtok-s2p strspn* strspn
               strtok-t2 strtok-t6)))

(disable strtok-t)

; strspn* -> strspn, strcspn* --> strcspn.
(prove-lemma strspn*-strspn (rewrite)
     (implies (and (strspn i n1 lst1 n2 lst2)
                   (equal i (nat-to-uint i*))
                   (nat-rangep i* 32)
                   (uint-rangep n1 32))
              (equal (nat-to-uint (strspn* i* i n1 lst1 n2 lst2))
                     (strspn i n1 lst1 n2 lst2)))
     ((induct (strspn* i* i n1 lst1 n2 lst2))))

(prove-lemma strcspn*-strcspn (rewrite)
     (implies (and (strcspn i n1 lst1 n2 lst2)
                   (equal i (nat-to-uint i*))
                   (nat-rangep i* 32)
                   (uint-rangep n1 32))
              (equal (nat-to-uint (strcspn* i* i n1 lst1 n2 lst2))
                     (strcspn i n1 lst1 n2 lst2)))
     ((induct (strcspn* i* i n1 lst1 n2 lst2))))

; some properties of strtok.
; see the file cstring.events. 
