#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "gcd" t)

#|

The following C program computes the greatest common divisor of 
three nonnegative integers a, b and c. We investigate the machine 
code of this program generated by a widely used C compiler gcc, 
and verify the correctness of the code.  The aim here is to see 
how to handle subroutine calls.

gcd3(a, b, c)
long int a, b, c;
{
  gcd(gcd(a, b), c);
}

Here is the MC68020 assembly code of the above GCD program.  The code is 
generated by gcc.

0x2324 <gcd3>:          linkw a6,#0
0x2328 <gcd3+4>:        movel a2,sp@-
0x232a <gcd3+6>:        movel a6@(16),sp@-
0x232e <gcd3+10>:       movel a6@(12),sp@-
0x2332 <gcd3+14>:       movel a6@(8),sp@-
0x2336 <gcd3+18>:       lea @#0x2350 <gcd>,a2
0x233c <gcd3+24>:       jsr a2@
0x233e <gcd3+26>:       addqw #8,sp
0x2340 <gcd3+28>:       movel d0,sp@-
0x2342 <gcd3+30>:       jsr a2@
0x2344 <gcd3+32>:       moveal a6@(-4),a2
0x2348 <gcd3+36>:       unlk a6
0x234a <gcd3+38>:       rts

The machine code of the above program is:

<gcd3>:       0x4e56  0x0000  0x2f0a  0x2f2e  0x0010  0x2f2e  0x000c  0x2f2e
<gcd3+16>:    0x0008  0x45f9  0x0000  0x2350  0x4e92  0x504f  0x2f00  0x4e92
<gcd3+32>:    0x246e  0xfffc  0x4e5e  0x4e75

'(78      86      0       0       47      10      47      46
  0       16      47      46      0       12      47      46
  0       8       69      249     0       0       35      80
  78      146     80      79      47      0       78      146
  36      110     255     252     78      94      78      117)
|#

; now we start to verify this GCD3 program,  defined by (gcd3-code).
(defn gcd3-code ()
  '(78      86      0       0       47      10      47      46
    0       16      47      46      0       12      47      46
    0       8       69      249     -1      -1      -1      -1
    78      146     80      79      47      0       78      146
    36      110     255     252     78      94      78      117))

(constrain gcd3-load (rewrite)
   (equal (gcd3-loadp s)
	  (and (evenp (gcd3-addr))
	       (numberp (gcd3-addr))
	       (nat-rangep (gcd3-addr) 32)
	       (rom-addrp (gcd3-addr) (mc-mem s) 40)
	       (mcode-addrp (gcd3-addr) (mc-mem s) (gcd3-code))
	       (gcd-loadp s)
	       (equal (pc-read-mem (add 32 (gcd3-addr) 20) (mc-mem s) 4)
		      (gcd-addr))))
    ((gcd3-loadp (lambda (s) f))
     (gcd3-addr (lambda () 1))))

(prove-lemma stepn-gcd3-loadp (rewrite)
     (equal (gcd3-loadp (stepn s n))
	    (gcd3-loadp s)))

(defn gcd3 (a b c)
  (gcd (gcd a b) c))

(defn gcd3-t0 (a b c)
  7)

(defn gcd3-t1 (a b c)
  (gcd-t a b))

(defn gcd3-t2 (a b c)
  3)

(defn gcd3-t3 (a b c)
  (gcd-t (gcd a b) c))

(defn gcd3-t4 (a b c)
  3)

(defn gcd3-t (a b c)
  (splus (gcd3-t0 a b c)
	 (splus (gcd3-t1 a b c)
		(splus (gcd3-t2 a b c)
		       (splus (gcd3-t3 a b c)
			      (gcd3-t4 a b c))))))

; the initial state.
(defn gcd3-statep (s a b c)
  (and (equal (mc-status s) 'running)
       (gcd3-loadp s)
       (equal (mc-pc s) (gcd3-addr))
       (ram-addrp (sub 32 36 (read-sp s)) (mc-mem s) 52)
       (equal a (iread-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal b (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal c (iread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (lessp 0 a)
       (lessp 0 b)
       (lessp 0 c)))

; the state after the execution of the first JSR instruction, but before
; the execution of the subroutine GCD.
(defn gcd3-s0p (s a b c)
  (and (equal (mc-status s) 'running)
       (gcd3-loadp s)
       (equal (mc-pc s) (gcd-addr))
       (equal (read-an 32 2 s) (gcd-addr))
       (equal (rts-addr s) (add 32 (gcd3-addr) 26))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 52)
       (equal* (read-an 32 6 s) (add 32 (read-sp s) 20))
       (equal a (iread-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal b (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal c (iread-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (lessp 0 a)
       (lessp 0 b)
       (lessp 0 c)))

; the state right after return from the first call to subroutine GCD.
(defn gcd3-s1p (s a b c)
  (and (equal (mc-status s) 'running)
       (gcd3-loadp s)
       (equal (read-an 32 2 s) (gcd-addr))
       (equal (mc-pc s) (add 32 (gcd3-addr) 26))
       (ram-addrp (sub 32 16 (read-sp s)) (mc-mem s) 52)
       (equal* (read-an 32 6 s) (add 32 (read-sp s) 16))
       (equal (iread-dn 32 0 s) (gcd a b))
       (equal c (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (lessp 0 a)
       (lessp 0 b)
       (lessp 0 c)))

; the state after the execution of the second JSR, but before the 
; execution of the subroutine GCD.
(defn gcd3-s2p (s a b c)
  (and (equal (mc-status s) 'running)
       (gcd3-loadp s)
       (equal (mc-pc s) (gcd-addr))
       (equal (rts-addr s) (add 32 (gcd3-addr) 32))
       (ram-addrp (sub 32 16 (read-sp s)) (mc-mem s) 52)
       (equal* (read-an 32 6 s) (add 32 (read-sp s) 16))
       (equal (gcd a b) (iread-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal c (iread-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (lessp 0 a)
       (lessp 0 b)
       (lessp 0 c)))

; the state returned from the second call to the subroutine GCD.
(defn gcd3-s3p (s a b c)
  (and (equal (mc-status s) 'running)
       (gcd3-loadp s)
       (equal (mc-pc s) (add 32 (gcd3-addr) 32))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 44)
       (equal* (read-an 32 6 s) (add 32 (read-sp s) 12))
       (equal (gcd (gcd a b) c) (iread-dn 32 0 s))
       (lessp 0 a)
       (lessp 0 b)
       (lessp 0 c)))

; from the initial state to s0.
(prove-lemma gcd3-s-s0 (rewrite)
     (let ((s0 (stepn s (gcd3-t0 a b c))))
       (implies (gcd3-statep s a b c)
		(and (gcd3-s0p s0 a b c)
		     (equal (linked-rts-addr s0) (rts-addr s))
		     (equal (linked-a6 s0) (read-an 32 6 s))
		     (equal (read-rn 32 14 (mc-rfile s0))
			    (sub 32 4 (read-sp s)))
		     (equal (rn-saved s0) (read-an 32 2 s))))))

(prove-lemma gcd3-s-s0-rfile (rewrite)
     (implies (and (gcd3-statep s a b c)
		   (d2-7a3-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (gcd3-t0 a b c))))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma gcd3-s-s0-mem (rewrite)
     (implies (and (gcd3-statep s a b c)
		   (disjoint x k (sub 32 36 (read-sp s)) 52))
	      (equal (read-mem x (mc-mem (stepn s (gcd3-t0 a b c))) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s1.
(prove-lemma gcd3-s0-s1 (rewrite)
     (let ((s1 (stepn s (gcd3-t1 a b c))))
       (implies (gcd3-s0p s a b c)
		(and (gcd3-s1p s1 a b c)
		     (equal (linked-rts-addr s1) (linked-rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile s1))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s1) (linked-a6 s))
		     (equal (rn-saved s1) (rn-saved s)))))
     ((disable rts-addr iread-dn)
      (enable gcd-statep)))

(prove-lemma gcd3-s0-s1-rfile (rewrite)
     (implies (and (gcd3-s0p s a b c)
		   (d2-7a2-5p rn)
		   (leq oplen 32))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (gcd3-t1 a b c))))
		     (read-rn oplen rn (mc-rfile s))))
     ((enable gcd-statep)))

(prove-lemma gcd3-s0-s1-mem (rewrite)
     (implies (and (gcd3-s0p s a b c)
		   (disjoint x k (sub 32 32 (read-an 32 6 s)) 52))
	      (equal (read-mem x (mc-mem (stepn s (gcd3-t1 a b c))) k)
		     (read-mem x (mc-mem s) k)))
     ((enable gcd-statep)))

; from s1 to s2. 
(prove-lemma gcd3-s1-s2 (rewrite)
     (let ((s2 (stepn s (gcd3-t2 a b c))))
       (implies (gcd3-s1p s a b c)
		(and (gcd3-s2p s2 a b c)
		     (equal (linked-rts-addr s2) (linked-rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile s2))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s2) (linked-a6 s))
		     (equal (rn-saved s2) (rn-saved s))))))

(prove-lemma gcd3-s1-s2-rfile (rewrite)
     (implies (and (gcd3-s1p s a b c)
		   (d2-7a3-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (gcd3-t2 a b c))))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma gcd3-s1-s2-mem (rewrite)
     (implies (and (gcd3-s1p s a b c)
		   (disjoint x k (sub 32 32 (read-an 32 6 s)) 52))
	      (equal (read-mem x (mc-mem (stepn s (gcd3-t2 a b c))) k)
		     (read-mem x (mc-mem s) k))))

; from s2 to s3.
(prove-lemma gcd-nonzero (rewrite)
     (implies (and (not (zerop a))
		   (not (zerop b)))
	      (not (equal (gcd a b) 0))))

(prove-lemma gcd3-s2-s3 (rewrite)
     (let ((s3 (stepn s (gcd3-t3 a b c))))
       (implies (gcd3-s2p s a b c)
		(and (gcd3-s3p s3 a b c)
		     (equal (linked-rts-addr s3) (linked-rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile s3))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s3) (linked-a6 s))
		     (equal (rn-saved s3) (rn-saved s)))))
     ((disable rts-addr iread-dn)
      (enable gcd-statep)))

(prove-lemma gcd3-s2-s3-rfile (rewrite)
     (implies (and (gcd3-s2p s a b c)
		   (d2-7a2-5p rn)
		   (leq oplen 32))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (gcd3-t3 a b c))))
		     (read-rn oplen rn (mc-rfile s))))
     ((enable gcd-statep)))

(prove-lemma gcd3-s2-s3-mem (rewrite)
     (implies (and (gcd3-s2p s a b c)
		   (disjoint x k (sub 32 32 (read-an 32 6 s)) 52))
	      (equal (read-mem x (mc-mem (stepn s (gcd3-t3 a b c))) k)
		     (read-mem x (mc-mem s) k)))
     ((enable gcd-statep)))

; from s3 to exit.
(prove-lemma gcd3-s3-sn (rewrite)
     (let ((sn (stepn s (gcd3-t4 a b c))))
       (implies (gcd3-s3p s a b c)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (iread-dn 32 0 sn) (gcd (gcd a b) c))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))))))

(prove-lemma gcd3-s3-sn-rfile (rewrite)
     (implies (and (gcd3-s3p s a b c)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (gcd3-t4 a b c))))
		     (if (equal rn 10)
			 (head (rn-saved s) oplen)
		       (read-rn oplen rn (mc-rfile s))))))

(prove-lemma gcd3-s3-sn-mem (rewrite)
     (implies (and (gcd3-s3p s a b c)
		   (disjoint x k (sub 32 32 (read-an 32 6 s)) 52))
	      (equal (read-mem x (mc-mem (stepn s (gcd3-t4 a b c))) k)
		     (read-mem x (mc-mem s) k))))

(disable gcd3-t0)
(disable gcd3-t1)
(disable gcd3-t2)
(disable gcd3-t3)
(disable gcd3-t4)

; the correctness of the program GCD3.
(prove-lemma gcd3-correctness (rewrite)
     (let ((sn (stepn s (gcd3-t a b c))))
       (implies (gcd3-statep s a b c)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-rn 32 15 (mc-rfile s)) 4))
		     (implies (and (leq oplen 32)
				   (d2-7a2-5p rn))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 36 (read-sp s)) 52)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (iread-dn 32 0 sn) (gcd (gcd a b) c)))))
     ((disable iread-dn gcd3-statep linked-rts-addr)))

(disable gcd3-t)

; in the logic, the function gcd3 does computes the greatest common divisor
; of its three arguments.
(prove-lemma remainder-trans (rewrite)
	     (implies (and (equal (remainder a b) 0)
			   (equal (remainder b c) 0))
		      (equal (remainder a c) 0)))

(prove-lemma gcd3-is-cd (rewrite)
	     (and (equal (remainder a (gcd3 a b c)) 0)
		  (equal (remainder b (gcd3 a b c)) 0)
		  (equal (remainder c (gcd3 a b c)) 0))
	     ((use (remainder-trans (b (gcd a b)) (c (gcd3 a b c)))
		   (remainder-trans (a b) (b (gcd a b)) (c (gcd3 a b c))))))

(prove-lemma cd-divides-gcd ()
	     (implies (and (equal (remainder a x) 0)
			   (equal (remainder b x) 0))
		      (equal (remainder (gcd a b) x) 0))
	     ((induct (gcd a b)) 
	      (enable remainder-difference)))

(prove-lemma gcd3-the-greatest (rewrite)
	     (implies (and (not (zerop a))
			   (not (zerop b))
			   (not (zerop c))
			   (equal (remainder a x) 0)
			   (equal (remainder b x) 0)
			   (equal (remainder c x) 0))
		      (not (lessp (gcd3 a b c) x)))
	     ((use (cd-divides-gcd))))

(disable remainder-trans)
