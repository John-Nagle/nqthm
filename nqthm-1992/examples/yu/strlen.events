#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRLEN Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strlen function in the Berkeley string library.

/* find the length of str[] */
size_t
strlen(str)
	const char *str;
{
	register const char *s;

	for (s = str; *s; ++s);
	return(s - str);
}

The MC68020 assembly code of the C function strlen on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x25b0 <strlen>:        linkw fp,#0
0x25b4 <strlen+4>:      movel fp@(8),d0
0x25b8 <strlen+8>:      moveal d0,a0
0x25ba <strlen+10>:     tstb a0@
0x25bc <strlen+12>:     beq 0x25c4 <strlen+20>
0x25be <strlen+14>:     addqw #1,a0
0x25c0 <strlen+16>:     tstb a0@
0x25c2 <strlen+18>:     bne 0x25be <strlen+14>
0x25c4 <strlen+20>:     subl a0,d0
0x25c6 <strlen+22>:     negl d0
0x25c8 <strlen+24>:     unlk fp
0x25ca <strlen+26>:     rts

The machine code of the above program is:

<strlen>:    0x4e56  0x0000  0x202e  0x0008  0x2040  0x4a10  0x6706  0x5248
<strlen+16>: 0x4a10  0x66fa  0x9088  0x4480  0x4e5e  0x4e75

'(78      86      0       0       32      46      0       8
  32      64      74      16      103     6       82      72
  74      16      102     250     144     136     68      128
  78      94      78      117)
|#

; in the logic, the above program is defined by (strlen-code).
(defn strlen-code ()
  '(78      86      0       0       32      46      0       8
    32      64      74      16      103     6       82      72
    74      16      102     250     144     136     68      128
    78      94      78      117))

(constrain strlen-load (rewrite)
   (equal (strlen-loadp s)
	  (and (evenp (strlen-addr))
	       (numberp (strlen-addr))
	       (nat-rangep (strlen-addr) 32)
	       (rom-addrp (strlen-addr) (mc-mem s) 28)
	       (mcode-addrp (strlen-addr) (mc-mem s) (strlen-code))))
    ((strlen-loadp (lambda (s) f))
     (strlen-addr (lambda () 1))))

(prove-lemma stepn-strlen-loadp (rewrite)
     (equal (strlen-loadp (stepn s n))
	    (strlen-loadp s)))

; the computation time of the program.
(defn strlen1-t (i n lst)
  (if (lessp i n)
      (if (equal (get-nth i lst) (null))
	  6
	(splus 3 (strlen1-t (add1 i) n lst)))
    0)
  ((lessp (difference n i))))

(defn strlen-t (n lst)
  (if (equal (get-nth 0 lst) 0)
      9
    (splus 6 (strlen1-t 1 n lst))))

; an induction hint.
(defn strlen-induct (s i* i n lst)
  (if (lessp i n)
      (if (equal (get-nth i lst) (null))
	  t
	(strlen-induct (stepn s 3) (add 32 i* 1) (add1 i) n lst))
    t)
  ((lessp (difference n i))))

; the preconditions of the initial state.
(defn strlen-statep (s str n lst)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 28)
       (mcode-addrp (mc-pc s) (mc-mem s) (strlen-code))
       (ram-addrp (sub 32 4 (read-sp s)) (mc-mem s) 12)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint str n (sub 32 4 (read-sp s)) 12)
       (equal str (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (lessp (slen 0 n lst) n)
       (numberp n)
       (uint-rangep n 32)))

; an intermediate state.
(defn strlen-s0p (s str i* i n lst)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 16 (mc-pc s)) (mc-mem s) 28)
       (mcode-addrp (sub 32 16 (mc-pc s)) (mc-mem s) (strlen-code))
       (ram-addrp (read-an 32 6 s) (mc-mem s) 12)
       (ram-addrp str (mc-mem s) n)
       (mem-lst 1 str (mc-mem s) n lst)
       (disjoint str n (read-an 32 6 s) 12)
       (equal* (read-an 32 0 s) (add 32 str i*))
       (equal str (read-dn 32 0 s))
       (equal i (nat-to-uint i*))
       (lessp (slen i n lst) n)
       (numberp i*)
       (nat-rangep i* 32)
       (numberp n)
       (uint-rangep n 32)))

; from the intial state s to exit: s --> sn.
(prove-lemma strlen-s-sn (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (equal (get-nth 0 lst) 0))
	      (and (equal (mc-status (stepn s 9)) 'running)
		   (equal (mc-pc (stepn s 9)) (rts-addr s))
		   (equal (nat-to-uint (read-dn 32 0 (stepn s 9))) 0)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 9)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 9))) 
			  (read-an 32 6 s)))))

(prove-lemma strlen-s-sn-rfile (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (equal (get-nth 0 lst) 0)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 9)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strlen-s-sn-mem (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (equal (get-nth 0 lst) 0)
		   (disjoint x k (sub 32 4 (read-sp s)) 12))
	      (equal (read-mem x (mc-mem (stepn s 9)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state s to s0: s --> s0.
(prove-lemma strlen-s-s0 ()
     (implies (and (strlen-statep s str n lst)
		   (not (equal (get-nth 0 lst) 0)))
	      (strlen-s0p (stepn s 6) str 1 1 n lst)))

(prove-lemma strlen-s-s0-else (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (not (equal (get-nth 0 lst) 0)))
	      (and (equal (linked-rts-addr (stepn s 6)) (rts-addr s))
		   (equal (linked-a6 (stepn s 6)) (read-an 32 6 s))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
			  (sub 32 4 (read-sp s))))))

(prove-lemma strlen-s-s0-rfile (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (not (equal (get-nth 0 lst) 0))
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strlen-s-s0-mem (rewrite)
     (implies (and (strlen-statep s str n lst)
		   (not (equal (get-nth 0 lst) 0))
		   (disjoint x k (sub 32 4 (read-sp s)) 12))
	      (equal (read-mem x (mc-mem (stepn s 6)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to exit (base case), from s0 to s0 (induction case).
; base case: s0 --> exit.
(prove-lemma strlen-s0-sn-base (rewrite)
     (implies (and (strlen-s0p s str i* i n lst)
		   (equal (get-nth i lst) 0))
	      (and (equal (mc-status (stepn s 6)) 'running)
		   (equal (mc-pc (stepn s 6)) (linked-rts-addr s))
		   (equal (nat-to-uint (read-dn 32 0 (stepn s 6))) i)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6))) 
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 6)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 6)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strlen-s0-sn-rfile-base (rewrite)
     (implies (and (strlen-s0p s str i* i n lst)
		   (d2-7a2-5p rn)
		   (equal (get-nth i lst) 0))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
		     (read-rn oplen rn (mc-rfile s)))))

; induction case: s0 --> s0.
(prove-lemma strlen-s0-s0 (rewrite)
     (implies (and (strlen-s0p s str i* i n lst)
		   (not (equal (get-nth i lst) 0)))
	      (and (strlen-s0p (stepn s 3) str (add 32 i* 1) (add1 i) n lst)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 3)) (linked-rts-addr s))
		   (equal (read-mem x (mc-mem (stepn s 3)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strlen-s0-s0-rfile (rewrite)
     (implies (and (strlen-s0p s str i* i n lst)
		   (d2-7a2-5p rn)
		   (not (equal (get-nth i lst) 0)))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

; put together (s0 --> exit).
(prove-lemma strlen-s0p-info (rewrite)
     (implies (strlen-s0p s str i* i n lst)
	      (equal (lessp i n) t)))

(prove-lemma strlen-s0-sn (rewrite)
     (let ((sn (stepn s (strlen1-t i n lst))))
       (implies (strlen-s0p s str i* i n lst)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (nat-to-uint (read-dn 32 0 sn))
			    (strlen i n lst))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strlen-induct s i* i n lst))
      (disable strlen-s0p read-dn)))

(disable strlen-s0p-info)

(prove-lemma strlen-s0-sn-rfile (rewrite)
     (implies 
      (and (strlen-s0p s str i* i n lst)
	   (d2-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strlen1-t i n lst))))
	     (read-rn oplen rn (mc-rfile s))))
     ((induct (strlen-induct s i* i n lst))
      (disable strlen-s0p)))

; the correctness of the STRLEN program.
(prove-lemma strlen-statep-info ()
     (implies (strlen-statep s str n lst)
	      (not (zerop n))))

(prove-lemma strlen-correctness (rewrite)
     (let ((sn (stepn s (strlen-t n lst))))
       (implies (strlen-statep s str n lst)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (d2-7a2-5p rn)
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 4 (read-sp s)) 12)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (uread-dn 32 0 sn) (strlen 0 n lst)))))
     ((use (strlen-s-s0) (strlen-statep-info))
      (disable strlen-statep strlen-s0p linked-rts-addr linked-a6 read-dn)))

(disable strlen-t)

; some properties of strlen.
; see the file cstring.events.

(make-lib "strlen" t)