#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mc20-2" t)
;          Proof of the Correctness of the STRCSPN Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strcspn function in the Berkeley string library.

size_t
strcspn(s1, s2)
	const char *s1;
	register const char *s2;
{
	register const char *p, *spanp;
	register char c, sc;

	/*
	 * Stop as soon as we find any character from s2.  Note that there
	 * must be a NUL in s2; it suffices to stop when we find that, too.
	 */
	for (p = s1;;) {
		c = *p++;
		spanp = s2;
		do {
			if ((sc = *spanp++) == c)
				return (p - 1 - s1);
		} while (sc != 0);
	}
	/* NOTREACHED */
}

The MC68020 assembly code of the C function strcspn on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2578 <strcspn>:       linkw fp,#0
0x257c <strcspn+4>:     moveml d2-d3,sp@-
0x2580 <strcspn+8>:     movel fp@(8),d0
0x2584 <strcspn+12>:    movel fp@(12),d3
0x2588 <strcspn+16>:    moveal d0,a1
0x258a <strcspn+18>:    movel d0,d2
0x258c <strcspn+20>:    addql #1,d2
0x258e <strcspn+22>:    moveb a1@+,d1
0x2590 <strcspn+24>:    moveal d3,a0
0x2592 <strcspn+26>:    moveb a0@+,d0
0x2594 <strcspn+28>:    cmpb d0,d1
0x2596 <strcspn+30>:    beq 0x259e <strcspn+38>
0x2598 <strcspn+32>:    tstb d0
0x259a <strcspn+34>:    bne 0x2592 <strcspn+26>
0x259c <strcspn+36>:    bra 0x258e <strcspn+22>
0x259e <strcspn+38>:    movel a1,d0
0x25a0 <strcspn+40>:    subl d2,d0
0x25a2 <strcspn+42>:    moveml fp@(-8),d2-d3
0x25a8 <strcspn+48>:    unlk fp
0x25aa <strcspn+50>:    rts

The machine code of the above program is:

<strcspn>:     0x4e56  0x0000  0x48e7  0x3000  0x202e  0x0008  0x262e  0x000c
<strcspn+16>:  0x2240  0x2400  0x5282  0x1219  0x2043  0x1018  0xb200  0x6706
<strcspn+32>:  0x4a00  0x66f6  0x60f0  0x2009  0x9082  0x4cee  0x000c  0xfff8
<strcspn+48>:  0x4e5e  0x4e75

'(78      86      0       0       72      231     48      0
  32      46      0       8       38      46      0       12
  34      64      36      0       82      130     18      25
  32      67      16      24      178     0       103     6
  74      0       102     246     96      240     32      9
  144     130     76      238     0       12      255     248
  78      94      78      117)
|#

; in the logic, the above program is defined by (strcspn-code).
(defn strcspn-code ()
  '(78      86      0       0       72      231     48      0
    32      46      0       8       38      46      0       12
    34      64      36      0       82      130     18      25
    32      67      16      24      178     0       103     6
    74      0       102     246     96      240     32      9
    144     130     76      238     0       12      255     248
    78      94      78      117))

; the computatin time of the program.
(defn strcspn-t0 (i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal (get-nth i2 lst2) ch)
	  8
	(if (equal (get-nth i2 lst2) 0)
	    6
	  (splus 5 (strcspn-t0 (add1 i2) n2 lst2 ch))))
    0)
  ((lessp (difference n2 i2))))

(defn strcspn-t1 (n2 lst2 ch)
  (splus 2 (strcspn-t0 0 n2 lst2 ch)))

(defn strcspn-t2 (i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
	  (strcspn-t1 n2 lst2 (get-nth i1 lst1))
	(splus (strcspn-t1 n2 lst2 (get-nth i1 lst1))
	       (strcspn-t2 (add1 i1) n1 lst1 n2 lst2)))
    0)
  ((lessp (difference n1 i1))))

(defn strcspn-t (n1 lst1 n2 lst2)
  (splus 7 (strcspn-t2 0 n1 lst1 n2 lst2)))

; two induction hints.
(defn strcspn-induct0 (s i2* i2 n2 lst2 ch)
  (if (lessp i2 n2)
      (if (equal (get-nth i2 lst2) ch)
	  t
	(if (equal (get-nth i2 lst2) 0)
	    t
	  (strcspn-induct0 (stepn s 5) (add 32 i2* 1) (add1 i2) n2 lst2 ch)))
    t)
  ((lessp (difference n2 i2))))

(defn strcspn-induct1 (s i1* i1 n1 lst1 n2 lst2)
  (if (lessp i1 n1)
      (if (strchr 0 n2 lst2 (get-nth i1 lst1))
	  t
	(strcspn-induct1 (stepn s (strcspn-t1 n2 lst2 (get-nth i1 lst1)))
			 (add 32 i1* 1) (add1 i1) n1 lst1 n2 lst2))
    t)
  ((lessp (difference n1 i1))))      

; the preconditions of the initial state.
(defn strcspn-statep (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 52)
       (mcode-addrp (mc-pc s) (mc-mem s) (strcspn-code))
       (ram-addrp (sub 32 12 (read-sp s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 12 (read-sp s)) 24 str1 n1)
       (disjoint (sub 32 12 (read-sp s)) 24 str2 n2)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (lessp (slen 0 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)
       (uint-rangep n2 32)))

; an intermediate state s0.
(defn strcspn-s0p (s i1* i1 str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 22 (mc-pc s)) (mc-mem s) 52)
       (mcode-addrp (sub 32 22 (mc-pc s)) (mc-mem s) (strcspn-code))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 8 (read-an 32 6 s)) 24 str1 n1)
       (disjoint (sub 32 8 (read-an 32 6 s)) 24 str2 n2)
       (equal* (read-an 32 1 s) (add 32 str1 i1*))
       (equal str2 (read-dn 32 3 s))
       (equal (read-dn 32 2 s) (add 32 str1 1))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (lessp (slen i1 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (numberp n1)
       (numberp n2)
       (uint-rangep n1 32)
       (uint-rangep n2 32)))

; an intermediate state s1.
(defn strcspn-s1-1p (s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 26 (mc-pc s)) (mc-mem s) 52)
       (mcode-addrp (sub 32 26 (mc-pc s)) (mc-mem s) (strcspn-code))
       (ram-addrp (sub 32 8 (read-an 32 6 s)) (mc-mem s) 24)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 8 (read-an 32 6 s)) 24 str2 n2)
       (equal* (read-an 32 1 s) (add 32 str1 i1*))
       (equal* (read-an 32 0 s) (add 32 str2 i2*))
       (equal str2 (read-dn 32 3 s))
       (equal ch (uread-dn 8 1 s))
       (equal (read-dn 32 2 s) (add 32 str1 1))
       (numberp i1*)
       (nat-rangep i1* 32)
       (equal i1 (nat-to-uint i1*))
       (numberp i2*)
       (nat-rangep i2* 32)
       (equal i2 (nat-to-uint i2*))
       (lessp (slen 0 n2 lst2) n2)
       (lessp (slen i2 n2 lst2) n2)
       (numberp n2)
       (uint-rangep n2 32)))

(defn strcspn-s1p (s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
  (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (disjoint (sub 32 8 (read-an 32 6 s)) 24 str1 n1)
       (lessp (slen i1 n1 lst1) n1)
       (numberp n1)
       (uint-rangep n1 32)))

; from the initial state s to s0: s --> s0.
(prove-lemma strcspn-s-s0 ()
     (implies (strcspn-statep s str1 n1 lst1 str2 n2 lst2)
              (strcspn-s0p (stepn s 7) 0 0 str1 n1 lst1 str2 n2 lst2)))

(prove-lemma strcspn-s-s0-else (rewrite)
     (implies (strcspn-statep s str1 n1 lst1 str2 n2 lst2)
              (and (equal (linked-rts-addr (stepn s 7)) (rts-addr s))
                   (equal (linked-a6 (stepn s 7)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
                          (sub 32 4 (read-sp s)))
		   (equal (movem-saved (stepn s 7) 4 8 2)
                          (readm-rn 32 '(2 3) (mc-rfile s))))))

(prove-lemma strcspn-s-s0-rfile (rewrite)
     (implies (and (strcspn-statep s str1 n1 lst1 str2 n2 lst2)
		   (d4-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strcspn-s-s0-mem (rewrite)
     (implies (and (strcspn-statep s str1 n1 lst1 str2 n2 lst2)
		   (disjoint x k (sub 32 12 (read-sp s)) 24))
	      (equal (read-mem x (mc-mem (stepn s 7)) k)
		     (read-mem x (mc-mem s) k))))

; loop 0.
; from s0 to s1: s0 --> s1.
(prove-lemma strcspn-s0-s1-1 ()
     (implies (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
	      (strcspn-s1-1p (stepn s 2) (add 32 i1* 1) (add1 i1) str1
			     n1 lst1 0 0 str2 n2 lst2 (get-nth i1 lst1))))

(prove-lemma strchr-la ()
     (implies (and (lessp (slen i2 n2 lst2) n2)
		   (not (strchr i2 n2 lst2 ch)))
	      (not (equal ch 0)))
     ((enable slen)))

(prove-lemma strcspn-s0-s1 ()
     (implies (and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		   (not (strchr 0 n2 lst2 (get-nth i1 lst1))))
	      (strcspn-s1p (stepn s 2) (add 32 i1* 1) (add1 i1) str1
			   n1 lst1 0 0 str2 n2 lst2 (get-nth i1 lst1)))
     ((use (strchr-la (i2 0) (ch (get-nth i1 lst1))))))
	      
(prove-lemma strcspn-s0-s1-else (rewrite)
     (let ((s1 (stepn s 2)))
       (implies (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		(and (equal (read-rn 32 14 (mc-rfile s1))
			    (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 s1) (linked-a6 s))
		   (equal (linked-rts-addr s1) (linked-rts-addr s))
		   (equal (movem-saved s1 4 8 2) (movem-saved s 4 8 2))
		   (equal (read-mem x (mc-mem s1) k)
			  (read-mem x (mc-mem s) k))))))

(prove-lemma strcspn-s0-s1-rfile (rewrite)
     (implies (and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		   (d4-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 2)))
		     (read-rn oplen rn (mc-rfile s)))))

; loop 1.
; base case 1. from s1 to exit: s1 --> sn, when lst1[i] = lst2[j].
(prove-lemma strcspn-s1-sn-base (rewrite)
     (implies (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (equal (get-nth i2 lst2) ch))
	      (and (equal (mc-status (stepn s 8)) 'running)
		   (equal (mc-pc (stepn s 8)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 8)) (sub 32 1 i1*))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 8)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 8)) k)
			  (read-mem x (mc-mem s) k)))))			  

(prove-lemma strcspn-s1-sn-rfile-base (rewrite)
     (implies (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (equal (get-nth i2 lst2) ch)
		   (leq oplen 32)
		   (d2-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (if (d4-7a2-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))

; base case 2.  s1 --> s0, when lst1[i] =\= lst2[j] and lst2[j] = 0.
(prove-lemma strcspn-s1-s0-base (rewrite)
     (implies (and (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (not (equal (get-nth i2 lst2) ch))
		   (equal (get-nth i2 lst2) 0))
	      (and (strcspn-s0p (stepn s 6) i1* i1 str1 n1 lst1 str2 n2 lst2)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 6)))
                          (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 6)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 6)) 
			  (linked-rts-addr s))
		   (equal (movem-saved (stepn s 6) 4 8 2)
                          (movem-saved s 4 8 2))
		   (equal (read-mem x (mc-mem (stepn s 6)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strcspn-s1-s0-rfile-base (rewrite)
     (implies (and (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (not (equal (get-nth i2 lst2) ch))
                   (equal (get-nth i2 lst2) 0)
		   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 6)))
                     (read-rn oplen rn (mc-rfile s)))))

; induction case. s1 --> s1, when lst1[i] =\= lst2[j] and lst2[j] =\= 0.
(prove-lemma strcspn-s1-s1-1 (rewrite)
     (implies (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (not (equal (get-nth i2 lst2) ch))
		   (not (equal (get-nth i2 lst2) 0)))
	      (and (strcspn-s1-1p (stepn s 5) i1* i1 str1 n1 lst1 
				  (add 32 i2* 1) (add1 i2) str2 n2 lst2 ch)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 5)))
                          (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 5)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 5)) 
			  (linked-rts-addr s))
		   (equal (movem-saved (stepn s 5) 4 8 2)
                          (movem-saved s 4 8 2))
		   (equal (read-mem x (mc-mem (stepn s 5)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strcspn-s1-s1 (rewrite)
     (implies (and (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		   (not (equal (get-nth i2 lst2) ch))
		   (not (equal (get-nth i2 lst2) 0)))
	      (strcspn-s1p (stepn s 5) i1* i1 str1 n1 lst1 
			   (add 32 i2* 1) (add1 i2) str2 n2 lst2 ch)))

(prove-lemma strcspn-s1-s1-rfile (rewrite)
     (implies (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
                   (not (equal (get-nth i2 lst2) ch))
                   (not (equal (get-nth i2 lst2) 0))
                   (d4-7a2-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 5)))
                     (read-rn oplen rn (mc-rfile s)))))

; put together.
; case 1. s1 --> exit, when (strchr i2 n2 lst2 ch).
(prove-lemma strcspn-s1-1p-info (rewrite)
     (implies (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
	      (equal (lessp i2 n2) t)))

(prove-lemma strcspn-s1-sn (rewrite)
     (let ((sn (stepn s (strcspn-t0 i2 n2 lst2 ch))))
       (implies 
	(and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
	     (strchr i2 n2 lst2 ch))
	(and (equal (mc-status sn) 'running)
	     (equal (mc-pc sn) (linked-rts-addr s))
	     (equal (read-dn 32 0 sn) (sub 32 1 i1*))
	     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
	     (equal (read-rn 32 15 (mc-rfile sn)) (add 32 (read-an 32 6 s) 8))
	     (equal (read-mem x (mc-mem sn) k) (read-mem x (mc-mem s) k)))))
     ((induct (strcspn-induct0 s i2* i2 n2 lst2 ch))
      (disable strcspn-s1-1p read-dn)))

(prove-lemma strcspn-s1-sn-rfile (rewrite)
     (implies
      (and (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
	   (strchr i2 n2 lst2 ch)
           (d2-7a2-5p rn)
           (leq oplen 32))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strcspn-t0 i2 n2 lst2 ch))))
             (if (d4-7a2-5p rn)
                 (read-rn oplen rn (mc-rfile s))
               (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2)))))
     ((induct (strcspn-induct0 s i2* i2 n2 lst2 ch))
      (disable strcspn-s1-1p)))

; case 2. s1 --> s0, when (not (strchr i2 n2 lst2 ch)).
(prove-lemma strcspn-s1p-s1-1p ()
     (implies (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
	      (strcspn-s1-1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)))

(prove-lemma strcspn-s1-s0 (rewrite)
     (let ((s0 (stepn s (strcspn-t0 i2 n2 lst2 ch))))
       (implies (and (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
		     (not (strchr i2 n2 lst2 ch)))
		(and (strcspn-s0p s0 i1* i1 str1 n1 lst1 str2 n2 lst2)
		     (equal (read-rn 32 14 (mc-rfile s0))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s0) (linked-a6 s))
		     (equal (linked-rts-addr s0) (linked-rts-addr s))
		     (equal (movem-saved s0 4 8 2)
			    (movem-saved s 4 8 2))
		     (equal (read-mem x (mc-mem s0) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strcspn-induct0 s i2* i2 n2 lst2 ch))
      (use (strcspn-s1p-s1-1p))
      (disable strcspn-s0p strcspn-s1p strcspn-s1-1p movem-saved linked-a6
	       linked-rts-addr)))

(disable strcspn-s1-1p-info)

(prove-lemma strcspn-s1-s0-rfile (rewrite)
     (implies 
      (and (strcspn-s1p s i1* i1 str1 n1 lst1 i2* i2 str2 n2 lst2 ch)
	   (not (strchr i2 n2 lst2 ch))
	   (d4-7a2-5p rn))
      (equal (read-rn oplen rn (mc-rfile (stepn s (strcspn-t0 i2 n2 lst2 ch))))
	     (read-rn oplen rn (mc-rfile s))))
     ((induct (strcspn-induct0 s i2* i2 n2 lst2 ch))
      (use (strcspn-s1p-s1-1p))
      (disable strcspn-s1p strcspn-s1-1p)))

; from s0 --> exit. s0 --> sn.
; base case:  s0 --> sn, when (strchr i2 n2 lst2 ch).
(prove-lemma strcspn-s0-sn-base (rewrite)
     (let ((sn (stepn s (strcspn-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		     (strchr 0 n2 lst2 (get-nth i1 lst1)))
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) (head i1* 32))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((use (strcspn-s0-s1-1))
      (disable strcspn-s0p strcspn-s1-1p strchr strcspn-t0 read-dn)))

(prove-lemma strcspn-s0-sn-rfile-base (rewrite)
     (let ((ch (get-nth i1 lst1)))
       (implies 
	(and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
	     (strchr 0 n2 lst2 ch)
	     (leq oplen 32)
	     (d2-7a2-5p rn))
	(equal (read-rn oplen rn (mc-rfile (stepn s (strcspn-t1 n2 lst2 ch))))
	       (if (d4-7a2-5p rn)
		   (read-rn oplen rn (mc-rfile s))
		 (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2))))))
     ((use (strcspn-s0-s1-1))
      (disable strcspn-s0p strcspn-s1-1p strchr strcspn-t0)))

; induction case: s0 --> s0, when (not (strchr i2 n2 lst2 ch)).
(prove-lemma strcspn-s0-s0 (rewrite)
     (let ((s0 (stepn s (strcspn-t1 n2 lst2 (get-nth i1 lst1)))))
       (implies (and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		     (not (strchr 0 n2 lst2 (get-nth i1 lst1))))
		(and (strcspn-s0p s0 (add 32 i1* 1) (add1 i1) str1 n1 lst1 
				  str2 n2 lst2)
		     (equal (read-rn 32 14 (mc-rfile s0))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-a6 s0) (linked-a6 s))
		     (equal (linked-rts-addr s0) (linked-rts-addr s))
		     (equal (movem-saved s0 4 8 2)
			    (movem-saved s 4 8 2))
		     (equal (read-mem x (mc-mem s0) k)
			    (read-mem x (mc-mem s) k)))))
       ((use (strcspn-s0-s1))
	(disable strcspn-s0p strcspn-s1p strcspn-t0 strchr)))

(prove-lemma strcspn-s0-s0-rfile (rewrite)
     (let ((ch (get-nth i1 lst1)))
       (implies 
	(and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
	     (not (strchr 0 n2 lst2 ch))
	     (d4-7a2-5p rn))
	(equal (read-rn oplen rn (mc-rfile (stepn s (strcspn-t1 n2 lst2 ch))))
	       (read-rn oplen rn (mc-rfile s)))))
     ((use (strcspn-s0-s1))
      (disable strcspn-s0p strcspn-s1p strcspn-t0 strchr)))

; put together: s0 --> sn.
(prove-lemma strcspn-s0p-info (rewrite)
     (implies (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
	      (and (equal (lessp i1 n1) t)
		   (equal (nat-to-uint (head i1* 32)) (fix i1)))))

(prove-lemma strcspn-s0-sn (rewrite)
     (let ((sn (stepn s (strcspn-t2 i1 n1 lst1 n2 lst2))))
       (implies (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (uread-dn 32 0 sn)
			    (strcspn i1 n1 lst1 n2 lst2))
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strcspn-induct1 s i1* i1 n1 lst1 n2 lst2))
      (disable strcspn-s0p strchr strcspn-t1 read-dn)))

(prove-lemma strcspn-s0-sn-rfile (rewrite)
     (implies
      (and (strcspn-s0p s i1* i1 str1 n1 lst1 str2 n2 lst2)
           (d2-7a2-5p rn)
           (leq oplen 32))
      (equal (read-rn oplen rn 
		      (mc-rfile (stepn s (strcspn-t2 i1 n1 lst1 n2 lst2))))
             (if (d4-7a2-5p rn)
                 (read-rn oplen rn (mc-rfile s))
               (get-vlst oplen 0 rn '(2 3) (movem-saved s 4 8 2)))))
     ((induct (strcspn-induct1 s i1* i1 n1 lst1 n2 lst2))
      (disable strcspn-s0p strchr strcspn-t1)))

(disable strcspn-s0p-info)

; now, finally, the correctness of strcspn.
(prove-lemma strcspn-correctness (rewrite)
     (let ((sn (stepn s (strcspn-t n1 lst1 n2 lst2))))
       (implies (strcspn-statep s str1 n1 lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 7 s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 12 (read-sp s)) 24)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (uread-dn 32 0 sn) (strcspn 0 n1 lst1 n2 lst2)))))
     ((use (strcspn-s-s0))
      (disable strcspn-statep strcspn-s0p linked-rts-addr linked-a6 uread-dn)))

(disable strcspn-t)

; some properties of strcspn.
; see file cstring.events.