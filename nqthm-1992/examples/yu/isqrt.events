#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

;          Proof of the Correctness of the ISQRT Program
;
(note-lib "mc20-2" t)
#|
The following C function ISQRT computes the integer square root of a given 
nonnegative integer i.

/* computes the integer square root of a given nonnegative integer */
isqrt(int i)
{
  int j;

  j = (i / 2);
  while ((i / j) < j) 
    j = (j + (i / j)) / 2;
  return (j);
}

Here is the MC68020 assembly code of the above ISQRT program.  The code is
generated by "gcc -O".

The program expects an nonnegative integer input which is on the sp
stack at address (sp)+4.  The local variable j is assigned to d2.  The
program exits with the answer in register d0 and the program counter
equals the return address saved on the sp stack at address (sp).

0x2318 <isqrt>: 	linkw a6,#0
0x231c <isqrt+4>:	movel d2,sp@-
0x231e <isqrt+6>:	movel a6@(8),d1
0x2322 <isqrt+10>:	movel d1,d2
0x2324 <isqrt+12>:	bra 0x232e <isqrt+22>
0x2326 <isqrt+14>:	movel d2,d0
0x2328 <isqrt+16>:	divsll d1,d0,d0
0x232c <isqrt+20>:	addl d0,d1
0x232e <isqrt+22>:	tstl d1
0x2330 <isqrt+24>:	bge 0x2334 <isqrt+28>
0x2332 <isqrt+26>:	addql #1,d1
0x2334 <isqrt+28>:	asrl #1,d1
0x2336 <isqrt+30>:	movel d2,d0
0x2338 <isqrt+32>:	divsll d1,d0,d0
0x233c <isqrt+36>:	cmpl d0,d1
0x233e <isqrt+38>:	bgt 0x2326 <isqrt+14>
0x2340 <isqrt+40>:	movel d1,d0
0x2342 <isqrt+42>:	movel a6@(-4),d2
0x2346 <isqrt+46>:	unlk a6
0x2348 <isqrt+48>:	rts

The machine code of the above program is:

<isqrt>:	0x4e56	0x0000	0x2f02	0x222e	0x0008	0x2401	0x6008	0x2002
<isqrt+16>:	0x4c41	0x0800	0xd280	0x4a81	0x6c02	0x5281	0xe281	0x2002
<isqrt+32>:	0x4c41	0x0800	0xb280	0x6ee6	0x2001	0x242e	0xfffc	0x4e5e
<isqrt+48>:	0x4e75

In the logic, it is going to be a list like:

'(78      86      0       0       47      2       34      46
  0       8       36      1       96      8       32      2
  76      65      8       0       210     128     74      129
  108     2       82      129     226     129     32      2
  76      65      8       0       178     128     110     230
  32      1       36      46      255     252     78      94
  78      117)
|#

; in the logic, the program is defined by (isqrt-code).	     
(defn isqrt-code ()
  '(78      86      0       0       47      2       34      46
    0       8       36      1       96      8       32      2
    76      65      8       0       210     128     74      129
    108     2       82      129     226     129     32      2
    76      65      8       0       178     128     110     230
    32      1       36      46      255     252     78      94
    78      117))

(prove-lemma mean-lessp-1 (rewrite)
     (equal (lessp (quotient (plus b a) 2) b)
	    (lessp a b))
     ((disable quotient-times-lessp)))

; isqrt1 is a function in the Logic simulating the loop of the above code.
(defn isqrt1 (i j)
  (if (zerop j)
      (fix i)
    (if (lessp (quotient i j) j)
	(isqrt1 i (quotient (plus j (quotient i j)) 2))
      (fix j))))

; isqrt is a function in the Logic simulating the above code.
(defn isqrt (i)
  (isqrt1 i (quotient i 2)))

; the computation time of the loop.
(defn isqrt1-t (i j)
  (if (zerop j)
      0
    (if (lessp (quotient i j) j)
	(splus 10 (isqrt1-t i (quotient (plus j (quotient i j)) 2)))
      8)))

(defn isqrt-t (i)
  (splus 8 (isqrt1-t i (quotient i 2))))

(enable iplus)
(enable integerp)
(enable iquotient)
(enable ilessp)

(disable remainder)
(disable quotient)

(prove-lemma isqrt-no-overflow (rewrite)
      (implies (and (int-rangep (times 2 j) n)
		    (lessp (quotient i j) j))
	       (int-rangep (plus j (quotient i j)) n)))

(prove-lemma j-nonzerop (rewrite)
     (implies (and (lessp 1 i)
		   (lessp 0 j))
	      (not (equal (quotient (plus j (quotient i j)) 2) 0))))

(prove-lemma j-int-rangep (rewrite)
     (implies (and (int-rangep (times 2 j) n)
		   (lessp (quotient i j) j))
	      (int-rangep (times 2 (quotient (plus j (quotient i j)) 2))
			  n)))

; an induction hint.
(defn isqrt-induct (s i j)
  (if (zerop j)
      t
    (if (lessp (quotient i j) j)
	(isqrt-induct (stepn s 10) i (quotient (plus j (quotient i j)) 2))
      t)))

(defn isqrt-statep (s i)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (mc-pc s) (mc-mem s) 50)
       (mcode-addrp (mc-pc s) (mc-mem s) (isqrt-code))
       (ram-addrp (sub 32 8 (read-sp s)) (mc-mem s) 16)
       (equal i (iread-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (ilessp 1 i)))

(defn isqrt-s0p (s i j)
  (and (equal (mc-status s) 'running)
       (evenp (mc-pc s))
       (rom-addrp (sub 32 30 (mc-pc s)) (mc-mem s) 50)
       (mcode-addrp (sub 32 30 (mc-pc s)) (mc-mem s) (isqrt-code))
       (ram-addrp (sub 32 4 (read-an 32 6 s)) (mc-mem s) 16)
       (equal i (iread-dn 32 2 s))
       (equal j (iread-dn 32 1 s))
       (int-rangep (times 2 j) 32)
       (ilessp 1 i)
       (ilessp 0 j)))

; from the initial state to s0.
(prove-lemma initial-j-int-rangep (rewrite)
     (implies (int-rangep i n)
	      (int-rangep (times 2 (quotient i 2)) n))
     ((enable int-rangep)))

(prove-lemma isqrt-s-s0 (rewrite)
     (implies (isqrt-statep s i)
	      (and (isqrt-s0p (stepn s 8) i (quotient i 2))
		   (equal (linked-rts-addr (stepn s 8))
			  (rts-addr s))
		   (equal (linked-a6 (stepn s 8))
			  (read-an 32 6 s))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (sub 32 4 (read-sp s)))
		   (equal (rn-saved (stepn s 8))
			  (read-dn 32 2 s)))))

(prove-lemma isqrt-s-s0-rfile (rewrite)
     (implies (and (isqrt-statep s i)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma isqrt-s-s0-mem (rewrite)
     (implies (and (isqrt-statep s i)
		   (disjoint x k (sub 32 8 (read-sp s)) 16))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s0 (induction csae), or from s0 to exit (base case).
; base case:
; the basics we need to prove: 
;   0. the machine is still running.
;   1. the pc is at the right position.
;   2. d0 contains the local variable j, the computing square root.
;   3. a6 should have the right value.
;   4. sp(a7) should have the right value.
(prove-lemma isqrt-s0-sn (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (not (lessp (quotient i j) j)))
	      (and (equal (mc-status (stepn s 8)) 'running)
		   (equal (mc-pc (stepn s 8)) (linked-rts-addr s))
		   (equal (iread-dn 32 0 (stepn s 8)) j)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 8)))
			  (add 32 (read-an 32 6 s) 8)))))

; 5. d2, which is used by this program, should be restored.
(prove-lemma isqrt-s0-sn-d2 (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (not (lessp (quotient i j) j))
		   (leq oplen 32))
	      (equal (read-rn oplen 2 (mc-rfile (stepn s 8)))
		     (head (rn-saved s) oplen))))

; and 6. those registers untouched by this program should still
; have their original contents.
(prove-lemma isqrt-s0-sn-rfile (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (not (lessp (quotient i j) j))
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (read-rn oplen rn (mc-rfile s)))))
		      
; and 7. the memory is correctly changed.
(prove-lemma isqrt1-s0-sn-mem (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (not (lessp (quotient i j) j)))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

(prove-lemma isqrt-s0p-j_nonzerop (rewrite)
     (implies (isqrt-s0p s i j)
	      (and (not (equal j 0))
		   (numberp j))))

; induction case: s0 --> s0.
; we need to prove:
;  0. the state predicate at s0 is still satisfied.
;  1. a6 is unchanged.
;  2. the content of original a6 on the sp stack is not changed.
;  3. the return address on the sp atack is not changed.
;  4. the content of original d2 on the sp stack is not changed.
(prove-lemma isqrt-s0-s0 (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (lessp (quotient i j) j))
	      (and (isqrt-s0p (stepn s 10) 
			      i 
			      (quotient (plus j (quotient i j)) 2))
		   (equal (read-rn oplen 14 (mc-rfile (stepn s 10)))
			  (read-rn oplen 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 10)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 10)) 
			  (linked-rts-addr s))
		   (equal (rn-saved (stepn s 10))
			  (rn-saved s))))
     ((disable quotient-equal-0 quotient-times-lessp)))

; and 5. the registers that are not modified by this program still have
; their previous values.
(prove-lemma isqrt-s0-s0-rfile (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (lessp (quotient i j) j)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 10)))
		     (read-rn oplen rn (mc-rfile s)))))
		      
; and 6. the memory is correctly changed.
(prove-lemma isqrt-s0-s0-mem (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (lessp (quotient i j) j))
	      (equal (read-mem x (mc-mem (stepn s 10)) k)
		     (read-mem x (mc-mem s) k))))

(disable isqrt-statep)
(disable isqrt-s0p)

(prove-lemma isqrt1-correctness (rewrite)
    (implies (isqrt-s0p s i j)
	     (and (equal (mc-status (stepn s (isqrt1-t i j))) 'running)
		  (equal (mc-pc (stepn s (isqrt1-t i j))) 
			 (linked-rts-addr s))
		  (equal (iread-dn 32 0 (stepn s (isqrt1-t i j)))
			 (isqrt1 i j))
		  (equal (read-rn 32 14 (mc-rfile (stepn s (isqrt1-t i j))))
			 (linked-a6 s))
		  (equal (read-rn 32 15 (mc-rfile (stepn s (isqrt1-t i j))))
			 (add 32 (read-an 32 6 s) 8))
		  (equal (read-mem x (mc-mem (stepn s (isqrt1-t i j))) k)
			 (read-mem x (mc-mem s) k))))
    ((induct (isqrt-induct s i j))
     (disable quotient-times-lessp linked-rts-addr linked-a6)))

(prove-lemma isqrt1-d2 (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (leq oplen 32))
	      (equal (read-rn oplen 2 (mc-rfile (stepn s (isqrt1-t i j))))
		     (head (rn-saved s) oplen)))
     ((induct (isqrt-induct s i j))
      (disable rn-saved)))

(prove-lemma isqrt1-rfile (rewrite)
     (implies (and (isqrt-s0p s i j)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (isqrt1-t i j))))
		     (read-rn oplen rn (mc-rfile s))))
     ((induct (isqrt-induct s i j))))

; after an execution of this program,  the machine state satisfies:
;  0. normal exit.
;  1. the pc is returned to the next instruction of the caller.
;  2. the result -- ISQRT(i), is stored in D0.
;  3. a6, used by LINK, is restored to its original content.
;  4. the stack pointer sp(a7) is updated correctly to pop off one frame.
(prove-lemma isqrt-correctness (rewrite)
     (implies (isqrt-statep s i)
	      (and (equal (mc-status (stepn s (isqrt-t i))) 'running)
		   (equal (mc-pc (stepn s (isqrt-t i)))
			  (rts-addr s))
		   (equal (iread-dn 32 0 (stepn s (isqrt-t i)))
			  (isqrt i))
		   (equal (read-an 32 6 (stepn s (isqrt-t i)))
			  (read-an 32 6 s))
		   (equal (read-an 32 7 (stepn s (isqrt-t i)))
			  (add 32 (read-an 32 7 s) 4))))
     ((disable rts-addr linked-rts-addr linked-a6)))

;  5. d2, used for local variable j, is restored to its original value.
(prove-lemma isqrt-d2 (rewrite)
     (implies (and (isqrt-statep s i)
		   (leq oplen 32))
	      (equal (read-rn oplen 2 (mc-rfile (stepn s (isqrt-t i))))
		     (read-dn oplen 2 s)))
     ((disable rn-saved)))
	      
; and 6. the registers that are not modified by this program still have
; their original values.
(prove-lemma isqrt-rfile (rewrite)
     (implies (and (isqrt-statep s i)
		   (d3-7a2-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s (isqrt-t i))))
		     (read-rn oplen rn (mc-rfile s)))))

; and 7. the memory is correctly changed.  i.e. specify clearly the portions
; of the memory were changed and prove that is a truth.
(prove-lemma isqrt-read-mem (rewrite)
     (implies (and (isqrt-statep s i)
		   (disjoint x k (sub 32 8 (read-sp s)) 16))
	      (equal (read-mem x (mc-mem (stepn s (isqrt-t i))) k)
		     (read-mem x (mc-mem s) k))))

(disable isqrt-t)

#|
; we next need to prove that isqrt does compute the integer square root.
; the following is the same as the proof in the file isqrt-ada.events.
(defn sq (j)
  (times j j))

(prove-lemma isqrt1-lower-bound (rewrite)
     (implies (not (zerop j))
	      (not (lessp i (sq (isqrt1 i j))))))

(prove-lemma quotient-by-2 (rewrite)
     (not (lessp (plus (quotient x 2) (quotient x 2))
		 (sub1 x))))

(prove-lemma main-trick (rewrite)
     (not (lessp (sq (add1 (quotient (plus j k) 2)))
		 (plus (times j k) j)))
     ((induct (difference j k))))

(prove-lemma sq-add1-non-zero (rewrite)
     (not (equal (sq (add1 x)) 0)))

(prove-lemma main (rewrite)
     (implies (not (zerop j))
	      (lessp i 
		     (sq (add1 (quotient (plus j (quotient i j)) 2)))))
     ((disable sq)))

(prove-lemma isqrt1-upper-bound (rewrite)
     (implies (lessp i (sq (add1 j)))
	      (lessp i (sq (add1 (isqrt1 i j)))))
     ((disable sq)))

(prove-lemma isqrt->isqrt1 (rewrite)
   (implies (lessp 1 i)
	    (lessp i (sq (add1 (quotient i 2))))))

; (isqrt i) is the square root of i:  (isqrt i)^2 <= i < [(isqrt i)+1]^2.
(prove-lemma isqrt-logic-correctness ()
     (implies (lessp 1 i)
	      (and (lessp i (sq (add1 (isqrt i))))
		   (not (lessp i (sq (isqrt i))))))
     ((disable sq isqrt1)))

|#
