#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

#|\
%---------------------------------------------------------------------------
% Date:      Jan, 1991
% File:      mc20-1.events
% Last modified on Mon Jan 18 15:50:27 PST 1993 by yuanyu
%---------------------------------------------------------------------------
%
% Although this is an event file suitable for running through Nqthm, it
% also can be used to produce a technical report in Latex.  The peculiar
% use of ! below is an instruction to the infix preprocessor to replace certain
% Nqthm forms with their infix equivalent. 
\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\begin{center}
\Large
\vspace*{2in}
A Formal Specification of\\
Some User Mode Instructions for the \\
Motorola 68020\\[.25in]

{\em Robert S. Boyer {\em and} Yuan Yu}\\[.25in]

\large
Technical Report  \\
Computer Sciences Department \\
University of Texas at Austin\\
Austin, Texas 78712\\[.25in]

December, 1992\\[.25in]
\end{center}
\newpage
\tableofcontents

\newpage
\pagenumbering{arabic}

\begin{center}
\Large

A Formal Specification of\\
Some User Mode Instructions for the \\
Motorola 68020{\normalsize \footnotemark} \\[.25in]

{\em Robert S. Boyer {\em and} Yuan Yu}\\[.25in]

\large
Computer Sciences and Mathematics Departments \\
University of Texas at Austin\\
Austin, Texas 78712\\[.25in]

December, 1992\\[.25in]

\normalsize
telephone: (512) 471-9745\\
email: boyer@cs.utexas.edu or yuan@cs.utexas.edu\\[.25in]
Technical Report  TR-92-04 (rev. 2.3 - dissertation version)\\
\end{center}

\footnotetext{The work described here was supported in part by
NSF Grant MIP-9017499.}

\vspace{.10in}
\noindent {\bf Abstract.}
We present a formal specification of approximately 80\% of the `user
mode' instructions of the Motorola MC68020 microprocessor.  The
specification is given in the form of definitions in the logic of
Nqthm, the Boyer-Moore system.  The definitions are displayed in a
conventional mathematical syntax.  The specification has been used in
the mechanical verification of several dozen machine code programs,
whose binary was generated by `industrial strength' C and Ada
compilers.

\section{Introduction}

This report contains a formal specification of
approximately 80\% of the `user mode' instructions of the Motorola MC68020
microprocessor.  An earlier report \cite{Boyer-Yu-91} describes how we have
used this specification to prove mechanically the correctness of several dozen
machine code programs, most of them generated by `industrial strength'
compilers for C or Ada.  Our specification is based upon the user's manual
for the MC68020 \cite{m20}.

The function definitions below are ordered so that a function is defined before
it is referenced by another function.  One of the very last functions defined,
!qstepn, p.~\pageref{stepn}, emulates the MC68020.  Like all the functions in
this specification, !qstepn is a recursive and hence computable function.
Approximately speaking, if we are given an MC68020 state !ts and a positive
integer !tn, we can compute the state {\em s'} that results from executing an
MC68020 for !tn instructions, starting in state !ts, by applying !qstepn to !ts
and !tn.  If an illegal instruction or an instruction not among those covered
in this specification is encountered during execution, then {\em s'} will
exhibit an indication of the error.  If no such error indication is exhibited,
then the returned state correctly represents the state that a `real' MC68020
would have after running !tn instructions provided that (i) the caches are
initially consistent with memory, (ii) no interrupts happen during execution,
and, of course, (iii) no externally caused changes to the state occur during
execution.  In Section \ref{example} is a theorem that illustrates the use of
!qstepn to emulate an MC68020 on a specific state, one that contains machine
code for Euclid's GCD algorithm.

{\bf Disclaimer}: The development of this formal specification is part of a
small scientific project aimed at examining the feasibility of mechanically
checking the correctness of machine code programs that run on widely-used
microprocessors.  The accuracy with which the specification presented here
represents a `real' MC68020 is something we do not know how to ascertain with
the certainty of a mathematical proof.  One can only become increasingly
confident by such activities as critical reading, testing, and bug fixing.  It
is in a spirit of scientific cooperation that we distribute this specification,
but we distribute it without any warranty of any kind, on an `as is' basis.

The definitions below were written in the logic described in {\em A
Computational Logic Handbook,} \cite{BM-88}, with syntactic extensions
for `let' and `cond'.  The definitions have been admitted under the
definitional principle described in that book, using the mechanical
theorem prover also described in that book.  Although the logic and
prover use the prefix, parenthesized notation of Church's lambda
calculus and McCarthy's Lisp, in this report, we use a notation that
is conventional.  This new syntax is summarized in Section \ref{syntax}.

Our principal purpose in writing this technical report is to
communicate precisely the formal, mathematical definitions of our
specification of the MC68020.  This report is decidedly not a tutorial
on the MC68020 or on our specification of it.  The reader will find it
easier to read this specification after having read
\cite{Boyer-Yu-91}.  The reader will also find it invaluable to have a
copy of \cite{m20} handy.  Readers in search of a less stark
introduction to this specification will find it in the Ph.~D.
dissertation of Yuan Yu.  There also will be found a review of the
related scientific literature.

\section{A Few Basic Functions}

The objects we use in this specification are truth values, integers, ordered
pairs, and symbols.  The precise axioms and notations for these objects and the
built-in functions that operate on these objects may be found in \cite{BM-88}.
Here are a few brief remarks about some of these objects and functions.

\begin{itemize}

\item The constant !qtrue, abbreviated !Tt, is the true truth value.

\item The constant !qfalse, abbreviated !Tf, is the false truth value.

\item !qif is a function of three arguments.  !T(if x y z) returns !Tz if !Tx is
equal to !Tf, and !Ty otherwise.

\item !qcons is a function of two arguments.  !T(cons x y) returns an ordered
pair whose first component is !tx and whose second is !ty.

\item !qcar is a function of one argument.  !T(car x) returns the first component
if !tx is an ordered pair;  otherwise, it returns 0.

\item !qcdr is a function of one argument.  !T(cdr x) returns the second component
if !tx is an ordered pair;  otherwise, it returns 0.

\item !qlist is a function of any number of arguments. !t(list x y z) is !t(cons
x (cons y (cons z nil))).  !tnil is a symbol, and is used to denote the empty
list.

\end{itemize}

Except for !tnil, symbols are printed in a typewriter font, preceded by a single
quotation mark, e.g., !t'running and !t'read_unavailable_memory.

% The instructions we have done: (75)

% ADD, ADDA, ADDI, ADDQ, ADDX, AND, ANDI, ANDI to CCR, ASL, ASR, Bcc,
% BCHG, BCLR, BSET, BTST, BRA, BSR, CLR, CMP, CMPA, CMPI, CMPM, DBcc,
% DIVS, DIVSL, DIVU, DIVUL, EOR, EORI, EORI to CCR, EXG, EXT, EXTB, 
% JMP, JSR, LEA, LINK, LSL, LSR, MOVE, MOVEA, MOVE from CCR, MOVE to CCR, 
% MOVEM, MOVEP, MOVEQ, MULS, MULSL, MULU, MULUL, NEG, NEGX, NOP, NOT, OR, 
% ORI, ORI to CCR, PEA, ROL, ROR, ROXL, ROXR, RTD, RTR, RTS, SCC, SUB, 
% SUBA, SUBI, SUBQ, SUBX, SWAP, TAS, TST, UNLK.
%
% The instructions we have included, but not yet finished: (8)
%
% BFCHG, BFCLR, BFEXTS, BFEXTU, BFFFO, BFINS, BFSET, BFTST.
%
% The instructions we are not going to consider: (21)
%
% ABCD, BKPT, CALLM, CAS and CAS2, CHK, CHK2, CMP2, CPBCC, CPDBcc,
% CPGEN, CPSCC, CPTRAPCC, ILLEGAL, NBCD, PACK, RTM, SBCD, TRAP, TRAPcc,
% TRAPV, UNPK.
%
% The privileged instructions: (13)
%
% ANDI to SR, CPRESTORE, CPSAVE, EORI to SR, MOVE from SR, MOVE to SR,
% MOVE USP, MOVEC, MOVES, ORI to SR, RESET, RTE, STOP.
%
% The final specification will cover 80% of the user available instructions.

\section{Start Up}

|#

(note-lib "mc20-0" t)

#|\

Our initial library {\tt mc20-0} contains (i) the basic axioms and definitions
of Nqthm, which are described in Chapter 4 of \cite{BM-88}, (ii) some proved
arithmetic lemmas that are used to help in the admission of the following
definitions, and (iii) a definition of the nonnegative integer exponentiation
function !qexp, which is defined as: !t(equal (exp x y) (if
(zerop y) 1 (times x (exp x (sub1 y))))).  \index{exp}

\section{Some Constants}

We first define a few constants.

|#

;\ In the MC68020, a ``byte'' is 8 bits long.  A ``word'' is 16 bits long. 
;\ A ``long word'' is 32 bits long.  A ``quad word'' is 64 bits long.

(defn b () 8)
(defn w () 16)
(defn l () 32)
(defn q () 64)

(defn bsz () 1)
(defn wsz () 2)
(defn lsz () 4)
(defn qsz () 8)

;\ Some error signals.
(defn read-signal () 'read_unavailable_memory)

(defn write-signal () 'write_rom_or_unavailable_memory)

(defn reserved-signal () 'motorola_reserved_for_future_development)

(defn pc-signal () 'pc_outside_rom)

(defn pc-odd-signal () 'pc_at_odd_address)

(defn mode-signal () 'illegal_addressing_mode_in_current_instruction)

;\ Throughout our specification, we have frequent need to refer to bits and
;\ bit-vectors.  In our model, bit ::= 0 {\tt |} 1, and bit-vectors ::= nonnegative
;\ integers.  If the operation is signed, we use the two conversion functions
;\ !qnat-to-int and !qint-to-nat.

;\ !qbitp is a function of one argument, !tx.  !qbitp returns !tt or !tf
;\ according to whether !tx is a bit or not.
(defn bitp (x)
  (or (equal x 0) (equal x 1)))

;\ We frequently use the bits 0 and 1.  For clarity, to identify informally
;\ when we are using these integers as bits, we use the two constants !qb1
;\ and !qb0.

(defn b1 () 1)

(defn b0 () 0)

;\ We frequently test a bit to see whether it is 0 or 1.  We define
;\ the functions !qb1p and !qb0p to return !tt or !tf according to whether
;\ their arguments are 0 or non-0 respectively.
(defn b0p (x)
  (equal x (b0)))

(defn b1p (x)
  (not (equal x (b0))))

(defn fix-bit (c)
  (if (b0p c) (b0) (b1)))

;\ Here are the definitions of some operators for logical arithmetic on bits.

;\ !qb-not returns the complement of its argument.
(defn b-not (x)
  (if (b0p x) (b1) (b0)))

;\ !qb-and returns the logical and of its two arguments.
(defn b-and (x y)
  (if (b0p x)
      (b0)
    (if (b0p y) (b0) (b1))))

;\ !qb-or returns the logical or of its two arguments.
(defn b-or (x y)
  (if (b0p x)
      (if (b0p y) (b0) (b1))
    (b1)))

;\ !qb-nor returns the logical nor of its two arguments.
(defn b-nor (x y)
  (if (b0p x)
      (if (b0p y) (b1) (b0))
    (b0)))

;\ !qb-nand returns the logical nand of its two arguments.
(defn b-nand (x y)
  (if (b0p x)
      (b1)
    (if (b0p y) (b1) (b0))))

;\ !qb-eor returns the exclusive or of its two arguments.
(defn b-eor (x y)
  (if (b0p x)
      (if (b0p y) (b0) (b1))
    (if (b0p y) (b1) (b0))))

;\ !qb-equal returns the logical equal of its two arguments.
(defn b-equal (x y)
  (if (b0p x) (b0p y) (b1p y)))

;\ \section{Bit Vector Arithmetic}

;\ !qbcar returns the first bit of !tx.
(defn bcar (x)
  (remainder x 2))

;\ !qbcdr returns a natural number by cutting off the first bit of !tx.
;\ For any natural number !tx, !t(equal (plus (bcar x) (times x (bcdr x))) x).

(defn bcdr (x)
  (quotient x 2))

;\ !qhead is a function of two arguments, !tx and !tn.  !tx and !tn should be
;\ nonnegative integers.  !qhead returns the remainder of !tx divided by
;\ $2^n$.
(defn head (x n)
  (remainder x (exp 2 n)))

;\ !qtail is a function of two arguments, !tx and !tn.  !tx and !tn should be
;\ nonnegative integers.  !qtail returns the quotient of !tx divided by
;\ $2^n$.
(defn tail (x n)
  (quotient x (exp 2 n)))

;\ We next define some logical operations on bit-vectors.  !qlognot takes
;\ two naturals as its arguments and returns the logical complement of its
;\ second argument.
(defn lognot (n x)
  (sub1 (difference (exp 2 n) (head x n))))

;\ !qlogand takes two naturals as arguments and returns their logical and.
(defn logand (x y)
  (if (or (zerop x) (zerop y))
      0
    (plus (b-and (bcar x) (bcar y))
          (times 2 (logand (bcdr x) (bcdr y))))))

;\ !qlogor takes two naturals as arguments and returns the logical
;\ (inclusive) or of the two arguments.
(defn logor (x y)
  (if (zerop x)
      (fix y)
    (if (zerop y)
        (fix x)
      (plus (b-or (bcar x) (bcar y))
            (times 2 (logor (bcdr x) (bcdr y)))))))

;\ !qlogeor takes two naturals as arguments and returns the logical
;\ exclusive or of the two arguments.
(defn logeor (x y)
  (if (and (zerop x) (zerop y))
      0
    (plus (b-eor (bcar x) (bcar y))
          (times 2 (logeor (bcdr x) (bcdr y)))))
  ((lessp (plus x y))))

;\ !qbitn retrieves the nth bit of !tx.  Indexing is 0-based.
(defn bitn (x n)
  (bcar (tail x n)))

;\ !qmbit returns the most significant bit of !tx, assuming that !tx is a 
;\ bit vector of !tn bits.
(defn mbit (x n)
  (bitn x (sub1 n)))

;\ !qbits returns bits !ti through !tj as a natural number.  !qbits is a function
;\ of three arguments, !tx, !ti, and !tj.  !tx, !ti, and !tj should be natural numbers.
;\ Intuitively, bits extracts bits of !tx from bit !ti to bit !tj.  Normally, !ti
;\ should be less than or equal to !tj.
(defn bits (x i j)
  (head (tail x i) (add1 (difference j i))))

;\ !qsetn updates the $n^{\rm th}$ bit of !tx by the given value !tc.  Indexing is 0-based.
(defn setn (x n c)
  (if (zerop n)
      (plus (fix-bit c) (times 2 (bcdr x)))
    (plus (bcar x) (times 2 (setn (bcdr x) (sub1 n) c)))))

;\ !qadder takes four arguments and returns the addition of !tx, !ty, and !tc modulo
;\ $2^n$.  That is, !t (remainder (plus x y c) (exp n 2)).  Typically,  !tc is either 0 or 1.
(defn adder (n c x y)
  (head (plus c x y) n))

;\ !qadd takes three arguments and returns the addition of !tx and !ty modulo
;\ $2^n$.  That is, !t(remainder (plus x y) (exp n 2)).
(defn add (n x y)
  (head (plus x y) n))

;\ !qsubtracter takes four arguments and returns the subtraction of !ty and
;\ !t(remainder (plus x c) (exp n 2)).  That is, !t(remainder (difference y (plus x c)) (exp n 2)).  Typically,  !tc is
;\ either 0 or 1.
(defn subtracter (n c x y)
  (adder n (b-not c) y (lognot n x)))

;\ !qsub takes three arguments and returns, in the form of 2's complement,
;\ the subtraction of y and x.  That is, !t(remainder (difference y  x) (exp n 2)).
(defn sub (n x y)
  (head (plus y (difference (exp 2 n) (head x n)))
        n))

;\ !qapp ``appends'' two naturals.  !qapp takes three arguments, !tn, !tx, and !ty.
(defn app (n x y)
  (plus (head x n)
        (times y (exp 2 n))))

;\ !qreplace replaces !tx partially by !ty in the head. !qreplace is a function
;\ of three arguments, !tn, !tx and !ty, all of which should be naturals. !qreplace
;\ is frequently used when updating only one byte or one word in a register,
;\ leaving the other bytes alone.
(defn replace (n x y)
  (app n x (tail y n)))

;\ !qext is a function of three arguments, !tn, !tx and !tsize.  !qext is used
;\ frequently to do ``sign-extension''.  For instance, in the MC68020,
;\ we often extract a byte or word and wish to add it into a 32-bit sum,
;\ but we first sign-extend the extracted quantity to obtain a meaningful
;\ sum.
(defn ext (n x size)
  (if (lessp n size)
      (if (b0p (bitn x (sub1 n)))
          (head x n)
        (app n x (sub1 (exp 2 (difference size n)))))
    (head x size)))

;\ Shift operations.

;\ Logical shift left.
(defn lsl (len x cnt)
  (head (times x (exp 2 cnt)) len))

;\ Arithmetic shift left.
(defn asl (len x cnt)
  (head (times x (exp 2 cnt)) len))

;\ Logical shift right.
(defn lsr (x cnt)
  (tail x cnt))

;\ Arithmetic shift right.
(defn asr (n x cnt)
  (if (lessp x (exp 2 (sub1 n)))
      (tail x cnt)
    (if (lessp n cnt)
        (sub1 (exp 2 n))
      (app (difference n cnt) (tail x cnt) (sub1 (exp 2 cnt))))))

;\ \section{Integer Arithmetic}

;\ Throughout most of this MC68020 specification, we restrict our attention to
;\ arithmetic on the nonnegative integers.  However, in the definition of two
;\ machine instructions, those for signed multiplication and division, we also
;\ consider all of the integers, both nonnegative and negative.  The Nqthm
;\ logic adds the negative integers almost as an afterthought, and the basic,
;\ built-in arithmetic operations of the Nqthm logic work only for nonnegative
;\ integers.  To do arithmetic on all the integers, we must define appropriate
;\ operations explicitly, as we do below.
;\ 
;\ The Nqthm logic has the peculiarity that !t(minus 0) is not the same as !t0 .
;\ However, we will restrict our domain so that !t(minus 0) is not considered.
;\ A negative integer is defined to be of the form !t(minus x) with !tx nonzero.
(defn negp (i)
  (and (negativep i)
       (not (equal i (minus 0)))))

;\ !tx is an integer iff !tx is either a nonnegative number or a negative number.
(defn integerp (x)
  (or (numberp x)
      (negp x)))

(defn fix-int (x)
  (if (integerp x) x 0))

(defn izerop (x)
  (equal (fix-int x) 0))

(defn abs (x)
  (if (negp x)
      (negative-guts x)
    (fix x)))

(defn ilessp (i j)
  (if (negp i)
      (if (negp j)
          (lessp (negative-guts j) (negative-guts i))
        t)
    (if (negp j)
        f
      (lessp i j))))

(defn ileq (i j)
  (not (ilessp j i)))

(defn iplus (x y)
  (if (negp x)
      (if (negp y)
          (minus (plus (negative-guts x)
                       (negative-guts y)))
        (if (lessp y (negative-guts x))
            (minus (difference (negative-guts x) y))
          (difference y (negative-guts x))))
    (if (negp y)
        (if (lessp x (negative-guts y))
            (minus (difference (negative-guts y) x))
          (difference x (negative-guts y)))
      (plus x y))))

(defn ineg (x)
  (if (izerop x)
      0
    (if (negp x)
        (negative-guts x)
      (minus x))))

(defn idifference (x y)
  (iplus x (ineg y)))

(defn itimes (x y)
  (if (negp x)
      (if (negp y)
          (times (negative-guts x) (negative-guts y))
        (fix-int (minus (times (negative-guts x) y))))
    (if (negp y)
        (fix-int (minus (times x (negative-guts y))))
      (times x y))))

(defn iremainder (x y)
  (if (negp x)
      (fix-int (minus (remainder (negative-guts x) (abs y))))
    (remainder x (abs y))))

(defn iquotient (x y)
  (if (negp x)
      (if (negp y)
          (quotient (negative-guts x) (negative-guts y))
        (fix-int (minus (quotient (negative-guts x) y))))
    (if (negp y)
        (fix-int (minus (quotient x (negative-guts y))))
      (quotient x y))))

;\ The size of bit vectors.
;\ !qnat-rangep returns !tT, if !t(lessp nat (exp n 2)), but returns !tF, otherwise.
(defn nat-rangep (nat n)
  (lessp nat (exp 2 n)))

;\ The size of an unsigned integer.
;\ !quint-rangep returns !tT, if !t(leq 0 x (exp n 2)), and returns !tF, otherwise.
(defn uint-rangep (x n)
  (lessp x (exp 2 n)))

;\ Two conversion functions for unsigned integer interpretation.
(defn nat-to-uint (x) (fix x))

(defn uint-to-nat (x) (fix x))

;\ The size of an integer.
;\ !qint-rangep returns !tT, if !t(and (leq (minus (exp 2 (sub1 n))) int) (lessp int (exp 2 (sub1 n)))), and returns !tF, otherwise.
(defn int-rangep (int n)
  (if (zerop n)
      (equal (fix-int int) 0)
    (if (negativep int)
        (leq (negative-guts int) (exp 2 (sub1 n)))
      (lessp int (exp 2 (sub1 n))))))

;\ Two conversion functions for signed integer interpretation. !qnat-to-int 
;\ converts natural numbers to integers, !qint-to-nat converts integers to 
;\ natural numbers.
(defn nat-to-int (x n)
  (if (lessp x (exp 2 (sub1 n)))
      (fix x)
    (minus (difference (exp 2 n) x))))

(defn int-to-nat (x size)
  (if (negativep x)
      (difference (exp 2 size)
                  (negative-guts x))
    (fix x)))

;\  \section{Binary Trees for Memory}

;\ A binary tree is either !tnil or an object of the form (!tvalue !tbt0 . !tbt1),
;\ where !tbt0 and !tbt1 are binary trees and !tvalue is any object stored at
;\ that node.

;\ !qvalue-field is a function of one argument.  !qvalue-field returns the
;\ object stored at the current node, i.e., the !qcar.
(defn value-field (bt)
  (if (listp bt) (car bt) 0))

;\ !qbranch0 is a function of one argument, which should be a non-!tnil binary
;\ tree. !qbranch0 returns the left branch, i.e., the !qcadr.
(defn branch0 (bt)
  (if (listp bt) (cadr bt) nil))

;\ !qbranch1 is a function of one argument, which should be a non-!tnil bin-tree.
;\ !qbranch1 returns the right branch, i.e., the !qcddr.
(defn branch1 (bt)
  (if (and (listp bt) (listp (cdr bt)))
      (cddr bt)
    nil))

;\ Construct a binary tree (!tvalue !tbr0 . !tbr1).
(defn make-bt (value br0 br1)
  (cons value (cons br0 br1)))

;\ In order to execute MC68020 instructions reasonably efficiently in an
;\ applicative programming language, we implement memory using binary trees
;\ rather than simple linear lists or association lists.  Binary trees give us
;\ logarithmic access and change times.

;\ A memory state in this specification is actually given by a !qcons of two
;\ binary trees, one that tells us `protection' information about each byte of
;\ the memory and one that is the `physical' memory, i.e., the byte of data
;\ stored at each 32-bit address.

;\ A completely `full' binary tree would contain $2^{32}$ tips, and the explicit
;\ representation of such a tree would vastly exceed the memory capacity of any
;\ known implementation of Nqthm.  Therefore, we assign meaning to non-full,
;\ i.e., partially full, binary trees, both for protection and for data.

;\ To characterize, informally, the content and protection of an address in
;\ memory, let us momentarily view an address as a sequence of 32 bits, most
;\ significant bit on the left.  By an `initial sequence' of an address !tx, we mean a
;\ sequence to which one can append another possibly empty sequence on the
;\ right to obtain !tx.  Thus {\tt 001} is an initial sequence of {\tt
;\ 0010011}.  For a given memory data tree !tbt and address !tx, what is the
;\ content of !tbt at !tx?  Answer: if the subtree of !tbt obtained by taking
;\ the path through !tbt determined by any initial sequence of !tx is !tnil,
;\ then the content of !tbt at !tx is {\tt 0}.  Otherwise, the content is the
;\ value field at the subtree of !tbt determined by !tx.  In other words, if
;\ !tbt is not sufficiently deep along the path !tx, then the content of
;\ !tbt at !tx is {\tt 0}.

;\ A memory protection tree !tmap is a binary tree which has stored at each
;\ node, in the value cell, either !tnil, !t'(unavailable), !t'(rom), or
;\ !t'(unavailable rom).  (The last of these has the same meaning as
;\ !t'(unavailable).) For a given memory protection tree !tmap and address !tx,
;\ what is the protection status of !tmap at !tx?  Answer: if !t'unavailable is
;\ a member of the value cell at any subtree of !tmap obtained by taking the
;\ path through !tmap determined by any initial subsequence of !tx, then the
;\ address !tx is said to be unavailable, and it may not be read or written
;\ (even as part of a word or long word operation) by any instruction.
;\ Moreover, if an address !tx is not unavailable by the preceding rule, but
;\ !t'rom is a member of any such value cell, then the address is said to be
;\ ROM and may not be written by any instruction.  Instructions must come
;\ entirely from such ROM addresses.  Finally, if an address is not unavailable
;\ or ROM by the preceding rules, we say that it is RAM, and it may be read or
;\ written by any instruction.  \index{RAM}\index{ROM}\index{unavailable}
;\ \index{memory}\index{protection}\index{binary tree}

;\ !qreadp is a function of three arguments, !tx, !tmap, and !tn.  !tmap should
;\ be a memory protection binary tree.  !tx should be a natural number.  !tn is
;\ the index of the `next bit' to select upon in !tx while walking the !tx path
;\ through !tmap.  Typically !qreadp is called with !tn initially equal to 32
;\ and !tmap equal to the current memory protection map.  !qreadp returns
;\ !tf if it encounters an !t'unavailable at a node on the !tx path through
;\ !tmap (considering only the least !tn significant bits of !tx), and otherwise
;\ !treadp returns !tt .
(defn readp (x n map)
  (if (member 'unavailable (value-field map))
      f
    (if (or (nlistp map) (zerop n))
        t
      (if (b0p (bitn x (sub1 n)))
          (readp x (sub1 n) (branch0 map))
        (readp x (sub1 n) (branch1 map)))))
  ((lessp (count n))))

;\ In our specification, programs can only be stored in ROM.  The function
;\ !qpc-readp returns !tt only when it hits a !t'rom at a node on the path !tx
;\ through !tmap and only if there is no !t'unavailable at each node on the
;\ path !tx.  !tn serves the same role it does in !qreadp, as an index into
;\ !tx.
(defn pc-readp (x n map)
  (if (member 'unavailable (value-field map))
      f
    (if (member 'rom (value-field map))
        (readp x n map)
      (if (or (nlistp map) (zerop n))
          f
        (if (b0p (bitn x (sub1 n)))
            (pc-readp x (sub1 n) (branch0 map))
          (pc-readp x (sub1 n) (branch1 map))))))
  ((lessp (count n))))

;\ !qwritep is a function of three arguments, !tx, !tn, and !tmap.  !qmap
;\ should be a memory protection binary tree.  !tx should be a natural number.
;\ !qwritep returns !tt if it never encounters !t'unavailable or !t'rom at a
;\ node on the path !tx through !tmap, otherwise !tf .  !tn serves the same role
;\ it does in !qreadp, as an index into !tx.
(defn writep (x n map)
  (if (or (member 'unavailable (value-field map))
          (member 'rom (value-field map)))
      f
    (if (or (nlistp map) (zerop n))
        t
      (if (b0p (bitn x (sub1 n)))
          (writep x (sub1 n) (branch0 map))
        (writep x (sub1 n) (branch1 map)))))
  ((lessp (count n))))

;\ !qread is a function of three arguments, !tx, !tn, and !tbt.  !tbt should be
;\ a binary tree, !tx and !tn should be natural numbers.  !qread returns the
;\ value component at the node reached by taking the path !tx through !tbt. !tn
;\ serves the same role it does in !qreadp, as an index into !tx.

(defn read (x n bt)
  (if (zerop n)
      (value-field bt)
    (if (b0p (bitn x (sub1 n)))
        (read x (sub1 n) (branch0 bt))
      (read x (sub1 n) (branch1 bt)))))

;\ !qpc-read acts the same as read. But it is used in a  quite different
;\ sense.  So we introduce this dummy function.
(defn pc-read (x n bt)
  (read x n bt))

;\ !qwrite is a function of four arguments, !tvalue, !tx, !tn, and !tbt.
;\ !tvalue, !tx, and !tn should be nonnegative integers, and !tbt should be a
;\ binary tree.  !qwrite returns the binary tree obtained by updating !tbt at
;\ the address !tx.  !tn serves the same role it does in !qreadp, as an index
;\ into !tx.

(defn write (value x n bt)
  (if (zerop n)
      (make-bt value (branch0 bt) (branch1 bt))
    (if (b0p (bitn x (sub1 n)))
        (make-bt (value-field bt)
                 (write value x (sub1 n) (branch0 bt))
                 (branch1 bt))
      (make-bt (value-field bt)
               (branch0 bt)
               (write value x (sub1 n) (branch1 bt))))))

;\ !qget-nth is a function of two arguments.  The first should be a
;\ nonnegative integer and the second should be a list.  !qget-nth
;\ returns the $n^{\rm{th}}$ element of !tlst.  Indexing is 0-based.
;\ For example, !t(equal (get-nth 0 (list a b c)) a).
(defn get-nth (n lst)
  (if (zerop n)
      (car lst)
    (get-nth (sub1 n) (cdr lst))))

;\ !qput-nth is a function of three arguments: !tvalue, !tn, and !tlst.
;\ !tvalue and !tn should be natural numbers, and !tlst should be
;\ a list.  !qput-nth returns a list like !tlst except that the $n^{\rm th}$
;\ element has been changed to be !tvalue.  Indexing is 0-based,
;\ e.g., !t(equal (put-nth d 1 (list a b c)) (list a d c)).
(defn put-nth (value n lst)
  (if (zerop n)
      (cons value (cdr lst))
    (cons (car lst) (put-nth value (sub1 n) (cdr lst)))))

;\ The size of the operand, given the operation length.
(defn op-sz (oplen)
  (quotient oplen (b)))

;\ !qread-rn and !qwrite-rn are two functions used to fetch and modify
;\ the register !trn in the register file !tregs.
(defn read-rn (oplen rn regs)
  (head (get-nth rn regs) oplen))

(defn write-rn (oplen value rn regs)
  (put-nth (replace oplen value (get-nth rn regs)) rn regs))

;\ A machine state is defined to be a list of length 5, say (!tstatus !tregs !tpc !tccr
;\ !tmem), whose components have the following purposes: !tstatus, if it is not
;\ !t'running, is the reason that execution was stopped; !tregs holds the data
;\ registers and the address registers; !tpc is the program counter; !tccr is the
;\ 16-bit condition code register; and !tmem is the memory, including protection information.
;\ The status field is
;\ set when we encounter an instruction which we do not choose to handle for
;\ some reason.  Among the many reasons that might arise for setting the
;\ status field are (1) an illegal instruction, (2) a legal MC68020 instruction (e.g., CALLM)
;\ that this specification does not handle, and (3) an illegal addressing mode.  To construct a
;\ state one uses the 5 argument function !qmc-state, giving it as arguments, in
;\ order, the halt-reason, the data and address registers, the pc, the ccr, and
;\ the memory.  The five fields of a state can be accessed with the five
;\ accessor functions !qmc-status, !qmc-rfile, !qmc-pc, !qmc-ccr, and !qmc-mem.

(defn mc-state (status regs pc ccr mem)
  (list status regs pc ccr mem))

(defn mc-status (s) (car s))

(defn mc-rfile (s) (cadr s))

(defn mc-pc (s) (head (caddr s) (l)))

(defn mc-ccr (s) (head (cadddr s) (b)))

(defn mc-mem (s) (caddddr s))

;\ !qlen is a function of one argument, !tlst, which should be a proper list.
;\ !qlen returns the length of !tlst, i.e., the number of elements in !tlst.
(defn len (lst)
  (if (nlistp lst)
      0
    (add1 (len (cdr lst)))))

;\ !qmc-haltp returns !tT if some halting condition has been satisfied.
(defn mc-haltp (s)
  (not (equal (mc-status s) 'running)))


;\ \section{Operands from Memory}

;\ Everything in this section is machine dependent.  We assume the memory
;\ capacity is $2^{32}$.  In our specification, the memory is a binary tree
;\ with depth 32.
(defn byte-readp (x mem)
  (readp x 32 (car mem)))

;\ !qread-memp returns !tt if the !tk consecutive bytes in memory starting
;\ at !tx are readable, but returns !tf otherwise.
(defn read-memp (x mem k)
  (if (zerop k)
      t
    (and (byte-readp (add 32 x (sub1 k)) mem)
         (read-memp x mem (sub1 k)))))

;\ !qword-readp determines whether both bytes of the word at the memory address !tx are readable.
(defn word-readp (x mem)
  (read-memp x mem (wsz)))

;\ !qlong-readp determines whether all four bytes of the longword at the memory address !tx are readable.
(defn long-readp (x mem)
  (read-memp x mem (lsz)))

;\ Programs can only be stored in ROM.  Assume that !tx is a pointer
;\ in some program segment.  !qpc-read-memp returns !tt if the next !tk
;\ consecutive bytes are ROM.
(defn pc-byte-readp (x mem)
  (pc-readp x 32 (car mem)))

(defn pc-read-memp (x mem k)
  (if (zerop k)
      t
    (and (pc-byte-readp (add 32 x (sub1 k)) mem)
         (pc-read-memp x mem (sub1 k)))))

(defn pc-word-readp (x mem)
  (pc-read-memp x mem (wsz)))

(defn pc-long-readp (x mem)
  (pc-read-memp x mem (lsz)))

;\ Read from the memory.
;\ !qbyte-read reads a byte from the memory.
(defn byte-read (x mem)
  (head (read x 32 (cdr mem)) (b)))

;\ Read !tk consecutive bytes from the memory at !tx to form a natural number.
;\ !qread-mem is a function of three arguments, !tx, !tmem, and !tk.  
;\ !qread-mem
;\ returns the natural number obtained by `appending' together the !tn bytes
;\ that are obtained by reading from !tmem at locations !taddr, \ldots, 
;\ $addr+n-1$.  The most significant byte is the one with the lowest
;\ memory address, and conversely, the least significant byte is the
;\ one with the highest memory address.  This is known as the `Big Endian'
;\ scheme of memory.\index{Big Endian} \index{Endian} \index{reading memory}
(defn read-mem (x mem k)
   (if (zerop k)
       0
     (app (b)
          (byte-read (add 32 x (sub1 k)) mem)
          (read-mem x mem (sub1 k)))))

;\ The two functions !qword-read and !qlong-read use the function
;\ !qread-mem to obtain a word or a long word from the memory.
(defn word-read (x mem)
  (read-mem x mem (wsz)))

(defn long-read (x mem)
  (read-mem x mem (lsz)))

;\ Fetch instructions, by fetching bytes pointed to by the pc.  This is
;\ the same as reading from memory.  But we define a separate set of functions
;\ because we use them in a very different sense in our specification.
;\ !qpc-byte-read reads a byte from the memory at pc.
(defn pc-byte-read (pc mem)
  (head (pc-read pc 32 (cdr mem)) (b)))

(defn pc-read-mem (pc mem k)
  (if (zerop k)
      0
    (app (b)
         (pc-byte-read (add 32 pc (sub1 k)) mem)
         (pc-read-mem pc mem (sub1 k)))))

;\ !qpc-word-read reads a word from the memory at pc.
(defn pc-word-read (pc mem)
  (pc-read-mem pc mem (wsz)))

;\ !qpc-long-read reads a longword from the memory at pc.
(defn pc-long-read (pc mem)
  (pc-read-mem pc mem (lsz)))

;\ We define some bit field extractors.  The function names reflect the
;\ meanings of the fields for MC68020 instructions.

;\ The source register field.  !qs_rn is a function of one argument, !tins,
;\ which should be a word, i.e., a 16-bit bit-vector.
;\ Nonnegative integer value of bits 0..2 of ins.
(defn s_rn (ins)
  (bits ins 0 2))

;\ The source mode field.  Integer value of bits 3..5 of ins.
(defn s_mode (ins)
  (bits ins 3 5))

;\ The destination mode field.  Integer value of bits 6..8 of ins.
(defn d_mode (ins)
  (bits ins 6 8))

;\ The destination register field.  Integer value of bits 9..11 of ins.
(defn d_rn (ins)
  (bits ins 9 11))

;\ The op-mode field.  Integer value of bits 6..8 of ins.
(defn opmode-field (ins)
  (bits ins 6 8))

;\ The condition field.  Integer value of bits 8..11 of ins.
(defn cond-field (ins)
  (bits ins 8 11))

;\ By the ``oplen'' of an instruction we mean whether an instruction
;\ deals with a byte, word, long word, or quad word operation.

;\ The oplen of the operation is normally determined by bits 6 and 7.
;\ !qop-len is a function of one argument, !tins, which normally is the
;\ first word of an instruction.
;\
;\ \begin{tabular}{ll}
;\  67 & (common bit numbers)  \\
;\  00 & byte \\
;\  10 & word \\
;\  01 & long word \\
;\  11 & illegal, but we return (qsz).
;\ \end{tabular}
;\ 
(defn op-len (ins)
  (times (b) (exp 2 (bits ins 6 7))))

;\ \section{Storing the Result}

;\ !qbyte-writep determines whether the location !tx is writable with respect to the current memory.
(defn byte-writep (x mem)
  (writep x 32 (car mem)))

;\ !qwrite-memp determines whether the k consecutive bytes starting at address x in the memory are writable.
(defn write-memp (x mem k)
  (if (zerop k)
      t
    (and (byte-writep (add 32 x (sub1 k)) mem)
         (write-memp x mem (sub1 k)))))
  
;\ !qwrite-mem is a function of four arguments, !tvalue, !tx, !tmem, and !tk.
;\ !tvalue should be a natural number, namely the thing we are storing;
;\ !tx should be a natural number, namely the address at which to store
;\ !tvalue;  !tmem is the memory;  !tk is the number of bytes to store.  We
;\ store the bytes one byte at a time, storing the most significant
;\ byte of !tvalue first, at location !tx, and storing subsequently,
;\ decreasingly significant bytes at increasing addresses.
(defn byte-write (value x mem)
  (cons (car mem)
        (write (head value (b)) x 32 (cdr mem))))

(defn write-mem (value x mem k)
      (if (zerop k)
          mem
        (write-mem (tail value (b))
                   x
                   (byte-write value (add 32 x (sub1 k)) mem)
                   (sub1 k))))

;\ Obtain c, v, z, n, and x from CCR.  The following five functions !qccr-c,
;\ !qccr-v, !qccr-z, !qccr-n, and !qccr-x simply access the five
;\ correspondingly named bits of the CCR.  We use them to
;\ specify the condition cc in the bcc instruction.
(defn ccr-c (ccr) (bitn ccr 0))

(defn ccr-v (ccr) (bitn ccr 1))

(defn ccr-z (ccr) (bitn ccr 2))

(defn ccr-n (ccr) (bitn ccr 3))

(defn ccr-x (ccr) (bitn ccr 4))

;\ Whenever instructions update the CCR, !qcvznx simply generates a new partial
;\ CCR consisting of the new cvznx-flags.
(defn cvznx (c v z n x)
  (plus (fix-bit c)
        (plus (times 2 (fix-bit v))
              (plus (times 4 (fix-bit z))
                    (plus (times 8 (fix-bit n))
                          (times 16 (fix-bit x)))))))

;\ !qset-cvznx replaces the old flags in CCR by the given flags.
(defn set-cvznx (cvznx ccr)
  (replace 5 cvznx ccr))

(defn set-c (c ccr)
  (set-cvznx (cvznx c (ccr-v ccr) (ccr-z ccr) (ccr-n ccr) (ccr-x ccr))
             ccr))

(defn set-v (v ccr)
  (set-cvznx (cvznx (ccr-c ccr) v (ccr-z ccr) (ccr-n ccr) (ccr-x ccr))
             ccr))

(defn set-z (z ccr)
  (set-cvznx (cvznx (ccr-c ccr) (ccr-v ccr) z (ccr-n ccr) (ccr-x ccr))
             ccr))

(defn set-n (n ccr)
  (set-cvznx (cvznx (ccr-c ccr) (ccr-v ccr) (ccr-z ccr) n (ccr-x ccr))
             ccr))

(defn set-x (x ccr)
  (set-cvznx (cvznx (ccr-c ccr) (ccr-v ccr) (ccr-z ccr) (ccr-n ccr) x)
             ccr))

;\ To halt the machine, we simply put the halting reason ``signal'' in
;\ the machine state.
(defn halt (signal s)
  (mc-state signal
            (mc-rfile s)
            (mc-pc s)
            (mc-ccr s)
            (mc-mem s)))

;\ To update the register file in the state !ts.
(defn update-rfile (new-rfile s)
  (mc-state (mc-status s)
            new-rfile
            (mc-pc s)
            (mc-ccr s)
            (mc-mem s)))

;\ To update the program counter in the state !ts.
(defn update-pc (new-pc s)
  (mc-state (mc-status s)
            (mc-rfile s)
            new-pc
            (mc-ccr s)
            (mc-mem s)))

;\ To update the condition code in the state !ts.
(defn update-ccr (new-ccr s)
  (mc-state (mc-status s)
            (mc-rfile s)
            (mc-pc s)
            (set-cvznx new-ccr (mc-ccr s))
            (mc-mem s)))

;\ To update the memory in the state !ts.
(defn update-mem (new-mem s)
  (mc-state (mc-status s)
            (mc-rfile s)
            (mc-pc s)
            (mc-ccr s)
            new-mem))

;\ !qread-dn and !qread-an are used to fetch data and address registers in the machine state !ts.
(defn read-dn (oplen dn s)
  (read-rn oplen dn (mc-rfile s)))

(defn read-an (oplen an s)
  (read-rn oplen (plus 8 an) (mc-rfile s)))

;\ !qwrite-dn and !qwrite-an are used to modify data and address registers in the machine state !ts.
;\ They return the modified machine state.
(defn write-dn (oplen value dn s)
  (update-rfile (write-rn oplen value dn (mc-rfile s))
                s))

(defn write-an (oplen value an s)
  (update-rfile (write-rn oplen value (plus 8 an) (mc-rfile s))
                s))

;\ !qsp is the constant 7, which refers to the stack pointer sp(a7) in the 
;\ address register file.
(defn sp () 7)

;\ !qread-sp is a function that fetches the stack pointer in the given
;\ state s.
(defn read-sp (s)
  (read-an (l) (sp) s))

;\ !qwrite-sp is a function of two arguments, !tvalue and !ts.  It returns
;\ a new machine state with the stack pointer updated to value.
(defn write-sp (value s)
  (write-an (l) value (sp) s))

;\ !qpush-up pushes !tvalue onto the sp stack and increments sp.
(defn push-sp (opsz value s)
  (let ((sp (sub (l) opsz (read-sp s))))
    (if (write-memp sp (mc-mem s) opsz)
        (update-mem (write-mem value sp (mc-mem s) opsz)
                    (write-sp sp s))
      (halt (write-signal) s))))

;\ \section{Retrieving the Operand According to Oplen}

;\ The function !qoperand returns the operand based on the given addr.
;\ !taddr should be a cons; the !qcar tells us where to retrieve the operand,
;\ the !qcdr provides the real address.
(defn operand (oplen addr s)
  (if (equal (car addr) 'd)
      (read-dn oplen (cdr addr) s)
    (if (equal (car addr) 'a)
        (read-an oplen (cdr addr) s)
      (if (equal (car addr) 'm)
          (read-mem (cdr addr) (mc-mem s) (op-sz oplen))
        (cdr addr)))))

;\ \section{Effective Address Calculation}

;\ We now begin the definition of a collection of functions culminating
;\ in the function !qeffec-addr, which computes ``the effective
;\ address'' for MC68020 instructions.  (Actually, some instructions,
;\ e.g., the MOVE instruction, compute two effective addresses.)

;\ In his Ph.~D.\ thesis, Warren Hunt specified the FM8502 microprocessor in
;\ the Nqthm logic \cite{m:stack}.  In Hunt's FM8502 there is only one instruction
;\ format.  Therefore in the FM8502 ``soft-machine'' specification one
;\ can compute the effective addresses before looking at the op-code.
;\ But in the MC68020, there are several instruction formats, and the
;\ algorithm for computing effective addresses depends upon what the
;\ op-code is.  So we cannot handle instructions as uniformly as in
;\ FM8502.  We have to know what the op-code is at a very early stage
;\ in the implementation.

;\ Pre-effect and post-effect are two functions used in address
;\ register predecrement and postincrement.
(defn post-effect (oplen rn addr)
  (if (and (equal rn (sp))
           (equal oplen (b)))
      (add (l) addr (wsz))
    (add (l) addr (op-sz oplen))))

(defn pre-effect (oplen rn addr)
  (if (and (equal rn (sp))
           (equal oplen (b)))
      (sub (l) (wsz) addr)
    (sub (l) (op-sz oplen) addr)))

;\ For each of the different effective addressing modes, we define a
;\ function that ``does the work.''  In each case, the function takes
;\ as its argument the current value of the state, !ts.  Some may
;\ take other parameters.  In each case a !qcons is returned, consisting
;\ of (a) an internal state with possible an and pc updates after the
;\ effective address calculation; (b) the effective address, normally
;\ another cons indicating where to look and where to get the operands.
;\
;\ \bigskip
;\ Register direct modes.  Data register direct (000) and address
;\ register direct (001).
;\ Number of extension words: 0.

;\ !qdn-direct is a function of two arguments, !trn and !ts.  !trn should be
;\ a natural number and !ts should be an mc-state.  Mode 000.
(defn dn-direct (rn s)
  (cons s (cons 'd rn)))

;\ !qan-direct is a function of two arguments, !trn and !ts.  !trn should be
;\ a natural number and !ts should be an mc-state.  Mode 001.
(defn an-direct (rn s)
  (cons s (cons 'a rn)))

;\ Memory address modes.
;\ The pc argument to these effective address subroutines need not be
;\ the actual pc of the instruction.  In the case of the MOVE instruction,
;\ which involves two effective address calculations, the pc will point
;\ to the word before the ``next'' possible byte in the
;\ memory which is to be used as an extension word.  For example, the
;\ instruction
;\   \begin{quotation}i:    move (1,a0) (2,a2)\end{quotation}
;\ i.e., move the word at 1 + (a0) to 2 + (a2), requires altogether 3
;\ words because two extension words are required, one for each of the
;\ displacements (1 and 2).  When we invoke the function !qaddr-disp for
;\ the calculation of the first effective address, the pc will be i.
;\ But when we again invoke the function !qaddr-disp for the calculation
;\ of the second effective address, the pc will be i+2.

;\ A subtlety about pc displacement.  The one MC68020 instruction that
;\ involves two effective address calculations, the MOVE instruction,
;\ will have its second effective address calculation performed by us
;\ with the pc not pointing necessarily to the MOVE instruction but
;\ rather (possibly) pointing to the next word after the calculation
;\ of the first effective address.  However, this discrepancy does not
;\ cause a problem with pc relative addressing because pc relative
;\ addressing is prohibited in the second effective address calculation.
;\
;\ \bigskip
;\
;\ Address register indirect, mode 010.
;\ Number of extension words: 0.
;\ !qaddr-indirect is a function of two arguments, !trn and !ts.  !trn should
;\ be a natural number and !ts should be a machine state.  It returns the
;\ contents of the !trn element of the address register file.
(defn addr-indirect (rn s)
  (cons s (cons 'm (read-an (l) rn s))))

;\ Address register indirect with postincrement, mode 011.
;\ Number of extension words: 0.
(defn addr-postinc (oplen rn s)
  (let ((addr (read-an (l) rn s)))
    (cons (write-an (l) (post-effect oplen rn addr) rn s)
          (cons 'm addr))))

;\ Address register indirect with predecrement, mode 100.
;\ Number of extension words: 0.
;\ The function !qaddr-predec returns a cons of the given state !ts and
;\ the contents of the !trn element of the register file after
;\ the register has been predecremented.
(defn addr-predec (oplen rn s)
  (let ((addr (read-an (l) rn s)))
    (cons (write-an (l) (pre-effect oplen rn addr) rn s)
          (cons 'm (pre-effect oplen rn addr)))))

;\ Address register indirect with index, mode 101.
;\ Number of extension words: 1.
;\ We now begin handling an effective address calculation which involves
;\ an extension word.  In this mode, we add in the sign-extended 16-bit
;\ quantity in the word after the pc.  We return a cons with (a) the
;\ state with pc incremented and (b) the sum of the address register !trn
;\ and the sign-extended contents of the next word.
(defn addr-disp (pc rn s)
  (if (pc-word-readp pc (mc-mem s))
      (cons (update-pc (add (l) pc (wsz)) s)
            (cons 'm (add (l)
                          (read-an (l) rn s)
                          (ext (w) (pc-word-read pc (mc-mem s)) (l)))))
    (cons (halt (pc-signal) s) nil)))

;\ Address register indirect with index (8-bit displacement), mode 110.
;\ Number of extension words: 1.
(defn index-rn (indexwd)
  (bits indexwd 12 14))

(defn index-register (indexwd s)
  (if (b0p (bitn indexwd 15))
      (if (b0p (bitn indexwd 11))
          (ext (w) (read-dn (w) (index-rn indexwd) s) (l))
        (read-dn (l) (index-rn indexwd) s))
    (if (b0p (bitn indexwd 11))
        (ext (w) (read-an (w) (index-rn indexwd) s) (l))
      (read-an (l) (index-rn indexwd) s))))

(defn ir-scaled (indexwd s)
  (asl (l)
       (index-register indexwd s)
       (bits indexwd 9 10)))

(defn addr-index-disp (pc rn indexwd s)
  (cons (update-pc pc s)
        (cons 'm (add (l)
                      (add (l)
                           (read-an (l) rn s)
                           (ext (b) (head indexwd (b)) (l)))
                      (ir-scaled indexwd s)))))

;\ Address register indirect with index (base displacement), mode 110.
;\ Number of extension words: 1, 2, or 3.
(defn addr-index-bd (pc addr indexwd s)
  (cons (update-pc pc s)
        (cons 'm (add (l) addr (ir-scaled indexwd s)))))

;\ Memory indirect without index, mode 110.
;\ Number of extension words: 1, 2, 3, 4, or 5.
(defn mem-indirect (pc addr olen s)
  (if (long-readp addr (mc-mem s))
      (if (pc-read-memp pc (mc-mem s) (op-sz olen))
          (cons (update-pc (add (l) pc (op-sz olen)) s)
                (cons 'm (add (l)
                              (long-read addr (mc-mem s))
                              (ext olen
                                   (pc-read-mem pc (mc-mem s) (op-sz olen))
                                   (l)))))
        (cons (halt (pc-signal) s) nil))
    (cons (halt (read-signal) s) nil)))

;\ Memory indirect postindexed mode.
(defn mem-postindex (pc addr indexwd olen s)
  (if (long-readp addr (mc-mem s))
      (if (pc-read-memp pc (mc-mem s) (op-sz olen))
          (cons (update-pc (add (l) pc (op-sz olen)) s)
                (cons 'm
                      (add (l)
                           (add (l)
                                (long-read addr (mc-mem s))
                                (ir-scaled indexwd s))
                           (ext olen
                                (pc-read-mem pc (mc-mem s) (op-sz olen))
                                (l)))))
        (cons (halt (pc-signal) s) nil))
    (cons (halt (read-signal) s) nil)))

;\ Memory indirect preindexed mode.
(defn mem-preindex (pc addr indexwd olen s)
  (mem-indirect pc (add (l) addr (ir-scaled indexwd s)) olen s))

(defn i-is (indexwd)
  (bits indexwd 0 2))

;\ The base displacement has been added to !taddr, if necessary.  !qaddr-index3
;\ is to consider the index register and index/indirect selection.
(defn addr-index3 (pc addr indexwd s)
  (if (b0p (bitn indexwd 6))
      (if (lessp (i-is indexwd) 4)
          (if (lessp (i-is indexwd) 2)
              (if (equal (i-is indexwd) 0)
                  (addr-index-bd pc addr indexwd s)
                (mem-preindex pc addr indexwd 0 s))
            (if (equal (i-is indexwd) 2)
                (mem-preindex pc addr indexwd (w) s)
              (mem-preindex pc addr indexwd (l) s)))
        (if (lessp (i-is indexwd) 6)
            (if (equal (i-is indexwd) 4)
                (cons (halt (reserved-signal) s) nil)
              (mem-postindex pc addr indexwd 0 s))
          (if (equal (i-is indexwd) 6)
              (mem-postindex pc addr indexwd (w) s)
            (mem-postindex pc addr indexwd (l) s))))
    (if (lessp (i-is indexwd) 4)
        (if (lessp (i-is indexwd) 2)
            (if (equal (i-is indexwd) 0)
                (cons (update-pc pc s) (cons 'm addr))
              (mem-indirect pc addr 0 s))
          (if (equal (i-is indexwd) 2)
              (mem-indirect pc addr (w) s)
            (mem-indirect pc addr (l) s)))
      (cons (halt (reserved-signal) s) nil))))

(defn bd-sz (indexwd)
  (bits indexwd 4 5))

;\ The address register (base register) has been added to addr, if necessary.
;\ !qaddr-index2 is to consider the base displacement.
(defn addr-index2 (pc addr indexwd s)
  (if (lessp (bd-sz indexwd) 2)
      (if (equal (bd-sz indexwd) 0)
          (cons (halt (reserved-signal) s) nil)
        (addr-index3 pc addr indexwd s))
    (if (equal (bd-sz indexwd) 2)
        (if (pc-word-readp pc (mc-mem s))
            (addr-index3 (add (l) pc (wsz))
                         (add (l)
                              addr
                              (ext (w) (pc-word-read pc (mc-mem s)) (l)))
                         indexwd
                         s)
          (cons (halt (pc-signal) s) nil))
      (if (pc-long-readp pc (mc-mem s))
          (addr-index3 (add (l) pc (lsz))
                       (add (l) addr (pc-long-read pc (mc-mem s)))
                       indexwd
                       s)
        (cons (halt (pc-signal) s) nil)))))

(defn bs-register (rn indexwd s)
  (if (b0p (bitn indexwd 7))
      (read-an (l) rn s)
    0))

;\ !qaddr-index1 is to consider the address register (base register).
(defn addr-index1 (pc rn indexwd s)
  (if (b0p (bitn indexwd 8))
      (addr-index-disp pc rn indexwd s)
    (if (b0p (bitn indexwd 3))
        (addr-index2 pc (bs-register rn indexwd s) indexwd s)
      (cons (halt (reserved-signal) s) nil))))

(defn addr-index (pc rn s)
  (if (pc-word-readp pc (mc-mem s))
      (addr-index1 (add (l) pc (wsz)) rn (pc-word-read pc (mc-mem s)) s)
    (cons (halt (pc-signal) s) nil)))

;\ Absolute short address.   Mode 111, rn 000.
(defn absolute-short (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (cons (update-pc (add (l) pc (wsz)) s)
            (cons 'm (ext (w) (pc-word-read pc (mc-mem s)) (l))))
    (cons (halt (pc-signal) s) nil)))

;\ Absolute long address.  Mode 111, rn 001.
(defn absolute-long (pc s)
  (if (pc-long-readp pc (mc-mem s))
      (cons (update-pc (add (l) pc (lsz)) s)
            (cons 'm (pc-long-read pc (mc-mem s))))
    (cons (halt (pc-signal) s) nil)))

;\ Surprisingly, the design of the MC68020 deliberately avoids having
;\ two program counter addressing modes.  This specification here
;\ relies on this very fact.

;\ Program counter indirect with displacement.  Mode 111, rn 010.
;\ Number of extension words: 1.
(defn pc-disp (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (cons (update-pc (add (l) pc (wsz)) s)
            (cons 'm
                  (add (l)
                       pc
                       (ext (w) (pc-word-read pc (mc-mem s)) (l)))))
    (cons (halt (pc-signal) s) nil)))

;\ Program counter indirect with index (8-bit displacement). mode 111, rn 011.
(defn pc-index-disp (pc indexwd s)
  (cons (update-pc (add (l) pc (wsz)) s)
        (cons 'm (add (l)
                      (add (l)
                           pc
                           (ext (b) (head indexwd (b)) (l)))
                      (ir-scaled indexwd s)))))

;\ \noindent Program counter indirect with index (base displacement) mode. \\
;\ Program counter memory indirect postindexed mode. \\
;\ Program counter memory indirect preindexed mode.
(defn bs-pc (pc indexwd)
  (if (b0p (bitn indexwd 7)) pc  0))
 
(defn pc-index1 (pc indexwd s)
  (if (b0p (bitn indexwd 8))
      (pc-index-disp pc indexwd s)
    (if (b0p (bitn indexwd 3))
        (addr-index2 (add (l) pc (wsz)) (bs-pc pc indexwd) indexwd s)
      (cons (halt (reserved-signal) s) nil))))

(defn pc-index (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (pc-index1 pc (pc-word-read pc (mc-mem s)) s)
    (cons (halt (pc-signal) s) nil)))

;\ Immediate data. Mode 111, rn 100.
;\ Number of extension words: 1 or 2.
(defn immediate (oplen pc s)
  (if (equal oplen (b))
      (if (pc-word-readp pc (mc-mem s))
          (cons (update-pc (add (l) pc (wsz)) s)
                (cons 'i (pc-byte-read (add (l) pc (bsz)) (mc-mem s))))
        (cons (halt (pc-signal) s) nil))
    (if (pc-read-memp pc (mc-mem s) (op-sz oplen))
        (cons (update-pc (add (l) pc (op-sz oplen)) s)
              (cons 'i (pc-read-mem pc (mc-mem s) (op-sz oplen))))
      (cons (halt (pc-signal) s) nil))))

;\ Effective address calculation.  !qeffec-addr is a function of
;\ four arguments, !toplen, !tmode, !trn, and !ts.  !qoplen should be !t(b),
;\ !t(w), or !t(l); it is the size of the datum we are computing the
;\ effective address of.  !tmode is a natural number extracted from
;\ the first word of the instruction;  !tmode indicates pre-decrement,
;\ post-increment, etc.  !trn is a natural number extracted from the
;\ first word of the instruction; !trn designates a register. !ts the
;\ current machine state.  !qeffec-addr returns a pair, or !qcons as it
;\ is called in Lisp and Nqthm.  The first element (or !qcar) of this
;\ pair is an internal state after this effective address calculation.
;\ The second element (or cdr) is another !qcons consisting of the
;\ direction ('d, 'a, 'm, or 'i),  and the effective address (a
;\ nonnegative integer).  Because MC68020 instructions can be as
;\ many as 11 words long, the calculation of the next pc is intimately
;\ tied to the effective address calculation.
(defn effec-addr (oplen mode rn s)
  (if (lessp mode 4)
      (if (lessp mode 2)
          (if (equal mode 0)
              (dn-direct rn s)                       ; 000
            (an-direct rn s))                        ; 001
        (if (equal mode 2)
            (addr-indirect rn s)                     ; 010
          (addr-postinc oplen rn s)))                ; 011
    (if (lessp mode 6)
        (if (equal mode 4)
            (addr-predec oplen rn s)                 ; 100
          (addr-disp (mc-pc s) rn s))                ; 101
      (if (equal mode 6)
          (addr-index (mc-pc s) rn s)                ; 110
        (if (lessp rn 4)                             ; 111
            (if (lessp rn 2)
                (if (equal rn 0)
                    (absolute-short (mc-pc s) s)     ; 111 000
                  (absolute-long (mc-pc s) s))       ; 111 001
              (if (equal rn 2)               
                  (pc-disp (mc-pc s) s)              ; 111 010
                (pc-index (mc-pc s) s)))             ; 111 011
          (immediate oplen (mc-pc s) s)))))          ; 111 100
 )

;\ Given an effective address field, test if it is one of the existing
;\ addressing modes.
(defn addr-modep (mode rn)
  (if (equal mode 7) (leq rn 4) t))
                   
;\ Given an effective address field, test if it is a data addressing mode.
(defn data-addr-modep (mode rn)
  (if (equal mode 7) (leq rn 4) (not (equal mode 1))))

;\ Given an effective address field, test if it is a memory addressing mode.
(defn memory-addr-modep (mode rn)
  (if (equal mode 7) (leq rn 4) (geq mode 2)))

;\ Given an effective address field, test if it is a control addressing mode.
(defn control-addr-modep (mode rn)
  (if (equal mode 7)
      (leq rn 3)
    (or (equal mode 2)
        (geq mode 5))))

;\ Given an effective address field, test if it is an alterable addressing mode.
(defn alterable-addr-modep (mode rn)
  (or (not (equal mode 7))
      (equal rn 0)
      (equal rn 1)))

;\ !qdn-direct-modep returns !tt if the addressing mode is a data register direct.
;\ Returns !tf otherwise.
(defn dn-direct-modep (mode)
  (equal mode 0))

;\ !qan-direct-modep returns !tt if the addressing mode is an address register direct,
;\ and returns !tf otherwise.
(defn an-direct-modep (mode)
  (equal mode 1))

;\ Postincrement.
(defn postinc-modep (mode)
  (equal mode 3))

;\ Predecrement.
(defn predec-modep (mode)
  (equal mode 4))

(defn idata-modep (mode rn)
  (and (equal mode 7)
       (equal rn 4)))

;\ In address register direct (001), a byte size operation is not allowed.
(defn byte-an-direct-modep (oplen mode)
  (and (equal oplen (b))
       (an-direct-modep mode)))

;\ An internal state in the execution of one instruction.
(defn mc-instate (oplen ins s)
  (let ((s&addr (effec-addr oplen (s_mode ins) (s_rn ins) s)))
    (if (equal (cadr s&addr) 'm)
        (if (read-memp (cddr s&addr) (mc-mem s) (op-sz oplen))
            s&addr
          (cons (halt (read-signal) s) nil))
      s&addr)))

;\ Mapping functions.  !qmapping finishes the execution of instructions.
;\ !qmapping maps a machine state into the next state.
(defn d-mapping (oplen v&cvznx addr s)
  (mc-state (mc-status s)
            (write-rn oplen (car v&cvznx) addr (mc-rfile s))
            (mc-pc s)
            (set-cvznx (cdr v&cvznx) (mc-ccr s))
            (mc-mem s)))

(defn a-mapping (oplen v&cvznx addr s)
  (mc-state (mc-status s)
            (write-rn oplen (car v&cvznx) (plus 8 addr) (mc-rfile s))
            (mc-pc s)
            (set-cvznx (cdr v&cvznx) (mc-ccr s))
            (mc-mem s)))

(defn m-mapping (oplen v&cvznx addr s)
  (if (write-memp addr (mc-mem s) (op-sz oplen))
      (mc-state (mc-status s)
                (mc-rfile s)
                (mc-pc s)
                (set-cvznx (cdr v&cvznx) (mc-ccr s))
                (write-mem (car v&cvznx) addr (mc-mem s) (op-sz oplen)))
    (halt (write-signal) s)))

(defn mapping (oplen v&cvznx s&addr)
  (if (equal (cadr s&addr) 'd)
      (d-mapping oplen v&cvznx (cddr s&addr) (car s&addr))
    (if (equal (cadr s&addr) 'a)
        (a-mapping oplen v&cvznx (cddr s&addr) (car s&addr))
      (m-mapping oplen v&cvznx (cddr s&addr) (car s&addr)))))


;\ \section{The Individual Instructions}

;\ ADD instruction.
;\ The computation of the condition code register(CCR).
(defn add-c (n sopd dopd)
  (let ((result (add n sopd dopd)))
    (b-or (b-or (b-and (mbit sopd n) (mbit dopd n))
                (b-and (b-not (mbit result n)) (mbit dopd n)))
          (b-and (mbit sopd n) (b-not (mbit result n))))))

(defn add-v (n sopd dopd)
  (let ((result (add n sopd dopd)))
    (b-or (b-and (b-and (mbit sopd n) (mbit dopd n))
                 (b-not (mbit result n)))
          (b-and (b-and (b-not (mbit sopd n)) (b-not (mbit dopd n)))
                 (mbit result n)))))

(defn add-z (oplen sopd dopd)
  (if (equal (add oplen dopd sopd) 0)
      (b1) (b0)))

(defn add-n (oplen sopd dopd)
  (mbit (add oplen dopd sopd) oplen))

(defn add-cvznx (oplen sopd dopd)
  (cvznx (add-c oplen sopd dopd)
         (add-v oplen sopd dopd)
         (add-z oplen sopd dopd)
         (add-n oplen sopd dopd)
         (add-c oplen sopd dopd)))

;\ The effects of the execution of an ADD instruction are given as follows.
(defn add-effect (oplen sopd dopd)
  (cons (add oplen dopd sopd)
        (add-cvznx oplen sopd dopd)))

;\ Test if the addressing mode is legal.
(defn add-addr-modep1 (oplen ins)
  (and (addr-modep (s_mode ins) (s_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))

(defn add-addr-modep2 (ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (memory-addr-modep (s_mode ins) (s_rn ins))))

;\ An execution of an ADD instruction.
(defn add-ins1 (oplen ins s)
  (if (add-addr-modep1 oplen ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (d-mapping oplen
                     (add-effect oplen
                                 (operand oplen (cdr s&addr) s)
                                 (read-dn oplen (d_rn ins) s))
                     (d_rn ins)
                     (car s&addr))))
    (halt (mode-signal) s)))

(defn add-mapping (opd oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (add-effect oplen opd (operand oplen (cdr s&addr) s))
               s&addr))))
                  
(defn add-ins2 (oplen ins s)
  (if (add-addr-modep2 ins)
      (add-mapping (read-dn oplen (d_rn ins) s)
                   oplen
                   ins
                   s)
    (halt (mode-signal) s)))

;\ ADDA instruction.
(defn adda-addr-modep (ins)
  (addr-modep (s_mode ins) (s_rn ins)))

;\ Notice that the ADDA instruction does not affect CCR.
(defn adda-ins (oplen ins s)
  (if (adda-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (write-an (l)
                    (add (l)
                         (read-an (l) (d_rn ins) (car s&addr))
                         (ext oplen (operand oplen (cdr s&addr) s) (l)))
                    (d_rn ins)
                    (car s&addr))))
    (halt (mode-signal) s)))

;\ ADDX instruction.
(defn addx-c (n x sopd dopd)
  (let ((result (adder n x sopd dopd)))
    (b-or (b-or (b-and (mbit sopd n) (mbit dopd n))
                (b-and (b-not (mbit result n)) (mbit dopd n)))
          (b-and (mbit sopd n) (b-not (mbit result n))))))

(defn addx-v (n x sopd dopd)
  (let ((result (adder n x sopd dopd)))
    (b-or (b-and (b-and (mbit sopd n) (mbit dopd n))
                 (b-not (mbit result n)))
          (b-and (b-and (b-not (mbit sopd n))
                        (b-not (mbit dopd n)))
                 (mbit result n)))))

(defn addx-z (oplen z x sopd dopd)
  (b-and z
         (if (equal (adder oplen x dopd sopd) 0)
             (b1) (b0))))

(defn addx-n (oplen x sopd dopd)
  (mbit (adder oplen x dopd sopd) oplen))

(defn addx-cvznx (oplen z x sopd dopd)
  (cvznx (addx-c oplen x sopd dopd)
         (addx-v oplen x sopd dopd)
         (addx-z oplen z x sopd dopd)
         (addx-n oplen x sopd dopd)
         (addx-c oplen x sopd dopd)))

(defn addx-effect (oplen sopd dopd ccr)
  (cons (adder oplen (ccr-x ccr) dopd sopd)
        (addx-cvznx oplen (ccr-z ccr) (ccr-x ccr) sopd dopd)))

(defn addx-ins1 (oplen ins s)
  (d-mapping oplen
             (addx-effect oplen
                          (read-dn oplen (s_rn ins) s)
                          (read-dn oplen (d_rn ins) s)
                          (mc-ccr s))
             (d_rn ins)
             s))

(defn addx-ins2 (oplen ins s)
  (let ((s&addr0 (addr-predec oplen (s_rn ins) s)))
    (if (read-memp (cddr s&addr0) (mc-mem s) (op-sz oplen))
        (let ((s&addr (addr-predec oplen (d_rn ins) (car s&addr0))))
          (if (read-memp (cddr s&addr) (mc-mem s) (op-sz oplen))
              (mapping oplen
                       (addx-effect oplen
                                    (operand oplen (cdr s&addr0) (car s&addr0))
                                    (operand oplen (cdr s&addr) (car s&addr))
                                    (mc-ccr s))
                       s&addr)
            (halt (read-signal) s)))
      (halt (read-signal) s))))

;\ Opcode 1101.
;\ The ADD instruction group includes three instructions ADD, ADDA, and ADDX.
(defn add-group (opmode ins s)
  (if (lessp opmode 4)
      (if (equal opmode 3)
          (adda-ins (w) ins s)
        (add-ins1 (op-len ins) ins s))
    (if (equal opmode 7)
        (adda-ins (l) ins s)
      (if (equal (s_mode ins) 0)
          (addx-ins1 (op-len ins) ins s)
        (if (equal (s_mode ins) 1)
            (addx-ins2 (op-len ins) ins s)
          (add-ins2 (op-len ins) ins s))))))

;\ SUB instruction.
;\ The computation of the condition code register (ccr).
(defn sub-c (n sopd dopd)
  (let ((result (sub n sopd dopd)))
    (b-or (b-or (b-and (mbit sopd n) (b-not (mbit dopd n)))
                (b-and (mbit result n) (b-not (mbit dopd n))))
          (b-and (mbit sopd n) (mbit result n)))))

(defn sub-v (n sopd dopd)
  (let ((result (sub n sopd dopd)))
    (b-or (b-and (b-and (b-not (mbit sopd n)) (mbit dopd n))
                 (b-not (mbit result n)))
          (b-and (b-and (mbit sopd n) (b-not (mbit dopd n)))
                 (mbit result n)))))

(defn sub-z (oplen sopd dopd)
  (if (equal (sub oplen sopd dopd) 0) (b1) (b0)))

(defn sub-n (oplen sopd dopd)
  (mbit (sub oplen sopd dopd) oplen))

(defn sub-cvznx (oplen sopd dopd)
  (cvznx (sub-c oplen sopd dopd)
         (sub-v oplen sopd dopd)
         (sub-z oplen sopd dopd)
         (sub-n oplen sopd dopd)
         (sub-c oplen sopd dopd)))

;\ The effect of an execution of a SUB instruction.
(defn sub-effect (oplen sopd dopd)
  (cons (sub oplen sopd dopd)
        (sub-cvznx oplen sopd dopd)))

;\ Test if the addressing mode is illegal.
(defn sub-addr-modep1 (oplen ins)
  (and (addr-modep (s_mode ins) (s_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))

(defn sub-addr-modep2 (ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (memory-addr-modep (s_mode ins) (s_rn ins))))

;\ The execution of the SUB instruction.
(defn sub-ins1 (oplen ins s)
  (if (sub-addr-modep1 oplen ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (d-mapping oplen
                     (sub-effect oplen
                                 (operand oplen (cdr s&addr) s)
                                 (read-dn oplen (d_rn ins) s))
                     (d_rn ins)
                     (car s&addr))))
    (halt (mode-signal) s)))

(defn sub-mapping (opd oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (sub-effect oplen opd (operand oplen (cdr s&addr) s))
               s&addr))))

(defn sub-ins2 (oplen ins s)
  (if (sub-addr-modep2 ins)
      (sub-mapping (read-dn oplen (d_rn ins) s)
                   oplen
                   ins
                   s)
    (halt (mode-signal) s)))
                      
;\ SUBA instruction.
(defn suba-addr-modep (ins)
  (addr-modep (s_mode ins) (s_rn ins)))

(defn suba-ins (oplen ins s)
  (if (suba-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (write-an (l)
                    (sub (l)
                         (ext oplen (operand oplen (cdr s&addr) s) (l))
                         (read-an (l) (d_rn ins) (car s&addr)))
                    (d_rn ins)
                    (car s&addr))))
    (halt (mode-signal) s)))

;\ SUBX instruction.
(defn subx-c (n x sopd dopd)
  (let ((result (subtracter n x sopd dopd)))
    (b-or (b-or (b-and (mbit sopd n) (b-not (mbit dopd n)))
                (b-and (mbit result n) (b-not (mbit dopd n))))
          (b-and (mbit sopd n) (mbit result n)))))

(defn subx-v (n x sopd dopd)
  (let ((result (subtracter n x sopd dopd)))
    (b-or (b-and (b-and (b-not (mbit sopd n)) (mbit dopd n))
                 (b-not (mbit result n)))
          (b-and (b-and (mbit sopd n) (b-not (mbit dopd n)))
                 (mbit result n)))))

(defn subx-z (oplen z x sopd dopd)
  (b-and z
         (if (equal (subtracter oplen x sopd dopd) 0)
             (b1) (b0))))

(defn subx-n (oplen x sopd dopd)
  (mbit (subtracter oplen x sopd dopd) oplen))

(defn subx-cvznx (oplen z x sopd dopd)
  (cvznx (subx-c oplen x sopd dopd)
         (subx-v oplen x sopd dopd)
         (subx-z oplen z x sopd dopd)
         (subx-n oplen x sopd dopd)
         (subx-c oplen x sopd dopd)))

(defn subx-effect (oplen sopd dopd ccr)
  (cons (subtracter oplen (ccr-x ccr) sopd dopd)
        (subx-cvznx oplen (ccr-z ccr) (ccr-x ccr) sopd dopd)))
 
(defn subx-ins1 (oplen ins s)
  (d-mapping oplen
             (subx-effect oplen
                          (read-dn oplen (s_rn ins) s)
                          (read-dn oplen (d_rn ins) s)
                          (mc-ccr s))
             (d_rn ins)
             s))

(defn subx-ins2 (oplen ins s)
  (let ((s&addr0 (addr-predec oplen (s_rn ins) s)))
    (if (read-memp (cddr s&addr0) (mc-mem s) (op-sz oplen))
        (let ((s&addr (addr-predec oplen (d_rn ins) (car s&addr0))))
          (if (read-memp (cddr s&addr) (mc-mem s) (op-sz oplen))
              (mapping oplen
                       (subx-effect oplen
                                    (operand oplen (cdr s&addr0) (car s&addr0))
                                    (operand oplen (cdr s&addr) (car s&addr))
                                    (mc-ccr s))
                       s&addr)
            (halt (read-signal) s)))
      (halt (read-signal) s))))

;\ Opcode 1001.
;\ The SUB instruction group includes three instructions SUB, SUBA, and SUBX.
(defn sub-group (opmode ins s)
  (if (lessp opmode 4)
      (if (equal opmode 3)
          (suba-ins (w) ins s)
        (sub-ins1 (op-len ins) ins s))
    (if (equal opmode 7)
        (suba-ins (l) ins s)
      (if (equal (s_mode ins) 0)
          (subx-ins1 (op-len ins) ins s)
        (if (equal (s_mode ins) 1)
            (subx-ins2 (op-len ins) ins s)
          (sub-ins2 (op-len ins) ins s))))))

;\ AND instruction.
;\ The computation of the condition code register(CCR).
(defn and-z (oplen sopd dopd)
  (if (equal (logand sopd dopd) 0) (b1) (b0)))

(defn and-n (oplen sopd dopd)
  (mbit (logand sopd dopd) oplen))

(defn and-cvznx (oplen sopd dopd ccr)
  (cvznx (b0)
         (b0)
         (and-z oplen sopd dopd)
         (and-n oplen sopd dopd)
         (ccr-x ccr)))

;\ The effect of the execution of the AND instruction.
(defn and-effect (oplen sopd dopd ccr)
  (cons (logand sopd dopd)
        (and-cvznx oplen sopd dopd ccr)))

;\ Test if the addressing mode is legal.
(defn and-addr-modep1 (ins)
  (data-addr-modep (s_mode ins) (s_rn ins)))

(defn and-addr-modep2 (ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (memory-addr-modep (s_mode ins) (s_rn ins))))

;\ The execution of the AND instruction.
(defn and-ins1 (oplen ins s)
  (if (and-addr-modep1 ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (d-mapping oplen
                     (and-effect oplen
                                 (operand oplen (cdr s&addr) s)
                                 (read-dn oplen (d_rn ins) s)
                                 (mc-ccr s))                      
                     (d_rn ins)
                     (car s&addr))))
    (halt (mode-signal) s)))

(defn and-mapping (sopd oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (and-effect oplen
                           sopd
                           (operand oplen (cdr s&addr) s)
                           (mc-ccr s))              
               s&addr))))

(defn and-ins2 (oplen ins s)
  (if (and-addr-modep2 ins)
      (and-mapping (read-dn oplen (d_rn ins) s)
                   oplen
                   ins
                   s)
    (halt (mode-signal) s)))

;\ MULU.W/MULS.W instruction.  S * D $\rightarrow$ D.
;\ MULU expects !tx and !ty to be two natural numbers.
(defn mulu (n x y i)
  (head (times x y) n))

;\ MULS expects !tx and !ty to be two natural numbers.
(defn muls (n x y i)
  (head (int-to-nat (itimes (nat-to-int x i) (nat-to-int y i))
                    (times 2 i))
        n))

(defn mul&div-addr-modep (ins)
  (data-addr-modep (s_mode ins) (s_rn ins)))

;\ The condition codes for MULU.
(defn mulu-v (n sopd dopd i)
  (if (lessp (times sopd dopd) (exp 2 n))
      (b0) (b1)))

(defn mulu-z (n sopd dopd i)
  (if (equal (mulu n sopd dopd i) 0) (b1) (b0)))

(defn mulu-n (n sopd dopd i)
  (mbit (mulu n sopd dopd i) n))

(defn mulu-cvznx (n sopd dopd i ccr)
  (cvznx (b0)
         (mulu-v n sopd dopd i)
         (mulu-z n sopd dopd i)
         (mulu-n n sopd dopd i)
         (ccr-x ccr)))

(defn mulu_w-ins (sopd dn s)
  (let ((dopd (read-dn (w) dn s)))
    (update-ccr (mulu-cvznx (l) sopd dopd (w) (mc-ccr s))
                (write-dn (l) (mulu (l) sopd dopd (w)) dn s))))

;\ The condition codes for MULS.
(defn muls-v (n sopd dopd i)
  (if (int-rangep (itimes (nat-to-int sopd i)
                          (nat-to-int dopd i))
                  n)
      (b0) (b1)))

(defn muls-z (n sopd dopd i)
  (if (equal (muls n sopd dopd i) 0)
      (b1) (b0)))

(defn muls-n (n sopd dopd i)
  (mbit (muls n sopd dopd i) n))

(defn muls-cvznx (n sopd dopd i ccr)
  (cvznx (b0)
         (muls-v n sopd dopd i)
         (muls-z n sopd dopd i)
         (muls-n n sopd dopd i)
         (ccr-x ccr)))

(defn muls_w-ins (sopd dn s)
  (let ((dopd (read-dn (w) dn s)))
    (update-ccr (muls-cvznx (l) sopd dopd (w) (mc-ccr s))
                (write-dn (l) (muls (l) sopd dopd (w)) dn s))))

;\ EXG instruction.
;\ Exchange the contents of two data registers.
(defn exg-drdr-ins (ins s)
  (let ((dx (read-dn (l) (d_rn ins) s))
        (dy (read-dn (l) (s_rn ins) s)))
    (write-dn (l)
              dy
              (d_rn ins)
              (write-dn (l) dx (s_rn ins) s))))

;\ Exchange the contents of two address registers.
(defn exg-arar-ins (ins s)
  (let ((ax (read-an (l) (d_rn ins) s))
        (ay (read-an (l) (s_rn ins) s)))
    (write-an (l)
              ay
              (d_rn ins)
              (write-an (l) ax (s_rn ins) s))))

;\ Exchange the contents of data and address registers.
(defn exg-drar-ins (ins s)
  (let ((dx (read-dn (l) (d_rn ins) s))
        (ay (read-an (l) (s_rn ins) s)))
    (write-dn (l)
              ay
              (d_rn ins)
              (write-an (l) dx (s_rn ins) s))))

(defn mul_w-ins (ins s)
  (if (mul&div-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (let ((sopd (operand (w) (cdr s&addr) s)))
            (if (b0p (bitn ins 8))
                (mulu_w-ins sopd (d_rn ins) (car s&addr))
              (muls_w-ins sopd (d_rn ins) (car s&addr))))))
    (halt (mode-signal) s)))

;\ Opcode 1100.
;\ The AND instruction group includes three instructions AND, MULS.W/MULU.W,
;\ and EXG.  Detect ABCD.
(defn and-group (oplen ins s)
  (if (equal oplen (q))
      (mul_w-ins ins s)
    (if (b0p (bitn ins 8))
        (and-ins1 oplen ins s)
      (if (lessp (s_mode ins) 2)
          (if (equal oplen (b))
              (halt 'abcd-unspecified s)
            (if (equal oplen (w))
                (if (equal (s_mode ins) 0)
                    (exg-drdr-ins ins s)
                  (exg-arar-ins ins s))
              (if (equal (s_mode ins) 0)
                  (halt (reserved-signal) s)
                (exg-drar-ins ins s))))
        (and-ins2 oplen ins s)))))

;\ OR instruction.
;\ The computation of the condition code register.
(defn or-z (oplen sopd dopd)
  (if (equal (logor sopd dopd) 0) (b1) (b0)))

(defn or-n (oplen sopd dopd)
  (b-or (mbit sopd oplen)
	(mbit dopd oplen)))

(defn or-cvznx (oplen sopd dopd ccr)
  (cvznx (b0)
         (b0)
         (or-z oplen sopd dopd)
         (or-n oplen sopd dopd)
         (ccr-x ccr)))

;\ The effect of an execution of an  OR instruction.
(defn or-effect (oplen sopd dopd ccr)
  (cons (logor sopd dopd)
        (or-cvznx oplen sopd dopd ccr)))

;\ Test if the addressing mode is illegal.
(defn or-addr-modep1 (ins)
  (data-addr-modep (s_mode ins) (s_rn ins)))

(defn or-addr-modep2 (ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (memory-addr-modep (s_mode ins) (s_rn ins))))

;\ The execution of the OR instruction.
(defn or-ins1 (oplen ins s)
  (if (or-addr-modep1 ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (d-mapping oplen
                     (or-effect oplen
                                (operand oplen (cdr s&addr) s)
                                (read-dn oplen (d_rn ins) s)
                                (mc-ccr s))                      
                     (d_rn ins)
                     (car s&addr))))
    (halt (mode-signal) s)))

(defn or-mapping (sopd oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (or-effect oplen
                          sopd
                          (operand oplen (cdr s&addr) s)
                          (mc-ccr s))              
               s&addr))))

(defn or-ins2 (oplen ins s)
  (if (or-addr-modep2 ins)
      (or-mapping (read-dn oplen (d_rn ins) s)
                  oplen
                  ins
                  s)
    (halt (mode-signal) s)))

;\ DIVU.W/DIVS.W instructions.  D(32)/S(16) $\rightarrow$ D(16r:16q).
;\ !qiquot and !qirem expect that !ts and !td are unsigned integers.  They are
;\ used in the DIV instruction.
(defn iquot (n s i d j)
  (head (int-to-nat (iquotient (nat-to-int d j)
                               (nat-to-int s i))
                    j)
        n))

(defn irem (n s i d j)
  (head (int-to-nat (iremainder (nat-to-int d j)
                                (nat-to-int s i))
                    i)
        n))

;\ DIVS.W instruction.
(defn divs-v (n sopd i dopd j)
  (if (int-rangep (iquotient (nat-to-int dopd j) (nat-to-int sopd i))
                  n)
      (b0) (b1)))

(defn divs-z (n sopd i dopd j)
  (if (equal (iquot n sopd i dopd j) 0)
      (b1) (b0)))

(defn divs-n (n sopd i dopd j)
  (mbit (iquot n sopd i dopd j) n))

;\ In our specification of DIV,  we only make sure that the N and Z bits 
;\ are set correctly when there is NO overflow.
;\ Since we test for overflow before this instruction is fully completed,
;\ the setting of CCR is actually the same as AND's if NO overflow occurs.
;\ When an overflow is detected, we simply halt the machine with an
;\ error signal.

;\ If overflow or divide by zero happens during the DIV instructions, then
;\ the MC68020 manual states that values of N, Z, and V are undefined.
;\ Thus one should not count on the validity of these values in the
;\ error state returned by !qstepi.

(defn divs-cvznx (n sopd i dopd j ccr)
  (cvznx (b0)
         (b0)
         (divs-z n sopd i dopd j)
         (divs-n n sopd i dopd j)
         (ccr-x ccr)))

;\ 32/16 $\rightarrow$ 16r:16q.
(defn divs_w-ins (sopd dn s)
  (if (equal (nat-to-int sopd (w)) 0)
      (halt 'trap-exception s)
    (let ((dopd (read-dn (l) dn s)))
      (if (b0p (divs-v (w) sopd (w) dopd (l)))
          (update-ccr (divs-cvznx (w) sopd (w) dopd (l) (mc-ccr s))
                      (write-dn (l)
                                (app (w)
                                     (iquot (w) sopd (w) dopd (l))
                                     (irem (w) sopd (w) dopd (l)))
                                dn
                                s))
      (halt 'divs-overflow (update-ccr (set-v (b1) (mc-ccr s)) s))))))

;\ DIVU.W instruction.
(defn quot (n x y)
  (head (quotient y x) n))

(defn rem (n x y)
  (head (remainder y x) n))

;\ The condition codes for DIVU.
(defn divu-v (n sopd dopd)
  (if (lessp (quotient dopd sopd) (exp 2 n))
      (b0) (b1)))

(defn divu-z (n sopd dopd)
  (if (equal (quot n sopd dopd) 0)
      (b1) (b0)))

(defn divu-n (n sopd dopd)
  (mbit (quot n sopd dopd) n))

;\ Same treatment as divs-cvznx.
(defn divu-cvznx (n sopd dopd ccr)
  (cvznx (b0)
         (b0)
         (divu-z n sopd dopd)
         (divu-n n sopd dopd)
         (ccr-x ccr)))

;\ 32/16 $\rightarrow$ 16r:16q.
(defn divu_w-ins (sopd dn s)
  (if (equal (nat-to-uint sopd) 0)
      (halt 'trap-exception s)
    (let ((dopd (read-dn (l) dn s)))
      (if (b0p (divu-v (w) sopd dopd))
          (update-ccr (divu-cvznx (w) sopd dopd (mc-ccr s))
                      (write-dn (l)
                                (app (w)
                                     (quot (w) sopd dopd)
                                     (rem (w) sopd dopd))
                                dn
                                s))
      (halt 'divu-overflow (update-ccr (set-v (b1) (mc-ccr s)) s))))))

(defn div_w-ins (ins s)
  (if (mul&div-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (let ((sopd (operand (w) (cdr s&addr) s)))
            (if (b0p (bitn ins 8))
                (divu_w-ins sopd (d_rn ins) (car s&addr))
              (divs_w-ins sopd (d_rn ins) (car s&addr))))))
    (halt (mode-signal) s)))

;\ Opcode 1000.
;\ The OR instruction group includes two instructions OR and DIVU.W/DIVS.W.
(defn or-group (oplen ins s)
  (if (equal oplen (q))
      (div_w-ins ins s)
    (if (b0p (bitn ins 8))
        (or-ins1 oplen ins s)
      (if (lessp (s_mode ins) 2)
          (halt 'sbcd-pack-unpk-unspecified s)
        (or-ins2 oplen ins s)))))

;\ Rotate operations.
;\ Rotate left !tcnt times.  !tlen is supposed to be the length of !tx.
(defn rol (len x cnt)
  (let ((n (remainder cnt len)))
    (app n (tail x (difference len n)) (head x (difference len n)))))

;\ Rotate right !tcnt times.  !tlen is supposed to be the length of !tx.
(defn ror (len x cnt)
  (let ((n (remainder cnt len)))
    (app (difference len n) (tail x n) (head x n))))

;\ For memory shift/rotate, only memory alterable addressing modes are allowed.
(defn s&r-addr-modep (ins)
  (and (memory-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

;\ !qi-data returns a nonnegative integer.  In register shift/rotate, it is
;\ the shift/rotate cnt.  In ADDQ and SUBQ, it is the immediate data.
(defn i-data (n)
  (if (zerop n) 8 n))

(defn sr-cnt (ins s)
  (if (b0p (bitn ins 5))
      (i-data (d_rn ins))
    (remainder (read-dn (b) (d_rn ins) s) 64)))

;\ ROL and ROR instructions.
;\ We divide the ROL/ROR instruction into a few subinstructions.

;\ Register ROL instruction.
;\ The setting of cvznx-flags for ROL.
(defn rol-c (len x cnt)
  (if (equal cnt 0)
      (b0)
    (let ((n (remainder cnt len)))
      (if (zerop n)
          (bcar x)
        (bitn x (difference len n))))))

(defn rol-z (len x cnt)
  (if (equal x 0) (b1) (b0)))

(defn rol-n (len x cnt)
  (bitn x (sub1 (difference len (remainder cnt len)))))

(defn rol-cvznx (len opd cnt ccr)
  (cvznx (rol-c len opd cnt)
         (b0)
         (rol-z len opd cnt)
         (rol-n len opd cnt)
         (ccr-x ccr)))

(defn rol-effect (len opd cnt ccr)
  (cons (rol len opd cnt)
        (rol-cvznx len opd cnt ccr)))

(defn register-rol-ins (oplen ins s)
  (d-mapping oplen
             (rol-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Register ROR instruction.
(defn ror-c (len x cnt)
  (if (equal cnt 0)
      (b0)
    (let ((n (remainder cnt len)))
      (if (equal n 0)
          (bitn x (sub1 len))
        (bitn x (sub1 n))))))

(defn ror-z (len opd cnt)
  (if (equal opd 0) (b1) (b0)))

(defn ror-n (len x cnt)
  (let ((n (remainder cnt len)))
    (if (zerop n)
        (bitn x (sub1 len))
      (bitn x (sub1 n)))))

(defn ror-cvznx (len opd cnt ccr)
  (cvznx (ror-c len opd cnt)
         (b0)
         (ror-z len opd cnt)
         (ror-n len opd cnt)
         (ccr-x ccr)))

(defn ror-effect (oplen opd cnt ccr)
  (cons (ror oplen opd cnt)
        (ror-cvznx oplen opd cnt ccr)))

(defn register-ror-ins (oplen ins s)
  (d-mapping oplen
             (ror-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Memory ROL instruction.
;\ The operand size should be word, and the shift operation is one bit only.
(defn mem-rol-effect (opd ccr)
  (rol-effect (w) opd 1 ccr))

(defn mem-rol-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-rol-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ Memory ROR instruction.
;\ The operand size should be word, and the shift operation is one bit only.
(defn mem-ror-effect (opd ccr)
  (ror-effect (w) opd 1 ccr))

(defn mem-ror-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-ror-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ LSL and LSR instructions.
;\ We divided the LSL/LSR instruction into several subinstructions.

;\ Register LSL instruction.
(defn lsl-c (len opd cnt)
  (if (equal cnt 0)
      (b0)
    (if (lessp len cnt)
	(b0)
      (bitn opd (difference len cnt)))))

(defn lsl-z (len opd cnt)
  (if (equal (lsl len opd cnt) 0)
      (b1) (b0)))

(defn lsl-n (len opd cnt)
  (mbit (lsl len opd cnt) len))

(defn lsl-x (len opd cnt ccr)
  (if (equal cnt 0)
      (ccr-x ccr)
    (lsl-c len opd cnt)))

(defn lsl-cvznx (len opd cnt ccr)
  (cvznx (lsl-c len opd cnt)
         (b0)
         (lsl-z len opd cnt)
         (lsl-n len opd cnt)
         (lsl-x len opd cnt ccr)))

(defn lsl-effect (len opd cnt ccr)
  (cons (lsl len opd cnt)
        (lsl-cvznx len opd cnt ccr)))

(defn register-lsl-ins (oplen ins s)
  (d-mapping oplen
             (lsl-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Register LSR instruction.
(defn lsr-c (len opd cnt)
  (if (equal cnt 0)
      (b0)
    (if (lessp len cnt)
        (b0)
      (bitn opd (sub1 cnt)))))

(defn lsr-z (len opd cnt)
  (if (equal (lsr opd cnt) 0)
      (b1) (b0)))

(defn lsr-n (len opd cnt)
  (mbit (lsr opd cnt) len))

(defn lsr-x (len opd cnt ccr)
  (if (equal cnt 0)
      (ccr-x ccr)
    (lsr-c len opd cnt)))
   
(defn lsr-cvznx (len opd cnt ccr)
  (cvznx (lsr-c len opd cnt)
         (b0)
         (lsr-z len opd cnt)
         (lsr-n len opd cnt)
         (lsr-x len opd cnt ccr)))

(defn lsr-effect (len opd cnt ccr)
  (cons (lsr opd cnt)
        (lsr-cvznx len opd cnt ccr)))

(defn register-lsr-ins (oplen ins s)
  (d-mapping oplen
             (lsr-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Memory LSL instruction.
(defn mem-lsl-effect (opd ccr)
  (lsl-effect (w) opd 1 ccr))

(defn mem-lsl-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-lsl-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ Memory LSR instruction.
(defn mem-lsr-effect (opd ccr)
  (lsr-effect (w) opd 1 ccr))

(defn mem-lsr-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-lsr-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))
                
;\ ASL and ASR instructions.

;\ Register ASL instruction.
(defn asl-c (len opd cnt)
  (lsl-c len opd cnt))

(defn asl-v (len opd cnt)
  (if (int-rangep (nat-to-int opd len)
                  (difference len cnt))
      (b0) (b1)))

(defn asl-z (len opd cnt)
  (if (equal (asl len opd cnt) 0)
      (b1) (b0)))

(defn asl-n (len opd cnt)
  (mbit (asl len opd cnt) len))

(defn asl-x (len opd cnt ccr)
  (if (equal cnt 0)
      (ccr-x ccr)
    (asl-c len opd cnt)))

(defn asl-cvznx (len opd cnt ccr)
  (cvznx (asl-c len opd cnt)
         (asl-v len opd cnt)
         (asl-z len opd cnt)
         (asl-n len opd cnt)
         (asl-x len opd cnt ccr)))

(defn asl-effect (len opd cnt ccr)
  (cons (asl len opd cnt)
        (asl-cvznx len opd cnt ccr)))

(defn register-asl-ins (oplen ins s)
  (d-mapping oplen
             (asl-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Register ASR instruction.
(defn asr-c (len opd cnt)
  (if (equal cnt 0)
      (b0)
    (if (lessp cnt len)
        (bitn opd (sub1 cnt))
      (bitn opd (sub1 len)))))

(defn asr-z (len opd cnt)
  (if (equal (asr len opd cnt) 0)
      (b1) (b0)))

(defn asr-n (len opd cnt)
  (mbit (asr len opd cnt) len))

(defn asr-x (len opd cnt ccr)
  (if (equal cnt 0)
      (ccr-x ccr)
    (asr-c len opd cnt)))

(defn asr-cvznx (len opd cnt ccr)
  (cvznx (asr-c len opd cnt)
         (b0)
         (asr-z len opd cnt)
         (asr-n len opd cnt)
         (asr-x len opd cnt ccr)))

(defn asr-effect (len opd cnt ccr)
  (cons (asr len opd cnt)
        (asr-cvznx len opd cnt ccr)))

(defn register-asr-ins (oplen ins s)
  (d-mapping oplen
             (asr-effect oplen
                         (read-dn oplen (s_rn ins) s)
                         (sr-cnt ins s)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ Memory ASL instruction.
(defn mem-asl-effect (opd ccr)
  (asl-effect (w) opd 1 ccr))

(defn mem-asl-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-asl-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ Memory ASR instruction.
(defn mem-asr-effect (opd ccr)
  (asr-effect (w) opd 1 ccr))

(defn mem-asr-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-asr-effect (operand (w) (cdr s&addr) s)
                                   (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ ROXL and ROXR instructions.

;\ !qroxl defines the rotate left with extend operation.
(defn roxl (len opd cnt x)
  (let ((temp (plus x (times 2 opd))))
    (bcdr (rol (add1 len) temp cnt))))

;\ !qroxr defines the rotate right with extend operation.
(defn roxr (len opd cnt x)
  (let ((temp (plus opd (times x (exp 2 len)))))
    (head (ror (add1 len) temp cnt) len)))

;\ Register ROXL instruction.
(defn roxl-c (len opd cnt x)
  (let ((tmp (remainder cnt (add1 len))))
    (if (equal tmp 0)
        (fix-bit x)
      (bitn opd (difference len tmp)))))

(defn roxl-z (len opd cnt x)
  (if (equal (roxl len opd cnt x) 0) (b1) (b0)))

(defn roxl-n (len opd cnt x)
  (bitn (roxl len opd cnt x) (sub1 len)))

(defn roxl-cvznx (len opd cnt x)
  (cvznx (roxl-c len opd cnt x)
         (b0)
         (roxl-z len opd cnt x)
         (roxl-n len opd cnt x)
         (roxl-c len opd cnt x)))

(defn roxl-effect (len opd cnt ccr)
  (cons (roxl len opd cnt (ccr-x ccr))
        (roxl-cvznx len opd cnt (ccr-x ccr))))

(defn register-roxl-ins (oplen ins s)
  (d-mapping oplen
             (roxl-effect oplen
                          (read-dn oplen (s_rn ins) s)
                          (sr-cnt ins s)
                          (mc-ccr s))
             (s_rn ins)
             s))

;\ Register ROXR instruction.
(defn roxr-c (len opd cnt x)
  (let ((tmp (remainder cnt (add1 len))))
    (if (equal tmp 0)
        (fix-bit x)
      (bitn opd (sub1 tmp)))))

(defn roxr-z (len opd cnt x)
  (if (equal (roxr len opd cnt x) 0) (b1) (b0)))

(defn roxr-n (len opd cnt x)
  (bitn (roxr len opd cnt x) (sub1 len)))

(defn roxr-cvznx (len opd cnt x)
  (cvznx (roxr-c len opd cnt x)
         (b0)
         (roxr-z len opd cnt x)
         (roxr-n len opd cnt x)
         (roxr-c len opd cnt x)))

(defn roxr-effect (len opd cnt ccr)
  (cons (roxr len opd cnt (ccr-x ccr))
        (roxr-cvznx len opd cnt (ccr-x ccr))))

(defn register-roxr-ins (oplen ins s)
  (d-mapping oplen
             (roxr-effect oplen
                          (read-dn oplen (s_rn ins) s)
                          (sr-cnt ins s)
                          (mc-ccr s))
             (s_rn ins)
             s))

;\ Memory ROXL instruction.
(defn mem-roxl-effect (opd ccr)
  (roxl-effect (w) opd 1 ccr))

(defn mem-roxl-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-roxl-effect (operand (w) (cdr s&addr) s)
                                    (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ Memory ROXR instruction.
(defn mem-roxr-effect (opd ccr)
  (roxr-effect (w) opd 1 ccr))

(defn mem-roxr-ins (ins s)
  (if (s&r-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (mem-roxr-effect (operand (w) (cdr s&addr) s)
                                    (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ Memory shift/rotate.
(defn memory-shift-rotate (ins s)
  (if (b0p (bitn ins 10))
      (if (b0p (bitn ins 9))
          (if (b0p (bitn ins 8))
              (mem-asr-ins ins s)
            (mem-asl-ins ins s))
        (if (b0p (bitn ins 8))
            (mem-lsr-ins ins s)
          (mem-lsl-ins ins s)))
    (if (b0p (bitn ins 9))
        (if (b0p (bitn ins 8))
            (mem-roxr-ins ins s)
          (mem-roxl-ins ins s))
      (if (b0p (bitn ins 8))
          (mem-ror-ins ins s)
        (mem-rol-ins ins s)))))

;\ Register shift/rotate.
(defn register-shift-rotate (oplen ins s)
  (if (b0p (bitn ins 4))
      (if (b0p (bitn ins 3))
          (if (b0p (bitn ins 8))
              (register-asr-ins oplen ins s)
            (register-asl-ins oplen ins s))
        (if (b0p (bitn ins 8))
            (register-lsr-ins oplen ins s)
          (register-lsl-ins oplen ins s)))
    (if (b0p (bitn ins 3))
        (if (b0p (bitn ins 8))
            (register-roxr-ins oplen ins s)
          (register-roxl-ins oplen ins s))
      (if (b0p (bitn ins 8))
          (register-ror-ins oplen ins s)
        (register-rol-ins oplen ins s)))))

;\ The bit field instruction group consists of BFxxx instructions. All of
;\ these instructions are new in the MC68020.  Note that bit 15 in the 
;\ extension word has to be 0!
(defn bf-subgroup (ins s)
  (halt 'i-will-do-it-later s))

;\ Opcode 1110.
;\ The shift/rotate instruction group includes the ASL/ASR, LSL/LSR, ROL/ROR,
;\ ROXL/RORL, BFTST, BFEXTU, BFCHG, BFEXTS, BFCLR, BFFFO, BFSET, and BFINS
;\ instructions.  But it actually divides into many varieties of these
;\ instructions.
(defn s&r-group (ins s)
  (if (equal (op-len ins) (q))
      (if (b0p (bitn ins 11))
          (memory-shift-rotate ins s)
        (bf-subgroup ins s))
    (register-shift-rotate (op-len ins) ins s)))

;\ MOVE instruction.
(defn move-addr-modep (oplen ins)
  (and (addr-modep (s_mode ins) (s_rn ins))
       (data-addr-modep (d_mode ins) (d_rn ins))
       (alterable-addr-modep (d_mode ins) (d_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))

(defn move-z (oplen sopd)
  (if (equal (head sopd oplen) 0) (b1) (b0)))

(defn move-n (oplen sopd)
  (mbit sopd oplen))

;\ The definition of cvznx-flags of MOVE instruction.  It is also used in
;\ TST and TAS instructions.
(defn move-cvznx (oplen sopd ccr)
  (cvznx (b0)
         (b0)
         (move-z oplen sopd)
         (move-n oplen sopd)
         (ccr-x ccr)))

(defn move-effect (oplen sopd ccr)
  (cons sopd
        (move-cvznx oplen sopd ccr)))

(defn move-mapping (sopd oplen ins s)
  (let ((s&addr (effec-addr oplen (d_mode ins) (d_rn ins) s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (move-effect oplen sopd (mc-ccr s))
               s&addr))))
      
(defn move-ins (oplen ins s)
  (if (move-addr-modep oplen ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (move-mapping (operand oplen (cdr s&addr) s)
                        oplen
                        ins
                        (car s&addr))))
    (halt (mode-signal) s)))

;\ MOVEA instruction.
;\ MOVEA differs from MOVE in several ways:  ccr is not affected and word
;\ operation is sign-extended.  Therefore, we define it separately.
(defn movea-addr-modep (ins)
  (addr-modep (s_mode ins) (s_rn ins)))

(defn movea-ins (oplen ins s)
  (if (movea-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (write-an (l)
                    (ext oplen (operand oplen (cdr s&addr) s) (l))
                    (d_rn ins)
                    (car s&addr))))
    (halt (mode-signal) s)))

;\ Opcode 0010 and 0011.
;\ The following definition is defined to distinguish MOVE and MOVEA
;\ instructions.  This definition is only for word and long operations.
(defn move-group (oplen ins s)
  (if (equal (d_mode ins) 1)
      (movea-ins oplen ins s)
    (move-ins oplen ins s)))

;\ LEA instruction.
(defn lea-addr-modep (ins)
  (control-addr-modep (s_mode ins) (s_rn ins)))

;\ !qlea-ins calls !qeffec-addr, instead of !qmc-instate, since the effective
;\ address is JUST what we need.  Notice that LEA and PEA only deal with
;\ memory address.  The address direct modes are not allowed.
;\ Operation size: long.
(defn lea-ins (smode ins s)
  (if (lea-addr-modep ins)
      (let ((s&addr (effec-addr (l) smode (s_rn ins) s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (write-an (l)
                    (cddr s&addr)
                    (d_rn ins)
                    (car s&addr))))
    (halt (mode-signal) s)))

;\ EXTB instruction.
;\ Sign-extend a byte to a longword.  It is new in the MC68020.
(defn ext-z (oplen opd size)
  (if (equal (ext oplen opd size) 0) 
      (b1) (b0)))

(defn ext-n (oplen opd size)
  (mbit (ext oplen opd size) size))

(defn ext-cvznx (oplen opd size ccr)
  (cvznx (b0)
         (b0)
         (ext-z oplen opd size)
         (ext-n oplen opd size)
         (ccr-x ccr)))

(defn ext-effect (oplen opd size ccr)
  (cons (ext oplen opd size)
        (ext-cvznx oplen opd size ccr)))

(defn extb-ins (ins s)
  (d-mapping (l)
             (ext-effect (b)
                         (read-dn (b) (s_rn ins) s)
                         (l)
                         (mc-ccr s))
             (s_rn ins)
             s))

;\ The LEA instruction subgroup includes LEA and EXTB instructions.
(defn lea-subgroup (ins s)
  (if (equal (s_mode ins) 0)
      (if (equal (bits ins 9 11) 4)
          (extb-ins ins s)
        (halt (reserved-signal) s))
    (lea-ins (s_mode ins) ins s)))

;\ CLR instruction.
(defn clr-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn clr-cvznx (ccr)
  (cvznx (b0) (b0) (b1) (b0) (ccr-x ccr)))

(defn clr-effect (ccr)
  (cons 0 (clr-cvznx ccr)))

(defn clr-ins (oplen ins s)
  (if (clr-addr-modep ins)
      (let ((s&addr (effec-addr oplen (s_mode ins) (s_rn ins) s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping oplen
                   (clr-effect (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ MOVE from CCR instruction.
(defn move-from-ccr-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

;\ This instruction has no effect on CCR. Therefore, the original CCR is
;\ copied for the updating.  This is intended to have a uniform treatment
;\ for cvznx-flags.  It makes it possible to use one theorem to characterize
;\ the action.
(defn move-from-ccr-effect (ccr)
  (cons ccr ccr))

(defn move-from-ccr-ins (ins s)
  (if (move-from-ccr-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (w)
                   (move-from-ccr-effect (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ The CLR instruction subgroup includes CLR and MOVE from CCR instructions.
(defn clr-subgroup (ins s)
  (if (equal (op-len ins) (q))
      (move-from-ccr-ins ins s)
    (clr-ins (op-len ins) ins s)))

;\ NEGX instruction.
(defn negx-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn negx-ins (oplen ins s)
  (if (negx-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping oplen
                   (subx-effect oplen
                                (operand oplen (cdr s&addr) s)
                                0
                                (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ The NEGX instruction subgroup includes the NEGX instruction.
;\ Detect MOVE from SR.
(defn negx-subgroup (ins s)
  (if (equal (op-len ins) (q))
      (halt 'move-from-sr-privileged s)
    (negx-ins (op-len ins) ins s)))

;\ NEG instruction.
(defn neg-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn neg-ins (oplen ins s)
  (if (neg-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping oplen
                   (sub-effect oplen
                               (operand oplen (cdr s&addr) s)
                               0)
                   s&addr)))
    (halt (mode-signal) s)))

;\ MOVE to CCR instruction.
(defn move-to-ccr-addr-modep (ins)
  (data-addr-modep (s_mode ins) (s_rn ins)))

(defn move-to-ccr-ins (ins s)
  (if (move-to-ccr-addr-modep ins)
      (let ((s&addr (mc-instate (w) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (update-ccr (head (operand (w) (cdr s&addr) s) (b))
                      (car s&addr))))
    (halt (mode-signal) s)))

;\ The NEG instruction subgroup includes NEG and MOVE to CCR instructions.
(defn neg-subgroup (ins s)
  (if (equal (op-len ins) (q))
      (move-to-ccr-ins ins s)
    (neg-ins (op-len ins) ins s)))

;\ PEA instruction.
(defn pea-addr-modep (ins)
  (control-addr-modep (s_mode ins) (s_rn ins)))

(defn pea-ins (smode ins s)
  (if (pea-addr-modep ins)
      (let ((s&addr (effec-addr (l) smode (s_rn ins) s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (push-sp (lsz) (cddr s&addr) (car s&addr))))
    (halt (mode-signal) s)))

;\ SWAP instruction.
(defn swap-z (opd)
  (if (equal (fix opd) 0) (b1) (b0)))

(defn swap-n (opd)
  (bitn opd 15))

(defn swap-cvznx (opd ccr)
  (cvznx (b0)
         (b0)
         (swap-z opd)
         (swap-n opd)
         (ccr-x ccr)))

(defn swap-effect (opd ccr)
  (cons (app (w) (tail opd (w)) (head opd (w)))
        (swap-cvznx opd ccr)))

(defn swap-ins (ins s)
  (d-mapping (l)
             (swap-effect (read-dn (l) (s_rn ins) s)
                          (mc-ccr s))
             (s_rn ins)
             s))

;\ The PEA instruction subgroup includes PEA and SWAP.
;\ Detect BKPT.
(defn pea-subgroup (ins s)
  (if (lessp (s_mode ins) 2)
      (if (equal (s_mode ins) 0)
          (swap-ins ins s)
        (halt 'bkpt-unspecified s))
    (pea-ins (s_mode ins) ins s)))

;\ EXT instruction.
(defn ext-ins (ins s)
  (if (b0p (bitn ins 6))
      (d-mapping (w)
                 (ext-effect (b)
                             (read-dn (b) (s_rn ins) s)
                             (w)
                             (mc-ccr s))
                 (s_rn ins)
                 s)
    (d-mapping (l)
               (ext-effect (w)
                           (read-dn (w) (s_rn ins) s)
                           (l)
                           (mc-ccr s))
               (s_rn ins)
               s)))

;\ MOVEM Rn to EA instruction.
;\ A pair of functions for multiple read/write on memory.
(defn readm-mem (opsz addr mem n)
  (if (zerop n)
      nil
    (cons (read-mem addr mem opsz)
          (readm-mem opsz (add (l) addr opsz) mem (sub1 n)))))

(defn writem-mem (opsz vlst addr mem)
  (if (listp vlst)
      (writem-mem opsz
                  (cdr vlst)
                  (add (l) addr opsz)
                  (write-mem (car vlst) addr mem opsz))
    mem))

;\ A pair of functions for multiple read/write on the register file.
(defn readm-rn (oplen rnlst rfile)
  (if (listp rnlst)
      (cons (read-rn oplen (car rnlst) rfile)
            (readm-rn oplen (cdr rnlst) rfile))
    nil))

(defn writem-rn (oplen vlst rnlst rfile)
  (if (listp rnlst)
      (writem-rn oplen
                 (cdr vlst)
                 (cdr rnlst)
                 (write-rn (l) (ext oplen (car vlst) (l)) (car rnlst) rfile))
    rfile))

;\ A list of the number of registers to be moved.
(defn movem-rnlst (mask i)
  (if (zerop mask)
      nil
    (if (b0p (bcar mask))
        (movem-rnlst (bcdr mask) (add1 i))
      (cons i (movem-rnlst (bcdr mask) (add1 i))))))

(defn movem-len (mask)
  (if (zerop mask)
      0
    (if (b0p (bcar mask))
        (movem-len (bcdr mask))
      (add1 (movem-len (bcdr mask))))))

(defn writemp (mask oplen addr mem)
  (write-memp addr mem (times (op-sz oplen) (movem-len mask))))

;\ In the case of predecrement, there are a few things we have to treat
;\ separately.
;\ The order of the mask is the reverse of the other cases.
(defn movem-pre-rnlst (mask i lst)
  (if (zerop mask)
      lst
    (if (b0p (bcar mask))
        (movem-pre-rnlst (bcdr mask) (sub1 i) lst)
      (movem-pre-rnlst (bcdr mask) (sub1 i) (cons i lst)))))

;\ The reason we modify the address register !trn here is that if it is also moved to memory, it
;\ is changed before it is moved.  This function returns a `cons':  the
;\ first element is an intermediate state with the address register !trn changed, the second
;\ element is the starting memory address to move those registers.
(defn movem-predec (mask oplen rn s)
  (let ((addr (read-an (l) rn s)))
    (cons (write-an (l) (pre-effect oplen rn addr) rn s)
          (cons 'm (sub (l) (times (op-sz oplen) (movem-len mask)) addr)))))

;\ The addressing modes are control alterable plus predecrement.  We
;\ deal with -(An) separately.
(defn movem-rn-ea-addr-modep (ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (control-addr-modep (s_mode ins) (s_rn ins))))

;\ Note in the predecrement mode, if mask = 0, there is no action on An.
(defn movem-rn-ea-ins (mask oplen ins s)
  (if (predec-modep (s_mode ins))
      (let ((s&addr (movem-predec mask oplen (s_rn ins) s)))
        (if (writemp mask oplen (cddr s&addr) (mc-mem s))
            (write-an (l)
                      (cddr s&addr)
                      (s_rn ins)
                      (update-mem
                       (writem-mem (op-sz oplen)
                                   (readm-rn oplen
                                             (movem-pre-rnlst mask 15 nil)
                                             (mc-rfile (car s&addr)))
                                   (cddr s&addr)
                                   (mc-mem s))
                       (car s&addr)))
          (halt (write-signal) s)))
    (if (movem-rn-ea-addr-modep ins)
        (let ((s&addr (effec-addr oplen (s_mode ins) (s_rn ins) s)))
          (if (mc-haltp (car s&addr))
              (car s&addr)
            (if (writemp mask oplen (cddr s&addr) (mc-mem s))
                (update-mem (writem-mem (op-sz oplen)
                                        (readm-rn oplen
                                                  (movem-rnlst mask 0)
                                                  (mc-rfile s))
                                        (cddr s&addr)
                                        (mc-mem s))
                            (car s&addr))
              (halt (write-signal) s))))
      (halt (mode-signal) s))))

;\ The EXT instruction subgroup includes EXT and MOVEM Rn to EA.
(defn ext-subgroup (ins s)
  (if (equal (s_mode ins) 0)
      (ext-ins ins s)
    (if (pc-word-readp (mc-pc s) (mc-mem s))
        (movem-rn-ea-ins (pc-word-read (mc-pc s) (mc-mem s))
                         (if (b0p (bitn ins 6)) (w) (l))
                         ins
                         (update-pc (add (l) (mc-pc s) (wsz)) s))
      (halt (pc-signal) s))))

;\ TST instruction.
;\ MC68020 and MC68000 differ about addressing modes.
(defn tst-addr-modep (oplen ins)
  (if (equal oplen (b))
      (data-addr-modep (s_mode ins) (s_rn ins))
    (addr-modep (s_mode ins) (s_rn ins))))

(defn tst-ins (oplen ins s)
  (if (tst-addr-modep oplen ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (update-ccr (move-cvznx oplen
                                  (operand oplen (cdr s&addr) s)
                                  (mc-ccr s))
                      (car s&addr))))
    (halt (mode-signal) s)))

;\ TAS instruction.
;\ It is usually used as a multiprocessor operation. 
(defn tas-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn tas-effect (opd ccr)
  (cons (setn opd 7 (b1))
        (move-cvznx (b) opd ccr)))

;\ The opsize of the TAS instruction is byte.
(defn tas-ins (ins s)
  (if (tas-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (b)
                   (tas-effect (operand (b) (cdr s&addr) s)
                               (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ The TST instruction subgroup includes TAS and TST.
;\ Detect ILLEGAL instruction.
(defn tst-subgroup (ins s)
  (if (equal (op-len ins) (q))
      (if (equal (head ins 6) 60)
          (halt 'illegal-unspecified s)
        (tas-ins ins s))
    (tst-ins (op-len ins) ins s)))

;\ DIVS\_L instructions.  D / S $\rightarrow$ D.
;\ 32/32 $\rightarrow$ 32q,  32/32 $\rightarrow$ 32r:32q.  The order of 
;\ write-dn:  remainder first, and then quotient.  The overflow happens 
;\ only when the !tdopd is $-2^{31}$ and !tsopd is $-1$.
(defn divsl_l (sopd dopd dq dr s)
  (if (b0p (divs-v (l) sopd (l) dopd (l)))
      (let ((q (iquot (l) sopd (l) dopd (l)))
            (r (irem (l) sopd (l) dopd (l))))
        (update-ccr (divs-cvznx (l) sopd (l) dopd (l) (mc-ccr s))
                    (write-dn (l) q dq (write-dn (l) r dr s))))
    (halt 'divs-overflow (update-ccr (set-v (b1) (mc-ccr s)) s))))

;\ 64/32 $\rightarrow$ 32r:32q.
(defn divs_l (sopd dopd_low dq dr s)
  (let ((dopd (app (l) dopd_low (read-dn (l) dr s))))
    (if (b0p (divs-v (l) sopd (l) dopd (q)))
        (let ((q (iquot (l) sopd (l) dopd (q)))
              (r (irem (l) sopd (l) dopd (q))))
          (update-ccr (divs-cvznx (l) sopd (l) dopd (q) (mc-ccr s))
                      (write-dn (l) q dq (write-dn (l) r dr s))))
      (halt 'divs-overflow (update-ccr (set-v (b1) (mc-ccr s)) s)))))

;\ DIVU\_L instructions.  D / S $\rightarrow$ D.
;\ 32/32 $\rightarrow$ 32q,  32/32 $\rightarrow$ 32r:32q.  In this case, 
;\ overflow never happens!  It is justified by the event quotient-nat-rangep.
(defn divul_l (sopd dopd dq dr s)
  (let ((q (quot (l) sopd dopd))
        (r (rem (l) sopd dopd)))
    (update-ccr (divu-cvznx (l) sopd dopd (mc-ccr s))
                (write-dn (l) q dq (write-dn (l) r dr s)))))

;\ 64/32 $\rightarrow$ 32r:32q.
(defn divu_l (sopd dopd_low dq dr s)
  (let ((dopd (app (l) dopd_low (read-dn (l) dr s))))
    (if (b0p (divu-v (l) sopd dopd))
        (let ((q (quot (l) sopd dopd))
              (r (rem (l) sopd dopd)))
          (update-ccr (divu-cvznx (l) sopd dopd (mc-ccr s))
                      (write-dn (l) q dq (write-dn (l) r dr s))))
      (halt 'divu-overflow (update-ccr (set-v (b1) (mc-ccr s)) s)))))

(defn dq (word)
  (bits word 12 14))

(defn dr (word)
  (bits word 0 2))

(defn div_l-ins (sopd word s)
  (let ((dopd_low (read-dn (l) (dq word) s)))
    (if (b0p (bitn word 11))
        (if (equal (nat-to-uint sopd) 0)
            (halt 'trap-exception s)
          (if (b0p (bitn word 10))
              (divul_l sopd dopd_low (dq word) (dr word) s)
            (divu_l sopd dopd_low (dq word) (dr word) s)))
      (if (equal (nat-to-int sopd (l)) 0)
          (halt 'trap-exception s)
        (if (b0p (bitn word 10))
            (divsl_l sopd dopd_low (dq word) (dr word) s)
          (divs_l sopd dopd_low (dq word) (dr word) s))))))
     
;\ MULS/MULU-long instructions.  S * D $\rightarrow$ D.
(defn mulu_l_dl (sopd dopd dl s)
  (update-ccr (mulu-cvznx (l) sopd dopd (l) (mc-ccr s))
              (write-dn (l) (mulu (l) sopd dopd (l)) dl s)))

(defn mulu_l_dldh (sopd dopd dl dh s)
  (if (equal dl dh)
      (halt 'mc-undefined s)
    (update-ccr (mulu-cvznx (q) sopd dopd (l) (mc-ccr s))
                (write-dn (l)
                          (tail (mulu (q) sopd dopd (l)) (l))
                          dh
                          (write-dn (l)
                                    (head (mulu (q) sopd dopd (l)) (l))
                                    dl
                                    s)))))

(defn muls_l_dl (sopd dopd dl s)
  (update-ccr (muls-cvznx (l) sopd dopd (l) (mc-ccr s))
              (write-dn (l) (muls (l) sopd dopd (l)) dl s)))

(defn muls_l_dldh (sopd dopd dl dh s)
  (if (equal dl dh)
      (halt 'mc-undefined s)
    (update-ccr (muls-cvznx (q) sopd dopd (l) (mc-ccr s))
                (write-dn (l)
                          (tail (muls (q) sopd dopd (l)) (l))
                          dh
                          (write-dn (l)
                                    (head (muls (q) sopd dopd (l)) (l))
                                    dl
                                    s)))))

(defn dl (word)
  (bits word 12 14))

(defn dh (word)
  (bits word 0 2))

(defn mul_l-ins (sopd word s)
  (let ((dopd (read-dn (l) (dl word) s)))
    (if (b0p (bitn word 11))
        (if (b0p (bitn word 10))
            (mulu_l_dl sopd dopd (dl word) s)
          (mulu_l_dldh sopd dopd (dl word) (dh word) s))
      (if (b0p (bitn word 10))
          (muls_l_dl sopd dopd (dl word) s)
        (muls_l_dldh sopd dopd (dl word) (dh word) s)))))

(defn mul-div_l-ins (word ins s)
  (if (and (b0p (bitn word 15))
           (equal (bits word 3 9) 0))
      (if (mul&div-addr-modep ins)
          (let ((s&addr (mc-instate (l) ins s)))
            (if (mc-haltp (car s&addr))
                (car s&addr)
              (let ((sopd (operand (l) (cdr s&addr) (car s&addr))))
                (if (b0p (bitn ins 6))
                    (mul_l-ins sopd word (car s&addr))
                  (div_l-ins sopd word (car s&addr))))))
        (halt (mode-signal) s))
    (halt (reserved-signal) s)))

;\ MOVEM EA to RN instruction.
;\ The addressing modes are control plus postincrement.  We deal with
;\ (An)+ separately.
(defn movem-ea-rn-addr-modep (ins)
  (control-addr-modep (s_mode ins) (s_rn ins)))

(defn readmp (mask oplen addr mem)
  (read-memp addr mem (times (op-sz oplen) (movem-len mask))))

;\ In the mode of postincrement, if the address register is also loaded
;\ from the memory, the value of it upon completion of this instruction
;\ has no difference from the other modes.
(defn movem-ea-rn-ins (mask oplen ins s)
  (if (postinc-modep (s_mode ins))
      (let ((addr (read-an (l) (s_rn ins) s)))
        (if (readmp mask oplen addr (mc-mem s))
            (write-an (l)
                      (add (l) addr (times (op-sz oplen) (movem-len mask)))
                      (s_rn ins)
                      (update-rfile (writem-rn oplen
                                               (readm-mem (op-sz oplen)
                                                          addr
                                                          (mc-mem s)
                                                          (movem-len mask))
                                               (movem-rnlst mask 0)
                                               (mc-rfile s))
                                    s))
          (halt (read-signal) s)))
    (if (movem-ea-rn-addr-modep ins)
        (let ((s&addr (effec-addr oplen (s_mode ins) (s_rn ins) s)))
          (if (mc-haltp (car s&addr))
              (car s&addr)
            (if (readmp mask oplen (cddr s&addr) (mc-mem s))
                (update-rfile (writem-rn oplen
                                         (readm-mem (op-sz oplen)
                                                    (cddr s&addr)
                                                    (mc-mem s)
                                                    (movem-len mask))
                                         (movem-rnlst mask 0)
                                         (mc-rfile s))
                              (car s&addr))
              (halt (read-signal) s))))
      (halt (mode-signal) s))))

;\ The MOVEM-EA-RN-SUBGROUP includes MOVEM, DIVS/U and MULS/U instructions.
(defn movem-ea-rn-subgroup (ins s)
  (if (pc-word-readp (mc-pc s) (mc-mem s))
      (let ((word (pc-word-read (mc-pc s) (mc-mem s))))
        (if (b0p (bitn ins 7))
            (mul-div_l-ins word
                           ins
                           (update-pc (add (l) (mc-pc s) (wsz)) s))
          (movem-ea-rn-ins word
                           (if (b0p (bitn ins 6)) (w) (l))
                           ins
                           (update-pc (add (l) (mc-pc s) (wsz)) s))))
    (halt (pc-signal) s)))

;\ LINK-long instruction.
;\ LINK and UNLK are somewhat complicated.  When sp is used as an,  the
;\ execution order seems different from a simple instantiation.
(defn link-mapping (an disp s)
  (let ((sp (sub (l) (lsz) (read-sp s))))
    (if (write-memp sp (mc-mem s) (lsz))
        (update-mem (write-mem (read-an (l) an s) sp (mc-mem s) (lsz))
                    (write-sp (add (l) sp disp)
                              (write-an (l) sp an s)))
      (halt (write-signal) s))))

(defn link_l-ins (an s)
  (if (pc-long-readp (mc-pc s) (mc-mem s))
      (link-mapping an
                    (pc-long-read (mc-pc s) (mc-mem s))
                    (update-pc (add (l) (mc-pc s) (lsz)) s))
    (halt (pc-signal) s)))

;\ LINK-word instruction.
(defn link_w-ins (an s)
  (if (pc-word-readp (mc-pc s) (mc-mem s))
      (link-mapping an
                    (ext (w) (pc-word-read (mc-pc s) (mc-mem s)) (l))
                    (update-pc (add (l) (mc-pc s) (wsz)) s))
    (halt (pc-signal) s)))

;\ UNLK instruction.
(defn unlk-ins (an s)
  (let ((sp (read-an (l) an s)))
    (if (long-readp sp (mc-mem s))
        (write-an (l)
                  (long-read sp (mc-mem s))
                  an
                  (write-sp (add (l) sp (lsz)) s))
      (halt (read-signal) s))))

;\ The unlk instruction subgroup includes UNLK and LINK-word instructions.
;\ detect trap instruction.
(defn unlk-subgroup (ins s)
  (if (b0p (bitn ins 4))
      (halt 'trap-unspecified s)
    (if (b0p (bitn ins 3))
        (link_w-ins (s_rn ins) s)
      (unlk-ins (s_rn ins) s))))

;\ NOP instruction.
;\ The machine state, except the program counter, is not affected.  But
;\ we have already incremented pc when we read the first word of the
;\ current instruction.  Therefore, we simply return s.
(defn nop-ins (s) s)

;\ RTD instruction.
(defn rtd-mapping (sp disp s)
  (if (long-readp sp (mc-mem s))
      (let ((new-sp (add (l) (add (l) sp (lsz)) (ext (w) disp (l)))))
        (update-pc (long-read sp (mc-mem s))
                   (write-sp new-sp s)))
    (halt (read-signal) s)))

(defn rtd-ins (s)
  (if (pc-word-readp (mc-pc s) (mc-mem s))
      (rtd-mapping (read-sp s)
                   (pc-word-read (mc-pc s) (mc-mem s))
                   s)
    (halt (pc-signal) s)))

;\ RTS instruction.
;\ Notice that disp is 0.
(defn rts-ins (s)
  (rtd-mapping (read-sp s) 0 s))

;\ RTR instruction.
;\ Notice that disp is 0.
(defn rtr-ins (s)
  (let ((sp (read-sp s)))
    (if (word-readp sp (mc-mem s))
        (rtd-mapping (add (l) sp (wsz))
                     0
                     (update-ccr (word-read sp (mc-mem s)) s))
      (halt (read-signal) s))))

;\ TRAPV instruction.
;\ If the overflow is set, we simply halt the machine.  Otherwise, nop.
;\ To handle this instruction in verifications, we intend to prove the
;\ overflow is not set, and hence the machine performs nop.
(defn bvs (v) (fix-bit v))

(defn trapv-ins (s)
  (if (b1p (bvs (ccr-v (mc-ccr s))))
      (halt 'trapv-exception s)
    s))

;\ The NOP instruction subgroup includes NOP, RTD, RTS, and RTR instructions.
;\ Detect RESET, STOP, RTE, and TRAPV.
(defn nop-subgroup (ins s)
  (if (b0p (bitn ins 2))
      (if (b0p (bitn ins 1))
          (if (b0p (bitn ins 0))
              (halt 'reset-privileged s)
            (nop-ins s))
        (if (b0p (bitn ins 0))
            (halt 'stop-privileged s)
          (halt 'rte-privileged s)))
    (if (b0p (bitn ins 1))
        (if (b0p (bitn ins 0))
            (rtd-ins s)
          (rts-ins s))
      (if (b0p (bitn ins 0))
          (trapv-ins s)
        (rtr-ins s)))))

;\ JMP instruction.
;\ The JMP instruction is unsized. To calculate the effective address by
;\ effec-addr,  one can arbitrarily supply the operand length.  Note
;\ that the addr-predec, addr-postinc and immediate are not allowed.
(defn jmp-addr-modep (ins)
  (control-addr-modep (s_mode ins) (s_rn ins)))

;\ JMP does not affect CCR!
(defn jmp-mapping (addr s)
  (if (mc-haltp s)
      s
    (update-pc addr s)))

(defn jmp-ins (ins s)
  (if (jmp-addr-modep ins)
      (let ((s&addr (effec-addr (l) (s_mode ins) (s_rn ins) s)))
        (jmp-mapping (cddr s&addr) (car s&addr)))
    (halt (mode-signal) s)))

;\ JSR instruction.
;\ JSR does not affect CCR!
(defn jsr-addr-modep (ins)
  (control-addr-modep (s_mode ins) (s_rn ins)))

(defn jsr-ins (ins s)
  (if (jsr-addr-modep ins)
      (let ((s&addr (effec-addr (l) (s_mode ins) (s_rn ins) s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (jmp-mapping (cddr s&addr)
                       (push-sp (lsz)
                                (mc-pc (car s&addr))
                                (car s&addr)))))
    (halt (mode-signal) s)))

;\ NOT instruction.
(defn not-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn not-z (oplen opd)
  (if (equal (lognot oplen opd) 0) (b1) (b0)))

(defn not-n (oplen opd)
  (mbit (lognot oplen opd) oplen))

(defn not-cvznx (oplen opd ccr)
  (cvznx (b0)
         (b0)
         (not-z oplen opd)
         (not-n oplen opd)
         (ccr-x ccr)))

(defn not-effect (oplen opd ccr)
  (cons (lognot oplen opd)
        (not-cvznx oplen opd ccr)))

(defn not-ins (oplen ins s)
  (if (not-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping oplen
                   (not-effect oplen
                               (operand oplen (cdr s&addr) s)
                               (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

(defn not-subgroup (ins s)
  (if (equal (op-len ins) (q))
      (halt 'move-to-sr-privileged s)
    (not-ins (op-len ins) ins s)))

;\ Opcode 0100.
;\ The miscellaneous instruction group includes LEA, CLR, MOVE from CCR,
;\ NEG, MOVE to CCR, NOT, SWAP, PEA, EXT-word, MOVEM to EA, TST, TAS,
;\ MOVEM to RN, LINK, UNLK, NOP, RTD, RTS, RTR, JSR, JMP.
(defn misc-group (ins s)
  (if (b0p (bitn ins 8))
      (if (b0p (bitn ins 11))
          (if (b0p (bitn ins 10))
              (if (b0p (bitn ins 9))
                  (negx-subgroup ins s)                    ; 0000...
                (clr-subgroup ins s))                      ; 0010...
            (if (b0p (bitn ins 9))
                (neg-subgroup ins s)                       ; 0100...
              (not-subgroup ins s)))                       ; 0110
        (if (b0p (bitn ins 10))
            (if (b0p (bitn ins 9))                         ; 1000...
                (if (b0p (bitn ins 7))
                    (if (b0p (bitn ins 6))
                        (if (and (b0p (bitn ins 5))        ; 100000...
                                 (b0p (bitn ins 4))
                                 (b1p (bitn ins 3)))
                            (link_l-ins (s_rn ins) s)
                          (halt 'nbcd-unspecified s))
                      (pea-subgroup ins s))                ; 100001...
                  (ext-subgroup ins s))                    ; 10001...
              (tst-subgroup ins s))                        ; 1010...
          (if (b0p (bitn ins 9))
              (movem-ea-rn-subgroup ins s)                 ; 1100...
            (if (b0p (bitn ins 7))
                (if (b0p (bitn ins 6))
                    (halt (reserved-signal) s)
                  (if (b0p (bitn ins 5))
                      (unlk-subgroup ins s)                ; 1110010...
                    (if (b0p (bitn ins 4))
                        (halt 'move-usp-unspecified s)
                      (if (b0p (bitn ins 3))
                          (nop-subgroup ins s)             ; 111001110...
                        (halt 'movec-unspecified s)))))    ; 111001111
              (if (b0p (bitn ins 6))
                  (jsr-ins ins s)
                (jmp-ins ins s))))))
    (if (and (b1p (bitn ins 6))                            ; 0...
             (b1p (bitn ins 7)))
        (lea-subgroup ins s)
      (halt 'chk-unspecified s))))

;\ Some useful definitions for Bcc and Scc instruction groups.  Notice that
;\ bvs has been defined in TRAPV.
(defn bcs (c) (fix-bit c))

(defn beq (z) (fix-bit z))

(defn bmi (n) (fix-bit n))

(defn ble (v z n)
  (b-or z (b-or (b-and n (b-not v))
                (b-and (b-not n) v))))

(defn bgt (v z n)
  (b-and (b-or (b-and n v)
               (b-and (b-not n) (b-not v)))
         (b-not z)))

(defn blt (v n)
  (b-or (b-and n (b-not v))
        (b-and (b-not n) v)))

(defn bge (v n)
  (b-or (b-and n v)
        (b-and (b-not n) (b-not v))))

(defn bls (c z)
  (b-or c z))

(defn bhi (c z)
  (b-and (b-not c) (b-not z)))

(defn branch-cc (cond ccr)
  (if (lessp cond 8)
      (if (lessp cond 4)
          (if (lessp cond 2)
              (if (equal cond 0)
                  (b1)                                    ; 0000
                (b0))                                     ; 0001
            (if (equal cond 2)
                (bhi (ccr-c ccr) (ccr-z ccr))             ; 0010
              (bls (ccr-c ccr) (ccr-z ccr))))             ; 0011
        (if (lessp cond 6)
            (if (equal cond 4)
                (b-not (bcs (ccr-c ccr)))                  ; 0100
              (bcs (ccr-c ccr)))                           ; 0101
          (if (equal cond 6)
              (b-not (beq (ccr-z ccr)))                    ; 0110
            (beq (ccr-z ccr)))))                           ; 0111
    (if (lessp cond 12)
        (if (lessp cond 10)
            (if (equal cond 8)
                (b-not (bvs (ccr-v ccr)))                  ; 1000
              (bvs (ccr-v ccr)))                           ; 1001
          (if (equal cond 10)
              (b-not (bmi (ccr-n ccr)))                    ; 1010
            (bmi (ccr-n ccr))))                            ; 1011
      (if (lessp cond 14)
          (if (equal cond 12)
              (bge (ccr-v ccr) (ccr-n ccr))                ; 1100
            (blt (ccr-v ccr) (ccr-n ccr)))                 ; 1101
        (if (equal cond 14)
            (bgt (ccr-v ccr) (ccr-z ccr) (ccr-n ccr))      ; 1110
          (ble (ccr-v ccr) (ccr-z ccr) (ccr-n ccr))))))   ; 1111
 )
;\ BSR instruction.
(defn bsr-ins (pc disp s)
  (push-sp (lsz)
           pc
           (update-pc (add (l) (mc-pc s) disp) s)))

;\ Bcc and BRA instructions are specified as follows.  The BSR
;\ instruction needs
;\ some auxiliary functions to specify it.
;\ We define BRA and Bcc together.
;\ Since 0000 is always true.
(defn bcc-ra-sr (pc cond disp s)
  (if (equal cond 0)
      (update-pc (add (l) (mc-pc s) disp) s)                 ; BRA
    (if (equal cond 1)
        (bsr-ins pc disp s)                                  ; BSR
      (if (b0p (branch-cc cond (mc-ccr s)))                  ; Bcc
          (update-pc pc s)
        (update-pc (add (l) (mc-pc s) disp)  s)))))

;\ Opcode 0110.
;\ The Bcc instruction group includes Bcc, BRA and BSR instructions.
(defn bcc-group (disp ins s)
  (if (equal disp 0)               ; disp = 0.
      (if (pc-word-readp (mc-pc s) (mc-mem s))
            (bcc-ra-sr (add (l) (mc-pc s) (wsz))
                       (cond-field ins)
                       (ext (w) (pc-word-read (mc-pc s) (mc-mem s)) (l))
                       s)
          (halt (pc-signal) s))
      (if (equal disp 255)        ; disp = 2^8 - 1.
          (if (pc-long-readp (mc-pc s) (mc-mem s))
              (bcc-ra-sr (add (l) (mc-pc s) (lsz))
                         (cond-field ins)
                         (pc-long-read (mc-pc s) (mc-mem s))
                         s)
            (halt (pc-signal) s))
        (bcc-ra-sr (mc-pc s)
                   (cond-field ins)
                   (ext (b) disp (l))
                   s))))

;\ Scc instruction.
(defn scc-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

;\ CCR is not affected by Scc.
(defn scc-effect (cond ccr)
  (cons (if (b0p (branch-cc cond ccr)) 0 255)
        ccr))

(defn scc-ins (ins s)
  (if (scc-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (b)
                   (scc-effect (cond-field ins) (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ DBcc instruction.
(defn dbcc-loop (rn s)
  (let ((cnt (sub (w) 1 (read-dn (w) rn s))))
    (if (equal (nat-to-int cnt (w)) -1)
        (update-pc (add (l) (mc-pc s) (wsz))
                   (write-dn (w) cnt rn s))
      (update-pc (add (l)
                      (mc-pc s)
                      (ext (w) (pc-word-read (mc-pc s) (mc-mem s)) (l)))
                 (write-dn (w) cnt rn s)))))

(defn dbcc-ins (ins s)
  (if (pc-word-readp (mc-pc s) (mc-mem s))
      (if (b0p (branch-cc (cond-field ins) (mc-ccr s)))
          (dbcc-loop (s_rn ins) s)
        (update-pc (add (l) (mc-pc s) (wsz)) s))
    (halt (pc-signal) s)))

;\ ADDQ instruction.
(defn addq-addr-modep (oplen ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))

;\ It seems to us that there is no
;\ difference between word and long word operations for the
;\ ADDQ instruction in the address register direct mode.

(defn addq-ins (oplen ins s)
  (if (addq-addr-modep oplen ins)
      (if (an-direct-modep (s_mode ins))
          (write-an (l)
                    (add (l)
                         (read-an (l) (s_rn ins) s)
                         (i-data (d_rn ins)))            
                    (s_rn ins)
                    s)
        (add-mapping (i-data (d_rn ins)) oplen ins s))
    (halt (mode-signal) s)))

;\ SUBQ instruction.
;\ Same remark as for ADDQ.
(defn subq-addr-modep (oplen ins)
  (and (alterable-addr-modep (s_mode ins) (s_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))

(defn subq-ins (oplen ins s)
  (if (subq-addr-modep oplen ins)
      (if (an-direct-modep (s_mode ins))
          (write-an (l)
                    (sub (l)
                         (i-data (d_rn ins))
                         (read-an (l) (s_rn ins) s))
                    (s_rn ins)
                    s)
        (sub-mapping (i-data (d_rn ins)) oplen ins s))
    (halt (mode-signal) s)))

;\ Opcode 0101.
;\ The Scc instruction group includes Scc, DBcc, ADDQ, and SUBQ instructions.
(defn scc-group (ins s)
  (if (equal (op-len ins) (q))
      (if (equal (s_mode ins) 1)
          (dbcc-ins ins s)
        (if (and (equal (s_mode ins) 7)
		 (lessp 1 (s_rn ins)))
            (halt 'trapcc-unspecified s)
          (scc-ins ins s)))
    (if (b0p (bitn ins 8))
        (addq-ins (op-len ins) ins s)
      (subq-ins (op-len ins) ins s))))

;\ Opcode 0111.
;\ MOVEQ instruction.
(defn moveq-ins (ins s)
  (if (b0p (bitn ins 8))
      (d-mapping (l)
                 (move-effect (l)
                              (ext (b) (head ins (b)) (l))
                              (mc-ccr s))
                 (d_rn ins)
                 s)
    (halt (reserved-signal) s)))

;\ CMP instruction.
(defn cmp-cvznx (oplen sopd dopd ccr) 
  (cvznx (sub-c oplen sopd dopd)
         (sub-v oplen sopd dopd)
         (sub-z oplen sopd dopd)
         (sub-n oplen sopd dopd)
         (ccr-x ccr)))                ; it is different from sub-x.  

(defn cmp-addr-modep (oplen ins)
  (and (addr-modep (s_mode ins) (s_rn ins))
       (not (byte-an-direct-modep oplen (s_mode ins)))))
        
;\ The execution of the CMP instruction.
(defn cmp-ins (oplen ins s)
  (if (cmp-addr-modep oplen ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (update-ccr (cmp-cvznx oplen
                                 (operand oplen (cdr s&addr) (car s&addr))
                                 (read-dn oplen (d_rn ins) s)
                                 (mc-ccr s))
                      (car s&addr))))
    (halt (mode-signal) s)))

;\ CMPA instruction.
(defn cmpa-addr-modep (ins)
  (addr-modep (s_mode ins) (s_rn ins)))

;\ The cvznx-flag setting is the same as the CMP instruction.
;\ The only difference is that word operation is sign-extended to longword
;\ operation.
(defn cmpa-ins (oplen ins s)
  (if (cmpa-addr-modep ins)
      (let ((s&addr (mc-instate oplen ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (update-ccr (cmp-cvznx (l)
                                 (ext oplen
                                      (operand oplen (cdr s&addr) s)
                                      (l))
                                 (read-an (l) (d_rn ins) (car s&addr))
                                 (mc-ccr s))
                      (car s&addr))))
    (halt (mode-signal) s)))

;\ EOR instruction.
(defn eor-z (oplen sopd dopd)
  (if (equal (logeor sopd dopd) 0) (b1) (b0)))

(defn eor-n (oplen sopd dopd)
  (b-eor (mbit sopd oplen)
         (mbit dopd oplen)))

(defn eor-cvznx (oplen sopd dopd ccr)
  (cvznx (b0)
         (b0)
         (eor-z oplen sopd dopd)
         (eor-n oplen sopd dopd)
         (ccr-x ccr)))

(defn eor-effect (oplen sopd dopd ccr)
  (cons (logeor sopd dopd)
        (eor-cvznx oplen sopd dopd ccr)))

(defn eor&eori-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn eor-mapping (sopd oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (mapping oplen
               (eor-effect oplen
                           sopd
                           (operand oplen (cdr s&addr) s)
                           (mc-ccr s))
               s&addr))))

(defn eor-ins (oplen ins s)
  (if (eor&eori-addr-modep ins)
      (eor-mapping (read-dn oplen (d_rn ins) s)
                   oplen
                   ins
                   s)
    (halt (mode-signal) s)))

;\ CMPM instruction.
(defn cmpm-mapping (addr oplen ins s)
  (let ((s&addr (addr-postinc oplen (d_rn ins) s)))
    (if (read-memp (cddr s&addr) (mc-mem s) (op-sz oplen))
        (update-ccr (cmp-cvznx oplen
                               (operand oplen addr s)
                               (operand oplen (cdr s&addr) s)
                               (mc-ccr s))
                    (car s&addr))
      (halt (read-signal) s))))

(defn cmpm-ins (oplen ins s)
  (let ((s&addr (addr-postinc oplen (s_rn ins) s)))
    (if (read-memp (cddr s&addr) (mc-mem s) (op-sz oplen))
        (cmpm-mapping (cdr s&addr) oplen ins (car s&addr))
      (halt (read-signal) s))))

;\ Opcode 1011.
;\ The CMP instruction group includes instructions CMP, CMPA, EOR, and CMPM.
(defn cmp-group (oplen ins s)
  (if (b0p (bitn ins 8))
      (if (equal oplen (q))
          (cmpa-ins (w) ins s)
        (cmp-ins oplen ins s))
    (if (equal oplen (q))
        (cmpa-ins (l) ins s)
      (if (equal (s_mode ins) 1)
          (cmpm-ins oplen ins s)
        (eor-ins oplen ins s)))))

;\ MOVEP instruction.
;\ MOVEP moves a data register into alternate bytes of memory.
(defn movep-writep (addr mem n)
  (if (zerop n)
      t
    (and (byte-writep (add (l) addr (times 2 (sub1 n))) mem)
         (movep-writep addr mem (sub1 n)))))

(defn movep-write (value addr mem n)
  (if (zerop n)
      mem
    (movep-write (tail value (b))
                 addr
                 (byte-write value (add (l) addr (times 2 (sub1 n))) mem)
                 (sub1 n))))

(defn movep-to-mem (addr oplen ins s)
  (if (movep-writep addr (mc-mem s) (op-sz oplen))
      (update-mem (movep-write (read-dn oplen (d_rn ins) s)
                               addr
                               (mc-mem s)
                               (op-sz oplen))
                  s)
    (halt (write-signal) s)))

;\ MOVEP moves alternate bytes in memory into a data register.
(defn movep-readp (addr mem n)
  (if (zerop n)
      t
    (and (byte-readp addr mem)
         (movep-readp (add (l) addr (wsz)) mem (sub1 n)))))

(defn movep-read (addr mem n)
  (if (zerop n)
      0
    (app (b)
         (byte-read (add (l) addr (times 2 (sub1 n))) mem)
         (movep-read addr mem (sub1 n)))))

(defn movep-to-reg (addr oplen ins s)
  (if (movep-readp addr (mc-mem s) (op-sz oplen))
      (write-dn oplen
                (movep-read addr (mc-mem s) (op-sz oplen))
                (d_rn ins)
                s)
    (halt (read-signal) s)))

(defn evenp (x)
  (b0p (bcar x)))

(defn movep-addr (s&addr)
  (if (evenp (cddr s&addr))
      (cddr s&addr)
    (add (l) (cddr s&addr) (bsz))))

(defn movep-ins (opmode ins s)
  (let ((s&addr (addr-disp (mc-pc s) (s_rn ins) s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (if (lessp opmode 6)
          (if (equal opmode 4)
              (movep-to-reg (movep-addr s&addr) (w) ins (car s&addr))
            (movep-to-reg (movep-addr s&addr) (l) ins (car s&addr)))
        (if (equal opmode 6)
            (movep-to-mem (movep-addr s&addr) (w) ins (car s&addr))
          (movep-to-mem (movep-addr s&addr) (l) ins (car s&addr)))))))

;\ Some functions for bit operations.
(defn bxxx-oplen (smode)
  (if (dn-direct-modep smode) (l) (b)))

(defn bxxx-num (smode bnum)
  (if (dn-direct-modep smode)
      (head bnum 5)
    (head bnum 3)))

(defn bxxx-opd (smode s&addr)
  (if (dn-direct-modep smode)
      (read-dn (l) (cddr s&addr) (car s&addr))
    (operand (b) (cdr s&addr) (car s&addr))))

;\ BCHG instruction.
(defn bchg-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn bchg-effect (bnum opd ccr)
  (cons (setn opd bnum (b-not (bitn opd bnum)))
        (set-z (b-not (bitn opd bnum)) ccr)))

(defn bchg-ins (bnum ins s)
  (if (bchg-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (bxxx-oplen (s_mode ins))
                   (bchg-effect (bxxx-num (s_mode ins) bnum)
                                (bxxx-opd (s_mode ins) s&addr)
                                (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ BCLR instruction.
(defn bclr-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn bclr-effect (bnum opd ccr)
  (cons (setn opd bnum (b0))
        (set-z (b-not (bitn opd bnum)) ccr)))

(defn bclr-ins (bnum ins s)
  (if (bclr-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (bxxx-oplen (s_mode ins))
                   (bclr-effect (bxxx-num (s_mode ins) bnum)
                                (bxxx-opd (s_mode ins) s&addr)
                                (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ BSET instruction.
(defn bset-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn bset-effect (bnum opd ccr)
  (cons (setn opd bnum (b1))
        (set-z (b-not (bitn opd bnum)) ccr)))

(defn bset-ins (bnum ins s)
  (if (bset-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (mapping (bxxx-oplen (s_mode ins))
                   (bset-effect (bxxx-num (s_mode ins) bnum)
                                (bxxx-opd (s_mode ins) s&addr)
                                (mc-ccr s))
                   s&addr)))
    (halt (mode-signal) s)))

;\ BTST instruction.
(defn btst-addr-modep (ins)
  (data-addr-modep (s_mode ins) (s_rn ins)))

(defn btst-ins (bnum ins s)
  (if (btst-addr-modep ins)
      (let ((s&addr (mc-instate (b) ins s)))
        (if (mc-haltp (car s&addr))
            (car s&addr)
          (update-ccr (set-z (b-not (bitn (bxxx-opd (s_mode ins) s&addr)
                                          (bxxx-num (s_mode ins) bnum)))
                             (mc-ccr s))
                      (car s&addr))))
    (halt (mode-signal) s)))

;\ !qbit-ins includes the BTST, BCLR, BCHG, and BSET instructions.
(defn bit-ins (bnum ins s)
  (let ((type (bits ins 6 7)))
    (if (lessp type 2)
        (if (equal type 0)
            (btst-ins bnum ins s)
          (bchg-ins bnum ins s))
      (if (equal type 2)
          (bclr-ins bnum ins s)
        (bset-ins bnum ins s)))))

;\ Dynamic bit operation.  BTST, BCLR, BCHG, and BSET instructions.
(defn d-bit-subgroup (ins s)
  (if (equal (s_mode ins) 1)
      (movep-ins (opmode-field ins) ins s)
    (bit-ins (read-dn (l) (d_rn ins) s) ins s)))

;\ Static bit operation.  BTST, BCLR, BCHG, and BSET instructions.
(defn s-bit-subgroup (ins s)
  (if (pc-word-readp (mc-pc s) (mc-mem s))
      (if (equal (pc-byte-read (mc-pc s) (mc-mem s)) 0)
          (bit-ins (pc-byte-read (add (l) (mc-pc s) (bsz)) (mc-mem s))
                   ins
                   (update-pc (add (l) (mc-pc s) (wsz)) s))
        (halt (reserved-signal) s))
    (halt (pc-signal) s)))

;\ ORI instruction.
(defn ori-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn ori-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp (car s&idata))
        (car s&idata)
      (if (ori-addr-modep ins)
          (or-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

;\ ORI to CCR instruction.
(defn ori-to-ccr-ins (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (if (equal (pc-byte-read pc (mc-mem s)) 0)
          (update-ccr (logor (pc-byte-read (add (l) pc (bsz)) (mc-mem s))
                             (mc-ccr s))
                      (update-pc (add (l) pc (wsz)) s))
        (halt (reserved-signal) s))
    (halt (pc-signal) s)))

;\ ORI and ORI to CCR instructions.
;\ Detect ORI to SR, CMP2, and CHK2.
(defn ori-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'cmp2-chk2-unspecified s)
    (if (equal (head ins 6) 60)
        (if (equal oplen (b))
            (ori-to-ccr-ins (mc-pc s) s)
          (if (equal oplen (w))
              (halt 'ori-to-sr-privileged s)
            (halt (reserved-signal) s)))
      (ori-ins oplen ins s))))

;\ ANDI instruction.
(defn andi-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn andi-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp s)
        (car s&idata)
      (if (andi-addr-modep ins)
          (and-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

;\ ANDI to CCR instruction.
(defn andi-to-ccr-ins (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (if (equal (pc-byte-read pc (mc-mem s)) 0)
          (update-ccr (logand (pc-byte-read (add (l) pc (bsz)) (mc-mem s))
                              (mc-ccr s))
                      (update-pc (add (l) pc (wsz)) s))
        (halt (reserved-signal) s))
    (halt (pc-signal) s)))

;\ ANDI and ANDI to CCR instructions.
;\ Detect ANDI to SR, CMP2 and CHK2.
(defn andi-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'cmp2-chk2-unspecified s)
    (if (equal (head ins 6) 60)
        (if (equal oplen (b))
            (andi-to-ccr-ins (mc-pc s) s)
          (if (equal oplen (w))
              (halt 'andi-to-sr-unspecified s)
            (halt (reserved-signal) s)))
      (andi-ins oplen ins s))))

;\ SUBI instruction. Detect CMP2 and CHK2.
(defn subi-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn subi-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp (car s&idata))
        (car s&idata)
      (if (subi-addr-modep ins)
          (sub-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

(defn subi-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'cmp2-chk2-unspecified s)
    (subi-ins oplen ins s)))

;\ ADDI instruction.  Detect RTM and CALLM.
(defn addi-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (alterable-addr-modep (s_mode ins) (s_rn ins))))

(defn addi-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp (car s&idata))
        (car s&idata)
      (if (addi-addr-modep ins)
          (add-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

(defn addi-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'rtm-callm-unspecified s)
    (addi-ins oplen ins s)))

;\ EORI instruction.
(defn eori-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp (car s&idata))
        (car s&idata)
      (if (eor&eori-addr-modep ins)
          (eor-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

;\ EORI to CCR instruction.
(defn eori-to-ccr-ins (pc s)
  (if (pc-word-readp pc (mc-mem s))
      (if (equal (pc-byte-read pc (mc-mem s)) 0)
          (update-ccr (logeor (pc-byte-read (add (l) pc (bsz)) (mc-mem s))
                              (mc-ccr s))
                      (update-pc (add (l) pc (wsz)) s))
        (halt (reserved-signal) s))
    (halt (pc-signal) s)))

;\ EORI and EORI to CCR instructions.
;\ Detect EORI to SR, CAS and CAS2 instructions!
(defn eori-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'cas-cas2-unspecified s)
    (if (equal (head ins 6) 60)
        (if (equal oplen (b))
            (eori-to-ccr-ins (mc-pc s) s)
          (if (equal oplen (w))
              (halt 'eori-to-sr-unspecified s)
            (halt (reserved-signal) s)))
      (eori-ins oplen ins s))))

;\ CMPI instruction.
(defn cmpi-addr-modep (ins)
  (and (data-addr-modep (s_mode ins) (s_rn ins))
       (not (idata-modep (s_mode ins) (s_rn ins)))))

(defn cmpi-mapping (idata oplen ins s)
  (let ((s&addr (mc-instate oplen ins s)))
    (if (mc-haltp (car s&addr))
        (car s&addr)
      (update-ccr (cmp-cvznx oplen
                             idata
                             (operand oplen (cdr s&addr) s)
                             (mc-ccr s))
                  (car s&addr)))))
          
(defn cmpi-ins (oplen ins s)
  (let ((s&idata (immediate oplen (mc-pc s) s)))
    (if (mc-haltp (car s&idata))
        (car s&idata)
      (if (cmpi-addr-modep ins)
          (cmpi-mapping (cddr s&idata) oplen ins (car s&idata))
        (halt (mode-signal) s)))))

;\ The CMPI subgroup includes only the CMPI instruction.
;\ Detect CAS and CAS2 instructions!
(defn cmpi-subgroup (oplen ins s)
  (if (equal oplen (q))
      (halt 'cas-cas2-unspecified s)
    (cmpi-ins oplen ins s)))

;\ Opcode 0000.
;\ This instruction group includes instructions ORI, ORI to CCR, BTST, BCLR,
;\ BCHG, BSET, MOVEP, ANDI, ANDI to CCR, SUBI, ADDI, EORI, EORI to CCR, CMPI.
(defn bit-group (ins s)
  (if (b0p (bitn ins 8))
      (if (b0p (bitn ins 11))
          (if (b0p (bitn ins 10))
              (if (b0p (bitn ins 9))
                  (ori-subgroup (op-len ins) ins s)
                (andi-subgroup (op-len ins) ins s))
            (if (b0p (bitn ins 9))
                (subi-subgroup (op-len ins) ins s)
              (addi-subgroup (op-len ins) ins s)))
        (if (b0p (bitn ins 10))
            (if (b0p (bitn ins 9))
                (s-bit-subgroup ins s)
              (eori-subgroup (op-len ins) ins s))
          (if (b0p (bitn ins 9))
              (cmpi-subgroup (op-len ins) ins s)
            (halt 'moves-cas-cas2-unspecified s))))
    (d-bit-subgroup ins s)))

;\ The opcode field.
(defn opcode-field (ins)
  (bits ins 12 15))

;\ Execute the current instruction.  See Table 3-14 of \cite{m20}
;\ for this classification.
(defn execute-ins (ins s)
  (let ((opcode (opcode-field ins)))
    (if (lessp opcode 8)
        (if (lessp opcode 4)
            (if (lessp opcode 2)
                (if (equal opcode 0)
                    (bit-group ins s)                         ; 0000
                  (move-ins (b) ins s))                       ; 0001
              (if (equal opcode 2)
                  (move-group (l) ins s)                      ; 0010
                (move-group (w) ins s)))                      ; 0011
          (if (lessp opcode 6)
              (if (equal opcode 4)
                  (misc-group ins s)                          ; 0100
                (scc-group ins s))                            ; 0101
            (if (equal opcode 6)
                (bcc-group (head ins (b)) ins s)              ; 0110
              (moveq-ins ins s))))                            ; 0111
      (if (lessp opcode 12)
          (if (lessp opcode 10)
              (if (equal opcode 8)
                  (or-group (op-len ins) ins s)               ; 1000
                (sub-group (opmode-field ins) ins s))         ; 1001
            (if (equal opcode 10)
                (halt (reserved-signal) s)                    ; 1010
              (cmp-group (op-len ins) ins s)))                ; 1011
        (if (lessp opcode 14)
            (if (equal opcode 12)
                (and-group (op-len ins) ins s)                ; 1100
              (add-group (opmode-field ins) ins s))           ; 1101
          (if (equal opcode 14)
              (s&r-group ins s)                               ; 1110
            (halt 'coprocessor-unspecified s))))))            ; 1111
 )

;\ !qcurrent-ins is a function of two arguments, !tpc and !ts.  !tpc is the
;\ current value of the program counter, and !ts is the current state.
;\ !qcurrent-ins returns the current instruction (a word, not including
;\ any possible extension words), that is, the word pointed to by pc.
;\ To determine what instruction we are to execute, this word may only
;\ provide partial information.  Many instructions require that we
;\ examine subsequent words to determine what to do.  But to figure out
;\ how many words we need, we must start with the first word.
(defn current-ins (pc s)
  (pc-word-read pc (mc-mem s)))

;\ \newpage \section{Stepi and Stepn}
;\ !qstepi maps a machine state to the next machine state by executing
;\ the current instruction.
(defn stepi (s)
  (if (evenp (mc-pc s))
      (if (pc-word-readp (mc-pc s) (mc-mem s))
          (execute-ins (current-ins (mc-pc s) s)
                       (update-pc (add (l) (mc-pc s) (wsz)) s))
        (halt (pc-signal) s))
    (halt (pc-odd-signal) s)))

;\ \label{stepn}!qstepn is a function of two arguments: !ts is the current state of the
;\ machine, and !tn is the number of instructions to execute.
(defn stepn (s n)
  (if (or (mc-haltp s) (zerop n))
      s
    (stepn (stepi s) (sub1 n)))
  ((lessp (count n))))

;\ \section{Auxiliary Functions}
;\ This section contains some auxiliary functions which are not needed
;\ to define !qstepn but are used only in the example of the next section.
;\ !qmap-update updates the map in the memory.  The !tmap is a binary tree
;\ with a list of keys in the key field.  By updating the map we assign 
;\ new properties to the memory.
(defn cons-key-lst (key lst)
  (if (member key lst)
      lst
    (cons key lst)))

(defn key-field (map)
  (if (listp map) (car map) nil))

(defn make-map (key map)
  (make-bt (cons-key-lst key (key-field map))
           (branch0 map)
           (branch1 map)))

(defn map-update (key x n map)
  (if (zerop n)
      (make-map key map)
    (if (b0p (bitn x (sub1 n)))
        (make-bt (key-field map)
                 (map-update key x (sub1 n) (branch0 map))
                 (branch1 map))
      (make-bt (key-field map)
               (branch0 map)
               (map-update key x (sub1 n) (branch1 map))))))

;\ Load the values in the list into the memory starting from location !taddr.
(defn load-lst-mem (opsz lst addr mem)
  (if (listp lst)
      (load-lst-mem opsz
                    (cdr lst)
                    (add 32 addr opsz)
                    (write-mem (car lst) addr mem opsz))
    mem))

(compile-uncompiled-defns "tmp")

;\ \newpage \section{An Example of Simulation}
;\ \label{example}

;\ Here is an utterly concrete theorem about !qstepn.  Roughly speaking, the
;\ theorem states that if !qstepn executes 37 instructions starting in a state
;\ that contains machine code instructions for Euclid's GCD algorithm in ROM and
;\ the integers 54 and 42 on the stack, then the correct answer, 6, is the value of
;\ data register d0 in the resulting state.  This theorem has, of course, an
;\ utterly trivial proof: we just run !qstepn .  We present this trivial theorem
;\ here only to illustrate setting up !qstepn to run.

(prove-lemma gcd-example nil
  (implies (and
	    (equal stack-pointer #XEFFFE40)
	    (equal rfile '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 #XEFFFE4C #XEFFFE40))
	    (equal pc #X22B6)
	    (equal ccr 0)
	    (equal gcd-code
		   '(78      86      0       0       72      231     48      0
		     36      46      0       8       38      46      0       12
		     74      130     103     28      74      131     102     4
		     32      2       96      22      182     130     108     8
		     76      67      40      0       36      0       96      232
		     76      66      56      0       38      0       96      224
		     32      3       76      238     0       12      255     248
		     78      94      78      117))
	    (equal empty-memory '((NIL (NIL (NIL (NIL (NIL ((ROM) NIL))))))))
	    (equal mem (load-lst-mem 4 '(#X22B2 54 42) stack-pointer
			     (load-lst-mem 1 gcd-code pc empty-memory)))
	    (equal initial-state (mc-state 'running rfile pc ccr mem))
	    (equal final-state (stepn initial-state 37)))
           (and (equal (mc-status final-state) 'running)
                (equal (mc-rfile final-state)
                       '(6 0 0 0 0 0 0 0 0 0 0 0 0 0 #XEFFFE4C #XEFFFE44))
                (equal (mc-pc final-state) #X22B2))))

;\ \bigskip Here is a paraphrase of the foregoing theorem.  The
;\ specific numbers in the theorem are derived from the compilation of
;\ a C program for GCD and from the result of loading that program on
;\ a Sun-3.
;\ \begin{itemize}
;\ \item If \begin{enumerate}
;\ \item !tstack-pointer = !t#XEFFFE40,
;\ \item the register file !trfile is all !v0's excepting for A6 and SP,
;\ which are !t#XEFFFE4C and !tstack-pointer, respectively,
;\ \item   the program counter !tpc = !t#X22B6 and the condition code register !tccr = !v0,
;\ \item  !tgcd-code is the long list of integers above beginning with !v78
;\ and ending with !v117,
;\ \item !tempty-memory is a pair representing a 32-bit wide memory
;\ which has a !t0 byte at every address, which is of type ROM from
;\ address !t#x0 to address !t#x07FFFFFF, and which is of type RAM at
;\ all other addresses,
;\ \item  !tmem is the result of first loading
;\ !tgcd-code into an empty memory at !tpc and then further loading the
;\ two natural numbers !v54 and !v42 and the return address of the
;\ caller (!t#X22B2) at the location pointed to by
;\ !tstack-pointer,
;\ \item  !tinitial-state is an mc-state whose five fields
;\ are !t'running, !trfile, !tpc, !tccr, and !tmem, respectively, and finally
;\ \item  !tfinal-state is the result of running !qstepn for
;\ !v37 instructions starting with !tinitial-state, \end{enumerate}
;\ \item then, if we examine !tfinal-state, we
;\ find:
;\ \begin{enumerate}
;\ \item the machine is still !t'running,
;\ \item the register file is !t'(6 0 0 0 0 0 0 0 0 0 0 0 0 0 #XEFFFE4C #XEFFFE44), observing that d0 is
;\ equal to !v6, the GCD of !v54 and !v42, and
;\ \item  the program counter is set to
;\ !t#X22B2, the return address to the caller. \end{enumerate} \end{itemize}

;\ This
;\ theorem should not be confused with the much more general theorem
;\ stating the correctness of the same GCD program on {\em all} input, a theorem
;\ whose mechanical proof is described in \cite{Boyer-Yu-91}.

(make-lib "mc20-1" t)

#|\ 
\newpage\section{Acknowledgements}

We would like to thank Bill Bevier, Don Good, Warren Hunt, Matt
Kaufmann, J Moore, and Bill Schelter for their many constructive
suggestions and discussions.  Special thanks to Fay Goytowski for her
meticulous reading of the MC68020 specification, which revealed a
dozen or so errors, and to Ken Albin for setting up a test suite for
our MC68020 model, which further revealed ??? errors. The general
style of Nqthm formalization used in this MC68020 specification is the
product of over a decade of study by the authors of Nqthm and their
students.  Especially influential was the FM8502 and Piton work
\cite{m:stack}.  The development of Nqthm was primarily supported by
NSF, ONR, and DARPA.

\newpage
\section{Syntax Summary}
\label{syntax}
        Here is a summary of the conventional syntax used in this report in terms of the official syntax
        of the Nqthm logic described in \cite{BM-88}.  (!qcond and !qlet are recent extensions not
        described in \cite{BM-88}.)

        \begin{enumerate}
        \item Variables.  {\it{x\/}}, {\it{y\/}}, {\it{z\/}}, etc. are printed in italics.

        \item Function application.  For any function symbol for which special
        syntax is not given below, an application of the symbol is printed with
        the usual notation; e.g., the term {\tt{(}}{\tt{fn}} {\tt{x}} {\tt{y}} {\tt{z}}{\tt{)}} is
        printed as {\rm{fn}}\,({\it{x\/}}, {\it{y\/}}, {\it{z\/}}).  Note that the function symbol is printed in
        Roman.  In the special case that `c' is a function symbol of no
        arguments, i.e., it is a constant, the term {\tt{(}}{\tt{c}}{\tt{)}} is printed merely as
        {\sc{c}}, in small caps, with no trailing parentheses.  Because variables are printed in
        italics, there is no confusion between the printing of variables and
        constants.

        \item Other constants.  {\bf{t}}, {\bf{f}}, and {\bf{nil}} are printed in bold.
        Quoted constants are printed in the ordinary fashion of the Nqthm logic,
        e.g., {\tt '(a b c)} is still printed just that way.  \verb+#b001+ is printed
        as ${\tt{001_{2}}}$, \verb+#o765+ is printed as ${\tt{765_{8}}}$, and \verb+#xA9+ is printed as
        ${\tt{A9_{16}}}$ .\item {\tt{(}}{\tt{if}} {\tt{x}} {\tt{y}} {\tt{z}}{\tt{)}} is printed as 

{\bf if }{\it{x\/}} {\bf then }{\it{y\/}} {\bf else }{\it{z\/}}$\;${\bf  endif}.

\item {\tt{(}}{\tt{cond}} {\tt{(}}{\tt{test1}} {\tt{value1}}{\tt{)}} {\tt{(}}{\tt{test2}} {\tt{value2}}{\tt{)}} {\tt{(}}{\tt{t}} {\tt{value3}}{\tt{)}}{\tt{)}} is printed as 

{\bf if }{\it{test1\/}} {\bf then }{\it{value1\/}} {\bf elseif }{\it{test2\/}} {\bf then }{\it{value2\/}} {\bf else }{\it{value3\/}}$\;${\bf  endif}.

\item {\tt{(}}{\tt{let}} {\tt{(}}{\tt{(}}{\tt{var1}} {\tt{val1}}{\tt{)}} {\tt{(}}{\tt{var2}} {\tt{val2}}{\tt{)}}{\tt{)}} {\tt{form}}{\tt{)}} is printed as 

{\bf let }{\it{var1\/}}{\bf $\;$ be$\;$}{\it{val1\/}}, {\it{var2\/}}{\bf $\;$ be$\;$}{\it{val2\/}} {\bf in} {\it{form\/}}$\;${\bf  endlet}.

\item  The remaining function symbols that are printed specially are
               described in the following table.

\end{enumerate}

\begin{tabular}{|c|c|}\hline
Nqthm Syntax &  Conventional Syntax \\ \hline \hline{\tt{(}}{\tt{or}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\vee$ {\it{y\/}} \\  
{\tt{(}}{\tt{and}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\wedge$ {\it{y\/}} \\  
{\tt{(}}{\tt{times}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $*$ {\it{y\/}} \\  
{\tt{(}}{\tt{plus}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $+$ {\it{y\/}} \\  
{\tt{(}}{\tt{remainder}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} ${\rm\bf{mod}}$ {\it{y\/}} \\  
{\tt{(}}{\tt{quotient}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\div$ {\it{y\/}} \\  
{\tt{(}}{\tt{difference}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $-$ {\it{y\/}} \\  
{\tt{(}}{\tt{implies}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\rightarrow$ {\it{y\/}} \\  
{\tt{(}}{\tt{member}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\in$ {\it{y\/}} \\  
{\tt{(}}{\tt{geq}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\geq$ {\it{y\/}} \\  
{\tt{(}}{\tt{greaterp}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $>$ {\it{y\/}} \\  
{\tt{(}}{\tt{leq}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $\leq$ {\it{y\/}} \\  
{\tt{(}}{\tt{lessp}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $<$ {\it{y\/}} \\  
{\tt{(}}{\tt{equal}} {\tt{x}} {\tt{y}}{\tt{)}}&{\it{x\/}} $=$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{member}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\in$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{geq}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\geq$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{greaterp}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not>$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{leq}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\leq$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{lessp}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not<$ {\it{y\/}} \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{equal}} {\tt{x}} {\tt{y}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not=$ {\it{y\/}} \\  
{\tt{(}}{\tt{minus}} {\tt{x}}{\tt{)}}&$-$ {\it{x\/}} \\  
{\tt{(}}{\tt{add1}} {\tt{x}}{\tt{)}}&$1\;+$ {\it{x\/}} \\  
{\tt{(}}{\tt{nlistp}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\simeq {\rm{\bf{nil}}}$ \\  
{\tt{(}}{\tt{zerop}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\simeq 0$ \\  
{\tt{(}}{\tt{numberp}} {\tt{x}}{\tt{)}}&{\it{x\/}} $\in {\rm\bf{N}}$ \\  
{\tt{(}}{\tt{sub1}} {\tt{x}}{\tt{)}}&{\it{x\/}} $-\;1$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{nlistp}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\simeq {\rm{\bf{nil}}}$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{zerop}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\simeq 0$ \\  
{\tt{(}}{\tt{not}} {\tt{(}}{\tt{numberp}} {\tt{x}}{\tt{)}}{\tt{)}}&{\it{x\/}} $\not\in {\rm\bf{N}}$ \\  
  \hline \end{tabular}

\newpage

\begin{thebibliography}{99}

\bibitem{m:stack} William~Bevier, J~Strother~Moore, Warren~Hunt, and William
Young.  Special issue on system verification.  {\em Journal of Automated
Reasoning}, 5(4), 1989.

\bibitem{BM-88} Robert S. Boyer and J Strother Moore. {\em A Computational
Logic Handbook}. Academic Press, 1988.

\bibitem{Boyer-Yu-91} Robert S. Boyer and Yuan Yu.  Automated Correctness
Proofs of Machine Code Programs for a Commercial Microprocessor, Technical
Report TR-91-33, University of Texas at Austin, to appear in the proceedings of
the 11th International Conference on Automated Deduction, Lecture Notes in
Computer Science, Springer-Verlag, 1992.

\bibitem{m20} Motorola, Inc.  {\em MC68020 32-bit Microprocessor User's
Manual}.  Prentice Hall, New Jersey, 1989.

\end{thebibliography}

\newpage
\addcontentsline{toc}{section}{Index}
|#
