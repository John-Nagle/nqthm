#|

 Copyright (C) 1994 by Yuan Yu.  All Rights Reserved.

 This script is hereby placed in the public domain, and therefore unlimited
 editing and redistribution is permitted.

 NO WARRANTY

 Yuan Yu PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS PROVIDED "AS IS"
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT
 LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Yuan Yu BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST PROFITS,
 LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
 OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
 PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH DAMAGES, OR
 FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "strncmp" t)

;          Proof of the Correctness of the STRSTR Function
#|
This is part of our effort to verify the Berkeley string library.  The 
Berkeley string library is widely used as part of the Berkeley Unix OS.

This is the source code of strstr function in the Berkeley string library.

/* find pointer to first occurrence of find[] in s[] */
char *
strstr(s, find)
	register const char *s, *find;
{
	register char c, sc;
	register size_t len;

	if ((c = *find++) != 0) {
		len = strlen(find);
		do {
			do {
				if ((sc = *s++) == 0)
					return (NULL);
			} while (sc != c);
		} while (strncmp(s, find, len) != 0);
		s--;
	}
	return ((char *)s);
}

The MC68020 assembly code of the C function strstr on SUN-3 is given as 
follows.  This binary is generated by "gcc -O".

0x2718 <strstr>:        linkw fp,#0
0x271c <strstr+4>:      moveml d2-d3/a2-a3,sp@-
0x2720 <strstr+8>:      moveal fp@(8),a2
0x2724 <strstr+12>:     moveal fp@(12),a3
0x2728 <strstr+16>:     moveb a3@+,d2
0x272a <strstr+18>:     beq 0x275a <strstr+66>
0x272c <strstr+20>:     movel a3,sp@-
0x272e <strstr+22>:     jsr @#0x25b0 <strlen>
0x2734 <strstr+28>:     movel d0,d3
0x2736 <strstr+30>:     addqw #4,sp
0x2738 <strstr+32>:     moveb a2@+,d0
0x273a <strstr+34>:     bne 0x2740 <strstr+40>
0x273c <strstr+36>:     clrl d0
0x273e <strstr+38>:     bra 0x275c <strstr+68>
0x2740 <strstr+40>:     cmpb d0,d2
0x2742 <strstr+42>:     bne 0x2738 <strstr+32>
0x2744 <strstr+44>:     movel d3,sp@-
0x2746 <strstr+46>:     movel a3,sp@-
0x2748 <strstr+48>:     movel a2,sp@-
0x274a <strstr+50>:     jsr @#0x2608 <strncmp>
0x2750 <strstr+56>:     addaw #12,sp
0x2754 <strstr+60>:     tstl d0
0x2756 <strstr+62>:     bne 0x2738 <strstr+32>
0x2758 <strstr+64>:     subqw #1,a2
0x275a <strstr+66>:     movel a2,d0
0x275c <strstr+68>:     moveml fp@(-16),d2-d3/a2-a3
0x2762 <strstr+74>:     unlk fp
0x2764 <strstr+76>:     rts

The machine code of the above program is:

<strstr>:      0x4e56  0x0000  0x48e7  0x3030  0x246e  0x0008  0x266e  0x000c
<strstr+16>:   0x141b  0x672e  0x2f0b  0x4eb9  0x0000  0x25b0  0x2600  0x584f
<strstr+32>:   0x101a  0x6604  0x4280  0x601c  0xb400  0x66f4  0x2f03  0x2f0b
<strstr+48>:   0x2f0a  0x4eb9  0x0000  0x2608  0xdefc  0x000c  0x4a80  0x66e0
<strstr+64>:   0x534a  0x200a  0x4cee  0x0c0c  0xfff0  0x4e5e  0x4e75

'(78      86      0       0       72      231     48      48
  36      110     0       8       38      110     0       12
  20      27      103     46      47      11      78      185
  0       0       37      176     38      0       88      79
  16      26      102     4       66      128     96      28
  180     0       102     244     47      3       47      11
  47      10      78      185     0       0       38      8
  222     252     0       12      74      128     102     224
  83      74      32      10      76      238     12      12
  255     240     78      94      78      117)
|#

; in the logic, the above program is defined by (strstr-code).
(defn strstr-code ()
  '(78      86      0       0       72      231     48      48
    36      110     0       8       38      110     0       12
    20      27      103     46      47      11      78      185
    -1      -1      -1      -1      38      0       88      79
    16      26      102     4       66      128     96      28
    180     0       102     244     47      3       47      11
    47      10      78      185     -1      -1      -1      -1
    222     252     0       12      74      128     102     224
    83      74      32      10      76      238     12      12
    255     240     78      94      78      117))

(constrain strstr-load (rewrite)
   (equal (strstr-loadp s)
	  (and (evenp (strstr-addr))
	       (numberp (strstr-addr))
	       (nat-rangep (strstr-addr) 32)
	       (rom-addrp (strstr-addr) (mc-mem s) 78)
	       (mcode-addrp (strstr-addr) (mc-mem s) (strstr-code))
	       (strlen-loadp s)
	       (strncmp-loadp s)
	       (equal (pc-read-mem (add 32 (strstr-addr) 24) (mc-mem s) 4)
		      (strlen-addr))
	       (equal (pc-read-mem (add 32 (strstr-addr) 52) (mc-mem s) 4)
		      (strncmp-addr))))
   ((strstr-loadp (lambda (s) f))
    (strstr-addr (lambda () 1))))

(prove-lemma stepn-strstr-loadp (rewrite)
     (equal (strstr-loadp (stepn s n))
            (strstr-loadp s)))

; the computation time of the program.
(defn strstr-t0 (n2 lst2)
  (splus 8 (splus (strlen-t (sub1 n2) (cdr lst2)) 2)))

(defn strstr-t1 (i n1 lst1 lst2)
  (if (lessp i n1)
      (if (equal (get-nth i lst1) 0)
	  7
	(if (equal (get-nth i lst1) (get-nth 0 lst2))
	    8
	  (splus 4 (strstr-t1 (add1 i) n1 lst1 lst2))))
    0)
  ((lessp (difference n1 i))))

(defn strstr-t2 (i n1 lst1 lst2 len)
  (let ((j (strchr1 i n1 lst1 (get-nth 0 lst2))))
    (if (numberp j)
	(if (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
	    (splus (strstr-t1 i n1 lst1 lst2) 
		   (splus (strncmp-t len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 
			  8))
	  (splus (strstr-t1 i n1 lst1 lst2)
		 (splus (strncmp-t len (mcdr (add1 j) lst1) (mcdr 1 lst2))
			3)))
      (strstr-t1 i n1 lst1 lst2))))

(defn strstr-t3 (i n1 lst1 lst2 len)
  (if (lessp i n1)
      (let ((j (strchr1 i n1 lst1 (get-nth 0 lst2))))
	(if (numberp j)
	    (if (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
		(strstr-t2 i n1 lst1 lst2 len)
	      (splus (strstr-t2 i n1 lst1 lst2 len)
		     (strstr-t3 (add1 j) n1 lst1 lst2 len)))
	  (strstr-t1 i n1 lst1 lst2)))
    0)
  ((lessp (difference n1 i))))

(defn strstr-t (n1 lst1 n2 lst2)
  (if (equal (get-nth 0 lst2) 0)
      10
    (splus (strstr-t0 n2 lst2)
	   (strstr-t3 0 n1 lst1 lst2 (strlen 0 (sub1 n2) (mcdr 1 lst2))))))

; two induction hints.
(defn strstr-induct1 (s i* i n1 lst1 lst2)
  (if (lessp i n1)
      (if (equal (get-nth i lst1) 0)
	  t
	(if (equal (get-nth i lst1) (get-nth 0 lst2))
	    t
	  (strstr-induct1 (stepn s 4) (add 32 i* 1) (add1 i) n1 lst1 lst2)))
    t)
  ((lessp (difference n1 i))))

(defn strstr-induct2 (s i* i n1 lst1 lst2 len)
  (if (lessp i n1)
      (let ((j* (strchr1* i* i n1 lst1 (get-nth 0 lst2)))
	    (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
        (if (numberp j)
            (if (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
                t
	      (strstr-induct2 (stepn s (strstr-t2 i n1 lst1 lst2 len))
			      (add 32 j* 1) (add1 j) n1 lst1 lst2 len))
	  t))
    t)
  ((lessp (difference n1 i))))
  
; the preconditions of the initial state.
(defn strstr-statep (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (strstr-addr))
       (ram-addrp (sub 32 48 (read-sp s)) (mc-mem s) 60)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str1 n1 (sub 32 48 (read-sp s)) 60)
       (disjoint str2 n2 (sub 32 48 (read-sp s)) 60)
       (equal str1 (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal str2 (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (lessp (slen 0 n1 lst1) n1)
       (lessp (slen 0 n2 lst2) n2)
       (not (equal (nat-to-uint str1) 0))
       (not (zerop n1))
       (uint-rangep (plus (nat-to-uint str1) n1) 32)
       (not (zerop n2))
       (uint-rangep n2 32)))

; the intermediate state right before the call to strlen.
(defn strstr-s0p (s str1 n1 lst1 str2 n2 lst2)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (strlen-addr))
       (equal (rts-addr s) (add 32 (strstr-addr) 28))
       (ram-addrp (sub 32 44 (read-an 32 6 s)) (mc-mem s) 60)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str1 n1 (sub 32 44 (read-an 32 6 s)) 60)
       (disjoint str2 n2 (sub 32 44 (read-an 32 6 s)) 60)
       (equal str1 (read-an 32 2 s))
       (equal (nat-to-uint (read-dn 8 2 s)) (get-nth 0 lst2))
       (equal* (read-an 32 3 s) (add 32 str2 1))
       (equal* (read-sp s) (sub 32 24 (read-an 32 6 s)))
       (equal (read-an 32 3 s) (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (lessp (slen 0 n1 lst1) n1)
       (lessp (slen 1 n2 lst2) n2)
       (not (zerop n1))
       (uint-rangep n1 32)
       (not (zerop n2))
       (uint-rangep n2 32)))

; the intermediate state returned from the call to strlen.
(defn strstr-s1p (s str1 n1 lst1 str2 n2 lst2 len)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (add 32 (strstr-addr) 28))
       (ram-addrp (sub 32 44 (read-an 32 6 s)) (mc-mem s) 60)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str1 n1 (sub 32 44 (read-an 32 6 s)) 60)
       (disjoint str2 n2 (sub 32 44 (read-an 32 6 s)) 60)
       (equal str1 (read-an 32 2 s))
       (equal (nat-to-uint (read-dn 8 2 s)) (get-nth 0 lst2))
       (equal* (read-an 32 3 s) (add 32 str2 1))
       (equal* (read-sp s) (sub 32 20 (read-an 32 6 s)))
       (equal len (uread-dn 32 0 s))
       (lessp (slen 0 n1 lst1) n1)
       (lessp (slen 1 n2 lst2) n2)
       (numberp n1)
       (uint-rangep n1 32)
       (numberp n2)
       (uint-rangep n2 32)))

; the intermediate state right before the outer loop.
(defn strstr-s2p (s i* i str1 n1 lst1 str2 n2 lst2 len)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (add 32 (strstr-addr) 32))
       (ram-addrp (sub 32 44 (read-an 32 6 s)) (mc-mem s) 60)       
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str1 n1 (sub 32 44 (read-an 32 6 s)) 60)
       (disjoint str2 n2 (sub 32 44 (read-an 32 6 s)) 60)
       (equal (uread-dn 8 2 s) (get-nth 0 lst2))
       (equal* (read-an 32 2 s) (add 32 str1 i*))
       (equal* (read-an 32 3 s) (add 32 str2 1))
       (equal* (read-sp s) (sub 32 16 (read-an 32 6 s)))
       (equal len (uread-dn 32 3 s))
       (lessp (slen i n1 lst1) n1)
       (lessp (slen 1 n2 lst2) n2)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n1))
       (uint-rangep n1 32)
       (not (zerop n2))
       (uint-rangep n2 32)))

; the intermediate state right before the call to strncmp.
(defn strstr-s3p (s i* i str1 n1 lst1 str2 n2 lst2 len)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (strncmp-addr))
       (equal (rts-addr s) (add 32 (strstr-addr) 56))
       (ram-addrp (sub 32 44 (read-an 32 6 s)) (mc-mem s) 60)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint (sub 32 44 (read-an 32 6 s)) 60 str1 n1)
       (disjoint (sub 32 44 (read-an 32 6 s)) 60 str2 n2)
       (equal (uread-dn 8 2 s) (get-nth 0 lst2))
       (equal* (read-an 32 2 s) (add 32 str1 i*))
       (equal* (read-an 32 3 s) (add 32 str2 1))
       (equal* (read-sp s) (sub 32 32 (read-an 32 6 s)))
       (equal len (uread-dn 32 3 s))
       (equal (read-an 32 2 s) (read-mem (add 32 (read-sp s) 4) (mc-mem s) 4))
       (equal (read-an 32 3 s) (read-mem (add 32 (read-sp s) 8) (mc-mem s) 4))
       (equal (read-dn 32 3 s) (read-mem (add 32 (read-sp s) 12) (mc-mem s) 4))
       (lessp (slen i n1 lst1) n1)
       (lessp (slen 1 n2 lst2) n2)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n1))
       (uint-rangep n1 32)
       (not (zerop n2))
       (uint-rangep n2 32)))

; the intermediate state right after the call to strncmp.
(defn strstr-s4p (s i* i str1 n1 lst1 str2 n2 lst2 len)
  (and (equal (mc-status s) 'running)
       (strstr-loadp s)
       (equal (mc-pc s) (add 32 (strstr-addr) 56))
       (ram-addrp (sub 32 44 (read-an 32 6 s)) (mc-mem s) 60)
       (ram-addrp str1 (mc-mem s) n1)
       (mem-lst 1 str1 (mc-mem s) n1 lst1)
       (ram-addrp str2 (mc-mem s) n2)
       (mem-lst 1 str2 (mc-mem s) n2 lst2)
       (disjoint str1 n1 (sub 32 44 (read-an 32 6 s)) 60)
       (disjoint str2 n2 (sub 32 44 (read-an 32 6 s)) 60)
       (equal (iread-dn 32 0 s) (strncmp len (mcdr i lst1) (mcdr 1 lst2)))
       (equal (uread-dn 8 2 s) (get-nth 0 lst2))
       (equal* (read-an 32 2 s) (add 32 str1 i*))
       (equal* (read-an 32 3 s) (add 32 str2 1))
       (equal* (read-sp s) (sub 32 28 (read-an 32 6 s)))
       (equal len (uread-dn 32 3 s))
       (lessp (slen i n1 lst1) n1)
       (lessp (slen 1 n2 lst2) n2)
       (numberp i*)
       (nat-rangep i* 32)
       (equal i (nat-to-uint i*))
       (not (zerop n1))
       (uint-rangep n1 32)
       (not (zerop n2))
       (uint-rangep n2 32)))

; from the initial state to exit:  s --> sn, when lst2[0] == 0.
(prove-lemma strstr-s-sn (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst2) 0))
	      (and (equal (mc-status (stepn s 10)) 'running)
		   (equal (mc-pc (stepn s 10)) (rts-addr s))
		   (equal (read-dn 32 0 (stepn s 10)) str1)
		   (equal (read-rn 32 15 (mc-rfile (stepn s 10)))
			  (add 32 (read-an 32 7 s) 4))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 10))) 
			  (read-an 32 6 s)))))

(prove-lemma strstr-s-sn-rfile (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst2) 0)
		   (leq oplen 32)
		   (d2-7a2-5p rn))		   
	      (equal (read-rn oplen rn (mc-rfile (stepn s 10)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strstr-s-sn-mem (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (equal (get-nth 0 lst2) 0)
		   (disjoint x k (sub 32 48 (read-sp s)) 60))
	      (equal (read-mem x (mc-mem (stepn s 10)) k)
		     (read-mem x (mc-mem s) k))))

; from the initial state to s0.  s --> s0.
(prove-lemma strstr-s-s0 ()
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst2) 0)))		   
	      (strstr-s0p (stepn s 8) str1 n1 lst1 str2 n2 lst2)))

(prove-lemma strstr-s-s0-else (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst2) 0)))		   
	      (and (equal (linked-rts-addr (stepn s 8)) (rts-addr s))
                   (equal (linked-a6 (stepn s 8)) (read-an 32 6 s))
                   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
                          (sub 32 4 (read-sp s)))
                   (equal (movem-saved (stepn s 8) 4 16 4)
			  (readm-rn 32 '(2 3 10 11) (mc-rfile s))))))

(prove-lemma strstr-s-s0-rfile (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst2) 0))
		   (d4-7a4-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strstr-s-s0-mem (rewrite)
     (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		   (not (equal (get-nth 0 lst2) 0))
		   (disjoint x k (sub 32 48 (read-sp s)) 60))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

; from s0 to s1:  s0 --> s1.  by strlen.
(prove-lemma strstr-s0p-strlen-statep ()
     (implies (strstr-s0p s str1 n1 lst1 str2 n2 lst2)
	      (strlen-statep s (add 32 str2 1) (sub1 n2) (mcdr 1 lst2))))

(prove-lemma strstr-s0-s1 ()
     (let ((s1 (stepn s (strlen-t (sub1 n2) (mcdr 1 lst2)))))
       (implies (strstr-s0p s str1 n1 lst1 str2 n2 lst2)
		(strstr-s1p s1 str1 n1 lst1 str2 n2 lst2 
			    (strlen 0 (sub1 n2) (mcdr 1 lst2)))))
     ((use (strstr-s0p-strlen-statep))
      (disable strlen-statep strlen-load strncmp-load uread-dn)))

(prove-lemma strstr-s0-s1-else (rewrite)
     (let ((s1 (stepn s (strlen-t (sub1 n2) (cdr lst2)))))
       (implies (strstr-s0p s str1 n1 lst1 str2 n2 lst2)
		(and (equal (read-rn 32 14 (mc-rfile s1))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-rts-addr s1) (linked-rts-addr s))
		     (equal (linked-a6 s1) (linked-a6 s))
		     (equal (movem-saved s1 4 16 4)
			    (movem-saved s 4 16 4)))))
     ((use (strstr-s0p-strlen-statep))
      (disable strlen-statep strstr-load)))

(prove-lemma strstr-s0-s1-rfile (rewrite)
     (let ((s1 (stepn s (strlen-t (sub1 n2) (cdr lst2)))))
       (implies (and (strstr-s0p s str1 n1 lst1 str2 n2 lst2)
		     (d2-7a2-5p rn))
		(equal (read-rn oplen rn (mc-rfile s1))
		       (read-rn oplen rn (mc-rfile s)))))
     ((use (strstr-s0p-strlen-statep))
      (disable strstr-s0p strlen-statep)))

(prove-lemma strstr-s0-s1-mem (rewrite)
     (let ((s1 (stepn s (strlen-t (sub1 n2) (cdr lst2)))))
       (implies (and (strstr-s0p s str1 n1 lst1 str2 n2 lst2)
		     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
		(equal (read-mem x (mc-mem s1) k)
		       (read-mem x (mc-mem s) k))))
     ((use (strstr-s0p-strlen-statep))
      (disable strlen-statep strstr-load)))

; from s1 to s2:  s1 --> s2.
(prove-lemma strstr-s1-s2 (rewrite)
     (implies (strstr-s1p s str1 n1 lst1 str2 n2 lst2 len)
	      (strstr-s2p (stepn s 2) 0 0 str1 n1 lst1 str2 n2 lst2 len)))

(prove-lemma strstr-s1-s2-else (rewrite)
     (implies (strstr-s1p s str1 n1 lst1 str2 n2 lst2 len)
	      (and (equal (linked-rts-addr (stepn s 2)) (linked-rts-addr s))
		   (equal (linked-a6 (stepn s 2)) (linked-a6 s))
		   (equal (read-rn oplen 14 (mc-rfile (stepn s 2)))
			  (read-rn oplen 14 (mc-rfile s)))
		   (equal (movem-saved (stepn s 2) 4 16 4)
			  (movem-saved s 4 16 4))
		   (equal (read-mem x (mc-mem (stepn s 2)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strstr-s1-s2-rfile (rewrite)
     (implies (and (strstr-s1p s str1 n1 lst1 str2 n2 lst2 len)
		   (d4-7a4-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 2)))
		     (read-rn oplen rn (mc-rfile s)))))

; from s2 to exit:  s2 --> sn, when lst1[i] == 0.
(prove-lemma strstr-s2-sn-base (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (equal (get-nth i lst1) 0))
              (and (equal (mc-status (stepn s 7)) 'running)
                   (equal (mc-pc (stepn s 7)) 
			  (linked-rts-addr s))
                   (equal (read-dn 32 0 (stepn s 7)) 0)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 7)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 7)))
			  (add 32 (read-an 32 6 s) 8))		   
                   (equal (read-mem x (mc-mem (stepn s 7)) k)
                          (read-mem x (mc-mem s) k)))))

(prove-lemma strstr-s2-sn-base-rfile (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (equal (get-nth i lst1) 0)
		   (d2-7a2-5p rn)
		   (leq oplen 32))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 7)))
		     (if (d4-7a4-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3 10 11)
                                 (movem-saved s 4 16 4))))))

; from s2 to s3:  s2 --> s3, when lst1[i] =\= 0 and lst1[i] == lst2[0].
(prove-lemma strstr-s2-s3-base (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (get-nth i lst1) 0))
		   (equal (get-nth i lst1) (get-nth 0 lst2)))
	      (and (strstr-s3p (stepn s 8) (add 32 i* 1) (add1 i) str1 n1 lst1
			       str2 n2 lst2 len)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-a6 (stepn s 8)) (linked-a6 s))
		   (equal (linked-rts-addr (stepn s 8)) (linked-rts-addr s))
		   (equal (movem-saved (stepn s 8) 4 16 4)
			  (movem-saved s 4 16 4)))))

(prove-lemma strstr-s2-s3-base-rfile (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (get-nth i lst1) 0))
		   (equal (get-nth i lst1) (get-nth 0 lst2))
		   (d4-7a4-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (read-rn oplen rn (mc-rfile s)))))

(prove-lemma strstr-s2-s3-base-mem (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (get-nth i lst1) 0))
		   (equal (get-nth i lst1) (get-nth 0 lst2))
		   (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
	      (equal (read-mem x (mc-mem (stepn s 8)) k)
		     (read-mem x (mc-mem s) k))))

; from s2 to s2:  s2 --> s2.
(prove-lemma strstr-s2-s2 (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (get-nth i lst1) 0))
		   (not (equal (get-nth i lst1) (get-nth 0 lst2))))
	      (and (strstr-s2p (stepn s 4) (add 32 i* 1) (add1 i) str1 n1
			       lst1 str2 n2 lst2 len)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 4)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-rts-addr (stepn s 4)) (linked-rts-addr s))
		   (equal (rts-addr (stepn s 4)) (rts-addr s))
		   (equal (movem-saved (stepn s 4) 4 16 4)
			  (movem-saved s 4 16 4))
		   (equal (read-mem x (mc-mem (stepn s 4)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strstr-s2-s2-rfile (rewrite)
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (get-nth i lst1) 0))
		   (not (equal (get-nth i lst1) (get-nth 0 lst2)))
		   (d4-7a4-5p rn))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 4)))
		     (read-rn oplen rn (mc-rfile s)))))

; from s3 to s4:  s3 --> s4. The call to strncmp.
(prove-lemma strstr-s3p-strncmp-statep ()
     (implies (strstr-s3p s i* i str1 n1 lst1 str2 n2 lst2 len)
	      (strncmp-statep s (add 32 str1 i*) (difference n1 i) 
			      (mcdr i lst1) (add 32 str2 1) (sub1 n2) 
			      (mcdr 1 lst2) len)))

(prove-lemma strstr-s3-s4 ()
     (let ((s4 (stepn s (strncmp-t len (mcdr i lst1) (mcdr 1 lst2)))))
       (implies (strstr-s3p s i* i str1 n1 lst1 str2 n2 lst2 len)
		(strstr-s4p s4 i* i str1 n1 lst1 str2 n2 lst2 len)))
     ((use (strstr-s3p-strncmp-statep))
      (disable strncmp-statep strlen-load strncmp-load iread-dn)))

(prove-lemma strstr-s3-s4-else (rewrite)
     (let ((s4 (stepn s (strncmp-t len (mcdr i lst1) (mcdr 1 lst2)))))
       (implies (strstr-s3p s i* i str1 n1 lst1 str2 n2 lst2 len)
		(and (equal (read-rn 32 14 (mc-rfile s4))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-rts-addr s4) (linked-rts-addr s))
		     (equal (linked-a6 s4) (linked-a6 s))
		     (equal (movem-saved s4 4 16 4)
			    (movem-saved s 4 16 4)))))
     ((use (strstr-s3p-strncmp-statep))
      (disable strncmp-statep strstr-load)))

(prove-lemma strstr-s3-s4-rfile (rewrite)
     (let ((s4 (stepn s (strncmp-t len (mcdr i lst1) (mcdr 1 lst2)))))
       (implies (and (strstr-s3p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile s4))
		       (read-rn oplen rn (mc-rfile s)))))
     ((use (strstr-s3p-strncmp-statep))
      (disable strncmp-statep strstr-s3p)))

(prove-lemma strstr-s3-s4-mem (rewrite)
     (let ((s4 (stepn s (strncmp-t len (mcdr i lst1) (mcdr 1 lst2)))))
       (implies (and (strstr-s3p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
		(equal (read-mem x (mc-mem s4) k)
		       (read-mem x (mc-mem s) k))))
     ((use (strstr-s3p-strncmp-statep))
      (disable strncmp-statep strlen-load strncmp-load)))

; from s4 to exit:  s4 --> sn, when strncmp == 0.
(prove-lemma strstr-s4-sn (rewrite)
     (implies (and (strstr-s4p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (equal (strncmp len (mcdr i lst1) (mcdr 1 lst2)) 0))
	      (and (equal (mc-status (stepn s 8)) 'running)
                   (equal (mc-pc (stepn s 8)) (linked-rts-addr s))
		   (equal (read-dn 32 0 (stepn s 8)) 
			  (add 32 str1 (sub 32 1 i*)))
		   (equal (read-rn 32 14 (mc-rfile (stepn s 8)))
			  (linked-a6 s))
		   (equal (read-rn 32 15 (mc-rfile (stepn s 8)))
			  (add 32 (read-an 32 6 s) 8))
		   (equal (read-mem x (mc-mem (stepn s 8)) k)
                          (read-mem x (mc-mem s) k))))
     ((disable strncmp)))

(prove-lemma strstr-s4-sn-rfile (rewrite)
     (implies (and (strstr-s4p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (equal (strncmp len (mcdr i lst1) (mcdr 1 lst2)) 0)
		   (d2-7a2-5p rn)
		   (leq oplen 32))
	      (equal (read-rn oplen rn (mc-rfile (stepn s 8)))
		     (if (d4-7a4-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3 10 11)
                                 (movem-saved s 4 16 4)))))
     ((disable strncmp)))

; from s4 to s2: s4 --> s2, when strncmp =\= 0.
(prove-lemma strstr-s4-s2 (rewrite)
     (implies (and (strstr-s4p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (strncmp len (mcdr i lst1) (mcdr 1 lst2)) 0)))
	      (and (strstr-s2p (stepn s 3) i* i str1 n1 lst1 str2 n2 lst2 len)
		   (equal (read-rn 32 14 (mc-rfile (stepn s 3)))
			  (read-rn 32 14 (mc-rfile s)))
		   (equal (linked-rts-addr (stepn s 3)) (linked-rts-addr s))
		   (equal (linked-a6 (stepn s 3)) (linked-a6 s))
		   (equal (movem-saved (stepn s 3) 4 16 4)
			  (movem-saved s 4 16 4))
		   (equal (read-mem x (mc-mem (stepn s 3)) k)
			  (read-mem x (mc-mem s) k)))))

(prove-lemma strstr-s4-s2-rfile (rewrite)
     (implies (and (strstr-s4p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (not (equal (strncmp len (mcdr i lst1) (mcdr 1 lst2)) 0))
                   (d4-7a4-5p rn))
              (equal (read-rn oplen rn (mc-rfile (stepn s 3)))
		     (read-rn oplen rn (mc-rfile s)))))

; put together: s2 --> s3.
(prove-lemma strstr-s2p-info (rewrite)
     (implies (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	      (and (numberp i)
		   (equal (lessp i n1) t))))
		   
(prove-lemma strstr-s2-s3 ()
     (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		   (numberp (strchr1 i n1 lst1 (get-nth 0 lst2))))
	      (strstr-s3p (stepn s (strstr-t1 i n1 lst1 lst2))
			  (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1)
			  (add1 (strchr1 i n1 lst1 (get-nth 0 lst2)))
			  str1 n1 lst1 str2 n2 lst2 len))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p strstr-s3p)))

(prove-lemma strstr-s2-s3-else (rewrite)
     (let ((s3 (stepn s (strstr-t1 i n1 lst1 lst2))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (numberp (strchr1 i n1 lst1 (get-nth 0 lst2))))
		(and (equal (read-rn 32 14 (mc-rfile s3))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (linked-rts-addr s3) (linked-rts-addr s))
		     (equal (linked-a6 s3) (linked-a6 s))
		     (equal (movem-saved s3 4 16 4) (movem-saved s 4 16 4)))))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p)))

(prove-lemma strstr-s2-s3-rfile (rewrite)
     (let ((s3 (stepn s (strstr-t1 i n1 lst1 lst2))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (numberp (strchr1 i n1 lst1 (get-nth 0 lst2)))
		     (d4-7a4-5p rn))
		(equal (read-rn oplen rn (mc-rfile s3))
		       (read-rn oplen rn (mc-rfile s)))))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p)))

(prove-lemma strstr-s2-s3-mem (rewrite)
     (let ((s3 (stepn s (strstr-t1 i n1 lst1 lst2))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (numberp (strchr1 i n1 lst1 (get-nth 0 lst2)))
		     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
		(equal (read-mem x (mc-mem s3) k)
		       (read-mem x (mc-mem s) k))))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p)))
		      
; put together: s2 --> exit.
(prove-lemma strstr-s2-sn (rewrite)
     (let ((sn (stepn s (strstr-t1 i n1 lst1 lst2))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (not (numberp (strchr1 i n1 lst1 (get-nth 0 lst2)))))
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (linked-rts-addr s))
		     (equal (read-dn 32 0 sn) 0)
		     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-an 32 6 s) 8))
		     (equal (read-mem x (mc-mem sn) k)
			    (read-mem x (mc-mem s) k)))))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p read-dn)))

(prove-lemma strstr-s2-sn-rfile (rewrite)
     (let ((sn (stepn s (strstr-t1 i n1 lst1 lst2))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (not (numberp (strchr1 i n1 lst1 (get-nth 0 lst2))))
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		     (if (d4-7a4-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3 10 11)
                                 (movem-saved s 4 16 4))))))
     ((induct (strstr-induct1 s i* i n1 lst1 lst2))
      (disable strstr-s2p)))

; put together: s --> s1.
(prove-lemma strstr-s-s2 ()
     (let ((s2 (stepn s (strstr-t0 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (not (equal (get-nth 0 lst2) 0)))		   
	      (strstr-s2p s2 0 0 str1 n1 lst1 str2 n2 lst2 
			  (strlen 0 (sub1 n2) (mcdr 1 lst2)))))
     ((use (strstr-s-s0) (strstr-s0-s1 (s (stepn s 8))))
      (disable strstr-statep strstr-s0p strstr-s1p strstr-s2p)))

(prove-lemma strstr-s-s2-else (rewrite)
     (let ((s2 (stepn s (strstr-t0 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (not (equal (get-nth 0 lst2) 0)))		   
		(and (equal (linked-rts-addr s2) (rts-addr s))
		     (equal (linked-a6 s2) (read-an 32 6 s))
		     (equal (read-rn 32 14 (mc-rfile s2))
			    (sub 32 4 (read-sp s)))
		     (equal (movem-saved s2 4 16 4)
			    (readm-rn 32 '(2 3 10 11) (mc-rfile s))))))
     ((use (strstr-s-s0) (strstr-s0-s1 (s (stepn s 8))))
      (disable strstr-statep strstr-s0p strstr-s1p strstr-s2p linked-rts-addr
	       rts-addr linked-a6 movem-saved strlen)))

(prove-lemma strstr-s-s2-rfile (rewrite)
     (let ((s2 (stepn s (strstr-t0 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (not (equal (get-nth 0 lst2) 0))
		     (d4-7a4-5p rn))
		(equal (read-rn oplen rn (mc-rfile s2))
		       (read-rn oplen rn (mc-rfile s)))))
     ((use (strstr-s-s0) (strstr-s0-s1 (s (stepn s 8))))
      (disable strstr-statep strstr-s0p strstr-s1p strstr-s2p strlen)))

(prove-lemma strstr-s-s2-mem (rewrite)
     (let ((s2 (stepn s (strstr-t0 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (not (equal (get-nth 0 lst2) 0))
		     (disjoint x k (sub 32 48 (read-sp s)) 60))
		(equal (read-mem x (mc-mem s2) k)
		       (read-mem x (mc-mem s) k))))
     ((use (strstr-s-s0) (strstr-s0-s1 (s (stepn s 8))))
      (disable strstr-statep strstr-s0p strstr-s1p strstr-s2p strlen)))     

; put together: s2 --> s2.
(prove-lemma strstr-s2-s2-1 (rewrite)
     (let ((s2 (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j* (strchr1* i* i n1 lst1 (get-nth 0 lst2)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (not (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)))
	(and (strstr-s2p s2 (add 32 j* 1) (add1 j) str1 n1 lst1
			 str2 n2 lst2 len)
	     (equal (read-rn 32 14 (mc-rfile s2)) (read-rn 32 14 (mc-rfile s)))
	     (equal (linked-rts-addr s2) (linked-rts-addr s))
	     (equal (linked-a6 s2) (linked-a6 s))
	     (equal (movem-saved s2 4 16 4) (movem-saved s 4 16 4)))))
     ((use (strstr-s2-s3) 
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p linked-rts-addr
	       rts-addr linked-a6 movem-saved mcdr)))   

(prove-lemma strstr-s2-s2-rfile-1 (rewrite)
     (let ((s2 (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (not (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0))
	     (leq oplen 32)
	     (d4-7a4-5p rn))
	(equal (read-rn oplen rn (mc-rfile s2))
	       (read-rn oplen rn (mc-rfile s)))))
     ((use (strstr-s2-s3) 
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p mcdr)))

(prove-lemma strstr-s2-s2-mem-1 (rewrite)
     (let ((s2 (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (not (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0))
	     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
	(equal (read-mem x (mc-mem s2) k) (read-mem x (mc-mem s) k))))
     ((use (strstr-s2-s3)
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p mcdr)))

; put together: s2 --> sn.
(prove-lemma strstr-s2-sn-base-1 (rewrite)
     (let ((sn (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j* (strchr1* i* i n1 lst1 (get-nth 0 lst2)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0))
	(and (equal (mc-status sn) 'running)
	     (equal (mc-pc sn) (linked-rts-addr s))
	     (equal (read-dn 32 0 sn) (add 32 str1 j*))
	     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
	     (equal (read-rn 32 15 (mc-rfile sn))
		    (add 32 (read-an 32 6 s) 8)))))
     ((use (strstr-s2-s3) 
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p linked-rts-addr
	       rts-addr linked-a6 movem-saved mcdr read-dn)))   

(prove-lemma strstr-s2-sn-base-rfile-1 (rewrite)
     (let ((sn (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
	     (leq oplen 32)
	     (d2-7a2-5p rn))
	(equal (read-rn oplen rn (mc-rfile sn))
	       (if (d4-7a4-5p rn)
		   (read-rn oplen rn (mc-rfile s))
		 (get-vlst oplen 0 rn '(2 3 10 11) (movem-saved s 4 16 4))))))
     ((use (strstr-s2-s3) 
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p mcdr)))

(prove-lemma strstr-s2-sn-base-mem-1 (rewrite)
     (let ((sn (stepn s (strstr-t2 i n1 lst1 lst2 len)))
	   (j (strchr1 i n1 lst1 (get-nth 0 lst2))))
       (implies 
	(and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	     (numberp j)
	     (equal (strncmp len (mcdr (add1 j) lst1) (mcdr 1 lst2)) 0)
	     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
	(equal (read-mem x (mc-mem sn) k) (read-mem x (mc-mem s) k))))
     ((use (strstr-s2-s3)
	   (strstr-s3-s4 
	    (s (stepn s (strstr-t1 i n1 lst1 lst2)))
	    (i* (add 32 (strchr1* i* i n1 lst1 (get-nth 0 lst2)) 1))
	    (i (add1 (strchr1 i n1 lst1 (get-nth 0 lst2))))))
      (disable strstr-s2p strstr-s3p strstr-s4p mcdr)))

; put together: s2 --> sn.
(prove-lemma strstr-s2-sn-2 (rewrite)
     (let ((sn (stepn s (strstr-t3 i n1 lst1 lst2 len))))
       (implies 
	(strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
	(and (equal (mc-status sn) 'running)
	     (equal (mc-pc sn) (linked-rts-addr s))
	     (equal (read-dn 32 0 sn)
		    (if (strstr1 i n1 lst1 n2 lst2 len)
			(add 32 str1 (strstr1* i* i n1 lst1 n2 lst2 len))
		      0))
	     (equal (read-rn 32 14 (mc-rfile sn)) (linked-a6 s))
	     (equal (read-rn 32 15 (mc-rfile sn))
		    (add 32 (read-an 32 6 s) 8)))))
     ((induct (strstr-induct2 s i* i n1 lst1 lst2 len))
      (disable strstr-s2p strchr1 strstr-t2 read-dn)))

(prove-lemma strstr-s2-sn-rfile-2 (rewrite)
     (let ((sn (stepn s (strstr-t3 i n1 lst1 lst2 len))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (d2-7a2-5p rn)
		     (leq oplen 32))
		(equal (read-rn oplen rn (mc-rfile sn))
		     (if (d4-7a4-5p rn)
			 (read-rn oplen rn (mc-rfile s))
		       (get-vlst oplen 0 rn '(2 3 10 11)
                                 (movem-saved s 4 16 4))))))
     ((induct (strstr-induct2 s i* i n1 lst1 lst2 len))
      (disable strstr-s2p strchr1 strstr-t2)))     

(prove-lemma strstr-s2-sn-mem-2 (rewrite)
     (let ((sn (stepn s (strstr-t3 i n1 lst1 lst2 len))))
       (implies (and (strstr-s2p s i* i str1 n1 lst1 str2 n2 lst2 len)
		     (disjoint x k (sub 32 44 (read-an 32 6 s)) 60))
		(equal (read-mem x (mc-mem sn) k)
		       (read-mem x (mc-mem s) k))))
     ((induct (strstr-induct2 s i* i n1 lst1 lst2 len))
      (disable strstr-s2p strchr1 strstr-t2)))

(disable strstr-s2p-info)

; the correctness of strstr.
(prove-lemma strstr-statep-info (rewrite)
     (implies (strstr-statep s str1 n1 lst1 str2 n2 lst2)
	      (and (numberp str1)
		   (nat-rangep str1 32))))

(prove-lemma strstr-correctness (rewrite)
     (let ((sn (stepn s (strstr-t n1 lst1 n2 lst2))))
       (implies (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		(and (equal (mc-status sn) 'running)
		     (equal (mc-pc sn) (rts-addr s))
		     (equal (read-rn 32 14 (mc-rfile sn))
			    (read-rn 32 14 (mc-rfile s)))
		     (equal (read-rn 32 15 (mc-rfile sn))
			    (add 32 (read-sp s) 4))
		     (implies (and (d2-7a2-5p rn)
				   (leq oplen 32))
			      (equal (read-rn oplen rn (mc-rfile sn))
				     (read-rn oplen rn (mc-rfile s))))
		     (implies (disjoint x k (sub 32 48 (read-sp s)) 60)
			      (equal (read-mem x (mc-mem sn) k)
				     (read-mem x (mc-mem s) k)))
		     (equal (read-dn 32 0 sn)
			    (if (strstr n1 lst1 n2 lst2)
				(add 32 str1 (strstr* n1 lst1 n2 lst2))
			      0)))))
     ((use (strstr-s-s2))
      (disable strstr-statep strstr-s2p strstr-t0 strlen strstr1 strstr1*
	       linked-rts-addr linked-a6 read-dn)))

(disable strstr-statep-info)
(disable strstr-t)

; strstr* --> strstr.
(prove-lemma strchr1*-strchr1 (rewrite)
     (implies (and (strchr1 i n lst ch)
		   (equal i (nat-to-uint i*))
		   (nat-rangep i* 32)
		   (uint-rangep n 32))
	      (equal (nat-to-uint (strchr1* i* i n lst ch))
		     (strchr1 i n lst ch)))
     ((induct (strchr1* i* i n lst ch))))

(prove-lemma strstr*-strstr (rewrite)
     (implies (and (strstr1 i n1 lst1 n2 lst2 len)
		   (equal i (nat-to-uint i*))
		   (nat-rangep i* 32)
		   (uint-rangep n1 32))
	      (equal (nat-to-uint (strstr1* i* i n1 lst1 n2 lst2 len))
		     (strstr1 i n1 lst1 n2 lst2 len)))
     ((induct (strstr1* i* i n1 lst1 n2 lst2 len))
      (enable nat-rangep-la)))

(prove-lemma strstr-non-zerop-la ()
     (let ((sn (stepn s (strstr-t n1 lst1 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (nat-rangep str1 32)
		     (not (equal (nat-to-uint str1) 0))
		     (uint-rangep (plus (nat-to-uint str1) n1) 32)
		     (numberp str1)
		     (strstr n1 lst1 n2 lst2))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((enable nat-rangep-la)
      (disable strstr-statep read-dn)))

(prove-lemma strstr-non-zerop (rewrite)
     (let ((sn (stepn s (strstr-t n1 lst1 n2 lst2))))
       (implies (and (strstr-statep s str1 n1 lst1 str2 n2 lst2)
		     (strstr n1 lst1 n2 lst2))
	      (not (equal (nat-to-uint (read-dn 32 0 sn)) 0))))
     ((use (strstr-non-zerop-la))))

(disable strstr*)

; some properties of strstr.
; see the file cstring.events.
