#|
     Copyright (C) 1990-1994 Computational Logic, Inc.  All Rights
     Reserved.

                        FM9001 PUBLIC SOFTWARE LICENSE
                          Computational Logic, Inc.
                          1717 West Sixth, Suite 290
                           Austin, Texas 78703-4776

Please  read this license carefully before using the FM9001 Software. By using
the FM9001 Software, you are agreeing  to  be  bound  by  the  terms  of  this
license. If you do not agree to the terms of this license, promptly return the
FM9001 Software to the place where you obtained it.

The FM9001 Software was developed by Computational Logic, Inc.(CLI).  You  own
the  disk  or  other  medium on which the FM9001 Software is recorded, but CLI
retains title to the FM9001 Software.  The purposes of  this  license  are  to
identify  the  FM9001  Software and to make the FM9001 Software, including its
source code, freely  available.    This  license  allows  you  to  use,  copy,
distribute  and  modify  the FM9001 Software, on the condition that you comply
with all the Copying Policies set out below.

COPYING POLICIES

1. You may copy and distribute verbatim copies of the FM9001 Software  as  you
receive  it,  in  any  medium,  including  embedding it verbatim in derivative
works, provided that you a) conspicuously and appropriately  publish  on  each
copy a valid copyright notice "Copyright (C) 1990-1994 by Computational Logic,
Inc. All Rights Reserved.", b) keep intact on all files the notices that refer
to  this License Agreement and to the absence of any warranty, and c) give all
recipients of the FM9001 Software a copy of this License Agreement along  with
the program.

2. You may modify your copy or copies of the FM9001 Software or any portion of
it, and copy and distribute such modifications provided  you  tell  recipients
that  what they have is a modification by your organization of the CLI version
of the FM9001 Software.

3. You may incorporate parts  of  the  FM9001  Software  into  other  programs
provided  that  you  acknowledge  Computational  Logic  Inc.  in  the  program
documentation.

CLI also requests, but does not require, that any improvements  or  extensions
to the FM9001 Software be returned to one of the addresses below, so that they
may be shared with other FM9001 users.  The  FM9001  Software,  including  its
source, can be obtained by contacting one of these addresses.

    Software-Request                 or     Software-Request@CLI.COM
    Computational Logic Inc.
    1717 West Sixth, Suite 290
    Austin, TX 78703-4776

NO WARRANTY

BECAUSE  THE FM9001 SOFTWARE IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
NO WARRANTY.  THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF  ANY  KIND,
EITHER  EXPRESS  OR  IMPLIED,  INCLUDING,  BUT  NOT  LIMITED  TO,  ANY IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS  FOR  A  PARTICULAR  PURPOSE.    THE
ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
SHOULD THE FM9001 SOFTWARE  PROVE  DEFECTIVE,  YOU  ASSUME  THE  COST  OF  ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN  NO  EVENT  WILL COMPUTATIONAL LOGIC INC. BE LIABLE TO YOU FOR ANY DAMAGES,
ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL  OR  CONSEQUENTIAL
DAMAGES  ARISING  OUT  OF  THE  USE  OR  INABILITY  TO USE THE FM9001 SOFTWARE
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING  RENDERED  INACCURATE
OR  LOSSES  SUSTAINED  BY  THIRD  PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(BOOT-STRAP NQTHM)

(SETQ REDUCE-TERM-CLOCK 2000)

(DEFN DELETE
      (X L)
      (IF (LISTP L)
          (IF (EQUAL X (CAR L))
              (CDR L)
              (CONS (CAR L) (DELETE X (CDR L))))
          L))

(DEFN BAGDIFF
      (X Y)
      (IF (LISTP Y)
          (IF (MEMBER (CAR Y) X)
              (BAGDIFF (DELETE (CAR Y) X) (CDR Y))
              (BAGDIFF X (CDR Y)))
          X))

(DEFN BAGINT
      (X Y)
      (IF (LISTP X)
          (IF (MEMBER (CAR X) Y)
              (CONS (CAR X)
                    (BAGINT (CDR X) (DELETE (CAR X) Y)))
              (BAGINT (CDR X) Y))
          NIL))

(DEFN OCCURRENCES
      (X L)
      (IF (LISTP L)
          (IF (EQUAL X (CAR L))
              (ADD1 (OCCURRENCES X (CDR L)))
              (OCCURRENCES X (CDR L)))
          0))

(DEFN SUBBAGP
      (X Y)
      (IF (LISTP X)
          (IF (MEMBER (CAR X) Y)
              (SUBBAGP (CDR X) (DELETE (CAR X) Y))
              F)
          T))

(PROVE-LEMMA LISTP-DELETE
             (REWRITE)
             (EQUAL (LISTP (DELETE X L))
                    (IF (LISTP L)
                        (OR (NOT (EQUAL X (CAR L)))
                            (LISTP (CDR L)))
                        F))
             ((ENABLE DELETE)
              (INDUCT (DELETE X L))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE LISTP-DELETE-OFF LISTP-DELETE T)

(PROVE-LEMMA DELETE-NON-MEMBER
             (REWRITE)
             (IMPLIES (NOT (MEMBER X Y))
                      (EQUAL (DELETE X Y) Y))
             ((ENABLE DELETE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DELETE-DELETE
             (REWRITE)
             (EQUAL (DELETE Y (DELETE X Z))
                    (DELETE X (DELETE Y Z)))
             ((ENABLE DELETE DELETE-NON-MEMBER)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-OCCURRENCES-ZERO
             (REWRITE)
             (EQUAL (EQUAL (OCCURRENCES X L) 0)
                    (NOT (MEMBER X L)))
             ((ENABLE OCCURRENCES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA MEMBER-NON-LIST
             (REWRITE)
             (IMPLIES (NOT (LISTP L))
                      (NOT (MEMBER X L)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA MEMBER-DELETE
             (REWRITE)
             (EQUAL (MEMBER X (DELETE Y L))
                    (IF (MEMBER X L)
                        (IF (EQUAL X Y)
                            (LESSP 1 (OCCURRENCES X L))
                            T)
                        F))
             ((ENABLE DELETE OCCURRENCES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA MEMBER-DELETE-IMPLIES-MEMBERSHIP
             (REWRITE)
             (IMPLIES (MEMBER X (DELETE Y L))
                      (MEMBER X L))
             ((ENABLE DELETE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA OCCURRENCES-DELETE
             (REWRITE)
             (EQUAL (OCCURRENCES X (DELETE Y L))
                    (IF (EQUAL X Y)
                        (IF (MEMBER X L)
                            (SUB1 (OCCURRENCES X L))
                            0)
                        (OCCURRENCES X L)))
             ((ENABLE OCCURRENCES DELETE EQUAL-OCCURRENCES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA MEMBER-BAGDIFF
             (REWRITE)
             (EQUAL (MEMBER X (BAGDIFF A B))
                    (LESSP (OCCURRENCES X B)
                           (OCCURRENCES X A)))
             ((ENABLE BAGDIFF OCCURRENCES EQUAL-OCCURRENCES-ZERO
                      OCCURRENCES-DELETE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA BAGDIFF-DELETE
             (REWRITE)
             (EQUAL (BAGDIFF (DELETE E X) Y)
                    (DELETE E (BAGDIFF X Y)))
             ((ENABLE BAGDIFF DELETE DELETE-DELETE DELETE-NON-MEMBER
                      MEMBER-BAGDIFF MEMBER-DELETE OCCURRENCES-DELETE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA SUBBAGP-DELETE
             (REWRITE)
             (IMPLIES (SUBBAGP X (DELETE U Y))
                      (SUBBAGP X Y))
             ((ENABLE DELETE SUBBAGP DELETE-DELETE
                      MEMBER-DELETE-IMPLIES-MEMBERSHIP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA SUBBAGP-CDR1
             (REWRITE)
             (IMPLIES (SUBBAGP X Y)
                      (SUBBAGP (CDR X) Y))
             ((ENABLE SUBBAGP SUBBAGP-DELETE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA SUBBAGP-CDR2
             (REWRITE)
             (IMPLIES (SUBBAGP X (CDR Y))
                      (SUBBAGP X Y))
             ((ENABLE DELETE SUBBAGP DELETE-NON-MEMBER SUBBAGP-CDR1)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA SUBBAGP-BAGINT1
             (REWRITE)
             (SUBBAGP (BAGINT X Y) X)
             ((ENABLE DELETE SUBBAGP BAGINT SUBBAGP-CDR2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA SUBBAGP-BAGINT2
             (REWRITE)
             (SUBBAGP (BAGINT X Y) Y)
             ((ENABLE SUBBAGP BAGINT SUBBAGP-CDR2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA OCCURRENCES-BAGINT
             (REWRITE)
             (EQUAL (OCCURRENCES X (BAGINT A B))
                    (IF (LESSP (OCCURRENCES X A)
                               (OCCURRENCES X B))
                        (OCCURRENCES X A)
                        (OCCURRENCES X B)))
             ((ENABLE OCCURRENCES BAGINT EQUAL-OCCURRENCES-ZERO
                      OCCURRENCES-DELETE)))

(PROVE-LEMMA OCCURRENCES-BAGDIFF
             (REWRITE)
             (EQUAL (OCCURRENCES X (BAGDIFF A B))
                    (DIFFERENCE (OCCURRENCES X A)
                                (OCCURRENCES X B)))
             ((ENABLE OCCURRENCES BAGDIFF EQUAL-OCCURRENCES-ZERO
                      OCCURRENCES-DELETE)))

(PROVE-LEMMA MEMBER-BAGINT
             (REWRITE)
             (EQUAL (MEMBER X (BAGINT A B))
                    (AND (MEMBER X A) (MEMBER X B)))
             ((ENABLE BAGINT MEMBER-DELETE)))

(DEFTHEORY BAGS
           (OCCURRENCES-BAGINT BAGDIFF-DELETE OCCURRENCES-BAGDIFF
                               MEMBER-BAGINT MEMBER-BAGDIFF SUBBAGP-BAGINT2
                               SUBBAGP-BAGINT1 SUBBAGP-CDR2 SUBBAGP-CDR1
                               SUBBAGP-DELETE))

(PROVE-LEMMA EQUAL-PLUS-0
             (REWRITE)
             (EQUAL (EQUAL (PLUS A B) 0)
                    (AND (ZEROP A) (ZEROP B)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-CANCELLATION
             (REWRITE)
             (EQUAL (EQUAL (PLUS A B) (PLUS A C))
                    (EQUAL (FIX B) (FIX C)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE PLUS-CANCELLATION-OFF PLUS-CANCELLATION T)

(PROVE-LEMMA EQUAL-DIFFERENCE-0
             (REWRITE)
             (AND (EQUAL (EQUAL (DIFFERENCE X Y) 0)
                         (NOT (LESSP Y X)))
                  (EQUAL (EQUAL 0 (DIFFERENCE X Y))
                         (NOT (LESSP Y X))))
             ((INDUCT (DIFFERENCE X Y))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-CANCELLATION
             (REWRITE)
             (EQUAL (EQUAL (DIFFERENCE X Y)
                           (DIFFERENCE Z Y))
                    (COND ((LESSP X Y) (NOT (LESSP Y Z)))
                          ((LESSP Z Y) (NOT (LESSP Y X)))
                          (T (EQUAL (FIX X) (FIX Z)))))
             ((ENABLE EQUAL-DIFFERENCE-0)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFFERENCE-CANCELLATION-OFF DIFFERENCE-CANCELLATION T)

(PROVE-LEMMA COMMUTATIVITY-OF-PLUS
             (REWRITE)
             (EQUAL (PLUS X Y) (PLUS Y X))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-PLUS
             (REWRITE)
             (EQUAL (PLUS X Y Z) (PLUS Y X Z))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-ZERO-ARG2
             (REWRITE)
             (IMPLIES (ZEROP Y)
                      (EQUAL (PLUS X Y) (FIX X)))
             ((INDUCT (PLUS X Y))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-ADD1-ARG1
             (REWRITE)
             (EQUAL (PLUS (ADD1 A) B)
                    (ADD1 (PLUS A B)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-ADD1-ARG2
             (REWRITE)
             (EQUAL (PLUS X (ADD1 Y))
                    (IF (NUMBERP Y)
                        (ADD1 (PLUS X Y))
                        (ADD1 X)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-PLUS
             (REWRITE)
             (EQUAL (PLUS (PLUS X Y) Z)
                    (PLUS X Y Z))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-DIFFERENCE-ARG1
             (REWRITE)
             (EQUAL (PLUS (DIFFERENCE A B) C)
                    (IF (LESSP B A)
                        (DIFFERENCE (PLUS A C) B)
                        (PLUS 0 C)))
             ((INDUCT (DIFFERENCE A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-DIFFERENCE-ARG2
             (REWRITE)
             (EQUAL (PLUS A (DIFFERENCE B C))
                    (IF (LESSP C B)
                        (DIFFERENCE (PLUS A B) C)
                        (PLUS A 0)))
             ((INDUCT (PLUS A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-PLUS-CANCELLATION-PROOF NIL
             (EQUAL (DIFFERENCE (PLUS X Y) X)
                    (FIX Y))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-PLUS-CANCELLATION
             (REWRITE)
             (AND (EQUAL (DIFFERENCE (PLUS X Y) X)
                         (FIX Y))
                  (EQUAL (DIFFERENCE (PLUS Y X) X)
                         (FIX Y)))
             ((USE (DIFFERENCE-PLUS-CANCELLATION-PROOF (X X)
                                                       (Y Y)))
              (ENABLE COMMUTATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFFERENCE-PLUS-CANCELLATION-OFF DIFFERENCE-PLUS-CANCELLATION T)

(PROVE-LEMMA DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF NIL
             (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                    (DIFFERENCE Y Z))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-PLUS-PLUS-CANCELLATION
             (REWRITE)
             (AND (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                         (DIFFERENCE Y Z))
                  (EQUAL (DIFFERENCE (PLUS Y X) (PLUS X Z))
                         (DIFFERENCE Y Z))
                  (EQUAL (DIFFERENCE (PLUS X Y) (PLUS Z X))
                         (DIFFERENCE Y Z))
                  (EQUAL (DIFFERENCE (PLUS Y X) (PLUS Z X))
                         (DIFFERENCE Y Z)))
             ((USE (DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF (X X)
                                                            (Y Y)
                                                            (Z Z)))
              (ENABLE COMMUTATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFFERENCE-PLUS-PLUS-CANCELLATION-OFF DIFFERENCE-PLUS-PLUS-CANCELLATION
        T)

(PROVE-LEMMA DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK
             (REWRITE)
             (EQUAL (DIFFERENCE (PLUS W X A) (PLUS Y Z A))
                    (DIFFERENCE (PLUS W X) (PLUS Y Z)))
             ((ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY2-OF-PLUS
                      DIFFERENCE-PLUS-PLUS-CANCELLATION)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK-OFF
        DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK T)

(PROVE-LEMMA DIFF-SUB1-ARG2
             (REWRITE)
             (EQUAL (DIFFERENCE A (SUB1 B))
                    (COND ((ZEROP B) (FIX A))
                          ((LESSP A B) 0)
                          (T (ADD1 (DIFFERENCE A B)))))
             ((INDUCT (DIFFERENCE A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFF-SUB1-ARG2-OFF DIFF-SUB1-ARG2 T)

(PROVE-LEMMA DIFF-DIFF-ARG1
             (REWRITE)
             (EQUAL (DIFFERENCE (DIFFERENCE X Y) Z)
                    (DIFFERENCE X (PLUS Y Z)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFF-DIFF-ARG2
             (REWRITE)
             (EQUAL (DIFFERENCE A (DIFFERENCE B C))
                    (IF (LESSP B C)
                        (FIX A)
                        (DIFFERENCE (PLUS A C) B)))
             ((ENABLE DIFF-SUB1-ARG2 PLUS-ZERO-ARG2)
              (INDUCT (DIFFERENCE A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFF-DIFF-DIFF
             (REWRITE)
             (IMPLIES (AND (IF (LESSP A B) F T)
                           (IF (LESSP C D) F T))
                      (EQUAL (DIFFERENCE (DIFFERENCE A B)
                                         (DIFFERENCE C D))
                             (DIFFERENCE (PLUS A D) (PLUS B C))))
             ((ENABLE DIFF-DIFF-ARG1 DIFF-DIFF-ARG2 PLUS-DIFFERENCE-ARG2
                      PLUS-ZERO-ARG2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFF-DIFF-DIFF-OFF DIFF-DIFF-DIFF T)

(PROVE-LEMMA DIFFERENCE-LESSP-ARG1
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (EQUAL (DIFFERENCE A B) 0))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE DIFFERENCE-LESSP-ARG1-OFF DIFFERENCE-LESSP-ARG1 T)

(DEFN PLUS-FRINGE
      (X)
      (IF (AND (LISTP X) (EQUAL (CAR X) 'PLUS))
          (APPEND (PLUS-FRINGE (CADR X))
                  (PLUS-FRINGE (CADDR X)))
          (LIST X)))

(DEFN PLUS-TREE
      (L)
      (COND ((NLISTP L) ''0)
            ((NLISTP (CDR L))
             (LIST 'FIX (CAR L)))
            ((NLISTP (CDDR L))
             (LIST 'PLUS (CAR L) (CADR L)))
            (T (LIST 'PLUS
                     (CAR L)
                     (PLUS-TREE (CDR L))))))

(PROVE-LEMMA NUMBERP-EVAL$-PLUS
             (REWRITE)
             (IMPLIES (AND (LISTP X) (EQUAL (CAR X) 'PLUS))
                      (NUMBERP (EVAL$ T X A)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE NUMBERP-EVAL$-PLUS-OFF NUMBERP-EVAL$-PLUS T)

(PROVE-LEMMA NUMBERP-EVAL$-PLUS-TREE
             (REWRITE)
             (NUMBERP (EVAL$ T (PLUS-TREE L) A))
             ((ENABLE PLUS-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE NUMBERP-EVAL$-PLUS-TREE-OFF NUMBERP-EVAL$-PLUS-TREE T)

(PROVE-LEMMA MEMBER-IMPLIES-PLUS-TREE-GREATEREQP
             (REWRITE)
             (IMPLIES (MEMBER X Y)
                      (NOT (LESSP (EVAL$ T (PLUS-TREE Y) A)
                                  (EVAL$ T X A))))
             ((ENABLE PLUS-TREE PLUS-ZERO-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE MEMBER-IMPLIES-PLUS-TREE-GREATEREQP-OFF
        MEMBER-IMPLIES-PLUS-TREE-GREATEREQP T)

(PROVE-LEMMA PLUS-TREE-DELETE
             (REWRITE)
             (EQUAL (EVAL$ T (PLUS-TREE (DELETE X Y)) A)
                    (IF (MEMBER X Y)
                        (DIFFERENCE (EVAL$ T (PLUS-TREE Y) A)
                                    (EVAL$ T X A))
                        (EVAL$ T (PLUS-TREE Y) A)))
             ((ENABLE DELETE PLUS-TREE DELETE-NON-MEMBER
                      DIFFERENCE-PLUS-CANCELLATION EQUAL-DIFFERENCE-0
                      EQUAL-PLUS-0 LISTP-DELETE
                      MEMBER-IMPLIES-PLUS-TREE-GREATEREQP
                      NUMBERP-EVAL$-PLUS-TREE PLUS-ZERO-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE PLUS-TREE-DELETE-OFF PLUS-TREE-DELETE T)

(PROVE-LEMMA SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP
             (REWRITE)
             (IMPLIES (SUBBAGP X Y)
                      (NOT (LESSP (EVAL$ T (PLUS-TREE Y) A)
                                  (EVAL$ T (PLUS-TREE X) A))))
             ((ENABLE PLUS-TREE SUBBAGP MEMBER-IMPLIES-PLUS-TREE-GREATEREQP
                      PLUS-TREE-DELETE PLUS-ZERO-ARG2 SUBBAGP-CDR2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP-OFF
        SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP T)

(PROVE-LEMMA PLUS-TREE-BAGDIFF
             (REWRITE)
             (IMPLIES (SUBBAGP X Y)
                      (EQUAL (EVAL$ T (PLUS-TREE (BAGDIFF Y X)) A)
                             (DIFFERENCE (EVAL$ T (PLUS-TREE Y) A)
                                         (EVAL$ T (PLUS-TREE X) A))))
             ((ENABLE BAGDIFF PLUS-TREE SUBBAGP COMMUTATIVITY-OF-PLUS
                      DIFF-DIFF-ARG1 DIFFERENCE-LESSP-ARG1
                      MEMBER-IMPLIES-PLUS-TREE-GREATEREQP
                      NUMBERP-EVAL$-PLUS-TREE PLUS-TREE-DELETE PLUS-ZERO-ARG2
                      SUBBAGP-CDR2 SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE PLUS-TREE-BAGDIFF-OFF PLUS-TREE-BAGDIFF T)

(PROVE-LEMMA NUMBERP-EVAL$-BRIDGE
             (REWRITE)
             (IMPLIES (EQUAL (EVAL$ T Z A)
                             (EVAL$ T (PLUS-TREE X) A))
                      (NUMBERP (EVAL$ T Z A)))
             ((ENABLE PLUS-TREE NUMBERP-EVAL$-PLUS-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE NUMBERP-EVAL$-BRIDGE-OFF NUMBERP-EVAL$-BRIDGE T)

(PROVE-LEMMA BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP
             (REWRITE)
             (IMPLIES (AND (SUBBAGP Y (PLUS-FRINGE Z))
                           (EQUAL (EVAL$ T Z A)
                                  (EVAL$ T
                                         (PLUS-TREE (PLUS-FRINGE Z))
                                         A)))
                      (EQUAL (LESSP (EVAL$ T Z A)
                                    (EVAL$ T (PLUS-TREE Y) A))
                             F))
             ((ENABLE SUBBAGP PLUS-FRINGE PLUS-TREE
                      SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP-OFF
        BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP T)

(PROVE-LEMMA EVAL$-PLUS-TREE-APPEND
             (REWRITE)
             (EQUAL (EVAL$ T (PLUS-TREE (APPEND X Y)) A)
                    (PLUS (EVAL$ T (PLUS-TREE X) A)
                          (EVAL$ T (PLUS-TREE Y) A)))
             ((ENABLE PLUS-ZERO-ARG2 COMMUTATIVITY2-OF-PLUS
                      COMMUTATIVITY-OF-PLUS EQUAL-PLUS-0 PLUS-CANCELLATION
                      PLUS-TREE NUMBERP-EVAL$-PLUS-TREE NUMBERP-EVAL$-BRIDGE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-PLUS-TREE-APPEND-OFF EVAL$-PLUS-TREE-APPEND T)

(PROVE-LEMMA PLUS-TREE-PLUS-FRINGE
             (REWRITE)
             (EQUAL (EVAL$ T
                           (PLUS-TREE (PLUS-FRINGE X))
                           A)
                    (FIX (EVAL$ T X A)))
             ((ENABLE PLUS-ZERO-ARG2 COMMUTATIVITY-OF-PLUS PLUS-FRINGE
                      PLUS-TREE NUMBERP-EVAL$-PLUS NUMBERP-EVAL$-BRIDGE
                      EVAL$-PLUS-TREE-APPEND)
              (INDUCT (PLUS-FRINGE X))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE PLUS-TREE-PLUS-FRINGE-OFF PLUS-TREE-PLUS-FRINGE T)

(PROVE-LEMMA MEMBER-IMPLIES-NUMBERP
             (REWRITE)
             (IMPLIES (AND (MEMBER C (PLUS-FRINGE X))
                           (NUMBERP (EVAL$ T C A)))
                      (NUMBERP (EVAL$ T X A)))
             ((ENABLE PLUS-FRINGE NUMBERP-EVAL$-PLUS)
              (INDUCT (PLUS-FRINGE X))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE MEMBER-IMPLIES-NUMBERP-OFF MEMBER-IMPLIES-NUMBERP T)

(PROVE-LEMMA CADR-EVAL$-LIST
             (REWRITE)
             (AND (EQUAL (CAR (EVAL$ 'LIST X A))
                         (EVAL$ T (CAR X) A))
                  (EQUAL (CDR (EVAL$ 'LIST X A))
                         (IF (LISTP X)
                             (EVAL$ 'LIST (CDR X) A)
                             0)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE CADR-EVAL$-LIST-OFF CADR-EVAL$-LIST T)

(PROVE-LEMMA EVAL$-QUOTE
             (REWRITE)
             (EQUAL (EVAL$ T (CONS 'QUOTE ARGS) A)
                    (CAR ARGS))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-QUOTE-OFF EVAL$-QUOTE T)

(PROVE-LEMMA LISTP-EVAL$
             (REWRITE)
             (EQUAL (LISTP (EVAL$ 'LIST X A))
                    (LISTP X))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE LISTP-EVAL$-OFF LISTP-EVAL$ T)

(DEFN CANCEL-EQUAL-PLUS
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'EQUAL))
          (COND ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS))
                 (LIST 'EQUAL
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADDR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))))
                ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (MEMBER (CADDR X)
                              (PLUS-FRINGE (CADR X))))
                 (LIST 'IF
                       (LIST 'NUMBERP (CADDR X))
                       (CONS 'EQUAL
                             (CONS (PLUS-TREE (DELETE (CADDR X)
                                                      (PLUS-FRINGE (CADR X))))
                                   '('0)))
                       (LIST 'QUOTE F)))
                ((AND (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS)
                      (MEMBER (CADR X)
                              (PLUS-FRINGE (CADDR X))))
                 (LIST 'IF
                       (LIST 'NUMBERP (CADR X))
                       (LIST 'EQUAL
                             ''0
                             (PLUS-TREE (DELETE (CADR X)
                                                (PLUS-FRINGE (CADDR X)))))
                       (LIST 'QUOTE F)))
                (T X))
          X))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-EQUAL-PLUS
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-EQUAL-PLUS X) A))
             ((ENABLE BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP
                      CANCEL-EQUAL-PLUS DIFFERENCE-CANCELLATION
                      EQUAL-DIFFERENCE-0 EVAL$-QUOTE MEMBER-IMPLIES-NUMBERP
                      MEMBER-IMPLIES-PLUS-TREE-GREATEREQP NUMBERP-EVAL$-PLUS
                      PLUS-TREE-BAGDIFF PLUS-TREE-DELETE PLUS-TREE-PLUS-FRINGE
                      SUBBAGP-BAGINT1 SUBBAGP-BAGINT2)
              (DISABLE EVAL$)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN CANCEL-DIFFERENCE-PLUS
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'DIFFERENCE))
          (COND ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS))
                 (LIST 'DIFFERENCE
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADDR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))))
                ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (MEMBER (CADDR X)
                              (PLUS-FRINGE (CADR X))))
                 (PLUS-TREE (DELETE (CADDR X)
                                    (PLUS-FRINGE (CADR X)))))
                ((AND (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS)
                      (MEMBER (CADR X)
                              (PLUS-FRINGE (CADDR X))))
                 ''0)
                (T X))
          X))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS
             ((META DIFFERENCE))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-DIFFERENCE-PLUS X)
                           A))
             ((ENABLE CANCEL-DIFFERENCE-PLUS ASSOCIATIVITY-OF-PLUS
                      BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP
                      COMMUTATIVITY-OF-PLUS DIFF-DIFF-DIFF
                      DIFFERENCE-LESSP-ARG1
                      DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK
                      EQUAL-DIFFERENCE-0 EVAL$-QUOTE
                      MEMBER-IMPLIES-PLUS-TREE-GREATEREQP NUMBERP-EVAL$-PLUS
                      PLUS-TREE-BAGDIFF PLUS-TREE-DELETE PLUS-TREE-PLUS-FRINGE
                      SUBBAGP-BAGINT1 SUBBAGP-BAGINT2)
              (DISABLE EVAL$)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-ELIM
             (ELIM)
             (IMPLIES (AND (NUMBERP Y) (NOT (LESSP Y X)))
                      (EQUAL (PLUS X (DIFFERENCE Y X)) Y))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-LEQ-ARG1
             (REWRITE)
             (IMPLIES (IF (LESSP B A) F T)
                      (EQUAL (DIFFERENCE A B) 0))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-ADD1-ARG2
             (REWRITE)
             (EQUAL (DIFFERENCE A (ADD1 B))
                    (IF (LESSP B A)
                        (SUB1 (DIFFERENCE A B))
                        0))
             ((ENABLE DIFFERENCE-LEQ-ARG1)
              (INDUCT (DIFFERENCE A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-SUB1-ARG2
             (REWRITE)
             (EQUAL (DIFFERENCE A (SUB1 B))
                    (COND ((ZEROP B) (FIX A))
                          ((LESSP A B) 0)
                          (T (ADD1 (DIFFERENCE A B)))))
             ((ENABLE DIFF-SUB1-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-DIFFERENCE-ARG1
             (REWRITE)
             (EQUAL (DIFFERENCE (DIFFERENCE X Y) Z)
                    (DIFFERENCE X (PLUS Y Z)))
             ((ENABLE DIFF-DIFF-ARG1)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-DIFFERENCE-ARG2
             (REWRITE)
             (EQUAL (DIFFERENCE A (DIFFERENCE B C))
                    (IF (LESSP B C)
                        (FIX A)
                        (DIFFERENCE (PLUS A C) B)))
             ((ENABLE DIFF-DIFF-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIFFERENCE-X-X
             (REWRITE)
             (EQUAL (DIFFERENCE X X) 0)
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-DIFFERENCE-CANCELLATION
             (REWRITE)
             (EQUAL (LESSP (DIFFERENCE A C)
                           (DIFFERENCE B C))
                    (IF (IF (LESSP A C) F T)
                        (LESSP A B)
                        (LESSP C B)))
             ((ENABLE EQUAL-DIFFERENCE-0)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE LESSP-DIFFERENCE-CANCELLATION-OFF LESSP-DIFFERENCE-CANCELLATION T)

(DEFN CANCEL-LESSP-PLUS
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'LESSP))
          (COND ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS))
                 (LIST 'LESSP
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))
                       (PLUS-TREE (BAGDIFF (PLUS-FRINGE (CADDR X))
                                           (BAGINT (PLUS-FRINGE (CADR X))
                                                   (PLUS-FRINGE (CADDR X)))))))
                ((AND (LISTP (CADR X))
                      (EQUAL (CAADR X) 'PLUS)
                      (MEMBER (CADDR X)
                              (PLUS-FRINGE (CADR X))))
                 (LIST 'QUOTE F))
                ((AND (LISTP (CADDR X))
                      (EQUAL (CAADDR X) 'PLUS)
                      (MEMBER (CADR X)
                              (PLUS-FRINGE (CADDR X))))
                 (LIST 'NOT
                       (LIST 'ZEROP
                             (PLUS-TREE (DELETE (CADR X)
                                                (PLUS-FRINGE (CADDR X)))))))
                (T X))
          X))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-LESSP-PLUS
             ((META LESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-LESSP-PLUS X) A))
             ((ENABLE CANCEL-LESSP-PLUS
                      BRIDGE-TO-SUBBAGP-IMPLIES-PLUS-TREE-GREATEREQP
                      EQUAL-DIFFERENCE-0 EVAL$-QUOTE
                      LESSP-DIFFERENCE-CANCELLATION
                      MEMBER-IMPLIES-PLUS-TREE-GREATEREQP NUMBERP-EVAL$-PLUS
                      PLUS-TREE-BAGDIFF PLUS-TREE-DELETE PLUS-TREE-PLUS-FRINGE
                      SUBBAGP-BAGINT1 SUBBAGP-BAGINT2)
              (DISABLE EVAL$)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY ADDITION
           (EQUAL-PLUS-0 EQUAL-DIFFERENCE-0 COMMUTATIVITY-OF-PLUS
                         COMMUTATIVITY2-OF-PLUS PLUS-ZERO-ARG2 PLUS-ADD1-ARG2
                         PLUS-ADD1-ARG1 ASSOCIATIVITY-OF-PLUS
                         PLUS-DIFFERENCE-ARG1 PLUS-DIFFERENCE-ARG2
                         DIFF-DIFF-ARG1 DIFF-DIFF-ARG2
                         CORRECTNESS-OF-CANCEL-EQUAL-PLUS
                         CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS DIFFERENCE-ELIM
                         DIFFERENCE-LEQ-ARG1 DIFFERENCE-ADD1-ARG2
                         DIFFERENCE-SUB1-ARG2 DIFFERENCE-DIFFERENCE-ARG1
                         DIFFERENCE-DIFFERENCE-ARG2 DIFFERENCE-X-X
                         CORRECTNESS-OF-CANCEL-LESSP-PLUS))

(PROVE-LEMMA EQUAL-TIMES-0
             (REWRITE)
             (EQUAL (EQUAL (TIMES X Y) 0)
                    (OR (ZEROP X) (ZEROP Y)))
             ((ENABLE EQUAL-PLUS-0)
              (INDUCT (TIMES X Y))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-TIMES-1
             (REWRITE)
             (EQUAL (EQUAL (TIMES A B) 1)
                    (AND (EQUAL A 1) (EQUAL B 1)))
             ((ENABLE EQUAL-PLUS-0)
              (INDUCT (TIMES A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-SUB1-0
             (REWRITE)
             (EQUAL (EQUAL (SUB1 X) 0)
                    (OR (ZEROP X) (EQUAL X 1)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-ZERO
             (REWRITE)
             (IMPLIES (ZEROP Y)
                      (EQUAL (TIMES X Y) 0))
             ((ENABLE PLUS-ZERO-ARG2 COMMUTATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-ADD1
             (REWRITE)
             (EQUAL (TIMES X (ADD1 Y))
                    (IF (NUMBERP Y)
                        (PLUS X (TIMES X Y))
                        (FIX X)))
             ((ENABLE PLUS-ZERO-ARG2 COMMUTATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY-OF-TIMES
             (REWRITE)
             (EQUAL (TIMES Y X) (TIMES X Y))
             ((ENABLE TIMES-ZERO TIMES-ADD1)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-DISTRIBUTES-OVER-PLUS-PROOF NIL
             (EQUAL (TIMES X (PLUS Y Z))
                    (PLUS (TIMES X Y) (TIMES X Z)))
             ((ENABLE COMMUTATIVITY2-OF-PLUS ASSOCIATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-DISTRIBUTES-OVER-PLUS
             (REWRITE)
             (AND (EQUAL (TIMES X (PLUS Y Z))
                         (PLUS (TIMES X Y) (TIMES X Z)))
                  (EQUAL (TIMES (PLUS X Y) Z)
                         (PLUS (TIMES X Z) (TIMES Y Z))))
             ((USE (TIMES-DISTRIBUTES-OVER-PLUS-PROOF (X X)
                                                      (Y Y)
                                                      (Z Z))
                   (TIMES-DISTRIBUTES-OVER-PLUS-PROOF (X Z)
                                                      (Y X)
                                                      (Z Y)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-TIMES
             (REWRITE)
             (EQUAL (TIMES X Y Z) (TIMES Y X Z))
             ((ENABLE COMMUTATIVITY-OF-TIMES TIMES-DISTRIBUTES-OVER-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-TIMES
             (REWRITE)
             (EQUAL (TIMES (TIMES X Y) Z)
                    (TIMES X Y Z))
             ((ENABLE COMMUTATIVITY-OF-TIMES COMMUTATIVITY2-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF NIL
             (EQUAL (TIMES (DIFFERENCE A B) C)
                    (DIFFERENCE (TIMES A C) (TIMES B C)))
             ((ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-DISTRIBUTES-OVER-DIFFERENCE
             (REWRITE)
             (AND (EQUAL (TIMES (DIFFERENCE A B) C)
                         (DIFFERENCE (TIMES A C) (TIMES B C)))
                  (EQUAL (TIMES A (DIFFERENCE B C))
                         (DIFFERENCE (TIMES A B) (TIMES A C))))
             ((USE (TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF (A A)
                                                            (B B)
                                                            (C C))
                   (TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF (A B)
                                                            (B C)
                                                            (C A)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-QUOTIENT-PROOF NIL
             (IMPLIES (AND (NOT (ZEROP X))
                           (EQUAL (REMAINDER Y X) 0))
                      (EQUAL (TIMES (QUOTIENT Y X) X)
                             (FIX Y)))
             ((ENABLE TIMES-ZERO TIMES-ADD1)
              (INDUCT (REMAINDER Y X))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-QUOTIENT
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP Y))
                           (EQUAL (REMAINDER X Y) 0))
                      (AND (EQUAL (TIMES (QUOTIENT X Y) Y)
                                  (FIX X))
                           (EQUAL (TIMES Y (QUOTIENT X Y))
                                  (FIX X))))
             ((USE (TIMES-QUOTIENT-PROOF (X Y) (Y X)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TIMES-1-ARG1
             (REWRITE)
             (EQUAL (TIMES 1 X) (FIX X))
             ((ENABLE TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES1-PROOF NIL
             (IMPLIES (AND (LESSP A B) (NOT (ZEROP C)))
                      (EQUAL (LESSP A (TIMES B C)) T))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES1
             (REWRITE)
             (IMPLIES (AND (LESSP A B) (NOT (ZEROP C)))
                      (AND (EQUAL (LESSP A (TIMES B C)) T)
                           (EQUAL (LESSP A (TIMES C B)) T)))
             ((ENABLE COMMUTATIVITY-OF-TIMES)
              (USE (LESSP-TIMES1-PROOF (A A)
                                       (B B)
                                       (C C)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES2-PROOF NIL
             (IMPLIES (AND (IF (LESSP B A) F T)
                           (NOT (ZEROP C)))
                      (EQUAL (LESSP (TIMES B C) A) F))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES2
             (REWRITE)
             (IMPLIES (AND (IF (LESSP B A) F T)
                           (NOT (ZEROP C)))
                      (AND (EQUAL (LESSP (TIMES B C) A) F)
                           (EQUAL (LESSP (TIMES C B) A) F)))
             ((ENABLE COMMUTATIVITY-OF-TIMES)
              (USE (LESSP-TIMES2-PROOF (A A)
                                       (B B)
                                       (C C)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES3-PROOF1 NIL
             (IMPLIES (AND (NOT (ZEROP A)) (LESSP 1 B))
                      (LESSP A (TIMES A B)))
             ((ENABLE-THEORY ADDITION GROUND-ZERO)
              (ENABLE TIMES-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES3-PROOF2 NIL
             (IMPLIES (LESSP A (TIMES A B))
                      (AND (NOT (ZEROP A)) (LESSP 1 B)))
             ((ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES3
             (REWRITE)
             (AND (EQUAL (LESSP A (TIMES A B))
                         (AND (NOT (ZEROP A)) (LESSP 1 B)))
                  (EQUAL (LESSP A (TIMES B A))
                         (AND (NOT (ZEROP A)) (LESSP 1 B))))
             ((ENABLE COMMUTATIVITY-OF-TIMES)
              (USE (LESSP-TIMES3-PROOF1 (A A) (B B))
                   (LESSP-TIMES3-PROOF2 (A A) (B B)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES-CANCELLATION-PROOF NIL
             (EQUAL (LESSP (TIMES X Z) (TIMES Y Z))
                    (AND (NOT (ZEROP Z)) (LESSP X Y)))
             ((ENABLE COMMUTATIVITY-OF-TIMES CORRECTNESS-OF-CANCEL-LESSP-PLUS
                      TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-TIMES-CANCELLATION1
             (REWRITE)
             (AND (EQUAL (LESSP (TIMES X Z) (TIMES Y Z))
                         (AND (NOT (ZEROP Z)) (LESSP X Y)))
                  (EQUAL (LESSP (TIMES Z X) (TIMES Y Z))
                         (AND (NOT (ZEROP Z)) (LESSP X Y)))
                  (EQUAL (LESSP (TIMES X Z) (TIMES Z Y))
                         (AND (NOT (ZEROP Z)) (LESSP X Y)))
                  (EQUAL (LESSP (TIMES Z X) (TIMES Z Y))
                         (AND (NOT (ZEROP Z)) (LESSP X Y))))
             ((USE (LESSP-TIMES-CANCELLATION-PROOF (X X)
                                                   (Y Y)
                                                   (Z Z)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE LESSP-TIMES-CANCELLATION1-OFF LESSP-TIMES-CANCELLATION1 T)

(PROVE-LEMMA LESSP-PLUS-TIMES-PROOF NIL
             (IMPLIES (LESSP X A)
                      (EQUAL (LESSP (PLUS X (TIMES A B))
                                    (TIMES A C))
                             (LESSP B C)))
             ((ENABLE-THEORY ADDITION GROUND-ZERO)
              (ENABLE COMMUTATIVITY-OF-TIMES LESSP-TIMES-CANCELLATION1
                      LESSP-TIMES1 LESSP-TIMES2 LESSP-TIMES3 TIMES-ADD1
                      TIMES-ZERO)
              (INDUCT (LESSP B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-PLUS-TIMES1
             (REWRITE)
             (AND (EQUAL (LESSP (PLUS A (TIMES B C)) B)
                         (AND (LESSP A B) (ZEROP C)))
                  (EQUAL (LESSP (PLUS A (TIMES C B)) B)
                         (AND (LESSP A B) (ZEROP C)))
                  (EQUAL (LESSP (PLUS (TIMES C B) A) B)
                         (AND (LESSP A B) (ZEROP C)))
                  (EQUAL (LESSP (PLUS (TIMES B C) A) B)
                         (AND (LESSP A B) (ZEROP C))))
             ((USE (LESSP-PLUS-TIMES-PROOF (A B)
                                           (B C)
                                           (C 1)
                                           (X A)))
              (ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY-OF-TIMES
                      TIMES-1-ARG1)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-PLUS-TIMES2
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP A)) (LESSP X A))
                      (AND (EQUAL (LESSP (PLUS X (TIMES A B))
                                         (TIMES A C))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS X (TIMES B A))
                                         (TIMES A C))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS X (TIMES A B))
                                         (TIMES C A))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS X (TIMES B A))
                                         (TIMES C A))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS (TIMES A B) X)
                                         (TIMES A C))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS (TIMES B A) X)
                                         (TIMES A C))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS (TIMES A B) X)
                                         (TIMES C A))
                                  (LESSP B C))
                           (EQUAL (LESSP (PLUS (TIMES B A) X)
                                         (TIMES C A))
                                  (LESSP B C))))
             ((ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY-OF-TIMES)
              (USE (LESSP-PLUS-TIMES-PROOF (A A)
                                           (B B)
                                           (C C)
                                           (X X)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-1-TIMES
             (REWRITE)
             (EQUAL (LESSP 1 (TIMES A B))
                    (NOT (OR (ZEROP A)
                             (ZEROP B)
                             (AND (EQUAL A 1) (EQUAL B 1)))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN TIMES-TREE
      (X)
      (COND ((NLISTP X) ''1)
            ((NLISTP (CDR X))
             (LIST 'FIX (CAR X)))
            ((NLISTP (CDDR X))
             (LIST 'TIMES (CAR X) (CADR X)))
            (T (LIST 'TIMES
                     (CAR X)
                     (TIMES-TREE (CDR X))))))

(DEFN TIMES-FRINGE
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'TIMES))
          (APPEND (TIMES-FRINGE (CADR X))
                  (TIMES-FRINGE (CADDR X)))
          (LIST X)))

(DEFN OR-ZEROP-TREE
      (X)
      (COND ((NLISTP X) '(FALSE))
            ((NLISTP (CDR X))
             (LIST 'ZEROP (CAR X)))
            ((NLISTP (CDDR X))
             (LIST 'OR
                   (LIST 'ZEROP (CAR X))
                   (LIST 'ZEROP (CADR X))))
            (T (LIST 'OR
                     (LIST 'ZEROP (CAR X))
                     (OR-ZEROP-TREE (CDR X))))))

(DEFN AND-NOT-ZEROP-TREE
      (X)
      (COND ((NLISTP X) '(TRUE))
            ((NLISTP (CDR X))
             (LIST 'NOT (LIST 'ZEROP (CAR X))))
            (T (LIST 'AND
                     (LIST 'NOT (LIST 'ZEROP (CAR X)))
                     (AND-NOT-ZEROP-TREE (CDR X))))))

(PROVE-LEMMA NUMBERP-EVAL$-TIMES
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'TIMES)
                      (NUMBERP (EVAL$ T X A)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE NUMBERP-EVAL$-TIMES-OFF NUMBERP-EVAL$-TIMES T)

(PROVE-LEMMA EVAL$-TIMES
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'TIMES)
                      (EQUAL (EVAL$ T X A)
                             (TIMES (EVAL$ T (CADR X) A)
                                    (EVAL$ T (CADDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-TIMES-OFF EVAL$-TIMES T)

(PROVE-LEMMA EVAL$-OR
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'OR)
                      (EQUAL (EVAL$ T X A)
                             (OR (EVAL$ T (CADR X) A)
                                 (EVAL$ T (CADDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-OR-OFF EVAL$-OR T)

(PROVE-LEMMA EVAL$-EQUAL
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'EQUAL)
                      (EQUAL (EVAL$ T X A)
                             (EQUAL (EVAL$ T (CADR X) A)
                                    (EVAL$ T (CADDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-EQUAL-OFF EVAL$-EQUAL T)

(PROVE-LEMMA EVAL$-LESSP
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'LESSP)
                      (EQUAL (EVAL$ T X A)
                             (LESSP (EVAL$ T (CADR X) A)
                                    (EVAL$ T (CADDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-LESSP-OFF EVAL$-LESSP T)

(PROVE-LEMMA EVAL$-QUOTIENT
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'QUOTIENT)
                      (EQUAL (EVAL$ T X A)
                             (QUOTIENT (EVAL$ T (CADR X) A)
                                       (EVAL$ T (CADDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-QUOTIENT-OFF EVAL$-QUOTIENT T)

(PROVE-LEMMA EVAL$-IF
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'IF)
                      (EQUAL (EVAL$ T X A)
                             (IF (EVAL$ T (CADR X) A)
                                 (EVAL$ T (CADDR X) A)
                                 (EVAL$ T (CADDDR X) A))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-IF-OFF EVAL$-IF T)

(PROVE-LEMMA NUMBERP-EVAL$-TIMES-TREE
             (REWRITE)
             (NUMBERP (EVAL$ T (TIMES-TREE X) A))
             ((ENABLE TIMES-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE NUMBERP-EVAL$-TIMES-TREE-OFF NUMBERP-EVAL$-TIMES-TREE T)

(PROVE-LEMMA LESSP-TIMES-ARG1 NIL
             (IMPLIES (NOT (ZEROP A))
                      (EQUAL (NOT (LESSP (TIMES A X) (TIMES A Y)))
                             (NOT (LESSP X Y))))
             ((INDUCT (PLUS A X))
              (ENABLE TIMES CORRECTNESS-OF-CANCEL-LESSP-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INFER-EQUALITY-FROM-NOT-LESSP NIL
             (IMPLIES (AND (NUMBERP A) (NUMBERP B))
                      (EQUAL (AND (NOT (LESSP A B))
                                  (NOT (LESSP B A)))
                             (EQUAL A B)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-TIMES-ARG1
             (REWRITE)
             (IMPLIES (NOT (ZEROP A))
                      (EQUAL (EQUAL (TIMES A X) (TIMES A Y))
                             (EQUAL (FIX X) (FIX Y))))
             ((USE (LESSP-TIMES-ARG1 (A A) (X X) (Y Y))
                   (LESSP-TIMES-ARG1 (A A) (X Y) (Y X))
                   (INFER-EQUALITY-FROM-NOT-LESSP (A (TIMES A X))
                                                  (B (TIMES A Y))))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EQUAL-TIMES-ARG1-OFF EQUAL-TIMES-ARG1 T)

(PROVE-LEMMA EQUAL-TIMES-BRIDGE
             (REWRITE)
             (EQUAL (EQUAL (TIMES A B) (TIMES C A D))
                    (OR (ZEROP A)
                        (EQUAL (FIX B) (TIMES C D))))
             ((ENABLE COMMUTATIVITY-OF-TIMES COMMUTATIVITY2-OF-TIMES
                      EQUAL-TIMES-0 EQUAL-TIMES-ARG1 TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EQUAL-TIMES-BRIDGE-OFF EQUAL-TIMES-BRIDGE T)

(PROVE-LEMMA EVAL$-TIMES-MEMBER
             (REWRITE)
             (IMPLIES (MEMBER E X)
                      (EQUAL (EVAL$ T (TIMES-TREE X) A)
                             (TIMES (EVAL$ T E A)
                                    (EVAL$ T
                                           (TIMES-TREE (DELETE E X))
                                           A))))
             ((ENABLE DELETE TIMES-TREE COMMUTATIVITY-OF-TIMES
                      DELETE-NON-MEMBER EQUAL-TIMES-0 EQUAL-TIMES-BRIDGE
                      LISTP-DELETE MEMBER-NON-LIST TIMES-1-ARG1 TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-TIMES-MEMBER-OFF EVAL$-TIMES-MEMBER T)

(PROVE-LEMMA ZEROP-MAKES-TIMES-TREE-ZERO
             (REWRITE)
             (IMPLIES (AND (NOT (EVAL$ T (AND-NOT-ZEROP-TREE X) A))
                           (SUBBAGP X Y))
                      (EQUAL (EVAL$ T (TIMES-TREE Y) A) 0))
             ((ENABLE AND-NOT-ZEROP-TREE COMMUTATIVITY-OF-TIMES
                      EVAL$-TIMES-MEMBER SUBBAGP TIMES-TREE TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE ZEROP-MAKES-TIMES-TREE-ZERO-OFF ZEROP-MAKES-TIMES-TREE-ZERO T)

(PROVE-LEMMA OR-ZEROP-TREE-IS-NOT-ZEROP-TREE
             (REWRITE)
             (EQUAL (EVAL$ T (OR-ZEROP-TREE X) A)
                    (NOT (EVAL$ T (AND-NOT-ZEROP-TREE X) A)))
             ((ENABLE AND-NOT-ZEROP-TREE OR-ZEROP-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE OR-ZEROP-TREE-IS-NOT-ZEROP-TREE-OFF OR-ZEROP-TREE-IS-NOT-ZEROP-TREE T)

(PROVE-LEMMA ZEROP-MAKES-TIMES-TREE-ZERO2
             (REWRITE)
             (IMPLIES (AND (EVAL$ T (OR-ZEROP-TREE X) A)
                           (SUBBAGP X Y))
                      (EQUAL (EVAL$ T (TIMES-TREE Y) A) 0))
             ((USE (ZEROP-MAKES-TIMES-TREE-ZERO)
                   (OR-ZEROP-TREE-IS-NOT-ZEROP-TREE))
              (ENABLE OR-ZEROP-TREE SUBBAGP TIMES-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE ZEROP-MAKES-TIMES-TREE-ZERO2-OFF ZEROP-MAKES-TIMES-TREE-ZERO2 T)

(PROVE-LEMMA TIMES-TREE-APPEND
             (REWRITE)
             (EQUAL (EVAL$ T (TIMES-TREE (APPEND X Y)) A)
                    (TIMES (EVAL$ T (TIMES-TREE X) A)
                           (EVAL$ T (TIMES-TREE Y) A)))
             ((ENABLE APPEND ASSOCIATIVITY-OF-TIMES COMMUTATIVITY-OF-TIMES
                      COMMUTATIVITY2-OF-TIMES EQUAL-TIMES-0 EQUAL-TIMES-ARG1
                      EQUAL-TIMES-BRIDGE NUMBERP-EVAL$-TIMES-TREE TIMES-1-ARG1
                      TIMES-TREE TIMES-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE TIMES-TREE-APPEND-OFF TIMES-TREE-APPEND T)

(PROVE-LEMMA TIMES-TREE-OF-TIMES-FRINGE
             (REWRITE)
             (EQUAL (EVAL$ T
                           (TIMES-TREE (TIMES-FRINGE X))
                           A)
                    (FIX (EVAL$ T X A)))
             ((ENABLE COMMUTATIVITY-OF-TIMES EVAL$-TIMES TIMES-FRINGE
                      TIMES-TREE TIMES-TREE-APPEND TIMES-ZERO)
              (INDUCT (TIMES-FRINGE X))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE TIMES-TREE-OF-TIMES-FRINGE-OFF TIMES-TREE-OF-TIMES-FRINGE T)

(DEFN CANCEL-LESSP-TIMES
 (X)
 (IF (AND (EQUAL (CAR X) 'LESSP)
          (EQUAL (CAADR X) 'TIMES)
          (EQUAL (CAADDR X) 'TIMES))
     (IF (LISTP (BAGINT (TIMES-FRINGE (CADR X))
                        (TIMES-FRINGE (CADDR X))))
         (LIST 'AND
               (AND-NOT-ZEROP-TREE (BAGINT (TIMES-FRINGE (CADR X))
                                           (TIMES-FRINGE (CADDR X))))
               (LIST 'LESSP
                     (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADR X))
                                          (BAGINT (TIMES-FRINGE (CADR X))
                                                  (TIMES-FRINGE (CADDR X)))))
                     (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADDR X))
                                          (BAGINT (TIMES-FRINGE (CADR X))
                                                  (TIMES-FRINGE (CADDR X)))))))
         X)
     X))

(PROVE-LEMMA EVAL$-LESSP-TIMES-TREE-BAGDIFF
             (REWRITE)
             (IMPLIES (AND (SUBBAGP X Y)
                           (SUBBAGP X Z)
                           (EVAL$ T (AND-NOT-ZEROP-TREE X) A))
                      (EQUAL (LESSP (EVAL$ T (TIMES-TREE (BAGDIFF Y X)) A)
                                    (EVAL$ T
                                           (TIMES-TREE (BAGDIFF Z X))
                                           A))
                             (LESSP (EVAL$ T (TIMES-TREE Y) A)
                                    (EVAL$ T (TIMES-TREE Z) A))))
             ((ENABLE AND-NOT-ZEROP-TREE BAGDIFF EVAL$-TIMES-MEMBER
                      LESSP-TIMES-CANCELLATION1 SUBBAGP SUBBAGP-CDR1
                      SUBBAGP-CDR2 TIMES-TREE ZEROP-MAKES-TIMES-TREE-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-LESSP-TIMES-TREE-BAGDIFF-OFF EVAL$-LESSP-TIMES-TREE-BAGDIFF T)

(PROVE-LEMMA ZEROP-MAKES-LESSP-FALSE-BRIDGE
       (REWRITE)
       (IMPLIES (AND (EQUAL (CAR X) 'TIMES)
                     (EQUAL (CAR Y) 'TIMES)
                     (NOT (EVAL$ T
                                 (AND-NOT-ZEROP-TREE (BAGINT (TIMES-FRINGE X)
                                                             (TIMES-FRINGE Y)))
                                 A)))
                (EQUAL (LESSP (TIMES (EVAL$ T (CADR X) A)
                                     (EVAL$ T (CADDR X) A))
                              (TIMES (EVAL$ T (CADR Y) A)
                                     (EVAL$ T (CADDR Y) A)))
                       F))
       ((ENABLE AND-NOT-ZEROP-TREE BAGINT COMMUTATIVITY-OF-TIMES DELETE
                EQUAL-TIMES-0 EVAL$-TIMES SUBBAGP-BAGINT1 SUBBAGP-BAGINT2
                TIMES-FRINGE TIMES-TREE TIMES-TREE-APPEND
                TIMES-TREE-OF-TIMES-FRINGE TIMES-ZERO)
        (USE (ZEROP-MAKES-TIMES-TREE-ZERO (X (BAGINT (TIMES-FRINGE X)
                                                     (TIMES-FRINGE Y)))
                                          (Y (TIMES-FRINGE X)))
             (ZEROP-MAKES-TIMES-TREE-ZERO (X (BAGINT (TIMES-FRINGE X)
                                                     (TIMES-FRINGE Y)))
                                          (Y (TIMES-FRINGE Y))))
        (ENABLE-THEORY GROUND-ZERO)
        (DISABLE-THEORY T)))

(TOGGLE ZEROP-MAKES-LESSP-FALSE-BRIDGE-OFF ZEROP-MAKES-LESSP-FALSE-BRIDGE T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-LESSP-TIMES
             ((META LESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-LESSP-TIMES X) A))
             ((ENABLE CANCEL-LESSP-TIMES EVAL$-LESSP-TIMES-TREE-BAGDIFF
                      EVAL$-LESSP EVAL$-TIMES SUBBAGP-BAGINT1 SUBBAGP-BAGINT2
                      TIMES-TREE-OF-TIMES-FRINGE
                      ZEROP-MAKES-LESSP-FALSE-BRIDGE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN CANCEL-EQUAL-TIMES
 (X)
 (IF (AND (EQUAL (CAR X) 'EQUAL)
          (EQUAL (CAADR X) 'TIMES)
          (EQUAL (CAADDR X) 'TIMES))
     (IF (LISTP (BAGINT (TIMES-FRINGE (CADR X))
                        (TIMES-FRINGE (CADDR X))))
         (LIST 'OR
               (OR-ZEROP-TREE (BAGINT (TIMES-FRINGE (CADR X))
                                      (TIMES-FRINGE (CADDR X))))
               (LIST 'EQUAL
                     (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADR X))
                                          (BAGINT (TIMES-FRINGE (CADR X))
                                                  (TIMES-FRINGE (CADDR X)))))
                     (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADDR X))
                                          (BAGINT (TIMES-FRINGE (CADR X))
                                                  (TIMES-FRINGE (CADDR X)))))))
         X)
     X))

(PROVE-LEMMA ZEROP-MAKES-EQUAL-TRUE-BRIDGE
             (REWRITE)
             (IMPLIES (AND (EQUAL (CAR X) 'TIMES)
                           (EQUAL (CAR Y) 'TIMES)
                           (EVAL$ T
                                  (OR-ZEROP-TREE (BAGINT (TIMES-FRINGE X)
                                                         (TIMES-FRINGE Y)))
                                  A))
                      (EQUAL (EQUAL (TIMES (EVAL$ T (CADR X) A)
                                           (EVAL$ T (CADDR X) A))
                                    (TIMES (EVAL$ T (CADR Y) A)
                                           (EVAL$ T (CADDR Y) A)))
                             T))
             ((ENABLE BAGINT COMMUTATIVITY-OF-TIMES DELETE EQUAL-TIMES-0
                      EVAL$-TIMES OR-ZEROP-TREE SUBBAGP-BAGINT1
                      SUBBAGP-BAGINT2 TIMES-FRINGE TIMES-TREE
                      TIMES-TREE-APPEND TIMES-TREE-OF-TIMES-FRINGE TIMES-ZERO)
              (USE (ZEROP-MAKES-TIMES-TREE-ZERO2 (X (BAGINT (TIMES-FRINGE X)
                                                            (TIMES-FRINGE Y)))
                                                 (Y (TIMES-FRINGE X)))
                   (ZEROP-MAKES-TIMES-TREE-ZERO2 (X (BAGINT (TIMES-FRINGE X)
                                                            (TIMES-FRINGE Y)))
                                                 (Y (TIMES-FRINGE Y))))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE ZEROP-MAKES-EQUAL-TRUE-BRIDGE-OFF ZEROP-MAKES-EQUAL-TRUE-BRIDGE T)

(PROVE-LEMMA EVAL$-EQUAL-TIMES-TREE-BAGDIFF
             (REWRITE)
             (IMPLIES (AND (SUBBAGP X Y)
                           (SUBBAGP X Z)
                           (NOT (EVAL$ T (OR-ZEROP-TREE X) A)))
                      (EQUAL (EQUAL (EVAL$ T (TIMES-TREE (BAGDIFF Y X)) A)
                                    (EVAL$ T
                                           (TIMES-TREE (BAGDIFF Z X))
                                           A))
                             (EQUAL (EVAL$ T (TIMES-TREE Y) A)
                                    (EVAL$ T (TIMES-TREE Z) A))))
             ((ENABLE AND-NOT-ZEROP-TREE BAGDIFF EQUAL-TIMES-ARG1
                      EVAL$-TIMES-MEMBER NUMBERP-EVAL$-TIMES-TREE
                      OR-ZEROP-TREE OR-ZEROP-TREE-IS-NOT-ZEROP-TREE SUBBAGP
                      SUBBAGP-CDR1 SUBBAGP-CDR2 TIMES-TREE
                      ZEROP-MAKES-TIMES-TREE-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-EQUAL-TIMES-TREE-BAGDIFF-OFF EVAL$-EQUAL-TIMES-TREE-BAGDIFF T)

(PROVE-LEMMA CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY
             (REWRITE)
             (IMPLIES (AND (SUBBAGP Z X)
                           (SUBBAGP Z Y)
                           (NOT (EQUAL (EVAL$ T (TIMES-TREE X) A)
                                       (EVAL$ T (TIMES-TREE Y) A))))
                      (NOT (EQUAL (EVAL$ T (TIMES-TREE (BAGDIFF X Z)) A)
                                  (EVAL$ T
                                         (TIMES-TREE (BAGDIFF Y Z))
                                         A))))
             ((ENABLE BAGDIFF EVAL$-TIMES-MEMBER SUBBAGP SUBBAGP-CDR2
                      TIMES-TREE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY-OFF
        CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY T)

(PROVE-LEMMA CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY-BRIDGE
   (REWRITE)
   (IMPLIES (AND (EQUAL (CAR X) 'TIMES)
                 (EQUAL (CAR Y) 'TIMES)
                 (NOT (EQUAL (TIMES (EVAL$ T (CADR X) A)
                                    (EVAL$ T (CADDR X) A))
                             (TIMES (EVAL$ T (CADR Y) A)
                                    (EVAL$ T (CADDR Y) A)))))
            (NOT (EQUAL (EVAL$ T
                               (TIMES-TREE (BAGDIFF (TIMES-FRINGE X)
                                                    (BAGINT (TIMES-FRINGE X)
                                                            (TIMES-FRINGE Y))))
                               A)
                        (EVAL$ T
                               (TIMES-TREE (BAGDIFF (TIMES-FRINGE Y)
                                                    (BAGINT (TIMES-FRINGE X)
                                                            (TIMES-FRINGE Y))))
                               A))))
   ((ENABLE BAGDIFF BAGINT COMMUTATIVITY-OF-TIMES SUBBAGP-BAGINT1
            SUBBAGP-BAGINT2 TIMES-FRINGE TIMES-TREE TIMES-TREE-APPEND
            TIMES-TREE-OF-TIMES-FRINGE TIMES-ZERO)
    (USE (CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY (Z (BAGINT (TIMES-FRINGE X)
                                                             (TIMES-FRINGE Y)))
                                                  (X (TIMES-FRINGE X))
                                                  (Y (TIMES-FRINGE Y))))
    (ENABLE-THEORY GROUND-ZERO)
    (DISABLE-THEORY T)))

(TOGGLE CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY-BRIDGE-OFF
        CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY-BRIDGE T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-EQUAL-TIMES
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-EQUAL-TIMES X) A))
             ((ENABLE CANCEL-EQUAL-TIMES
                      CANCEL-EQUAL-TIMES-PRESERVES-INEQUALITY-BRIDGE
                      EVAL$-EQUAL EVAL$-EQUAL-TIMES-TREE-BAGDIFF EVAL$-TIMES
                      SUBBAGP-BAGINT1 SUBBAGP-BAGINT2
                      TIMES-TREE-OF-TIMES-FRINGE ZEROP-MAKES-EQUAL-TRUE-BRIDGE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY MULTIPLICATION
           (EQUAL-TIMES-0 EQUAL-TIMES-1 EQUAL-SUB1-0 TIMES-ZERO TIMES-ADD1
                          COMMUTATIVITY-OF-TIMES TIMES-DISTRIBUTES-OVER-PLUS
                          COMMUTATIVITY2-OF-TIMES ASSOCIATIVITY-OF-TIMES
                          TIMES-DISTRIBUTES-OVER-DIFFERENCE TIMES-QUOTIENT
                          TIMES-1-ARG1 LESSP-TIMES1 LESSP-TIMES2 LESSP-TIMES3
                          LESSP-PLUS-TIMES1 LESSP-PLUS-TIMES2 LESSP-1-TIMES
                          CORRECTNESS-OF-CANCEL-LESSP-TIMES
                          CORRECTNESS-OF-CANCEL-EQUAL-TIMES))

(PROVE-LEMMA LESSP-REMAINDER
             (REWRITE GENERALIZE)
             (EQUAL (LESSP (REMAINDER X Y) Y)
                    (NOT (ZEROP Y)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-NOOP
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (EQUAL (REMAINDER A B) (FIX A)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-OF-NON-NUMBER
             (REWRITE)
             (IMPLIES (NOT (NUMBERP A))
                      (EQUAL (REMAINDER A N)
                             (REMAINDER 0 N)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-ZERO
             (REWRITE)
             (IMPLIES (ZEROP X)
                      (EQUAL (REMAINDER Y X) (FIX Y)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA PLUS-REMAINDER-TIMES-QUOTIENT
             (REWRITE)
             (EQUAL (PLUS (REMAINDER X Y)
                          (TIMES Y (QUOTIENT X Y)))
                    (FIX X))
             ((ENABLE COMMUTATIVITY2-OF-PLUS COMMUTATIVITY-OF-PLUS TIMES-ZERO
                      TIMES-ADD1 COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE PLUS-REMAINDER-TIMES-QUOTIENT-OFF PLUS-REMAINDER-TIMES-QUOTIENT T)

(PROVE-LEMMA REMAINDER-QUOTIENT-ELIM
             (ELIM)
             (IMPLIES (AND (NOT (ZEROP Y)) (NUMBERP X))
                      (EQUAL (PLUS (REMAINDER X Y)
                                   (TIMES Y (QUOTIENT X Y)))
                             X))
             ((ENABLE PLUS-REMAINDER-TIMES-QUOTIENT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-ADD1
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A B) 0)
                      (EQUAL (REMAINDER (ADD1 A) B)
                             (REMAINDER 1 B)))
             ((ENABLE REMAINDER-NOOP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER A B))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-PLUS-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER B C) 0)
                      (EQUAL (REMAINDER (PLUS A B) C)
                             (REMAINDER A C)))
             ((ENABLE REMAINDER-NOOP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-PLUS
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (AND (EQUAL (REMAINDER (PLUS A B) C)
                                  (REMAINDER B C))
                           (EQUAL (REMAINDER (PLUS B A) C)
                                  (REMAINDER B C))
                           (EQUAL (REMAINDER (PLUS X Y A) C)
                                  (REMAINDER (PLUS X Y) C))))
             ((USE (REMAINDER-PLUS-PROOF (A B)
                                         (B A)
                                         (C C))
                   (REMAINDER-PLUS-PROOF (A A)
                                         (B B)
                                         (C C))
                   (REMAINDER-PLUS-PROOF (B A)
                                         (A (PLUS X Y))
                                         (C C)))
              (ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY2-OF-PLUS
                      ASSOCIATIVITY-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-REMAINDER-PLUS-0-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (EQUAL (EQUAL (REMAINDER (PLUS A B) C) 0)
                             (EQUAL (REMAINDER B C) 0)))
             ((ENABLE REMAINDER-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-REMAINDER-PLUS-0
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (AND (EQUAL (EQUAL (REMAINDER (PLUS A B) C) 0)
                                  (EQUAL (REMAINDER B C) 0))
                           (EQUAL (EQUAL (REMAINDER (PLUS B A) C) 0)
                                  (EQUAL (REMAINDER B C) 0))
                           (EQUAL (EQUAL (REMAINDER (PLUS X Y A) C) 0)
                                  (EQUAL (REMAINDER (PLUS X Y) C) 0))))
             ((USE (EQUAL-REMAINDER-PLUS-0-PROOF (A A)
                                                 (B B)
                                                 (C C))
                   (EQUAL-REMAINDER-PLUS-0-PROOF (A B)
                                                 (B A)
                                                 (C C))
                   (EQUAL-REMAINDER-PLUS-0-PROOF (A A)
                                                 (B (PLUS X Y))
                                                 (C C)))
              (ENABLE ASSOCIATIVITY-OF-PLUS COMMUTATIVITY-OF-PLUS
                      COMMUTATIVITY2-OF-PLUS)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-REMAINDER-PLUS-REMAINDER-PROOF NIL
             (IMPLIES (LESSP A C)
                      (EQUAL (EQUAL (REMAINDER (PLUS A B) C)
                                    (REMAINDER B C))
                             (ZEROP A)))
             ((ENABLE REMAINDER-NOOP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-REMAINDER-PLUS-REMAINDER
             (REWRITE)
             (IMPLIES (LESSP A C)
                      (AND (EQUAL (EQUAL (REMAINDER (PLUS A B) C)
                                         (REMAINDER B C))
                                  (ZEROP A))
                           (EQUAL (EQUAL (REMAINDER (PLUS B A) C)
                                         (REMAINDER B C))
                                  (ZEROP A))))
             ((USE (EQUAL-REMAINDER-PLUS-REMAINDER-PROOF (A A)
                                                         (B B)
                                                         (C C)))
              (ENABLE COMMUTATIVITY-OF-PLUS)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EQUAL-REMAINDER-PLUS-REMAINDER-OFF EQUAL-REMAINDER-PLUS-REMAINDER T)

(PROVE-LEMMA REMAINDER-TIMES1-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER B C) 0)
                      (EQUAL (REMAINDER (TIMES A B) C) 0))
             ((ENABLE-THEORY MULTIPLICATION ADDITION GROUND-ZERO)
              (ENABLE REMAINDER-PLUS REMAINDER-NOOP REMAINDER-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES1
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER B C) 0)
                      (AND (EQUAL (REMAINDER (TIMES A B) C) 0)
                           (EQUAL (REMAINDER (TIMES B A) C) 0)))
             ((USE (REMAINDER-TIMES1-PROOF (A A)
                                           (B B)
                                           (C C))
                   (REMAINDER-TIMES1-PROOF (A B)
                                           (B A)
                                           (C C)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES1-INSTANCE-PROOF NIL
             (EQUAL (REMAINDER (TIMES X Y) Y) 0)
             ((ENABLE COMMUTATIVITY-OF-TIMES DIFFERENCE-PLUS-CANCELLATION
                      REMAINDER-ZERO)
              (INDUCT (TIMES X Y))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES1-INSTANCE
             (REWRITE)
             (AND (EQUAL (REMAINDER (TIMES X Y) Y) 0)
                  (EQUAL (REMAINDER (TIMES X Y) X) 0))
             ((USE (REMAINDER-TIMES1-INSTANCE-PROOF (X X)
                                                    (Y Y))
                   (REMAINDER-TIMES1-INSTANCE-PROOF (X Y)
                                                    (Y X)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES-TIMES-PROOF NIL
             (EQUAL (REMAINDER (TIMES X Y) (TIMES X Z))
                    (TIMES X (REMAINDER Y Z)))
             ((ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (ENABLE REMAINDER-ZERO)
              (INDUCT (REMAINDER Y Z))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES-TIMES
             (REWRITE)
             (AND (EQUAL (REMAINDER (TIMES X Y) (TIMES X Z))
                         (TIMES X (REMAINDER Y Z)))
                  (EQUAL (REMAINDER (TIMES X Z) (TIMES Y Z))
                         (TIMES (REMAINDER X Y) Z)))
             ((USE (REMAINDER-TIMES-TIMES-PROOF (X X)
                                                (Y Y)
                                                (Z Z))
                   (REMAINDER-TIMES-TIMES-PROOF (X Z)
                                                (Y X)
                                                (Z Y)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE REMAINDER-TIMES-TIMES-OFF REMAINDER-TIMES-TIMES T)

(PROVE-LEMMA REMAINDER-TIMES2-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER A Z) 0)
                      (EQUAL (REMAINDER A (TIMES Z Y))
                             (TIMES Z
                                    (REMAINDER (QUOTIENT A Z) Y))))
             ((ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (ENABLE LESSP-REMAINDER REMAINDER-NOOP REMAINDER-PLUS
                      REMAINDER-QUOTIENT-ELIM REMAINDER-TIMES-TIMES
                      REMAINDER-TIMES1-INSTANCE REMAINDER-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES2
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A Z) 0)
                      (AND (EQUAL (REMAINDER A (TIMES Y Z))
                                  (TIMES Z
                                         (REMAINDER (QUOTIENT A Z) Y)))
                           (EQUAL (REMAINDER A (TIMES Z Y))
                                  (TIMES Z
                                         (REMAINDER (QUOTIENT A Z) Y)))))
             ((USE (REMAINDER-TIMES2-PROOF (A A)
                                           (Y Y)
                                           (Z Z)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-TIMES2-INSTANCE
             (REWRITE)
             (AND (EQUAL (REMAINDER (TIMES X Y) (TIMES X Z))
                         (TIMES X (REMAINDER Y Z)))
                  (EQUAL (REMAINDER (TIMES X Z) (TIMES Y Z))
                         (TIMES (REMAINDER X Y) Z)))
             ((ENABLE REMAINDER-TIMES-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-DIFFERENCE1
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C)
                             (REMAINDER B C))
                      (EQUAL (REMAINDER (DIFFERENCE A B) C)
                             (DIFFERENCE (REMAINDER A C)
                                         (REMAINDER B C))))
             ((ENABLE LESSP-REMAINDER EQUAL-REMAINDER-PLUS-REMAINDER
                      REMAINDER-PLUS REMAINDER-QUOTIENT-ELIM
                      REMAINDER-TIMES1-INSTANCE)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(DEFN DOUBLE-REMAINDER-INDUCTION
      (A B C)
      (COND ((ZEROP C) 0)
            ((LESSP A C) 0)
            ((LESSP B C) 0)
            (T (DOUBLE-REMAINDER-INDUCTION (DIFFERENCE A C)
                                           (DIFFERENCE B C)
                                           C))))

(PROVE-LEMMA REMAINDER-DIFFERENCE2
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER A C) 0)
                           (NOT (EQUAL (REMAINDER B C) 0)))
                      (EQUAL (REMAINDER (DIFFERENCE A B) C)
                             (IF (LESSP B A)
                                 (DIFFERENCE C (REMAINDER B C))
                                 0)))
             ((ENABLE EQUAL-REMAINDER-PLUS-0 LESSP-REMAINDER REMAINDER-NOOP
                      REMAINDER-OF-NON-NUMBER REMAINDER-QUOTIENT-ELIM
                      REMAINDER-TIMES1-INSTANCE REMAINDER-ZERO)
              (DISABLE TIMES-DISTRIBUTES-OVER-PLUS)
              (ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (INDUCT (DOUBLE-REMAINDER-INDUCTION A B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-DIFFERENCE3
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER B C) 0)
                           (NOT (EQUAL (REMAINDER A C) 0)))
                      (EQUAL (REMAINDER (DIFFERENCE A B) C)
                             (IF (LESSP B A) (REMAINDER A C) 0)))
             ((ENABLE REMAINDER-NOOP REMAINDER-OF-NON-NUMBER REMAINDER-ZERO)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (DOUBLE-REMAINDER-INDUCTION A B C))
              (DISABLE-THEORY T)))

(TOGGLE REMAINDER-DIFFERENCE3-OFF REMAINDER-DIFFERENCE3 T)

(PROVE-LEMMA EQUAL-REMAINDER-DIFFERENCE-0
             (REWRITE)
             (EQUAL (EQUAL (REMAINDER (DIFFERENCE A B) C)
                           0)
                    (IF (IF (LESSP A B) F T)
                        (EQUAL (REMAINDER A C)
                               (REMAINDER B C))
                        T))
             ((ENABLE LESSP-REMAINDER REMAINDER-DIFFERENCE1
                      REMAINDER-OF-NON-NUMBER REMAINDER-PLUS
                      REMAINDER-QUOTIENT-ELIM REMAINDER-TIMES1-INSTANCE
                      REMAINDER-ZERO)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(TOGGLE EQUAL-REMAINDER-DIFFERENCE-0-OFF EQUAL-REMAINDER-DIFFERENCE-0 T)

(PROVE-LEMMA LESSP-PLUS-FACT
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER B X) 0)
                           (EQUAL (REMAINDER C X) 0)
                           (LESSP B C)
                           (LESSP A X))
                      (EQUAL (LESSP (PLUS A B) C) T))
             ((ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (DOUBLE-REMAINDER-INDUCTION B C X))
              (DISABLE-THEORY T)))

(TOGGLE LESSP-PLUS-FACT-OFF LESSP-PLUS-FACT T)

(PROVE-LEMMA REMAINDER-PLUS-FACT NIL
             (IMPLIES (AND (EQUAL (REMAINDER B X) 0)
                           (EQUAL (REMAINDER C X) 0)
                           (LESSP A X))
                      (EQUAL (REMAINDER (PLUS A B) C)
                             (PLUS A (REMAINDER B C))))
             ((ENABLE LESSP-PLUS-FACT REMAINDER-NOOP REMAINDER-DIFFERENCE1)
              (ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (INDUCT (REMAINDER B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-PLUS-TIMES-TIMES-PROOF NIL
             (IMPLIES (LESSP A B)
                      (EQUAL (REMAINDER (PLUS A (TIMES B C))
                                        (TIMES B D))
                             (PLUS A
                                   (REMAINDER (TIMES B C) (TIMES B D)))))
             ((USE (REMAINDER-PLUS-FACT (A A)
                                        (X B)
                                        (B (TIMES B C))
                                        (C (TIMES B D))))
              (ENABLE REMAINDER-TIMES1-INSTANCE REMAINDER-TIMES2-INSTANCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-PLUS-TIMES-TIMES
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (AND (EQUAL (REMAINDER (PLUS A (TIMES B C))
                                             (TIMES B D))
                                  (PLUS A
                                        (REMAINDER (TIMES B C) (TIMES B D))))
                           (EQUAL (REMAINDER (PLUS A (TIMES C B))
                                             (TIMES D B))
                                  (PLUS A
                                        (REMAINDER (TIMES C B)
                                                   (TIMES D B))))))
             ((USE (REMAINDER-PLUS-TIMES-TIMES-PROOF (A A)
                                                     (B B)
                                                     (C C)
                                                     (D D)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-PLUS-TIMES-TIMES-INSTANCE
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (AND (EQUAL (REMAINDER (PLUS A (TIMES B C) (TIMES B D))
                                             (TIMES B E))
                                  (PLUS A
                                        (TIMES B (REMAINDER (PLUS C D) E))))
                           (EQUAL (REMAINDER (PLUS A (TIMES C B) (TIMES D B))
                                             (TIMES E B))
                                  (PLUS A
                                        (TIMES B (REMAINDER (PLUS C D) E))))))
             ((ENABLE COMMUTATIVITY-OF-TIMES REMAINDER-TIMES-TIMES
                      REMAINDER-PLUS-TIMES-TIMES)
              (USE (TIMES-DISTRIBUTES-OVER-PLUS (X B)
                                                (Y C)
                                                (Z D)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-REMAINDER
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER B A) 0)
                      (EQUAL (REMAINDER (REMAINDER N B) A)
                             (REMAINDER N A)))
             ((INDUCT (REMAINDER N B))
              (ENABLE REMAINDER-PLUS REMAINDER-QUOTIENT-ELIM REMAINDER-ZERO)
              (ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-1-ARG1
             (REWRITE)
             (EQUAL (REMAINDER 1 X)
                    (IF (EQUAL X 1) 0 1))
             ((ENABLE DIFFERENCE-LEQ-ARG1)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-1-ARG2
             (REWRITE)
             (EQUAL (REMAINDER Y 1) 0)
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-X-X
             (REWRITE)
             (EQUAL (REMAINDER X X) 0)
             ((ENABLE EQUAL-DIFFERENCE-0)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA TRANSITIVITY-OF-DIVIDES NIL
             (IMPLIES (AND (EQUAL (REMAINDER A B) 0)
                           (EQUAL (REMAINDER B C) 0))
                      (EQUAL (REMAINDER A C) 0))
             ((ENABLE REMAINDER REMAINDER-NOOP REMAINDER-PLUS)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY REMAINDERS
           (LESSP-REMAINDER REMAINDER-NOOP REMAINDER-OF-NON-NUMBER
                            REMAINDER-ZERO REMAINDER-QUOTIENT-ELIM
                            REMAINDER-ADD1 REMAINDER-PLUS
                            EQUAL-REMAINDER-PLUS-0 REMAINDER-TIMES1
                            REMAINDER-TIMES1-INSTANCE REMAINDER-TIMES2
                            REMAINDER-TIMES2-INSTANCE REMAINDER-DIFFERENCE1
                            REMAINDER-DIFFERENCE2 REMAINDER-PLUS-TIMES-TIMES
                            REMAINDER-PLUS-TIMES-TIMES-INSTANCE
                            REMAINDER-REMAINDER REMAINDER-1-ARG1
                            REMAINDER-1-ARG2 REMAINDER-X-X))

(PROVE-LEMMA QUOTIENT-NOOP
             (REWRITE)
             (IMPLIES (EQUAL B 1)
                      (EQUAL (QUOTIENT A B) (FIX A)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-OF-NON-NUMBER
             (REWRITE)
             (IMPLIES (NOT (NUMBERP A))
                      (EQUAL (QUOTIENT A N) (QUOTIENT 0 N)))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-ZERO
             (REWRITE)
             (IMPLIES (ZEROP X)
                      (EQUAL (QUOTIENT Y X) 0))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-ADD1
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A B) 0)
                      (EQUAL (QUOTIENT (ADD1 A) B)
                             (IF (EQUAL B 1)
                                 (ADD1 (QUOTIENT A B))
                                 (QUOTIENT A B))))
             ((ENABLE QUOTIENT-NOOP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER A B))
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-QUOTIENT-0
             (REWRITE)
             (EQUAL (EQUAL (QUOTIENT A B) 0)
                    (OR (ZEROP B) (LESSP A B)))
             ((INDUCT (QUOTIENT A B))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-SUB1
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP A)) (NOT (ZEROP B)))
                      (EQUAL (QUOTIENT (SUB1 A) B)
                             (IF (EQUAL (REMAINDER A B) 0)
                                 (SUB1 (QUOTIENT A B))
                                 (QUOTIENT A B))))
             ((ENABLE QUOTIENT-NOOP EQUAL-QUOTIENT-0)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER A B))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER B C) 0)
                      (EQUAL (QUOTIENT (PLUS A B) C)
                             (PLUS (QUOTIENT A C) (QUOTIENT B C))))
             ((ENABLE REMAINDER-NOOP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (AND (EQUAL (QUOTIENT (PLUS A B) C)
                                  (PLUS (QUOTIENT A C) (QUOTIENT B C)))
                           (EQUAL (QUOTIENT (PLUS B A) C)
                                  (PLUS (QUOTIENT A C) (QUOTIENT B C)))
                           (EQUAL (QUOTIENT (PLUS X Y A) C)
                                  (PLUS (QUOTIENT (PLUS X Y) C)
                                        (QUOTIENT A C)))))
             ((USE (QUOTIENT-PLUS-PROOF (A B)
                                        (B A)
                                        (C C))
                   (QUOTIENT-PLUS-PROOF (A A)
                                        (B B)
                                        (C C))
                   (QUOTIENT-PLUS-PROOF (A (PLUS X Y))
                                        (B A)
                                        (C C)))
              (ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY2-OF-PLUS
                      ASSOCIATIVITY-OF-PLUS)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES-INSTANCE-TEMP-PROOF NIL
             (EQUAL (QUOTIENT (TIMES Y X) Y)
                    (IF (ZEROP Y) 0 (FIX X)))
             ((ENABLE TIMES-ZERO COMMUTATIVITY-OF-TIMES
                      DIFFERENCE-PLUS-CANCELLATION)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES-INSTANCE-TEMP
             (REWRITE)
             (AND (EQUAL (QUOTIENT (TIMES Y X) Y)
                         (IF (ZEROP Y) 0 (FIX X)))
                  (EQUAL (QUOTIENT (TIMES X Y) Y)
                         (IF (ZEROP Y) 0 (FIX X))))
             ((USE (QUOTIENT-TIMES-INSTANCE-TEMP-PROOF (X X)
                                                       (Y Y))
                   (QUOTIENT-TIMES-INSTANCE-TEMP-PROOF (X Y)
                                                       (Y X)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE QUOTIENT-TIMES-INSTANCE-TEMP-OFF QUOTIENT-TIMES-INSTANCE-TEMP T)

(PROVE-LEMMA QUOTIENT-TIMES-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (EQUAL (QUOTIENT (TIMES A B) C)
                             (TIMES B (QUOTIENT A C))))
             ((ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (ENABLE QUOTIENT-PLUS QUOTIENT-NOOP EQUAL-QUOTIENT-0
                      QUOTIENT-TIMES-INSTANCE-TEMP)
              (INDUCT (REMAINDER A C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C) 0)
                      (AND (EQUAL (QUOTIENT (TIMES A B) C)
                                  (TIMES B (QUOTIENT A C)))
                           (EQUAL (QUOTIENT (TIMES B A) C)
                                  (TIMES B (QUOTIENT A C)))))
             ((ENABLE COMMUTATIVITY-OF-TIMES)
              (USE (QUOTIENT-TIMES-PROOF (A A)
                                         (B B)
                                         (C C)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES-INSTANCE
             (REWRITE)
             (AND (EQUAL (QUOTIENT (TIMES Y X) Y)
                         (IF (ZEROP Y) 0 (FIX X)))
                  (EQUAL (QUOTIENT (TIMES X Y) Y)
                         (IF (ZEROP Y) 0 (FIX X))))
             ((ENABLE QUOTIENT-TIMES-INSTANCE-TEMP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES-TIMES-PROOF NIL
             (EQUAL (QUOTIENT (TIMES X Y) (TIMES X Z))
                    (IF (ZEROP X) 0 (QUOTIENT Y Z)))
             ((ENABLE-THEORY ADDITION GROUND-ZERO)
              (ENABLE LESSP-TIMES-CANCELLATION1 EQUAL-TIMES-0 TIMES-ZERO
                      COMMUTATIVITY-OF-TIMES TIMES-DISTRIBUTES-OVER-DIFFERENCE)
              (INDUCT (QUOTIENT Y Z))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-TIMES-TIMES
             (REWRITE)
             (AND (EQUAL (QUOTIENT (TIMES X Y) (TIMES X Z))
                         (IF (ZEROP X) 0 (QUOTIENT Y Z)))
                  (EQUAL (QUOTIENT (TIMES X Z) (TIMES Y Z))
                         (IF (ZEROP Z) 0 (QUOTIENT X Y))))
             ((USE (QUOTIENT-TIMES-TIMES-PROOF (X X)
                                               (Y Y)
                                               (Z Z))
                   (QUOTIENT-TIMES-TIMES-PROOF (X Z)
                                               (Y X)
                                               (Z Y)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE QUOTIENT-TIMES-TIMES-OFF QUOTIENT-TIMES-TIMES T)

(PROVE-LEMMA QUOTIENT-DIFFERENCE1
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER A C)
                             (REMAINDER B C))
                      (EQUAL (QUOTIENT (DIFFERENCE A B) C)
                             (DIFFERENCE (QUOTIENT A C)
                                         (QUOTIENT B C))))
             ((ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (ENABLE QUOTIENT-PLUS QUOTIENT-TIMES-INSTANCE
                      EQUAL-REMAINDER-PLUS-REMAINDER)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-LESSP-ARG1
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (EQUAL (QUOTIENT A B) 0))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-DIFFERENCE2
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER A C) 0)
                           (NOT (EQUAL (REMAINDER B C) 0)))
                      (EQUAL (QUOTIENT (DIFFERENCE A B) C)
                             (IF (LESSP B A)
                                 (DIFFERENCE (QUOTIENT A C)
                                             (ADD1 (QUOTIENT B C)))
                                 0)))
             ((ENABLE EQUAL-QUOTIENT-0 EQUAL-REMAINDER-PLUS-0
                      QUOTIENT-TIMES-INSTANCE QUOTIENT-ZERO)
              (DISABLE TIMES-DISTRIBUTES-OVER-PLUS
                       EQUAL-REMAINDER-DIFFERENCE-0 REMAINDER-DIFFERENCE3)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (INDUCT (DOUBLE-REMAINDER-INDUCTION A B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-DIFFERENCE3
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER B C) 0)
                           (NOT (EQUAL (REMAINDER A C) 0)))
                      (EQUAL (QUOTIENT (DIFFERENCE A B) C)
                             (IF (LESSP B A)
                                 (DIFFERENCE (QUOTIENT A C)
                                             (QUOTIENT B C))
                                 0)))
             ((ENABLE EQUAL-QUOTIENT-0 EQUAL-REMAINDER-PLUS-0
                      QUOTIENT-LESSP-ARG1 QUOTIENT-TIMES-INSTANCE
                      QUOTIENT-ZERO)
              (DISABLE TIMES-DISTRIBUTES-OVER-PLUS
                       EQUAL-REMAINDER-DIFFERENCE-0 REMAINDER-DIFFERENCE3)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (INDUCT (DOUBLE-REMAINDER-INDUCTION A B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-EQUALS-ITS-FIRST-ARGUMENT
             (REWRITE)
             (EQUAL (EQUAL A (REMAINDER A B))
                    (AND (NUMBERP A)
                         (OR (ZEROP B) (LESSP A B))))
             ((INDUCT (REMAINDER A B))
              (ENABLE LESSP-REMAINDER REMAINDER-NOOP REMAINDER-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE REMAINDER-EQUALS-ITS-FIRST-ARGUMENT-OFF
        REMAINDER-EQUALS-ITS-FIRST-ARGUMENT T)

(PROVE-LEMMA QUOTIENT-REMAINDER-TIMES
             (REWRITE)
             (EQUAL (QUOTIENT (REMAINDER X (TIMES A B)) A)
                    (REMAINDER (QUOTIENT X A) B))
             ((ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (ENABLE REMAINDER-EQUALS-ITS-FIRST-ARGUMENT QUOTIENT-NOOP
                      QUOTIENT-PLUS QUOTIENT-TIMES-INSTANCE QUOTIENT-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-REMAINDER
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER C A) 0)
                      (EQUAL (QUOTIENT (REMAINDER B C) A)
                             (REMAINDER (QUOTIENT B A)
                                        (QUOTIENT C A))))
             ((ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (ENABLE QUOTIENT-NOOP QUOTIENT-PLUS QUOTIENT-REMAINDER-TIMES
                      QUOTIENT-TIMES-INSTANCE QUOTIENT-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-REMAINDER-INSTANCE
             (REWRITE)
             (EQUAL (QUOTIENT (REMAINDER X (TIMES A B)) A)
                    (REMAINDER (QUOTIENT X A) B))
             ((ENABLE QUOTIENT-REMAINDER QUOTIENT-TIMES-INSTANCE
                      REMAINDER-TIMES1-INSTANCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS-FACT NIL
             (IMPLIES (AND (EQUAL (REMAINDER B X) 0)
                           (EQUAL (REMAINDER C X) 0)
                           (LESSP A X))
                      (EQUAL (QUOTIENT (PLUS A B) C)
                             (QUOTIENT B C)))
             ((ENABLE QUOTIENT-LESSP-ARG1 LESSP-PLUS-FACT)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (INDUCT (QUOTIENT B C))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS-TIMES-TIMES-PROOF NIL
             (IMPLIES (LESSP A B)
                      (EQUAL (QUOTIENT (PLUS A (TIMES B C))
                                       (TIMES B D))
                             (QUOTIENT (TIMES B C) (TIMES B D))))
             ((USE (QUOTIENT-PLUS-FACT (A A)
                                       (X B)
                                       (B (TIMES B C))
                                       (C (TIMES B D))))
              (ENABLE REMAINDER-TIMES1-INSTANCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS-TIMES-TIMES
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (AND (EQUAL (QUOTIENT (PLUS A (TIMES B C))
                                            (TIMES B D))
                                  (QUOTIENT (TIMES B C) (TIMES B D)))
                           (EQUAL (QUOTIENT (PLUS A (TIMES B C))
                                            (TIMES B D))
                                  (QUOTIENT (TIMES B C) (TIMES B D)))))
             ((USE (QUOTIENT-PLUS-TIMES-TIMES-PROOF (A A)
                                                    (B B)
                                                    (C C)
                                                    (D D)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-PLUS-TIMES-TIMES-INSTANCE
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (AND (EQUAL (QUOTIENT (PLUS A (TIMES B C) (TIMES B D))
                                            (TIMES B E))
                                  (IF (ZEROP B)
                                      0
                                      (QUOTIENT (PLUS C D) E)))
                           (EQUAL (QUOTIENT (PLUS A (TIMES C B) (TIMES D B))
                                            (TIMES E B))
                                  (IF (ZEROP B)
                                      0
                                      (QUOTIENT (PLUS D C) E)))))
             ((ENABLE COMMUTATIVITY-OF-TIMES COMMUTATIVITY-OF-PLUS
                      QUOTIENT-TIMES-TIMES QUOTIENT-PLUS-TIMES-TIMES)
              (USE (TIMES-DISTRIBUTES-OVER-PLUS (X B)
                                                (Y C)
                                                (Z D)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-QUOTIENT
             (REWRITE)
             (EQUAL (QUOTIENT (QUOTIENT B A) C)
                    (QUOTIENT B (TIMES A C)))
             ((ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (DISABLE TIMES-DISTRIBUTES-OVER-PLUS)
              (ENABLE QUOTIENT-LESSP-ARG1 QUOTIENT-PLUS
                      QUOTIENT-PLUS-TIMES-TIMES QUOTIENT-TIMES-INSTANCE
                      QUOTIENT-TIMES-TIMES QUOTIENT-NOOP QUOTIENT-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LEQ-QUOTIENT NIL
             (IMPLIES (LESSP A B)
                      (IF (LESSP (QUOTIENT B C) (QUOTIENT A C))
                          F T))
             ((INDUCT (DOUBLE-REMAINDER-INDUCTION A B C))
              (ENABLE QUOTIENT-LESSP-ARG1 QUOTIENT-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-1-ARG2
             (REWRITE)
             (EQUAL (QUOTIENT N 1) (FIX N))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-1-ARG1-CASESPLIT NIL
             (OR (ZEROP N) (EQUAL N 1) (LESSP 1 N))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-1-ARG1
             (REWRITE)
             (EQUAL (QUOTIENT 1 N)
                    (IF (EQUAL N 1) 1 0))
             ((ENABLE QUOTIENT-LESSP-ARG1)
              (USE (QUOTIENT-1-ARG1-CASESPLIT))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-X-X
             (REWRITE)
             (IMPLIES (NOT (ZEROP X))
                      (EQUAL (QUOTIENT X X) 1))
             ((ENABLE DIFFERENCE-X-X)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-QUOTIENT
             (REWRITE)
             (EQUAL (LESSP (QUOTIENT I J) I)
                    (AND (NOT (ZEROP I))
                         (NOT (EQUAL J 1))))
             ((ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN CANCEL-QUOTIENT-TIMES
 (X)
 (IF
  (AND (EQUAL (CAR X) 'QUOTIENT)
       (EQUAL (CAADR X) 'TIMES)
       (EQUAL (CAADDR X) 'TIMES))
  (IF
   (LISTP (BAGINT (TIMES-FRINGE (CADR X))
                  (TIMES-FRINGE (CADDR X))))
   (CONS 'IF
    (CONS (AND-NOT-ZEROP-TREE (BAGINT (TIMES-FRINGE (CADR X))
                                      (TIMES-FRINGE (CADDR X))))
          (CONS (LIST 'QUOTIENT
                      (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADR X))
                                           (BAGINT (TIMES-FRINGE (CADR X))
                                                   (TIMES-FRINGE (CADDR X)))))
                      (TIMES-TREE (BAGDIFF (TIMES-FRINGE (CADDR X))
                                           (BAGINT (TIMES-FRINGE (CADR X))
                                                   (TIMES-FRINGE (CADDR X))))))
                '((ZERO)))))
   X)
  X))

(PROVE-LEMMA ZEROP-MAKES-QUOTIENT-ZERO-BRIDGE
       (REWRITE)
       (IMPLIES (AND (EQUAL (CAR X) 'TIMES)
                     (EQUAL (CAR Y) 'TIMES)
                     (NOT (EVAL$ T
                                 (AND-NOT-ZEROP-TREE (BAGINT (TIMES-FRINGE X)
                                                             (TIMES-FRINGE Y)))
                                 A)))
                (EQUAL (QUOTIENT (TIMES (EVAL$ T (CADR X) A)
                                        (EVAL$ T (CADDR X) A))
                                 (TIMES (EVAL$ T (CADR Y) A)
                                        (EVAL$ T (CADDR Y) A)))
                       0))
       ((USE (ZEROP-MAKES-TIMES-TREE-ZERO (X (BAGINT (TIMES-FRINGE X)
                                                     (TIMES-FRINGE Y)))
                                          (Y (TIMES-FRINGE X)))
             (ZEROP-MAKES-TIMES-TREE-ZERO (X (BAGINT (TIMES-FRINGE X)
                                                     (TIMES-FRINGE Y)))
                                          (Y (TIMES-FRINGE Y))))
        (ENABLE AND-NOT-ZEROP-TREE BAGINT DELETE EQUAL-QUOTIENT-0
                EQUAL-TIMES-0 EVAL$-TIMES SUBBAGP-BAGINT1 SUBBAGP-BAGINT2
                TIMES-FRINGE TIMES-TREE TIMES-TREE-APPEND
                TIMES-TREE-OF-TIMES-FRINGE ZEROP-MAKES-LESSP-FALSE-BRIDGE)
        (ENABLE-THEORY GROUND-ZERO)
        (DISABLE-THEORY T)))

(TOGGLE ZEROP-MAKES-QUOTIENT-ZERO-BRIDGE-OFF ZEROP-MAKES-QUOTIENT-ZERO-BRIDGE T)

(PROVE-LEMMA EVAL$-QUOTIENT-TIMES-TREE-BAGDIFF
             (REWRITE)
             (IMPLIES (AND (SUBBAGP X Y)
                           (SUBBAGP X Z)
                           (EVAL$ T (AND-NOT-ZEROP-TREE X) A))
                      (EQUAL (QUOTIENT (EVAL$ T (TIMES-TREE (BAGDIFF Y X)) A)
                                       (EVAL$ T
                                              (TIMES-TREE (BAGDIFF Z X))
                                              A))
                             (QUOTIENT (EVAL$ T (TIMES-TREE Y) A)
                                       (EVAL$ T (TIMES-TREE Z) A))))
             ((ENABLE AND-NOT-ZEROP-TREE BAGDIFF EQUAL-QUOTIENT-0
                      EVAL$-TIMES-MEMBER NUMBERP-EVAL$-TIMES-TREE
                      QUOTIENT-TIMES-TIMES SUBBAGP SUBBAGP-CDR1 SUBBAGP-CDR2
                      TIMES-TREE ZEROP-MAKES-TIMES-TREE-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE EVAL$-QUOTIENT-TIMES-TREE-BAGDIFF-OFF EVAL$-QUOTIENT-TIMES-TREE-BAGDIFF
        T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES
             ((META QUOTIENT))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-QUOTIENT-TIMES X) A))
             ((ENABLE CANCEL-QUOTIENT-TIMES EVAL$-QUOTIENT-TIMES-TREE-BAGDIFF
                      EVAL$-QUOTIENT EVAL$-TIMES SUBBAGP-BAGINT1
                      SUBBAGP-BAGINT2 TIMES-TREE-OF-TIMES-FRINGE
                      ZEROP-MAKES-QUOTIENT-ZERO-BRIDGE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY QUOTIENTS
           (QUOTIENT-NOOP QUOTIENT-OF-NON-NUMBER QUOTIENT-ZERO QUOTIENT-ADD1
                          EQUAL-QUOTIENT-0 QUOTIENT-SUB1 QUOTIENT-PLUS
                          QUOTIENT-TIMES QUOTIENT-TIMES-INSTANCE
                          QUOTIENT-DIFFERENCE1 QUOTIENT-LESSP-ARG1
                          QUOTIENT-DIFFERENCE2 QUOTIENT-DIFFERENCE3
                          QUOTIENT-REMAINDER-TIMES QUOTIENT-REMAINDER
                          QUOTIENT-REMAINDER-INSTANCE
                          QUOTIENT-PLUS-TIMES-TIMES
                          QUOTIENT-PLUS-TIMES-TIMES-INSTANCE QUOTIENT-QUOTIENT
                          QUOTIENT-1-ARG2 QUOTIENT-1-ARG1 QUOTIENT-X-X
                          LESSP-QUOTIENT CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES))

(DEFN EXP
      (I J)
      (IF (ZEROP J)
          1
          (TIMES I (EXP I (SUB1 J)))))

(DEFN LOG
      (BASE N)
      (COND ((LESSP BASE 2) 0)
            ((ZEROP N) 0)
            (T (ADD1 (LOG BASE (QUOTIENT N BASE))))))

(DEFN GCD
      (X Y)
      (COND ((ZEROP X) (FIX Y))
            ((ZEROP Y) X)
            ((LESSP X Y) (GCD X (DIFFERENCE Y X)))
            (T (GCD (DIFFERENCE X Y) Y)))
      ((ORD-LESSP (CONS (ADD1 X) (FIX Y)))))

(PROVE-LEMMA REMAINDER-EXP
             (REWRITE)
             (IMPLIES (NOT (ZEROP K))
                      (EQUAL (REMAINDER (EXP N K) N) 0))
             ((ENABLE EXP REMAINDER-TIMES1-INSTANCE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN DOUBLE-NUMBER-INDUCTION
      (I J)
      (COND ((ZEROP I) 0)
            ((ZEROP J) 0)
            (T (DOUBLE-NUMBER-INDUCTION (SUB1 I)
                                        (SUB1 J)))))

(PROVE-LEMMA REMAINDER-EXP-EXP
             (REWRITE)
             (IMPLIES (IF (LESSP J I) F T)
                      (EQUAL (REMAINDER (EXP A J) (EXP A I))
                             0))
             ((ENABLE EXP REMAINDER-1-ARG2 REMAINDER-TIMES2-INSTANCE)
              (ENABLE-THEORY ADDITION MULTIPLICATION GROUND-ZERO)
              (INDUCT (DOUBLE-NUMBER-INDUCTION I J))
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-EXP
             (REWRITE)
             (IMPLIES (NOT (ZEROP K))
                      (EQUAL (QUOTIENT (EXP N K) N)
                             (IF (ZEROP N) 0 (EXP N (SUB1 K)))))
             ((ENABLE EXP QUOTIENT-TIMES-INSTANCE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-ZERO
             (REWRITE)
             (IMPLIES (ZEROP K)
                      (EQUAL (EXP N K) 1))
             ((ENABLE EXP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-ADD1
             (REWRITE)
             (EQUAL (EXP N (ADD1 K))
                    (TIMES N (EXP N K)))
             ((ENABLE EXP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-PLUS
             (REWRITE)
             (EQUAL (EXP I (PLUS J K))
                    (TIMES (EXP I J) (EXP I K)))
             ((ENABLE EXP ASSOCIATIVITY-OF-TIMES COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-0-ARG1
             (REWRITE)
             (EQUAL (EXP 0 K) (IF (ZEROP K) 1 0))
             ((ENABLE EXP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-1-ARG1
             (REWRITE)
             (EQUAL (EXP 1 K) 1)
             ((ENABLE EXP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-0-ARG2
             (REWRITE)
             (EQUAL (EXP N 0) 1)
             ((ENABLE EXP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-TIMES
             (REWRITE)
             (EQUAL (EXP (TIMES I J) K)
                    (TIMES (EXP I K) (EXP J K)))
             ((ENABLE EXP ASSOCIATIVITY-OF-TIMES COMMUTATIVITY2-OF-TIMES
                      EXP-ZERO)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-EXP
             (REWRITE)
             (EQUAL (EXP (EXP I J) K)
                    (EXP I (TIMES J K)))
             ((ENABLE EXP EXP-ZERO EXP-1-ARG1 EXP-PLUS EXP-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-EXP-0
             (REWRITE)
             (EQUAL (EQUAL (EXP N K) 0)
                    (AND (ZEROP N) (NOT (ZEROP K))))
             ((ENABLE EXP EQUAL-TIMES-0)
              (INDUCT (EXP N K))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-EXP-1
             (REWRITE)
             (EQUAL (EQUAL (EXP N K) 1)
                    (IF (ZEROP K) T (EQUAL N 1)))
             ((ENABLE EXP TIMES-ZERO TIMES-ADD1)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EXP-DIFFERENCE
             (REWRITE)
             (IMPLIES (AND (IF (LESSP B C) F T)
                           (NOT (ZEROP A)))
                      (EQUAL (EXP A (DIFFERENCE B C))
                             (QUOTIENT (EXP A B) (EXP A C))))
             ((ENABLE EXP)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY EXPONENTIATION
           (EQUAL-EXP-0 EQUAL-EXP-1 EXP-EXP EXP-ADD1 EXP-TIMES EXP-1-ARG1
                        EXP-ZERO EXP-0-ARG2 EXP-0-ARG1 EXP-DIFFERENCE EXP-PLUS
                        QUOTIENT-EXP REMAINDER-EXP-EXP REMAINDER-EXP))

(PROVE-LEMMA EQUAL-LOG-0
             (REWRITE)
             (EQUAL (EQUAL (LOG BASE N) 0)
                    (OR (LESSP BASE 2) (ZEROP N)))
             ((ENABLE LOG)
              (INDUCT (LOG BASE N))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-0
             (REWRITE)
             (IMPLIES (ZEROP N)
                      (EQUAL (LOG BASE N) 0))
             ((ENABLE LOG)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-1
             (REWRITE)
             (IMPLIES (LESSP 1 BASE)
                      (EQUAL (LOG BASE 1) 1))
             ((ENABLE LOG)
              (INDUCT (LOG BASE N))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN DOUBLE-LOG-INDUCTION
      (BASE A B)
      (COND ((LESSP BASE 2) 0)
            ((ZEROP A) 0)
            ((ZEROP B) 0)
            (T (DOUBLE-LOG-INDUCTION BASE
                                     (QUOTIENT A BASE)
                                     (QUOTIENT B BASE)))))

(PROVE-LEMMA LEQ-LOG-LOG NIL
             (IMPLIES (IF (LESSP M N) F T)
                      (IF (LESSP (LOG C M) (LOG C N)) F T))
             ((ENABLE LOG)
              (INDUCT (DOUBLE-LOG-INDUCTION C N M))
              (USE (LEQ-QUOTIENT (A N) (B M) (C C)))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-QUOTIENT
             (REWRITE)
             (IMPLIES (LESSP 1 C)
                      (EQUAL (LOG C (QUOTIENT N C))
                             (SUB1 (LOG C N))))
             ((ENABLE LOG)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-QUOTIENT-TIMES-PROOF NIL
             (IMPLIES (LESSP 1 C)
                      (EQUAL (LOG C (QUOTIENT N (TIMES C M)))
                             (SUB1 (LOG C (QUOTIENT N M)))))
             ((ENABLE LOG)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-QUOTIENT-TIMES
             (REWRITE)
             (IMPLIES (LESSP 1 C)
                      (AND (EQUAL (LOG C (QUOTIENT N (TIMES C M)))
                                  (SUB1 (LOG C (QUOTIENT N M))))
                           (EQUAL (LOG C (QUOTIENT N (TIMES M C)))
                                  (SUB1 (LOG C (QUOTIENT N M))))))
             ((USE (LOG-QUOTIENT-TIMES-PROOF (C C)
                                             (N N)
                                             (M M)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-QUOTIENT-EXP
             (REWRITE)
             (IMPLIES (LESSP 1 C)
                      (EQUAL (LOG C (QUOTIENT N (EXP C M)))
                             (DIFFERENCE (LOG C N) M)))
             ((ENABLE EXP LOG LOG-QUOTIENT-TIMES)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-TIMES-PROOF NIL
             (IMPLIES (AND (LESSP 1 C) (NOT (ZEROP N)))
                      (EQUAL (LOG C (TIMES C N))
                             (ADD1 (LOG C N))))
             ((ENABLE LOG)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-TIMES
             (REWRITE)
             (IMPLIES (AND (LESSP 1 C) (NOT (ZEROP N)))
                      (AND (EQUAL (LOG C (TIMES C N))
                                  (ADD1 (LOG C N)))
                           (EQUAL (LOG C (TIMES N C))
                                  (ADD1 (LOG C N)))))
             ((USE (LOG-TIMES-PROOF (C C) (N N)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-TIMES-EXP-PROOF NIL
             (IMPLIES (AND (LESSP 1 C) (NOT (ZEROP N)))
                      (EQUAL (LOG C (TIMES N (EXP C M)))
                             (PLUS (LOG C N) M)))
             ((ENABLE LOG EXP)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-TIMES-EXP
             (REWRITE)
             (IMPLIES (AND (LESSP 1 C) (NOT (ZEROP N)))
                      (AND (EQUAL (LOG C (TIMES N (EXP C M)))
                                  (PLUS (LOG C N) M))
                           (EQUAL (LOG C (TIMES (EXP C M) N))
                                  (PLUS (LOG C N) M))))
             ((USE (LOG-TIMES-EXP-PROOF (C C)
                                        (N N)
                                        (M M)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA LOG-EXP
             (REWRITE)
             (IMPLIES (LESSP 1 C)
                      (EQUAL (LOG C (EXP C N)) (ADD1 N)))
             ((ENABLE LOG EXP LOG-1)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS QUOTIENTS
                             GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFTHEORY LOGS
           (LOG-EXP LOG-TIMES-EXP LOG-TIMES LOG-QUOTIENT-EXP
                    LOG-QUOTIENT-TIMES LOG-QUOTIENT LOG-1 LOG-0 EQUAL-LOG-0
                    EXP-EXP))

(PROVE-LEMMA COMMUTATIVITY-OF-GCD
             (REWRITE)
             (EQUAL (GCD B A) (GCD A B))
             ((ENABLE GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN SINGLE-NUMBER-INDUCTION
      (N)
      (IF (ZEROP N)
          0
          (SINGLE-NUMBER-INDUCTION (SUB1 N))))

(PROVE-LEMMA GCD-0
             (REWRITE)
             (AND (EQUAL (GCD 0 X) (FIX X))
                  (EQUAL (GCD X 0) (FIX X)))
             ((ENABLE GCD)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-1
             (REWRITE)
             (AND (EQUAL (GCD 1 X) 1)
                  (EQUAL (GCD X 1) 1))
             ((ENABLE GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (SINGLE-NUMBER-INDUCTION X))
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-GCD-0
             (REWRITE)
             (EQUAL (EQUAL (GCD A B) 0)
                    (AND (ZEROP A) (ZEROP B)))
             ((ENABLE GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (GCD A B))
              (DISABLE-THEORY T)))

(PROVE-LEMMA LESSP-GCD
             (REWRITE)
             (IMPLIES (NOT (ZEROP B))
                      (AND (EQUAL (LESSP B (GCD A B)) F)
                           (EQUAL (LESSP B (GCD B A)) F)))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-PLUS-INSTANCE-TEMP-PROOF NIL
             (EQUAL (GCD A (PLUS A B)) (GCD A B))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (GCD A B))
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-PLUS-INSTANCE-TEMP
             (REWRITE)
             (AND (EQUAL (GCD A (PLUS A B)) (GCD A B))
                  (EQUAL (GCD A (PLUS B A)) (GCD A B)))
             ((ENABLE COMMUTATIVITY-OF-PLUS)
              (USE (GCD-PLUS-INSTANCE-TEMP-PROOF (A A)
                                                 (B B)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-PLUS-PROOF NIL
             (IMPLIES (EQUAL (REMAINDER B A) 0)
                      (EQUAL (GCD A (PLUS B C)) (GCD A C)))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD GCD-1 GCD-PLUS-INSTANCE-TEMP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (REMAINDER B A))
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-PLUS
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER B A) 0)
                      (AND (EQUAL (GCD A (PLUS B C)) (GCD A C))
                           (EQUAL (GCD A (PLUS C B)) (GCD A C))
                           (EQUAL (GCD (PLUS B C) A) (GCD A C))
                           (EQUAL (GCD (PLUS C B) A) (GCD A C))))
             ((ENABLE COMMUTATIVITY-OF-PLUS COMMUTATIVITY-OF-GCD)
              (USE (GCD-PLUS-PROOF (A A) (B B) (C C)))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-PLUS-INSTANCE
             (REWRITE)
             (AND (EQUAL (GCD A (PLUS A B)) (GCD A B))
                  (EQUAL (GCD A (PLUS B A)) (GCD A B)))
             ((ENABLE GCD-PLUS-INSTANCE-TEMP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA REMAINDER-GCD
             (REWRITE)
             (AND (EQUAL (REMAINDER A (GCD A B)) 0)
                  (EQUAL (REMAINDER B (GCD A B)) 0))
             ((ENABLE GCD)
              (ENABLE-THEORY ADDITION REMAINDERS GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF NIL
             (EQUAL (GCD (TIMES X Z) (TIMES Y Z))
                    (TIMES Z (GCD X Y)))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD GCD-0 GCD-PLUS)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DISTRIBUTIVITY-OF-TIMES-OVER-GCD
             (REWRITE)
             (AND (EQUAL (GCD (TIMES X Z) (TIMES Y Z))
                         (TIMES Z (GCD X Y)))
                  (EQUAL (GCD (TIMES Z X) (TIMES Y Z))
                         (TIMES Z (GCD X Y)))
                  (EQUAL (GCD (TIMES X Z) (TIMES Z Y))
                         (TIMES Z (GCD X Y)))
                  (EQUAL (GCD (TIMES Z X) (TIMES Z Y))
                         (TIMES Z (GCD X Y))))
             ((USE (DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF (X X)
                                                           (Y Y)
                                                           (Z Z)))
              (ENABLE COMMUTATIVITY-OF-TIMES)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-IS-THE-GREATEST NIL
             (IMPLIES (AND (NOT (ZEROP X))
                           (NOT (ZEROP Y))
                           (EQUAL (REMAINDER X Z) 0)
                           (EQUAL (REMAINDER Y Z) 0))
                      (IF (LESSP (GCD X Y) Z) F T))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD
                      DISTRIBUTIVITY-OF-TIMES-OVER-GCD EQUAL-GCD-0)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMON-DIVISOR-DIVIDES-GCD
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER X Z) 0)
                           (EQUAL (REMAINDER Y Z) 0))
                      (EQUAL (REMAINDER (GCD X Y) Z) 0))
             ((ENABLE GCD COMMUTATIVITY-OF-GCD
                      DISTRIBUTIVITY-OF-TIMES-OVER-GCD EQUAL-GCD-0)
              (ENABLE-THEORY ADDITION MULTIPLICATION REMAINDERS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-GCD-ZERO-CASE NIL
             (IMPLIES (OR (ZEROP A) (ZEROP B) (ZEROP C))
                      (EQUAL (GCD (GCD A B) C)
                             (GCD A (GCD B C))))
             ((ENABLE GCD GCD-0)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-GCD
             (REWRITE)
             (EQUAL (GCD (GCD A B) C)
                    (GCD A (GCD B C)))
             ((ENABLE EQUAL-GCD-0 REMAINDER-GCD)
              (USE (GCD-IS-THE-GREATEST (X A)
                                        (Y (GCD B C))
                                        (Z (GCD (GCD A B) C)))
                   (GCD-IS-THE-GREATEST (X (GCD A B))
                                        (Y C)
                                        (Z (GCD A (GCD B C))))
                   (ASSOCIATIVITY-OF-GCD-ZERO-CASE (A A)
                                                   (B B)
                                                   (C C))
                   (TRANSITIVITY-OF-DIVIDES (A A)
                                            (B (GCD A B))
                                            (C (GCD (GCD A B) C)))
                   (TRANSITIVITY-OF-DIVIDES (A B)
                                            (B (GCD A B))
                                            (C (GCD (GCD A B) C)))
                   (TRANSITIVITY-OF-DIVIDES (A B)
                                            (B (GCD B C))
                                            (C (GCD A (GCD B C))))
                   (TRANSITIVITY-OF-DIVIDES (A C)
                                            (B (GCD B C))
                                            (C (GCD A (GCD B C))))
                   (COMMON-DIVISOR-DIVIDES-GCD (X B)
                                               (Y C)
                                               (Z (GCD (GCD A B) C)))
                   (COMMON-DIVISOR-DIVIDES-GCD (X A)
                                               (Y B)
                                               (Z (GCD A (GCD B C)))))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-GCD-ZERO-CASE NIL
             (IMPLIES (OR (ZEROP A) (ZEROP B) (ZEROP C))
                      (EQUAL (GCD B (GCD A C))
                             (GCD A (GCD B C))))
             ((ENABLE GCD GCD-0 COMMUTATIVITY-OF-GCD)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-GCD
             (REWRITE)
             (EQUAL (GCD B (GCD A C))
                    (GCD A (GCD B C)))
             ((ENABLE EQUAL-GCD-0 REMAINDER-GCD)
              (USE (GCD-IS-THE-GREATEST (X A)
                                        (Y (GCD B C))
                                        (Z (GCD B (GCD A C))))
                   (GCD-IS-THE-GREATEST (X B)
                                        (Y (GCD A C))
                                        (Z (GCD A (GCD B C))))
                   (COMMUTATIVITY2-OF-GCD-ZERO-CASE (A A)
                                                    (B B)
                                                    (C C))
                   (TRANSITIVITY-OF-DIVIDES (A A)
                                            (B (GCD A C))
                                            (C (GCD B (GCD A C))))
                   (TRANSITIVITY-OF-DIVIDES (A C)
                                            (B (GCD A C))
                                            (C (GCD B (GCD A C))))
                   (TRANSITIVITY-OF-DIVIDES (A B)
                                            (B (GCD B C))
                                            (C (GCD A (GCD B C))))
                   (TRANSITIVITY-OF-DIVIDES (A C)
                                            (B (GCD B C))
                                            (C (GCD A (GCD B C))))
                   (COMMON-DIVISOR-DIVIDES-GCD (X B)
                                               (Y C)
                                               (Z (GCD B (GCD A C))))
                   (COMMON-DIVISOR-DIVIDES-GCD (X A)
                                               (Y C)
                                               (Z (GCD A (GCD B C)))))
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-X-X
             (REWRITE)
             (EQUAL (GCD X X) (FIX X))
             ((ENABLE GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (SINGLE-NUMBER-INDUCTION X))
              (DISABLE-THEORY T)))

(PROVE-LEMMA GCD-IDEMPOTENCE
             (REWRITE)
             (AND (EQUAL (GCD X (GCD X Y)) (GCD X Y))
                  (EQUAL (GCD Y (GCD X Y)) (GCD X Y)))
             ((ENABLE GCD GCD-X-X GCD-PLUS REMAINDER-GCD GCD-1
                      COMMUTATIVITY-OF-GCD)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (INDUCT (GCD X Y))
              (DISABLE-THEORY T)))

(DEFTHEORY GCDS
           (COMMUTATIVITY2-OF-GCD ASSOCIATIVITY-OF-GCD
                                  COMMON-DIVISOR-DIVIDES-GCD
                                  DISTRIBUTIVITY-OF-TIMES-OVER-GCD LESSP-GCD
                                  EQUAL-GCD-0 GCD-0 GCD-IDEMPOTENCE GCD-X-X
                                  REMAINDER-GCD GCD-PLUS GCD-PLUS-INSTANCE
                                  GCD-1 COMMUTATIVITY-OF-GCD))

(DEFTHEORY NATURALS
           (ADDITION MULTIPLICATION REMAINDERS QUOTIENTS EXPONENTIATION LOGS
                     GCDS))

(DEFN INTEGERP
      (X)
      (COND ((NUMBERP X) T)
            ((NEGATIVEP X)
             (NOT (ZEROP (NEGATIVE-GUTS X))))
            (T F)))

(DEFN FIX-INT
      (X)
      (IF (INTEGERP X) X 0))

(DEFN IZEROP
      (I)
      (EQUAL (FIX-INT I) 0))

(DEFN ILESSP
      (I J)
      (COND ((NEGATIVEP I)
             (COND ((NEGATIVEP J)
                    (LESSP (NEGATIVE-GUTS J)
                           (NEGATIVE-GUTS I)))
                   ((EQUAL I (MINUS 0)) (LESSP 0 J))
                   (T T)))
            ((NEGATIVEP J) F)
            (T (LESSP I J))))

(DEFN ILEQ (I J) (NOT (ILESSP J I)))

(DEFN IPLUS
      (X Y)
      (COND ((NEGATIVEP X)
             (COND ((NEGATIVEP Y)
                    (IF (AND (ZEROP (NEGATIVE-GUTS X))
                             (ZEROP (NEGATIVE-GUTS Y)))
                        0
                        (MINUS (PLUS (NEGATIVE-GUTS X)
                                     (NEGATIVE-GUTS Y)))))
                   ((LESSP Y (NEGATIVE-GUTS X))
                    (MINUS (DIFFERENCE (NEGATIVE-GUTS X) Y)))
                   (T (DIFFERENCE Y (NEGATIVE-GUTS X)))))
            ((NEGATIVEP Y)
             (IF (LESSP X (NEGATIVE-GUTS Y))
                 (MINUS (DIFFERENCE (NEGATIVE-GUTS Y) X))
                 (DIFFERENCE X (NEGATIVE-GUTS Y))))
            (T (PLUS X Y))))

(DEFN INEG
      (X)
      (COND ((NEGATIVEP X) (NEGATIVE-GUTS X))
            ((ZEROP X) 0)
            (T (MINUS X))))

(DEFN IDIFFERENCE
      (X Y)
      (IPLUS X (INEG Y)))

(DEFN IABS
      (I)
      (IF (NEGATIVEP I)
          (NEGATIVE-GUTS I)
          (FIX I)))

(DEFN ITIMES
      (I J)
      (COND ((NEGATIVEP I)
             (IF (NEGATIVEP J)
                 (TIMES (NEGATIVE-GUTS I)
                        (NEGATIVE-GUTS J))
                 (FIX-INT (MINUS (TIMES (NEGATIVE-GUTS I) J)))))
            ((NEGATIVEP J)
             (FIX-INT (MINUS (TIMES I (NEGATIVE-GUTS J)))))
            (T (TIMES I J))))

(DEFN IQUOTIENT
     (I J)
     (COND ((EQUAL (FIX-INT J) 0) 0)
           ((NEGATIVEP I)
            (COND ((NEGATIVEP J)
                   (IF (EQUAL (REMAINDER (NEGATIVE-GUTS I)
                                         (NEGATIVE-GUTS J))
                              0)
                       (QUOTIENT (NEGATIVE-GUTS I)
                                 (NEGATIVE-GUTS J))
                       (ADD1 (QUOTIENT (NEGATIVE-GUTS I)
                                       (NEGATIVE-GUTS J)))))
                  ((EQUAL (REMAINDER (NEGATIVE-GUTS I) J)
                          0)
                   (FIX-INT (MINUS (QUOTIENT (NEGATIVE-GUTS I) J))))
                  (T (FIX-INT (MINUS (ADD1 (QUOTIENT (NEGATIVE-GUTS I) J)))))))
           ((NEGATIVEP J)
            (FIX-INT (MINUS (QUOTIENT I (NEGATIVE-GUTS J)))))
           (T (QUOTIENT I J))))

(DEFN IREMAINDER
      (I J)
      (IDIFFERENCE I
                   (ITIMES J (IQUOTIENT I J))))

(DEFN IDIV
     (I J)
     (COND ((EQUAL (FIX-INT J) 0) 0)
           ((NEGATIVEP I)
            (COND ((NEGATIVEP J)
                   (QUOTIENT (NEGATIVE-GUTS I)
                             (NEGATIVE-GUTS J)))
                  ((EQUAL (REMAINDER (NEGATIVE-GUTS I) J)
                          0)
                   (FIX-INT (MINUS (QUOTIENT (NEGATIVE-GUTS I) J))))
                  (T (FIX-INT (MINUS (ADD1 (QUOTIENT (NEGATIVE-GUTS I) J)))))))
           ((NEGATIVEP J)
            (IF (EQUAL (REMAINDER I (NEGATIVE-GUTS J))
                       0)
                (FIX-INT (MINUS (QUOTIENT I (NEGATIVE-GUTS J))))
                (FIX-INT (MINUS (ADD1 (QUOTIENT I (NEGATIVE-GUTS J)))))))
           (T (QUOTIENT I J))))

(DEFN IMOD
      (I J)
      (IDIFFERENCE (FIX-INT I)
                   (ITIMES J (IDIV I J))))

(DEFN IQUO
      (I J)
      (COND ((EQUAL (FIX-INT J) 0) 0)
            ((NEGATIVEP I)
             (IF (NEGATIVEP J)
                 (QUOTIENT (NEGATIVE-GUTS I)
                           (NEGATIVE-GUTS J))
                 (FIX-INT (MINUS (QUOTIENT (NEGATIVE-GUTS I) J)))))
            ((NEGATIVEP J)
             (FIX-INT (MINUS (QUOTIENT I (NEGATIVE-GUTS J)))))
            (T (QUOTIENT I J))))

(DEFN IREM
      (I J)
      (IDIFFERENCE (FIX-INT I)
                   (ITIMES J (IQUO I J))))

(DEFTHEORY INTEGER-DEFNS
           (INTEGERP FIX-INT ILESSP IPLUS INEG IABS ITIMES IQUOTIENT
                     IREMAINDER IDIV IMOD IQUO IREM))

(DEFTHEORY ALL-INTEGER-DEFNS
           (INTEGERP FIX-INT IZEROP ILESSP ILEQ IPLUS INEG IDIFFERENCE IABS
                     ITIMES IQUOTIENT IREMAINDER IDIV IMOD IQUO IREM))

(TOGGLE INTEGERP-OFF INTEGERP T)

(TOGGLE FIX-INT-OFF FIX-INT T)

(TOGGLE ILESSP-OFF ILESSP T)

(TOGGLE IPLUS-OFF IPLUS T)

(TOGGLE INEG-OFF INEG T)

(TOGGLE IABS-OFF IABS T)

(TOGGLE ITIMES-OFF ITIMES T)

(PROVE-LEMMA INTEGERP-FIX-INT
             (REWRITE)
             (INTEGERP (FIX-INT X))
             ((ENABLE INTEGERP FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IPLUS
             (REWRITE)
             (INTEGERP (IPLUS X Y))
             ((ENABLE INTEGERP IPLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IDIFFERENCE
             (REWRITE)
             (INTEGERP (IDIFFERENCE X Y))
             ((ENABLE INTEGERP-IPLUS IDIFFERENCE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-INEG
             (REWRITE)
             (INTEGERP (INEG X))
             ((ENABLE INTEGERP INEG)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IABS
             (REWRITE)
             (INTEGERP (IABS X))
             ((ENABLE INTEGERP IABS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-ITIMES
             (REWRITE)
             (INTEGERP (ITIMES X Y))
             ((ENABLE INTEGERP ITIMES FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-REMOVER
             (REWRITE)
             (IMPLIES (INTEGERP X)
                      (EQUAL (FIX-INT X) X))
             ((ENABLE FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-FIX-INT
             (REWRITE)
             (EQUAL (FIX-INT (FIX-INT X))
                    (FIX-INT X))
             ((ENABLE FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IPLUS
             (REWRITE)
             (EQUAL (FIX-INT (IPLUS A B))
                    (IPLUS A B))
             ((ENABLE FIX-INT INTEGERP IPLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IDIFFERENCE
             (REWRITE)
             (EQUAL (FIX-INT (IDIFFERENCE A B))
                    (IDIFFERENCE A B))
             ((ENABLE FIX-INT-IPLUS IDIFFERENCE)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-INEG
             (REWRITE)
             (EQUAL (FIX-INT (INEG X)) (INEG X))
             ((ENABLE FIX-INT INTEGERP INEG)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IABS
             (REWRITE)
             (EQUAL (FIX-INT (IABS X)) (IABS X))
             ((ENABLE INTEGERP FIX-INT IABS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-ITIMES
             (REWRITE)
             (EQUAL (FIX-INT (ITIMES X Y))
                    (ITIMES X Y))
             ((ENABLE INTEGERP ITIMES FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INEG-IPLUS
             (REWRITE)
             (EQUAL (INEG (IPLUS A B))
                    (IPLUS (INEG A) (INEG B)))
             ((ENABLE IPLUS INEG PLUS-ZERO-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INEG-INEG
             (REWRITE)
             (EQUAL (INEG (INEG X)) (FIX-INT X))
             ((ENABLE INEG FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INEG-FIX-INT
             (REWRITE)
             (EQUAL (INEG (FIX-INT X)) (INEG X))
             ((ENABLE INEG FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INEG-OF-NON-INTEGERP
             (REWRITE)
             (IMPLIES (NOT (INTEGERP X))
                      (EQUAL (INEG X) 0))
             ((ENABLE INEG INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE INEG-OF-NON-INTEGERP-OFF INEG-OF-NON-INTEGERP T)

(PROVE-LEMMA INEG-0
             (REWRITE)
             (EQUAL (INEG 0) 0)
             ((ENABLE INEG)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-LEFT-ID
             (REWRITE)
             (IMPLIES (NOT (INTEGERP X))
                      (EQUAL (IPLUS X Y) (FIX-INT Y)))
             ((ENABLE INTEGERP IPLUS FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE IPLUS-LEFT-ID-OFF IPLUS-LEFT-ID T)

(PROVE-LEMMA IPLUS-RIGHT-ID
             (REWRITE)
             (IMPLIES (NOT (INTEGERP Y))
                      (EQUAL (IPLUS X Y) (FIX-INT X)))
             ((ENABLE INTEGERP IPLUS FIX-INT PLUS-ZERO-ARG2)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE IPLUS-RIGHT-ID-OFF IPLUS-RIGHT-ID T)

(PROVE-LEMMA IPLUS-0-LEFT
             (REWRITE)
             (EQUAL (IPLUS 0 X) (FIX-INT X))
             ((ENABLE IPLUS FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-0-RIGHT
             (REWRITE)
             (EQUAL (IPLUS X 0) (FIX-INT X))
             ((ENABLE IPLUS FIX-INT INTEGERP)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-IPLUS
             (REWRITE)
             (EQUAL (IPLUS X (IPLUS Y Z))
                    (IPLUS Y (IPLUS X Z)))
             ((ENABLE IPLUS COMMUTATIVITY2-OF-PLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY-OF-IPLUS
             (REWRITE)
             (EQUAL (IPLUS X Y) (IPLUS Y X))
             ((ENABLE IPLUS COMMUTATIVITY2-OF-IPLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-IPLUS
             (REWRITE)
             (EQUAL (IPLUS (IPLUS X Y) Z)
                    (IPLUS X (IPLUS Y Z)))
             ((ENABLE IPLUS)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-CANCELLATION-1
             (REWRITE)
             (EQUAL (EQUAL (IPLUS A B) (IPLUS A C))
                    (EQUAL (FIX-INT B) (FIX-INT C)))
             ((ENABLE IPLUS FIX-INT INTEGERP)
              (ENABLE-THEORY ADDITION GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-CANCELLATION-2
             (REWRITE)
             (EQUAL (EQUAL (IPLUS B A) (IPLUS C A))
                    (EQUAL (FIX-INT B) (FIX-INT C)))
             ((USE (IPLUS-CANCELLATION-1))
              (ENABLE COMMUTATIVITY-OF-IPLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-INEG1
             (REWRITE)
             (EQUAL (IPLUS (INEG A) A) 0)
             ((ENABLE IPLUS INEG INTEGERP FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-INEG2
             (REWRITE)
             (EQUAL (IPLUS A (INEG A)) 0)
             ((ENABLE IPLUS INEG INTEGERP FIX-INT)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-FIX-INT1
             (REWRITE)
             (EQUAL (IPLUS (FIX-INT A) B)
                    (IPLUS A B))
             ((ENABLE IPLUS FIX-INT INTEGERP PLUS-ZERO-ARG2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-FIX-INT2
             (REWRITE)
             (EQUAL (IPLUS A (FIX-INT B))
                    (IPLUS A B))
             ((ENABLE IPLUS FIX-INT INTEGERP PLUS-ZERO-ARG2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IDIFFERENCE-FIX-INT1
             (REWRITE)
             (EQUAL (IDIFFERENCE (FIX-INT A) B)
                    (IDIFFERENCE A B))
             ((ENABLE IDIFFERENCE IPLUS-FIX-INT1)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IDIFFERENCE-FIX-INT2
             (REWRITE)
             (EQUAL (IDIFFERENCE A (FIX-INT B))
                    (IDIFFERENCE A B))
             ((ENABLE IDIFFERENCE IPLUS-FIX-INT2 INEG-FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(DEFN CANCEL-INEG-AUX
      (X Y)
      (COND ((LISTP X)
             (COND ((EQUAL (CAR X) 'INEG)
                    (COND ((EQUAL Y (CADR X)) ''0)
                          ((LISTP Y)
                           (IF (EQUAL (CAR Y) 'IPLUS)
                               (COND ((EQUAL (CADR Y) (CADR X))
                                      (LIST 'FIX-INT (CADDR Y)))
                                     ((CANCEL-INEG-AUX X (CADDR Y))
                                      (LIST 'IPLUS
                                            (CADR Y)
                                            (CANCEL-INEG-AUX X (CADDR Y))))
                                     (T F))
                               F))
                          (T F)))
                   ((NLISTP Y) F)
                   ((EQUAL (CAR Y) 'INEG)
                    (IF (EQUAL X (CADR Y)) ''0 F))
                   ((EQUAL (CAR Y) 'IPLUS)
                    (COND ((LISTP (CADR Y))
                           (COND ((EQUAL (CAADR Y) 'INEG)
                                  (COND ((EQUAL X (CADADR Y))
                                         (LIST 'FIX-INT (CADDR Y)))
                                        ((CANCEL-INEG-AUX X (CADDR Y))
                                         (LIST 'IPLUS
                                               (CADR Y)
                                               (CANCEL-INEG-AUX X (CADDR Y))))
                                        (T F)))
                                 ((CANCEL-INEG-AUX X (CADDR Y))
                                  (LIST 'IPLUS
                                        (CADR Y)
                                        (CANCEL-INEG-AUX X (CADDR Y))))
                                 (T F)))
                          ((CANCEL-INEG-AUX X (CADDR Y))
                           (LIST 'IPLUS
                                 (CADR Y)
                                 (CANCEL-INEG-AUX X (CADDR Y))))
                          (T F)))
                   (T F)))
            ((NLISTP Y) F)
            ((EQUAL (CAR Y) 'INEG)
             (IF (EQUAL X (CADR Y)) ''0 F))
            ((EQUAL (CAR Y) 'IPLUS)
             (COND ((LISTP (CADR Y))
                    (COND ((EQUAL (CAADR Y) 'INEG)
                           (COND ((EQUAL X (CADADR Y))
                                  (LIST 'FIX-INT (CADDR Y)))
                                 ((CANCEL-INEG-AUX X (CADDR Y))
                                  (LIST 'IPLUS
                                        (CADR Y)
                                        (CANCEL-INEG-AUX X (CADDR Y))))
                                 (T F)))
                          ((CANCEL-INEG-AUX X (CADDR Y))
                           (LIST 'IPLUS
                                 (CADR Y)
                                 (CANCEL-INEG-AUX X (CADDR Y))))
                          (T F)))
                   ((CANCEL-INEG-AUX X (CADDR Y))
                    (LIST 'IPLUS
                          (CADR Y)
                          (CANCEL-INEG-AUX X (CADDR Y))))
                   (T F)))
            (T F)))

(DEFN CANCEL-INEG
      (X)
      (IF (LISTP X)
          (IF (EQUAL (CAR X) 'IPLUS)
              (IF (CANCEL-INEG-AUX (CADR X) (CADDR X))
                  (CANCEL-INEG-AUX (CADR X) (CADDR X))
                  X)
              X)
          X))

(PROVE-LEMMA EVAL$-LIST-CONS
             (REWRITE)
             (EQUAL (EVAL$ 'LIST (CONS X Y) A)
                    (CONS (EVAL$ T X A)
                          (EVAL$ 'LIST Y A))))

(PROVE-LEMMA EVAL$-LIST-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP X)
                      (EQUAL (EVAL$ 'LIST X A) NIL)))

(PROVE-LEMMA EVAL$-LITATOM
             (REWRITE)
             (IMPLIES (LITATOM X)
                      (EQUAL (EVAL$ T X A)
                             (CDR (ASSOC X A)))))

(TOGGLE EVAL$-QUOTE-ON EVAL$-QUOTE NIL)

(PROVE-LEMMA EVAL$-OTHER
             (REWRITE)
             (IMPLIES (AND (NOT (LITATOM X)) (NLISTP X))
                      (EQUAL (EVAL$ T X A) X)))

(TOGGLE EVAL$-OFF EVAL$ T)

(DEFN EVAL$-CANCEL-INEG-AUX-FN
      (X Y A)
      (COND ((AND (LISTP X) (EQUAL (CAR X) 'INEG))
             (COND ((EQUAL Y (CADR X)) 0)
                   ((EQUAL (CADR Y) (CADR X))
                    (FIX-INT (EVAL$ T (CADDR Y) A)))
                   ((LISTP Y)
                    (IPLUS (EVAL$ T (CADR Y) A)
                           (EVAL$-CANCEL-INEG-AUX-FN X
                                                     (CADDR Y)
                                                     A)))
                   (T 0)))
            ((EQUAL (CAR Y) 'INEG) 0)
            ((AND (LISTP (CADR Y))
                  (EQUAL (CAADR Y) 'INEG)
                  (EQUAL X (CADADR Y)))
             (FIX-INT (EVAL$ T (CADDR Y) A)))
            ((LISTP Y)
             (IPLUS (EVAL$ T (CADR Y) A)
                    (EVAL$-CANCEL-INEG-AUX-FN X
                                              (CADDR Y)
                                              A)))
            (T 0)))

(PROVE-LEMMA EVAL$-CANCEL-INEG-AUX-IS-ITS-FN
             (REWRITE)
             (IMPLIES (NOT (EQUAL (CANCEL-INEG-AUX X Y) F))
                      (EQUAL (EVAL$ T (CANCEL-INEG-AUX X Y) A)
                             (EVAL$-CANCEL-INEG-AUX-FN X Y A))))

(PROVE-LEMMA IPLUS-INEG3
             (REWRITE)
             (EQUAL (IPLUS (INEG X) (IPLUS X Y))
                    (FIX-INT Y))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IPLUS-INEG4
             (REWRITE)
             (EQUAL (IPLUS X (IPLUS (INEG X) Y))
                    (FIX-INT Y))
             ((USE (IPLUS-INEG3 (X (INEG X)) (Y Y)))))

(PROVE-LEMMA IPLUS-INEG-PROMOTE
             (REWRITE)
             (EQUAL (IPLUS Y (INEG X))
                    (IPLUS (INEG X) Y)))

(PROVE-LEMMA IPLUS-X-Y-INEG-X
             (REWRITE)
             (EQUAL (IPLUS X (IPLUS Y (INEG X)))
                    (FIX-INT Y)))

(TOGGLE IPLUS-INEG-PROMOTE-OFF IPLUS-INEG-PROMOTE T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-INEG-AUX
             (REWRITE)
             (IMPLIES (NOT (EQUAL (CANCEL-INEG-AUX X Y) F))
                      (EQUAL (EVAL$-CANCEL-INEG-AUX-FN X Y A)
                             (IPLUS (EVAL$ T X A) (EVAL$ T Y A))))
             ((INDUCT (CANCEL-INEG-AUX X Y))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-INEG
             ((META IPLUS))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-INEG X) A))
             ((DISABLE CANCEL-INEG-AUX)))

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-AUX-OFF CORRECTNESS-OF-CANCEL-INEG-AUX T)

(DEFN IPLUS-FRINGE
      (X)
      (IF (LISTP X)
          (IF (EQUAL (CAR X) 'IPLUS)
              (APPEND (IPLUS-FRINGE (CADR X))
                      (IPLUS-FRINGE (CADDR X)))
              (LIST X))
          (LIST X)))

(PROVE-LEMMA LESSP-COUNT-LISTP-CDR
             (REWRITE)
             (IMPLIES (LISTP (CDR X))
                      (LESSP (COUNT (CDR X)) (COUNT X))))

(DEFN IPLUS-TREE-REC
      (L)
      (IF (NLISTP (CDR L))
          (CAR L)
          (LIST 'IPLUS
                (CAR L)
                (IPLUS-TREE-REC (CDR L)))))

(DEFN IPLUS-TREE
      (L)
      (IF (LISTP L)
          (IF (LISTP (CDR L))
              (IPLUS-TREE-REC L)
              (LIST 'FIX-INT (CAR L)))
          ''0))

(DEFN IPLUS-LIST
      (X)
      (IF (LISTP X)
          (IPLUS (CAR X) (IPLUS-LIST (CDR X)))
          0))

(PROVE-LEMMA INTEGERP-IPLUS-LIST
             (REWRITE)
             (INTEGERP (IPLUS-LIST X)))

(PROVE-LEMMA EVAL$-IPLUS-TREE-REC
             (REWRITE)
             (EQUAL (EVAL$ T (IPLUS-TREE-REC X) A)
                    (IF (LISTP X)
                        (IF (LISTP (CDR X))
                            (IPLUS-LIST (EVAL$ 'LIST X A))
                            (EVAL$ T (CAR X) A))
                        0)))

(PROVE-LEMMA EVAL$-IPLUS-TREE
             (REWRITE)
             (EQUAL (EVAL$ T (IPLUS-TREE X) A)
                    (IPLUS-LIST (EVAL$ 'LIST X A))))

(PROVE-LEMMA EVAL$-LIST-APPEND
             (REWRITE)
             (EQUAL (EVAL$ 'LIST (APPEND X Y) A)
                    (APPEND (EVAL$ 'LIST X A)
                            (EVAL$ 'LIST Y A))))

(DEFN CANCEL-IPLUS
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'EQUAL)
   (COND
    ((LISTP (CADR X))
     (COND
      ((EQUAL (CAADR X) 'IPLUS)
       (COND
        ((LISTP (CADDR X))
         (COND
           ((EQUAL (CAADDR X) 'IPLUS)
            (IF (LISTP (BAGINT (IPLUS-FRINGE (CADR X))
                               (IPLUS-FRINGE (CADDR X))))
                (LIST 'EQUAL
                      (IPLUS-TREE (BAGDIFF (IPLUS-FRINGE (CADR X))
                                           (BAGINT (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                      (IPLUS-TREE (BAGDIFF (IPLUS-FRINGE (CADDR X))
                                           (BAGINT (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
                X))
           ((MEMBER (CADDR X)
                    (IPLUS-FRINGE (CADR X)))
            (LIST 'IF
                  (LIST 'INTEGERP (CADDR X))
                  (CONS 'EQUAL
                        (CONS (IPLUS-TREE (DELETE (CADDR X)
                                                  (IPLUS-FRINGE (CADR X))))
                              '('0)))
                  (LIST 'QUOTE F)))
           (T X)))
        ((MEMBER (CADDR X)
                 (IPLUS-FRINGE (CADR X)))
         (LIST 'IF
               (LIST 'INTEGERP (CADDR X))
               (CONS 'EQUAL
                     (CONS (IPLUS-TREE (DELETE (CADDR X)
                                               (IPLUS-FRINGE (CADR X))))
                           '('0)))
               (LIST 'QUOTE F)))
        (T X)))
      ((LISTP (CADDR X))
       (IF (EQUAL (CAADDR X) 'IPLUS)
           (IF (MEMBER (CADR X)
                       (IPLUS-FRINGE (CADDR X)))
               (LIST 'IF
                     (LIST 'INTEGERP (CADR X))
                     (LIST 'EQUAL
                           ''0
                           (IPLUS-TREE (DELETE (CADR X)
                                               (IPLUS-FRINGE (CADDR X)))))
                     (LIST 'QUOTE F))
               X)
           X))
      (T X)))
    ((LISTP (CADDR X))
     (IF (EQUAL (CAADDR X) 'IPLUS)
         (IF (MEMBER (CADR X)
                     (IPLUS-FRINGE (CADDR X)))
             (LIST 'IF
                   (LIST 'INTEGERP (CADR X))
                   (LIST 'EQUAL
                         ''0
                         (IPLUS-TREE (DELETE (CADR X)
                                             (IPLUS-FRINGE (CADDR X)))))
                   (LIST 'QUOTE F))
             X)
         X))
    (T X))
   X)
  X))

(PROVE-LEMMA EVAL$-CANCEL-IPLUS
 (REWRITE)
 (EQUAL
  (EVAL$ T (CANCEL-IPLUS X) A)
  (IF
   (AND (LISTP X)
        (EQUAL (CAR X) 'EQUAL))
   (COND
     ((AND (LISTP (CADR X))
           (EQUAL (CAADR X) 'IPLUS)
           (LISTP (CADDR X))
           (EQUAL (CAADDR X) 'IPLUS))
      (IF (LISTP (BAGINT (IPLUS-FRINGE (CADR X))
                         (IPLUS-FRINGE (CADDR X))))
          (EQUAL (IPLUS-LIST (EVAL$ 'LIST
                                    (BAGDIFF (IPLUS-FRINGE (CADR X))
                                             (BAGINT (IPLUS-FRINGE (CADR X))
                                                     (IPLUS-FRINGE (CADDR X))))
                                    A))
                 (IPLUS-LIST (EVAL$ 'LIST
                                    (BAGDIFF (IPLUS-FRINGE (CADDR X))
                                             (BAGINT (IPLUS-FRINGE (CADR X))
                                                     (IPLUS-FRINGE (CADDR X))))
                                    A)))
          (EVAL$ T X A)))
     ((AND (LISTP (CADR X))
           (EQUAL (CAADR X) 'IPLUS)
           (MEMBER (CADDR X)
                   (IPLUS-FRINGE (CADR X))))
      (IF (INTEGERP (EVAL$ T (CADDR X) A))
          (EQUAL (IPLUS-LIST (EVAL$ 'LIST
                                    (DELETE (CADDR X)
                                            (IPLUS-FRINGE (CADR X)))
                                    A))
                 0)
          F))
     ((AND (LISTP (CADDR X))
           (EQUAL (CAADDR X) 'IPLUS)
           (MEMBER (CADR X)
                   (IPLUS-FRINGE (CADDR X))))
      (IF (INTEGERP (EVAL$ T (CADR X) A))
          (EQUAL 0
                 (IPLUS-LIST (EVAL$ 'LIST
                                    (DELETE (CADR X)
                                            (IPLUS-FRINGE (CADDR X)))
                                    A)))
          F))
     (T (EVAL$ T X A)))
   (EVAL$ T X A)))
 ((ENABLE EVAL$-IPLUS-TREE CANCEL-IPLUS EVAL$-LIST-CONS EVAL$-LITATOM
          EVAL$-QUOTE)
  (DISABLE EVAL$)
  (ENABLE-THEORY GROUND-ZERO)
  (DISABLE-THEORY T)))

(TOGGLE CANCEL-IPLUS-OFF CANCEL-IPLUS T)

(PROVE-LEMMA EVAL$-IPLUS-LIST-DELETE
             (REWRITE)
             (IMPLIES (MEMBER Z Y)
                      (EQUAL (IPLUS-LIST (EVAL$ 'LIST (DELETE Z Y) A))
                             (IDIFFERENCE (IPLUS-LIST (EVAL$ 'LIST Y A))
                                          (EVAL$ T Z A)))))

(PROVE-LEMMA EVAL$-IPLUS-LIST-BAGDIFF
             (REWRITE)
             (IMPLIES (SUBBAGP X Y)
                      (EQUAL (IPLUS-LIST (EVAL$ 'LIST (BAGDIFF Y X) A))
                             (IDIFFERENCE (IPLUS-LIST (EVAL$ 'LIST Y A))
                                          (IPLUS-LIST (EVAL$ 'LIST X A))))))

(PROVE-LEMMA IPLUS-LIST-APPEND
             (REWRITE)
             (EQUAL (IPLUS-LIST (APPEND X Y))
                    (IPLUS (IPLUS-LIST X)
                           (IPLUS-LIST Y))))

(TOGGLE IPLUS-TREE-OFF IPLUS-TREE T)

(PROVE-LEMMA NOT-INTEGERP-IMPLIES-NOT-EQUAL-IPLUS
             (REWRITE)
             (IMPLIES (NOT (INTEGERP A))
                      (EQUAL (EQUAL A (IPLUS B C)) F))
             ((USE (INTEGERP-IPLUS (X B) (Y C)))
              (ENABLE INTEGERP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IPLUS-LIST-EVAL$-FRINGE
             (REWRITE)
             (EQUAL (IPLUS-LIST (EVAL$ 'LIST (IPLUS-FRINGE X) A))
                    (FIX-INT (EVAL$ T X A)))
             ((INDUCT (IPLUS-FRINGE X))))

(PROVE-LEMMA IPLUS-INEG5-LEMMA-1
             (REWRITE)
             (IMPLIES (INTEGERP X)
                      (EQUAL (EQUAL X (IPLUS Y (IPLUS (INEG Z) W)))
                             (EQUAL X
                                    (IPLUS (INEG Z) (IPLUS Y W))))))

(PROVE-LEMMA IPLUS-INEG5-LEMMA-2
             (REWRITE)
             (IMPLIES (AND (INTEGERP X) (INTEGERP V))
                      (EQUAL (EQUAL X (IPLUS (INEG Z) V))
                             (EQUAL (IPLUS X Z) V))))

(PROVE-LEMMA IPLUS-INEG5
             (REWRITE)
             (IMPLIES (INTEGERP X)
                      (EQUAL (EQUAL X (IPLUS Y (IPLUS (INEG Z) W)))
                             (EQUAL (IPLUS X Z) (IPLUS Y W))))
             ((ENABLE IPLUS-INEG5-LEMMA-1 IPLUS-INEG5-LEMMA-2 INTEGERP-IPLUS)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE IPLUS-INEG5-LEMMA-1-OFF IPLUS-INEG5-LEMMA-1 T)

(TOGGLE IPLUS-INEG5-LEMMA-2-OFF IPLUS-INEG5-LEMMA-2 T)

(PROVE-LEMMA IPLUS-INEG6
             (REWRITE)
             (IMPLIES (INTEGERP X)
                      (EQUAL (EQUAL X (IPLUS Y (IPLUS W (INEG Z))))
                             (EQUAL (IPLUS X Z) (IPLUS Y W))))
             ((USE (IPLUS-INEG5)
                   (COMMUTATIVITY-OF-IPLUS (X W)
                                           (Y (INEG Z))))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EVAL$-IPLUS
             (REWRITE)
             (IMPLIES (AND (LISTP X)
                           (EQUAL (CAR X) 'IPLUS))
                      (EQUAL (EVAL$ T X A)
                             (IPLUS (EVAL$ T (CADR X) A)
                                    (EVAL$ T (CADDR X) A)))))

(PROVE-LEMMA IPLUS-INEG7
             (REWRITE)
             (EQUAL (EQUAL 0 (IPLUS X (INEG Y)))
                    (EQUAL (FIX-INT Y) (FIX-INT X)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-IPLUS
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-IPLUS X) A)))

(TOGGLE IPLUS-INEG5-OFF IPLUS-INEG5 T)

(TOGGLE IPLUS-INEG6-OFF IPLUS-INEG6 T)

(PROVE-LEMMA ILESSP-FIX-INT-1
             (REWRITE)
             (EQUAL (ILESSP (FIX-INT X) Y)
                    (ILESSP X Y))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-FIX-INT-2
             (REWRITE)
             (EQUAL (ILESSP X (FIX-INT Y))
                    (ILESSP X Y))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(DEFN MAKE-CANCEL-IPLUS-INEQUALITY-1
      (X Y)
      (LIST 'ILESSP
            (IPLUS-TREE (BAGDIFF X (BAGINT X Y)))
            (IPLUS-TREE (BAGDIFF Y (BAGINT X Y)))))

(DEFN CANCEL-IPLUS-ILESSP-1
      (X)
      (IF (LISTP X)
          (IF (EQUAL (CAR X) 'ILESSP)
              (MAKE-CANCEL-IPLUS-INEQUALITY-1 (IPLUS-FRINGE (CADR X))
                                              (IPLUS-FRINGE (CADDR X)))
              X)
          X))

(PROVE-LEMMA LESSP-DIFFERENCE-PLUS-ARG1
             (REWRITE)
             (EQUAL (LESSP W (DIFFERENCE (PLUS W Y) X))
                    (LESSP X Y)))

(PROVE-LEMMA LESSP-DIFFERENCE-PLUS-ARG1-COMMUTED
             (REWRITE)
             (EQUAL (LESSP W (DIFFERENCE (PLUS Y W) X))
                    (LESSP X Y)))

(PROVE-LEMMA IPLUS-CANCELLATION-1-FOR-ILESSP
             (REWRITE)
             (EQUAL (ILESSP (IPLUS A B) (IPLUS A C))
                    (ILESSP B C))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IPLUS-CANCELLATION-2-FOR-ILESSP
             (REWRITE)
             (EQUAL (ILESSP (IPLUS B A) (IPLUS C A))
                    (ILESSP B C)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-LEMMA NIL
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-IPLUS-ILESSP-1 X)
                           A)))

(DEFN IPLUS-TREE-NO-FIX-INT
      (L)
      (IF (LISTP L)
          (IPLUS-TREE-REC L)
          ''0))

(PROVE-LEMMA EVAL$-ILESSP-IPLUS-TREE-NO-FIX-INT
             (REWRITE)
             (EQUAL (ILESSP (EVAL$ T (IPLUS-TREE-NO-FIX-INT X) A)
                            (EVAL$ T (IPLUS-TREE-NO-FIX-INT Y) A))
                    (ILESSP (EVAL$ T (IPLUS-TREE X) A)
                            (EVAL$ T (IPLUS-TREE Y) A))))

(TOGGLE IPLUS-TREE-NO-FIX-INT-OFF IPLUS-TREE-NO-FIX-INT T)

(PROVE-LEMMA MAKE-CANCEL-IPLUS-INEQUALITY-SIMPLIFIER
          (REWRITE)
          (EQUAL (EVAL$ T
                        (MAKE-CANCEL-IPLUS-INEQUALITY-1 X Y)
                        A)
                 (EVAL$ T
                        (LIST 'ILESSP
                              (IPLUS-TREE-NO-FIX-INT (BAGDIFF X (BAGINT X Y)))
                              (IPLUS-TREE-NO-FIX-INT (BAGDIFF Y (BAGINT X Y))))
                        A))
          ((ENABLE MAKE-CANCEL-IPLUS-INEQUALITY-1
                   EVAL$-ILESSP-IPLUS-TREE-NO-FIX-INT)
           (DISABLE EVAL$)
           (ENABLE-THEORY GROUND-ZERO)
           (DISABLE-THEORY T)))

(DEFN CANCEL-IPLUS-ILESSP
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'ILESSP)
   (IF
     (LISTP (BAGINT (IPLUS-FRINGE (CADR X))
                    (IPLUS-FRINGE (CADDR X))))
     (LIST 'ILESSP
           (IPLUS-TREE-NO-FIX-INT (BAGDIFF (IPLUS-FRINGE (CADR X))
                                           (BAGINT (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
           (IPLUS-TREE-NO-FIX-INT (BAGDIFF (IPLUS-FRINGE (CADDR X))
                                           (BAGINT (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
     X)
   X)
  X))

(TOGGLE MAKE-CANCEL-IPLUS-INEQUALITY-1-OFF MAKE-CANCEL-IPLUS-INEQUALITY-1 T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-IPLUS-ILESSP
             ((META ILESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-IPLUS-ILESSP X) A))
             ((USE (CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-LEMMA))))

(PROVE-LEMMA ITIMES-ZERO1
             (REWRITE)
             (IMPLIES (EQUAL (FIX-INT X) 0)
                      (EQUAL (ITIMES X Y) 0))
             ((ENABLE ITIMES TIMES FIX-INT INTEGERP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-0-LEFT
             (REWRITE)
             (EQUAL (ITIMES 0 Y) 0))

(TOGGLE ITIMES-ZERO1-OFF ITIMES-ZERO1 T)

(PROVE-LEMMA ITIMES-ZERO2
             (REWRITE)
             (IMPLIES (EQUAL (FIX-INT Y) 0)
                      (EQUAL (ITIMES X Y) 0))
             ((ENABLE ITIMES FIX-INT INTEGERP TIMES-ZERO)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-0-RIGHT
             (REWRITE)
             (EQUAL (ITIMES X 0) 0))

(TOGGLE ITIMES-ZERO2-OFF ITIMES-ZERO2 T)

(PROVE-LEMMA ITIMES-FIX-INT1
             (REWRITE)
             (EQUAL (ITIMES (FIX-INT A) B)
                    (ITIMES A B))
             ((ENABLE ITIMES FIX-INT INTEGERP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-FIX-INT2
             (REWRITE)
             (EQUAL (ITIMES A (FIX-INT B))
                    (ITIMES A B))
             ((ENABLE ITIMES FIX-INT INTEGERP TIMES-ZERO)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY-OF-ITIMES
             (REWRITE)
             (EQUAL (ITIMES X Y) (ITIMES Y X))
             ((ENABLE ITIMES FIX-INT INTEGERP)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF NIL
             (EQUAL (ITIMES X (IPLUS Y Z))
                    (IPLUS (ITIMES X Y) (ITIMES X Z)))
             ((ENABLE ITIMES IPLUS INTEGERP FIX-INT COMMUTATIVITY2-OF-IPLUS
                      ASSOCIATIVITY-OF-IPLUS)
              (ENABLE-THEORY MULTIPLICATION ADDITION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-DISTRIBUTES-OVER-IPLUS
             (REWRITE)
             (AND (EQUAL (ITIMES X (IPLUS Y Z))
                         (IPLUS (ITIMES X Y) (ITIMES X Z)))
                  (EQUAL (ITIMES (IPLUS X Y) Z)
                         (IPLUS (ITIMES X Z) (ITIMES Y Z))))
             ((USE (ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF (X X)
                                                        (Y Y)
                                                        (Z Z))
                   (ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF (X Z)
                                                        (Y X)
                                                        (Z Y)))
              (ENABLE COMMUTATIVITY-OF-ITIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA COMMUTATIVITY2-OF-ITIMES
             (REWRITE)
             (EQUAL (ITIMES X (ITIMES Y Z))
                    (ITIMES Y (ITIMES X Z)))
             ((ENABLE ITIMES INTEGERP FIX-INT)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ASSOCIATIVITY-OF-ITIMES
             (REWRITE)
             (EQUAL (ITIMES (ITIMES X Y) Z)
                    (ITIMES X (ITIMES Y Z)))
             ((ENABLE ITIMES INTEGERP FIX-INT)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-ITIMES-0
             (REWRITE)
             (EQUAL (EQUAL (ITIMES X Y) 0)
                    (OR (EQUAL (FIX-INT X) 0)
                        (EQUAL (FIX-INT Y) 0)))
             ((ENABLE ITIMES INTEGERP FIX-INT)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-ITIMES-1
             (REWRITE)
             (EQUAL (EQUAL (ITIMES A B) 1)
                    (OR (AND (EQUAL A 1) (EQUAL B 1))
                        (AND (EQUAL A -1) (EQUAL B -1))))
             ((ENABLE ITIMES INTEGERP FIX-INT)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA EQUAL-ITIMES-MINUS-1
             (REWRITE)
             (EQUAL (EQUAL (ITIMES A B) -1)
                    (OR (AND (EQUAL A -1) (EQUAL B 1))
                        (AND (EQUAL A 1) (EQUAL B -1))))
             ((ENABLE ITIMES INTEGERP FIX-INT)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-1-ARG1
             (REWRITE)
             (EQUAL (ITIMES 1 X) (FIX-INT X))
             ((ENABLE INTEGERP FIX-INT ITIMES)
              (ENABLE-THEORY MULTIPLICATION GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-REMAINDER-UNIQUENESS NIL
             (IMPLIES (AND (EQUAL A (PLUS R (TIMES B Q)))
                           (LESSP R B))
                      (AND (EQUAL (FIX R) (REMAINDER A B))
                           (EQUAL (FIX Q) (QUOTIENT A B))))
             ((ENABLE-THEORY NATURALS GROUND-ZERO)
              (ENABLE REMAINDER QUOTIENT)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIVISION-THEOREM-PART1 NIL
             (IMPLIES (INTEGERP I)
                      (EQUAL (IPLUS (IREMAINDER I J)
                                    (ITIMES J (IQUOTIENT I J)))
                             I)))

(PROVE-LEMMA DIVISION-THEOREM-PART2 NIL
             (IMPLIES (AND (INTEGERP J) (NOT (EQUAL J 0)))
                      (NOT (ILESSP (IREMAINDER I J) 0)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM-PART3 NIL
             (IMPLIES (AND (INTEGERP J) (NOT (EQUAL J 0)))
                      (ILESSP (IREMAINDER I J) (IABS J)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (NOT (EQUAL J 0)))
                      (AND (EQUAL (IPLUS (IREMAINDER I J)
                                         (ITIMES J (IQUOTIENT I J)))
                                  I)
                           (NOT (ILESSP (IREMAINDER I J) 0))
                           (ILESSP (IREMAINDER I J) (IABS J))))
             ((USE (DIVISION-THEOREM-PART1 (I I) (J J))
                   (DIVISION-THEOREM-PART2 (I I) (J J))
                   (DIVISION-THEOREM-PART3 (I I) (J J)))
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA QUOTIENT-DIFFERENCE-LESSP-ARG2
             (REWRITE)
             (IMPLIES (AND (EQUAL (REMAINDER A C) 0)
                           (LESSP B C))
                      (EQUAL (QUOTIENT (DIFFERENCE A B) C)
                             (COND ((ZEROP B) (QUOTIENT A C))
                                   ((LESSP B A)
                                    (DIFFERENCE (QUOTIENT A C)
                                                (ADD1 (QUOTIENT B C))))
                                   (T 0))))
             ((ENABLE-THEORY NATURALS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUOTIENT-IREMAINDER-UNIQUENESS NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (INTEGERP R)
                           (INTEGERP Q)
                           (NOT (EQUAL J 0))
                           (EQUAL I (IPLUS R (ITIMES J Q)))
                           (NOT (ILESSP R 0))
                           (ILESSP R (IABS J)))
                      (AND (EQUAL R (IREMAINDER I J))
                           (EQUAL Q (IQUOTIENT I J))))
             ((ENABLE IREMAINDER IABS IDIFFERENCE IPLUS INEG FIX-INT ITIMES
                      IQUOTIENT ILESSP INTEGERP QUOTIENT-DIFFERENCE-LESSP-ARG2)
              (ENABLE-THEORY NATURALS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1 NIL
             (IMPLIES (INTEGERP I)
                      (EQUAL (IPLUS (IMOD I J)
                                    (ITIMES J (IDIV I J)))
                             I))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2 NIL
             (IMPLIES (ILESSP 0 J)
                      (AND (NOT (ILESSP (IMOD I J) 0))
                           (ILESSP (IMOD I J) J)))
             ((ENABLE IMOD ILESSP IDIFFERENCE IPLUS INEG ITIMES IDIV INTEGERP
                      FIX-INT)
              (ENABLE-THEORY NATURALS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3 NIL
             (IMPLIES (AND (INTEGERP J) (ILESSP J 0))
                      (AND (NOT (ILESSP 0 (IMOD I J)))
                           (ILESSP J (IMOD I J))))
             ((ENABLE IMOD ILESSP IDIFFERENCE IPLUS INEG ITIMES IDIV INTEGERP
                      FIX-INT)
              (ENABLE-THEORY NATURALS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (NOT (EQUAL J 0)))
                      (AND (EQUAL (IPLUS (IMOD I J)
                                         (ITIMES J (IDIV I J)))
                                  I)
                           (IF (ILESSP 0 J)
                               (AND (NOT (ILESSP (IMOD I J) 0))
                                    (ILESSP (IMOD I J) J))
                               (AND (NOT (ILESSP 0 (IMOD I J)))
                                    (ILESSP J (IMOD I J))))))
             ((USE (DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1 (I I)
                                                                  (J J))
                   (DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2 (I I)
                                                                  (J J))
                   (DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3 (I I)
                                                                  (J J)))
              (ENABLE INTEGERP ILESSP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IDIV-IMOD-UNIQUENESS NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (INTEGERP R)
                           (INTEGERP Q)
                           (NOT (EQUAL J 0))
                           (EQUAL I (IPLUS R (ITIMES J Q)))
                           (IF (ILESSP 0 J)
                               (AND (NOT (ILESSP R 0)) (ILESSP R J))
                               (AND (NOT (ILESSP 0 R))
                                    (ILESSP J R))))
                      (AND (EQUAL R (IMOD I J))
                           (EQUAL Q (IDIV I J))))
             ((ENABLE IMOD IABS IDIFFERENCE IPLUS INEG FIX-INT ITIMES IDIV
                      ILESSP INTEGERP QUOTIENT-DIFFERENCE-LESSP-ARG2)
              (ENABLE-THEORY NATURALS GROUND-ZERO)
              (DO-NOT-INDUCT T)
              (DISABLE-THEORY T)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 NIL
             (IMPLIES (INTEGERP I)
                      (EQUAL (IPLUS (IREM I J)
                                    (ITIMES J (IQUO I J)))
                             I))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2 NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (NOT (EQUAL J 0))
                           (NOT (ILESSP I 0)))
                      (AND (NOT (ILESSP (IREM I J) 0))
                           (ILESSP (IREM I J) (IABS J))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3 NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (NOT (EQUAL J 0))
                           (ILESSP I 0))
                      (AND (NOT (ILESSP 0 (IREM I J)))
                           (ILESSP (INEG (IABS J)) (IREM I J))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (NOT (EQUAL J 0)))
                      (AND (EQUAL (IPLUS (IREM I J)
                                         (ITIMES J (IQUO I J)))
                                  I)
                           (IF (NOT (ILESSP I 0))
                               (AND (NOT (ILESSP (IREM I J) 0))
                                    (ILESSP (IREM I J) (IABS J)))
                               (AND (NOT (ILESSP 0 (IREM I J)))
                                    (ILESSP (INEG (IABS J))
                                            (IREM I J))))))
             ((USE (DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 (I I)
                                                                (J J))
                   (DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2 (I I)
                                                                (J J))
                   (DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3 (I I)
                                                                (J J)))
              (ENABLE INTEGERP ILESSP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUO-IREM-UNIQUENESS NIL
             (IMPLIES (AND (INTEGERP I)
                           (INTEGERP J)
                           (INTEGERP R)
                           (INTEGERP Q)
                           (NOT (EQUAL J 0))
                           (EQUAL I (IPLUS R (ITIMES J Q)))
                           (IF (NOT (ILESSP I 0))
                               (AND (NOT (ILESSP R 0))
                                    (ILESSP R (IABS J)))
                               (AND (NOT (ILESSP 0 R))
                                    (ILESSP (INEG (IABS J)) R))))
                      (AND (EQUAL R (IREM I J))
                           (EQUAL Q (IQUO I J))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ITIMES-INEG-1
             (REWRITE)
             (EQUAL (ITIMES (INEG X) Y)
                    (INEG (ITIMES X Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ITIMES-INEG-2
             (REWRITE)
             (EQUAL (ITIMES X (INEG Y))
                    (INEG (ITIMES X Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ITIMES-CANCELLATION-1
             (REWRITE)
             (EQUAL (EQUAL (ITIMES A B) (ITIMES A C))
                    (OR (EQUAL (FIX-INT A) 0)
                        (EQUAL (FIX-INT B) (FIX-INT C))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ITIMES-CANCELLATION-2
             (REWRITE)
             (EQUAL (EQUAL (ITIMES B A) (ITIMES C A))
                    (OR (EQUAL (FIX-INT A) 0)
                        (EQUAL (FIX-INT B) (FIX-INT C))))
             ((USE (ITIMES-CANCELLATION-1))
              (ENABLE COMMUTATIVITY-OF-ITIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-CANCELLATION-3
             (REWRITE)
             (EQUAL (EQUAL (ITIMES A B) (ITIMES C A))
                    (OR (EQUAL (FIX-INT A) 0)
                        (EQUAL (FIX-INT B) (FIX-INT C))))
             ((USE (ITIMES-CANCELLATION-1))
              (ENABLE COMMUTATIVITY-OF-ITIMES)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IQUOTIENT
             (REWRITE)
             (INTEGERP (IQUOTIENT I J))
             ((ENABLE INTEGERP IQUOTIENT FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IREMAINDER
             (REWRITE)
             (INTEGERP (IREMAINDER I J))
             ((ENABLE IREMAINDER INTEGERP-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IDIV
             (REWRITE)
             (INTEGERP (IDIV I J))
             ((ENABLE INTEGERP IDIV FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IMOD
             (REWRITE)
             (INTEGERP (IMOD I J))
             ((ENABLE IMOD INTEGERP-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IQUO
             (REWRITE)
             (INTEGERP (IQUO I J))
             ((ENABLE INTEGERP IQUO FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA INTEGERP-IREM
             (REWRITE)
             (INTEGERP (IREM I J))
             ((ENABLE IREM INTEGERP-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUOTIENT-FIX-INT1
             (REWRITE)
             (EQUAL (IQUOTIENT (FIX-INT I) J)
                    (IQUOTIENT I J))
             ((ENABLE INTEGERP IQUOTIENT FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUOTIENT-FIX-INT2
             (REWRITE)
             (EQUAL (IQUOTIENT I (FIX-INT J))
                    (IQUOTIENT I J))
             ((ENABLE INTEGERP IQUOTIENT FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IREMAINDER-FIX-INT1
             (REWRITE)
             (EQUAL (IREMAINDER (FIX-INT I) J)
                    (IREMAINDER I J))
             ((ENABLE IREMAINDER IDIFFERENCE-FIX-INT1 IQUOTIENT-FIX-INT1)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IREMAINDER-FIX-INT2
             (REWRITE)
             (EQUAL (IREMAINDER I (FIX-INT J))
                    (IREMAINDER I J))
             ((ENABLE IREMAINDER ITIMES-FIX-INT1 IQUOTIENT-FIX-INT2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IDIV-FIX-INT1
             (REWRITE)
             (EQUAL (IDIV (FIX-INT I) J)
                    (IDIV I J))
             ((ENABLE INTEGERP IDIV FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IDIV-FIX-INT2
             (REWRITE)
             (EQUAL (IDIV I (FIX-INT J))
                    (IDIV I J))
             ((ENABLE INTEGERP IDIV FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IMOD-FIX-INT1
             (REWRITE)
             (EQUAL (IMOD (FIX-INT I) J)
                    (IMOD I J))
             ((ENABLE IMOD FIX-INT-FIX-INT IDIV-FIX-INT1)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IMOD-FIX-INT2
             (REWRITE)
             (EQUAL (IMOD I (FIX-INT J))
                    (IMOD I J))
             ((ENABLE IMOD ITIMES-FIX-INT1 IDIV-FIX-INT2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUO-FIX-INT1
             (REWRITE)
             (EQUAL (IQUO (FIX-INT I) J)
                    (IQUO I J))
             ((ENABLE INTEGERP IQUO FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IQUO-FIX-INT2
             (REWRITE)
             (EQUAL (IQUO I (FIX-INT J))
                    (IQUO I J))
             ((ENABLE INTEGERP IQUO FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IREM-FIX-INT1
             (REWRITE)
             (EQUAL (IREM (FIX-INT I) J)
                    (IREM I J))
             ((ENABLE IREM FIX-INT-FIX-INT IQUO-FIX-INT1)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA IREM-FIX-INT2
             (REWRITE)
             (EQUAL (IREM I (FIX-INT J))
                    (IREM I J))
             ((ENABLE IREM ITIMES-FIX-INT1 IQUO-FIX-INT2)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IQUOTIENT
             (REWRITE)
             (EQUAL (FIX-INT (IQUOTIENT I J))
                    (IQUOTIENT I J))
             ((ENABLE INTEGERP IQUOTIENT FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IREMAINDER
             (REWRITE)
             (EQUAL (FIX-INT (IREMAINDER I J))
                    (IREMAINDER I J))
             ((ENABLE IREMAINDER FIX-INT-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IDIV
             (REWRITE)
             (EQUAL (FIX-INT (IDIV I J))
                    (IDIV I J))
             ((ENABLE INTEGERP IDIV FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IMOD
             (REWRITE)
             (EQUAL (FIX-INT (IMOD I J))
                    (IMOD I J))
             ((ENABLE IMOD FIX-INT-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IQUO
             (REWRITE)
             (EQUAL (FIX-INT (IQUO I J))
                    (IQUO I J))
             ((ENABLE INTEGERP IQUO FIX-INT)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA FIX-INT-IREM
             (REWRITE)
             (EQUAL (FIX-INT (IREM I J))
                    (IREM I J))
             ((ENABLE IREM FIX-INT-IDIFFERENCE)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(TOGGLE IQUOTIENT-OFF IQUOTIENT T)

(TOGGLE IREMAINDER-OFF IREMAINDER T)

(TOGGLE IDIV-OFF IDIV T)

(TOGGLE IMOD-OFF IMOD T)

(TOGGLE IQUO-OFF IQUO T)

(TOGGLE IREM-OFF IREM T)

(DEFN ITIMES-FRINGE
      (X)
      (IF (LISTP X)
          (IF (EQUAL (CAR X) 'ITIMES)
              (APPEND (ITIMES-FRINGE (CADR X))
                      (ITIMES-FRINGE (CADDR X)))
              (LIST X))
          (LIST X)))

(DEFN ITIMES-TREE-REC
      (L)
      (IF (NLISTP (CDR L))
          (CAR L)
          (LIST 'ITIMES
                (CAR L)
                (ITIMES-TREE-REC (CDR L)))))

(DEFN ITIMES-TREE
      (L)
      (IF (LISTP L)
          (IF (LISTP (CDR L))
              (ITIMES-TREE-REC L)
              (LIST 'FIX-INT (CAR L)))
          ''1))

(DEFN ITIMES-LIST
      (X)
      (IF (LISTP X)
          (ITIMES (CAR X) (ITIMES-LIST (CDR X)))
          1))

(PROVE-LEMMA INTEGERP-ITIMES-LIST
             (REWRITE)
             (INTEGERP (ITIMES-LIST X)))

(PROVE-LEMMA EVAL$-ITIMES-TREE-REC
             (REWRITE)
             (IMPLIES (LISTP X)
                      (EQUAL (EVAL$ T (ITIMES-TREE-REC X) A)
                             (IF (LISTP (CDR X))
                                 (ITIMES-LIST (EVAL$ 'LIST X A))
                                 (EVAL$ T (CAR X) A)))))

(PROVE-LEMMA EVAL$-ITIMES-TREE
             (REWRITE)
             (EQUAL (EVAL$ T (ITIMES-TREE X) A)
                    (ITIMES-LIST (EVAL$ 'LIST X A))))

(TOGGLE ITIMES-TREE-OFF ITIMES-TREE T)

(DEFN MAKE-CANCEL-ITIMES-EQUALITY
      (X Y IN-BOTH)
      (LIST 'IF
            (CONS 'EQUAL
                  (CONS (ITIMES-TREE IN-BOTH) '('0)))
            (LIST 'QUOTE T)
            (LIST 'EQUAL
                  (ITIMES-TREE (BAGDIFF X IN-BOTH))
                  (ITIMES-TREE (BAGDIFF Y IN-BOTH)))))

(DEFN CANCEL-ITIMES
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'EQUAL)
   (COND
    ((LISTP (CADR X))
     (COND
      ((EQUAL (CAADR X) 'ITIMES)
       (COND
        ((LISTP (CADDR X))
         (COND
          ((EQUAL (CAADDR X) 'ITIMES)
           (IF (LISTP (BAGINT (ITIMES-FRINGE (CADR X))
                              (ITIMES-FRINGE (CADDR X))))
               (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FRINGE (CADR X))
                                            (ITIMES-FRINGE (CADDR X))
                                            (BAGINT (ITIMES-FRINGE (CADR X))
                                                    (ITIMES-FRINGE (CADDR X))))
               X))
          ((MEMBER (CADDR X)
                   (ITIMES-FRINGE (CADR X)))
           (LIST 'IF
                 (LIST 'INTEGERP (CADDR X))
                 (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FRINGE (CADR X))
                                              (LIST (CADDR X))
                                              (LIST (CADDR X)))
                 (LIST 'QUOTE F)))
          (T X)))
        ((MEMBER (CADDR X)
                 (ITIMES-FRINGE (CADR X)))
         (LIST 'IF
               (LIST 'INTEGERP (CADDR X))
               (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FRINGE (CADR X))
                                            (LIST (CADDR X))
                                            (LIST (CADDR X)))
               (LIST 'QUOTE F)))
        (T X)))
      ((LISTP (CADDR X))
       (IF (EQUAL (CAADDR X) 'ITIMES)
           (IF (MEMBER (CADR X)
                       (ITIMES-FRINGE (CADDR X)))
               (LIST 'IF
                     (LIST 'INTEGERP (CADR X))
                     (MAKE-CANCEL-ITIMES-EQUALITY (LIST (CADR X))
                                                  (ITIMES-FRINGE (CADDR X))
                                                  (LIST (CADR X)))
                     (LIST 'QUOTE F))
               X)
           X))
      (T X)))
    ((LISTP (CADDR X))
     (IF (EQUAL (CAADDR X) 'ITIMES)
         (IF (MEMBER (CADR X)
                     (ITIMES-FRINGE (CADDR X)))
             (LIST 'IF
                   (LIST 'INTEGERP (CADR X))
                   (MAKE-CANCEL-ITIMES-EQUALITY (LIST (CADR X))
                                                (ITIMES-FRINGE (CADDR X))
                                                (LIST (CADR X)))
                   (LIST 'QUOTE F))
             X)
         X))
    (T X))
   X)
  X))

(PROVE-LEMMA ITIMES-LIST-APPEND
             (REWRITE)
             (EQUAL (ITIMES-LIST (APPEND X Y))
                    (ITIMES (ITIMES-LIST X)
                            (ITIMES-LIST Y))))

(PROVE-LEMMA ITIMES-LIST-EVAL$-FRINGE
             (REWRITE)
             (EQUAL (ITIMES-LIST (EVAL$ 'LIST (ITIMES-FRINGE X) A))
                    (FIX-INT (EVAL$ T X A)))
             ((INDUCT (ITIMES-FRINGE X))))

(PROVE-LEMMA INTEGERP-EVAL$-ITIMES
             (REWRITE)
             (IMPLIES (EQUAL (CAR X) 'ITIMES)
                      (INTEGERP (EVAL$ T X A))))

(PROVE-LEMMA NOT-INTEGERP-IMPLIES-NOT-EQUAL-ITIMES
             (REWRITE)
             (IMPLIES (NOT (INTEGERP A))
                      (EQUAL (EQUAL A (ITIMES B C)) F))
             ((USE (INTEGERP-ITIMES (X B) (Y C)))
              (ENABLE INTEGERP)
              (DO-NOT-INDUCT T)
              (ENABLE-THEORY GROUND-ZERO)
              (DISABLE-THEORY T)))

(PROVE-LEMMA ITIMES-LIST-EVAL$-DELETE
        (REWRITE)
        (IMPLIES (MEMBER Z Y)
                 (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                        (ITIMES (EVAL$ T Z A)
                                (ITIMES-LIST (EVAL$ 'LIST (DELETE Z Y) A))))))

(PROVE-LEMMA ITIMES-LIST-BAGDIFF
           (REWRITE)
           (IMPLIES (SUBBAGP X Y)
                    (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                           (ITIMES (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF Y X) A))
                                   (ITIMES-LIST (EVAL$ 'LIST X A)))))
           ((INDUCT (BAGDIFF Y X))))

(PROVE-LEMMA EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE
            (REWRITE)
            (IMPLIES (AND (MEMBER C Y)
                          (NOT (EQUAL (FIX-INT (EVAL$ T C A)) 0)))
                     (EQUAL (EQUAL X
                                   (ITIMES-LIST (EVAL$ 'LIST (DELETE C Y) A)))
                            (AND (INTEGERP X)
                                 (EQUAL (ITIMES X (EVAL$ T C A))
                                        (ITIMES-LIST (EVAL$ 'LIST Y A)))))))

(TOGGLE ITIMES-LIST-EVAL$-DELETE-OFF ITIMES-LIST-EVAL$-DELETE T)

(PROVE-LEMMA MEMBER-APPEND
             (REWRITE)
             (EQUAL (MEMBER A (APPEND X Y))
                    (OR (MEMBER A X) (MEMBER A Y))))

(PROVE-LEMMA MEMBER-IZEROP-ITIMES-FRINGE
             (REWRITE)
             (IMPLIES (AND (MEMBER Z (ITIMES-FRINGE X))
                           (EQUAL (FIX-INT (EVAL$ T Z A)) 0))
                      (EQUAL (FIX-INT (EVAL$ T X A)) 0))
             ((INDUCT (ITIMES-FRINGE X))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-HACK-1
             (REWRITE)
             (IMPLIES (AND (MEMBER W
                                   (ITIMES-FRINGE (CONS 'ITIMES X1)))
                           (EQUAL (FIX-INT (EVAL$ T W A)) 0)
                           (NOT (EQUAL (FIX-INT (EVAL$ T (CAR X1) A))
                                       0)))
                      (EQUAL (FIX-INT (EVAL$ T (CADR X1) A))
                             0)))

(TOGGLE EVAL$-EQUAL-ON EVAL$-EQUAL NIL)

(PROVE-LEMMA EVAL$-MAKE-CANCEL-ITIMES-EQUALITY
           (REWRITE)
           (EQUAL (EVAL$ T
                         (MAKE-CANCEL-ITIMES-EQUALITY X Y IN-BOTH)
                         A)
                  (IF (EVAL$ T
                             (CONS 'EQUAL
                                   (CONS (ITIMES-TREE IN-BOTH) '('0)))
                             A)
                      T
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF X IN-BOTH) A))
                             (ITIMES-LIST (EVAL$ 'LIST
                                                 (BAGDIFF Y IN-BOTH)
                                                 A))))))

(TOGGLE MAKE-CANCEL-ITIMES-EQUALITY-OFF MAKE-CANCEL-ITIMES-EQUALITY T)

(PROVE-LEMMA EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-1
             (REWRITE)
             (EQUAL (EVAL$ T
                           (MAKE-CANCEL-ITIMES-EQUALITY (LIST X)
                                                        Y
                                                        (LIST X))
                           A)
                    (IF (EQUAL (FIX-INT (EVAL$ T X A)) 0)
                        T
                        (EQUAL 1
                               (ITIMES-LIST (EVAL$ 'LIST (DELETE X Y) A))))))

(PROVE-LEMMA EQUAL-FIX-INT
             (REWRITE)
             (EQUAL (EQUAL (FIX-INT X) X)
                    (INTEGERP X))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-2
             (REWRITE)
             (EQUAL (EVAL$ T
                           (MAKE-CANCEL-ITIMES-EQUALITY X
                                                        (LIST Y)
                                                        (LIST Y))
                           A)
                    (IF (EQUAL (FIX-INT (EVAL$ T Y A)) 0)
                        T
                        (EQUAL 1
                               (ITIMES-LIST (EVAL$ 'LIST (DELETE Y X) A))))))

(PROVE-LEMMA EVAL$-EQUAL-ITIMES-TREE-ITIMES-FRINGE-0
             (REWRITE)
             (IMPLIES (AND (EVAL$ T
                                  (CONS 'EQUAL
                                        (CONS (ITIMES-TREE (ITIMES-FRINGE X))
                                              '('0)))
                                  A)
                           (EQUAL (CAR X) 'ITIMES))
                      (EQUAL (EVAL$ T X A) 0)))

(PROVE-LEMMA IZEROP-EVAL-OF-MEMBER-IMPLIES-ITIMES-LIST-0
             (REWRITE)
             (IMPLIES (AND (MEMBER Z Y)
                           (EQUAL (FIX-INT (EVAL$ T Z A)) 0))
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                             0)))

(DEFN SUBSETP
      (X Y)
      (COND ((NLISTP X) T)
            ((MEMBER (CAR X) Y)
             (SUBSETP (CDR X) Y))
            (T F)))

(PROVE-LEMMA SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0
             (REWRITE)
             (IMPLIES (AND (SUBSETP X Y)
                           (EQUAL (ITIMES-LIST (EVAL$ 'LIST X A))
                                  0))
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                             0)))

(PROVE-LEMMA SUBBAGP-SUBSETP
             (REWRITE)
             (IMPLIES (SUBBAGP X Y) (SUBSETP X Y)))

(PROVE-LEMMA EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-1
             (REWRITE)
             (IMPLIES (EQUAL (ITIMES-LIST (EVAL$ 'LIST (BAGINT X Y) A))
                             0)
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST X A))
                             0))
             ((USE (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                               (Y X)))
              (DISABLE SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0)))

(PROVE-LEMMA EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-2
             (REWRITE)
             (IMPLIES (EQUAL (ITIMES-LIST (EVAL$ 'LIST (BAGINT X Y) A))
                             0)
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                             0))
             ((USE (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                               (Y Y)))
              (DISABLE SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-HACK-2
  (REWRITE)
  (IMPLIES (AND (LISTP U)
                (EQUAL (CAR U) 'ITIMES)
                (LISTP V)
                (EQUAL (CAR V) 'ITIMES)
                (NOT (EQUAL (EVAL$ T U A) (EVAL$ T V A))))
           (NOT (EQUAL (ITIMES-LIST (EVAL$ 'LIST
                                           (BAGDIFF (ITIMES-FRINGE U)
                                                    (BAGINT (ITIMES-FRINGE U)
                                                            (ITIMES-FRINGE V)))
                                           A))
                       (ITIMES-LIST (EVAL$ 'LIST
                                           (BAGDIFF (ITIMES-FRINGE V)
                                                    (BAGINT (ITIMES-FRINGE U)
                                                            (ITIMES-FRINGE V)))
                                           A)))))
  ((USE (ITIMES-LIST-BAGDIFF (Y (ITIMES-FRINGE U))
                             (X (BAGINT (ITIMES-FRINGE U)
                                        (ITIMES-FRINGE V)))
                             (A A))
        (ITIMES-LIST-BAGDIFF (Y (ITIMES-FRINGE V))
                             (X (BAGINT (ITIMES-FRINGE U)
                                        (ITIMES-FRINGE V)))
                             (A A)))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-LEMMA
             (REWRITE)
             (IMPLIES (AND (EQUAL U (ITIMES A B))
                           (NOT (EQUAL (FIX-INT A) 0)))
                      (EQUAL (EQUAL U (ITIMES A C))
                             (EQUAL (FIX-INT B) (FIX-INT C)))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-HACK-3
 (REWRITE)
 (IMPLIES
         (AND (LISTP U)
              (EQUAL (CAR U) 'ITIMES)
              (LISTP V)
              (EQUAL (CAR V) 'ITIMES)
              (EQUAL (EVAL$ T U A) (EVAL$ T V A))
              (NOT (EVAL$ T
                          (CONS 'EQUAL
                                (CONS (ITIMES-TREE (BAGINT (ITIMES-FRINGE U)
                                                           (ITIMES-FRINGE V)))
                                      '('0)))
                          A)))
         (EQUAL (EQUAL (ITIMES-LIST (EVAL$ 'LIST
                                           (BAGDIFF (ITIMES-FRINGE U)
                                                    (BAGINT (ITIMES-FRINGE U)
                                                            (ITIMES-FRINGE V)))
                                           A))
                       (ITIMES-LIST (EVAL$ 'LIST
                                           (BAGDIFF (ITIMES-FRINGE V)
                                                    (BAGINT (ITIMES-FRINGE U)
                                                            (ITIMES-FRINGE V)))
                                           A)))
                T))
 ((USE (ITIMES-LIST-BAGDIFF (Y (ITIMES-FRINGE U))
                            (X (BAGINT (ITIMES-FRINGE U)
                                       (ITIMES-FRINGE V)))
                            (A A))
       (ITIMES-LIST-BAGDIFF (Y (ITIMES-FRINGE V))
                            (X (BAGINT (ITIMES-FRINGE U)
                                       (ITIMES-FRINGE V)))
                            (A A)))))

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-LEMMA-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-LEMMA T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-ITIMES X) A))
             ((DO-NOT-INDUCT T)))

(DEFN ITIMES-TREE-NO-FIX-INT
      (L)
      (IF (LISTP L)
          (ITIMES-TREE-REC L)
          ''1))

(PROVE-LEMMA EVAL$-ITIMES-TREE-NO-FIX-INT-1
             (REWRITE)
             (EQUAL (ILESSP (EVAL$ T (ITIMES-TREE-NO-FIX-INT X) A)
                            Y)
                    (ILESSP (EVAL$ T (ITIMES-TREE X) A)
                            Y)))

(PROVE-LEMMA EVAL$-ITIMES-TREE-NO-FIX-INT-2
             (REWRITE)
             (EQUAL (ILESSP Y
                            (EVAL$ T
                                   (ITIMES-TREE-NO-FIX-INT X)
                                   A))
                    (ILESSP Y
                            (EVAL$ T (ITIMES-TREE X) A))))

(TOGGLE ITIMES-TREE-NO-FIX-INT-OFF ITIMES-TREE-NO-FIX-INT T)

(DEFN MAKE-CANCEL-ITIMES-INEQUALITY
    (X Y IN-BOTH)
    (LIST 'IF
          (CONS 'ILESSP
                (CONS (ITIMES-TREE-NO-FIX-INT IN-BOTH)
                      '('0)))
          (LIST 'ILESSP
                (ITIMES-TREE-NO-FIX-INT (BAGDIFF Y IN-BOTH))
                (ITIMES-TREE-NO-FIX-INT (BAGDIFF X IN-BOTH)))
          (CONS 'IF
                (CONS (LIST 'ILESSP
                            ''0
                            (ITIMES-TREE-NO-FIX-INT IN-BOTH))
                      (CONS (LIST 'ILESSP
                                  (ITIMES-TREE-NO-FIX-INT (BAGDIFF X IN-BOTH))
                                  (ITIMES-TREE-NO-FIX-INT (BAGDIFF Y IN-BOTH)))
                            '((FALSE)))))))

(DEFN CANCEL-ITIMES-ILESSP
 (X)
 (IF (LISTP X)
     (IF (EQUAL (CAR X) 'ILESSP)
         (IF (LISTP (BAGINT (ITIMES-FRINGE (CADR X))
                            (ITIMES-FRINGE (CADDR X))))
             (MAKE-CANCEL-ITIMES-INEQUALITY (ITIMES-FRINGE (CADR X))
                                            (ITIMES-FRINGE (CADDR X))
                                            (BAGINT (ITIMES-FRINGE (CADR X))
                                                    (ITIMES-FRINGE (CADDR X))))
             X)
         X)
     X))

(PROVE-LEMMA EVAL$-MAKE-CANCEL-ITIMES-INEQUALITY
      (REWRITE)
      (EQUAL (EVAL$ T
                    (MAKE-CANCEL-ITIMES-INEQUALITY X Y IN-BOTH)
                    A)
             (COND ((EVAL$ T
                           (CONS 'ILESSP
                                 (CONS (ITIMES-TREE-NO-FIX-INT IN-BOTH)
                                       '('0)))
                           A)
                    (ILESSP (EVAL$ T
                                   (ITIMES-TREE-NO-FIX-INT (BAGDIFF Y IN-BOTH))
                                   A)
                            (EVAL$ T
                                   (ITIMES-TREE-NO-FIX-INT (BAGDIFF X IN-BOTH))
                                   A)))
                   ((EVAL$ T
                           (LIST 'ILESSP
                                 ''0
                                 (ITIMES-TREE-NO-FIX-INT IN-BOTH))
                           A)
                    (ILESSP (EVAL$ T
                                   (ITIMES-TREE-NO-FIX-INT (BAGDIFF X IN-BOTH))
                                   A)
                            (EVAL$ T
                                   (ITIMES-TREE-NO-FIX-INT (BAGDIFF Y IN-BOTH))
                                   A)))
                   (T F))))

(TOGGLE MAKE-CANCEL-ITIMES-INEQUALITY-OFF MAKE-CANCEL-ITIMES-INEQUALITY T)

(PROVE-LEMMA LISTP-BAGINT-WITH-SINGLETON-IMPLIES-MEMBER
             (REWRITE)
             (IMPLIES (LISTP (BAGINT Y (LIST Z)))
                      (MEMBER Z Y)))

(PROVE-LEMMA ITIMES-LIST-EVAL$-LIST-0
             (REWRITE)
             (IMPLIES (MEMBER 0 X)
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST X A))
                             0)))

(PROVE-LEMMA ILESSP-ITIMES-RIGHT-POSITIVE NIL
             (IMPLIES (ILESSP 0 X)
                      (EQUAL (ILESSP Y Z)
                             (ILESSP (ITIMES Y X) (ITIMES Z X))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-1
 (REWRITE)
 (IMPLIES (AND (SUBBAGP BAG X)
               (SUBBAGP BAG Y)
               (ILESSP 0
                       (ITIMES-LIST (EVAL$ 'LIST BAG A))))
          (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF X BAG) A))
                         (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF Y BAG) A)))
                 (ILESSP (ITIMES-LIST (EVAL$ 'LIST X A))
                         (ITIMES-LIST (EVAL$ 'LIST Y A)))))
 ((USE
   (ILESSP-ITIMES-RIGHT-POSITIVE
                            (X (ITIMES-LIST (EVAL$ 'LIST BAG A)))
                            (Y (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF X BAG) A)))
                            (Z (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF Y BAG) A))))
   (ITIMES-LIST-BAGDIFF (Y X)
                        (X BAG)
                        (A A))
   (ITIMES-LIST-BAGDIFF (Y Y)
                        (X BAG)
                        (A A)))))

(PROVE-LEMMA LISTP-BAGINT-WITH-SINGLETON-MEMBER
             (REWRITE)
             (EQUAL (LISTP (BAGINT Y (LIST Z)))
                    (MEMBER Z Y)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2-LEMMA
             (REWRITE)
             (IMPLIES (MEMBER 0 (ITIMES-FRINGE W))
                      (EQUAL (EVAL$ T W A) 0))
             ((EXPAND (ITIMES-FRINGE W))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2
             (REWRITE)
             (IMPLIES (MEMBER 0 (ITIMES-FRINGE W))
                      (NOT (ILESSP (EVAL$ T W A) 0))))

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2-LEMMA-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2-LEMMA T)

(PROVE-LEMMA ILESSP-TRICHOTOMY
             (REWRITE)
             (IMPLIES (NOT (ILESSP X Y))
                      (EQUAL (ILESSP Y X)
                             (NOT (EQUAL (FIX-INT X) (FIX-INT Y)))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-1 NIL
             (IMPLIES (AND (EQUAL 0
                                  (ITIMES-LIST (EVAL$ 'LIST BAG A)))
                           (SUBSETP BAG Z))
                      (EQUAL (ITIMES-LIST (EVAL$ 'LIST Z A))
                             0)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-2 NIL
 (IMPLIES (AND (EQUAL 0
                      (ITIMES-LIST (EVAL$ 'LIST BAG A)))
               (SUBSETP BAG (ITIMES-FRINGE X)))
          (EQUAL (FIX-INT (EVAL$ T X A)) 0))
 ((USE
   (CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-1
                                                      (Z (ITIMES-FRINGE X))))))

(PROVE-LEMMA SAME-FIX-INT-IMPLIES-NOT-ILESSP
             (REWRITE)
             (IMPLIES (EQUAL (FIX-INT X) (FIX-INT Y))
                      (NOT (ILESSP X Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3
        (REWRITE)
        (IMPLIES (AND (NOT (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG A))
                                   0))
                      (NOT (ILESSP 0
                                   (ITIMES-LIST (EVAL$ 'LIST BAG A))))
                      (SUBBAGP BAG (ITIMES-FRINGE W))
                      (SUBBAGP BAG (ITIMES-FRINGE V)))
                 (NOT (ILESSP (EVAL$ T W A) (EVAL$ T V A))))
        ((USE (CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-2 (X W)
                                                                  (BAG BAG))
              (CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-2 (X V)
                                                                  (BAG BAG)))))

(PROVE-LEMMA ILESSP-ITIMES-RIGHT-NEGATIVE NIL
             (IMPLIES (ILESSP X 0)
                      (EQUAL (ILESSP Y Z)
                             (ILESSP (ITIMES Z X) (ITIMES Y X))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-4
 (REWRITE)
 (IMPLIES (AND (SUBBAGP BAG X)
               (SUBBAGP BAG Y)
               (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG A))
                       0))
          (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF X BAG) A))
                         (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF Y BAG) A)))
                 (ILESSP (ITIMES-LIST (EVAL$ 'LIST Y A))
                         (ITIMES-LIST (EVAL$ 'LIST X A)))))
 ((USE
   (ILESSP-ITIMES-RIGHT-NEGATIVE
                            (X (ITIMES-LIST (EVAL$ 'LIST BAG A)))
                            (Y (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF X BAG) A)))
                            (Z (ITIMES-LIST (EVAL$ 'LIST (BAGDIFF Y BAG) A))))
   (ITIMES-LIST-BAGDIFF (Y X)
                        (X BAG)
                        (A A))
   (ITIMES-LIST-BAGDIFF (Y Y)
                        (X BAG)
                        (A A)))))

(TOGGLE ILESSP-TRICHOTOMY-OFF ILESSP-TRICHOTOMY T)

(TOGGLE SAME-FIX-INT-IMPLIES-NOT-ILESSP-OFF SAME-FIX-INT-IMPLIES-NOT-ILESSP T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP
             ((META ILESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-ITIMES-ILESSP X) A))
             ((DO-NOT-INDUCT T)))

(PROVE-LEMMA ILESSP-STRICT
             (REWRITE)
             (IMPLIES (ILESSP X Y)
                      (NOT (ILESSP Y X)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(TOGGLE EVAL$-CANCEL-IPLUS-OFF EVAL$-CANCEL-IPLUS T)

(TOGGLE EVAL$-IPLUS-OFF EVAL$-IPLUS T)

(TOGGLE LESSP-COUNT-LISTP-CDR-OFF LESSP-COUNT-LISTP-CDR T)

(TOGGLE EVAL$-IPLUS-TREE-REC-OFF EVAL$-IPLUS-TREE-REC T)

(TOGGLE EVAL$-IPLUS-TREE-OFF EVAL$-IPLUS-TREE T)

(TOGGLE IPLUS-LIST-EVAL$-FRINGE-OFF IPLUS-LIST-EVAL$-FRINGE T)

(TOGGLE EVAL$-IPLUS-LIST-BAGDIFF-OFF EVAL$-IPLUS-LIST-BAGDIFF T)

(TOGGLE LESSP-DIFFERENCE-PLUS-ARG1-OFF LESSP-DIFFERENCE-PLUS-ARG1 T)

(TOGGLE LESSP-DIFFERENCE-PLUS-ARG1-COMMUTED-OFF
        LESSP-DIFFERENCE-PLUS-ARG1-COMMUTED T)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-LEMMA-OFF
        CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-LEMMA T)

(TOGGLE EVAL$-ILESSP-IPLUS-TREE-NO-FIX-INT-OFF
        EVAL$-ILESSP-IPLUS-TREE-NO-FIX-INT T)

(TOGGLE MAKE-CANCEL-IPLUS-INEQUALITY-SIMPLIFIER-OFF
        MAKE-CANCEL-IPLUS-INEQUALITY-SIMPLIFIER T)

(TOGGLE QUOTIENT-DIFFERENCE-LESSP-ARG2-OFF QUOTIENT-DIFFERENCE-LESSP-ARG2 T)

(TOGGLE EVAL$-ITIMES-TREE-REC-OFF EVAL$-ITIMES-TREE-REC T)

(TOGGLE EVAL$-ITIMES-TREE-OFF EVAL$-ITIMES-TREE T)

(TOGGLE ITIMES-LIST-EVAL$-FRINGE-OFF ITIMES-LIST-EVAL$-FRINGE T)

(TOGGLE INTEGERP-EVAL$-ITIMES-OFF INTEGERP-EVAL$-ITIMES T)

(TOGGLE ITIMES-LIST-BAGDIFF-OFF ITIMES-LIST-BAGDIFF T)

(TOGGLE EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-OFF
        EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE T)

(TOGGLE MEMBER-IZEROP-ITIMES-FRINGE-OFF MEMBER-IZEROP-ITIMES-FRINGE T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-HACK-1-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-HACK-1 T)

(TOGGLE EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-OFF EVAL$-MAKE-CANCEL-ITIMES-EQUALITY
        T)

(TOGGLE EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-1-OFF
        EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-1 T)

(TOGGLE EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-2-OFF
        EVAL$-MAKE-CANCEL-ITIMES-EQUALITY-2 T)

(TOGGLE EVAL$-EQUAL-ITIMES-TREE-ITIMES-FRINGE-0-OFF
        EVAL$-EQUAL-ITIMES-TREE-ITIMES-FRINGE-0 T)

(TOGGLE IZEROP-EVAL-OF-MEMBER-IMPLIES-ITIMES-LIST-0-OFF
        IZEROP-EVAL-OF-MEMBER-IMPLIES-ITIMES-LIST-0 T)

(TOGGLE SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0-OFF
        SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 T)

(TOGGLE EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-1-OFF
        EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-1 T)

(TOGGLE EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-2-OFF
        EQUAL-0-ITIMES-LIST-EVAL$-BAGINT-2 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-HACK-2-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-HACK-2 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-LEMMA-OFF1
        CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-LEMMA T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-HACK-3-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-HACK-3 T)

(TOGGLE EVAL$-ITIMES-TREE-NO-FIX-INT-1-OFF EVAL$-ITIMES-TREE-NO-FIX-INT-1 T)

(TOGGLE EVAL$-ITIMES-TREE-NO-FIX-INT-2-OFF EVAL$-ITIMES-TREE-NO-FIX-INT-2 T)

(TOGGLE EVAL$-MAKE-CANCEL-ITIMES-INEQUALITY-OFF
        EVAL$-MAKE-CANCEL-ITIMES-INEQUALITY T)

(TOGGLE LISTP-BAGINT-WITH-SINGLETON-IMPLIES-MEMBER-OFF
        LISTP-BAGINT-WITH-SINGLETON-IMPLIES-MEMBER T)

(TOGGLE ITIMES-LIST-EVAL$-LIST-0-OFF ITIMES-LIST-EVAL$-LIST-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-1-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-1 T)

(TOGGLE LISTP-BAGINT-WITH-SINGLETON-MEMBER-OFF
        LISTP-BAGINT-WITH-SINGLETON-MEMBER T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-2 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-1-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-1 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-2-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-LEMMA-2 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-3 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-4-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-HACK-4 T)

(DEFN ITIMES-TREE-INEG
      (L)
      (IF (LISTP L)
          (IF (EQUAL (CAR L) ''-1)
              (IF (LISTP (CDR L))
                  (LIST 'INEG
                        (ITIMES-TREE-REC (CDR L)))
                  (CAR L))
              (ITIMES-TREE-REC L))
          ''1))

(DEFN ITIMES-FACTORS
 (X)
 (IF
  (LISTP X)
  (CASE
   (CAR X)
   (ITIMES (APPEND (ITIMES-FACTORS (CADR X))
                   (ITIMES-FACTORS (CADDR X))))
   (IPLUS
    (IF
     (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                    (ITIMES-FACTORS (CADDR X))))
     (CONS
        (LIST 'IPLUS
              (ITIMES-TREE-INEG (BAGDIFF (ITIMES-FACTORS (CADR X))
                                         (BAGINT (ITIMES-FACTORS (CADR X))
                                                 (ITIMES-FACTORS (CADDR X)))))
              (ITIMES-TREE-INEG (BAGDIFF (ITIMES-FACTORS (CADDR X))
                                         (BAGINT (ITIMES-FACTORS (CADR X))
                                                 (ITIMES-FACTORS (CADDR X))))))
        (BAGINT (ITIMES-FACTORS (CADR X))
                (ITIMES-FACTORS (CADDR X))))
     (LIST X)))
   (INEG (CONS ''-1
               (ITIMES-FACTORS (CADR X))))
   (OTHERWISE (LIST X)))
  (LIST X)))

(PROVE-LEMMA ITIMES--1
             (REWRITE)
             (EQUAL (ITIMES -1 X) (INEG X))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA EQUAL-INEG-INEG
             (REWRITE)
             (EQUAL (EQUAL (INEG X) (INEG Y))
                    (EQUAL (FIX-INT X) (FIX-INT Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-INEG-INEG
             (REWRITE)
             (EQUAL (ILESSP (INEG X) (INEG Y))
                    (ILESSP Y X))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA FIX-INT-EVAL$-ITIMES-TREE-REC
             (REWRITE)
             (IMPLIES (LISTP X)
                      (EQUAL (FIX-INT (EVAL$ T (ITIMES-TREE-REC X) A))
                             (ITIMES-LIST (EVAL$ 'LIST X A))))
             ((ENABLE EVAL$-ITIMES-TREE-REC)))

(PROVE-LEMMA EVAL$-ITIMES-TREE-INEG
             (REWRITE)
             (EQUAL (FIX-INT (EVAL$ T (ITIMES-TREE-INEG X) A))
                    (ITIMES-LIST (EVAL$ 'LIST X A)))
             ((ENABLE EVAL$-ITIMES-TREE-REC)))

(PROVE-LEMMA INEG-EVAL$-ITIMES-TREE-INEG
             (REWRITE)
             (EQUAL (INEG (EVAL$ T (ITIMES-TREE-INEG X) A))
                    (INEG (ITIMES-LIST (EVAL$ 'LIST X A))))
             ((USE (EVAL$-ITIMES-TREE-INEG))))

(PROVE-LEMMA IPLUS-EVAL$-ITIMES-TREE-INEG
             (REWRITE)
             (AND (EQUAL (IPLUS (EVAL$ T (ITIMES-TREE-INEG X) A)
                                Y)
                         (IPLUS (ITIMES-LIST (EVAL$ 'LIST X A))
                                Y))
                  (EQUAL (IPLUS Y
                                (EVAL$ T (ITIMES-TREE-INEG X) A))
                         (IPLUS Y
                                (ITIMES-LIST (EVAL$ 'LIST X A)))))
             ((USE (EVAL$-ITIMES-TREE-INEG))))

(PROVE-LEMMA ITIMES-EVAL$-ITIMES-TREE-INEG
             (REWRITE)
             (AND (EQUAL (ITIMES (EVAL$ T (ITIMES-TREE-INEG X) A)
                                 Y)
                         (ITIMES (ITIMES-LIST (EVAL$ 'LIST X A))
                                 Y))
                  (EQUAL (ITIMES Y
                                 (EVAL$ T (ITIMES-TREE-INEG X) A))
                         (ITIMES Y
                                 (ITIMES-LIST (EVAL$ 'LIST X A)))))
             ((USE (EVAL$-ITIMES-TREE-INEG))))

(TOGGLE ITIMES-TREE-INEG-OFF ITIMES-TREE-INEG T)

(DEFN IPLUS-OR-ITIMES-TERM
      (X)
      (IF (LISTP X)
          (CASE (CAR X)
                (IPLUS T)
                (ITIMES T)
                (INEG (IF (LISTP (CADR X))
                          (EQUAL (CAADR X) 'ITIMES)
                          F))
                (OTHERWISE F))
          F))

(DEFN CANCEL-ITIMES-FACTORS
 (X)
 (IF
  (AND (LISTP X)
       (EQUAL (CAR X) 'EQUAL))
  (COND
   ((IPLUS-OR-ITIMES-TERM (CADR X))
    (IF
     (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                    (ITIMES-FACTORS (CADDR X))))
     (IF
        (IPLUS-OR-ITIMES-TERM (CADDR X))
        (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                     (ITIMES-FACTORS (CADDR X))
                                     (BAGINT (ITIMES-FACTORS (CADR X))
                                             (ITIMES-FACTORS (CADDR X))))
        (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
     X))
   ((IPLUS-OR-ITIMES-TERM (CADDR X))
    (IF (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                       (ITIMES-FACTORS (CADDR X))))
        (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
        X))
   (T X))
  X))

(DEFN CANCEL-ITIMES-FACTORS-EXPANDED
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'EQUAL)
   (COND
    ((LISTP (CADR X))
     (CASE
      (CAADR X)
      (IPLUS
       (IF
        (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                       (ITIMES-FACTORS (CADDR X))))
        (IF
         (LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (IPLUS
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
          (ITIMES
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
          (INEG
           (IF
            (LISTP (CADADDR X))
            (IF
             (EQUAL (CAADADDR X) 'ITIMES)
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X))))
             (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
            (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))))
          (OTHERWISE
           (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))))
         (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
        X))
      (ITIMES
       (IF
        (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                       (ITIMES-FACTORS (CADDR X))))
        (IF
         (LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (IPLUS
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
          (ITIMES
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
          (INEG
           (IF
            (LISTP (CADADDR X))
            (IF
             (EQUAL (CAADADDR X) 'ITIMES)
             (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X))))
             (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
            (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))))
          (OTHERWISE
           (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))))
         (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
        X))
      (INEG
       (COND
        ((LISTP (CADADR X))
         (COND
          ((EQUAL (CAADADR X) 'ITIMES)
           (IF
            (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                           (ITIMES-FACTORS (CADDR X))))
            (IF
             (LISTP (CADDR X))
             (CASE
              (CAADDR X)
              (IPLUS
               (MAKE-CANCEL-ITIMES-EQUALITY
                                          (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
              (ITIMES
               (MAKE-CANCEL-ITIMES-EQUALITY
                                          (ITIMES-FACTORS (CADR X))
                                          (ITIMES-FACTORS (CADDR X))
                                          (BAGINT (ITIMES-FACTORS (CADR X))
                                                  (ITIMES-FACTORS (CADDR X)))))
              (INEG
               (IF
                (LISTP (CADADDR X))
                (IF
                 (EQUAL (CAADADDR X) 'ITIMES)
                 (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
                 (LIST 'IF
                  (LIST 'INTEGERP (CADDR X))
                  (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
                  (LIST 'QUOTE F)))
                (LIST 'IF
                 (LIST 'INTEGERP (CADDR X))
                 (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
                 (LIST 'QUOTE F))))
              (OTHERWISE
               (LIST 'IF
                (LIST 'INTEGERP (CADDR X))
                (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
                (LIST 'QUOTE F))))
             (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F)))
            X))
          ((LISTP (CADDR X))
           (CASE
            (CAADDR X)
            (IPLUS
             (IF
              (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                             (ITIMES-FACTORS (CADDR X))))
              (LIST 'IF
               (LIST 'INTEGERP (CADR X))
               (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
               (LIST 'QUOTE F))
              X))
            (ITIMES
             (IF
              (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                             (ITIMES-FACTORS (CADDR X))))
              (LIST 'IF
               (LIST 'INTEGERP (CADR X))
               (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
               (LIST 'QUOTE F))
              X))
            (INEG
             (IF
              (LISTP (CADADDR X))
              (IF
               (EQUAL (CAADADDR X) 'ITIMES)
               (IF
                (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                               (ITIMES-FACTORS (CADDR X))))
                (LIST 'IF
                 (LIST 'INTEGERP (CADR X))
                 (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
                 (LIST 'QUOTE F))
                X)
               X)
              X))
            (OTHERWISE X)))
          (T X)))
        ((LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (IPLUS
           (IF
            (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                           (ITIMES-FACTORS (CADDR X))))
            (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
            X))
          (ITIMES
           (IF
            (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                           (ITIMES-FACTORS (CADDR X))))
            (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
            X))
          (INEG
           (IF
            (LISTP (CADADDR X))
            (IF
             (EQUAL (CAADADDR X) 'ITIMES)
             (IF
              (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                             (ITIMES-FACTORS (CADDR X))))
              (LIST 'IF
               (LIST 'INTEGERP (CADR X))
               (MAKE-CANCEL-ITIMES-EQUALITY
                                           (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
               (LIST 'QUOTE F))
              X)
             X)
            X))
          (OTHERWISE X)))
        (T X)))
      (OTHERWISE
       (IF
        (LISTP (CADDR X))
        (CASE
         (CAADDR X)
         (IPLUS
          (IF
           (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                          (ITIMES-FACTORS (CADDR X))))
           (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
           X))
         (ITIMES
          (IF
           (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                          (ITIMES-FACTORS (CADDR X))))
           (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
           X))
         (INEG
          (IF
           (LISTP (CADADDR X))
           (IF
            (EQUAL (CAADADDR X) 'ITIMES)
            (IF
             (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                            (ITIMES-FACTORS (CADDR X))))
             (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
             X)
            X)
           X))
         (OTHERWISE X))
        X))))
    ((LISTP (CADDR X))
     (CASE
      (CAADDR X)
      (IPLUS
       (IF
        (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                       (ITIMES-FACTORS (CADDR X))))
        (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
        X))
      (ITIMES
       (IF
        (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                       (ITIMES-FACTORS (CADDR X))))
        (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
        X))
      (INEG
       (IF
        (LISTP (CADADDR X))
        (IF
         (EQUAL (CAADADDR X) 'ITIMES)
         (IF
          (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                         (ITIMES-FACTORS (CADDR X))))
          (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (MAKE-CANCEL-ITIMES-EQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
              (LIST 'QUOTE F))
          X)
         X)
        X))
      (OTHERWISE X)))
    (T X))
   X)
  X))

(PROVE-LEMMA CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS
             (REWRITE)
             (EQUAL (CANCEL-ITIMES-FACTORS-EXPANDED X)
                    (CANCEL-ITIMES-FACTORS X))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE IPLUS-OR-ITIMES-TERM CANCEL-ITIMES-FACTORS
                      CANCEL-ITIMES-FACTORS-EXPANDED)))

(TOGGLE CANCEL-ITIMES-FACTORS-EXPANDED-OFF CANCEL-ITIMES-FACTORS-EXPANDED T)

(TOGGLE IPLUS-OR-ITIMES-TERM-OFF IPLUS-OR-ITIMES-TERM T)

(PROVE-LEMMA EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-1
        (REWRITE)
        (IMPLIES (NOT (EQUAL (FIX-INT (EVAL$ T ELT A)) 0))
                 (EQUAL (EQUAL X
                               (ITIMES-LIST (EVAL$ 'LIST (DELETE ELT BAG) A)))
                        (IF (MEMBER ELT BAG)
                            (AND (INTEGERP X)
                                 (EQUAL (ITIMES X (EVAL$ T ELT A))
                                        (ITIMES-LIST (EVAL$ 'LIST BAG A))))
                            (EQUAL X
                                   (ITIMES-LIST (EVAL$ 'LIST BAG A))))))
        ((ENABLE EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE)))

(PROVE-LEMMA EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-2
         (REWRITE)
         (IMPLIES (NOT (EQUAL (FIX-INT (EVAL$ T ELT A)) 0))
                  (EQUAL (EQUAL (ITIMES-LIST (EVAL$ 'LIST (DELETE ELT BAG) A))
                                X)
                         (IF (MEMBER ELT BAG)
                             (AND (INTEGERP X)
                                  (EQUAL (ITIMES X (EVAL$ T ELT A))
                                         (ITIMES-LIST (EVAL$ 'LIST BAG A))))
                             (EQUAL X
                                    (ITIMES-LIST (EVAL$ 'LIST BAG A)))))))

(PROVE-LEMMA ITIMES-ITIMES-LIST-EVAL$-LIST-DELETE
         (REWRITE)
         (IMPLIES (MEMBER X BAG)
                  (EQUAL (ITIMES (EVAL$ T X A)
                                 (ITIMES-LIST (EVAL$ 'LIST (DELETE X BAG) A)))
                         (ITIMES-LIST (EVAL$ 'LIST BAG A)))))

(PROVE-LEMMA EQUAL-ITIMES-LIST-EVAL$-LIST-BAGDIFF
             (REWRITE)
             (IMPLIES (AND (SUBBAGP IN-BOTH BAG1)
                           (SUBBAGP IN-BOTH BAG2)
                           (NOT (EQUAL (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A))
                                       0)))
                      (EQUAL (EQUAL (ITIMES-LIST (EVAL$ 'LIST
                                                        (BAGDIFF BAG1 IN-BOTH)
                                                        A))
                                    (ITIMES-LIST (EVAL$ 'LIST
                                                        (BAGDIFF BAG2 IN-BOTH)
                                                        A)))
                             (EQUAL (ITIMES-LIST (EVAL$ 'LIST BAG1 A))
                                    (ITIMES-LIST (EVAL$ 'LIST BAG2 A))))))

(PROVE-LEMMA MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0
             (REWRITE)
             (IMPLIES (MEMBER 0 X)
                      (EQUAL (ITIMES-LIST X) 0)))

(PROVE-LEMMA MEMBER-0-EVAL$-LIST
             (REWRITE)
             (IMPLIES (MEMBER 0 X)
                      (MEMBER 0 (EVAL$ 'LIST X A))))

(PROVE-LEMMA ITIMES-LIST-EVAL$-FACTORS-LEMMA
           (REWRITE)
           (EQUAL (ITIMES (ITIMES-LIST (EVAL$ 'LIST (BAGINT BAG1 BAG2) A))
                          (ITIMES-LIST (EVAL$ 'LIST
                                              (BAGDIFF BAG2 (BAGINT BAG1 BAG2))
                                              A)))
                  (ITIMES-LIST (EVAL$ 'LIST BAG2 A)))
           ((USE (ITIMES-LIST-BAGDIFF (X (BAGINT BAG1 BAG2))
                                      (Y BAG2)))))

(PROVE-LEMMA ITIMES-LIST-EVAL$-FACTORS-LEMMA-PRIME
           (REWRITE)
           (EQUAL (ITIMES (ITIMES-LIST (EVAL$ 'LIST (BAGINT BAG1 BAG2) A))
                          (ITIMES-LIST (EVAL$ 'LIST
                                              (BAGDIFF BAG1 (BAGINT BAG1 BAG2))
                                              A)))
                  (ITIMES-LIST (EVAL$ 'LIST BAG1 A)))
           ((USE (ITIMES-LIST-BAGDIFF (X (BAGINT BAG1 BAG2))
                                      (Y BAG1)))))

(PROVE-LEMMA ITIMES-LIST-EVAL$-FACTORS
             (REWRITE)
             (EQUAL (ITIMES-LIST (EVAL$ 'LIST (ITIMES-FACTORS X) A))
                    (FIX-INT (EVAL$ T X A)))
             ((INDUCT (ITIMES-FACTORS X))
              (ENABLE INTEGERP-EVAL$-ITIMES ITIMES-LIST-BAGDIFF
                      LISTP-BAGINT-WITH-SINGLETON-MEMBER)))

(PROVE-LEMMA IPLUS-OR-ITIMES-TERM-INTEGERP-EVAL$
             (REWRITE)
             (IMPLIES (IPLUS-OR-ITIMES-TERM X)
                      (INTEGERP (EVAL$ T X A)))
             ((ENABLE IPLUS-OR-ITIMES-TERM)))

(PROVE-LEMMA EVAL$-LIST-BAGINT-0 NIL
             (IMPLIES (EQUAL (ITIMES-LIST (EVAL$ 'LIST (BAGINT X Y) A))
                             0)
                      (AND (EQUAL (ITIMES-LIST (EVAL$ 'LIST X A))
                                  0)
                           (EQUAL (ITIMES-LIST (EVAL$ 'LIST Y A))
                                  0)))
             ((USE (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                               (Y X))
                   (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                               (Y Y)))))

(PROVE-LEMMA EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL
           (REWRITE)
           (IMPLIES (AND (EQUAL (ITIMES-LIST (EVAL$ 'LIST
                                                    (BAGINT (ITIMES-FACTORS V)
                                                            (ITIMES-FACTORS W))
                                                    A))
                                0)
                         (INTEGERP (EVAL$ T V A))
                         (INTEGERP (EVAL$ T W A)))
                    (EQUAL (EQUAL (EVAL$ T V A) (EVAL$ T W A))
                           T))
           ((USE (EVAL$-LIST-BAGINT-0 (X (ITIMES-FACTORS V))
                                      (Y (ITIMES-FACTORS W))))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-FACTORS
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-ITIMES-FACTORS-EXPANDED X)
                           A))
             ((DO-NOT-INDUCT T)
              (ENABLE EVAL$-ITIMES-TREE EVAL$-MAKE-CANCEL-ITIMES-EQUALITY)))

(DEFN CANCEL-ITIMES-ILESSP-FACTORS
 (X)
 (IF
    (LISTP X)
    (IF (EQUAL (CAR X) 'ILESSP)
        (IF (LISTP (BAGINT (ITIMES-FACTORS (CADR X))
                           (ITIMES-FACTORS (CADDR X))))
            (MAKE-CANCEL-ITIMES-INEQUALITY (ITIMES-FACTORS (CADR X))
                                           (ITIMES-FACTORS (CADDR X))
                                           (BAGINT (ITIMES-FACTORS (CADR X))
                                                   (ITIMES-FACTORS (CADDR X))))
            X)
        X)
    X))

(PROVE-LEMMA BAGINT-SINGLETON
             (REWRITE)
             (EQUAL (BAGINT X (LIST Y))
                    (IF (MEMBER Y X) (LIST Y) NIL)))

(PROVE-LEMMA IZEROP-ILESSP-0-RELATIONSHIP
             (REWRITE)
             (EQUAL (EQUAL (FIX-INT X) 0)
                    (AND (NOT (ILESSP X 0))
                         (NOT (ILESSP 0 X))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-1
             (REWRITE)
             (IMPLIES (ILESSP 0 W)
                      (EQUAL (ILESSP (ITIMES X W) (ITIMES W U))
                             (ILESSP X U))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-2
             (REWRITE)
             (IMPLIES (ILESSP W 0)
                      (EQUAL (ILESSP (ITIMES W U) (ITIMES X W))
                             (ILESSP X U))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE
           (REWRITE)
           (IMPLIES (AND (MEMBER Z Y)
                         (NOT (EQUAL (FIX-INT (EVAL$ T Z A)) 0)))
                    (EQUAL (ILESSP X
                                   (ITIMES-LIST (EVAL$ 'LIST (DELETE Z Y) A)))
                           (COND ((ILESSP 0 (EVAL$ T Z A))
                                  (ILESSP (ITIMES X (EVAL$ T Z A))
                                          (ITIMES-LIST (EVAL$ 'LIST Y A))))
                                 ((ILESSP (EVAL$ T Z A) 0)
                                  (ILESSP (ITIMES-LIST (EVAL$ 'LIST Y A))
                                          (ITIMES X (EVAL$ T Z A))))
                                 (T F))))
           ((ENABLE ITIMES-LIST-EVAL$-DELETE)
            (DISABLE ITIMES-ITIMES-LIST-EVAL$-LIST-DELETE)))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-1
             (REWRITE)
             (IMPLIES (ILESSP 0 W)
                      (EQUAL (ILESSP (ITIMES W U) (ITIMES X W))
                             (ILESSP U X))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-2
             (REWRITE)
             (IMPLIES (ILESSP W 0)
                      (EQUAL (ILESSP (ITIMES X W) (ITIMES W U))
                             (ILESSP U X))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME
            (REWRITE)
            (IMPLIES (AND (MEMBER Z Y)
                          (NOT (EQUAL (FIX-INT (EVAL$ T Z A)) 0)))
                     (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST (DELETE Z Y) A))
                                    X)
                            (COND ((ILESSP 0 (EVAL$ T Z A))
                                   (ILESSP (ITIMES-LIST (EVAL$ 'LIST Y A))
                                           (ITIMES X (EVAL$ T Z A))))
                                  ((ILESSP (EVAL$ T Z A) 0)
                                   (ILESSP (ITIMES X (EVAL$ T Z A))
                                           (ITIMES-LIST (EVAL$ 'LIST Y A))))
                                  (T F))))
            ((ENABLE ITIMES-LIST-EVAL$-DELETE)
             (DISABLE ITIMES-ITIMES-LIST-EVAL$-LIST-DELETE
                      ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE)))

(PROVE-LEMMA ILESSP-0-ITIMES
             (REWRITE)
             (EQUAL (ILESSP 0 (ITIMES X Y))
                    (OR (AND (ILESSP 0 X) (ILESSP 0 Y))
                        (AND (ILESSP X 0) (ILESSP Y 0))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-ITIMES-0
             (REWRITE)
             (EQUAL (ILESSP (ITIMES X Y) 0)
                    (OR (AND (ILESSP 0 X) (ILESSP Y 0))
                        (AND (ILESSP X 0) (ILESSP 0 Y))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF
            (REWRITE)
            (IMPLIES (AND (SUBBAGP IN-BOTH BAG1)
                          (SUBBAGP IN-BOTH BAG2)
                          (NOT (EQUAL (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A))
                                      0)))
                     (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST
                                                        (BAGDIFF BAG1 IN-BOTH)
                                                        A))
                                    (ITIMES-LIST (EVAL$ 'LIST
                                                        (BAGDIFF BAG2 IN-BOTH)
                                                        A)))
                            (IF (ILESSP 0
                                        (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A)))
                                (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG1 A))
                                        (ITIMES-LIST (EVAL$ 'LIST BAG2 A)))
                                (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG2 A))
                                        (ITIMES-LIST (EVAL$ 'LIST BAG1 A))))))
            ((ENABLE ILESSP-TRICHOTOMY)
             (DISABLE IZEROP-ILESSP-0-RELATIONSHIP)))

(PROVE-LEMMA ZERO-ILESSP-IMPLIES-NOT-EQUAL NIL
             (IMPLIES (ILESSP 0 X)
                      (NOT (EQUAL 0 X))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1
 (REWRITE)
 (IMPLIES (AND (SUBBAGP IN-BOTH BAG1)
               (SUBBAGP IN-BOTH BAG2)
               (ILESSP 0
                       (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A))))
          (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST
                                             (BAGDIFF BAG1 IN-BOTH)
                                             A))
                         (ITIMES-LIST (EVAL$ 'LIST
                                             (BAGDIFF BAG2 IN-BOTH)
                                             A)))
                 (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG1 A))
                         (ITIMES-LIST (EVAL$ 'LIST BAG2 A)))))
 ((USE
   (ZERO-ILESSP-IMPLIES-NOT-EQUAL
                                 (X (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A)))))))

(PROVE-LEMMA ILESSP-ZERO-IMPLIES-NOT-EQUAL NIL
             (IMPLIES (ILESSP X 0)
                      (NOT (EQUAL 0 X))))

(PROVE-LEMMA ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2
 (REWRITE)
 (IMPLIES (AND (SUBBAGP IN-BOTH BAG1)
               (SUBBAGP IN-BOTH BAG2)
               (ILESSP (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A))
                       0))
          (EQUAL (ILESSP (ITIMES-LIST (EVAL$ 'LIST
                                             (BAGDIFF BAG1 IN-BOTH)
                                             A))
                         (ITIMES-LIST (EVAL$ 'LIST
                                             (BAGDIFF BAG2 IN-BOTH)
                                             A)))
                 (ILESSP (ITIMES-LIST (EVAL$ 'LIST BAG2 A))
                         (ITIMES-LIST (EVAL$ 'LIST BAG1 A)))))
 ((USE
   (ILESSP-ZERO-IMPLIES-NOT-EQUAL
                                 (X (ITIMES-LIST (EVAL$ 'LIST IN-BOTH A)))))))

(PROVE-LEMMA MEMBER-0-ITIMES-FACTORS-YIELDS-0
             (REWRITE)
             (IMPLIES (NOT (EQUAL (EVAL$ T W A) 0))
                      (NOT (MEMBER 0 (ITIMES-FACTORS W)))))

(PROVE-LEMMA MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1
             (REWRITE)
             (IMPLIES (ILESSP (EVAL$ T W A) 0)
                      (NOT (MEMBER 0 (ITIMES-FACTORS W))))
             ((USE (MEMBER-0-ITIMES-FACTORS-YIELDS-0))))

(PROVE-LEMMA MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2
             (REWRITE)
             (IMPLIES (ILESSP 0 (EVAL$ T W A))
                      (NOT (MEMBER 0 (ITIMES-FACTORS W))))
             ((USE (MEMBER-0-ITIMES-FACTORS-YIELDS-0))))

(TOGGLE ILESSP-TRICHOTOMY-ON ILESSP-TRICHOTOMY NIL)

(TOGGLE IZEROP-ILESSP-0-RELATIONSHIP-OFF IZEROP-ILESSP-0-RELATIONSHIP T)

(PROVE-LEMMA EVAL$-LIST-BAGINT-0-FOR-ILESSP NIL
      (IMPLIES (AND (NOT (ILESSP (ITIMES-LIST (EVAL$ 'LIST (BAGINT X Y) A))
                                 0))
                    (NOT (ILESSP 0
                                 (ITIMES-LIST (EVAL$ 'LIST (BAGINT X Y) A)))))
               (AND (EQUAL (FIX-INT (ITIMES-LIST (EVAL$ 'LIST X A)))
                           0)
                    (EQUAL (FIX-INT (ITIMES-LIST (EVAL$ 'LIST Y A)))
                           0)))
      ((USE (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                        (Y X))
            (SUBSETP-IMPLIES-ITIMES-LIST-EVAL$-EQUALS-0 (X (BAGINT X Y))
                                                        (Y Y)))))

(PROVE-LEMMA EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA NIL
     (IMPLIES (AND (NOT (ILESSP (ITIMES-LIST (EVAL$ 'LIST
                                                    (BAGINT (ITIMES-FACTORS V)
                                                            (ITIMES-FACTORS W))
                                                    A))
                                0))
                   (NOT (ILESSP 0
                                (ITIMES-LIST (EVAL$ 'LIST
                                                    (BAGINT (ITIMES-FACTORS V)
                                                            (ITIMES-FACTORS W))
                                                    A)))))
              (EQUAL (FIX-INT (EVAL$ T V A))
                     (FIX-INT (EVAL$ T W A))))
     ((USE (EVAL$-LIST-BAGINT-0-FOR-ILESSP (X (ITIMES-FACTORS V))
                                           (Y (ITIMES-FACTORS W))))))

(PROVE-LEMMA EQUAL-FIX-INT-TO-ILESSP NIL
             (IMPLIES (EQUAL (FIX-INT X) (FIX-INT Y))
                      (NOT (ILESSP X Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP
     (REWRITE)
     (IMPLIES (AND (NOT (ILESSP (ITIMES-LIST (EVAL$ 'LIST
                                                    (BAGINT (ITIMES-FACTORS V)
                                                            (ITIMES-FACTORS W))
                                                    A))
                                0))
                   (NOT (ILESSP 0
                                (ITIMES-LIST (EVAL$ 'LIST
                                                    (BAGINT (ITIMES-FACTORS V)
                                                            (ITIMES-FACTORS W))
                                                    A)))))
              (AND (NOT (ILESSP (EVAL$ T V A) (EVAL$ T W A)))
                   (NOT (ILESSP (EVAL$ T W A)
                                (EVAL$ T V A)))))
     ((USE (EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA)
           (EQUAL-FIX-INT-TO-ILESSP (X (EVAL$ T V A))
                                    (Y (EVAL$ T W A)))
           (EQUAL-FIX-INT-TO-ILESSP (X (EVAL$ T W A))
                                    (Y (EVAL$ T V A))))))

(TOGGLE ILESSP-TRICHOTOMY-OFF1 ILESSP-TRICHOTOMY T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS
             ((META ILESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-ITIMES-ILESSP-FACTORS X)
                           A))
             ((DO-NOT-INDUCT T)
              (ENABLE EVAL$-ITIMES-TREE-NO-FIX-INT-1
                      EVAL$-ITIMES-TREE-NO-FIX-INT-2 EVAL$-ITIMES-TREE
                      EVAL$-MAKE-CANCEL-ITIMES-INEQUALITY)))

(TOGGLE LESSP-COUNT-LISTP-CDR-ON LESSP-COUNT-LISTP-CDR NIL)

(DEFN DISJOIN-EQUALITIES-WITH-0
      (FACTORS)
      (IF (LISTP (CDR FACTORS))
          (LIST 'OR
                (CONS 'EQUAL
                      (CONS (LIST 'FIX-INT (CAR FACTORS))
                            '('0)))
                (DISJOIN-EQUALITIES-WITH-0 (CDR FACTORS)))
          (CONS 'EQUAL
                (CONS (LIST 'FIX-INT (CAR FACTORS))
                      '('0)))))

(TOGGLE LESSP-COUNT-LISTP-CDR-OFF1 LESSP-COUNT-LISTP-CDR T)

(DEFN CANCEL-FACTORS-0
      (X)
      (IF (LISTP X)
          (IF (EQUAL (CAR X) 'EQUAL)
              (COND ((EQUAL (CADR X) ''0)
                     (IF (LISTP (CDR (ITIMES-FACTORS (CADDR X))))
                         (DISJOIN-EQUALITIES-WITH-0 (ITIMES-FACTORS (CADDR X)))
                         X))
                    ((EQUAL (CADDR X) ''0)
                     (IF (LISTP (CDR (ITIMES-FACTORS (CADR X))))
                         (DISJOIN-EQUALITIES-WITH-0 (ITIMES-FACTORS (CADR X)))
                         X))
                    (T X))
              X)
          X))

(DEFN SOME-EVAL$S-TO-0
      (X A)
      (IF (LISTP X)
          (OR (EQUAL (FIX-INT (EVAL$ T (CAR X) A))
                     0)
              (SOME-EVAL$S-TO-0 (CDR X) A))
          F))

(PROVE-LEMMA EVAL$-DISJOIN-EQUALITIES-WITH-0
             (REWRITE)
             (IMPLIES (LISTP LST)
                      (EQUAL (EVAL$ T
                                    (DISJOIN-EQUALITIES-WITH-0 LST)
                                    A)
                             (SOME-EVAL$S-TO-0 LST A))))

(PROVE-LEMMA SOME-EVAL$S-TO-0-APPEND
             (REWRITE)
             (EQUAL (SOME-EVAL$S-TO-0 (APPEND X Y) A)
                    (OR (SOME-EVAL$S-TO-0 X A)
                        (SOME-EVAL$S-TO-0 Y A))))

(PROVE-LEMMA SOME-EVAL$S-TO-0-ELIMINATOR
             (REWRITE)
             (EQUAL (SOME-EVAL$S-TO-0 X A)
                    (EQUAL (ITIMES-LIST (EVAL$ 'LIST X A))
                           0)))

(PROVE-LEMMA LISTP-CDR-FACTORS-IMPLIES-INTEGERP
             (REWRITE)
             (IMPLIES (LISTP (CDR (ITIMES-FACTORS V)))
                      (INTEGERP (EVAL$ T V A)))
             ((EXPAND (ITIMES-FACTORS V))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-FACTORS-0
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T (CANCEL-FACTORS-0 X) A)))

(TOGGLE LESSP-COUNT-LISTP-CDR-ON1 LESSP-COUNT-LISTP-CDR NIL)

(DEFN CONJOIN-INEQUALITIES-WITH-0
      (FACTORS PARITY)
      (COND ((LISTP (CDR FACTORS))
             (IF PARITY
                 (LIST 'OR
                       (LIST 'AND
                             (LIST 'ILESSP ''0 (CAR FACTORS))
                             (CONJOIN-INEQUALITIES-WITH-0 (CDR FACTORS)
                                                          T))
                       (LIST 'AND
                             (CONS 'ILESSP
                                   (CONS (CAR FACTORS) '('0)))
                             (CONJOIN-INEQUALITIES-WITH-0 (CDR FACTORS)
                                                          F)))
                 (LIST 'OR
                       (LIST 'AND
                             (CONS 'ILESSP
                                   (CONS (CAR FACTORS) '('0)))
                             (CONJOIN-INEQUALITIES-WITH-0 (CDR FACTORS)
                                                          T))
                       (LIST 'AND
                             (LIST 'ILESSP ''0 (CAR FACTORS))
                             (CONJOIN-INEQUALITIES-WITH-0 (CDR FACTORS)
                                                          F)))))
            (PARITY (LIST 'ILESSP ''0 (CAR FACTORS)))
            (T (CONS 'ILESSP
                     (CONS (CAR FACTORS) '('0))))))

(TOGGLE LESSP-COUNT-LISTP-CDR-OFF2 LESSP-COUNT-LISTP-CDR T)

(DEFN CANCEL-FACTORS-ILESSP-0
     (X)
     (IF (LISTP X)
         (IF (EQUAL (CAR X) 'ILESSP)
             (COND ((EQUAL (CADR X) ''0)
                    (IF (LISTP (CDR (ITIMES-FACTORS (CADDR X))))
                        (CONJOIN-INEQUALITIES-WITH-0 (ITIMES-FACTORS (CADDR X))
                                                     T)
                        X))
                   ((EQUAL (CADDR X) ''0)
                    (IF (LISTP (CDR (ITIMES-FACTORS (CADR X))))
                        (CONJOIN-INEQUALITIES-WITH-0 (ITIMES-FACTORS (CADR X))
                                                     F)
                        X))
                   (T X))
             X)
         X))

(PROVE-LEMMA CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR
             (REWRITE)
             (IMPLIES (LISTP X)
                      (EQUAL (EVAL$ T
                                    (CONJOIN-INEQUALITIES-WITH-0 X PARITY)
                                    A)
                             (IF PARITY
                                 (ILESSP 0
                                         (ITIMES-LIST (EVAL$ 'LIST X A)))
                                 (ILESSP (ITIMES-LIST (EVAL$ 'LIST X A))
                                         0)))))

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0
             ((META ILESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-FACTORS-ILESSP-0 X)
                           A)))

(TOGGLE EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-1-OFF
        EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-1 T)

(TOGGLE EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-2-OFF
        EQUAL-ITIMES-LIST-EVAL$-LIST-DELETE-NEW-2 T)

(TOGGLE ITIMES-ITIMES-LIST-EVAL$-LIST-DELETE-OFF
        ITIMES-ITIMES-LIST-EVAL$-LIST-DELETE T)

(TOGGLE EQUAL-ITIMES-LIST-EVAL$-LIST-BAGDIFF-OFF
        EQUAL-ITIMES-LIST-EVAL$-LIST-BAGDIFF T)

(TOGGLE ITIMES-LIST-EVAL$-FACTORS-LEMMA-OFF ITIMES-LIST-EVAL$-FACTORS-LEMMA T)

(TOGGLE ITIMES-LIST-EVAL$-FACTORS-LEMMA-PRIME-OFF
        ITIMES-LIST-EVAL$-FACTORS-LEMMA-PRIME T)

(TOGGLE ITIMES-LIST-EVAL$-FACTORS-OFF ITIMES-LIST-EVAL$-FACTORS T)

(TOGGLE IPLUS-OR-ITIMES-TERM-INTEGERP-EVAL$-OFF
        IPLUS-OR-ITIMES-TERM-INTEGERP-EVAL$ T)

(TOGGLE EVAL$-LIST-BAGINT-0-OFF EVAL$-LIST-BAGINT-0 T)

(TOGGLE EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-OFF EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL
        T)

(TOGGLE IZEROP-ILESSP-0-RELATIONSHIP-OFF1 IZEROP-ILESSP-0-RELATIONSHIP T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-1-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-1 T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-2-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-HELPER-2 T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-1-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-1 T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-2-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-HELPER-2 T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-DELETE-PRIME T)

(TOGGLE ILESSP-0-ITIMES-OFF ILESSP-0-ITIMES T)

(TOGGLE ILESSP-ITIMES-0-OFF ILESSP-ITIMES-0 T)

(TOGGLE LISTP-CDR-FACTORS-IMPLIES-INTEGERP-OFF
        LISTP-CDR-FACTORS-IMPLIES-INTEGERP T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-OFF CORRECTNESS-OF-CANCEL-ITIMES T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP T)

(TOGGLE NOT-INTEGERP-IMPLIES-NOT-EQUAL-IPLUS-OFF
        NOT-INTEGERP-IMPLIES-NOT-EQUAL-IPLUS T)

(TOGGLE NOT-INTEGERP-IMPLIES-NOT-EQUAL-ITIMES-OFF
        NOT-INTEGERP-IMPLIES-NOT-EQUAL-ITIMES T)

(TOGGLE SUBBAGP-SUBSETP-OFF SUBBAGP-SUBSETP T)

(TOGGLE EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-OFF
        EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP T)

(DEFN SPLIT-OUT-INEG-TERMS
      (X)
      (IF (LISTP X)
          (IF (LISTP (CAR X))
              (COND ((EQUAL (CAAR X) 'INEG)
                     (CONS (CAR (SPLIT-OUT-INEG-TERMS (CDR X)))
                           (CONS (CADAR X)
                                 (CDR (SPLIT-OUT-INEG-TERMS (CDR X))))))
                    ((AND (EQUAL (CAAR X) 'QUOTE)
                          (NEGATIVEP (CADAR X))
                          (NOT (EQUAL (NEGATIVE-GUTS (CADAR X)) 0)))
                     (CONS (CAR (SPLIT-OUT-INEG-TERMS (CDR X)))
                           (CONS (LIST 'QUOTE
                                       (NEGATIVE-GUTS (CADAR X)))
                                 (CDR (SPLIT-OUT-INEG-TERMS (CDR X))))))
                    (T (CONS (CONS (CAR X)
                                   (CAR (SPLIT-OUT-INEG-TERMS (CDR X))))
                             (CDR (SPLIT-OUT-INEG-TERMS (CDR X))))))
              (CONS (CONS (CAR X)
                          (CAR (SPLIT-OUT-INEG-TERMS (CDR X))))
                    (CDR (SPLIT-OUT-INEG-TERMS (CDR X)))))
          '(NIL)))

(DEFN REMOVE-INEGS
      (X Y)
      (IF (OR (LISTP (CDR (SPLIT-OUT-INEG-TERMS X)))
              (LISTP (CDR (SPLIT-OUT-INEG-TERMS Y))))
          (CONS (APPEND (CDR (SPLIT-OUT-INEG-TERMS Y))
                        (CAR (SPLIT-OUT-INEG-TERMS X)))
                (APPEND (CDR (SPLIT-OUT-INEG-TERMS X))
                        (CAR (SPLIT-OUT-INEG-TERMS Y))))
          F))

(DEFN IPLUS-OR-INEG-TERM
      (X)
      (AND (LISTP X)
           (OR (EQUAL (CAR X) 'INEG)
               (EQUAL (CAR X) 'IPLUS))))

(DEFN MAKE-CANCEL-INEG-TERMS-EQUALITY
 (X)
 (IF
  (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                (IPLUS-FRINGE (CADDR X)))
  (COND
   ((IPLUS-OR-INEG-TERM (CADR X))
    (IF (IPLUS-OR-INEG-TERM (CADDR X))
        (LIST 'EQUAL
              (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                             (IPLUS-FRINGE (CADDR X)))))
              (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                             (IPLUS-FRINGE (CADDR X))))))
        (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F))))
   ((IPLUS-OR-INEG-TERM (CADDR X))
    (LIST 'IF
          (LIST 'INTEGERP (CADR X))
          (LIST 'EQUAL
                (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                               (IPLUS-FRINGE (CADDR X)))))
                (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                               (IPLUS-FRINGE (CADDR X))))))
          (LIST 'QUOTE F)))
   (T X))
  X))

(DEFN CANCEL-INEG-TERMS-FROM-EQUALITY
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'EQUAL))
          (MAKE-CANCEL-INEG-TERMS-EQUALITY X)
          X))

(DEFN CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'EQUAL)
   (IF
    (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                  (IPLUS-FRINGE (CADDR X)))
    (COND
     ((LISTP (CADR X))
      (CASE
       (CAADR X)
       (INEG
        (IF
         (LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (INEG
             (LIST 'EQUAL
                   (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))
                   (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))))
          (IPLUS
             (LIST 'EQUAL
                   (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))
                   (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))))
          (OTHERWISE
           (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F))))
         (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F))))
       (IPLUS
        (IF
         (LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (INEG
             (LIST 'EQUAL
                   (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))
                   (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))))
          (IPLUS
             (LIST 'EQUAL
                   (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))
                   (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                  (IPLUS-FRINGE (CADDR X)))))))
          (OTHERWISE
           (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F))))
         (LIST 'IF
              (LIST 'INTEGERP (CADDR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F))))
       (OTHERWISE
        (IF
         (LISTP (CADDR X))
         (CASE
          (CAADDR X)
          (INEG
           (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F)))
          (IPLUS
           (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F)))
          (OTHERWISE X))
         X))))
     ((LISTP (CADDR X))
      (CASE
       (CAADDR X)
       (INEG
        (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F)))
       (IPLUS
        (LIST 'IF
              (LIST 'INTEGERP (CADR X))
              (LIST 'EQUAL
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              (LIST 'QUOTE F)))
       (OTHERWISE X)))
     (T X))
    X)
   X)
  X))

(PROVE-LEMMA
       CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED
       (REWRITE)
       (EQUAL (CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED X)
              (CANCEL-INEG-TERMS-FROM-EQUALITY X))
       ((DISABLE-THEORY T)
        (ENABLE-THEORY GROUND-ZERO)
        (ENABLE MAKE-CANCEL-INEG-TERMS-EQUALITY IPLUS-OR-INEG-TERM
                CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED
                CANCEL-INEG-TERMS-FROM-EQUALITY)))

(TOGGLE CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-OFF
        CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED T)

(PROVE-LEMMA INTEGERP-EVAL$-IPLUS-OR-INEG-TERM
             (REWRITE)
             (IMPLIES (IPLUS-OR-INEG-TERM X)
                      (INTEGERP (EVAL$ T X A))))

(TOGGLE IPLUS-OR-INEG-TERM-OFF IPLUS-OR-INEG-TERM T)

(PROVE-LEMMA EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS
       (REWRITE)
       (IMPLIES (REMOVE-INEGS X Y)
                (EQUAL (IPLUS-LIST (EVAL$ 'LIST
                                          (CAR (REMOVE-INEGS X Y))
                                          A))
                       (IPLUS (IPLUS-LIST (EVAL$ 'LIST
                                                 (CAR (SPLIT-OUT-INEG-TERMS X))
                                                 A))
                              (IPLUS-LIST (EVAL$ 'LIST
                                                 (CDR (SPLIT-OUT-INEG-TERMS Y))
                                                 A))))))

(PROVE-LEMMA EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS
       (REWRITE)
       (IMPLIES (REMOVE-INEGS X Y)
                (EQUAL (IPLUS-LIST (EVAL$ 'LIST
                                          (CDR (REMOVE-INEGS X Y))
                                          A))
                       (IPLUS (IPLUS-LIST (EVAL$ 'LIST
                                                 (CAR (SPLIT-OUT-INEG-TERMS Y))
                                                 A))
                              (IPLUS-LIST (EVAL$ 'LIST
                                                 (CDR (SPLIT-OUT-INEG-TERMS X))
                                                 A))))))

(PROVE-LEMMA MINUS-INEG
             (REWRITE)
             (IMPLIES (AND (NUMBERP X) (NOT (EQUAL X 0)))
                      (EQUAL (MINUS X) (INEG X)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS
             (REWRITE)
             (EQUAL (IPLUS-LIST (EVAL$ 'LIST
                                       (CAR (SPLIT-OUT-INEG-TERMS X))
                                       A))
                    (IPLUS (IPLUS-LIST (EVAL$ 'LIST X A))
                           (IPLUS-LIST (EVAL$ 'LIST
                                              (CDR (SPLIT-OUT-INEG-TERMS X))
                                              A))))
             ((INDUCT (SPLIT-OUT-INEG-TERMS X))
              (ENABLE EVAL$-QUOTE)))

(TOGGLE REMOVE-INEGS-OFF REMOVE-INEGS T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY
             ((META EQUAL))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED X)
                           A))
             ((ENABLE EVAL$-IPLUS-TREE IPLUS-LIST-EVAL$-FRINGE EVAL$-QUOTE)
              (DISABLE IPLUS-FRINGE)))

(DEFN MAKE-CANCEL-INEG-TERMS-INEQUALITY
      (X)
      (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                        (IPLUS-FRINGE (CADDR X)))
          (LIST 'ILESSP
                (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                               (IPLUS-FRINGE (CADDR X)))))
                (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                               (IPLUS-FRINGE (CADDR X))))))
          X))

(DEFN CANCEL-INEG-TERMS-FROM-INEQUALITY
      (X)
      (IF (AND (LISTP X)
               (EQUAL (CAR X) 'ILESSP))
          (COND ((IPLUS-OR-INEG-TERM (CADR X))
                 (MAKE-CANCEL-INEG-TERMS-INEQUALITY X))
                ((IPLUS-OR-INEG-TERM (CADDR X))
                 (MAKE-CANCEL-INEG-TERMS-INEQUALITY X))
                (T X))
          X))

(DEFN CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
 (X)
 (IF
  (LISTP X)
  (IF
   (EQUAL (CAR X) 'ILESSP)
   (COND
    ((LISTP (CADR X))
     (CASE
      (CAADR X)
      (INEG
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
      (IPLUS
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
      (OTHERWISE
       (IF
        (LISTP (CADDR X))
        (CASE
         (CAADDR X)
         (INEG
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
         (IPLUS
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
         (OTHERWISE X))
        X))))
    ((LISTP (CADDR X))
     (CASE
      (CAADDR X)
      (INEG
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
      (IPLUS
          (IF (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                            (IPLUS-FRINGE (CADDR X)))
              (LIST 'ILESSP
                    (IPLUS-TREE (CAR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X)))))
                    (IPLUS-TREE (CDR (REMOVE-INEGS (IPLUS-FRINGE (CADR X))
                                                   (IPLUS-FRINGE (CADDR X))))))
              X))
      (OTHERWISE X)))
    (T X))
   X)
  X))

(PROVE-LEMMA
   CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
   (REWRITE)
   (EQUAL (CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED X)
          (CANCEL-INEG-TERMS-FROM-INEQUALITY X))
   ((DISABLE-THEORY T)
    (ENABLE-THEORY GROUND-ZERO)
    (ENABLE MAKE-CANCEL-INEG-TERMS-INEQUALITY IPLUS-OR-INEG-TERM
            CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
            CANCEL-INEG-TERMS-FROM-INEQUALITY)))

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-OFF
        CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED T)

(PROVE-LEMMA CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY
             ((META ILESSP))
             (EQUAL (EVAL$ T X A)
                    (EVAL$ T
                           (CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED X)
                           A))
             ((ENABLE EVAL$-IPLUS-TREE IPLUS-LIST-EVAL$-FRINGE EVAL$-QUOTE)
              (DISABLE IPLUS-FRINGE)))

(TOGGLE MINUS-INEG-OFF MINUS-INEG T)

(TOGGLE INTEGERP-EVAL$-IPLUS-OR-INEG-TERM-OFF INTEGERP-EVAL$-IPLUS-OR-INEG-TERM
        T)

(PROVE-LEMMA PLUS-IPLUS
             (REWRITE)
             (IMPLIES (AND (NUMBERP I) (NUMBERP J))
                      (EQUAL (PLUS I J) (IPLUS I J)))
             ((ENABLE IPLUS)))

(PROVE-LEMMA IPLUS-CONSTANTS
             (REWRITE)
             (EQUAL (IPLUS (ADD1 I) (IPLUS (ADD1 J) X))
                    (IPLUS (PLUS (ADD1 I) (ADD1 J)) X))
             ((ENABLE FIX-INT INTEGERP)
              (DISABLE PLUS-ADD1-ARG1)))

(PROVE-LEMMA NUMBERP-IS-INTEGERP
             (REWRITE)
             (IMPLIES (NUMBERP W) (INTEGERP W))
             ((ENABLE INTEGERP)))

(PROVE-LEMMA DIFFERENCE-IDIFFERENCE
             (REWRITE)
             (IMPLIES (AND (NUMBERP X)
                           (NUMBERP Y)
                           (IF (LESSP Y X) F T))
                      (EQUAL (DIFFERENCE Y X)
                             (IDIFFERENCE Y X))))

(PROVE-LEMMA CANCEL-CONSTANTS-EQUAL-LEMMA NIL
             (IMPLIES (AND (NUMBERP M) (NUMBERP N))
                      (EQUAL (EQUAL (IPLUS M X) (IPLUS N Y))
                             (IF (LESSP M N)
                                 (EQUAL (FIX-INT X)
                                        (IPLUS (DIFFERENCE N M) Y))
                                 (EQUAL (IPLUS (DIFFERENCE M N) X)
                                        (FIX-INT Y))))))

(PROVE-LEMMA CANCEL-CONSTANTS-EQUAL
             (REWRITE)
             (EQUAL (EQUAL (IPLUS (ADD1 I) X)
                           (IPLUS (ADD1 J) Y))
                    (IF (LESSP I J)
                        (EQUAL (FIX-INT X)
                               (IPLUS (DIFFERENCE J I) Y))
                        (EQUAL (IPLUS (DIFFERENCE I J) X)
                               (FIX-INT Y))))
             ((USE (CANCEL-CONSTANTS-EQUAL-LEMMA (M (ADD1 I))
                                                 (N (ADD1 J))))
              (EXPAND (DIFFERENCE (ADD1 I) (ADD1 J))
                      (DIFFERENCE (ADD1 J) (ADD1 I))
                      (LESSP (ADD1 I) (ADD1 J)))
              (DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)))

(PROVE-LEMMA ILESSP-ADD1
             (REWRITE)
             (IMPLIES (NUMBERP Y)
                      (EQUAL (ILESSP X (ADD1 Y))
                             (NOT (ILESSP Y X))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA ILESSP-ADD1-IPLUS
             (REWRITE)
             (IMPLIES (NUMBERP Y)
                      (EQUAL (ILESSP X (IPLUS (ADD1 Y) Z))
                             (NOT (ILESSP (IPLUS Y Z) X))))
             ((ENABLE-THEORY INTEGER-DEFNS)
              (DISABLE PLUS-IPLUS DIFFERENCE-IDIFFERENCE)))

(PROVE-LEMMA CANCEL-CONSTANTS-ILESSP-LEMMA-1 NIL
             (IMPLIES (AND (NUMBERP M) (NUMBERP N))
                      (EQUAL (ILESSP (IPLUS M X) (IPLUS N Y))
                             (IF (LESSP M N)
                                 (ILESSP X (IPLUS (DIFFERENCE N M) Y))
                                 (ILESSP (IPLUS (DIFFERENCE M N) X)
                                         Y)))))

(PROVE-LEMMA CANCEL-CONSTANTS-ILESSP-LEMMA-2 NIL
             (IMPLIES (AND (NUMBERP M) (NUMBERP N))
                      (EQUAL (ILESSP (IPLUS M X) (IPLUS N Y))
                             (IF (LESSP M N)
                                 (NOT (ILESSP (IPLUS (SUB1 (DIFFERENCE N M)) Y)
                                              X))
                                 (ILESSP (IPLUS (DIFFERENCE M N) X)
                                         Y))))
             ((USE (CANCEL-CONSTANTS-ILESSP-LEMMA-1)
                   (ILESSP-ADD1-IPLUS (Y (SUB1 (DIFFERENCE N M)))
                                      (Z Y)
                                      (X X)))
              (DISABLE ILESSP-ADD1-IPLUS)))

(PROVE-LEMMA CANCEL-CONSTANTS-ILESSP
             (REWRITE)
             (EQUAL (ILESSP (IPLUS (ADD1 I) X)
                            (IPLUS (ADD1 J) Y))
                    (IF (LESSP I J)
                        (NOT (ILESSP (IPLUS (SUB1 (DIFFERENCE J I)) Y)
                                     X))
                        (ILESSP (IPLUS (DIFFERENCE I J) X)
                                Y)))
             ((USE (CANCEL-CONSTANTS-ILESSP-LEMMA-2 (M (ADD1 I))
                                                    (N (ADD1 J))))
              (EXPAND (DIFFERENCE (ADD1 I) (ADD1 J))
                      (DIFFERENCE (ADD1 J) (ADD1 I))
                      (LESSP (ADD1 I) (ADD1 J)))
              (DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)))

(TOGGLE PLUS-IPLUS-OFF PLUS-IPLUS T)

(TOGGLE NUMBERP-IS-INTEGERP-OFF NUMBERP-IS-INTEGERP T)

(TOGGLE DIFFERENCE-IDIFFERENCE-OFF DIFFERENCE-IDIFFERENCE T)

(DEFTHEORY INTEGERS
           (ILEQ IDIFFERENCE INTEGERP-FIX-INT INTEGERP-IPLUS
                 INTEGERP-IDIFFERENCE INTEGERP-INEG INTEGERP-IABS
                 INTEGERP-ITIMES FIX-INT-REMOVER FIX-INT-FIX-INT FIX-INT-IPLUS
                 FIX-INT-IDIFFERENCE FIX-INT-INEG FIX-INT-IABS FIX-INT-ITIMES
                 INEG-IPLUS INEG-INEG INEG-FIX-INT INEG-OF-NON-INTEGERP INEG-0
                 IPLUS-LEFT-ID IPLUS-RIGHT-ID IPLUS-0-LEFT IPLUS-0-RIGHT
                 COMMUTATIVITY2-OF-IPLUS COMMUTATIVITY-OF-IPLUS
                 ASSOCIATIVITY-OF-IPLUS IPLUS-CANCELLATION-1
                 IPLUS-CANCELLATION-2 IPLUS-INEG1 IPLUS-INEG2 IPLUS-FIX-INT1
                 IPLUS-FIX-INT2 IDIFFERENCE-FIX-INT1 IDIFFERENCE-FIX-INT2
                 IPLUS-LIST EVAL$-LIST-APPEND IPLUS-LIST-APPEND IPLUS-INEG3
                 IPLUS-INEG4 CORRECTNESS-OF-CANCEL-IPLUS ILESSP-FIX-INT-1
                 ILESSP-FIX-INT-2 IPLUS-CANCELLATION-1-FOR-ILESSP
                 IPLUS-CANCELLATION-2-FOR-ILESSP
                 CORRECTNESS-OF-CANCEL-IPLUS-ILESSP ITIMES-0-LEFT
                 ITIMES-0-RIGHT ITIMES-FIX-INT1 ITIMES-FIX-INT2
                 COMMUTATIVITY-OF-ITIMES ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF
                 ITIMES-DISTRIBUTES-OVER-IPLUS COMMUTATIVITY2-OF-ITIMES
                 ASSOCIATIVITY-OF-ITIMES EQUAL-ITIMES-0 EQUAL-ITIMES-1
                 EQUAL-ITIMES-MINUS-1 ITIMES-1-ARG1
                 QUOTIENT-REMAINDER-UNIQUENESS DIVISION-THEOREM ITIMES-INEG-1
                 ITIMES-INEG-2 ITIMES-CANCELLATION-1 ITIMES-CANCELLATION-2
                 ITIMES-CANCELLATION-3 INTEGERP-IQUOTIENT INTEGERP-IREMAINDER
                 INTEGERP-IDIV INTEGERP-IMOD INTEGERP-IQUO INTEGERP-IREM
                 IQUOTIENT-FIX-INT1 IQUOTIENT-FIX-INT2 IREMAINDER-FIX-INT1
                 IREMAINDER-FIX-INT2 IDIV-FIX-INT1 IDIV-FIX-INT2 IMOD-FIX-INT1
                 IMOD-FIX-INT2 IQUO-FIX-INT1 IQUO-FIX-INT2 IREM-FIX-INT1
                 IREM-FIX-INT2 FIX-INT-IQUOTIENT FIX-INT-IREMAINDER
                 FIX-INT-IDIV FIX-INT-IMOD FIX-INT-IQUO FIX-INT-IREM
                 ITIMES-LIST ITIMES-LIST-APPEND MEMBER-APPEND EQUAL-FIX-INT
                 SUBSETP CORRECTNESS-OF-CANCEL-ITIMES
                 CORRECTNESS-OF-CANCEL-ITIMES-ILESSP ILESSP-STRICT
                 EVAL$-LIST-CONS EVAL$-LIST-NLISTP EVAL$-LITATOM EVAL$-QUOTE
                 EVAL$-OTHER IPLUS-X-Y-INEG-X CORRECTNESS-OF-CANCEL-INEG
                 INTEGERP-IPLUS-LIST EVAL$-IPLUS-LIST-DELETE
                 EVAL$-IPLUS-LIST-BAGDIFF ITIMES-TREE-INEG ITIMES-FACTORS
                 ITIMES--1 EQUAL-INEG-INEG ILESSP-INEG-INEG
                 FIX-INT-EVAL$-ITIMES-TREE-REC EVAL$-ITIMES-TREE-INEG
                 INEG-EVAL$-ITIMES-TREE-INEG IPLUS-EVAL$-ITIMES-TREE-INEG
                 ITIMES-EVAL$-ITIMES-TREE-INEG IPLUS-OR-ITIMES-TERM
                 CANCEL-ITIMES-FACTORS CANCEL-ITIMES-FACTORS-EXPANDED
                 CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS
                 MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0 MEMBER-0-EVAL$-LIST
                 CORRECTNESS-OF-CANCEL-ITIMES-FACTORS
                 CANCEL-ITIMES-ILESSP-FACTORS BAGINT-SINGLETON
                 ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF
                 ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1
                 MEMBER-0-ITIMES-FACTORS-YIELDS-0
                 MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1
                 MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2
                 ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2
                 CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS
                 DISJOIN-EQUALITIES-WITH-0 CANCEL-FACTORS-0 SOME-EVAL$S-TO-0
                 EVAL$-DISJOIN-EQUALITIES-WITH-0 SOME-EVAL$S-TO-0-APPEND
                 SOME-EVAL$S-TO-0-ELIMINATOR CORRECTNESS-OF-CANCEL-FACTORS-0
                 CONJOIN-INEQUALITIES-WITH-0 CANCEL-FACTORS-ILESSP-0
                 SPLIT-OUT-INEG-TERMS
                 CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY
                 CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY
                 IPLUS-CONSTANTS CANCEL-CONSTANTS-EQUAL ILESSP-ADD1
                 ILESSP-ADD1-IPLUS CANCEL-CONSTANTS-ILESSP))

(TOGGLE EVAL$-ON EVAL$ NIL)

(DEFTHEORY MATH-THEORY
 (CANCEL-CONSTANTS-ILESSP CANCEL-CONSTANTS-ILESSP-LEMMA-2
   CANCEL-CONSTANTS-ILESSP-LEMMA-1 ILESSP-ADD1-IPLUS ILESSP-ADD1
   CANCEL-CONSTANTS-EQUAL CANCEL-CONSTANTS-EQUAL-LEMMA IPLUS-CONSTANTS
   CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY
   CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
   *1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
   CANCEL-INEG-TERMS-FROM-INEQUALITY *1*CANCEL-INEG-TERMS-FROM-INEQUALITY
   MAKE-CANCEL-INEG-TERMS-INEQUALITY *1*MAKE-CANCEL-INEG-TERMS-INEQUALITY
   CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY
   IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS
   EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS
   CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED
   *1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED CANCEL-INEG-TERMS-FROM-EQUALITY
   *1*CANCEL-INEG-TERMS-FROM-EQUALITY MAKE-CANCEL-INEG-TERMS-EQUALITY
   *1*MAKE-CANCEL-INEG-TERMS-EQUALITY *1*IPLUS-OR-INEG-TERM *1*REMOVE-INEGS
   SPLIT-OUT-INEG-TERMS *1*SPLIT-OUT-INEG-TERMS
   CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0
   CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR CANCEL-FACTORS-ILESSP-0
   *1*CANCEL-FACTORS-ILESSP-0 CONJOIN-INEQUALITIES-WITH-0
   *1*CONJOIN-INEQUALITIES-WITH-0 CORRECTNESS-OF-CANCEL-FACTORS-0
   SOME-EVAL$S-TO-0-ELIMINATOR SOME-EVAL$S-TO-0-APPEND
   EVAL$-DISJOIN-EQUALITIES-WITH-0 SOME-EVAL$S-TO-0 *1*SOME-EVAL$S-TO-0
   CANCEL-FACTORS-0 *1*CANCEL-FACTORS-0 DISJOIN-EQUALITIES-WITH-0
   *1*DISJOIN-EQUALITIES-WITH-0 CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS
   EQUAL-FIX-INT-TO-ILESSP EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA
   EVAL$-LIST-BAGINT-0-FOR-ILESSP
   MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2
   MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1
   MEMBER-0-ITIMES-FACTORS-YIELDS-0
   ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2
   ILESSP-ZERO-IMPLIES-NOT-EQUAL
   ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1
   ZERO-ILESSP-IMPLIES-NOT-EQUAL ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF
   BAGINT-SINGLETON CANCEL-ITIMES-ILESSP-FACTORS
   *1*CANCEL-ITIMES-ILESSP-FACTORS CORRECTNESS-OF-CANCEL-ITIMES-FACTORS
   MEMBER-0-EVAL$-LIST MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0
   CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS
   *1*CANCEL-ITIMES-FACTORS-EXPANDED CANCEL-ITIMES-FACTORS
   *1*CANCEL-ITIMES-FACTORS *1*IPLUS-OR-ITIMES-TERM
   ITIMES-EVAL$-ITIMES-TREE-INEG IPLUS-EVAL$-ITIMES-TREE-INEG
   INEG-EVAL$-ITIMES-TREE-INEG EVAL$-ITIMES-TREE-INEG
   FIX-INT-EVAL$-ITIMES-TREE-REC ILESSP-INEG-INEG EQUAL-INEG-INEG ITIMES--1
   ITIMES-FACTORS *1*ITIMES-FACTORS *1*ITIMES-TREE-INEG ILESSP-STRICT
   ILESSP-ITIMES-RIGHT-NEGATIVE ILESSP-ITIMES-RIGHT-POSITIVE
   CANCEL-ITIMES-ILESSP *1*CANCEL-ITIMES-ILESSP
   *1*MAKE-CANCEL-ITIMES-INEQUALITY *1*ITIMES-TREE-NO-FIX-INT SUBSETP
   *1*SUBSETP EQUAL-FIX-INT MEMBER-APPEND ITIMES-LIST-APPEND CANCEL-ITIMES
   *1*CANCEL-ITIMES *1*MAKE-CANCEL-ITIMES-EQUALITY INTEGERP-ITIMES-LIST
   ITIMES-LIST *1*ITIMES-LIST *1*ITIMES-TREE ITIMES-TREE-REC
   *1*ITIMES-TREE-REC ITIMES-FRINGE *1*ITIMES-FRINGE FIX-INT-IREM FIX-INT-IQUO
   FIX-INT-IMOD FIX-INT-IDIV FIX-INT-IREMAINDER FIX-INT-IQUOTIENT
   IREM-FIX-INT2 IREM-FIX-INT1 IQUO-FIX-INT2 IQUO-FIX-INT1 IMOD-FIX-INT2
   IMOD-FIX-INT1 IDIV-FIX-INT2 IDIV-FIX-INT1 IREMAINDER-FIX-INT2
   IREMAINDER-FIX-INT1 IQUOTIENT-FIX-INT2 IQUOTIENT-FIX-INT1 INTEGERP-IREM
   INTEGERP-IQUO INTEGERP-IMOD INTEGERP-IDIV INTEGERP-IREMAINDER
   INTEGERP-IQUOTIENT ITIMES-CANCELLATION-3 ITIMES-CANCELLATION-2
   ITIMES-CANCELLATION-1 ITIMES-INEG-2 ITIMES-INEG-1 IQUO-IREM-UNIQUENESS
   DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO
   DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3
   DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2
   DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 IDIV-IMOD-UNIQUENESS
   DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF
   DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3
   DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2
   DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1
   IQUOTIENT-IREMAINDER-UNIQUENESS DIVISION-THEOREM DIVISION-THEOREM-PART3
   DIVISION-THEOREM-PART2 DIVISION-THEOREM-PART1 QUOTIENT-REMAINDER-UNIQUENESS
   ITIMES-1-ARG1 EQUAL-ITIMES-MINUS-1 EQUAL-ITIMES-1 EQUAL-ITIMES-0
   ASSOCIATIVITY-OF-ITIMES COMMUTATIVITY2-OF-ITIMES
   ITIMES-DISTRIBUTES-OVER-IPLUS ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF
   COMMUTATIVITY-OF-ITIMES ITIMES-FIX-INT2 ITIMES-FIX-INT1 ITIMES-0-RIGHT
   ITIMES-0-LEFT CORRECTNESS-OF-CANCEL-IPLUS-ILESSP CANCEL-IPLUS-ILESSP
   *1*CANCEL-IPLUS-ILESSP *1*IPLUS-TREE-NO-FIX-INT
   IPLUS-CANCELLATION-2-FOR-ILESSP IPLUS-CANCELLATION-1-FOR-ILESSP
   CANCEL-IPLUS-ILESSP-1 *1*CANCEL-IPLUS-ILESSP-1
   *1*MAKE-CANCEL-IPLUS-INEQUALITY-1 ILESSP-FIX-INT-2 ILESSP-FIX-INT-1
   CORRECTNESS-OF-CANCEL-IPLUS IPLUS-INEG7 IPLUS-LIST-APPEND
   EVAL$-IPLUS-LIST-DELETE *1*CANCEL-IPLUS EVAL$-LIST-APPEND
   INTEGERP-IPLUS-LIST IPLUS-LIST *1*IPLUS-LIST *1*IPLUS-TREE IPLUS-TREE-REC
   *1*IPLUS-TREE-REC IPLUS-FRINGE *1*IPLUS-FRINGE CORRECTNESS-OF-CANCEL-INEG
   IPLUS-X-Y-INEG-X IPLUS-INEG4 IPLUS-INEG3 EVAL$-CANCEL-INEG-AUX-IS-ITS-FN
   EVAL$-CANCEL-INEG-AUX-FN *1*EVAL$-CANCEL-INEG-AUX-FN EVAL$-OTHER
   EVAL$-LITATOM EVAL$-LIST-NLISTP EVAL$-LIST-CONS CANCEL-INEG *1*CANCEL-INEG
   CANCEL-INEG-AUX *1*CANCEL-INEG-AUX IDIFFERENCE-FIX-INT2
   IDIFFERENCE-FIX-INT1 IPLUS-FIX-INT2 IPLUS-FIX-INT1 IPLUS-INEG2 IPLUS-INEG1
   IPLUS-CANCELLATION-2 IPLUS-CANCELLATION-1 ASSOCIATIVITY-OF-IPLUS
   COMMUTATIVITY-OF-IPLUS COMMUTATIVITY2-OF-IPLUS IPLUS-0-RIGHT IPLUS-0-LEFT
   INEG-0 INEG-FIX-INT INEG-INEG INEG-IPLUS FIX-INT-ITIMES FIX-INT-IABS
   FIX-INT-INEG FIX-INT-IDIFFERENCE FIX-INT-IPLUS FIX-INT-FIX-INT
   FIX-INT-REMOVER INTEGERP-ITIMES INTEGERP-IABS INTEGERP-INEG
   INTEGERP-IDIFFERENCE INTEGERP-IPLUS INTEGERP-FIX-INT *1*IREM *1*IQUO
   *1*IMOD *1*IDIV *1*IREMAINDER *1*IQUOTIENT *1*ITIMES *1*IABS IDIFFERENCE
   *1*IDIFFERENCE *1*INEG *1*IPLUS ILEQ *1*ILEQ *1*ILESSP IZEROP *1*IZEROP
   *1*FIX-INT *1*INTEGERP GCD-IDEMPOTENCE GCD-X-X COMMUTATIVITY2-OF-GCD
   COMMUTATIVITY2-OF-GCD-ZERO-CASE ASSOCIATIVITY-OF-GCD
   ASSOCIATIVITY-OF-GCD-ZERO-CASE COMMON-DIVISOR-DIVIDES-GCD
   GCD-IS-THE-GREATEST DISTRIBUTIVITY-OF-TIMES-OVER-GCD
   DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF REMAINDER-GCD GCD-PLUS-INSTANCE
   GCD-PLUS GCD-PLUS-PROOF GCD-PLUS-INSTANCE-TEMP GCD-PLUS-INSTANCE-TEMP-PROOF
   LESSP-GCD EQUAL-GCD-0 GCD-1 GCD-0 SINGLE-NUMBER-INDUCTION
   *1*SINGLE-NUMBER-INDUCTION COMMUTATIVITY-OF-GCD LOG-EXP LOG-TIMES-EXP
   LOG-TIMES-EXP-PROOF LOG-TIMES LOG-TIMES-PROOF LOG-QUOTIENT-EXP
   LOG-QUOTIENT-TIMES LOG-QUOTIENT-TIMES-PROOF LOG-QUOTIENT LEQ-LOG-LOG
   DOUBLE-LOG-INDUCTION *1*DOUBLE-LOG-INDUCTION LOG-1 LOG-0 EQUAL-LOG-0
   EXP-DIFFERENCE EQUAL-EXP-1 EQUAL-EXP-0 EXP-EXP EXP-TIMES EXP-0-ARG2
   EXP-1-ARG1 EXP-0-ARG1 EXP-PLUS EXP-ADD1 EXP-ZERO QUOTIENT-EXP
   REMAINDER-EXP-EXP DOUBLE-NUMBER-INDUCTION *1*DOUBLE-NUMBER-INDUCTION
   REMAINDER-EXP GCD *1*GCD LOG *1*LOG EXP *1*EXP
   CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES CANCEL-QUOTIENT-TIMES
   *1*CANCEL-QUOTIENT-TIMES LESSP-QUOTIENT QUOTIENT-X-X QUOTIENT-1-ARG1
   QUOTIENT-1-ARG1-CASESPLIT QUOTIENT-1-ARG2 LEQ-QUOTIENT QUOTIENT-QUOTIENT
   QUOTIENT-PLUS-TIMES-TIMES-INSTANCE QUOTIENT-PLUS-TIMES-TIMES
   QUOTIENT-PLUS-TIMES-TIMES-PROOF QUOTIENT-PLUS-FACT
   QUOTIENT-REMAINDER-INSTANCE QUOTIENT-REMAINDER QUOTIENT-REMAINDER-TIMES
   QUOTIENT-DIFFERENCE3 QUOTIENT-DIFFERENCE2 QUOTIENT-LESSP-ARG1
   QUOTIENT-DIFFERENCE1 QUOTIENT-TIMES-TIMES-PROOF QUOTIENT-TIMES-INSTANCE
   QUOTIENT-TIMES QUOTIENT-TIMES-PROOF QUOTIENT-TIMES-INSTANCE-TEMP-PROOF
   QUOTIENT-PLUS QUOTIENT-PLUS-PROOF QUOTIENT-SUB1 EQUAL-QUOTIENT-0
   QUOTIENT-ADD1 QUOTIENT-ZERO QUOTIENT-OF-NON-NUMBER QUOTIENT-NOOP
   TRANSITIVITY-OF-DIVIDES REMAINDER-X-X REMAINDER-1-ARG2 REMAINDER-1-ARG1
   REMAINDER-REMAINDER REMAINDER-PLUS-TIMES-TIMES-INSTANCE
   REMAINDER-PLUS-TIMES-TIMES REMAINDER-PLUS-TIMES-TIMES-PROOF
   REMAINDER-PLUS-FACT REMAINDER-DIFFERENCE2 DOUBLE-REMAINDER-INDUCTION
   *1*DOUBLE-REMAINDER-INDUCTION REMAINDER-DIFFERENCE1
   REMAINDER-TIMES2-INSTANCE REMAINDER-TIMES2 REMAINDER-TIMES2-PROOF
   REMAINDER-TIMES-TIMES-PROOF REMAINDER-TIMES1-INSTANCE
   REMAINDER-TIMES1-INSTANCE-PROOF REMAINDER-TIMES1 REMAINDER-TIMES1-PROOF
   EQUAL-REMAINDER-PLUS-REMAINDER-PROOF EQUAL-REMAINDER-PLUS-0
   EQUAL-REMAINDER-PLUS-0-PROOF REMAINDER-PLUS REMAINDER-PLUS-PROOF
   REMAINDER-ADD1 REMAINDER-QUOTIENT-ELIM REMAINDER-ZERO
   REMAINDER-OF-NON-NUMBER REMAINDER-NOOP LESSP-REMAINDER
   CORRECTNESS-OF-CANCEL-EQUAL-TIMES CANCEL-EQUAL-TIMES *1*CANCEL-EQUAL-TIMES
   CORRECTNESS-OF-CANCEL-LESSP-TIMES CANCEL-LESSP-TIMES *1*CANCEL-LESSP-TIMES
   INFER-EQUALITY-FROM-NOT-LESSP LESSP-TIMES-ARG1 EVAL$-EQUAL
   AND-NOT-ZEROP-TREE *1*AND-NOT-ZEROP-TREE OR-ZEROP-TREE *1*OR-ZEROP-TREE
   TIMES-FRINGE *1*TIMES-FRINGE TIMES-TREE *1*TIMES-TREE LESSP-1-TIMES
   LESSP-PLUS-TIMES2 LESSP-PLUS-TIMES1 LESSP-PLUS-TIMES-PROOF
   LESSP-TIMES-CANCELLATION-PROOF LESSP-TIMES3 LESSP-TIMES3-PROOF2
   LESSP-TIMES3-PROOF1 LESSP-TIMES2 LESSP-TIMES2-PROOF LESSP-TIMES1
   LESSP-TIMES1-PROOF TIMES-1-ARG1 TIMES-QUOTIENT TIMES-QUOTIENT-PROOF
   TIMES-DISTRIBUTES-OVER-DIFFERENCE TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF
   ASSOCIATIVITY-OF-TIMES COMMUTATIVITY2-OF-TIMES TIMES-DISTRIBUTES-OVER-PLUS
   TIMES-DISTRIBUTES-OVER-PLUS-PROOF COMMUTATIVITY-OF-TIMES TIMES-ADD1
   TIMES-ZERO EQUAL-SUB1-0 EQUAL-TIMES-1 EQUAL-TIMES-0
   CORRECTNESS-OF-CANCEL-LESSP-PLUS CANCEL-LESSP-PLUS *1*CANCEL-LESSP-PLUS
   DIFFERENCE-X-X DIFFERENCE-DIFFERENCE-ARG2 DIFFERENCE-DIFFERENCE-ARG1
   DIFFERENCE-SUB1-ARG2 DIFFERENCE-ADD1-ARG2 DIFFERENCE-LEQ-ARG1
   DIFFERENCE-ELIM CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS
   CANCEL-DIFFERENCE-PLUS *1*CANCEL-DIFFERENCE-PLUS
   CORRECTNESS-OF-CANCEL-EQUAL-PLUS CANCEL-EQUAL-PLUS *1*CANCEL-EQUAL-PLUS
   EVAL$-QUOTE PLUS-TREE *1*PLUS-TREE PLUS-FRINGE *1*PLUS-FRINGE
   DIFF-DIFF-ARG2 DIFF-DIFF-ARG1 DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF
   DIFFERENCE-PLUS-CANCELLATION-PROOF PLUS-DIFFERENCE-ARG2
   PLUS-DIFFERENCE-ARG1 ASSOCIATIVITY-OF-PLUS PLUS-ADD1-ARG2 PLUS-ADD1-ARG1
   PLUS-ZERO-ARG2 COMMUTATIVITY2-OF-PLUS COMMUTATIVITY-OF-PLUS
   EQUAL-DIFFERENCE-0 EQUAL-PLUS-0 MEMBER-BAGINT OCCURRENCES-BAGDIFF
   OCCURRENCES-BAGINT SUBBAGP-BAGINT2 SUBBAGP-BAGINT1 SUBBAGP-CDR2
   SUBBAGP-CDR1 SUBBAGP-DELETE BAGDIFF-DELETE MEMBER-BAGDIFF
   OCCURRENCES-DELETE MEMBER-DELETE-IMPLIES-MEMBERSHIP MEMBER-DELETE
   MEMBER-NON-LIST EQUAL-OCCURRENCES-ZERO DELETE-DELETE DELETE-NON-MEMBER
   SUBBAGP *1*SUBBAGP OCCURRENCES *1*OCCURRENCES BAGINT *1*BAGINT BAGDIFF
   *1*BAGDIFF DELETE *1*DELETE))

(TOGGLE CANCEL-CONSTANTS-ILESSP-OFF CANCEL-CONSTANTS-ILESSP T)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-2-OFF CANCEL-CONSTANTS-ILESSP-LEMMA-2 T)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-1-OFF CANCEL-CONSTANTS-ILESSP-LEMMA-1 T)

(TOGGLE ILESSP-ADD1-IPLUS-OFF ILESSP-ADD1-IPLUS T)

(TOGGLE ILESSP-ADD1-OFF ILESSP-ADD1 T)

(TOGGLE CANCEL-CONSTANTS-EQUAL-OFF CANCEL-CONSTANTS-EQUAL T)

(TOGGLE CANCEL-CONSTANTS-EQUAL-LEMMA-OFF CANCEL-CONSTANTS-EQUAL-LEMMA T)

(TOGGLE IPLUS-CONSTANTS-OFF IPLUS-CONSTANTS T)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY T)

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-OFF
 CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-OFF
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED T)

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF CANCEL-INEG-TERMS-FROM-INEQUALITY
        T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY T)

(TOGGLE MAKE-CANCEL-INEG-TERMS-INEQUALITY-OFF MAKE-CANCEL-INEG-TERMS-INEQUALITY
        T)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-INEQUALITY-OFF
        *1*MAKE-CANCEL-INEG-TERMS-INEQUALITY T)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY-OFF
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS-OFF
        IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS T)

(TOGGLE EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS-OFF EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS
        T)

(TOGGLE EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS-OFF EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS
        T)

(TOGGLE
   CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-OFF
   CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-OFF
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED T)

(TOGGLE CANCEL-INEG-TERMS-FROM-EQUALITY-OFF CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-OFF
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE MAKE-CANCEL-INEG-TERMS-EQUALITY-OFF MAKE-CANCEL-INEG-TERMS-EQUALITY T)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-EQUALITY-OFF
        *1*MAKE-CANCEL-INEG-TERMS-EQUALITY T)

(TOGGLE G*1*IPLUS-OR-INEG-TERM-OFF *1*IPLUS-OR-INEG-TERM T)

(TOGGLE G*1*REMOVE-INEGS-OFF *1*REMOVE-INEGS T)

(TOGGLE SPLIT-OUT-INEG-TERMS-OFF SPLIT-OUT-INEG-TERMS T)

(TOGGLE G*1*SPLIT-OUT-INEG-TERMS-OFF *1*SPLIT-OUT-INEG-TERMS T)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0-OFF
        CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR-OFF
        CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR T)

(TOGGLE CANCEL-FACTORS-ILESSP-0-OFF CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE G*1*CANCEL-FACTORS-ILESSP-0-OFF *1*CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-OFF CONJOIN-INEQUALITIES-WITH-0 T)

(TOGGLE G*1*CONJOIN-INEQUALITIES-WITH-0-OFF *1*CONJOIN-INEQUALITIES-WITH-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-0-OFF CORRECTNESS-OF-CANCEL-FACTORS-0 T)

(TOGGLE SOME-EVAL$S-TO-0-ELIMINATOR-OFF SOME-EVAL$S-TO-0-ELIMINATOR T)

(TOGGLE SOME-EVAL$S-TO-0-APPEND-OFF SOME-EVAL$S-TO-0-APPEND T)

(TOGGLE EVAL$-DISJOIN-EQUALITIES-WITH-0-OFF EVAL$-DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE SOME-EVAL$S-TO-0-OFF SOME-EVAL$S-TO-0 T)

(TOGGLE G*1*SOME-EVAL$S-TO-0-OFF *1*SOME-EVAL$S-TO-0 T)

(TOGGLE CANCEL-FACTORS-0-OFF CANCEL-FACTORS-0 T)

(TOGGLE G*1*CANCEL-FACTORS-0-OFF *1*CANCEL-FACTORS-0 T)

(TOGGLE DISJOIN-EQUALITIES-WITH-0-OFF DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE G*1*DISJOIN-EQUALITIES-WITH-0-OFF *1*DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE EQUAL-FIX-INT-TO-ILESSP-OFF EQUAL-FIX-INT-TO-ILESSP T)

(TOGGLE EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA-OFF
        EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA T)

(TOGGLE EVAL$-LIST-BAGINT-0-FOR-ILESSP-OFF EVAL$-LIST-BAGINT-0-FOR-ILESSP T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2-OFF
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2 T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1-OFF
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1 T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-OFF MEMBER-0-ITIMES-FACTORS-YIELDS-0 T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2 T)

(TOGGLE ILESSP-ZERO-IMPLIES-NOT-EQUAL-OFF ILESSP-ZERO-IMPLIES-NOT-EQUAL T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1 T)

(TOGGLE ZERO-ILESSP-IMPLIES-NOT-EQUAL-OFF ZERO-ILESSP-IMPLIES-NOT-EQUAL T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-OFF
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF T)

(TOGGLE BAGINT-SINGLETON-OFF BAGINT-SINGLETON T)

(TOGGLE CANCEL-ITIMES-ILESSP-FACTORS-OFF CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-FACTORS-OFF *1*CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-FACTORS-OFF
        CORRECTNESS-OF-CANCEL-ITIMES-FACTORS T)

(TOGGLE MEMBER-0-EVAL$-LIST-OFF MEMBER-0-EVAL$-LIST T)

(TOGGLE MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0-OFF
        MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0 T)

(TOGGLE CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS-OFF
        CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-EXPANDED-OFF
        *1*CANCEL-ITIMES-FACTORS-EXPANDED T)

(TOGGLE CANCEL-ITIMES-FACTORS-OFF CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-OFF *1*CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*IPLUS-OR-ITIMES-TERM-OFF *1*IPLUS-OR-ITIMES-TERM T)

(TOGGLE ITIMES-EVAL$-ITIMES-TREE-INEG-OFF ITIMES-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE IPLUS-EVAL$-ITIMES-TREE-INEG-OFF IPLUS-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE INEG-EVAL$-ITIMES-TREE-INEG-OFF INEG-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE EVAL$-ITIMES-TREE-INEG-OFF EVAL$-ITIMES-TREE-INEG T)

(TOGGLE FIX-INT-EVAL$-ITIMES-TREE-REC-OFF FIX-INT-EVAL$-ITIMES-TREE-REC T)

(TOGGLE ILESSP-INEG-INEG-OFF ILESSP-INEG-INEG T)

(TOGGLE EQUAL-INEG-INEG-OFF EQUAL-INEG-INEG T)

(TOGGLE ITIMES--1-OFF ITIMES--1 T)

(TOGGLE ITIMES-FACTORS-OFF ITIMES-FACTORS T)

(TOGGLE G*1*ITIMES-FACTORS-OFF *1*ITIMES-FACTORS T)

(TOGGLE G*1*ITIMES-TREE-INEG-OFF *1*ITIMES-TREE-INEG T)

(TOGGLE ILESSP-STRICT-OFF ILESSP-STRICT T)

(TOGGLE ILESSP-ITIMES-RIGHT-NEGATIVE-OFF ILESSP-ITIMES-RIGHT-NEGATIVE T)

(TOGGLE ILESSP-ITIMES-RIGHT-POSITIVE-OFF ILESSP-ITIMES-RIGHT-POSITIVE T)

(TOGGLE CANCEL-ITIMES-ILESSP-OFF CANCEL-ITIMES-ILESSP T)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-OFF *1*CANCEL-ITIMES-ILESSP T)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-INEQUALITY-OFF *1*MAKE-CANCEL-ITIMES-INEQUALITY
        T)

(TOGGLE G*1*ITIMES-TREE-NO-FIX-INT-OFF *1*ITIMES-TREE-NO-FIX-INT T)

(TOGGLE SUBSETP-OFF SUBSETP T)

(TOGGLE G*1*SUBSETP-OFF *1*SUBSETP T)

(TOGGLE EQUAL-FIX-INT-OFF EQUAL-FIX-INT T)

(TOGGLE MEMBER-APPEND-OFF MEMBER-APPEND T)

(TOGGLE ITIMES-LIST-APPEND-OFF ITIMES-LIST-APPEND T)

(TOGGLE CANCEL-ITIMES-OFF CANCEL-ITIMES T)

(TOGGLE G*1*CANCEL-ITIMES-OFF *1*CANCEL-ITIMES T)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-EQUALITY-OFF *1*MAKE-CANCEL-ITIMES-EQUALITY T)

(TOGGLE INTEGERP-ITIMES-LIST-OFF INTEGERP-ITIMES-LIST T)

(TOGGLE ITIMES-LIST-OFF ITIMES-LIST T)

(TOGGLE G*1*ITIMES-LIST-OFF *1*ITIMES-LIST T)

(TOGGLE G*1*ITIMES-TREE-OFF *1*ITIMES-TREE T)

(TOGGLE ITIMES-TREE-REC-OFF ITIMES-TREE-REC T)

(TOGGLE G*1*ITIMES-TREE-REC-OFF *1*ITIMES-TREE-REC T)

(TOGGLE ITIMES-FRINGE-OFF ITIMES-FRINGE T)

(TOGGLE G*1*ITIMES-FRINGE-OFF *1*ITIMES-FRINGE T)

(TOGGLE FIX-INT-IREM-OFF FIX-INT-IREM T)

(TOGGLE FIX-INT-IQUO-OFF FIX-INT-IQUO T)

(TOGGLE FIX-INT-IMOD-OFF FIX-INT-IMOD T)

(TOGGLE FIX-INT-IDIV-OFF FIX-INT-IDIV T)

(TOGGLE FIX-INT-IREMAINDER-OFF FIX-INT-IREMAINDER T)

(TOGGLE FIX-INT-IQUOTIENT-OFF FIX-INT-IQUOTIENT T)

(TOGGLE IREM-FIX-INT2-OFF IREM-FIX-INT2 T)

(TOGGLE IREM-FIX-INT1-OFF IREM-FIX-INT1 T)

(TOGGLE IQUO-FIX-INT2-OFF IQUO-FIX-INT2 T)

(TOGGLE IQUO-FIX-INT1-OFF IQUO-FIX-INT1 T)

(TOGGLE IMOD-FIX-INT2-OFF IMOD-FIX-INT2 T)

(TOGGLE IMOD-FIX-INT1-OFF IMOD-FIX-INT1 T)

(TOGGLE IDIV-FIX-INT2-OFF IDIV-FIX-INT2 T)

(TOGGLE IDIV-FIX-INT1-OFF IDIV-FIX-INT1 T)

(TOGGLE IREMAINDER-FIX-INT2-OFF IREMAINDER-FIX-INT2 T)

(TOGGLE IREMAINDER-FIX-INT1-OFF IREMAINDER-FIX-INT1 T)

(TOGGLE IQUOTIENT-FIX-INT2-OFF IQUOTIENT-FIX-INT2 T)

(TOGGLE IQUOTIENT-FIX-INT1-OFF IQUOTIENT-FIX-INT1 T)

(TOGGLE INTEGERP-IREM-OFF INTEGERP-IREM T)

(TOGGLE INTEGERP-IQUO-OFF INTEGERP-IQUO T)

(TOGGLE INTEGERP-IMOD-OFF INTEGERP-IMOD T)

(TOGGLE INTEGERP-IDIV-OFF INTEGERP-IDIV T)

(TOGGLE INTEGERP-IREMAINDER-OFF INTEGERP-IREMAINDER T)

(TOGGLE INTEGERP-IQUOTIENT-OFF INTEGERP-IQUOTIENT T)

(TOGGLE ITIMES-CANCELLATION-3-OFF ITIMES-CANCELLATION-3 T)

(TOGGLE ITIMES-CANCELLATION-2-OFF ITIMES-CANCELLATION-2 T)

(TOGGLE ITIMES-CANCELLATION-1-OFF ITIMES-CANCELLATION-1 T)

(TOGGLE ITIMES-INEG-2-OFF ITIMES-INEG-2 T)

(TOGGLE ITIMES-INEG-1-OFF ITIMES-INEG-1 T)

(TOGGLE IQUO-IREM-UNIQUENESS-OFF IQUO-IREM-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 T)

(TOGGLE IDIV-IMOD-UNIQUENESS-OFF IDIV-IMOD-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1-OFF
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1 T)

(TOGGLE IQUOTIENT-IREMAINDER-UNIQUENESS-OFF IQUOTIENT-IREMAINDER-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-OFF DIVISION-THEOREM T)

(TOGGLE DIVISION-THEOREM-PART3-OFF DIVISION-THEOREM-PART3 T)

(TOGGLE DIVISION-THEOREM-PART2-OFF DIVISION-THEOREM-PART2 T)

(TOGGLE DIVISION-THEOREM-PART1-OFF DIVISION-THEOREM-PART1 T)

(TOGGLE QUOTIENT-REMAINDER-UNIQUENESS-OFF QUOTIENT-REMAINDER-UNIQUENESS T)

(TOGGLE ITIMES-1-ARG1-OFF ITIMES-1-ARG1 T)

(TOGGLE EQUAL-ITIMES-MINUS-1-OFF EQUAL-ITIMES-MINUS-1 T)

(TOGGLE EQUAL-ITIMES-1-OFF EQUAL-ITIMES-1 T)

(TOGGLE EQUAL-ITIMES-0-OFF EQUAL-ITIMES-0 T)

(TOGGLE ASSOCIATIVITY-OF-ITIMES-OFF ASSOCIATIVITY-OF-ITIMES T)

(TOGGLE COMMUTATIVITY2-OF-ITIMES-OFF COMMUTATIVITY2-OF-ITIMES T)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-OFF ITIMES-DISTRIBUTES-OVER-IPLUS T)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF-OFF
        ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF T)

(TOGGLE COMMUTATIVITY-OF-ITIMES-OFF COMMUTATIVITY-OF-ITIMES T)

(TOGGLE ITIMES-FIX-INT2-OFF ITIMES-FIX-INT2 T)

(TOGGLE ITIMES-FIX-INT1-OFF ITIMES-FIX-INT1 T)

(TOGGLE ITIMES-0-RIGHT-OFF ITIMES-0-RIGHT T)

(TOGGLE ITIMES-0-LEFT-OFF ITIMES-0-LEFT T)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-OFF
        CORRECTNESS-OF-CANCEL-IPLUS-ILESSP T)

(TOGGLE CANCEL-IPLUS-ILESSP-OFF CANCEL-IPLUS-ILESSP T)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-OFF *1*CANCEL-IPLUS-ILESSP T)

(TOGGLE G*1*IPLUS-TREE-NO-FIX-INT-OFF *1*IPLUS-TREE-NO-FIX-INT T)

(TOGGLE IPLUS-CANCELLATION-2-FOR-ILESSP-OFF IPLUS-CANCELLATION-2-FOR-ILESSP T)

(TOGGLE IPLUS-CANCELLATION-1-FOR-ILESSP-OFF IPLUS-CANCELLATION-1-FOR-ILESSP T)

(TOGGLE CANCEL-IPLUS-ILESSP-1-OFF CANCEL-IPLUS-ILESSP-1 T)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-1-OFF *1*CANCEL-IPLUS-ILESSP-1 T)

(TOGGLE G*1*MAKE-CANCEL-IPLUS-INEQUALITY-1-OFF
        *1*MAKE-CANCEL-IPLUS-INEQUALITY-1 T)

(TOGGLE ILESSP-FIX-INT-2-OFF ILESSP-FIX-INT-2 T)

(TOGGLE ILESSP-FIX-INT-1-OFF ILESSP-FIX-INT-1 T)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-OFF CORRECTNESS-OF-CANCEL-IPLUS T)

(TOGGLE IPLUS-INEG7-OFF IPLUS-INEG7 T)

(TOGGLE IPLUS-LIST-APPEND-OFF IPLUS-LIST-APPEND T)

(TOGGLE EVAL$-IPLUS-LIST-DELETE-OFF EVAL$-IPLUS-LIST-DELETE T)

(TOGGLE G*1*CANCEL-IPLUS-OFF *1*CANCEL-IPLUS T)

(TOGGLE EVAL$-LIST-APPEND-OFF EVAL$-LIST-APPEND T)

(TOGGLE INTEGERP-IPLUS-LIST-OFF INTEGERP-IPLUS-LIST T)

(TOGGLE IPLUS-LIST-OFF IPLUS-LIST T)

(TOGGLE G*1*IPLUS-LIST-OFF *1*IPLUS-LIST T)

(TOGGLE G*1*IPLUS-TREE-OFF *1*IPLUS-TREE T)

(TOGGLE IPLUS-TREE-REC-OFF IPLUS-TREE-REC T)

(TOGGLE G*1*IPLUS-TREE-REC-OFF *1*IPLUS-TREE-REC T)

(TOGGLE IPLUS-FRINGE-OFF IPLUS-FRINGE T)

(TOGGLE G*1*IPLUS-FRINGE-OFF *1*IPLUS-FRINGE T)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-OFF CORRECTNESS-OF-CANCEL-INEG T)

(TOGGLE IPLUS-X-Y-INEG-X-OFF IPLUS-X-Y-INEG-X T)

(TOGGLE IPLUS-INEG4-OFF IPLUS-INEG4 T)

(TOGGLE IPLUS-INEG3-OFF IPLUS-INEG3 T)

(TOGGLE EVAL$-CANCEL-INEG-AUX-IS-ITS-FN-OFF EVAL$-CANCEL-INEG-AUX-IS-ITS-FN T)

(TOGGLE EVAL$-CANCEL-INEG-AUX-FN-OFF EVAL$-CANCEL-INEG-AUX-FN T)

(TOGGLE G*1*EVAL$-CANCEL-INEG-AUX-FN-OFF *1*EVAL$-CANCEL-INEG-AUX-FN T)

(TOGGLE EVAL$-OTHER-OFF EVAL$-OTHER T)

(TOGGLE EVAL$-LITATOM-OFF EVAL$-LITATOM T)

(TOGGLE EVAL$-LIST-NLISTP-OFF EVAL$-LIST-NLISTP T)

(TOGGLE EVAL$-LIST-CONS-OFF EVAL$-LIST-CONS T)

(TOGGLE CANCEL-INEG-OFF CANCEL-INEG T)

(TOGGLE G*1*CANCEL-INEG-OFF *1*CANCEL-INEG T)

(TOGGLE CANCEL-INEG-AUX-OFF CANCEL-INEG-AUX T)

(TOGGLE G*1*CANCEL-INEG-AUX-OFF *1*CANCEL-INEG-AUX T)

(TOGGLE IDIFFERENCE-FIX-INT2-OFF IDIFFERENCE-FIX-INT2 T)

(TOGGLE IDIFFERENCE-FIX-INT1-OFF IDIFFERENCE-FIX-INT1 T)

(TOGGLE IPLUS-FIX-INT2-OFF IPLUS-FIX-INT2 T)

(TOGGLE IPLUS-FIX-INT1-OFF IPLUS-FIX-INT1 T)

(TOGGLE IPLUS-INEG2-OFF IPLUS-INEG2 T)

(TOGGLE IPLUS-INEG1-OFF IPLUS-INEG1 T)

(TOGGLE IPLUS-CANCELLATION-2-OFF IPLUS-CANCELLATION-2 T)

(TOGGLE IPLUS-CANCELLATION-1-OFF IPLUS-CANCELLATION-1 T)

(TOGGLE ASSOCIATIVITY-OF-IPLUS-OFF ASSOCIATIVITY-OF-IPLUS T)

(TOGGLE COMMUTATIVITY-OF-IPLUS-OFF COMMUTATIVITY-OF-IPLUS T)

(TOGGLE COMMUTATIVITY2-OF-IPLUS-OFF COMMUTATIVITY2-OF-IPLUS T)

(TOGGLE IPLUS-0-RIGHT-OFF IPLUS-0-RIGHT T)

(TOGGLE IPLUS-0-LEFT-OFF IPLUS-0-LEFT T)

(TOGGLE INEG-0-OFF INEG-0 T)

(TOGGLE INEG-FIX-INT-OFF INEG-FIX-INT T)

(TOGGLE INEG-INEG-OFF INEG-INEG T)

(TOGGLE INEG-IPLUS-OFF INEG-IPLUS T)

(TOGGLE FIX-INT-ITIMES-OFF FIX-INT-ITIMES T)

(TOGGLE FIX-INT-IABS-OFF FIX-INT-IABS T)

(TOGGLE FIX-INT-INEG-OFF FIX-INT-INEG T)

(TOGGLE FIX-INT-IDIFFERENCE-OFF FIX-INT-IDIFFERENCE T)

(TOGGLE FIX-INT-IPLUS-OFF FIX-INT-IPLUS T)

(TOGGLE FIX-INT-FIX-INT-OFF FIX-INT-FIX-INT T)

(TOGGLE FIX-INT-REMOVER-OFF FIX-INT-REMOVER T)

(TOGGLE INTEGERP-ITIMES-OFF INTEGERP-ITIMES T)

(TOGGLE INTEGERP-IABS-OFF INTEGERP-IABS T)

(TOGGLE INTEGERP-INEG-OFF INTEGERP-INEG T)

(TOGGLE INTEGERP-IDIFFERENCE-OFF INTEGERP-IDIFFERENCE T)

(TOGGLE INTEGERP-IPLUS-OFF INTEGERP-IPLUS T)

(TOGGLE INTEGERP-FIX-INT-OFF INTEGERP-FIX-INT T)

(TOGGLE G*1*IREM-OFF *1*IREM T)

(TOGGLE G*1*IQUO-OFF *1*IQUO T)

(TOGGLE G*1*IMOD-OFF *1*IMOD T)

(TOGGLE G*1*IDIV-OFF *1*IDIV T)

(TOGGLE G*1*IREMAINDER-OFF *1*IREMAINDER T)

(TOGGLE G*1*IQUOTIENT-OFF *1*IQUOTIENT T)

(TOGGLE G*1*ITIMES-OFF *1*ITIMES T)

(TOGGLE G*1*IABS-OFF *1*IABS T)

(TOGGLE IDIFFERENCE-OFF IDIFFERENCE T)

(TOGGLE G*1*IDIFFERENCE-OFF *1*IDIFFERENCE T)

(TOGGLE G*1*INEG-OFF *1*INEG T)

(TOGGLE G*1*IPLUS-OFF *1*IPLUS T)

(TOGGLE ILEQ-OFF ILEQ T)

(TOGGLE G*1*ILEQ-OFF *1*ILEQ T)

(TOGGLE G*1*ILESSP-OFF *1*ILESSP T)

(TOGGLE IZEROP-OFF IZEROP T)

(TOGGLE G*1*IZEROP-OFF *1*IZEROP T)

(TOGGLE G*1*FIX-INT-OFF *1*FIX-INT T)

(TOGGLE G*1*INTEGERP-OFF *1*INTEGERP T)

(TOGGLE GCD-IDEMPOTENCE-OFF GCD-IDEMPOTENCE T)

(TOGGLE GCD-X-X-OFF GCD-X-X T)

(TOGGLE COMMUTATIVITY2-OF-GCD-OFF COMMUTATIVITY2-OF-GCD T)

(TOGGLE COMMUTATIVITY2-OF-GCD-ZERO-CASE-OFF COMMUTATIVITY2-OF-GCD-ZERO-CASE T)

(TOGGLE ASSOCIATIVITY-OF-GCD-OFF ASSOCIATIVITY-OF-GCD T)

(TOGGLE ASSOCIATIVITY-OF-GCD-ZERO-CASE-OFF ASSOCIATIVITY-OF-GCD-ZERO-CASE T)

(TOGGLE COMMON-DIVISOR-DIVIDES-GCD-OFF COMMON-DIVISOR-DIVIDES-GCD T)

(TOGGLE GCD-IS-THE-GREATEST-OFF GCD-IS-THE-GREATEST T)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-OFF DISTRIBUTIVITY-OF-TIMES-OVER-GCD T)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF-OFF
        DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF T)

(TOGGLE REMAINDER-GCD-OFF REMAINDER-GCD T)

(TOGGLE GCD-PLUS-INSTANCE-OFF GCD-PLUS-INSTANCE T)

(TOGGLE GCD-PLUS-OFF GCD-PLUS T)

(TOGGLE GCD-PLUS-PROOF-OFF GCD-PLUS-PROOF T)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-OFF GCD-PLUS-INSTANCE-TEMP T)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-PROOF-OFF GCD-PLUS-INSTANCE-TEMP-PROOF T)

(TOGGLE LESSP-GCD-OFF LESSP-GCD T)

(TOGGLE EQUAL-GCD-0-OFF EQUAL-GCD-0 T)

(TOGGLE GCD-1-OFF GCD-1 T)

(TOGGLE GCD-0-OFF GCD-0 T)

(TOGGLE SINGLE-NUMBER-INDUCTION-OFF SINGLE-NUMBER-INDUCTION T)

(TOGGLE G*1*SINGLE-NUMBER-INDUCTION-OFF *1*SINGLE-NUMBER-INDUCTION T)

(TOGGLE COMMUTATIVITY-OF-GCD-OFF COMMUTATIVITY-OF-GCD T)

(TOGGLE LOG-EXP-OFF LOG-EXP T)

(TOGGLE LOG-TIMES-EXP-OFF LOG-TIMES-EXP T)

(TOGGLE LOG-TIMES-EXP-PROOF-OFF LOG-TIMES-EXP-PROOF T)

(TOGGLE LOG-TIMES-OFF LOG-TIMES T)

(TOGGLE LOG-TIMES-PROOF-OFF LOG-TIMES-PROOF T)

(TOGGLE LOG-QUOTIENT-EXP-OFF LOG-QUOTIENT-EXP T)

(TOGGLE LOG-QUOTIENT-TIMES-OFF LOG-QUOTIENT-TIMES T)

(TOGGLE LOG-QUOTIENT-TIMES-PROOF-OFF LOG-QUOTIENT-TIMES-PROOF T)

(TOGGLE LOG-QUOTIENT-OFF LOG-QUOTIENT T)

(TOGGLE LEQ-LOG-LOG-OFF LEQ-LOG-LOG T)

(TOGGLE DOUBLE-LOG-INDUCTION-OFF DOUBLE-LOG-INDUCTION T)

(TOGGLE G*1*DOUBLE-LOG-INDUCTION-OFF *1*DOUBLE-LOG-INDUCTION T)

(TOGGLE LOG-1-OFF LOG-1 T)

(TOGGLE LOG-0-OFF LOG-0 T)

(TOGGLE EQUAL-LOG-0-OFF EQUAL-LOG-0 T)

(TOGGLE EXP-DIFFERENCE-OFF EXP-DIFFERENCE T)

(TOGGLE EQUAL-EXP-1-OFF EQUAL-EXP-1 T)

(TOGGLE EQUAL-EXP-0-OFF EQUAL-EXP-0 T)

(TOGGLE EXP-EXP-OFF EXP-EXP T)

(TOGGLE EXP-TIMES-OFF EXP-TIMES T)

(TOGGLE EXP-0-ARG2-OFF EXP-0-ARG2 T)

(TOGGLE EXP-1-ARG1-OFF EXP-1-ARG1 T)

(TOGGLE EXP-0-ARG1-OFF EXP-0-ARG1 T)

(TOGGLE EXP-PLUS-OFF EXP-PLUS T)

(TOGGLE EXP-ADD1-OFF EXP-ADD1 T)

(TOGGLE EXP-ZERO-OFF EXP-ZERO T)

(TOGGLE QUOTIENT-EXP-OFF QUOTIENT-EXP T)

(TOGGLE REMAINDER-EXP-EXP-OFF REMAINDER-EXP-EXP T)

(TOGGLE DOUBLE-NUMBER-INDUCTION-OFF DOUBLE-NUMBER-INDUCTION T)

(TOGGLE G*1*DOUBLE-NUMBER-INDUCTION-OFF *1*DOUBLE-NUMBER-INDUCTION T)

(TOGGLE REMAINDER-EXP-OFF REMAINDER-EXP T)

(TOGGLE GCD-OFF GCD T)

(TOGGLE G*1*GCD-OFF *1*GCD T)

(TOGGLE LOG-OFF LOG T)

(TOGGLE G*1*LOG-OFF *1*LOG T)

(TOGGLE EXP-OFF EXP T)

(TOGGLE G*1*EXP-OFF *1*EXP T)

(TOGGLE CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES-OFF
        CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES T)

(TOGGLE CANCEL-QUOTIENT-TIMES-OFF CANCEL-QUOTIENT-TIMES T)

(TOGGLE G*1*CANCEL-QUOTIENT-TIMES-OFF *1*CANCEL-QUOTIENT-TIMES T)

(TOGGLE LESSP-QUOTIENT-OFF LESSP-QUOTIENT T)

(TOGGLE QUOTIENT-X-X-OFF QUOTIENT-X-X T)

(TOGGLE QUOTIENT-1-ARG1-OFF QUOTIENT-1-ARG1 T)

(TOGGLE QUOTIENT-1-ARG1-CASESPLIT-OFF QUOTIENT-1-ARG1-CASESPLIT T)

(TOGGLE QUOTIENT-1-ARG2-OFF QUOTIENT-1-ARG2 T)

(TOGGLE LEQ-QUOTIENT-OFF LEQ-QUOTIENT T)

(TOGGLE QUOTIENT-QUOTIENT-OFF QUOTIENT-QUOTIENT T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-INSTANCE-OFF
        QUOTIENT-PLUS-TIMES-TIMES-INSTANCE T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-OFF QUOTIENT-PLUS-TIMES-TIMES T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-PROOF-OFF QUOTIENT-PLUS-TIMES-TIMES-PROOF T)

(TOGGLE QUOTIENT-PLUS-FACT-OFF QUOTIENT-PLUS-FACT T)

(TOGGLE QUOTIENT-REMAINDER-INSTANCE-OFF QUOTIENT-REMAINDER-INSTANCE T)

(TOGGLE QUOTIENT-REMAINDER-OFF QUOTIENT-REMAINDER T)

(TOGGLE QUOTIENT-REMAINDER-TIMES-OFF QUOTIENT-REMAINDER-TIMES T)

(TOGGLE QUOTIENT-DIFFERENCE3-OFF QUOTIENT-DIFFERENCE3 T)

(TOGGLE QUOTIENT-DIFFERENCE2-OFF QUOTIENT-DIFFERENCE2 T)

(TOGGLE QUOTIENT-LESSP-ARG1-OFF QUOTIENT-LESSP-ARG1 T)

(TOGGLE QUOTIENT-DIFFERENCE1-OFF QUOTIENT-DIFFERENCE1 T)

(TOGGLE QUOTIENT-TIMES-TIMES-PROOF-OFF QUOTIENT-TIMES-TIMES-PROOF T)

(TOGGLE QUOTIENT-TIMES-INSTANCE-OFF QUOTIENT-TIMES-INSTANCE T)

(TOGGLE QUOTIENT-TIMES-OFF QUOTIENT-TIMES T)

(TOGGLE QUOTIENT-TIMES-PROOF-OFF QUOTIENT-TIMES-PROOF T)

(TOGGLE QUOTIENT-TIMES-INSTANCE-TEMP-PROOF-OFF
        QUOTIENT-TIMES-INSTANCE-TEMP-PROOF T)

(TOGGLE QUOTIENT-PLUS-OFF QUOTIENT-PLUS T)

(TOGGLE QUOTIENT-PLUS-PROOF-OFF QUOTIENT-PLUS-PROOF T)

(TOGGLE QUOTIENT-SUB1-OFF QUOTIENT-SUB1 T)

(TOGGLE EQUAL-QUOTIENT-0-OFF EQUAL-QUOTIENT-0 T)

(TOGGLE QUOTIENT-ADD1-OFF QUOTIENT-ADD1 T)

(TOGGLE QUOTIENT-ZERO-OFF QUOTIENT-ZERO T)

(TOGGLE QUOTIENT-OF-NON-NUMBER-OFF QUOTIENT-OF-NON-NUMBER T)

(TOGGLE QUOTIENT-NOOP-OFF QUOTIENT-NOOP T)

(TOGGLE TRANSITIVITY-OF-DIVIDES-OFF TRANSITIVITY-OF-DIVIDES T)

(TOGGLE REMAINDER-X-X-OFF REMAINDER-X-X T)

(TOGGLE REMAINDER-1-ARG2-OFF REMAINDER-1-ARG2 T)

(TOGGLE REMAINDER-1-ARG1-OFF REMAINDER-1-ARG1 T)

(TOGGLE REMAINDER-REMAINDER-OFF REMAINDER-REMAINDER T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-INSTANCE-OFF
        REMAINDER-PLUS-TIMES-TIMES-INSTANCE T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-OFF REMAINDER-PLUS-TIMES-TIMES T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-PROOF-OFF REMAINDER-PLUS-TIMES-TIMES-PROOF T)

(TOGGLE REMAINDER-PLUS-FACT-OFF REMAINDER-PLUS-FACT T)

(TOGGLE REMAINDER-DIFFERENCE2-OFF REMAINDER-DIFFERENCE2 T)

(TOGGLE DOUBLE-REMAINDER-INDUCTION-OFF DOUBLE-REMAINDER-INDUCTION T)

(TOGGLE G*1*DOUBLE-REMAINDER-INDUCTION-OFF *1*DOUBLE-REMAINDER-INDUCTION T)

(TOGGLE REMAINDER-DIFFERENCE1-OFF REMAINDER-DIFFERENCE1 T)

(TOGGLE REMAINDER-TIMES2-INSTANCE-OFF REMAINDER-TIMES2-INSTANCE T)

(TOGGLE REMAINDER-TIMES2-OFF REMAINDER-TIMES2 T)

(TOGGLE REMAINDER-TIMES2-PROOF-OFF REMAINDER-TIMES2-PROOF T)

(TOGGLE REMAINDER-TIMES-TIMES-PROOF-OFF REMAINDER-TIMES-TIMES-PROOF T)

(TOGGLE REMAINDER-TIMES1-INSTANCE-OFF REMAINDER-TIMES1-INSTANCE T)

(TOGGLE REMAINDER-TIMES1-INSTANCE-PROOF-OFF REMAINDER-TIMES1-INSTANCE-PROOF T)

(TOGGLE REMAINDER-TIMES1-OFF REMAINDER-TIMES1 T)

(TOGGLE REMAINDER-TIMES1-PROOF-OFF REMAINDER-TIMES1-PROOF T)

(TOGGLE EQUAL-REMAINDER-PLUS-REMAINDER-PROOF-OFF
        EQUAL-REMAINDER-PLUS-REMAINDER-PROOF T)

(TOGGLE EQUAL-REMAINDER-PLUS-0-OFF EQUAL-REMAINDER-PLUS-0 T)

(TOGGLE EQUAL-REMAINDER-PLUS-0-PROOF-OFF EQUAL-REMAINDER-PLUS-0-PROOF T)

(TOGGLE REMAINDER-PLUS-OFF REMAINDER-PLUS T)

(TOGGLE REMAINDER-PLUS-PROOF-OFF REMAINDER-PLUS-PROOF T)

(TOGGLE REMAINDER-ADD1-OFF REMAINDER-ADD1 T)

(TOGGLE REMAINDER-QUOTIENT-ELIM-OFF REMAINDER-QUOTIENT-ELIM T)

(TOGGLE REMAINDER-ZERO-OFF REMAINDER-ZERO T)

(TOGGLE REMAINDER-OF-NON-NUMBER-OFF REMAINDER-OF-NON-NUMBER T)

(TOGGLE REMAINDER-NOOP-OFF REMAINDER-NOOP T)

(TOGGLE LESSP-REMAINDER-OFF LESSP-REMAINDER T)

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-TIMES-OFF CORRECTNESS-OF-CANCEL-EQUAL-TIMES
        T)

(TOGGLE CANCEL-EQUAL-TIMES-OFF CANCEL-EQUAL-TIMES T)

(TOGGLE G*1*CANCEL-EQUAL-TIMES-OFF *1*CANCEL-EQUAL-TIMES T)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-TIMES-OFF CORRECTNESS-OF-CANCEL-LESSP-TIMES
        T)

(TOGGLE CANCEL-LESSP-TIMES-OFF CANCEL-LESSP-TIMES T)

(TOGGLE G*1*CANCEL-LESSP-TIMES-OFF *1*CANCEL-LESSP-TIMES T)

(TOGGLE INFER-EQUALITY-FROM-NOT-LESSP-OFF INFER-EQUALITY-FROM-NOT-LESSP T)

(TOGGLE LESSP-TIMES-ARG1-OFF LESSP-TIMES-ARG1 T)

(TOGGLE EVAL$-EQUAL-OFF1 EVAL$-EQUAL T)

(TOGGLE AND-NOT-ZEROP-TREE-OFF AND-NOT-ZEROP-TREE T)

(TOGGLE G*1*AND-NOT-ZEROP-TREE-OFF *1*AND-NOT-ZEROP-TREE T)

(TOGGLE OR-ZEROP-TREE-OFF OR-ZEROP-TREE T)

(TOGGLE G*1*OR-ZEROP-TREE-OFF *1*OR-ZEROP-TREE T)

(TOGGLE TIMES-FRINGE-OFF TIMES-FRINGE T)

(TOGGLE G*1*TIMES-FRINGE-OFF *1*TIMES-FRINGE T)

(TOGGLE TIMES-TREE-OFF TIMES-TREE T)

(TOGGLE G*1*TIMES-TREE-OFF *1*TIMES-TREE T)

(TOGGLE LESSP-1-TIMES-OFF LESSP-1-TIMES T)

(TOGGLE LESSP-PLUS-TIMES2-OFF LESSP-PLUS-TIMES2 T)

(TOGGLE LESSP-PLUS-TIMES1-OFF LESSP-PLUS-TIMES1 T)

(TOGGLE LESSP-PLUS-TIMES-PROOF-OFF LESSP-PLUS-TIMES-PROOF T)

(TOGGLE LESSP-TIMES-CANCELLATION-PROOF-OFF LESSP-TIMES-CANCELLATION-PROOF T)

(TOGGLE LESSP-TIMES3-OFF LESSP-TIMES3 T)

(TOGGLE LESSP-TIMES3-PROOF2-OFF LESSP-TIMES3-PROOF2 T)

(TOGGLE LESSP-TIMES3-PROOF1-OFF LESSP-TIMES3-PROOF1 T)

(TOGGLE LESSP-TIMES2-OFF LESSP-TIMES2 T)

(TOGGLE LESSP-TIMES2-PROOF-OFF LESSP-TIMES2-PROOF T)

(TOGGLE LESSP-TIMES1-OFF LESSP-TIMES1 T)

(TOGGLE LESSP-TIMES1-PROOF-OFF LESSP-TIMES1-PROOF T)

(TOGGLE TIMES-1-ARG1-OFF TIMES-1-ARG1 T)

(TOGGLE TIMES-QUOTIENT-OFF TIMES-QUOTIENT T)

(TOGGLE TIMES-QUOTIENT-PROOF-OFF TIMES-QUOTIENT-PROOF T)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-OFF TIMES-DISTRIBUTES-OVER-DIFFERENCE
        T)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF-OFF
        TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF T)

(TOGGLE ASSOCIATIVITY-OF-TIMES-OFF ASSOCIATIVITY-OF-TIMES T)

(TOGGLE COMMUTATIVITY2-OF-TIMES-OFF COMMUTATIVITY2-OF-TIMES T)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-OFF TIMES-DISTRIBUTES-OVER-PLUS T)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-PROOF-OFF TIMES-DISTRIBUTES-OVER-PLUS-PROOF
        T)

(TOGGLE COMMUTATIVITY-OF-TIMES-OFF COMMUTATIVITY-OF-TIMES T)

(TOGGLE TIMES-ADD1-OFF TIMES-ADD1 T)

(TOGGLE TIMES-ZERO-OFF TIMES-ZERO T)

(TOGGLE EQUAL-SUB1-0-OFF EQUAL-SUB1-0 T)

(TOGGLE EQUAL-TIMES-1-OFF EQUAL-TIMES-1 T)

(TOGGLE EQUAL-TIMES-0-OFF EQUAL-TIMES-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-PLUS-OFF CORRECTNESS-OF-CANCEL-LESSP-PLUS T)

(TOGGLE CANCEL-LESSP-PLUS-OFF CANCEL-LESSP-PLUS T)

(TOGGLE G*1*CANCEL-LESSP-PLUS-OFF *1*CANCEL-LESSP-PLUS T)

(TOGGLE DIFFERENCE-X-X-OFF DIFFERENCE-X-X T)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG2-OFF DIFFERENCE-DIFFERENCE-ARG2 T)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG1-OFF DIFFERENCE-DIFFERENCE-ARG1 T)

(TOGGLE DIFFERENCE-SUB1-ARG2-OFF DIFFERENCE-SUB1-ARG2 T)

(TOGGLE DIFFERENCE-ADD1-ARG2-OFF DIFFERENCE-ADD1-ARG2 T)

(TOGGLE DIFFERENCE-LEQ-ARG1-OFF DIFFERENCE-LEQ-ARG1 T)

(TOGGLE DIFFERENCE-ELIM-OFF DIFFERENCE-ELIM T)

(TOGGLE CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS-OFF
        CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS T)

(TOGGLE CANCEL-DIFFERENCE-PLUS-OFF CANCEL-DIFFERENCE-PLUS T)

(TOGGLE G*1*CANCEL-DIFFERENCE-PLUS-OFF *1*CANCEL-DIFFERENCE-PLUS T)

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-PLUS-OFF CORRECTNESS-OF-CANCEL-EQUAL-PLUS T)

(TOGGLE CANCEL-EQUAL-PLUS-OFF CANCEL-EQUAL-PLUS T)

(TOGGLE G*1*CANCEL-EQUAL-PLUS-OFF *1*CANCEL-EQUAL-PLUS T)

(TOGGLE EVAL$-QUOTE-OFF1 EVAL$-QUOTE T)

(TOGGLE PLUS-TREE-OFF PLUS-TREE T)

(TOGGLE G*1*PLUS-TREE-OFF *1*PLUS-TREE T)

(TOGGLE PLUS-FRINGE-OFF PLUS-FRINGE T)

(TOGGLE G*1*PLUS-FRINGE-OFF *1*PLUS-FRINGE T)

(TOGGLE DIFF-DIFF-ARG2-OFF DIFF-DIFF-ARG2 T)

(TOGGLE DIFF-DIFF-ARG1-OFF DIFF-DIFF-ARG1 T)

(TOGGLE DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF-OFF
        DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF T)

(TOGGLE DIFFERENCE-PLUS-CANCELLATION-PROOF-OFF
        DIFFERENCE-PLUS-CANCELLATION-PROOF T)

(TOGGLE PLUS-DIFFERENCE-ARG2-OFF PLUS-DIFFERENCE-ARG2 T)

(TOGGLE PLUS-DIFFERENCE-ARG1-OFF PLUS-DIFFERENCE-ARG1 T)

(TOGGLE ASSOCIATIVITY-OF-PLUS-OFF ASSOCIATIVITY-OF-PLUS T)

(TOGGLE PLUS-ADD1-ARG2-OFF PLUS-ADD1-ARG2 T)

(TOGGLE PLUS-ADD1-ARG1-OFF PLUS-ADD1-ARG1 T)

(TOGGLE PLUS-ZERO-ARG2-OFF PLUS-ZERO-ARG2 T)

(TOGGLE COMMUTATIVITY2-OF-PLUS-OFF COMMUTATIVITY2-OF-PLUS T)

(TOGGLE COMMUTATIVITY-OF-PLUS-OFF COMMUTATIVITY-OF-PLUS T)

(TOGGLE EQUAL-DIFFERENCE-0-OFF EQUAL-DIFFERENCE-0 T)

(TOGGLE EQUAL-PLUS-0-OFF EQUAL-PLUS-0 T)

(TOGGLE MEMBER-BAGINT-OFF MEMBER-BAGINT T)

(TOGGLE OCCURRENCES-BAGDIFF-OFF OCCURRENCES-BAGDIFF T)

(TOGGLE OCCURRENCES-BAGINT-OFF OCCURRENCES-BAGINT T)

(TOGGLE SUBBAGP-BAGINT2-OFF SUBBAGP-BAGINT2 T)

(TOGGLE SUBBAGP-BAGINT1-OFF SUBBAGP-BAGINT1 T)

(TOGGLE SUBBAGP-CDR2-OFF SUBBAGP-CDR2 T)

(TOGGLE SUBBAGP-CDR1-OFF SUBBAGP-CDR1 T)

(TOGGLE SUBBAGP-DELETE-OFF SUBBAGP-DELETE T)

(TOGGLE BAGDIFF-DELETE-OFF BAGDIFF-DELETE T)

(TOGGLE MEMBER-BAGDIFF-OFF MEMBER-BAGDIFF T)

(TOGGLE OCCURRENCES-DELETE-OFF OCCURRENCES-DELETE T)

(TOGGLE MEMBER-DELETE-IMPLIES-MEMBERSHIP-OFF MEMBER-DELETE-IMPLIES-MEMBERSHIP T)

(TOGGLE MEMBER-DELETE-OFF MEMBER-DELETE T)

(TOGGLE MEMBER-NON-LIST-OFF MEMBER-NON-LIST T)

(TOGGLE EQUAL-OCCURRENCES-ZERO-OFF EQUAL-OCCURRENCES-ZERO T)

(TOGGLE DELETE-DELETE-OFF DELETE-DELETE T)

(TOGGLE DELETE-NON-MEMBER-OFF DELETE-NON-MEMBER T)

(TOGGLE SUBBAGP-OFF SUBBAGP T)

(TOGGLE G*1*SUBBAGP-OFF *1*SUBBAGP T)

(TOGGLE OCCURRENCES-OFF OCCURRENCES T)

(TOGGLE G*1*OCCURRENCES-OFF *1*OCCURRENCES T)

(TOGGLE BAGINT-OFF BAGINT T)

(TOGGLE G*1*BAGINT-OFF *1*BAGINT T)

(TOGGLE BAGDIFF-OFF BAGDIFF T)

(TOGGLE G*1*BAGDIFF-OFF *1*BAGDIFF T)

(TOGGLE DELETE-OFF DELETE T)

(TOGGLE G*1*DELETE-OFF *1*DELETE T)

(DEFN IF* (A B C) (IF A B C))

(TOGGLE IF*-OFF IF* T)

(DEFN OR* (A B) (IF* A T (IF* B T F)))

(TOGGLE OR*-OFF OR* T)

(DEFN AND*
      (A B)
      (IF* A (IF* B T F) F))

(TOGGLE AND*-OFF AND* T)

(DEFN NOT* (A) (IF* A F T))

(TOGGLE NOT*-OFF NOT* T)

(DEFTHEORY PROP*-THEORY
           (OR* AND* NOT*))

(PROVE-LEMMA SIMPLIFY-IF*
             (REWRITE)
             (AND (IMPLIES C (EQUAL (IF* C A B) A))
                  (IMPLIES (NOT C)
                           (EQUAL (IF* C A B) B)))
             ((ENABLE IF*)))

(PROVE-LEMMA IF*-C-X-X
             (REWRITE)
             (EQUAL (IF* C X X) X)
             ((ENABLE IF*)))

(PROVE-LEMMA IF*-CONS
             (REWRITE)
             (EQUAL (IF* A (CONS B C) (CONS D E))
                    (CONS (IF* A B D) (IF* A C E)))
             ((ENABLE IF*)))

(PROVE-LEMMA REWRITE-NOT*
             (REWRITE)
             (AND (IMPLIES X (EQUAL (NOT* X) F))
                  (IMPLIES (NOT X) (EQUAL (NOT* X) T)))
             ((ENABLE IF* NOT*)))

(PROVE-LEMMA REWRITE-AND*
             (REWRITE)
             (AND (EQUAL (AND* F X) F)
                  (EQUAL (AND* X F) F)
                  (IMPLIES Y
                           (AND (EQUAL (AND* Y X) (IF* X T F))
                                (EQUAL (AND* X Y) (IF* X T F)))))
             ((ENABLE IF* AND*)))

(PROVE-LEMMA REWRITE-OR*
             (REWRITE)
             (AND (EQUAL (OR* F X) (IF* X T F))
                  (EQUAL (OR* X F) (IF* X T F))
                  (IMPLIES Y
                           (AND (EQUAL (OR* Y X) T)
                                (EQUAL (OR* X Y) T))))
             ((ENABLE IF* OR*)))

(PROVE-LEMMA EXPAND-*-CONNECTIVES
             (REWRITE)
             (AND (EQUAL (IF* C A B) (IF C A B))
                  (EQUAL (OR* A B)
                         (COND (A T) (B T) (T F)))
                  (EQUAL (AND* A B) (IF A (IF B T F) F))
                  (EQUAL (NOT* A) (NOT A)))
             ((ENABLE IF* AND* OR* NOT*)))

(TOGGLE EXPAND-*-CONNECTIVES-OFF EXPAND-*-CONNECTIVES T)

(PROVE-LEMMA CAR-CDR-IF-CONS
             (REWRITE)
             (AND (EQUAL (CAR (IF X (CONS A B) (CONS C D)))
                         (IF X A C))
                  (EQUAL (CDR (IF X (CONS A B) (CONS C D)))
                         (IF X B D))))

(PROVE-LEMMA OUR-CAR-CDR-ELIM
             (REWRITE)
             (EQUAL (EQUAL L (CONS (CAR L) X))
                    (AND (LISTP L) (EQUAL X (CDR L)))))

(TOGGLE OUR-CAR-CDR-ELIM-OFF OUR-CAR-CDR-ELIM T)

(TOGGLE PLUS-OFF PLUS T)

(PROVE-LEMMA PLUS-0
             (REWRITE)
             (AND (IMPLIES (ZEROP ZERO)
                           (EQUAL (PLUS X ZERO) (FIX X)))
                  (IMPLIES (ZEROP ZERO)
                           (EQUAL (PLUS ZERO X) (FIX X))))
             ((ENABLE PLUS)))

(PROVE-LEMMA PLUS-ADD1
             (REWRITE)
             (AND (EQUAL (PLUS (ADD1 X) Y)
                         (ADD1 (PLUS X Y)))
                  (EQUAL (PLUS X (ADD1 Y))
                         (ADD1 (PLUS X Y)))))

(PROVE-LEMMA PLUS-BOTTOM
             (REWRITE)
             (EQUAL (EQUAL (PLUS A B) 0)
                    (AND (ZEROP A) (ZEROP B))))

(PROVE-LEMMA PLUS-ADD1-SUB1
             (REWRITE)
             (AND (IMPLIES (NOT (ZEROP N))
                           (EQUAL (PLUS (SUB1 N) (ADD1 M))
                                  (PLUS N M)))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (PLUS (ADD1 M) (SUB1 N))
                                  (PLUS M N)))))

(TOGGLE DIFFERENCE-OFF DIFFERENCE T)

(PROVE-LEMMA DIFFERENCE-X-1
             (REWRITE)
             (EQUAL (DIFFERENCE X 1) (SUB1 X))
             ((ENABLE DIFFERENCE)))

(PROVE-LEMMA OUR-DIFFERENCE-X-X
             (REWRITE)
             (EQUAL (DIFFERENCE X X) 0)
             ((ENABLE DIFFERENCE)))

(PROVE-LEMMA OUR-EQUAL-DIFFERENCE-0
             (REWRITE)
             (EQUAL (EQUAL (DIFFERENCE X Y) 0)
                    (IF (LESSP Y X) F T))
             ((ENABLE DIFFERENCE)))

(PROVE-LEMMA DIFFERENCE-0
             (REWRITE)
             (IMPLIES (ZEROP Z)
                      (EQUAL (DIFFERENCE X Z) (FIX X)))
             ((ENABLE DIFFERENCE)))

(PROVE-LEMMA DIFFERENCE-ADD1-ADD1
             (REWRITE)
             (EQUAL (DIFFERENCE (ADD1 X) (ADD1 Y))
                    (DIFFERENCE X Y))
             ((ENABLE DIFFERENCE)))

(PROVE-LEMMA NOT-LESSP-DIFFERENCE
             (REWRITE)
             (EQUAL (LESSP X (DIFFERENCE X Y)) F))

(PROVE-LEMMA LESSP-DIFFERENCE=0
             (REWRITE)
             (IMPLIES (IF (LESSP Y X) F T)
                      (EQUAL (DIFFERENCE X Y) 0)))

(PROVE-LEMMA TIMES-BOTTOM
             (REWRITE)
             (EQUAL (EQUAL (TIMES X Y) 0)
                    (OR (ZEROP X) (ZEROP Y))))

(PROVE-LEMMA TIMES-1
             (REWRITE)
             (AND (EQUAL (TIMES A 1) (FIX A))
                  (EQUAL (TIMES 1 A) (FIX A))))

(PROVE-LEMMA TIMES-ADD1-AGAIN
             (REWRITE)
             (EQUAL (TIMES A (ADD1 B))
                    (PLUS A (TIMES A B))))

(PROVE-LEMMA TIMES-COMMUTES
             (REWRITE)
             (EQUAL (TIMES A B) (TIMES B A))
             ((ENABLE PLUS)))

(PROVE-LEMMA QUOTIENT-LESSP
             (REWRITE)
             (IMPLIES (AND (LESSP 1 BASE) (NOT (ZEROP N)))
                      (LESSP (QUOTIENT N BASE) N)))

(PROVE-LEMMA ZEROP-QUOTIENT
             (REWRITE)
             (EQUAL (EQUAL (QUOTIENT N M) 0)
                    (OR (ZEROP N) (ZEROP M) (LESSP N M))))

(PROVE-LEMMA LESSP-X-X
             (REWRITE)
             (EQUAL (LESSP X X) F)
             ((ENABLE LESSP)))

(PROVE-LEMMA LESSP-SUB1-X-Y-CROCK
             (REWRITE)
             (IMPLIES (EQUAL X Y)
                      (EQUAL (LESSP (SUB1 X) Y)
                             (NOT (ZEROP X))))
             ((ENABLE LESSP)))

(PROVE-LEMMA LESSP-SUB1-X-X
             (REWRITE)
             (EQUAL (LESSP (SUB1 X) X)
                    (NOT (ZEROP X)))
             ((ENABLE LESSP)))

(PROVE-LEMMA LESSP-X-1
             (REWRITE)
             (EQUAL (LESSP X 1) (ZEROP X))
             ((ENABLE LESSP)))

(PROVE-LEMMA LEQ-LESSP-DIFFERENCE
             (REWRITE)
             (IMPLIES (AND (IF (LESSP Y X) F T)
                           (NOT (ZEROP Z))
                           (NOT (ZEROP Y)))
                      (EQUAL (LESSP (DIFFERENCE X Z) Y) T))
             ((ENABLE DIFFERENCE)))

(TOGGLE APPEND-OFF APPEND T)

(DEFN APPEND5
      (A B C D E)
      (APPEND A
              (APPEND B (APPEND C (APPEND D E)))))

(DEFN APPEND6
      (A B C D E G)
      (APPEND A
              (APPEND B
                      (APPEND C (APPEND D (APPEND E G))))))

(DEFN APPEND7
      (A B C D E G H)
      (APPEND A
              (APPEND B
                      (APPEND C
                              (APPEND D (APPEND E (APPEND G H)))))))

(DEFN APPEND8
      (A B C D E G H I)
      (APPEND A
              (APPEND B
                      (APPEND C
                              (APPEND D
                                      (APPEND E
                                              (APPEND G (APPEND H I))))))))

(PROVE-LEMMA APPEND-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP A)
                      (EQUAL (APPEND A B) B))
             ((ENABLE APPEND)))

(PROVE-LEMMA APPEND-CONS
             (REWRITE)
             (EQUAL (APPEND (CONS A B) C)
                    (CONS A (APPEND B C)))
             ((ENABLE APPEND)))

(PROVE-LEMMA OUR-MEMBER-APPEND
             (REWRITE)
             (EQUAL (MEMBER A (APPEND B C))
                    (OR (MEMBER A B) (MEMBER A C)))
             ((ENABLE APPEND)))

(PROVE-LEMMA ASSOCIATIVITY-OF-APPEND
             (REWRITE)
             (EQUAL (APPEND (APPEND A B) C)
                    (APPEND A (APPEND B C)))
             ((ENABLE APPEND)))

(PROVE-LEMMA EQUAL-APPEND-X-X
             (REWRITE)
             (EQUAL (EQUAL (APPEND A B) (APPEND A C))
                    (EQUAL B C))
             ((ENABLE APPEND)))

(DEFN PROPERP
      (L)
      (IF (LISTP L)
          (PROPERP (CDR L))
          (EQUAL L NIL)))

(TOGGLE PROPERP-OFF PROPERP T)

(PROVE-LEMMA PROPERP-IF
             (REWRITE)
             (IMPLIES (AND (PROPERP A) (PROPERP B))
                      (PROPERP (IF C A B))))

(PROVE-LEMMA PROPERP-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP L)
                      (EQUAL (PROPERP L) (EQUAL L NIL)))
             ((ENABLE PROPERP)))

(PROVE-LEMMA PROPERP-CONS
             (REWRITE)
             (EQUAL (PROPERP (CONS X Y))
                    (PROPERP Y))
             ((ENABLE PROPERP)))

(PROVE-LEMMA PROPERP-APPEND
             (REWRITE)
             (EQUAL (PROPERP (APPEND A B))
                    (PROPERP B))
             ((ENABLE PROPERP APPEND)))

(PROVE-LEMMA PROPERP-APPEND-NIL
             (REWRITE)
             (IMPLIES (PROPERP A)
                      (EQUAL (APPEND A NIL) A))
             ((ENABLE APPEND)))

(PROVE-LEMMA PROPERP-IF*
             (REWRITE)
             (IMPLIES (AND (PROPERP A) (PROPERP B))
                      (PROPERP (IF* C A B)))
             ((ENABLE IF*)))

(DEFN POSITION
      (X L)
      (COND ((NLISTP L) F)
            ((EQUAL X (CAR L)) 0)
            ((POSITION X (CDR L))
             (ADD1 (POSITION X (CDR L))))
            (T F)))

(TOGGLE POSITION-OFF POSITION T)

(PROVE-LEMMA MEMBER==>POSITION
             (REWRITE)
             (IMPLIES (MEMBER X L) (POSITION X L))
             ((ENABLE MEMBER POSITION)))

(DEFN LENGTH
      (L)
      (IF (LISTP L)
          (ADD1 (LENGTH (CDR L)))
          0))

(TOGGLE LENGTH-OFF LENGTH T)

(PROVE-LEMMA LENGTH-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP L)
                      (EQUAL (LENGTH L) 0))
             ((ENABLE LENGTH)))

(PROVE-LEMMA LENGTH-BOTTOM
             (REWRITE)
             (EQUAL (EQUAL (LENGTH X) 0)
                    (NLISTP X))
             ((ENABLE LENGTH)))

(PROVE-LEMMA LENGTH-1
             (REWRITE)
             (EQUAL (EQUAL (LENGTH A) 1)
                    (AND (LISTP A) (NLISTP (CDR A))))
             ((ENABLE LENGTH)))

(PROVE-LEMMA LENGTH-CONS
             (REWRITE)
             (EQUAL (LENGTH (CONS X Y))
                    (ADD1 (LENGTH Y)))
             ((ENABLE LENGTH)))

(PROVE-LEMMA LENGTH-APPEND
             (REWRITE)
             (EQUAL (LENGTH (APPEND A B))
                    (PLUS (LENGTH A) (LENGTH B)))
             ((ENABLE LENGTH PLUS APPEND)))

(PROVE-LEMMA LENGTH-CDR-LEMMAS
             (REWRITE)
             (AND (EQUAL (EQUAL (LENGTH (CDR X)) (LENGTH X))
                         (NLISTP X))
                  (EQUAL (LESSP (LENGTH (CDR X)) (LENGTH X))
                         (LISTP X)))
             ((ENABLE LESSP LENGTH)))

(PROVE-LEMMA EQUAL-LENGTH-ADD1
             (REWRITE)
             (EQUAL (EQUAL (LENGTH X) (ADD1 Y))
                    (AND (LISTP X)
                         (EQUAL (LENGTH (CDR X)) (FIX Y))))
             ((ENABLE LENGTH)))

(TOGGLE EQUAL-LENGTH-ADD1-OFF EQUAL-LENGTH-ADD1 T)

(PROVE-LEMMA LENGTH-CDR
             (REWRITE)
             (EQUAL (EQUAL (LENGTH (CDR V))
                           (SUB1 (LENGTH V)))
                    T))

(PROVE-LEMMA EQUAL-LENGTH-CDR
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (EQUAL (LENGTH (CDR A))
                                    (LENGTH (CDR B)))
                             T))
             ((ENABLE LENGTH)))

(PROVE-LEMMA LENGTH-IF
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (LENGTH (IF C A B))
                             (LENGTH A))))

(PROVE-LEMMA LENGTH-IF*
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (LENGTH (IF* C A B))
                             (LENGTH A)))
             ((ENABLE IF*)))

(DEFN REV1
      (X SPONGE)
      (IF (NLISTP X)
          SPONGE
          (REV1 (CDR X) (CONS (CAR X) SPONGE))))

(TOGGLE REV1-OFF REV1 T)

(DEFN REVERSE (X) (REV1 X NIL))

(TOGGLE REVERSE-OFF REVERSE T)

(PROVE-LEMMA LENGTH-REV1
             (REWRITE)
             (EQUAL (LENGTH (REV1 X SPONGE))
                    (PLUS (LENGTH X) (LENGTH SPONGE)))
             ((ENABLE REV1)))

(PROVE-LEMMA LENGTH-REVERSE
             (REWRITE)
             (EQUAL (LENGTH (REVERSE X))
                    (LENGTH X))
             ((ENABLE REVERSE)))

(DEFN DELETE*
      (X L)
      (COND ((NLISTP L) L)
            ((EQUAL X (CAR L))
             (DELETE* X (CDR L)))
            (T (CONS (CAR L) (DELETE* X (CDR L))))))

(TOGGLE DELETE*-OFF DELETE* T)

(DEFN SUBSET
      (L1 L2)
      (IF (NLISTP L1)
          T
          (AND (MEMBER (CAR L1) L2)
               (SUBSET (CDR L1) L2))))

(TOGGLE SUBSET-OFF SUBSET T)

(PROVE-LEMMA SUBSET-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP X) (SUBSET X Y))
             ((ENABLE SUBSET)))

(PROVE-LEMMA SUBSET-CONS
             (REWRITE)
             (EQUAL (SUBSET (CONS X Y) Z)
                    (AND (MEMBER X Z) (SUBSET Y Z)))
             ((ENABLE SUBSET)))

(PROVE-LEMMA SUBSET-X-CONS-Y-Z
             (REWRITE)
             (EQUAL (SUBSET X (CONS Y Z))
                    (OR (SUBSET X Z)
                        (AND (MEMBER Y X)
                             (SUBSET (DELETE* Y X) Z))))
             ((ENABLE SUBSET DELETE*)))

(PROVE-LEMMA SUBSET-APPEND
             (REWRITE)
             (IMPLIES (OR (SUBSET A B) (SUBSET A C))
                      (SUBSET A (APPEND B C)))
             ((ENABLE SUBSET APPEND)))

(PROVE-LEMMA SUBSET-X-X
             (REWRITE)
             (SUBSET X X)
             ((ENABLE SUBSET)))

(DEFN DISJOINT
      (L1 L2)
      (IF (NLISTP L1)
          T
          (AND (NOT (MEMBER (CAR L1) L2))
               (DISJOINT (CDR L1) L2))))

(TOGGLE DISJOINT-OFF DISJOINT T)

(PROVE-LEMMA DISJOINT-NLISTP
             (REWRITE)
             (IMPLIES (OR (NLISTP X) (NLISTP Y))
                      (DISJOINT X Y))
             ((ENABLE DISJOINT)))

(PROVE-LEMMA DISJOINT-CONS
             (REWRITE)
             (AND (EQUAL (DISJOINT (CONS X Y) Z)
                         (AND (NOT (MEMBER X Z))
                              (DISJOINT Y Z)))
                  (EQUAL (DISJOINT Z (CONS X Y))
                         (AND (NOT (MEMBER X Z))
                              (DISJOINT Z Y))))
             ((ENABLE DISJOINT)))

(PROVE-LEMMA DISJOINT-APPEND
             (REWRITE)
             (AND (EQUAL (DISJOINT X (APPEND Y Z))
                         (AND (DISJOINT X Y) (DISJOINT X Z)))
                  (EQUAL (DISJOINT (APPEND Y Z) X)
                         (AND (DISJOINT Y X) (DISJOINT Z X))))
             ((ENABLE DISJOINT)))

(DEFN DUPLICATES?
      (L)
      (IF (NLISTP L)
          F
          (OR (MEMBER (CAR L) (CDR L))
              (DUPLICATES? (CDR L)))))

(TOGGLE DUPLICATES?-OFF DUPLICATES? T)

(PROVE-LEMMA DUPLICATES?-CONS
             (REWRITE)
             (EQUAL (DUPLICATES? (CONS X Y))
                    (OR (MEMBER X Y) (DUPLICATES? Y)))
             ((ENABLE DUPLICATES?)))

(PROVE-LEMMA DUPLICATES-APPEND
             (REWRITE)
             (EQUAL (DUPLICATES? (APPEND A B))
                    (OR (DUPLICATES? A)
                        (DUPLICATES? B)
                        (NOT (DISJOINT A B))))
             ((ENABLE DUPLICATES? DISJOINT APPEND)))

(DEFN FIRSTN
      (N L)
      (IF (LISTP L)
          (IF (ZEROP N)
              NIL
              (CONS (CAR L)
                    (FIRSTN (SUB1 N) (CDR L))))
          NIL))

(TOGGLE FIRSTN-OFF FIRSTN T)

(PROVE-LEMMA LENGTH-FIRSTN
             (REWRITE)
             (EQUAL (LENGTH (FIRSTN N L))
                    (IF (IF (LESSP (LENGTH L) N) F T)
                        (FIX N)
                        (LENGTH L)))
             ((ENABLE FIRSTN LENGTH LESSP)))

(PROVE-LEMMA LENGTH-FIRSTN1
             (REWRITE)
             (IMPLIES (IF (LESSP (LENGTH L) N) F T)
                      (EQUAL (LENGTH (FIRSTN N L)) (FIX N)))
             ((ENABLE LENGTH-FIRSTN)))

(PROVE-LEMMA LENGTH-FIRSTN2
             (REWRITE)
             (IMPLIES (NOT (IF (LESSP (LENGTH L) N) F T))
                      (EQUAL (LENGTH (FIRSTN N L))
                             (LENGTH L)))
             ((ENABLE LENGTH-FIRSTN)))

(PROVE-LEMMA CAR-FIRSTN
             (REWRITE)
             (EQUAL (CAR (FIRSTN N A))
                    (IF (AND (LISTP A) (NOT (ZEROP N)))
                        (CAR A)
                        0))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA NOT-MEMBER-FIRSTN
             (REWRITE)
             (IMPLIES (NOT (MEMBER X Y))
                      (NOT (MEMBER X (FIRSTN N Y))))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA NOT-DUPLICATES?-FIRSTN
             (REWRITE)
             (IMPLIES (NOT (DUPLICATES? X))
                      (NOT (DUPLICATES? (FIRSTN N X))))
             ((ENABLE DUPLICATES? FIRSTN)))

(PROVE-LEMMA SUBSET-FIRSTN
             (REWRITE)
             (SUBSET (FIRSTN N L) L)
             ((ENABLE SUBSET FIRSTN)))

(PROVE-LEMMA FIRSTN-BOTTOM
             (REWRITE)
             (EQUAL (EQUAL (FIRSTN N L) NIL)
                    (OR (NLISTP L) (ZEROP N)))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA DISJOINT-FIRSTN
             (REWRITE)
             (IMPLIES (DISJOINT X Y)
                      (DISJOINT (FIRSTN N X) Y))
             ((ENABLE DISJOINT FIRSTN)))

(PROVE-LEMMA DISJOINT-FIRSTN1
             (REWRITE)
             (IMPLIES (DISJOINT Y X)
                      (DISJOINT Y (FIRSTN N X)))
             ((ENABLE DISJOINT FIRSTN)))

(PROVE-LEMMA PROPERP-FIRSTN
             (REWRITE)
             (PROPERP (FIRSTN N L))
             ((ENABLE PROPERP FIRSTN)))

(PROVE-LEMMA FIRSTN-APPEND
             (REWRITE)
             (EQUAL (FIRSTN N (APPEND A B))
                    (APPEND (FIRSTN N A)
                            (FIRSTN (DIFFERENCE N (LENGTH A)) B)))
             ((INDUCT (FIRSTN N A))
              (ENABLE FIRSTN APPEND LENGTH)))

(DEFN RESTN
      (N L)
      (IF (LISTP L)
          (IF (ZEROP N)
              L
              (RESTN (SUB1 N) (CDR L)))
          L))

(TOGGLE RESTN-OFF RESTN T)

(PROVE-LEMMA LENGTH-RESTN
             (REWRITE)
             (EQUAL (LENGTH (RESTN N L))
                    (DIFFERENCE (LENGTH L) N))
             ((ENABLE RESTN LENGTH DIFFERENCE)))

(PROVE-LEMMA NOT-DUPLICATES?-RESTN
             (REWRITE)
             (IMPLIES (NOT (DUPLICATES? X))
                      (NOT (DUPLICATES? (RESTN N X))))
             ((ENABLE DUPLICATES? RESTN)))

(PROVE-LEMMA NOT-MEMBER-RESTN
             (REWRITE)
             (IMPLIES (NOT (MEMBER X Y))
                      (NOT (MEMBER X (RESTN N Y))))
             ((ENABLE RESTN)))

(PROVE-LEMMA SUBSET-RESTN
             (REWRITE)
             (SUBSET (RESTN N L) L)
             ((ENABLE SUBSET RESTN)))

(PROVE-LEMMA DISJOINT-RESTN
             (REWRITE)
             (IMPLIES (DISJOINT X Y)
                      (DISJOINT (RESTN N X) Y))
             ((ENABLE DISJOINT RESTN)))

(PROVE-LEMMA DISJOINT-RESTN1
             (REWRITE)
             (IMPLIES (DISJOINT Y X)
                      (DISJOINT Y (RESTN N X)))
             ((ENABLE DISJOINT RESTN)))

(PROVE-LEMMA PROPERP-RESTN
             (REWRITE)
             (EQUAL (PROPERP (RESTN N L))
                    (PROPERP L))
             ((ENABLE PROPERP RESTN)))

(PROVE-LEMMA RESTN-APPEND
             (REWRITE)
             (EQUAL (RESTN N (APPEND A B))
                    (APPEND (RESTN N A)
                            (RESTN (DIFFERENCE N (LENGTH A)) B)))
             ((INDUCT (RESTN N A))
              (ENABLE RESTN APPEND)))

(PROVE-LEMMA TOO-MANY-RESTNS
             (REWRITE)
             (IMPLIES (AND (PROPERP L)
                           (IF (LESSP N (LENGTH L)) F T))
                      (EQUAL (RESTN N L) NIL))
             ((INDUCT (RESTN N L))
              (ENABLE RESTN PROPERP)))

(PROVE-LEMMA CDR-RESTN
             (REWRITE)
             (IMPLIES (LESSP N (LENGTH V))
                      (EQUAL (CDR (RESTN N V))
                             (RESTN (ADD1 N) V)))
             ((ENABLE RESTN LENGTH)))

(TOGGLE CDR-RESTN-OFF CDR-RESTN T)

(PROVE-LEMMA DISJOINT-FIRSTN-RESTN-LEMMAS
             (REWRITE)
             (AND (IMPLIES (DISJOINT X Y)
                           (DISJOINT (FIRSTN N X) (FIRSTN M Y)))
                  (IMPLIES (DISJOINT X Y)
                           (DISJOINT (FIRSTN N X) (RESTN M Y)))
                  (IMPLIES (DISJOINT X Y)
                           (DISJOINT (RESTN N X) (FIRSTN M Y)))
                  (IMPLIES (DISJOINT X Y)
                           (DISJOINT (RESTN N X) (RESTN M Y))))
             ((ENABLE DISJOINT FIRSTN RESTN)))

(PROVE-LEMMA NO-DUPLICATES-DISJOINT-FIRSTN-RESTN
             (REWRITE)
             (AND (IMPLIES (NOT (DUPLICATES? X))
                           (DISJOINT (FIRSTN N X) (RESTN N X)))
                  (IMPLIES (NOT (DUPLICATES? X))
                           (DISJOINT (RESTN N X) (FIRSTN N X))))
             ((ENABLE DUPLICATES? DISJOINT RESTN FIRSTN)))

(PROVE-LEMMA APPEND-FIRSTN-RESTN
             (REWRITE)
             (EQUAL (APPEND (FIRSTN N L) (RESTN N L))
                    L)
             ((ENABLE APPEND FIRSTN RESTN)))

(TOGGLE PAIRLIST-OFF PAIRLIST T)

(PROVE-LEMMA PAIRLIST-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP A)
                      (EQUAL (PAIRLIST A B) NIL))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA PAIRLIST-CONS
             (REWRITE)
             (EQUAL (PAIRLIST (CONS X Y) Z)
                    (CONS (CONS X (CAR Z))
                          (PAIRLIST Y (CDR Z))))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA PAIRLIST-APPEND
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH C))
                      (EQUAL (PAIRLIST (APPEND A B) (APPEND C D))
                             (APPEND (PAIRLIST A C)
                                     (PAIRLIST B D))))
             ((ENABLE PAIRLIST APPEND LENGTH)))

(PROVE-LEMMA PROPERP-PAIRLIST
             (REWRITE)
             (PROPERP (PAIRLIST X Y))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA PAIRLISTS-ARE-EQUAL-WHEN-THEIR-2ND-LISTS-ARE-NLISTP
             (REWRITE)
             (IMPLIES (AND (NLISTP L1) (NLISTP L2))
                      (EQUAL (EQUAL (PAIRLIST A L1)
                                    (PAIRLIST A L2))
                             T))
             ((ENABLE PAIRLIST)))

(DEFN NTH
      (N LIST)
      (IF (ZEROP N)
          (CAR LIST)
          (NTH (SUB1 N) (CDR LIST))))

(TOGGLE NTH-OFF NTH T)

(PROVE-LEMMA OPEN-NTH
             (REWRITE)
             (AND (IMPLIES (ZEROP N)
                           (EQUAL (NTH N LIST) (CAR LIST)))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (NTH N LIST)
                                  (NTH (SUB1 N) (CDR LIST)))))
             ((ENABLE NTH)))

(TOGGLE OPEN-NTH-OFF OPEN-NTH T)

(PROVE-LEMMA NTH-IF
             (REWRITE)
             (EQUAL (NTH N (IF A B C))
                    (IF A (NTH N B) (NTH N C))))

(TOGGLE NTH-IF-OFF NTH-IF T)

(PROVE-LEMMA NTH-RESTN
             (REWRITE)
             (EQUAL (NTH N V) (CAR (RESTN N V)))
             ((ENABLE LENGTH NTH RESTN)))

(TOGGLE NTH-RESTN-OFF NTH-RESTN T)

(PROVE-LEMMA NTH-APPEND
             (REWRITE)
             (IMPLIES (LESSP N (LENGTH A))
                      (EQUAL (NTH N (APPEND A B))
                             (NTH N A)))
             ((INDUCT (NTH N A))
              (ENABLE NTH APPEND)))

(PROVE-LEMMA NTH-APPEND-TOO
             (REWRITE)
             (IMPLIES (IF (LESSP N (LENGTH A)) F T)
                      (EQUAL (NTH N (APPEND A B))
                             (NTH (DIFFERENCE N (LENGTH A)) B)))
             ((INDUCT (NTH N A))
              (ENABLE NTH APPEND)))

(DEFN NTHCDR
      (N L)
      (IF (ZEROP N)
          L
          (NTHCDR (SUB1 N) (CDR L))))

(TOGGLE NTHCDR-OFF NTHCDR T)

(PROVE-LEMMA OPEN-NTHCDR
             (REWRITE)
             (AND (IMPLIES (ZEROP N)
                           (EQUAL (NTHCDR N L) L))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (NTHCDR N L)
                                  (NTHCDR (SUB1 N) (CDR L)))))
             ((ENABLE NTHCDR)))

(PROVE-LEMMA PROPERP-AS-NULL-NTHCDR
             (REWRITE)
             (EQUAL (PROPERP L)
                    (EQUAL (NTHCDR (LENGTH L) L) NIL))
             ((ENABLE PROPERP LENGTH NTHCDR)))

(TOGGLE PROPERP-AS-NULL-NTHCDR-OFF PROPERP-AS-NULL-NTHCDR T)

(PROVE-LEMMA CDR-NTHCDR
             (REWRITE)
             (EQUAL (CDR (NTHCDR N L))
                    (NTHCDR (ADD1 N) L))
             ((ENABLE NTHCDR)))

(TOGGLE CDR-NTHCDR-OFF CDR-NTHCDR T)

(PROVE-LEMMA LISTP-NTHCDR
             (REWRITE)
             (EQUAL (LISTP (NTHCDR N L))
                    (LESSP N (LENGTH L)))
             ((ENABLE NTHCDR LENGTH)))

(DEFN SUBRANGE
      (L N M)
      (COND ((LESSP M N) NIL)
            ((ZEROP N)
             (IF (ZEROP M)
                 (LIST (CAR L))
                 (CONS (CAR L)
                       (SUBRANGE (CDR L) 0 (SUB1 M)))))
            (T (SUBRANGE (CDR L)
                         (SUB1 N)
                         (SUB1 M)))))

(TOGGLE SUBRANGE-OFF SUBRANGE T)

(PROVE-LEMMA PROPERP-SUBRANGE
             (REWRITE)
             (PROPERP (SUBRANGE V N M))
             ((ENABLE SUBRANGE)))

(PROVE-LEMMA SUBRANGE-CONS
             (REWRITE)
             (EQUAL (SUBRANGE (CONS CAR CDR) N M)
                    (COND ((LESSP M N) NIL)
                          ((ZEROP N)
                           (IF (ZEROP M)
                               (LIST CAR)
                               (CONS CAR (SUBRANGE CDR 0 (SUB1 M)))))
                          (T (SUBRANGE CDR (SUB1 N) (SUB1 M)))))
             ((ENABLE SUBRANGE)))

(TOGGLE SUBRANGE-CONS-OFF SUBRANGE-CONS T)

(PROVE-LEMMA LENGTH-SUBRANGE
             (REWRITE)
             (EQUAL (LENGTH (SUBRANGE L N M))
                    (IF (LESSP M N)
                        0
                        (ADD1 (DIFFERENCE M N))))
             ((ENABLE SUBRANGE)))

(PROVE-LEMMA SUBRANGE-APPEND-RIGHT
             (REWRITE)
             (IMPLIES (AND (NOT (LESSP M N))
                           (IF (LESSP N (LENGTH A)) F T))
                      (EQUAL (SUBRANGE (APPEND A B) N M)
                             (SUBRANGE B
                                       (DIFFERENCE N (LENGTH A))
                                       (DIFFERENCE M (LENGTH A)))))
             ((INDUCT (SUBRANGE A N M))
              (ENABLE SUBRANGE APPEND LENGTH)
              (EXPAND (DIFFERENCE N (LENGTH A))
                      (DIFFERENCE M (LENGTH A)))))

(PROVE-LEMMA SUBRANGE-APPEND-LEFT
             (REWRITE)
             (IMPLIES (AND (NOT (LESSP M N))
                           (LESSP N (LENGTH A))
                           (LESSP M (LENGTH A)))
                      (EQUAL (SUBRANGE (APPEND A B) N M)
                             (SUBRANGE A N M)))
             ((INDUCT (SUBRANGE A N M))
              (ENABLE SUBRANGE APPEND LENGTH)))

(PROVE-LEMMA SUBRANGE-0
             (REWRITE)
             (IMPLIES (AND (EQUAL M (SUB1 (LENGTH A)))
                           (PROPERP A)
                           (NOT (ZEROP (LENGTH A))))
                      (EQUAL (SUBRANGE A 0 M) A))
             ((ENABLE SUBRANGE PROPERP)))

(PROVE-LEMMA LISTP-SUBRANGE
             (REWRITE)
             (EQUAL (LISTP (SUBRANGE L N M))
                    (NOT (LESSP M N)))
             ((ENABLE SUBRANGE)))

(PROVE-LEMMA SUBSET-SUBRANGE
             (REWRITE)
             (IMPLIES (LESSP N (LENGTH V))
                      (SUBSET (SUBRANGE V M N) V))
             ((ENABLE LENGTH SUBSET SUBRANGE)
              (EXPAND (SUBRANGE V M 0))))

(PROVE-LEMMA NOT-MEMBER-SUBRANGE
             (REWRITE)
             (IMPLIES (AND (LESSP N (LENGTH V))
                           (NOT (MEMBER X V)))
                      (NOT (MEMBER X (SUBRANGE V M N))))
             ((ENABLE LENGTH MEMBER SUBRANGE)))

(PROVE-LEMMA DISJOINT-SUBRANGE
             (REWRITE)
             (IMPLIES (AND (DISJOINT X Y)
                           (LESSP M (LENGTH Y)))
                      (AND (DISJOINT X (SUBRANGE Y N M))
                           (DISJOINT (SUBRANGE Y N M) X)))
             ((ENABLE DISJOINT SUBRANGE)))

(PROVE-LEMMA OPEN-SUBRANGE
             (REWRITE)
             (AND (IMPLIES (LESSP M N)
                           (EQUAL (SUBRANGE L N M) NIL))
                  (IMPLIES (AND (NOT (LESSP M N))
                                (ZEROP N)
                                (ZEROP M))
                           (EQUAL (SUBRANGE L N M)
                                  (LIST (CAR L))))
                  (IMPLIES (AND (NOT (LESSP M N))
                                (ZEROP N)
                                (NOT (ZEROP M)))
                           (EQUAL (SUBRANGE L N M)
                                  (CONS (CAR L)
                                        (SUBRANGE (CDR L) 0 (SUB1 M)))))
                  (IMPLIES (AND (NOT (LESSP M N))
                                (NOT (ZEROP N)))
                           (EQUAL (SUBRANGE L N M)
                                  (SUBRANGE (CDR L)
                                            (SUB1 N)
                                            (SUB1 M)))))
             ((ENABLE SUBRANGE)))

(TOGGLE OPEN-SUBRANGE-OFF OPEN-SUBRANGE T)

(DEFN UPDATE-NTH
      (N LST VALUE)
      (IF (LISTP LST)
          (IF (ZEROP N)
              (CONS VALUE (CDR LST))
              (CONS (CAR LST)
                    (UPDATE-NTH (SUB1 N)
                                (CDR LST)
                                VALUE)))
          LST))

(TOGGLE UPDATE-NTH-OFF UPDATE-NTH T)

(DEFN MAKE-LIST
      (N VALUE)
      (IF (ZEROP N)
          NIL
          (CONS VALUE
                (MAKE-LIST (SUB1 N) VALUE))))

(TOGGLE MAKE-LIST-OFF MAKE-LIST T)

(PROVE-LEMMA OPEN-MAKE-LIST
             (REWRITE)
             (AND (IMPLIES (ZEROP N)
                           (EQUAL (MAKE-LIST N X) NIL))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (MAKE-LIST N X)
                                  (CONS X (MAKE-LIST (SUB1 N) X)))))
             ((ENABLE MAKE-LIST)))

(TOGGLE OPEN-MAKE-LIST-OFF OPEN-MAKE-LIST T)

(PROVE-LEMMA LENGTH-MAKE-LIST
             (REWRITE)
             (EQUAL (LENGTH (MAKE-LIST N VALUE))
                    (FIX N))
             ((ENABLE MAKE-LIST)))

(PROVE-LEMMA MAKE-LIST-APPEND
             (REWRITE)
             (EQUAL (APPEND (MAKE-LIST N VALUE)
                            (MAKE-LIST M VALUE))
                    (MAKE-LIST (PLUS N M) VALUE))
             ((ENABLE MAKE-LIST)))

(PROVE-LEMMA PROPERP-MAKE-LIST
             (REWRITE)
             (PROPERP (MAKE-LIST N VALUE))
             ((ENABLE MAKE-LIST)))

(PROVE-LEMMA FIRSTN-MAKE-LIST
             (REWRITE)
             (IMPLIES (IF (LESSP M N) F T)
                      (EQUAL (FIRSTN N (MAKE-LIST M V))
                             (MAKE-LIST N V)))
             ((ENABLE FIRSTN MAKE-LIST)))

(DEFN TREE-SIZE
      (TREE)
      (IF (NLISTP TREE)
          1
          (PLUS (TREE-SIZE (CAR TREE))
                (TREE-SIZE (CDR TREE)))))

(TOGGLE TREE-SIZE-OFF TREE-SIZE T)

(PROVE-LEMMA TREE-SIZE-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP TREE)
                      (EQUAL (TREE-SIZE TREE) 1))
             ((ENABLE TREE-SIZE)))

(PROVE-LEMMA NOT-EQUAL-TREE-SIZE-TREE-0
             (REWRITE)
             (NOT (EQUAL (TREE-SIZE TREE) 0))
             ((ENABLE TREE-SIZE)))

(PROVE-LEMMA TREE-SIZE-1-CROCK
             (REWRITE)
             (NOT (EQUAL 1 (TREE-SIZE (CONS A B))))
             ((ENABLE TREE-SIZE)))

(PROVE-LEMMA A-HELPFUL-LEMMA-FOR-TREE-INDUCTIONS
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (TREE-SIZE TREE))
                      (EQUAL (LESSP (LENGTH A)
                                    (TREE-SIZE (CAR TREE)))
                             F))
             ((ENABLE TREE-SIZE LESSP)))

(PROVE-LEMMA TREE-SIZE-LEMMAS
             (REWRITE)
             (AND (IMPLIES (AND (LISTP TREE)
                                (EQUAL SIZE (TREE-SIZE TREE)))
                           (EQUAL (DIFFERENCE SIZE
                                              (TREE-SIZE (CAR TREE)))
                                  (TREE-SIZE (CDR TREE))))
                  (IMPLIES (AND (LISTP TREE)
                                (EQUAL SIZE (TREE-SIZE TREE)))
                           (EQUAL (DIFFERENCE SIZE
                                              (TREE-SIZE (CDR TREE)))
                                  (TREE-SIZE (CAR TREE)))))
             ((EXPAND (TREE-SIZE TREE))))

(PROVE-LEMMA MAKE-LIST-APPEND-TREE-CROCK
             (REWRITE)
             (IMPLIES (LISTP TREE)
                      (EQUAL (MAKE-LIST (PLUS (TREE-SIZE (CAR TREE))
                                              (TREE-SIZE (CDR TREE)))
                                        VALUE)
                             (MAKE-LIST (TREE-SIZE TREE) VALUE)))
             ((ENABLE TREE-SIZE)))

(TOGGLE MAKE-LIST-APPEND-TREE-CROCK-OFF MAKE-LIST-APPEND-TREE-CROCK T)

(DEFN TFIRSTN
      (LIST TREE)
      (FIRSTN (TREE-SIZE (CAR TREE)) LIST))

(DEFN TRESTN
      (LIST TREE)
      (RESTN (TREE-SIZE (CAR TREE)) LIST))

(DEFN TREE-HEIGHT
      (TREE)
      (IF (NLISTP TREE)
          1
          (ADD1 (MAX (TREE-HEIGHT (CAR TREE))
                     (TREE-HEIGHT (CDR TREE))))))

(TOGGLE TREE-HEIGHT-OFF TREE-HEIGHT T)

(DEFN MAKE-TREE
      (N)
      (COND ((ZEROP N) 0)
            ((EQUAL N 1) 0)
            (T (CONS (MAKE-TREE (QUOTIENT N 2))
                     (MAKE-TREE (DIFFERENCE N (QUOTIENT N 2)))))))

(TOGGLE MAKE-TREE-OFF MAKE-TREE T)

(PROVE-LEMMA TREE-SIZE-MAKE-TREE
             (REWRITE)
             (IMPLIES (NOT (ZEROP N))
                      (EQUAL (TREE-SIZE (MAKE-TREE N)) N))
             ((ENABLE TREE-SIZE MAKE-TREE)))

(PROVE-LEMMA LISTP-MAKE-TREE
             (REWRITE)
             (EQUAL (LISTP (MAKE-TREE N))
                    (IF (LESSP N 2) F T))
             ((DISABLE DIFFERENCE-0)
              (ENABLE MAKE-TREE)))

(PROVE-LEMMA LIST-REWRITE-4
             (REWRITE)
             (IMPLIES (AND (PROPERP A) (EQUAL (LENGTH A) 4))
                      (EQUAL (LIST (CAR A)
                                   (CADR A)
                                   (CADDR A)
                                   (CADDDR A))
                             A))
             ((ENABLE EQUAL-LENGTH-ADD1)))

(TOGGLE LIST-REWRITE-4-OFF LIST-REWRITE-4 T)

(PROVE-LEMMA LIST-ELIM-4
             (REWRITE)
             (EQUAL (EQUAL L (LIST A B C D))
                    (AND (EQUAL (CAR L) A)
                         (EQUAL (CADR L) B)
                         (EQUAL (CADDR L) C)
                         (EQUAL (CADDDR L) D)
                         (EQUAL (CDDDDR L) NIL))))

(TOGGLE LIST-ELIM-4-OFF LIST-ELIM-4 T)

(DEFN LIST-AS-COLLECTED-NTH
      (L LENGTH N)
      (IF (ZEROP LENGTH)
          NIL
          (CONS (NTH N L)
                (LIST-AS-COLLECTED-NTH L
                                       (SUB1 LENGTH)
                                       (ADD1 N)))))

(TOGGLE LIST-AS-COLLECTED-NTH-OFF LIST-AS-COLLECTED-NTH T)

(PROVE-LEMMA OPEN-LIST-AS-COLLECTED-NTH
             (REWRITE)
             (AND (IMPLIES (ZEROP LENGTH)
                           (EQUAL (LIST-AS-COLLECTED-NTH L LENGTH N)
                                  NIL))
                  (IMPLIES (NOT (ZEROP LENGTH))
                           (EQUAL (LIST-AS-COLLECTED-NTH L LENGTH N)
                                  (CONS (NTH N L)
                                        (LIST-AS-COLLECTED-NTH L
                                                               (SUB1 LENGTH)
                                                               (ADD1 N))))))
             ((ENABLE LIST-AS-COLLECTED-NTH)))

(PROVE-LEMMA EQUAL-LENGTH-4-AS-COLLECTED-NTH NIL
             (IMPLIES (AND (EQUAL (LENGTH L) 4) (PROPERP L))
                      (EQUAL L
                             (LIST-AS-COLLECTED-NTH L 4 0)))
             ((ENABLE OPEN-NTH PROPERP-AS-NULL-NTHCDR OUR-CAR-CDR-ELIM)
              (DISABLE CAR-CDR-ELIM)))

(PROVE-LEMMA EQUAL-LENGTH-32-AS-COLLECTED-NTH NIL
             (IMPLIES (AND (EQUAL (LENGTH L) 32)
                           (PROPERP L))
                      (EQUAL L
                             (LIST-AS-COLLECTED-NTH L 32 0)))
             ((ENABLE OPEN-NTH PROPERP-AS-NULL-NTHCDR OUR-CAR-CDR-ELIM)
              (DISABLE CAR-CDR-ELIM)))

(ADD-SHELL INDEX NIL INDEXP
           ((I-NAME (ONE-OF NUMBERP LITATOM) ZERO)
            (I-NUM (ONE-OF NUMBERP) ZERO)))

(DEFN LNFIX
      (X)
      (IF (OR (NUMBERP X) (LITATOM X)) X 0))

(DEFN INDICES
      (NAME FROM N)
      (IF (ZEROP N)
          NIL
          (CONS (INDEX NAME FROM)
                (INDICES NAME (ADD1 FROM) (SUB1 N)))))

(TOGGLE INDICES-OFF INDICES T)

(PROVE-LEMMA INDICES-ZEROP
             (REWRITE)
             (IMPLIES (ZEROP N)
                      (EQUAL (INDICES NAME FROM N) NIL))
             ((ENABLE INDICES)))

(PROVE-LEMMA OPEN-INDICES
             (REWRITE)
             (IMPLIES (NOT (ZEROP N))
                      (EQUAL (INDICES NAME FROM N)
                             (CONS (INDEX NAME FROM)
                                   (INDICES NAME (ADD1 FROM) (SUB1 N)))))
             ((ENABLE INDICES)))

(PROVE-LEMMA INDICES-AS-APPEND
            (REWRITE)
            (IMPLIES (NOT (ZEROP N))
                     (EQUAL (INDICES NAME FROM N)
                            (APPEND (INDICES NAME FROM (SUB1 N))
                                    (LIST (INDEX NAME (PLUS (SUB1 N) FROM))))))
            ((ENABLE INDICES)))

(TOGGLE INDICES-AS-APPEND-OFF INDICES-AS-APPEND T)

(PROVE-LEMMA LENGTH-INDICES
             (REWRITE)
             (EQUAL (LENGTH (INDICES NAME FROM N))
                    (FIX N))
             ((ENABLE LENGTH INDICES)))

(PROVE-LEMMA LISTP-INDICES
             (REWRITE)
             (EQUAL (LISTP (INDICES NAME FROM N))
                    (NOT (ZEROP N)))
             ((ENABLE INDICES)))

(PROVE-LEMMA PROPERP-INDICES
             (REWRITE)
             (PROPERP (INDICES NAME FROM N))
             ((ENABLE PROPERP INDICES)))

(PROVE-LEMMA MEMBER-INDICES
             (REWRITE)
             (EQUAL (MEMBER X (INDICES NAME FROM N))
                    (AND (NOT (ZEROP N))
                         (INDEXP X)
                         (EQUAL (I-NAME X) (LNFIX NAME))
                         (IF (LESSP (I-NUM X) FROM) F T)
                         (LESSP (I-NUM X) (PLUS FROM N))))
             ((ENABLE MEMBER INDICES LESSP)))

(PROVE-LEMMA DISJOINT-INDICES-DIFFERENT-NAMES
             (REWRITE)
             (IMPLIES (NOT (EQUAL (LNFIX NAME1) (LNFIX NAME2)))
                      (DISJOINT (INDICES NAME1 FROM1 N1)
                                (INDICES NAME2 FROM2 N2)))
             ((ENABLE DISJOINT INDICES)))

(PROVE-LEMMA NO-DUPLICATES-IN-INDICES
             (REWRITE)
             (NOT (DUPLICATES? (INDICES NAME FROM N)))
             ((ENABLE DUPLICATES? INDICES)))

(PROVE-LEMMA POSITION-NAME-INDICES
             (REWRITE)
             (IMPLIES (MEMBER INDEX (INDICES NAME FROM N))
                      (EQUAL (POSITION INDEX (INDICES NAME FROM N))
                             (DIFFERENCE (I-NUM INDEX) FROM)))
             ((INDUCT (INDICES NAME FROM N))
              (ENABLE POSITION INDICES)
              (DISABLE OPEN-INDICES)))

(PROVE-LEMMA NTH-INDICES
             (REWRITE)
             (IMPLIES (LESSP N M)
                      (EQUAL (NTH N (INDICES NAME FROM M))
                             (INDEX NAME (PLUS N FROM))))
             ((ENABLE NTH INDICES)))

(TOGGLE NTH-INDICES-OFF NTH-INDICES T)

(ADD-SHELL X NIL XP NIL)

(ADD-SHELL Z NIL ZP NIL)

(DEFN BOOLP
      (X)
      (OR (EQUAL X T) (EQUAL X F)))

(TOGGLE BOOLP-OFF BOOLP T)

(PROVE-LEMMA PROVE-BOOLP
             (REWRITE)
             (IMPLIES (OR (TRUEP X) (FALSEP X))
                      (BOOLP X))
             ((ENABLE BOOLP)))

(PROVE-LEMMA BOOLP-LEMMAS
             (REWRITE)
             (AND (BOOLP T)
                  (BOOLP F)
                  (IMPLIES (BOOLP B)
                           (EQUAL (EQUAL B T) B))
                  (IMPLIES (BOOLP B)
                           (EQUAL (EQUAL B F) (NOT B))))
             ((ENABLE BOOLP)))

(PROVE-LEMMA BOOLP-IMPLIES-NOT-EQUAL-Z
             (REWRITE)
             (IMPLIES (BOOLP X)
                      (NOT (EQUAL X (Z)))))

(TOGGLE BOOLP-IMPLIES-NOT-EQUAL-Z-OFF BOOLP-IMPLIES-NOT-EQUAL-Z T)

(DEFN BOOLFIX (X) (IF X T F))

(DEFN THREEP
      (X)
      (OR (EQUAL X T)
          (EQUAL X F)
          (EQUAL X (X))))

(DEFN THREEFIX
      (X)
      (IF (BOOLP X) X (X)))

(PROVE-LEMMA THREEFIX-IDEMPOTENT
             (REWRITE)
             (EQUAL (THREEFIX (THREEFIX X))
                    (THREEFIX X))
             ((ENABLE THREEFIX)))

(PROVE-LEMMA THREEFIX=X
             (REWRITE)
             (EQUAL (EQUAL (X) (THREEFIX X))
                    (NOT (BOOLP X))))

(TOGGLE THREEFIX=X-OFF THREEFIX=X T)

(DEFN FOURP
      (X)
      (OR (EQUAL X T)
          (EQUAL F X)
          (EQUAL X (X))
          (EQUAL X (Z))))

(DEFN FOURFIX
      (X)
      (IF (FOURP X) X (X)))

(DEFN BVP
      (X)
      (IF (NLISTP X)
          (EQUAL X NIL)
          (AND (BOOLP (CAR X)) (BVP (CDR X)))))

(TOGGLE BVP-OFF BVP T)

(PROVE-LEMMA BVP-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP X)
                      (EQUAL (BVP X) (EQUAL X NIL)))
             ((ENABLE BVP)))

(PROVE-LEMMA BVP-CONS
             (REWRITE)
             (EQUAL (BVP (CONS X Y))
                    (AND (BOOLP X) (BVP Y)))
             ((ENABLE BVP)))

(PROVE-LEMMA BVP-FIRSTN
             (REWRITE)
             (IMPLIES (BVP X) (BVP (FIRSTN N X)))
             ((ENABLE BVP FIRSTN)))

(PROVE-LEMMA BVP-RESTN
             (REWRITE)
             (IMPLIES (BVP X) (BVP (RESTN N X)))
             ((ENABLE BVP RESTN)))

(PROVE-LEMMA BVP-APPEND
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (BVP (APPEND A B)) (BVP B)))
             ((ENABLE BVP APPEND)))

(PROVE-LEMMA BVP-IS-PROPERP
             (REWRITE)
             (IMPLIES (BVP V) (PROPERP V))
             ((ENABLE BVP PROPERP)))

(PROVE-LEMMA BVP-MAKE-LIST
             (REWRITE)
             (EQUAL (BVP (MAKE-LIST N V))
                    (OR (ZEROP N) (BOOLP V)))
             ((ENABLE BVP MAKE-LIST)))

(PROVE-LEMMA BVP-NTHCDR
             (REWRITE)
             (IMPLIES (AND (BVP L)
                           (IF (LESSP (LENGTH L) N) F T))
                      (BVP (NTHCDR N L)))
             ((ENABLE BVP NTHCDR LENGTH)))

(PROVE-LEMMA BVP-IF
             (REWRITE)
             (IMPLIES (AND (BVP A) (BVP B))
                      (BVP (IF C A B))))

(PROVE-LEMMA BVP-IF*
             (REWRITE)
             (IMPLIES (AND (BVP A) (BVP B))
                      (BVP (IF* C A B)))
             ((ENABLE IF*)))

(DEFN BV2P
      (X Y)
      (AND (BVP X)
           (BVP Y)
           (EQUAL (LENGTH X) (LENGTH Y))))

(DEFN BVP-LENGTH
      (BVP N)
      (AND (BVP BVP)
           (IF (LESSP (LENGTH BVP) N) F T)))

(TOGGLE BVP-LENGTH-OFF BVP-LENGTH T)

(PROVE-LEMMA BVP-LENGTH-CDR
             (REWRITE)
             (IMPLIES (BVP-LENGTH X (ADD1 N))
                      (BVP-LENGTH (CDR X) N))
             ((INDUCT (FIRSTN N X))
              (ENABLE BVP-LENGTH BVP LENGTH)))

(PROVE-LEMMA BOOLFIX-CAR-X=X
             (REWRITE)
             (IMPLIES (BVP-LENGTH X 1)
                      (EQUAL (BOOLFIX (CAR X)) (CAR X)))
             ((ENABLE BOOLFIX BVP-LENGTH)))

(PROVE-LEMMA BOOLP-CAR-X
             (REWRITE)
             (IMPLIES (BVP-LENGTH X 1)
                      (BOOLP (CAR X)))
             ((ENABLE BOOLP BVP-LENGTH)))

(PROVE-LEMMA BVP-LENGTH-RESTN
             (REWRITE)
             (IMPLIES (BVP BVP)
                      (EQUAL (BVP-LENGTH (RESTN N BVP) M)
                             (IF (LESSP (DIFFERENCE (LENGTH BVP) N) M)
                                 F T)))
             ((ENABLE BVP-LENGTH)))

(PROVE-LEMMA SHOW-THAT-NTH=T
             (REWRITE)
             (IMPLIES (AND (NTH N A)
                           (BVP A)
                           (LESSP N (LENGTH A)))
                      (EQUAL (NTH N A) T))
             ((INDUCT (NTH N A)) (ENABLE BVP NTH)))

(TOGGLE SHOW-THAT-NTH=T-OFF SHOW-THAT-NTH=T T)

(PROVE-LEMMA BOOLP-NTH
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (BOOLP (NTH N A))
                             (LESSP N (LENGTH A))))
             ((INDUCT (NTH N A)) (ENABLE NTH BVP)))

(PROVE-LEMMA ANOTHER-WAY-TO-LOOK-AT-BOOLP-NTH
             (REWRITE)
             (IMPLIES (AND (BVP V) (LESSP N (LENGTH V)))
                      (EQUAL (EQUAL (IF (NTH N V) T F) (NTH N V))
                             T)))

(DEFN XOR
      (A B)
      (COND (A (IF B F T)) (B T) (T F)))

(DEFN B-BUF (X) (IF X T F))

(DEFN B-NOT (X) (NOT X))

(DEFN B-NAND (A B) (NOT (AND A B)))

(DEFN B-NAND3
      (A B C)
      (NOT (AND A B C)))

(DEFN B-NAND4
      (A B C D)
      (NOT (AND A B C D)))

(DEFN B-NAND5
      (A B C D E)
      (NOT (AND A B C D E)))

(DEFN B-NAND6
      (A B C D E G)
      (NOT (AND A B C D E G)))

(DEFN B-NAND8
      (A B C D E G H I)
      (NOT (AND A B C D E G H I)))

(DEFN B-OR (A B) (OR A B))

(DEFN B-OR3 (A B C) (OR A B C))

(DEFN B-OR4 (A B C D) (OR A B C D))

(DEFN B-XOR
      (X Y)
      (COND (X (IF Y F T)) (Y T) (T F)))

(DEFN B-XOR3
      (A B C)
      (B-XOR (B-XOR A B) C))

(DEFN B-EQUV
      (X Y)
      (COND (X (IF Y T F)) (Y F) (T T)))

(DEFN B-EQUV3
      (A B C)
      (B-EQUV A (B-XOR B C)))

(DEFN B-AND (A B) (AND A B))

(DEFN B-AND3 (A B C) (AND A B C))

(DEFN B-AND4 (A B C D) (AND A B C D))

(DEFN B-NOR (A B) (NOT (OR A B)))

(DEFN B-NOR3 (A B C) (NOT (OR A B C)))

(DEFN B-NOR4
      (A B C D)
      (NOT (OR A B C D)))

(DEFN B-NOR5
      (A B C D E)
      (NOT (OR A B C D E)))

(DEFN B-NOR6
      (A B C D E G)
      (NOT (OR A B C D E G)))

(DEFN B-NOR8
      (A B C D E G H I)
      (NOT (OR A B C D E G H I)))

(DEFN B-IF
      (C A B)
      (COND (C (IF A T F)) (B T) (T F)))

(PROVE-LEMMA OPEN-B-XOR
             (REWRITE)
             (EQUAL (B-XOR A B)
                    (COND (A (IF B F T)) (B T) (T F))))

(PROVE-LEMMA OPEN-B-XOR3
             (REWRITE)
             (EQUAL (B-XOR3 A B C)
                    (B-XOR A (B-XOR B C))))

(PROVE-LEMMA OPEN-B-EQUV
             (REWRITE)
             (EQUAL (B-EQUV A B)
                    (COND (A (IF B T F)) (B F) (T T))))

(PROVE-LEMMA OPEN-B-EQUV3
             (REWRITE)
             (EQUAL (B-EQUV3 A B C)
                    (B-EQUV A (B-XOR B C))))

(PROVE-LEMMA B-AND-REWRITE
             (REWRITE)
             (AND (NOT (B-AND F X))
                  (NOT (B-AND X F))
                  (IMPLIES (AND X Y) (B-AND X Y))))

(PROVE-LEMMA B-BUF-X=X
             (REWRITE)
             (IMPLIES (BOOLP X)
                      (EQUAL (B-BUF X) X)))

(DEFTHEORY B-GATES
           (B-BUF B-NOT B-NAND B-NAND3 B-NAND4 B-NAND5 B-NAND6 B-NAND8 B-OR
                  B-OR3 B-OR4 B-XOR B-XOR3 B-EQUV B-EQUV3 B-AND B-AND3 B-AND4
                  B-NOR B-NOR3 B-NOR4 B-NOR5 B-NOR6 B-NOR8 B-IF OPEN-B-XOR
                  OPEN-B-XOR3 OPEN-B-EQUV OPEN-B-EQUV3 B-AND-REWRITE B-BUF-X=X))

(PROVE-LEMMA BOOLP-B-GATES
             (REWRITE)
             (AND (BOOLP (B-BUF X))
                  (BOOLP (B-NOT X))
                  (BOOLP (B-NAND A B))
                  (BOOLP (B-NAND3 A B C))
                  (BOOLP (B-NAND4 A B C D))
                  (BOOLP (B-NAND5 A B C D E))
                  (BOOLP (B-NAND6 A B C D E G))
                  (BOOLP (B-NAND8 A B C D E G H I))
                  (BOOLP (B-OR A B))
                  (BOOLP (B-OR3 A B C))
                  (BOOLP (B-OR4 A B C D))
                  (BOOLP (B-XOR X Y))
                  (BOOLP (B-XOR3 A B C))
                  (BOOLP (B-EQUV X Y))
                  (BOOLP (B-EQUV3 A B C))
                  (BOOLP (B-AND A B))
                  (BOOLP (B-AND3 A B C))
                  (BOOLP (B-AND4 A B C D))
                  (BOOLP (B-NOR A B))
                  (BOOLP (B-NOR3 A B C))
                  (BOOLP (B-NOR4 A B C D))
                  (BOOLP (B-NOR5 A B C D E))
                  (BOOLP (B-NOR6 A B C D E G))
                  (BOOLP (B-NOR8 A B C D E G H I))
                  (BOOLP (B-IF C A B)))
             ((ENABLE BOOLP)))

(TOGGLE BOOLP-B-GATES-OFF BOOLP-B-GATES T)

(DEFN ID (X) X)

(DEFN AO2
      (A B C D)
      (B-NOR (B-AND A B) (B-AND C D)))

(DEFN AO4
      (A B C D)
      (B-NAND (B-OR A B) (B-OR C D)))

(DEFN AO6
      (A B C)
      (B-NOR (B-AND A B) C))

(DEFN AO7
      (A B C)
      (B-NAND (B-OR A B) C))

(DEFN VSS NIL F)

(DEFN VDD NIL T)

(DEFN V-BUF
      (X)
      (IF (NLISTP X)
          NIL
          (CONS (B-BUF (CAR X))
                (V-BUF (CDR X)))))

(TOGGLE V-BUF-OFF V-BUF T)

(DEFN V-NOT
      (X)
      (IF (NLISTP X)
          NIL
          (CONS (B-NOT (CAR X))
                (V-NOT (CDR X)))))

(TOGGLE V-NOT-OFF V-NOT T)

(DEFN V-AND
      (X Y)
      (IF (NLISTP X)
          NIL
          (CONS (B-AND (CAR X) (CAR Y))
                (V-AND (CDR X) (CDR Y)))))

(TOGGLE V-AND-OFF V-AND T)

(DEFN V-OR
      (X Y)
      (IF (NLISTP X)
          NIL
          (CONS (B-OR (CAR X) (CAR Y))
                (V-OR (CDR X) (CDR Y)))))

(TOGGLE V-OR-OFF V-OR T)

(DEFN V-XOR
      (X Y)
      (IF (NLISTP X)
          NIL
          (CONS (B-XOR (CAR X) (CAR Y))
                (V-XOR (CDR X) (CDR Y)))))

(TOGGLE V-XOR-OFF V-XOR T)

(DEFN V-SHIFT-RIGHT
      (A SI)
      (IF (NLISTP A)
          NIL
          (APPEND (V-BUF (CDR A))
                  (LIST (BOOLFIX SI)))))

(TOGGLE V-SHIFT-RIGHT-OFF V-SHIFT-RIGHT T)

(DEFN V-LSR (A) (V-SHIFT-RIGHT A F))

(DEFN V-ROR
      (A SI)
      (V-SHIFT-RIGHT A SI))

(DEFN V-ASR
      (A)
      (V-SHIFT-RIGHT A
                     (NTH (SUB1 (LENGTH A)) A)))

(DEFN V-IF
      (C A B)
      (IF (NLISTP A)
          NIL
          (CONS (IF (IF C (CAR A) (CAR B)) T F)
                (V-IF C (CDR A) (CDR B)))))

(TOGGLE V-IF-OFF V-IF T)

(PROVE-LEMMA BVP-V-BUF
             (REWRITE)
             (BVP (V-BUF A))
             ((ENABLE V-BUF)))

(PROVE-LEMMA BVP-V-NOT
             (REWRITE)
             (BVP (V-NOT A))
             ((ENABLE V-NOT)))

(PROVE-LEMMA BVP-V-AND
             (REWRITE)
             (BVP (V-AND A B))
             ((ENABLE V-AND)))

(PROVE-LEMMA BVP-V-OR
             (REWRITE)
             (BVP (V-OR A B))
             ((ENABLE V-OR)))

(PROVE-LEMMA BVP-V-XOR
             (REWRITE)
             (BVP (V-XOR A B))
             ((ENABLE V-XOR)))

(PROVE-LEMMA BVP-V-SHIFT-RIGHT
             (REWRITE)
             (BVP (V-SHIFT-RIGHT A SI))
             ((ENABLE V-SHIFT-RIGHT)))

(PROVE-LEMMA BVP-V-LSR
             (REWRITE)
             (BVP (V-LSR A))
             ((ENABLE V-LSR)))

(PROVE-LEMMA BVP-V-ASR
             (REWRITE)
             (BVP (V-ASR A))
             ((ENABLE V-ASR)))

(PROVE-LEMMA BVP-V-ROR
             (REWRITE)
             (BVP (V-ROR A C))
             ((ENABLE V-ROR)))

(PROVE-LEMMA BVP-V-IF
             (REWRITE)
             (BVP (V-IF C A B))
             ((ENABLE V-IF)))

(PROVE-LEMMA LENGTH-V-BUF
             (REWRITE)
             (EQUAL (LENGTH (V-BUF A)) (LENGTH A))
             ((ENABLE LENGTH V-BUF)))

(PROVE-LEMMA LENGTH-V-NOT
             (REWRITE)
             (EQUAL (LENGTH (V-NOT A)) (LENGTH A))
             ((ENABLE LENGTH V-NOT)))

(PROVE-LEMMA LENGTH-V-AND
             (REWRITE)
             (EQUAL (LENGTH (V-AND A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-AND)))

(PROVE-LEMMA LENGTH-V-OR
             (REWRITE)
             (EQUAL (LENGTH (V-OR A B)) (LENGTH A))
             ((ENABLE LENGTH V-OR)))

(PROVE-LEMMA LENGTH-V-XOR
             (REWRITE)
             (EQUAL (LENGTH (V-XOR A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-XOR)))

(PROVE-LEMMA LENGTH-V-SHIFT-RIGHT
             (REWRITE)
             (EQUAL (LENGTH (V-SHIFT-RIGHT A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-SHIFT-RIGHT)))

(PROVE-LEMMA LENGTH-V-LSR
             (REWRITE)
             (EQUAL (LENGTH (V-LSR A)) (LENGTH A))
             ((ENABLE LENGTH V-LSR)))

(PROVE-LEMMA LENGTH-V-ASR
             (REWRITE)
             (EQUAL (LENGTH (V-ASR A)) (LENGTH A))
             ((ENABLE LENGTH V-ASR)))

(PROVE-LEMMA LENGTH-V-ROR
             (REWRITE)
             (EQUAL (LENGTH (V-ROR A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-ROR)))

(PROVE-LEMMA LENGTH-V-IF
             (REWRITE)
             (EQUAL (LENGTH (V-IF C A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-IF)))

(PROVE-LEMMA V-AND-APPEND-HELP
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (APPEND (V-AND A B) (V-AND D E))
                             (V-AND (APPEND A D) (APPEND B E))))
             ((ENABLE APPEND LENGTH V-AND)))

(PROVE-LEMMA V-OR-APPEND-HELP
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (APPEND (V-OR A B) (V-OR D E))
                             (V-OR (APPEND A D) (APPEND B E))))
             ((ENABLE APPEND LENGTH V-OR)))

(PROVE-LEMMA V-XOR-APPEND-HELP
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (APPEND (V-XOR A B) (V-XOR D E))
                             (V-XOR (APPEND A D) (APPEND B E))))
             ((ENABLE APPEND LENGTH V-XOR)))

(PROVE-LEMMA V-NOT-APPEND-HELP
             (REWRITE)
             (EQUAL (APPEND (V-NOT A) (V-NOT B))
                    (V-NOT (APPEND A B)))
             ((ENABLE APPEND LENGTH V-NOT)))

(PROVE-LEMMA V-BUF-APPEND-HELP
             (REWRITE)
             (EQUAL (APPEND (V-BUF A) (V-BUF B))
                    (V-BUF (APPEND A B)))
             ((ENABLE APPEND LENGTH V-BUF)))

(PROVE-LEMMA V-IF-APPEND-HELP
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (APPEND (V-IF C A B) (V-IF C D E))
                             (V-IF C (APPEND A D) (APPEND B E))))
             ((ENABLE APPEND LENGTH V-IF)))

(PROVE-LEMMA V-IF-C-CONGRUENCE
             (REWRITE)
             (IMPLIES C
                      (EQUAL (EQUAL (V-IF C A B) (V-IF T A B))
                             T))
             ((ENABLE V-IF)))

(PROVE-LEMMA V-NOT-FIRSTN
             (REWRITE)
             (EQUAL (V-NOT (FIRSTN N L))
                    (FIRSTN N (V-NOT L)))
             ((ENABLE FIRSTN RESTN V-NOT)))

(PROVE-LEMMA V-NOT-RESTN
             (REWRITE)
             (EQUAL (V-NOT (RESTN N L))
                    (RESTN N (V-NOT L)))
             ((ENABLE FIRSTN RESTN V-NOT)))

(PROVE-LEMMA FIRSTN-V-NOT
             (REWRITE)
             (EQUAL (FIRSTN N (V-NOT L))
                    (V-NOT (FIRSTN N L))))

(TOGGLE FIRSTN-V-NOT-OFF FIRSTN-V-NOT T)

(PROVE-LEMMA RESTN-V-NOT
             (REWRITE)
             (EQUAL (RESTN N (V-NOT L))
                    (V-NOT (RESTN N L))))

(TOGGLE RESTN-V-NOT-OFF RESTN-V-NOT T)

(PROVE-LEMMA V-NOT-INVERTS-ALL
             (REWRITE)
             (IMPLIES (LESSP N (LENGTH BVP))
                      (EQUAL (NTH N (V-NOT BVP))
                             (B-NOT (NTH N BVP))))
             ((ENABLE NTH V-NOT LENGTH BOOLFIX SHOW-THAT-NTH=T)))

(PROVE-LEMMA V-OR-MAKE-LIST-F
             (REWRITE)
             (IMPLIES (AND (BVP A) (EQUAL (LENGTH A) N))
                      (EQUAL (V-OR (MAKE-LIST N F) A) A))
             ((ENABLE LENGTH MAKE-LIST V-OR)))

(DEFN V-TO-NAT
      (V)
      (IF (NLISTP V)
          0
          (PLUS (IF (CAR V) 1 0)
                (TIMES 2 (V-TO-NAT (CDR V))))))

(TOGGLE V-TO-NAT-OFF V-TO-NAT T)

(DEFN NAT-TO-V
      (X N)
      (IF (ZEROP N)
          NIL
          (CONS (NOT (ZEROP (REMAINDER X 2)))
                (NAT-TO-V (QUOTIENT X 2) (SUB1 N)))))

(TOGGLE NAT-TO-V-OFF NAT-TO-V T)

(PROVE-LEMMA FIRSTN-NAT-TO-V
             (REWRITE)
             (IMPLIES (IF (LESSP M N) F T)
                      (EQUAL (FIRSTN N (NAT-TO-V NAT M))
                             (NAT-TO-V NAT N)))
             ((ENABLE FIRSTN NAT-TO-V)))

(PROVE-LEMMA RESTN-NAT-TO-V-0-HACK
             (REWRITE)
             (IMPLIES (IF (LESSP M N) F T)
                      (EQUAL (RESTN N (NAT-TO-V 0 M))
                             (NAT-TO-V 0 (DIFFERENCE M N))))
             ((ENABLE RESTN NAT-TO-V DIFFERENCE)))

(PROVE-LEMMA LENGTH-NAT-TO-V
             (REWRITE)
             (EQUAL (LENGTH (NAT-TO-V N LENGTH))
                    (FIX LENGTH))
             ((ENABLE LENGTH NAT-TO-V)))

(PROVE-LEMMA BVP-NAT-TO-V
             (REWRITE)
             (BVP (NAT-TO-V N LENGTH))
             ((ENABLE BVP NAT-TO-V)))

(PROVE-LEMMA CAR-NAT-TO-V-0-IS-F
             (REWRITE)
             (IMPLIES (NOT (ZEROP N))
                      (NOT (CAR (NAT-TO-V 0 N))))
             ((ENABLE NAT-TO-V)))

(PROVE-LEMMA ANY-OF-NAT-TO-V-0-IS-F
             (REWRITE)
             (IMPLIES (LESSP N M)
                      (NOT (NTH N (NAT-TO-V 0 M))))
             ((ENABLE NTH NAT-TO-V)))

(DEFN V-NTH
      (V-N LST)
      (NTH (V-TO-NAT V-N) LST))

(TOGGLE V-NTH-OFF V-NTH T)

(DEFN UPDATE-V-NTH
      (V-N LST VALUE)
      (UPDATE-NTH (V-TO-NAT V-N) LST VALUE))

(TOGGLE UPDATE-V-NTH-OFF UPDATE-V-NTH T)

(DEFN V-NZEROP
      (X)
      (IF (NLISTP X)
          F
          (OR (CAR X) (V-NZEROP (CDR X)))))

(TOGGLE V-NZEROP-OFF V-NZEROP T)

(DEFN V-ZEROP (X) (NOT (V-NZEROP X)))

(PROVE-LEMMA V-NZEROP-AS-OR-CROCK
             (REWRITE)
             (AND (IMPLIES (V-NZEROP (FIRSTN N A))
                           (V-NZEROP A))
                  (IMPLIES (V-NZEROP (RESTN N A))
                           (V-NZEROP A)))
             ((ENABLE V-NZEROP FIRSTN RESTN)))

(PROVE-LEMMA NOT-V-NZEROP-AS-AND-CROCK
             (REWRITE)
             (IMPLIES (AND (NOT (V-NZEROP (FIRSTN N A)))
                           (NOT (V-NZEROP (RESTN N A))))
                      (NOT (V-NZEROP A)))
             ((ENABLE V-NZEROP FIRSTN RESTN)))

(PROVE-LEMMA NOT-V-NZEROP-V-XOR-X-X
             (REWRITE)
             (NOT (V-NZEROP (V-XOR X X)))
             ((ENABLE V-XOR V-NZEROP)))

(PROVE-LEMMA V-XOR-NZEROP=NOT-EQUAL
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-NZEROP (V-XOR A B))
                             (NOT (EQUAL A B))))
             ((ENABLE V-NZEROP V-XOR LENGTH BVP BOOLP)))

(PROVE-LEMMA V-ZEROP-MAKE-LIST-F
             (REWRITE)
             (EQUAL (V-ZEROP (MAKE-LIST N F)) T)
             ((ENABLE V-ZEROP V-NZEROP MAKE-LIST)))

(PROVE-LEMMA NOT-V-NZEROP-ALL-F
             (REWRITE)
             (NOT (V-NZEROP (MAKE-LIST N F)))
             ((ENABLE V-NZEROP MAKE-LIST)))

(DEFN V-NEGP
      (X)
      (COND ((NLISTP X) F)
            ((NLISTP (CDR X)) (CAR X))
            (T (V-NEGP (CDR X)))))

(TOGGLE V-NEGP-OFF V-NEGP T)

(PROVE-LEMMA BOOLP-V-NEGP
             (REWRITE)
             (IMPLIES (BVP V) (BOOLP (V-NEGP V)))
             ((ENABLE BOOLP BVP V-NEGP)))

(PROVE-LEMMA V-NEGP-AS-NTH
             (REWRITE)
             (IMPLIES (NOT (EQUAL (LENGTH BV) 0))
                      (EQUAL (V-NEGP BV)
                             (NTH (SUB1 (LENGTH BV)) BV)))
             ((ENABLE V-NEGP NTH)))

(TOGGLE V-NEGP-AS-NTH-OFF V-NEGP-AS-NTH T)

(DEFN SIGN-EXTEND
      (V N)
      (COND ((ZEROP N) NIL)
            ((NLISTP V) (MAKE-LIST N F))
            ((NLISTP (CDR V))
             (CONS (BOOLFIX (CAR V))
                   (MAKE-LIST (SUB1 N)
                              (BOOLFIX (CAR V)))))
            (T (CONS (BOOLFIX (CAR V))
                     (SIGN-EXTEND (CDR V) (SUB1 N))))))

(TOGGLE SIGN-EXTEND-OFF SIGN-EXTEND T)

(PROVE-LEMMA LENGTH-SIGN-EXTEND
             (REWRITE)
             (EQUAL (LENGTH (SIGN-EXTEND V N))
                    (FIX N))
             ((ENABLE SIGN-EXTEND LENGTH)))

(PROVE-LEMMA BVP-SIGN-EXTEND
             (REWRITE)
             (BVP (SIGN-EXTEND V N))
             ((ENABLE BVP SIGN-EXTEND)))

(PROVE-LEMMA SIGN-EXTEND-AS-APPEND
             (REWRITE)
             (IMPLIES (AND (BVP V)
                           (IF (LESSP N (LENGTH V)) F T)
                           (NOT (EQUAL (LENGTH V) 0)))
                      (EQUAL (SIGN-EXTEND V N)
                             (APPEND V
                                     (MAKE-LIST (DIFFERENCE N (LENGTH V))
                                                (NTH (SUB1 (LENGTH V)) V)))))
             ((INDUCT (SIGN-EXTEND V N))
              (ENABLE APPEND SIGN-EXTEND MAKE-LIST NTH DIFFERENCE)))

(TOGGLE SIGN-EXTEND-AS-APPEND-OFF SIGN-EXTEND-AS-APPEND T)

(DEFN V-ADDER
      (C A B)
      (IF (NLISTP A)
          (LIST (BOOLFIX C))
          (CONS (B-XOR3 C (CAR A) (CAR B))
                (V-ADDER (B-OR (B-AND (CAR A) (CAR B))
                               (B-OR (B-AND (CAR A) C)
                                     (B-AND (CAR B) C)))
                         (CDR A)
                         (CDR B)))))

(TOGGLE V-ADDER-OFF V-ADDER T)

(DEFN V-ADDER-OUTPUT
      (C A B)
      (FIRSTN (LENGTH A) (V-ADDER C A B)))

(DEFN V-ADDER-CARRY-OUT
      (C A B)
      (NTH (LENGTH A) (V-ADDER C A B)))

(DEFN V-ADDER-OVERFLOWP
      (C A B)
      (B-AND (B-EQUV (NTH (SUB1 (LENGTH A)) A)
                     (NTH (SUB1 (LENGTH B)) B))
             (B-XOR (NTH (SUB1 (LENGTH A)) A)
                    (NTH (SUB1 (LENGTH A))
                         (V-ADDER-OUTPUT C A B)))))

(DEFN V-SUBTRACTER-OUTPUT
      (C A B)
      (V-ADDER-OUTPUT (B-NOT C)
                      (V-NOT A)
                      B))

(DEFN V-SUBTRACTER-CARRY-OUT
      (C A B)
      (B-NOT (V-ADDER-CARRY-OUT (B-NOT C)
                                (V-NOT A)
                                B)))

(DEFN V-SUBTRACTER-OVERFLOWP
      (C A B)
      (V-ADDER-OVERFLOWP (B-NOT C)
                         (V-NOT A)
                         B))

(DEFN V-INC
      (X)
      (V-ADDER-OUTPUT T X
                      (NAT-TO-V 0 (LENGTH X))))

(TOGGLE V-INC-OFF V-INC T)

(DEFN V-DEC
      (X)
      (V-SUBTRACTER-OUTPUT T
                           (NAT-TO-V 0 (LENGTH X))
                           X))

(TOGGLE V-DEC-OFF V-DEC T)

(PROVE-LEMMA LENGTH-OF-V-ADDER
             (REWRITE)
             (EQUAL (LENGTH (V-ADDER C A B))
                    (ADD1 (LENGTH A)))
             ((ENABLE LENGTH V-ADDER)))

(PROVE-LEMMA BVP-V-ADDER
             (REWRITE)
             (BVP (V-ADDER C A B))
             ((ENABLE BVP V-ADDER)))

(PROVE-LEMMA LENGTH-OF-V-ADDER-OUTPUT
             (REWRITE)
             (EQUAL (LENGTH (V-ADDER-OUTPUT C A B))
                    (LENGTH A)))

(PROVE-LEMMA LENGTH-OF-V-SUBTRACTER-OUTPUT
             (REWRITE)
             (EQUAL (LENGTH (V-SUBTRACTER-OUTPUT C A B))
                    (LENGTH A)))

(PROVE-LEMMA BVP-LENGTH-V-INC-V-DEC
             (REWRITE)
             (AND (BVP (V-INC X))
                  (BVP (V-DEC X))
                  (EQUAL (LENGTH (V-INC X)) (LENGTH X))
                  (EQUAL (LENGTH (V-DEC X)) (LENGTH X)))
             ((ENABLE V-INC V-DEC)))

(PROVE-LEMMA V-BUF-WORKS
             (REWRITE)
             (IMPLIES (BVP X) (EQUAL (V-BUF X) X))
             ((ENABLE BVP V-BUF)))

(PROVE-LEMMA V-IF-WORKS
             (REWRITE)
             (IMPLIES (BV2P X Y)
                      (EQUAL (V-IF C X Y) (IF C X Y)))
             ((ENABLE BVP V-IF LENGTH)))

(PROVE-LEMMA V-ADDER-WORKS
             (REWRITE)
             (IMPLIES (BV2P X Y)
                      (EQUAL (V-TO-NAT (V-ADDER C X Y))
                             (PLUS (IF C 1 0)
                                   (V-TO-NAT X)
                                   (V-TO-NAT Y))))
             ((ENABLE BOOLFIX BVP LENGTH V-TO-NAT V-ADDER PLUS)))

(DEFN V-THREEFIX
      (V)
      (IF (NLISTP V)
          NIL
          (CONS (THREEFIX (CAR V))
                (V-THREEFIX (CDR V)))))

(TOGGLE V-THREEFIX-OFF V-THREEFIX T)

(PROVE-LEMMA OPEN-V-THREEFIX
             (REWRITE)
             (AND (IMPLIES (NLISTP V)
                           (EQUAL (V-THREEFIX V) NIL))
                  (IMPLIES (LISTP V)
                           (EQUAL (V-THREEFIX V)
                                  (CONS (THREEFIX (CAR V))
                                        (V-THREEFIX (CDR V))))))
             ((ENABLE V-THREEFIX)))

(PROVE-LEMMA V-THREEFIX-BVP
             (REWRITE)
             (IMPLIES (BVP V)
                      (EQUAL (V-THREEFIX V) V))
             ((ENABLE BVP V-THREEFIX)))

(PROVE-LEMMA PROPERP-V-THREEFIX
             (REWRITE)
             (PROPERP (V-THREEFIX X))
             ((ENABLE PROPERP V-THREEFIX)))

(PROVE-LEMMA LENGTH-V-THREEFIX
             (REWRITE)
             (EQUAL (LENGTH (V-THREEFIX X))
                    (LENGTH X))
             ((ENABLE LENGTH V-THREEFIX)))

(PROVE-LEMMA APPEND-V-THREEFIX
             (REWRITE)
             (EQUAL (APPEND (V-THREEFIX A) (V-THREEFIX B))
                    (V-THREEFIX (APPEND A B)))
             ((ENABLE APPEND V-THREEFIX)))

(PROVE-LEMMA V-THREEFIX-APPEND
             (REWRITE)
             (EQUAL (V-THREEFIX (APPEND A B))
                    (APPEND (V-THREEFIX A)
                            (V-THREEFIX B))))

(TOGGLE V-THREEFIX-APPEND-OFF V-THREEFIX-APPEND T)

(PROVE-LEMMA V-THREEFIX-IDEMPOTENCE
             (REWRITE)
             (EQUAL (V-THREEFIX (V-THREEFIX X))
                    (V-THREEFIX X))
             ((ENABLE V-THREEFIX)))

(PROVE-LEMMA BVP-V-THREEFIX
             (REWRITE)
             (IMPLIES (PROPERP V)
                      (EQUAL (BVP (V-THREEFIX V)) (BVP V)))
             ((ENABLE PROPERP BVP V-THREEFIX)))

(PROVE-LEMMA V-THREEFIX-MAKE-LIST-X
             (REWRITE)
             (EQUAL (V-THREEFIX (MAKE-LIST N (X)))
                    (MAKE-LIST N (X)))
             ((ENABLE V-THREEFIX MAKE-LIST)))

(DEFN V-FOURFIX
      (V)
      (IF (NLISTP V)
          NIL
          (CONS (FOURFIX (CAR V))
                (V-FOURFIX (CDR V)))))

(TOGGLE V-FOURFIX-OFF V-FOURFIX T)

(PROVE-LEMMA BVP-V-FOURFIX
             (REWRITE)
             (IMPLIES (BVP V)
                      (EQUAL (V-FOURFIX V) V))
             ((ENABLE V-FOURFIX BVP)))

(PROVE-LEMMA V-FOURFIX-MAKE-LIST
             (REWRITE)
             (IMPLIES (OR (EQUAL X T)
                          (EQUAL X F)
                          (EQUAL X (X))
                          (EQUAL X (Z)))
                      (EQUAL (V-FOURFIX (MAKE-LIST N X))
                             (MAKE-LIST N X)))
             ((ENABLE V-FOURFIX MAKE-LIST FOURFIX)))

(PROVE-LEMMA V-THREEFIX-V-FOURFIX
             (REWRITE)
             (EQUAL (V-THREEFIX (V-FOURFIX V))
                    (V-THREEFIX V))
             ((ENABLE V-THREEFIX V-FOURFIX)))

(DEFN V-IFF
      (A B)
      (IF (NLISTP A)
          T
          (AND (IFF (CAR A) (CAR B))
               (V-IFF (CDR A) (CDR B)))))

(TOGGLE V-IFF-OFF V-IFF T)

(PROVE-LEMMA V-IFF-X-X
             (REWRITE)
             (V-IFF X X)
             ((ENABLE V-IFF)))

(PROVE-LEMMA V-IFF-REV1
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (LENGTH B))
                           (EQUAL (LENGTH X) (LENGTH Y)))
                      (EQUAL (V-IFF (REV1 A X) (REV1 B Y))
                             (AND (V-IFF A B) (V-IFF X Y))))
             ((ENABLE V-IFF REV1)))

(PROVE-LEMMA V-IFF-REVERSE
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (V-IFF (REVERSE A) (REVERSE B))
                             (V-IFF A B)))
             ((ENABLE REVERSE)))

(PROVE-LEMMA V-IFF=EQUAL
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-IFF A B) (EQUAL A B)))
             ((ENABLE V-IFF BOOLP)))

(PROVE-LEMMA BVP-SUBRANGE
             (REWRITE)
             (IMPLIES (AND (BVP V) (LESSP N (LENGTH V)))
                      (BVP (SUBRANGE V M N)))
             ((ENABLE SUBRANGE BVP LENGTH)))

(PROVE-LEMMA BOOLP-IF*
             (REWRITE)
             (IMPLIES (AND (BOOLP A) (BOOLP B))
                      (BOOLP (IF* C A B)))
             ((ENABLE IF*)))

(DEFN VALUE
      (NAME ALIST)
      (COND ((NLISTP ALIST) 0)
            ((LISTP (CAR ALIST))
             (IF (EQUAL (CAAR ALIST) NAME)
                 (CDAR ALIST)
                 (VALUE NAME (CDR ALIST))))
            (T (VALUE NAME (CDR ALIST)))))

(TOGGLE VALUE-OFF VALUE T)

(DEFN COLLECT-VALUE
      (ARGS ALIST)
      (IF (NLISTP ARGS)
          NIL
          (CONS (VALUE (CAR ARGS) ALIST)
                (COLLECT-VALUE (CDR ARGS) ALIST))))

(TOGGLE COLLECT-VALUE-OFF COLLECT-VALUE T)

(PROVE-LEMMA REWRITE-VALUE
             (REWRITE)
             (EQUAL (VALUE A (CONS (CONS B C) D))
                    (IF (EQUAL A B) C (VALUE A D)))
             ((ENABLE VALUE)))

(PROVE-LEMMA REWRITE-VALUE-4X
             (REWRITE)
             (EQUAL (VALUE A
                           (CONS (CONS B C)
                                 (CONS (CONS D E)
                                       (CONS (CONS G H)
                                             (CONS (CONS I J) K)))))
                    (COND ((EQUAL A B) C)
                          ((EQUAL A D) E)
                          ((EQUAL A G) H)
                          ((EQUAL A I) J)
                          (T (VALUE A K))))
             ((ENABLE VALUE)))

(PROVE-LEMMA VALUE-APPEND-PAIRLIST
             (REWRITE)
             (EQUAL (VALUE A (APPEND (PAIRLIST B C) D))
                    (IF (MEMBER A B)
                        (VALUE A (PAIRLIST B C))
                        (VALUE A D)))
             ((ENABLE VALUE APPEND PAIRLIST)))

(PROVE-LEMMA VALUE-PAIRLIST
             (REWRITE)
             (IMPLIES (MEMBER NAME NAMES)
                      (EQUAL (VALUE NAME (PAIRLIST NAMES VALUES))
                             (CAR (RESTN (POSITION NAME NAMES)
                                         VALUES))))
             ((ENABLE VALUE PAIRLIST RESTN POSITION)))

(TOGGLE VALUE-PAIRLIST-OFF VALUE-PAIRLIST T)

(PROVE-LEMMA VALUE-INDICES-HACK
             (REWRITE)
             (IMPLIES (AND (MEMBER THE-NAME (INDICES NAME N M))
                           (IF (LESSP (LENGTH VALUES) M) F T))
                      (EQUAL (VALUE THE-NAME
                                    (PAIRLIST (INDICES NAME N M) VALUES))
                             (NTH (DIFFERENCE (I-NUM THE-NAME) N)
                                  VALUES)))
             ((ENABLE VALUE-PAIRLIST NTH-RESTN)
              (DISABLE OPEN-INDICES)))

(PROVE-LEMMA COLLECT-VALUE-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP ARGS)
                      (EQUAL (COLLECT-VALUE ARGS ALIST)
                             NIL))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA LISTP-COLLECT-VALUE
             (REWRITE)
             (EQUAL (LISTP (COLLECT-VALUE ARGS ALIST))
                    (LISTP ARGS))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA COLLECT-VALUE-APPEND
             (REWRITE)
             (EQUAL (COLLECT-VALUE (APPEND A B) ALIST)
                    (APPEND (COLLECT-VALUE A ALIST)
                            (COLLECT-VALUE B ALIST)))
             ((ENABLE COLLECT-VALUE APPEND)))

(PROVE-LEMMA LENGTH-COLLECT-VALUE
             (REWRITE)
             (EQUAL (LENGTH (COLLECT-VALUE ARGS ALIST))
                    (LENGTH ARGS))
             ((ENABLE LENGTH COLLECT-VALUE)))

(PROVE-LEMMA COLLECT-VALUE-APPEND-PAIRLIST-WHEN-SUBSET
             (REWRITE)
             (IMPLIES (SUBSET ARGS1 ARGS2)
                      (EQUAL (COLLECT-VALUE ARGS1
                                            (APPEND (PAIRLIST ARGS2 ANSWER) X))
                             (COLLECT-VALUE ARGS1
                                            (PAIRLIST ARGS2 ANSWER))))
             ((ENABLE SUBSET COLLECT-VALUE APPEND PAIRLIST)))

(PROVE-LEMMA COLLECT-VALUE-APPEND-PAIRLIST-WHEN-DISJOINT
             (REWRITE)
             (IMPLIES (DISJOINT ARGS1 ARGS2)
                      (EQUAL (COLLECT-VALUE ARGS1
                                            (APPEND (PAIRLIST ARGS2 A) B))
                             (COLLECT-VALUE ARGS1 B)))
             ((ENABLE DISJOINT COLLECT-VALUE APPEND PAIRLIST)))

(PROVE-LEMMA COLLECT-VALUE-DISJOINT-PAIRLIST
             (REWRITE)
             (IMPLIES (NOT (MEMBER A ARGS))
                      (EQUAL (COLLECT-VALUE ARGS
                                            (CONS (CONS A B) C))
                             (COLLECT-VALUE ARGS C)))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA COLLECT-VALUE-LITATOM-INDICES-SPEEDUP
             (REWRITE)
             (IMPLIES (LITATOM A)
                      (EQUAL (COLLECT-VALUE (INDICES NAME FROM TO)
                                            (CONS (CONS A B) C))
                             (COLLECT-VALUE (INDICES NAME FROM TO)
                                            C)))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA EQUAL-COLLECT-VALUE-PROMOTE-ALISTS
             (REWRITE)
             (IMPLIES (EQUAL ALIST1 ALIST2)
                      (EQUAL (EQUAL (COLLECT-VALUE ARGS ALIST1)
                                    (COLLECT-VALUE ARGS ALIST2))
                             T)))

(PROVE-LEMMA COLLECT-VALUE-FIRSTN
             (REWRITE)
             (IMPLIES (NOT (DUPLICATES? ARGS))
                      (EQUAL (COLLECT-VALUE (FIRSTN N ARGS)
                                            (PAIRLIST ARGS ANSWER))
                             (COLLECT-VALUE (FIRSTN N ARGS)
                                            (PAIRLIST (FIRSTN N ARGS)
                                                      (FIRSTN N ANSWER)))))
             ((ENABLE DUPLICATES? COLLECT-VALUE FIRSTN PAIRLIST)))

(PROVE-LEMMA COLLECT-VALUE-RESTN
             (REWRITE)
             (IMPLIES (NOT (DUPLICATES? ARGS))
                      (EQUAL (COLLECT-VALUE (RESTN N ARGS)
                                            (PAIRLIST ARGS ANSWER))
                             (COLLECT-VALUE (RESTN N ARGS)
                                            (PAIRLIST (RESTN N ARGS)
                                                      (RESTN N ANSWER)))))
             ((ENABLE DUPLICATES? COLLECT-VALUE RESTN PAIRLIST)))

(PROVE-LEMMA COLLECT-VALUE-CONS
             (REWRITE)
             (EQUAL (COLLECT-VALUE (CONS A B) ALIST)
                    (CONS (VALUE A ALIST)
                          (COLLECT-VALUE B ALIST)))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA SINGLETON-COLLECT-VALUE
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) 1)
                      (EQUAL (COLLECT-VALUE A ALIST)
                             (LIST (VALUE (CAR A) ALIST))))
             ((ENABLE COLLECT-VALUE)))

(PROVE-LEMMA PROPERP-COLLECT-VALUE
             (REWRITE)
             (PROPERP (COLLECT-VALUE ARGS ALIST))
             ((ENABLE COLLECT-VALUE PROPERP)))

(PROVE-LEMMA COLLECT-VALUE-ARGS-PAIRLIST-ARGS
             (REWRITE)
             (IMPLIES (AND (NOT (DUPLICATES? ARGS))
                           (EQUAL (LENGTH ARGS) (LENGTH LIST))
                           (PROPERP LIST))
                      (EQUAL (COLLECT-VALUE ARGS
                                            (PAIRLIST ARGS LIST))
                             LIST))
             ((ENABLE COLLECT-VALUE PAIRLIST)))

(PROVE-LEMMA COLLECT-VALUE-SPLITTING-CROCK-HELPER NIL
             (EQUAL (COLLECT-VALUE (APPEND (FIRSTN N L) (RESTN N L))
                                   ALIST)
                    (APPEND (COLLECT-VALUE (FIRSTN N L) ALIST)
                            (COLLECT-VALUE (RESTN N L) ALIST)))
             ((DISABLE APPEND-FIRSTN-RESTN)))

(PROVE-LEMMA COLLECT-VALUE-SPLITTING-CROCK NIL
             (EQUAL (COLLECT-VALUE L ALIST)
                    (APPEND (COLLECT-VALUE (FIRSTN N L) ALIST)
                            (COLLECT-VALUE (RESTN N L) ALIST)))
             ((USE (COLLECT-VALUE-SPLITTING-CROCK-HELPER))))

(PROVE-LEMMA COLLECT-VALUE-MAKE-LIST
             (REWRITE)
             (EQUAL (COLLECT-VALUE (MAKE-LIST N NAME)
                                   ALIST)
                    (MAKE-LIST N (VALUE NAME ALIST)))
             ((ENABLE COLLECT-VALUE MAKE-LIST)))

(DEFN CDR-CDR-SUB1-SUB1-INDUCTION
      (L1 N M L2)
      (COND ((LESSP M N) T)
            ((ZEROP N)
             (IF (ZEROP M)
                 T
                 (CDR-CDR-SUB1-SUB1-INDUCTION (CDR L1)
                                              0
                                              (SUB1 M)
                                              (CDR L2))))
            (T (CDR-CDR-SUB1-SUB1-INDUCTION (CDR L1)
                                            (SUB1 N)
                                            (SUB1 M)
                                            (CDR L2)))))

(PROVE-LEMMA COLLECT-VALUE-SUBRANGE-ARGS-PAIRLIST-ARGS
             (REWRITE)
             (IMPLIES (AND (NOT (DUPLICATES? ARGS))
                           (EQUAL (LENGTH ARGS) (LENGTH LIST))
                           (PROPERP LIST)
                           (LESSP N (LENGTH ARGS)))
                      (EQUAL (COLLECT-VALUE (SUBRANGE ARGS M N)
                                            (PAIRLIST ARGS LIST))
                             (SUBRANGE LIST M N)))
             ((ENABLE COLLECT-VALUE PAIRLIST SUBRANGE)
              (INDUCT (CDR-CDR-SUB1-SUB1-INDUCTION ARGS M N LIST))))

(ADD-SHELL ROM NIL ROMP
           ((ROM-GUTS (NONE-OF) ZERO)))

(ADD-SHELL RAM NIL RAMP
           ((RAM-GUTS (NONE-OF) ZERO)))

(ADD-SHELL STUB NIL STUBP
           ((STUB-GUTS (NONE-OF) ZERO)))

(DEFN MEMORY-PROPERP
      (N WIDTH MEM)
      (COND ((STUBP MEM)
             (AND (PROPERP (STUB-GUTS MEM))
                  (EQUAL (LENGTH (STUB-GUTS MEM))
                         WIDTH)))
            ((ZEROP N)
             (COND ((RAMP MEM)
                    (AND (PROPERP (RAM-GUTS MEM))
                         (EQUAL (LENGTH (RAM-GUTS MEM))
                                WIDTH)))
                   ((ROMP MEM)
                    (AND (PROPERP (ROM-GUTS MEM))
                         (EQUAL (LENGTH (ROM-GUTS MEM))
                                WIDTH)))
                   (T F)))
            (T (AND (LISTP MEM)
                    (MEMORY-PROPERP (SUB1 N)
                                    WIDTH
                                    (CAR MEM))
                    (MEMORY-PROPERP (SUB1 N)
                                    WIDTH
                                    (CDR MEM))))))

(TOGGLE MEMORY-PROPERP-OFF MEMORY-PROPERP T)

(DEFN MEMORY-OKP
      (N WIDTH MEM)
      (COND ((STUBP MEM)
             (AND (BVP (STUB-GUTS MEM))
                  (EQUAL (LENGTH (STUB-GUTS MEM))
                         WIDTH)))
            ((ZEROP N)
             (COND ((RAMP MEM)
                    (AND (BVP (RAM-GUTS MEM))
                         (EQUAL (LENGTH (RAM-GUTS MEM))
                                WIDTH)))
                   ((ROMP MEM)
                    (AND (BVP (ROM-GUTS MEM))
                         (EQUAL (LENGTH (ROM-GUTS MEM))
                                WIDTH)))
                   (T F)))
            (T (AND (LISTP MEM)
                    (MEMORY-OKP (SUB1 N) WIDTH (CAR MEM))
                    (MEMORY-OKP (SUB1 N)
                                WIDTH
                                (CDR MEM))))))

(TOGGLE MEMORY-OKP-OFF MEMORY-OKP T)

(DEFN READ-MEM1
      (V-ADDR MEM)
      (COND ((STUBP MEM) (STUB-GUTS MEM))
            ((NLISTP V-ADDR)
             (COND ((RAMP MEM) (RAM-GUTS MEM))
                   ((ROMP MEM) (ROM-GUTS MEM))
                   (T 0)))
            ((NLISTP MEM) 0)
            ((CAR V-ADDR)
             (READ-MEM1 (CDR V-ADDR) (CDR MEM)))
            (T (READ-MEM1 (CDR V-ADDR) (CAR MEM)))))

(TOGGLE READ-MEM1-OFF READ-MEM1 T)

(DEFN READ-MEM
      (V-ADDR MEM)
      (READ-MEM1 (REVERSE V-ADDR) MEM))

(TOGGLE READ-MEM-OFF READ-MEM T)

(DEFN WRITE-MEM1
      (V-ADDR MEM VALUE)
      (COND ((STUBP MEM) MEM)
            ((NLISTP V-ADDR)
             (IF (RAMP MEM) (RAM VALUE) MEM))
            ((NLISTP MEM) MEM)
            ((CAR V-ADDR)
             (CONS (CAR MEM)
                   (WRITE-MEM1 (CDR V-ADDR)
                               (CDR MEM)
                               VALUE)))
            (T (CONS (WRITE-MEM1 (CDR V-ADDR)
                                 (CAR MEM)
                                 VALUE)
                     (CDR MEM)))))

(TOGGLE WRITE-MEM1-OFF WRITE-MEM1 T)

(DEFN WRITE-MEM
      (V-ADDR MEM VALUE)
      (WRITE-MEM1 (REVERSE V-ADDR)
                  MEM VALUE))

(TOGGLE WRITE-MEM-OFF WRITE-MEM T)

(DEFN RAMP-MEM1
      (V-ADDR MEM)
      (COND ((STUBP MEM) F)
            ((NLISTP V-ADDR) (RAMP MEM))
            ((NLISTP MEM) F)
            ((CAR V-ADDR)
             (RAMP-MEM1 (CDR V-ADDR) (CDR MEM)))
            (T (RAMP-MEM1 (CDR V-ADDR) (CAR MEM)))))

(TOGGLE RAMP-MEM1-OFF RAMP-MEM1 T)

(DEFN RAMP-MEM
      (V-ADDR MEM)
      (RAMP-MEM1 (REVERSE V-ADDR) MEM))

(TOGGLE RAMP-MEM-OFF RAMP-MEM T)

(DEFN ALL-RAMP-MEM
      (N MEM)
      (COND ((STUBP MEM) F)
            ((ZEROP N) (RAMP MEM))
            ((NLISTP MEM) F)
            (T (AND (ALL-RAMP-MEM (SUB1 N) (CAR MEM))
                    (ALL-RAMP-MEM (SUB1 N) (CDR MEM))))))

(TOGGLE ALL-RAMP-MEM-OFF ALL-RAMP-MEM T)

(DEFN CONSTANT-RAM
      (MEM VALUE)
      (COND ((RAMP MEM) (RAM VALUE))
            ((NLISTP MEM) MEM)
            (T (CONS (CONSTANT-RAM (CAR MEM) VALUE)
                     (CONSTANT-RAM (CDR MEM) VALUE)))))

(TOGGLE CONSTANT-RAM-OFF CONSTANT-RAM T)

(PROVE-LEMMA MEMORY-PROPERP-IF
             (REWRITE)
             (IMPLIES (AND (MEMORY-PROPERP N WIDTH A)
                           (MEMORY-PROPERP N WIDTH B))
                      (MEMORY-PROPERP N WIDTH (IF C A B))))

(PROVE-LEMMA MEMORY-OKP-IF
             (REWRITE)
             (IMPLIES (AND (MEMORY-OKP N WIDTH A)
                           (MEMORY-OKP N WIDTH B))
                      (MEMORY-OKP N WIDTH (IF C A B))))

(PROVE-LEMMA MEMORY-PROPERP-CONSTANT-RAM
             (REWRITE)
             (IMPLIES (AND (MEMORY-PROPERP N WIDTH MEM)
                           (PROPERP VALUE)
                           (EQUAL WIDTH (LENGTH VALUE)))
                      (MEMORY-PROPERP N WIDTH
                                      (CONSTANT-RAM MEM VALUE)))
             ((ENABLE MEMORY-PROPERP CONSTANT-RAM)))

(PROVE-LEMMA MEMORY-PROPERP-AFTER-WRITE-MEM1
             (REWRITE)
             (IMPLIES (AND (MEMORY-PROPERP N WIDTH MEM)
                           (PROPERP VALUE)
                           (EQUAL WIDTH (LENGTH VALUE))
                           (EQUAL N (LENGTH V-ADDR)))
                      (MEMORY-PROPERP N WIDTH
                                      (WRITE-MEM1 V-ADDR MEM VALUE)))
             ((ENABLE MEMORY-PROPERP LENGTH WRITE-MEM1)))

(PROVE-LEMMA MEMORY-PROPERP-AFTER-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (MEMORY-PROPERP N WIDTH MEM)
                           (PROPERP VALUE)
                           (EQUAL WIDTH (LENGTH VALUE))
                           (EQUAL N (LENGTH V-ADDR)))
                      (MEMORY-PROPERP N WIDTH
                                      (WRITE-MEM V-ADDR MEM VALUE)))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA MEMORY-OKP-AFTER-WRITE-MEM1
             (REWRITE)
             (IMPLIES (AND (MEMORY-OKP N WIDTH MEM)
                           (BVP VALUE)
                           (EQUAL WIDTH (LENGTH VALUE))
                           (EQUAL N (LENGTH V-ADDR)))
                      (MEMORY-OKP N WIDTH
                                  (WRITE-MEM1 V-ADDR MEM VALUE)))
             ((ENABLE MEMORY-OKP LENGTH WRITE-MEM1)))

(PROVE-LEMMA MEMORY-OKP-AFTER-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (MEMORY-OKP N WIDTH MEM)
                           (BVP VALUE)
                           (EQUAL WIDTH (LENGTH VALUE))
                           (EQUAL N (LENGTH V-ADDR)))
                      (MEMORY-OKP N WIDTH
                                  (WRITE-MEM V-ADDR MEM VALUE)))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA V-IFF-V-ADDR1-V-ADDR2-READ-MEM1-WRITE-MEM1
             (REWRITE)
             (IMPLIES (AND (V-IFF V-ADDR1 V-ADDR2)
                           (RAMP-MEM1 V-ADDR2 MEM)
                           (EQUAL (LENGTH V-ADDR1)
                                  (LENGTH V-ADDR2)))
                      (EQUAL (READ-MEM1 V-ADDR1
                                        (WRITE-MEM1 V-ADDR2 MEM VALUE))
                             VALUE))
             ((ENABLE V-IFF MEMORY-OKP READ-MEM1 WRITE-MEM1 RAMP-MEM1)))

(PROVE-LEMMA V-IFF-V-ADDR1-V-ADDR2-READ-MEM1-WRITE-MEM1-NOT-RAM
             (REWRITE)
             (IMPLIES (AND (NOT (RAMP-MEM1 V-ADDR2 MEM))
                           (EQUAL (LENGTH V-ADDR1)
                                  (LENGTH V-ADDR2)))
                      (EQUAL (READ-MEM1 V-ADDR1
                                        (WRITE-MEM1 V-ADDR2 MEM VALUE))
                             (READ-MEM1 V-ADDR1 MEM)))
             ((ENABLE V-IFF MEMORY-OKP READ-MEM1 WRITE-MEM1 RAMP-MEM1)))

(PROVE-LEMMA NOT-V-IFF-V-ADDR1-V-ADDR2-READ-MEM1-WRITE-MEM1
             (REWRITE)
             (IMPLIES (NOT (V-IFF V-ADDR1 V-ADDR2))
                      (EQUAL (READ-MEM1 V-ADDR1
                                        (WRITE-MEM1 V-ADDR2 MEM VALUE))
                             (READ-MEM1 V-ADDR1 MEM)))
             ((ENABLE V-IFF MEMORY-OKP READ-MEM1 WRITE-MEM1)))

(PROVE-LEMMA READ-MEM-WRITE-MEM NIL
             (IMPLIES (EQUAL (LENGTH V-ADDR1)
                             (LENGTH V-ADDR2))
                      (EQUAL (READ-MEM V-ADDR1
                                       (WRITE-MEM V-ADDR2 MEM VALUE))
                             (IF (AND (V-IFF V-ADDR1 V-ADDR2)
                                      (RAMP-MEM V-ADDR2 MEM))
                                 VALUE
                                 (READ-MEM V-ADDR1 MEM))))
             ((ENABLE READ-MEM WRITE-MEM RAMP-MEM)))

(PROVE-LEMMA PROPERP-READ-MEM1
             (REWRITE)
             (IMPLIES (MEMORY-PROPERP (LENGTH V-ADDR)
                                      SIZE MEM)
                      (AND (PROPERP (READ-MEM1 V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM1 V-ADDR MEM))
                                  SIZE)))
             ((ENABLE MEMORY-PROPERP LENGTH READ-MEM1)))

(PROVE-LEMMA PROPERP-READ-MEM NIL
             (IMPLIES (MEMORY-PROPERP (LENGTH (REVERSE V-ADDR))
                                      SIZE MEM)
                      (AND (PROPERP (READ-MEM V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM V-ADDR MEM))
                                  SIZE)))
             ((ENABLE READ-MEM)
              (DISABLE LENGTH-REVERSE)))

(PROVE-LEMMA PROPERP-READ-MEM-32
             (REWRITE)
             (IMPLIES (MEMORY-PROPERP (LENGTH V-ADDR)
                                      32 MEM)
                      (AND (PROPERP (READ-MEM V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM V-ADDR MEM))
                                  32)))
             ((USE (PROPERP-READ-MEM (V-ADDR V-ADDR)
                                     (SIZE 32)
                                     (MEM MEM)))))

(PROVE-LEMMA BVP-READ-MEM1
             (REWRITE)
             (IMPLIES (MEMORY-OKP (LENGTH V-ADDR) SIZE MEM)
                      (AND (BVP (READ-MEM1 V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM1 V-ADDR MEM))
                                  SIZE)))
             ((ENABLE MEMORY-OKP LENGTH READ-MEM1)))

(PROVE-LEMMA BVP-READ-MEM NIL
             (IMPLIES (MEMORY-OKP (LENGTH (REVERSE V-ADDR))
                                  SIZE MEM)
                      (AND (BVP (READ-MEM V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM V-ADDR MEM))
                                  SIZE)))
             ((ENABLE READ-MEM)
              (DISABLE LENGTH-REVERSE)))

(PROVE-LEMMA BVP-READ-MEM-32
             (REWRITE)
             (IMPLIES (MEMORY-OKP (LENGTH V-ADDR) 32 MEM)
                      (AND (BVP (READ-MEM V-ADDR MEM))
                           (EQUAL (LENGTH (READ-MEM V-ADDR MEM))
                                  32)))
             ((USE (BVP-READ-MEM (V-ADDR V-ADDR)
                                 (SIZE 32)
                                 (MEM MEM)))))

(PROVE-LEMMA ALL-RAMP-MEM->RAMP-MEM1
             (REWRITE)
             (IMPLIES (ALL-RAMP-MEM (LENGTH V-ADDR) MEM)
                      (RAMP-MEM1 V-ADDR MEM))
             ((ENABLE ALL-RAMP-MEM RAMP-MEM1 LENGTH)))

(PROVE-LEMMA ALL-RAMP-MEM->RAMP-MEM
             (REWRITE)
             (IMPLIES (ALL-RAMP-MEM (LENGTH V-ADDR) MEM)
                      (RAMP-MEM V-ADDR MEM))
             ((ENABLE ALL-RAMP-MEM RAMP-MEM)))

(PROVE-LEMMA ALL-RAMP-MEM-AFTER-WRITE-MEM1 NIL
             (IMPLIES (AND (ALL-RAMP-MEM N MEM)
                           (EQUAL N (LENGTH V-ADDR)))
                      (ALL-RAMP-MEM N
                                    (WRITE-MEM1 V-ADDR MEM VALUE)))
             ((ENABLE ALL-RAMP-MEM WRITE-MEM1 LENGTH)))

(PROVE-LEMMA ALL-RAMP-MEM-AFTER-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (ALL-RAMP-MEM N MEM)
                           (EQUAL N (LENGTH V-ADDR)))
                      (ALL-RAMP-MEM N
                                    (WRITE-MEM V-ADDR MEM VALUE)))
             ((USE (ALL-RAMP-MEM-AFTER-WRITE-MEM1 (V-ADDR (REVERSE V-ADDR))))
              (ENABLE WRITE-MEM)))

(PROVE-LEMMA ALL-RAMP-MEM-CONSTANT-RAM
             (REWRITE)
             (EQUAL (ALL-RAMP-MEM N
                                  (CONSTANT-RAM MEM VALUE))
                    (ALL-RAMP-MEM N MEM))
             ((ENABLE ALL-RAMP-MEM CONSTANT-RAM)))

(PROVE-LEMMA MEMORY-OKP==>MEMORY-PROPERP
             (REWRITE)
             (IMPLIES (MEMORY-OKP N M MEM)
                      (MEMORY-PROPERP N M MEM))
             ((ENABLE MEMORY-OKP MEMORY-PROPERP)))

(DEFN DUAL-PORT-RAM-VALUE
    (BITS ADDRESS-LINES ARGS STATE)
    (COND ((OR (NOT (BVP (SUBRANGE ARGS 0
                                   (SUB1 ADDRESS-LINES))))
               (AND (NOT (EQUAL (NTH (TIMES 2 ADDRESS-LINES) ARGS)
                                T))
                    (OR (NOT (BVP (SUBRANGE ARGS ADDRESS-LINES
                                            (SUB1 (TIMES 2 ADDRESS-LINES)))))
                        (EQUAL (SUBRANGE ARGS 0 (SUB1 ADDRESS-LINES))
                               (SUBRANGE ARGS ADDRESS-LINES
                                         (SUB1 (TIMES 2 ADDRESS-LINES)))))))
           (MAKE-LIST BITS (X)))
          ((AND (PROPERP (READ-MEM (SUBRANGE ARGS 0 (SUB1 ADDRESS-LINES))
                                   STATE))
                (EQUAL (LENGTH (READ-MEM (SUBRANGE ARGS 0 (SUB1 ADDRESS-LINES))
                                         STATE))
                       BITS))
           (READ-MEM (SUBRANGE ARGS 0 (SUB1 ADDRESS-LINES))
                     STATE))
          (T (MAKE-LIST BITS (X)))))

(DEFN DUAL-PORT-RAM-STATE
      (BITS ADDRESS-LINES ARGS STATE)
      (COND ((EQUAL (NTH (TIMES 2 ADDRESS-LINES) ARGS)
                    T)
             STATE)
            ((NOT (BVP (SUBRANGE ARGS ADDRESS-LINES
                                 (SUB1 (TIMES 2 ADDRESS-LINES)))))
             (CONSTANT-RAM STATE
                           (MAKE-LIST BITS (X))))
            ((EQUAL (NTH (TIMES 2 ADDRESS-LINES) ARGS)
                    F)
             (WRITE-MEM (SUBRANGE ARGS ADDRESS-LINES
                                  (SUB1 (TIMES 2 ADDRESS-LINES)))
                        STATE
                        (SUBRANGE ARGS
                                  (ADD1 (TIMES 2 ADDRESS-LINES))
                                  (PLUS (TIMES 2 ADDRESS-LINES) BITS))))
            (T (WRITE-MEM (SUBRANGE ARGS ADDRESS-LINES
                                    (SUB1 (TIMES 2 ADDRESS-LINES)))
                          STATE
                          (MAKE-LIST BITS (X))))))

(PROVE-LEMMA PROPERP-LENGTH-DUAL-PORT-RAM-VALUE
             (REWRITE)
             (AND (PROPERP (DUAL-PORT-RAM-VALUE BITS ADDRESS-LINES ARGS STATE))
                  (EQUAL (LENGTH (DUAL-PORT-RAM-VALUE BITS ADDRESS-LINES ARGS
                                                      STATE))
                         (FIX BITS))))

(DEFN NEXT-MEMORY-STATE
 (STATE STROBE- RW- ADDRESS DATA)
 (IF
  (AND (BOOLP STROBE-) (BOOLP RW-))
  (CASE
    (CADR STATE)
    (0 (COND (STROBE- (LIST (CAR STATE)
                            0
                            (CADDR STATE)
                            0 T
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X)))))
             (RW- (IF (AND (CADDDDDR STATE)
                           (BOOLP (CADDDDDR STATE)))
                      (IF (AND (BVP ADDRESS)
                               (BVP (CADDDDDDR STATE))
                               (EQUAL ADDRESS (CADDDDDDR STATE)))
                          (LIST (CAR STATE)
                                1
                                (CDADDR STATE)
                                (SUB1 (CAADDR STATE))
                                (ZEROP (CAADDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))
                          (LIST (CAR STATE)
                                3
                                (CDADDR STATE)
                                (SUB1 (CAADDR STATE))
                                (ZEROP (CAADDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X)))))
                      (LIST (CONSTANT-RAM (CAR STATE)
                                          (MAKE-LIST 32 (X)))
                            3
                            (CDADDR STATE)
                            (SUB1 (CAADDR STATE))
                            (ZEROP (CAADDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))))
             ((AND (NOT (CADDDDDR STATE))
                   (AND (BVP ADDRESS)
                        (BVP (CADDDDDDR STATE))
                        (EQUAL ADDRESS (CADDDDDDR STATE)))
                   (BVP DATA)
                   (BVP (CADDDDDDDR STATE))
                   (EQUAL DATA (CADDDDDDDR STATE)))
              (LIST (CAR STATE)
                    2
                    (CDADDR STATE)
                    (SUB1 (CAADDR STATE))
                    (ZEROP (CAADDR STATE))
                    (THREEFIX RW-)
                    (V-THREEFIX ADDRESS)
                    (IF (BOOLP RW-)
                        (IF RW-
                            (V-THREEFIX (CADDDDDDDR STATE))
                            (V-THREEFIX DATA))
                        (MAKE-LIST (LENGTH DATA) (X)))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (1 (COND (STROBE- (IF RW-
                          (LIST (CAR STATE)
                                0
                                (CADDR STATE)
                                0 T
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))
                          (LIST (CONSTANT-RAM (CAR STATE)
                                              (MAKE-LIST 32 (X)))
                                0
                                (CADDR STATE)
                                0 T
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))))
             (RW- (IF (AND (BVP ADDRESS)
                           (BVP (CADDDDDDR STATE))
                           (EQUAL ADDRESS (CADDDDDDR STATE)))
                      (LIST (CAR STATE)
                            1
                            (CADDR STATE)
                            (SUB1 (CADDDR STATE))
                            (ZEROP (CADDDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))
                      (LIST (CAR STATE)
                            3
                            (CDADDR STATE)
                            (SUB1 (CAADDR STATE))
                            (ZEROP (CAADDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (2 (COND (STROBE- (COND (RW- (LIST (CONSTANT-RAM (CAR STATE)
                                                     (MAKE-LIST 32 (X)))
                                       0
                                       (CADDR STATE)
                                       0 T
                                       (THREEFIX RW-)
                                       (V-THREEFIX ADDRESS)
                                       (IF (BOOLP RW-)
                                           (IF RW-
                                               (V-THREEFIX (CADDDDDDDR STATE))
                                               (V-THREEFIX DATA))
                                           (MAKE-LIST (LENGTH DATA) (X)))))
                            ((AND (AND (BVP ADDRESS)
                                       (BVP (CADDDDDDR STATE))
                                       (EQUAL ADDRESS (CADDDDDDR STATE)))
                                  (AND (BVP DATA)
                                       (BVP (CADDDDDDDR STATE))
                                       (EQUAL DATA (CADDDDDDDR STATE)))
                                  (ZEROP (CADDDR STATE)))
                             (LIST (WRITE-MEM ADDRESS (CAR STATE) DATA)
                                   0
                                   (CADDR STATE)
                                   0 T
                                   (THREEFIX RW-)
                                   (V-THREEFIX ADDRESS)
                                   (IF (BOOLP RW-)
                                       (IF RW-
                                           (V-THREEFIX (CADDDDDDDR STATE))
                                           (V-THREEFIX DATA))
                                       (MAKE-LIST (LENGTH DATA) (X)))))
                            (T (LIST (CONSTANT-RAM (CAR STATE)
                                                   (MAKE-LIST 32 (X)))
                                     0
                                     (CADDR STATE)
                                     0 T
                                     (THREEFIX RW-)
                                     (V-THREEFIX ADDRESS)
                                     (IF (BOOLP RW-)
                                         (IF RW-
                                             (V-THREEFIX (CADDDDDDDR STATE))
                                             (V-THREEFIX DATA))
                                         (MAKE-LIST (LENGTH DATA) (X)))))))
             (RW- (LIST (CONSTANT-RAM (CAR STATE)
                                      (MAKE-LIST 32 (X)))
                        3
                        (CDADDR STATE)
                        (SUB1 (CAADDR STATE))
                        (ZEROP (CAADDR STATE))
                        (THREEFIX RW-)
                        (V-THREEFIX ADDRESS)
                        (IF (BOOLP RW-)
                            (IF RW-
                                (V-THREEFIX (CADDDDDDDR STATE))
                                (V-THREEFIX DATA))
                            (MAKE-LIST (LENGTH DATA) (X)))))
             ((AND (AND (BVP ADDRESS)
                        (BVP (CADDDDDDR STATE))
                        (EQUAL ADDRESS (CADDDDDDR STATE)))
                   (BVP DATA)
                   (BVP (CADDDDDDDR STATE))
                   (EQUAL DATA (CADDDDDDDR STATE)))
              (LIST (CAR STATE)
                    2
                    (CADDR STATE)
                    (SUB1 (CADDDR STATE))
                    (ZEROP (CADDDR STATE))
                    (THREEFIX RW-)
                    (V-THREEFIX ADDRESS)
                    (IF (BOOLP RW-)
                        (IF RW-
                            (V-THREEFIX (CADDDDDDDR STATE))
                            (V-THREEFIX DATA))
                        (MAKE-LIST (LENGTH DATA) (X)))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (OTHERWISE (COND (STROBE- (IF RW-
                                  (LIST (CAR STATE)
                                        0
                                        (CADDR STATE)
                                        0 T
                                        (THREEFIX RW-)
                                        (V-THREEFIX ADDRESS)
                                        (IF (BOOLP RW-)
                                            (IF RW-
                                                (V-THREEFIX (CADDDDDDDR STATE))
                                                (V-THREEFIX DATA))
                                            (MAKE-LIST (LENGTH DATA) (X))))
                                  (LIST (CONSTANT-RAM (CAR STATE)
                                                      (MAKE-LIST 32 (X)))
                                        0
                                        (CADDR STATE)
                                        0 T
                                        (THREEFIX RW-)
                                        (V-THREEFIX ADDRESS)
                                        (IF (BOOLP RW-)
                                            (IF RW-
                                                (V-THREEFIX (CADDDDDDDR STATE))
                                                (V-THREEFIX DATA))
                                            (MAKE-LIST (LENGTH DATA) (X))))))
                     (RW- (LIST (CAR STATE)
                                3
                                (CADDR STATE)
                                (SUB1 (CADDDR STATE))
                                (ZEROP (CADDDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X)))))
                     (T (LIST (CONSTANT-RAM (CAR STATE)
                                            (MAKE-LIST 32 (X)))
                              3
                              (CDADDR STATE)
                              (SUB1 (CAADDR STATE))
                              (ZEROP (CAADDR STATE))
                              (THREEFIX RW-)
                              (V-THREEFIX ADDRESS)
                              (IF (BOOLP RW-)
                                  (IF RW-
                                      (V-THREEFIX (CADDDDDDDR STATE))
                                      (V-THREEFIX DATA))
                                  (MAKE-LIST (LENGTH DATA) (X))))))))
  (LIST (CONSTANT-RAM (CAR STATE)
                      (MAKE-LIST 32 (X)))
        0
        (CADDR STATE)
        0 T
        (THREEFIX RW-)
        (V-THREEFIX ADDRESS)
        (IF (BOOLP RW-)
            (IF RW-
                (V-THREEFIX (CADDDDDDDR STATE))
                (V-THREEFIX DATA))
            (MAKE-LIST (LENGTH DATA) (X))))))

(TOGGLE NEXT-MEMORY-STATE-OFF NEXT-MEMORY-STATE T)

(DEFN MEMORY-VALUE
 (STATE STROBE- RW- ADDRESS DATA)
 (IF* (AND* (BOOLP STROBE-) (BOOLP RW-))
      (CASE (CADR STATE)
            (0 (IF* STROBE-
                    (CONS (X)
                          (MAKE-LIST (LENGTH DATA) (Z)))
                    (CONS (IF* (ZEROP (CAADDR STATE)) F T)
                          (IF* RW-
                               (MAKE-LIST (LENGTH DATA) (X))
                               (MAKE-LIST (LENGTH DATA) (Z))))))
            (1 (IF* STROBE-
                    (CONS (X)
                          (MAKE-LIST (LENGTH DATA) (Z)))
                    (IF* RW-
                         (IF* (AND* (EQUAL ADDRESS (CADDDDDDR STATE))
                                    (AND* (BVP ADDRESS)
                                          (BVP (CADDDDDDR STATE))))
                              (IF* (ZEROP (CADDDR STATE))
                                   (CONS F
                                         (IF* (CADDDDR STATE)
                                              (READ-MEM ADDRESS (CAR STATE))
                                              (MAKE-LIST (LENGTH DATA) (X))))
                                   (CONS T
                                         (MAKE-LIST (LENGTH DATA) (X))))
                              (IF* (ZEROP (CADDDR STATE))
                                   (CONS F (MAKE-LIST (LENGTH DATA) (X)))
                                   (CONS T
                                         (MAKE-LIST (LENGTH DATA) (X)))))
                         (IF* (ZEROP (CADDDR STATE))
                              (CONS F (MAKE-LIST (LENGTH DATA) (Z)))
                              (CONS T
                                    (MAKE-LIST (LENGTH DATA) (Z)))))))
            (2 (IF* STROBE-
                    (CONS (X)
                          (MAKE-LIST (LENGTH DATA) (Z)))
                    (IF* (ZEROP (CADDDR STATE))
                         (CONS F (MAKE-LIST (LENGTH DATA) (Z)))
                         (CONS T
                               (MAKE-LIST (LENGTH DATA) (Z))))))
            (OTHERWISE (IF* STROBE-
                            (CONS (X)
                                  (MAKE-LIST (LENGTH DATA) (Z)))
                            (IF* RW-
                                 (IF* (ZEROP (CADDDR STATE))
                                      (CONS F (MAKE-LIST (LENGTH DATA) (X)))
                                      (CONS T
                                            (MAKE-LIST (LENGTH DATA) (X))))
                                 (IF* (ZEROP (CADDDR STATE))
                                      (CONS F (MAKE-LIST (LENGTH DATA) (Z)))
                                      (CONS T
                                            (MAKE-LIST (LENGTH DATA) (Z))))))))
      (CONS (X)
            (MAKE-LIST (LENGTH DATA) (X)))))

(TOGGLE MEMORY-VALUE-OFF MEMORY-VALUE T)

(DEFN MEM-VALUE
      (ARGS STATE)
      (MEMORY-VALUE STATE
                    (CADR ARGS)
                    (CAR ARGS)
                    (SUBRANGE ARGS 2 33)
                    (SUBRANGE ARGS 34 65)))

(TOGGLE MEM-VALUE-OFF MEM-VALUE T)

(DEFN MEM-STATE
      (ARGS STATE)
      (NEXT-MEMORY-STATE STATE
                         (CADR ARGS)
                         (CAR ARGS)
                         (SUBRANGE ARGS 2 33)
                         (SUBRANGE ARGS 34 65)))

(TOGGLE MEM-STATE-OFF MEM-STATE T)

(PROVE-LEMMA PROPERP-LENGTH-MEMORY-VALUE
             (REWRITE)
             (IMPLIES (AND (MEMORY-PROPERP 32 32 (CAR STATE))
                           (EQUAL (LENGTH ADDRESS) 32)
                           (EQUAL (LENGTH DATA) 32))
                      (AND (PROPERP (CDR (MEMORY-VALUE STATE STROBE RW-
                                                       ADDRESS DATA)))
                           (EQUAL (LENGTH (CDR (MEMORY-VALUE STATE STROBE
                                                             RW- ADDRESS
                                                             DATA)))
                                  32)))
             ((ENABLE MEMORY-VALUE)
              (DISABLE *1*MAKE-LIST)))

(PROVE-LEMMA EQUAL-MEMORY-VALUE
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH DATA1) (LENGTH DATA2))
                      (EQUAL (EQUAL (MEMORY-VALUE STATE STROBE RW- ADDRESS
                                                  DATA1)
                                    (MEMORY-VALUE STATE STROBE RW- ADDRESS
                                                  DATA2))
                             T))
             ((ENABLE MEMORY-VALUE)))

(DEFN NEXT-MEMORY-STATE$INDUCTION
 (STATE STROBE- RW- ADDRESS DATA)
 (COND
  ((AND (BOOLP STROBE-) (BOOLP RW-))
   (CASE
    (CADR STATE)
    (0 (COND (STROBE- (LIST (CAR STATE)
                            0
                            (CADDR STATE)
                            0 T
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X)))))
             (RW- (IF (AND (CADDDDDR STATE)
                           (BOOLP (CADDDDDR STATE)))
                      (IF (AND (BVP ADDRESS)
                               (BVP (CADDDDDDR STATE))
                               (EQUAL ADDRESS (CADDDDDDR STATE)))
                          (LIST (CAR STATE)
                                1
                                (CDADDR STATE)
                                (SUB1 (CAADDR STATE))
                                (ZEROP (CAADDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))
                          (LIST (CAR STATE)
                                3
                                (CDADDR STATE)
                                (SUB1 (CAADDR STATE))
                                (ZEROP (CAADDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X)))))
                      (LIST (CONSTANT-RAM (CAR STATE)
                                          (MAKE-LIST 32 (X)))
                            3
                            (CDADDR STATE)
                            (SUB1 (CAADDR STATE))
                            (ZEROP (CAADDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))))
             ((AND (NOT (CADDDDDR STATE))
                   (AND (BVP ADDRESS)
                        (BVP (CADDDDDDR STATE))
                        (EQUAL ADDRESS (CADDDDDDR STATE)))
                   (BVP DATA)
                   (BVP (CADDDDDDDR STATE))
                   (EQUAL DATA (CADDDDDDDR STATE)))
              (LIST (CAR STATE)
                    2
                    (CDADDR STATE)
                    (SUB1 (CAADDR STATE))
                    (ZEROP (CAADDR STATE))
                    (THREEFIX RW-)
                    (V-THREEFIX ADDRESS)
                    (IF (BOOLP RW-)
                        (IF RW-
                            (V-THREEFIX (CADDDDDDDR STATE))
                            (V-THREEFIX DATA))
                        (MAKE-LIST (LENGTH DATA) (X)))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (1 (COND (STROBE- (IF RW-
                          (LIST (CAR STATE)
                                0
                                (CADDR STATE)
                                0 T
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))
                          (LIST (CONSTANT-RAM (CAR STATE)
                                              (MAKE-LIST 32 (X)))
                                0
                                (CADDR STATE)
                                0 T
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X))))))
             (RW- (IF (AND (BVP ADDRESS)
                           (BVP (CADDDDDDR STATE))
                           (EQUAL ADDRESS (CADDDDDDR STATE)))
                      (LIST (CAR STATE)
                            1
                            (CADDR STATE)
                            (SUB1 (CADDDR STATE))
                            (ZEROP (CADDDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))
                      (LIST (CAR STATE)
                            3
                            (CDADDR STATE)
                            (SUB1 (CAADDR STATE))
                            (ZEROP (CAADDR STATE))
                            (THREEFIX RW-)
                            (V-THREEFIX ADDRESS)
                            (IF (BOOLP RW-)
                                (IF RW-
                                    (V-THREEFIX (CADDDDDDDR STATE))
                                    (V-THREEFIX DATA))
                                (MAKE-LIST (LENGTH DATA) (X))))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (2 (COND (STROBE- (COND (RW- (LIST (CONSTANT-RAM (CAR STATE)
                                                     (MAKE-LIST 32 (X)))
                                       0
                                       (CADDR STATE)
                                       0 T
                                       (THREEFIX RW-)
                                       (V-THREEFIX ADDRESS)
                                       (IF (BOOLP RW-)
                                           (IF RW-
                                               (V-THREEFIX (CADDDDDDDR STATE))
                                               (V-THREEFIX DATA))
                                           (MAKE-LIST (LENGTH DATA) (X)))))
                            ((AND (AND (BVP ADDRESS)
                                       (BVP (CADDDDDDR STATE))
                                       (EQUAL ADDRESS (CADDDDDDR STATE)))
                                  (AND (BVP DATA)
                                       (BVP (CADDDDDDDR STATE))
                                       (EQUAL DATA (CADDDDDDDR STATE)))
                                  (ZEROP (CADDDR STATE)))
                             (LIST (WRITE-MEM ADDRESS (CAR STATE) DATA)
                                   0
                                   (CADDR STATE)
                                   0 T
                                   (THREEFIX RW-)
                                   (V-THREEFIX ADDRESS)
                                   (IF (BOOLP RW-)
                                       (IF RW-
                                           (V-THREEFIX (CADDDDDDDR STATE))
                                           (V-THREEFIX DATA))
                                       (MAKE-LIST (LENGTH DATA) (X)))))
                            (T (LIST (CONSTANT-RAM (CAR STATE)
                                                   (MAKE-LIST 32 (X)))
                                     0
                                     (CADDR STATE)
                                     0 T
                                     (THREEFIX RW-)
                                     (V-THREEFIX ADDRESS)
                                     (IF (BOOLP RW-)
                                         (IF RW-
                                             (V-THREEFIX (CADDDDDDDR STATE))
                                             (V-THREEFIX DATA))
                                         (MAKE-LIST (LENGTH DATA) (X)))))))
             (RW- (LIST (CONSTANT-RAM (CAR STATE)
                                      (MAKE-LIST 32 (X)))
                        3
                        (CDADDR STATE)
                        (SUB1 (CAADDR STATE))
                        (ZEROP (CAADDR STATE))
                        (THREEFIX RW-)
                        (V-THREEFIX ADDRESS)
                        (IF (BOOLP RW-)
                            (IF RW-
                                (V-THREEFIX (CADDDDDDDR STATE))
                                (V-THREEFIX DATA))
                            (MAKE-LIST (LENGTH DATA) (X)))))
             ((AND (AND (BVP ADDRESS)
                        (BVP (CADDDDDDR STATE))
                        (EQUAL ADDRESS (CADDDDDDR STATE)))
                   (BVP DATA)
                   (BVP (CADDDDDDDR STATE))
                   (EQUAL DATA (CADDDDDDDR STATE)))
              (LIST (CAR STATE)
                    2
                    (CADDR STATE)
                    (SUB1 (CADDDR STATE))
                    (ZEROP (CADDDR STATE))
                    (THREEFIX RW-)
                    (V-THREEFIX ADDRESS)
                    (IF (BOOLP RW-)
                        (IF RW-
                            (V-THREEFIX (CADDDDDDDR STATE))
                            (V-THREEFIX DATA))
                        (MAKE-LIST (LENGTH DATA) (X)))))
             (T (LIST (CONSTANT-RAM (CAR STATE)
                                    (MAKE-LIST 32 (X)))
                      3
                      (CDADDR STATE)
                      (SUB1 (CAADDR STATE))
                      (ZEROP (CAADDR STATE))
                      (THREEFIX RW-)
                      (V-THREEFIX ADDRESS)
                      (IF (BOOLP RW-)
                          (IF RW-
                              (V-THREEFIX (CADDDDDDDR STATE))
                              (V-THREEFIX DATA))
                          (MAKE-LIST (LENGTH DATA) (X)))))))
    (OTHERWISE (COND (STROBE- (IF RW-
                                  (LIST (CAR STATE)
                                        0
                                        (CADDR STATE)
                                        0 T
                                        (THREEFIX RW-)
                                        (V-THREEFIX ADDRESS)
                                        (IF (BOOLP RW-)
                                            (IF RW-
                                                (V-THREEFIX (CADDDDDDDR STATE))
                                                (V-THREEFIX DATA))
                                            (MAKE-LIST (LENGTH DATA) (X))))
                                  (LIST (CONSTANT-RAM (CAR STATE)
                                                      (MAKE-LIST 32 (X)))
                                        0
                                        (CADDR STATE)
                                        0 T
                                        (THREEFIX RW-)
                                        (V-THREEFIX ADDRESS)
                                        (IF (BOOLP RW-)
                                            (IF RW-
                                                (V-THREEFIX (CADDDDDDDR STATE))
                                                (V-THREEFIX DATA))
                                            (MAKE-LIST (LENGTH DATA) (X))))))
                     (RW- (LIST (CAR STATE)
                                3
                                (CADDR STATE)
                                (SUB1 (CADDDR STATE))
                                (ZEROP (CADDDR STATE))
                                (THREEFIX RW-)
                                (V-THREEFIX ADDRESS)
                                (IF (BOOLP RW-)
                                    (IF RW-
                                        (V-THREEFIX (CADDDDDDDR STATE))
                                        (V-THREEFIX DATA))
                                    (MAKE-LIST (LENGTH DATA) (X)))))
                     (T (LIST (CONSTANT-RAM (CAR STATE)
                                            (MAKE-LIST 32 (X)))
                              3
                              (CDADDR STATE)
                              (SUB1 (CAADDR STATE))
                              (ZEROP (CAADDR STATE))
                              (THREEFIX RW-)
                              (V-THREEFIX ADDRESS)
                              (IF (BOOLP RW-)
                                  (IF RW-
                                      (V-THREEFIX (CADDDDDDDR STATE))
                                      (V-THREEFIX DATA))
                                  (MAKE-LIST (LENGTH DATA) (X)))))))))
  ((NOT (AND (BOOLP STROBE-) (BOOLP RW-)))
   (LIST (CONSTANT-RAM (CAR STATE)
                       (MAKE-LIST 32 (X)))
         0
         (CADDR STATE)
         0 T
         (THREEFIX RW-)
         (V-THREEFIX ADDRESS)
         (IF (BOOLP RW-)
             (IF RW-
                 (V-THREEFIX (CADDDDDDDR STATE))
                 (V-THREEFIX DATA))
             (MAKE-LIST (LENGTH DATA) (X)))))
  (T (NEXT-MEMORY-STATE$INDUCTION (SUB1 STATE)
                                  STROBE- RW- ADDRESS DATA)))
 ((LESSP (COUNT STATE))))

(PROVE-LEMMA PROPERP-LENGTH-NEXT-MEMORY-STATE
             (REWRITE)
             (AND (PROPERP (NEXT-MEMORY-STATE STATE STROBE- RW- ADDRESS DATA))
                  (EQUAL (LENGTH (NEXT-MEMORY-STATE STATE STROBE- RW- ADDRESS
                                                    DATA))
                         8))
             ((INDUCT (NEXT-MEMORY-STATE$INDUCTION STATE STROBE- RW- ADDRESS
                                                   DATA))
              (ENABLE NEXT-MEMORY-STATE)))

(DEFN FIX-BREADTH-TREE-STACK
      (STACK N)
      (IF (NLISTP STACK)
          NIL
          (CONS (APPEND (MAKE-LIST N F) (CAR STACK))
                (FIX-BREADTH-TREE-STACK (CDR STACK)
                                        (TIMES 2 N)))))

(DEFN BREADTH-TREE
      (TREE STACK N)
      (IF (NLISTP TREE)
          (CONS (CONS T
                      (IF (NLISTP STACK)
                          (MAKE-LIST N F)
                          (CAR STACK)))
                (FIX-BREADTH-TREE-STACK (CDR STACK)
                                        2))
          (CONS (CONS T
                      (IF (NLISTP STACK)
                          (MAKE-LIST N F)
                          (CAR STACK)))
                (BREADTH-TREE (CDR TREE)
                              (BREADTH-TREE (CAR TREE)
                                            (CDR STACK)
                                            (TIMES 2 N))
                              (ADD1 (TIMES 2 N))))))

(DEFN COLLECT-BREADTH-TREE
      (STACK N)
      (COND ((NLISTP STACK) NIL)
            ((EQUAL (CAR STACK) (MAKE-LIST N T))
             (CONS T
                   (COLLECT-BREADTH-TREE (CDR STACK)
                                         (TIMES 2 N))))
            (T (CONS F
                     (APPEND (CAR STACK)
                             (COLLECT-BREADTH-TREE (CDR STACK)
                                                   (TIMES 2 N)))))))

(DEFN TREE-NUMBER
      (TREE)
      (QUOTIENT (ADD1 (V-TO-NAT (COLLECT-BREADTH-TREE (BREADTH-TREE TREE NIL 0)
                                                      1)))
                2))

(TOGGLE TREE-NUMBER-OFF TREE-NUMBER T)

(DEFN F-BUF (A) (THREEFIX A))

(DEFN F-AND
      (A B)
      (COND ((OR (EQUAL A F) (EQUAL B F)) F)
            ((AND (EQUAL A T) (EQUAL B T)) T)
            (T (X))))

(DEFN F-AND3
      (A B C)
      (F-AND A (F-AND B C)))

(DEFN F-AND4
      (A B C D)
      (F-AND A (F-AND B (F-AND C D))))

(DEFN F-NOT
      (A)
      (IF (BOOLP A) (NOT A) (X)))

(DEFN F-NAND
      (A B)
      (F-NOT (F-AND A B)))

(DEFN F-NAND3
      (A B C)
      (F-NOT (F-AND A (F-AND B C))))

(DEFN F-NAND4
      (A B C D)
      (F-NOT (F-AND A (F-AND B (F-AND C D)))))

(DEFN F-NAND5
      (A B C D E)
      (F-NOT (F-AND A
                    (F-AND B (F-AND C (F-AND D E))))))

(DEFN F-NAND6
      (A B C D E G)
      (F-NOT (F-AND A
                    (F-AND B
                           (F-AND C (F-AND D (F-AND E G)))))))

(DEFN F-NAND8
      (A B C D E G H I)
      (F-NOT (F-AND A
                    (F-AND B
                           (F-AND C
                                  (F-AND D
                                         (F-AND E (F-AND G (F-AND H I)))))))))

(DEFN F-OR
      (A B)
      (COND ((OR (EQUAL A T) (EQUAL B T)) T)
            ((AND (EQUAL A F) (EQUAL B F)) F)
            (T (X))))

(DEFN F-OR3
      (A B C)
      (F-OR A (F-OR B C)))

(DEFN F-OR4
      (A B C D)
      (F-OR A (F-OR B (F-OR C D))))

(DEFN F-NOR (A B) (F-NOT (F-OR A B)))

(DEFN F-NOR3
      (A B C)
      (F-NOT (F-OR A (F-OR B C))))

(DEFN F-NOR4
      (A B C D)
      (F-NOT (F-OR A (F-OR B (F-OR C D)))))

(DEFN F-NOR5
      (A B C D E)
      (F-NOT (F-OR A
                   (F-OR B (F-OR C (F-OR D E))))))

(DEFN F-NOR6
      (A B C D E G)
      (F-NOT (F-OR A
                   (F-OR B
                         (F-OR C (F-OR D (F-OR E G)))))))

(DEFN F-NOR8
      (A B C D E G H I)
      (F-NOT (F-OR A
                   (F-OR B
                         (F-OR C
                               (F-OR D
                                     (F-OR E (F-OR G (F-OR H I)))))))))

(DEFN F-XOR
      (A B)
      (COND ((EQUAL A T) (F-NOT B))
            ((EQUAL A F) (THREEFIX B))
            (T (X))))

(DEFN F-XOR3
      (A B C)
      (F-XOR A (F-XOR B C)))

(DEFN F-EQUV
      (A B)
      (COND ((EQUAL A T) (THREEFIX B))
            ((EQUAL A F) (F-NOT B))
            (T (X))))

(DEFN F-EQUV3
      (A B C)
      (F-EQUV A (F-XOR B C)))

(DEFN F-IF
      (C A B)
      (COND ((EQUAL C T) (THREEFIX A))
            ((EQUAL C F) (THREEFIX B))
            (T (X))))

(DEFN FT-BUF
      (C A)
      (COND ((EQUAL C T) (THREEFIX A))
            ((EQUAL C F) (Z))
            (T (X))))

(DEFN FT-WIRE
      (A B)
      (COND ((EQUAL A B) (FOURFIX A))
            ((EQUAL A (Z)) (FOURFIX B))
            ((EQUAL B (Z)) (FOURFIX A))
            (T (X))))

(DEFN F-PULLUP
      (A)
      (IF (EQUAL A (Z)) T (THREEFIX A)))

(DEFN F$AO2
      (A B C D)
      (F-NOR (F-AND A B) (F-AND C D)))

(PROVE-LEMMA EXPAND-F-FUNCTIONS
 (REWRITE)
 (AND
  (EQUAL (F-BUF A) (THREEFIX A))
  (EQUAL (F-AND A B)
         (COND ((OR (EQUAL A F) (EQUAL B F)) F)
               ((AND (EQUAL A T) (EQUAL B T)) T)
               (T (X))))
  (EQUAL (F-AND3 A B C)
         (F-AND A (F-AND B C)))
  (EQUAL (F-AND4 A B C D)
         (F-AND A (F-AND B (F-AND C D))))
  (EQUAL (F-NOT A)
         (IF (BOOLP A) (NOT A) (X)))
  (EQUAL (F-NAND A B)
         (F-NOT (F-AND A B)))
  (EQUAL (F-NAND3 A B C)
         (F-NOT (F-AND A (F-AND B C))))
  (EQUAL (F-NAND4 A B C D)
         (F-NOT (F-AND A (F-AND B (F-AND C D)))))
  (EQUAL (F-OR A B)
         (COND ((OR (EQUAL A T) (EQUAL B T)) T)
               ((AND (EQUAL A F) (EQUAL B F)) F)
               (T (X))))
  (EQUAL (F-NAND5 A B C D E)
         (F-NOT (F-AND A
                       (F-AND B (F-AND C (F-AND D E))))))
  (EQUAL (F-NAND6 A B C D E G)
         (F-NOT (F-AND A
                       (F-AND B
                              (F-AND C (F-AND D (F-AND E G)))))))
  (EQUAL
       (F-NAND8 A B C D E G H I)
       (F-NOT (F-AND A
                     (F-AND B
                            (F-AND C
                                   (F-AND D
                                          (F-AND E (F-AND G (F-AND H I)))))))))
  (EQUAL (F-OR3 A B C)
         (F-OR A (F-OR B C)))
  (EQUAL (F-OR4 A B C D)
         (F-OR A (F-OR B (F-OR C D))))
  (EQUAL (F-NOR A B) (F-NOT (F-OR A B)))
  (EQUAL (F-NOR3 A B C)
         (F-NOT (F-OR A (F-OR B C))))
  (EQUAL (F-NOR4 A B C D)
         (F-NOT (F-OR A (F-OR B (F-OR C D)))))
  (EQUAL (F-NOR5 A B C D E)
         (F-NOT (F-OR A
                      (F-OR B (F-OR C (F-OR D E))))))
  (EQUAL (F-NOR6 A B C D E G)
         (F-NOT (F-OR A
                      (F-OR B
                            (F-OR C (F-OR D (F-OR E G)))))))
  (EQUAL (F-NOR8 A B C D E G H I)
         (F-NOT (F-OR A
                      (F-OR B
                            (F-OR C
                                  (F-OR D
                                        (F-OR E (F-OR G (F-OR H I)))))))))
  (EQUAL (F-XOR A B)
         (COND ((EQUAL A T) (F-NOT B))
               ((EQUAL A F) (THREEFIX B))
               (T (X))))
  (EQUAL (F-XOR3 A B C)
         (F-XOR A (F-XOR B C)))
  (EQUAL (F-EQUV A B)
         (COND ((EQUAL A T) (THREEFIX B))
               ((EQUAL A F) (F-NOT B))
               (T (X))))
  (EQUAL (F-EQUV3 A B C)
         (F-EQUV A (F-XOR B C)))
  (EQUAL (F-IF C A B)
         (COND ((EQUAL C T) (THREEFIX A))
               ((EQUAL C F) (THREEFIX B))
               (T (X))))
  (EQUAL (FT-BUF C A)
         (COND ((EQUAL C T) (THREEFIX A))
               ((EQUAL C F) (Z))
               (T (X))))
  (EQUAL (FT-WIRE A B)
         (COND ((EQUAL A B) (FOURFIX A))
               ((EQUAL A (Z)) (FOURFIX B))
               ((EQUAL B (Z)) (FOURFIX A))
               (T (X))))
  (EQUAL (F-PULLUP A)
         (IF (EQUAL A (Z)) T (THREEFIX A)))))

(TOGGLE EXPAND-F-FUNCTIONS-OFF EXPAND-F-FUNCTIONS T)

(PROVE-LEMMA F-BUF-LEMMA
             (REWRITE)
             (IMPLIES (BOOLP X)
                      (EQUAL (F-BUF X) X)))

(PROVE-LEMMA F-AND-REWRITE
             (REWRITE)
             (AND (NOT (F-AND F X))
                  (NOT (F-AND X F))
                  (EQUAL (F-AND X T) (F-BUF X))
                  (EQUAL (F-AND T X) (F-BUF X))
                  (IMPLIES (AND X Y (BOOLP X) (BOOLP Y))
                           (EQUAL (F-AND X Y) T))))

(PROVE-LEMMA F-OR-REWRITE
             (REWRITE)
             (AND (EQUAL (F-OR F F) F)
                  (IMPLIES (AND X (BOOLP X))
                           (EQUAL (F-OR X Y) T))
                  (IMPLIES (AND X (BOOLP X))
                           (EQUAL (F-OR Y X) T))))

(PROVE-LEMMA F-NOT-REWRITE
             (REWRITE)
             (AND (EQUAL (F-NOT T) F)
                  (EQUAL (F-NOT F) T)))

(PROVE-LEMMA FT-BUF-REWRITE
             (REWRITE)
             (AND (EQUAL (FT-BUF T X) (THREEFIX X))
                  (EQUAL (FT-BUF F X) (Z))
                  (EQUAL (FT-BUF C (THREEFIX X))
                         (FT-BUF C X))
                  (EQUAL (FT-BUF (X) X) (X))))

(PROVE-LEMMA F-IF-REWRITE
             (REWRITE)
             (AND (EQUAL (F-IF T A B) (F-BUF A))
                  (EQUAL (F-IF F A B) (F-BUF B))))

(PROVE-LEMMA FT-WIRE-REWRITE
             (REWRITE)
             (AND (EQUAL (FT-WIRE (X) X) (X))
                  (EQUAL (FT-WIRE X (X)) (X))
                  (EQUAL (FT-WIRE X (Z)) (FOURFIX X))
                  (EQUAL (FT-WIRE (Z) X) (FOURFIX X))))

(PROVE-LEMMA F-PULLUP-REWRITE
             (REWRITE)
             (AND (EQUAL (F-PULLUP T) T)
                  (EQUAL (F-PULLUP F) F)
                  (EQUAL (F-PULLUP (X)) (X))
                  (EQUAL (F-PULLUP (Z)) T)))

(PROVE-LEMMA THREEFIX-HELP-LEMMA
             (REWRITE)
             (AND (EQUAL (THREEFIX F) F)
                  (EQUAL (THREEFIX T) T)
                  (EQUAL (THREEFIX (X)) (X))
                  (EQUAL (THREEFIX (F-BUF X))
                         (THREEFIX X))
                  (EQUAL (THREEFIX (F-NOT X)) (F-NOT X))
                  (EQUAL (THREEFIX (F-AND X Y))
                         (F-AND X Y))
                  (EQUAL (THREEFIX (F-OR X Y))
                         (F-OR X Y))
                  (EQUAL (THREEFIX (F-XOR X Y))
                         (F-XOR X Y))
                  (EQUAL (THREEFIX (F-EQUV X Y))
                         (F-EQUV X Y))))

(TOGGLE THREEFIX-HELP-LEMMA-OFF THREEFIX-HELP-LEMMA T)

(PROVE-LEMMA F-NOT-F-NOT=F-BUF
             (REWRITE)
             (EQUAL (F-NOT (F-NOT X)) (F-BUF X)))

(TOGGLE F-NOT-F-NOT=F-BUF-OFF F-NOT-F-NOT=F-BUF T)

(PROVE-LEMMA F-BUF-DELETE-LEMMAS
             (REWRITE)
             (AND (EQUAL (F-BUF (F-BUF A)) (F-BUF A))
                  (EQUAL (F-BUF (F-NOT A)) (F-NOT A))
                  (EQUAL (F-BUF (F-NAND A B))
                         (F-NAND A B))
                  (EQUAL (F-BUF (F-NAND3 A B C))
                         (F-NAND3 A B C))
                  (EQUAL (F-BUF (F-NAND4 A B C D))
                         (F-NAND4 A B C D))
                  (EQUAL (F-BUF (F-NAND5 A B C D E))
                         (F-NAND5 A B C D E))
                  (EQUAL (F-BUF (F-NAND6 A B C D E G))
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-BUF (F-NAND8 A B C D E G H I))
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-BUF (F-OR A B)) (F-OR A B))
                  (EQUAL (F-BUF (F-OR3 A B C))
                         (F-OR3 A B C))
                  (EQUAL (F-BUF (F-OR4 A B C D))
                         (F-OR4 A B C D))
                  (EQUAL (F-BUF (F-XOR A B))
                         (F-XOR A B))
                  (EQUAL (F-BUF (F-XOR3 A B C))
                         (F-XOR3 A B C))
                  (EQUAL (F-BUF (F-EQUV A B))
                         (F-EQUV A B))
                  (EQUAL (F-BUF (F-EQUV3 A B C))
                         (F-EQUV3 A B C))
                  (EQUAL (F-BUF (F-AND A B))
                         (F-AND A B))
                  (EQUAL (F-BUF (F-AND3 A B C))
                         (F-AND3 A B C))
                  (EQUAL (F-BUF (F-AND4 A B C D))
                         (F-AND4 A B C D))
                  (EQUAL (F-BUF (F-NOR A B))
                         (F-NOR A B))
                  (EQUAL (F-BUF (F-NOR3 A B C))
                         (F-NOR3 A B C))
                  (EQUAL (F-BUF (F-NOR4 A B C D))
                         (F-NOR4 A B C D))
                  (EQUAL (F-BUF (F-NOR5 A B C D E))
                         (F-NOR5 A B C D E))
                  (EQUAL (F-BUF (F-NOR6 A B C D E G))
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-BUF (F-NOR8 A B C D E G H I))
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-BUF (F-IF C A B))
                         (F-IF C A B)))
             ((ENABLE THREEFIX-HELP-LEMMA)))

(TOGGLE F-BUF-DELETE-LEMMAS-OFF F-BUF-DELETE-LEMMAS T)

(PROVE-LEMMA F-GATE-THREEFIX-CONGRUENCE-LEMMAS$HELP
             (REWRITE)
             (AND (EQUAL (F-BUF (THREEFIX A)) (F-BUF A))
                  (EQUAL (F-NOT (THREEFIX A)) (F-NOT A))
                  (EQUAL (F-OR (THREEFIX A) B)
                         (F-OR A B))
                  (EQUAL (F-OR A (THREEFIX B))
                         (F-OR A B))
                  (EQUAL (F-XOR (THREEFIX A) B)
                         (F-XOR A B))
                  (EQUAL (F-XOR A (THREEFIX B))
                         (F-XOR A B))
                  (EQUAL (F-EQUV (THREEFIX A) B)
                         (F-EQUV A B))
                  (EQUAL (F-EQUV A (THREEFIX B))
                         (F-EQUV A B))
                  (EQUAL (F-AND (THREEFIX A) B)
                         (F-AND A B))
                  (EQUAL (F-AND A (THREEFIX B))
                         (F-AND A B))
                  (EQUAL (F-IF (THREEFIX C) A B)
                         (F-IF C A B))
                  (EQUAL (F-IF C (THREEFIX A) B)
                         (F-IF C A B))
                  (EQUAL (F-IF C A (THREEFIX B))
                         (F-IF C A B))))

(TOGGLE F-GATE-THREEFIX-CONGRUENCE-LEMMAS$HELP-OFF
        F-GATE-THREEFIX-CONGRUENCE-LEMMAS$HELP T)

(PROVE-LEMMA F-GATE-THREEFIX-CONGRUENCE-LEMMAS
             (REWRITE)
             (AND (EQUAL (F-BUF (THREEFIX A)) (F-BUF A))
                  (EQUAL (F-NOT (THREEFIX A)) (F-NOT A))
                  (EQUAL (F-NAND (THREEFIX A) B)
                         (F-NAND A B))
                  (EQUAL (F-NAND A (THREEFIX B))
                         (F-NAND A B))
                  (EQUAL (F-NAND3 (THREEFIX A) B C)
                         (F-NAND3 A B C))
                  (EQUAL (F-NAND3 A (THREEFIX B) C)
                         (F-NAND3 A B C))
                  (EQUAL (F-NAND3 A (THREEFIX B) C)
                         (F-NAND3 A B C))
                  (EQUAL (F-NAND4 (THREEFIX A) B C D)
                         (F-NAND4 A B C D))
                  (EQUAL (F-NAND4 A (THREEFIX B) C D)
                         (F-NAND4 A B C D))
                  (EQUAL (F-NAND4 A B (THREEFIX C) D)
                         (F-NAND4 A B C D))
                  (EQUAL (F-NAND4 A B C (THREEFIX D))
                         (F-NAND4 A B C D))
                  (EQUAL (F-NAND5 (THREEFIX A) B C D E)
                         (F-NAND5 A B C D E))
                  (EQUAL (F-NAND5 A (THREEFIX B) C D E)
                         (F-NAND5 A B C D E))
                  (EQUAL (F-NAND5 A B (THREEFIX C) D E)
                         (F-NAND5 A B C D E))
                  (EQUAL (F-NAND5 A B C (THREEFIX D) E)
                         (F-NAND5 A B C D E))
                  (EQUAL (F-NAND5 A B C D (THREEFIX E))
                         (F-NAND5 A B C D E))
                  (EQUAL (F-NAND6 (THREEFIX A) B C D E G)
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND6 A (THREEFIX B) C D E G)
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND6 A B (THREEFIX C) D E G)
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND6 A B C (THREEFIX D) E G)
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND6 A B C D (THREEFIX E) G)
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND6 A B C D E (THREEFIX G))
                         (F-NAND6 A B C D E G))
                  (EQUAL (F-NAND8 (THREEFIX A) B C D E G H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A (THREEFIX B) C D E G H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B (THREEFIX C) D E G H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B C (THREEFIX D) E G H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B C D (THREEFIX E) G H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B C D E (THREEFIX G) H I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B C D E G (THREEFIX H) I)
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-NAND8 A B C D E G H (THREEFIX I))
                         (F-NAND8 A B C D E G H I))
                  (EQUAL (F-OR (THREEFIX A) B)
                         (F-OR A B))
                  (EQUAL (F-OR A (THREEFIX B))
                         (F-OR A B))
                  (EQUAL (F-OR3 (THREEFIX A) B C)
                         (F-OR3 A B C))
                  (EQUAL (F-OR3 A (THREEFIX B) C)
                         (F-OR3 A B C))
                  (EQUAL (F-OR3 A (THREEFIX B) C)
                         (F-OR3 A B C))
                  (EQUAL (F-OR4 (THREEFIX A) B C D)
                         (F-OR4 A B C D))
                  (EQUAL (F-OR4 A (THREEFIX B) C D)
                         (F-OR4 A B C D))
                  (EQUAL (F-OR4 A B (THREEFIX C) D)
                         (F-OR4 A B C D))
                  (EQUAL (F-OR4 A B C (THREEFIX D))
                         (F-OR4 A B C D))
                  (EQUAL (F-XOR (THREEFIX A) B)
                         (F-XOR A B))
                  (EQUAL (F-XOR A (THREEFIX B))
                         (F-XOR A B))
                  (EQUAL (F-XOR3 (THREEFIX A) B C)
                         (F-XOR3 A B C))
                  (EQUAL (F-XOR3 A (THREEFIX B) C)
                         (F-XOR3 A B C))
                  (EQUAL (F-XOR3 A (THREEFIX B) C)
                         (F-XOR3 A B C))
                  (EQUAL (F-EQUV (THREEFIX A) B)
                         (F-EQUV A B))
                  (EQUAL (F-EQUV A (THREEFIX B))
                         (F-EQUV A B))
                  (EQUAL (F-EQUV3 (THREEFIX A) B C)
                         (F-EQUV3 A B C))
                  (EQUAL (F-EQUV3 A (THREEFIX B) C)
                         (F-EQUV3 A B C))
                  (EQUAL (F-EQUV3 A (THREEFIX B) C)
                         (F-EQUV3 A B C))
                  (EQUAL (F-AND (THREEFIX A) B)
                         (F-AND A B))
                  (EQUAL (F-AND A (THREEFIX B))
                         (F-AND A B))
                  (EQUAL (F-AND3 (THREEFIX A) B C)
                         (F-AND3 A B C))
                  (EQUAL (F-AND3 A (THREEFIX B) C)
                         (F-AND3 A B C))
                  (EQUAL (F-AND3 A (THREEFIX B) C)
                         (F-AND3 A B C))
                  (EQUAL (F-AND4 (THREEFIX A) B C D)
                         (F-AND4 A B C D))
                  (EQUAL (F-AND4 A (THREEFIX B) C D)
                         (F-AND4 A B C D))
                  (EQUAL (F-AND4 A B (THREEFIX C) D)
                         (F-AND4 A B C D))
                  (EQUAL (F-AND4 A B C (THREEFIX D))
                         (F-AND4 A B C D))
                  (EQUAL (F-NOR (THREEFIX A) B)
                         (F-NOR A B))
                  (EQUAL (F-NOR A (THREEFIX B))
                         (F-NOR A B))
                  (EQUAL (F-NOR3 (THREEFIX A) B C)
                         (F-NOR3 A B C))
                  (EQUAL (F-NOR3 A (THREEFIX B) C)
                         (F-NOR3 A B C))
                  (EQUAL (F-NOR3 A (THREEFIX B) C)
                         (F-NOR3 A B C))
                  (EQUAL (F-NOR4 (THREEFIX A) B C D)
                         (F-NOR4 A B C D))
                  (EQUAL (F-NOR4 A (THREEFIX B) C D)
                         (F-NOR4 A B C D))
                  (EQUAL (F-NOR4 A B (THREEFIX C) D)
                         (F-NOR4 A B C D))
                  (EQUAL (F-NOR4 A B C (THREEFIX D))
                         (F-NOR4 A B C D))
                  (EQUAL (F-NOR5 (THREEFIX A) B C D E)
                         (F-NOR5 A B C D E))
                  (EQUAL (F-NOR5 A (THREEFIX B) C D E)
                         (F-NOR5 A B C D E))
                  (EQUAL (F-NOR5 A B (THREEFIX C) D E)
                         (F-NOR5 A B C D E))
                  (EQUAL (F-NOR5 A B C (THREEFIX D) E)
                         (F-NOR5 A B C D E))
                  (EQUAL (F-NOR5 A B C D (THREEFIX E))
                         (F-NOR5 A B C D E))
                  (EQUAL (F-NOR6 (THREEFIX A) B C D E G)
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR6 A (THREEFIX B) C D E G)
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR6 A B (THREEFIX C) D E G)
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR6 A B C (THREEFIX D) E G)
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR6 A B C D (THREEFIX E) G)
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR6 A B C D E (THREEFIX G))
                         (F-NOR6 A B C D E G))
                  (EQUAL (F-NOR8 (THREEFIX A) B C D E G H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A (THREEFIX B) C D E G H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B (THREEFIX C) D E G H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B C (THREEFIX D) E G H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B C D (THREEFIX E) G H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B C D E (THREEFIX G) H I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B C D E G (THREEFIX H) I)
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-NOR8 A B C D E G H (THREEFIX I))
                         (F-NOR8 A B C D E G H I))
                  (EQUAL (F-IF (THREEFIX C) A B)
                         (F-IF C A B))
                  (EQUAL (F-IF C (THREEFIX A) B)
                         (F-IF C A B))
                  (EQUAL (F-IF C A (THREEFIX B))
                         (F-IF C A B)))
             ((ENABLE F-GATE-THREEFIX-CONGRUENCE-LEMMAS$HELP)
              (DISABLE F-BUF F-NOT F-OR F-AND F-XOR F-EQUV F-IF THREEFIX)))

(TOGGLE F-GATE-THREEFIX-CONGRUENCE-LEMMAS-OFF F-GATE-THREEFIX-CONGRUENCE-LEMMAS
        T)

(DEFTHEORY F-GATES
           (F-BUF F-NOT F-NAND F-NAND3 F-NAND4 F-NAND5 F-NAND6 F-NAND8 F-OR
                  F-OR3 F-OR4 F-XOR F-XOR3 F-EQUV F-EQUV3 F-AND F-AND3 F-AND4
                  F-NOR F-NOR3 F-NOR4 F-NOR5 F-NOR6 F-NOR8 F-IF FT-BUF FT-WIRE
                  F-PULLUP))

(PROVE-LEMMA F-GATES=B-GATES
             (REWRITE)
             (AND (IMPLIES (BOOLP A)
                           (EQUAL (F-BUF A) (B-BUF A)))
                  (IMPLIES (BOOLP A)
                           (EQUAL (F-NOT A) (B-NOT A)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-NAND A B) (B-NAND A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-NAND3 A B C)
                                  (B-NAND3 A B C)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D))
                           (EQUAL (F-NAND4 A B C D)
                                  (B-NAND4 A B C D)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E))
                           (EQUAL (F-NAND5 A B C D E)
                                  (B-NAND5 A B C D E)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E)
                                (BOOLP G))
                           (EQUAL (F-NAND6 A B C D E G)
                                  (B-NAND6 A B C D E G)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E)
                                (BOOLP G)
                                (BOOLP H)
                                (BOOLP I))
                           (EQUAL (F-NAND8 A B C D E G H I)
                                  (B-NAND8 A B C D E G H I)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-OR A B) (B-OR A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-OR3 A B C) (B-OR3 A B C)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D))
                           (EQUAL (F-OR4 A B C D)
                                  (B-OR4 A B C D)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-XOR A B) (B-XOR A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-XOR3 A B C) (B-XOR3 A B C)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-EQUV A B) (B-EQUV A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-EQUV3 A B C)
                                  (B-EQUV3 A B C)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-AND A B) (B-AND A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-AND3 A B C) (B-AND3 A B C)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D))
                           (EQUAL (F-AND4 A B C D)
                                  (B-AND4 A B C D)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B))
                           (EQUAL (F-NOR A B) (B-NOR A B)))
                  (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                           (EQUAL (F-NOR3 A B C) (B-NOR3 A B C)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D))
                           (EQUAL (F-NOR4 A B C D)
                                  (B-NOR4 A B C D)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E))
                           (EQUAL (F-NOR5 A B C D E)
                                  (B-NOR5 A B C D E)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E)
                                (BOOLP G))
                           (EQUAL (F-NOR6 A B C D E G)
                                  (B-NOR6 A B C D E G)))
                  (IMPLIES (AND (BOOLP A)
                                (BOOLP B)
                                (BOOLP C)
                                (BOOLP D)
                                (BOOLP E)
                                (BOOLP G)
                                (BOOLP H)
                                (BOOLP I))
                           (EQUAL (F-NOR8 A B C D E G H I)
                                  (B-NOR8 A B C D E G H I)))
                  (IMPLIES (AND (BOOLP C) (BOOLP A) (BOOLP B))
                           (EQUAL (F-IF C A B) (B-IF C A B))))
             ((ENABLE BOOLP)))

(DEFN FV-OR
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (F-OR (CAR A) (CAR B))
                (FV-OR (CDR A) (CDR B)))))

(TOGGLE FV-OR-OFF FV-OR T)

(PROVE-LEMMA PROPERP-LENGTH-FV-OR
             (REWRITE)
             (AND (PROPERP (FV-OR A B))
                  (EQUAL (LENGTH (FV-OR A B))
                         (LENGTH A)))
             ((ENABLE PROPERP FV-OR LENGTH)))

(PROVE-LEMMA FV-OR=V-OR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (BVP B)
                           (EQUAL (LENGTH A) (LENGTH B)))
                      (EQUAL (FV-OR A B) (V-OR A B)))
             ((ENABLE BVP FV-OR V-OR)))

(DEFN FV-XOR
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (F-XOR (CAR A) (CAR B))
                (FV-XOR (CDR A) (CDR B)))))

(TOGGLE FV-XOR-OFF FV-XOR T)

(PROVE-LEMMA PROPERP-LENGTH-FV-XOR
             (REWRITE)
             (AND (PROPERP (FV-XOR A B))
                  (EQUAL (LENGTH (FV-XOR A B))
                         (LENGTH A)))
             ((ENABLE PROPERP FV-XOR LENGTH)))

(PROVE-LEMMA FV-XOR=V-XOR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (BVP B)
                           (EQUAL (LENGTH A) (LENGTH B)))
                      (EQUAL (FV-XOR A B) (V-XOR A B)))
             ((ENABLE BVP FV-XOR V-XOR)))

(DEFN FV-IF
      (C A B)
      (IF (NLISTP A)
          NIL
          (CONS (F-IF C (CAR A) (CAR B))
                (FV-IF C (CDR A) (CDR B)))))

(TOGGLE FV-IF-OFF FV-IF T)

(PROVE-LEMMA LENGTH-FV-IF
             (REWRITE)
             (EQUAL (LENGTH (FV-IF C A B))
                    (LENGTH A))
             ((ENABLE LENGTH FV-IF)))

(PROVE-LEMMA PROPERP-FV-IF
             (REWRITE)
             (PROPERP (FV-IF C A B))
             ((ENABLE PROPERP FV-IF)))

(PROVE-LEMMA V-THREEFIX-FV-IF
             (REWRITE)
             (EQUAL (V-THREEFIX (FV-IF C A B))
                    (FV-IF C A B))
             ((ENABLE V-THREEFIX FV-IF)))

(PROVE-LEMMA FV-IF-WHEN-BOOLP-C
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (AND (EQUAL (FV-IF T A B) (V-THREEFIX A))
                           (EQUAL (FV-IF F A B) (V-THREEFIX B))))
             ((ENABLE MAKE-LIST V-THREEFIX LENGTH FV-IF)))

(PROVE-LEMMA FV-IF-WHEN-BVP
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (BVP B)
                           (EQUAL (LENGTH A) (LENGTH B)))
                      (EQUAL (FV-IF C A B) (IF* C A B)))
             ((ENABLE IF* BOOLP)))

(PROVE-LEMMA FV-IF-REWRITE
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH B))
                      (EQUAL (FV-IF C A B)
                             (IF (BOOLP C)
                                 (IF C (V-THREEFIX A) (V-THREEFIX B))
                                 (MAKE-LIST (LENGTH A) (X)))))
             ((ENABLE LENGTH FV-IF BOOLP V-THREEFIX MAKE-LIST)))

(TOGGLE FV-IF-REWRITE-OFF FV-IF-REWRITE T)

(PROVE-LEMMA FV-IF-V-THREEFIX
             (REWRITE)
             (AND (EQUAL (FV-IF C (V-THREEFIX A) B)
                         (FV-IF C A B))
                  (EQUAL (FV-IF C A (V-THREEFIX B))
                         (FV-IF C A B)))
             ((ENABLE FV-IF V-THREEFIX)))

(DEFN V-WIRE
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (FT-WIRE (CAR A) (CAR B))
                (V-WIRE (CDR A) (CDR B)))))

(TOGGLE V-WIRE-OFF V-WIRE T)

(PROVE-LEMMA V-WIRE-X-X=X
             (REWRITE)
             (EQUAL (V-WIRE X X) (V-FOURFIX X))
             ((ENABLE V-WIRE V-FOURFIX)))

(PROVE-LEMMA V-WIRE-MAKE-LIST-Z
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH V) N)
                      (AND (EQUAL (V-WIRE (MAKE-LIST N (Z)) V)
                                  (V-FOURFIX V))
                           (EQUAL (V-WIRE V (MAKE-LIST N (Z)))
                                  (V-FOURFIX V))))
             ((INDUCT (NTH N V))
              (ENABLE LENGTH V-WIRE MAKE-LIST V-FOURFIX FOURFIX)))

(PROVE-LEMMA PROPERP-LENGTH-V-WIRE
             (REWRITE)
             (AND (PROPERP (V-WIRE A B))
                  (EQUAL (LENGTH (V-WIRE A B))
                         (LENGTH A)))
             ((ENABLE PROPERP LENGTH V-WIRE)))

(PROVE-LEMMA V-WIRE-MAKE-LIST-X
             (REWRITE)
             (IMPLIES (EQUAL N (LENGTH X))
                      (EQUAL (V-WIRE X (MAKE-LIST N (X)))
                             (MAKE-LIST N (X))))
             ((ENABLE LENGTH V-WIRE MAKE-LIST)))

(DEFN V-PULLUP
      (V)
      (IF (NLISTP V)
          NIL
          (CONS (F-PULLUP (CAR V))
                (V-PULLUP (CDR V)))))

(TOGGLE V-PULLUP-OFF V-PULLUP T)

(PROVE-LEMMA PROPERP-LENGTH-V-PULLUP
             (REWRITE)
             (AND (PROPERP (V-PULLUP V))
                  (EQUAL (LENGTH (V-PULLUP V))
                         (LENGTH V)))
             ((ENABLE PROPERP LENGTH V-PULLUP)))

(PROVE-LEMMA V-PULLUP-BVP
             (REWRITE)
             (IMPLIES (BVP V)
                      (EQUAL (V-PULLUP V) V))
             ((ENABLE V-PULLUP BVP)))

(PROVE-LEMMA V-PULLUP-MAKE-LIST-Z
             (REWRITE)
             (EQUAL (V-PULLUP (MAKE-LIST N (Z)))
                    (MAKE-LIST N T))
             ((ENABLE V-PULLUP MAKE-LIST)))

(DEFN FV-SHIFT-RIGHT
      (A SI)
      (IF (NLISTP A)
          NIL
          (APPEND (V-THREEFIX (CDR A))
                  (LIST (THREEFIX SI)))))

(TOGGLE FV-SHIFT-RIGHT-OFF FV-SHIFT-RIGHT T)

(PROVE-LEMMA FV-SHIFT-RIGHT=V-SHIFT-RIGHT
             (REWRITE)
             (IMPLIES (AND (BOOLP SI) (BVP A))
                      (EQUAL (FV-SHIFT-RIGHT A SI)
                             (V-SHIFT-RIGHT A SI)))
             ((EXPAND (FV-SHIFT-RIGHT A SI)
                      (V-SHIFT-RIGHT A SI))))

(PROVE-LEMMA PROPERP-LENGTH-FV-SHIFT-RIGHT
             (REWRITE)
             (AND (PROPERP (FV-SHIFT-RIGHT A SI))
                  (EQUAL (LENGTH (FV-SHIFT-RIGHT A SI))
                         (LENGTH A)))
             ((ENABLE FV-SHIFT-RIGHT)))

(PROVE-LEMMA V-THREEFIX-FV-SHIFT-RIGHT
             (REWRITE)
             (EQUAL (V-THREEFIX (FV-SHIFT-RIGHT A SI))
                    (FV-SHIFT-RIGHT A SI))
             ((ENABLE FV-SHIFT-RIGHT V-THREEFIX-APPEND)
              (DISABLE APPEND-V-THREEFIX)))

(DEFN VFT-BUF
      (C A)
      (IF (NLISTP A)
          NIL
          (CONS (FT-BUF C (CAR A))
                (VFT-BUF C (CDR A)))))

(TOGGLE VFT-BUF-OFF VFT-BUF T)

(PROVE-LEMMA PROPERP-LENGTH-VFT-BUF
             (REWRITE)
             (AND (PROPERP (VFT-BUF C A))
                  (EQUAL (LENGTH (VFT-BUF C A))
                         (LENGTH A)))
             ((ENABLE PROPERP VFT-BUF LENGTH)))

(PROVE-LEMMA VFT-BUF-LEMMAS
             (REWRITE)
             (AND (EQUAL (VFT-BUF T A) (V-THREEFIX A))
                  (EQUAL (VFT-BUF F A)
                         (MAKE-LIST (LENGTH A) (Z))))
             ((ENABLE VFT-BUF V-THREEFIX MAKE-LIST LENGTH)))

(PROVE-LEMMA VFT-BUF-REWRITE
             (REWRITE)
             (EQUAL (VFT-BUF C A)
                    (COND ((EQUAL C T) (V-THREEFIX A))
                          ((EQUAL C F)
                           (MAKE-LIST (LENGTH A) (Z)))
                          (T (MAKE-LIST (LENGTH A) (X)))))
             ((ENABLE VFT-BUF V-THREEFIX MAKE-LIST LENGTH)))

(TOGGLE VFT-BUF-REWRITE-OFF VFT-BUF-REWRITE T)

(DEFN PRIMP-DATABASE NIL
 (LIST
 '(AO2 (DELAYS ((263 737) (83 392)))
       (DRIVES 10)
       (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
       (INPUTS A B C D)
       (LOADINGS 1 1 1 1)
       (LSI-NAME . AO2)
       (OUT-DEPENDS (A B C D))
       (OUTPUT-TYPES BOOLP)
       (OUTPUTS Z)
       (RESULTS CONS
                (F-NOR (F-AND A B) (F-AND C D))
                'NIL)
       (GATES . 2)
       (PRIMITIVES . 1)
       (TRANSISTORS . 8))
 '(AO4 (DELAYS ((260 895) (82 311)))
       (DRIVES 10)
       (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
       (INPUTS A B C D)
       (LOADINGS 1 1 1 1)
       (LSI-NAME . AO4)
       (OUT-DEPENDS (A B C D))
       (OUTPUT-TYPES BOOLP)
       (OUTPUTS Z)
       (RESULTS CONS
                (F-NAND (F-OR A B) (F-OR C D))
                'NIL)
       (GATES . 2)
       (PRIMITIVES . 1)
       (TRANSISTORS . 8))
 '(AO6 (DELAYS ((260 745) (82 202)))
       (DRIVES 10)
       (INPUT-TYPES BOOLP BOOLP BOOLP)
       (INPUTS A B C)
       (LOADINGS 1 1 1)
       (LSI-NAME . AO6)
       (OUT-DEPENDS (A B C))
       (OUTPUT-TYPES BOOLP)
       (OUTPUTS Z)
       (RESULTS CONS
                (F-NOR (F-AND A B) C)
                'NIL)
       (GATES . 2)
       (PRIMITIVES . 1)
       (TRANSISTORS . 6))
 '(AO7 (DELAYS ((261 486) (83 293)))
       (DRIVES 10)
       (INPUT-TYPES BOOLP BOOLP BOOLP)
       (INPUTS A B C)
       (LOADINGS 1 1 1)
       (LSI-NAME . AO7)
       (OUT-DEPENDS (A B C))
       (OUTPUT-TYPES BOOLP)
       (OUTPUTS Z)
       (RESULTS CONS
                (F-NAND (F-OR A B) C)
                'NIL)
       (GATES . 2)
       (PRIMITIVES . 1)
       (TRANSISTORS . 6))
 '(B-AND (DELAYS ((144 422) (54 707)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP)
         (INPUTS A B)
         (LOADINGS 1 1)
         (LSI-NAME . AN2)
         (OUT-DEPENDS (A B))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-AND A B) 'NIL)
         (GATES . 2)
         (PRIMITIVES . 1)
         (TRANSISTORS . 6))
 '(B-AND3 (DELAYS ((146 663) (58 809)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP)
          (INPUTS A B C)
          (LOADINGS 1 1 1)
          (LSI-NAME . AN3)
          (OUT-DEPENDS (A B C))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-AND3 A B C) 'NIL)
          (GATES . 2)
          (PRIMITIVES . 1)
          (TRANSISTORS . 8))
 '(B-AND4 (DELAYS ((149 934) (60 870)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
          (INPUTS A B C D)
          (LOADINGS 1 1 1 1)
          (LSI-NAME . AN4)
          (OUT-DEPENDS (A B C D))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-AND4 A B C D) 'NIL)
          (GATES . 3)
          (PRIMITIVES . 1)
          (TRANSISTORS . 10))
 '(B-EQUV (DELAYS ((145 742) (67 973)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP)
          (INPUTS A B)
          (LOADINGS 1 2)
          (LSI-NAME . EN)
          (OUT-DEPENDS (A B))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-EQUV A B) 'NIL)
          (GATES . 3)
          (PRIMITIVES . 1)
          (TRANSISTORS . 12))
 '(B-EQUV3 (DELAYS ((151 1806) (79 1580)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP)
           (INPUTS A B C)
           (LOADINGS 1 3 2)
           (LSI-NAME . EN3)
           (OUT-DEPENDS (A B C))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS (F-EQUV3 A B C) 'NIL)
           (GATES . 7)
           (PRIMITIVES . 1)
           (TRANSISTORS . 22))
 '(B-IF (DELAYS ((70 775) (60 1040)))
        (DRIVES 10)
        (INPUT-TYPES BOOLP BOOLP BOOLP)
        (INPUTS S A B)
        (LOADINGS 2 1 1)
        (LSI-NAME MUX21H B A S)
        (OUT-DEPENDS (A B S))
        (OUTPUT-TYPES BOOLP)
        (OUTPUTS Z)
        (RESULTS CONS (F-IF S A B) 'NIL)
        (GATES . 4)
        (PRIMITIVES . 1)
        (TRANSISTORS . 12))
 '(B-NAND (DELAYS ((141 420) (82 161)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP)
          (INPUTS A B)
          (LOADINGS 1 1)
          (LSI-NAME . ND2)
          (OUT-DEPENDS (A B))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-NAND A B) 'NIL)
          (GATES . 1)
          (PRIMITIVES . 1)
          (TRANSISTORS . 4))
 '(B-NAND3 (DELAYS ((142 537) (109 322)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP)
           (INPUTS A B C)
           (LOADINGS 1 1 1)
           (LSI-NAME . ND3)
           (OUT-DEPENDS (A B C))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS (F-NAND3 A B C) 'NIL)
           (GATES . 2)
           (PRIMITIVES . 1)
           (TRANSISTORS . 6))
 '(B-NAND4 (DELAYS ((144 588) (144 418)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
           (INPUTS A B C D)
           (LOADINGS 1 1 1 1)
           (LSI-NAME . ND4)
           (OUT-DEPENDS (A B C D))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS (F-NAND4 A B C D) 'NIL)
           (GATES . 2)
           (PRIMITIVES . 1)
           (TRANSISTORS . 8))
 '(B-NAND5 (DELAYS ((144 1002) (59 1120)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP)
           (INPUTS A B C D E)
           (LOADINGS 1 1 1 1 1)
           (LSI-NAME . ND5)
           (OUT-DEPENDS (A B C D E))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS
                    (F-NAND5 A B C D E)
                    'NIL)
           (GATES . 4)
           (PRIMITIVES . 1)
           (TRANSISTORS . 16))
 '(B-NAND6 (DELAYS ((144 982) (59 1090)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)
           (INPUTS A B C D E G)
           (LOADINGS 1 1 1 1 1 1)
           (LSI-NAME . ND6)
           (OUT-DEPENDS (A B C D E G))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS
                    (F-NAND6 A B C D E G)
                    'NIL)
           (GATES . 5)
           (PRIMITIVES . 1)
           (TRANSISTORS . 18))
 '(B-NAND8 (DELAYS ((144 1042) (60 1360)))
           (DRIVES 10)
           (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)
           (INPUTS A B C D E G H I)
           (LOADINGS 1 1 1 1 1 1 1 1)
           (LSI-NAME . ND8)
           (OUT-DEPENDS (A B C D E G H I))
           (OUTPUT-TYPES BOOLP)
           (OUTPUTS Z)
           (RESULTS CONS
                    (F-NAND8 A B C D E G H I)
                    'NIL)
           (GATES . 6)
           (PRIMITIVES . 1)
           (TRANSISTORS . 22))
 '(B-NBUF (DELAYS ((142 447) (57 213))
                  ((143 302) (52 366)))
          (DRIVES 9 10)
          (INPUT-TYPES BOOLP)
          (INPUTS A)
          (LOADINGS 1)
          (LSI-NAME . IVDA)
          (OUT-DEPENDS (A) (A))
          (OUTPUT-TYPES BOOLP BOOLP)
          (OUTPUTS Y Z)
          (RESULTS CONS
                   (F-NOT A)
                   (CONS (F-BUF A) 'NIL))
          (GATES . 1)
          (PRIMITIVES . 1)
          (TRANSISTORS . 4))
 '(B-NOR (DELAYS ((260 460) (59 170)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP)
         (INPUTS A B)
         (LOADINGS 1 1)
         (LSI-NAME . NR2)
         (OUT-DEPENDS (A B))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-NOR A B) 'NIL)
         (GATES . 1)
         (PRIMITIVES . 1)
         (TRANSISTORS . 4))
 '(B-NOR3 (DELAYS ((384 798) (59 224)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP)
          (INPUTS A B C)
          (LOADINGS 1 1 1)
          (LSI-NAME . NR3)
          (OUT-DEPENDS (A B C))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-NOR3 A B C) 'NIL)
          (GATES . 2)
          (PRIMITIVES . 1)
          (TRANSISTORS . 6))
 '(B-NOR4 (DELAYS ((510 1072) (59 225)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
          (INPUTS A B C D)
          (LOADINGS 1 1 1 1)
          (LSI-NAME . NR4)
          (OUT-DEPENDS (A B C D))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-NOR4 A B C D) 'NIL)
          (GATES . 2)
          (PRIMITIVES . 1)
          (TRANSISTORS . 8))
 '(B-NOR5 (DELAYS ((145 1493) (55 767)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP)
          (INPUTS A B C D E)
          (LOADINGS 1 1 1 1 1)
          (LSI-NAME . NR5)
          (OUT-DEPENDS (A B C D E))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS
                   (F-NOR5 A B C D E)
                   'NIL)
          (GATES . 4)
          (PRIMITIVES . 1)
          (TRANSISTORS . 16))
 '(B-NOR6 (DELAYS ((146 1593) (55 807)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)
          (INPUTS A B C D E G)
          (LOADINGS 1 1 1 1 1 1)
          (LSI-NAME . NR6)
          (OUT-DEPENDS (A B C D E G))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS
                   (F-NOR6 A B C D E G)
                   'NIL)
          (GATES . 5)
          (PRIMITIVES . 1)
          (TRANSISTORS . 18))
 '(B-NOR8 (DELAYS ((146 1853) (54 767)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)
          (INPUTS A B C D E G H I)
          (LOADINGS 1 1 1 1 1 1 1 1)
          (LSI-NAME . NR8)
          (OUT-DEPENDS (A B C D E G H I))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS
                   (F-NOR8 A B C D E G H I)
                   'NIL)
          (GATES . 6)
          (PRIMITIVES . 1)
          (TRANSISTORS . 22))
 '(B-NOT (DELAYS ((70 235) (57 198)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP)
         (INPUTS A)
         (LOADINGS 2)
         (LSI-NAME . IVA)
         (OUT-DEPENDS (A))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-NOT A) 'NIL)
         (GATES . 1)
         (PRIMITIVES . 1)
         (TRANSISTORS . 3))
 '(B-NOT-B4IP (DELAYS ((17 333) (12 124)))
              (DRIVES 128)
              (INPUT-TYPES BOOLP)
              (INPUTS A)
              (LOADINGS 8)
              (LSI-NAME . B4IP)
              (OUT-DEPENDS (A))
              (OUTPUT-TYPES BOOLP)
              (OUTPUTS Z)
              (RESULTS CONS (F-NOT A) 'NIL)
              (GATES . 4)
              (PRIMITIVES . 1)
              (TRANSISTORS . 12))
 '(B-NOT-IVAP (DELAYS ((38 208) (35 126)))
              (DRIVES 20)
              (INPUT-TYPES BOOLP)
              (INPUTS A)
              (LOADINGS 3)
              (LSI-NAME . IVAP)
              (OUT-DEPENDS (A))
              (OUTPUT-TYPES BOOLP)
              (OUTPUTS Z)
              (RESULTS CONS (F-NOT A) 'NIL)
              (GATES . 2)
              (PRIMITIVES . 1)
              (TRANSISTORS . 6))
 '(B-OR (DELAYS ((143 332) (58 819)))
        (DRIVES 10)
        (INPUT-TYPES BOOLP BOOLP)
        (INPUTS A B)
        (LOADINGS 1 1)
        (LSI-NAME . OR2)
        (OUT-DEPENDS (A B))
        (OUTPUT-TYPES BOOLP)
        (OUTPUTS Z)
        (RESULTS CONS (F-OR A B) 'NIL)
        (GATES . 2)
        (PRIMITIVES . 1)
        (TRANSISTORS . 6))
 '(B-OR3 (DELAYS ((144 422) (70 1185)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP BOOLP)
         (INPUTS A B C)
         (LOADINGS 1 1 1)
         (LSI-NAME . OR3)
         (OUT-DEPENDS (A B C))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-OR3 A B C) 'NIL)
         (GATES . 2)
         (PRIMITIVES . 1)
         (TRANSISTORS . 8))
 '(B-OR4 (DELAYS ((143 352) (78 1329)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP)
         (INPUTS A B C D)
         (LOADINGS 1 1 1 1)
         (LSI-NAME . OR4)
         (OUT-DEPENDS (A B C D))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-OR4 A B C D) 'NIL)
         (GATES . 3)
         (PRIMITIVES . 1)
         (TRANSISTORS . 10))
 '(B-XOR (DELAYS ((145 742) (67 973)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP)
         (INPUTS A B)
         (LOADINGS 1 2)
         (LSI-NAME . EO)
         (OUT-DEPENDS (A B))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-XOR A B) 'NIL)
         (GATES . 3)
         (PRIMITIVES . 1)
         (TRANSISTORS . 12))
 '(B-XOR3 (DELAYS ((151 1806) (79 1580)))
          (DRIVES 10)
          (INPUT-TYPES BOOLP BOOLP BOOLP)
          (INPUTS A B C)
          (LOADINGS 1 3 2)
          (LSI-NAME . EO3)
          (OUT-DEPENDS (A B C))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-XOR3 A B C) 'NIL)
          (GATES . 7)
          (PRIMITIVES . 1)
          (TRANSISTORS . 22))
 '(DEL2 (DELAYS ((70 2035) (38 2199)))
        (DRIVES 10)
        (INPUT-TYPES BOOLP)
        (INPUTS A)
        (LOADINGS 1)
        (LSI-NAME . DEL2)
        (OUT-DEPENDS (A))
        (OUTPUT-TYPES BOOLP)
        (OUTPUTS Z)
        (RESULTS CONS (F-BUF A) 'NIL)
        (GATES . 4)
        (PRIMITIVES . 1)
        (TRANSISTORS . 16))
 '(DEL4 (DELAYS ((73 4017) (38 4179)))
        (DRIVES 10)
        (INPUT-TYPES BOOLP)
        (INPUTS A)
        (LOADINGS 1)
        (LSI-NAME . DEL4)
        (OUT-DEPENDS (A))
        (OUTPUT-TYPES BOOLP)
        (OUTPUTS Z)
        (RESULTS CONS (F-BUF A) 'NIL)
        (GATES . 7)
        (PRIMITIVES . 1)
        (TRANSISTORS . 28))
 '(DEL10 (DELAYS ((60 10530) (49 10424)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP)
         (INPUTS A)
         (LOADINGS 1)
         (LSI-NAME . DEL10)
         (OUT-DEPENDS (A))
         (OUTPUT-TYPES BOOLP)
         (OUTPUTS Z)
         (RESULTS CONS (F-BUF A) 'NIL)
         (GATES . 19)
         (PRIMITIVES . 1)
         (TRANSISTORS . 76))
 (LIST 'PROCMON
       '(DELAYS ((70 25000) (60 25000)))
       '(DRIVES 10)
       '(INPUT-TYPES PARAMETRIC PARAMETRIC PARAMETRIC PARAMETRIC)
       '(INPUTS A E S N)
       '(LOADINGS 2 2 2 1)
       '(LSI-NAME . PROCMON)
       '(OUT-DEPENDS (A E S N))
       '(OUTPUT-TYPES PARAMETRIC)
       '(OUTPUTS Z)
       (LIST 'RESULTS
             'CONS
             (LIST 'F-IF
                   'S
                   (LIST 'F-IF
                         'E
                         (LIST 'F-IF
                               'A
                               (LIST 'QUOTE F)
                               (LIST 'QUOTE F))
                         'A)
                   'N)
             ''NIL)
       '(GATES . 100)
       '(PRIMITIVES . 1)
       '(TRANSISTORS . 400))
 '(DP-RAM-16X32
   (DELAYS ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500))
           ((35 7500) (21 7500)))
   (DRIVES 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)
   (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP LEVEL BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP)
   (INPUTS READ-A0 READ-A1 READ-A2 READ-A3 WRITE-B0 WRITE-B1 WRITE-B2 WRITE-B3
           WEN D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 D14 D15 D16 D17
           D18 D19 D20 D21 D22 D23 D24 D25 D26 D27 D28 D29 D30 D31)
   (LOADINGS 2 2 2 2 2 2 2 2 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
             1 1 1 1 1 1 1 1)
   (LSI-NAME . CMRB100A)
   (NEW-STATES DUAL-PORT-RAM-STATE '32
    '4
    (CONS READ-A0
     (CONS READ-A1
      (CONS READ-A2
       (CONS READ-A3
        (CONS WRITE-B0
         (CONS WRITE-B1
          (CONS WRITE-B2
           (CONS WRITE-B3
            (CONS WEN
             (CONS D0
              (CONS D1
               (CONS D2
                (CONS D3
                 (CONS D4
                  (CONS D5
                   (CONS D6
                    (CONS D7
                     (CONS D8
                      (CONS D9
                       (CONS D10
                        (CONS D11
                         (CONS D12
                          (CONS D13
                           (CONS D14
                            (CONS D15
                             (CONS D16
                              (CONS D17
                               (CONS D18
                                (CONS D19
                                 (CONS D20
                                  (CONS D21
                                   (CONS D22
                                    (CONS D23
                                     (CONS
                                      D24
                                      (CONS
                                       D25
                                       (CONS
                                        D26
                                        (CONS
                                         D27
                                         (CONS
                                          D28
                                          (CONS
                                           D29
                                           (CONS
                                            D30
                                            (CONS D31
                                                       'NIL)))))))))))))))))))))))))))))))))))))))))
    STATE)
   (OUTPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                 BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                 BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                 BOOLP BOOLP)
   (OUT-DEPENDS (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3)
                (READ-A0 READ-A1 READ-A2 READ-A3))
   (OUTPUTS O0 O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 O11 O12 O13 O14 O15 O16 O17 O18
            O19 O20 O21 O22 O23 O24 O25 O26 O27 O28 O29 O30 O31)
   (RESULTS DUAL-PORT-RAM-VALUE '32
    '4
    (CONS READ-A0
     (CONS READ-A1
      (CONS READ-A2
       (CONS READ-A3
        (CONS WRITE-B0
         (CONS WRITE-B1
          (CONS WRITE-B2
           (CONS WRITE-B3
            (CONS WEN
             (CONS D0
              (CONS D1
               (CONS D2
                (CONS D3
                 (CONS D4
                  (CONS D5
                   (CONS D6
                    (CONS D7
                     (CONS D8
                      (CONS D9
                       (CONS D10
                        (CONS D11
                         (CONS D12
                          (CONS D13
                           (CONS D14
                            (CONS D15
                             (CONS D16
                              (CONS D17
                               (CONS D18
                                (CONS D19
                                 (CONS D20
                                  (CONS D21
                                   (CONS D22
                                    (CONS D23
                                     (CONS
                                      D24
                                      (CONS
                                       D25
                                       (CONS
                                        D26
                                        (CONS
                                         D27
                                         (CONS
                                          D28
                                          (CONS
                                           D29
                                           (CONS
                                            D30
                                            (CONS D31
                                                       'NIL)))))))))))))))))))))))))))))))))))))))))
    STATE)
   (STATE-TYPES ADDRESSED-STATE 4
                (RAM '(BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                             BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                             BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                             BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)))
   (STATES . STATE)
   (GATES . 2368)
   (PRIMITIVES . 1)
   (TRANSISTORS . 9472))
 '(FD1 (DELAYS ((147 1024) (55 1288))
               ((145 1432) (53 1447)))
       (DRIVES 10 10)
       (INPUT-TYPES BOOLP CLK)
       (INPUTS D CP)
       (LOADINGS 1 1)
       (LSI-NAME . FD1)
       (NEW-STATES F-BUF D)
       (OUT-DEPENDS NIL NIL)
       (OUTPUT-TYPES BOOLP BOOLP)
       (OUTPUTS Q QN)
       (RESULTS CONS
                (F-BUF STATE)
                (CONS (F-NOT STATE) 'NIL))
       (STATE-TYPES . BOOLP)
       (STATES . STATE)
       (GATES . 7)
       (PRIMITIVES . 1)
       (TRANSISTORS . 26))
 '(FD1S (DELAYS ((147 1024) (55 1288))
                ((145 1432) (53 1447)))
        (DRIVES 10 10)
        (INPUT-TYPES BOOLP CLK BOOLP BOOLP)
        (INPUTS D CP TI TE)
        (LOADINGS 1 1 1 2)
        (LSI-NAME . FD1S)
        (NEW-STATES F-IF TE TI D)
        (OUT-DEPENDS NIL NIL)
        (OUTPUT-TYPES BOOLP BOOLP)
        (OUTPUTS Q QN)
        (RESULTS CONS
                 (F-BUF STATE)
                 (CONS (F-NOT STATE) 'NIL))
        (STATE-TYPES . BOOLP)
        (STATES . STATE)
        (GATES . 9)
        (PRIMITIVES . 1)
        (TRANSISTORS . 34))
 '(FD1SP (DELAYS ((68 1084) (34 1327))
                 ((65 1712) (32 1596)))
         (DRIVES 16 16)
         (INPUT-TYPES BOOLP CLK BOOLP BOOLP)
         (INPUTS D CP TI TE)
         (LOADINGS 1 1 1 2)
         (LSI-NAME . FD1SP)
         (NEW-STATES F-IF TE TI D)
         (OUT-DEPENDS NIL NIL)
         (OUTPUT-TYPES BOOLP BOOLP)
         (OUTPUTS Q QN)
         (RESULTS CONS
                  (F-BUF STATE)
                  (CONS (F-NOT STATE) 'NIL))
         (STATE-TYPES . BOOLP)
         (STATES . STATE)
         (GATES . 10)
         (PRIMITIVES . 1)
         (TRANSISTORS . 38))
 '(FD1SLP (DELAYS ((70 1085) (45 982))
                  ((67 1493) (35 1568)))
          (DRIVES 12 12)
          (INPUT-TYPES BOOLP CLK BOOLP BOOLP BOOLP)
          (INPUTS D CP LD TI TE)
          (LOADINGS 1 1 2 1 2)
          (LSI-NAME . FD1SLP)
          (NEW-STATES F-IF TE TI
                      (F-IF LD D STATE))
          (OUT-DEPENDS NIL NIL)
          (OUTPUT-TYPES BOOLP BOOLP)
          (OUTPUTS Q QN)
          (RESULTS CONS
                   (F-BUF STATE)
                   (CONS (F-NOT STATE) 'NIL))
          (STATE-TYPES . BOOLP)
          (STATES . STATE)
          (GATES . 12)
          (PRIMITIVES . 1)
          (TRANSISTORS . 40))
 '(ID (DELAYS A)
      (DRIVES A)
      (INPUT-TYPES FREE)
      (INPUTS A)
      (LOADINGS 0)
      (LSI-NAME . ID)
      (OUT-DEPENDS (A))
      (OUTPUT-TYPES (A))
      (OUTPUTS Z)
      (RESULTS CONS A 'NIL)
      (GATES . 0)
      (PRIMITIVES . 0)
      (TRANSISTORS . 0))
 '(MEM-32X32
   (DELAYS ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000))
           ((1410 20000) (820 20000)))
   (DRIVES 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
           10 10 10 10 10 10 10 10 10 10 10)
   (INPUT-TYPES BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP)
   (INPUTS RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15
           A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28 A29 A30 A31 D0
           D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 D14 D15 D16 D17 D18 D19
           D20 D21 D22 D23 D24 D25 D26 D27 D28 D29 D30 D31)
   (LOADINGS 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
   (LSI-NAME . MEM-32X32)
   (NEW-STATES MEM-STATE
    (CONS RW-
     (CONS STROBE-
      (CONS A0
       (CONS A1
        (CONS A2
         (CONS A3
          (CONS A4
           (CONS A5
            (CONS A6
             (CONS A7
              (CONS A8
               (CONS A9
                (CONS A10
                 (CONS A11
                  (CONS A12
                   (CONS A13
                    (CONS A14
                     (CONS A15
                      (CONS A16
                       (CONS A17
                        (CONS A18
                         (CONS A19
                          (CONS A20
                           (CONS A21
                            (CONS A22
                             (CONS A23
                              (CONS A24
                               (CONS A25
                                (CONS A26
                                 (CONS A27
                                  (CONS A28
                                   (CONS A29
                                    (CONS A30
                                     (CONS
                                      A31
                                      (CONS
                                       D0
                                       (CONS
                                        D1
                                        (CONS
                                         D2
                                         (CONS
                                          D3
                                          (CONS
                                           D4
                                           (CONS
                                            D5
                                            (CONS
                                             D6
                                             (CONS
                                              D7
                                              (CONS
                                               D8
                                               (CONS
                                                D9
                                                (CONS
                                                 D10
                                                 (CONS
                                                  D11
                                                  (CONS
                                                   D12
                                                   (CONS
                                                    D13
                                                    (CONS
                                                     D14
                                                     (CONS
                                                      D15
                                                      (CONS
                                                       D16
                                                       (CONS
                                                        D17
                                                        (CONS
                                                         D18
                                                         (CONS
                                                          D19
                                                          (CONS
                                                           D20
                                                           (CONS
                                                            D21
                                                            (CONS
                                                             D22
                                                             (CONS
                                                              D23
                                                              (CONS
                                                               D24
                                                               (CONS
                                                                D25
                                                                (CONS
                                                                 D26
                                                                 (CONS
                                                                  D27
                                                                  (CONS
                                                                   D28
                                                                   (CONS
                                                                    D29
                                                                    (CONS
                                                                     D30
                                                                     (CONS D31
                                                                                                                                  'NIL))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    STATE)
   (OUT-DEPENDS (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
                     A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                     A29 A30 A31)
                (RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13
                     A14 A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27
                     A28 A29 A30 A31))
   (OUTPUT-TYPES BOOLP TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE
                 TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE
                 TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE
                 TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE
                 TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE TRI-STATE
                 TRI-STATE TRI-STATE TRI-STATE)
   (OUTPUTS DTACK- O0 O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 O11 O12 O13 O14 O15 O16
            O17 O18 O19 O20 O21 O22 O23 O24 O25 O26 O27 O28 O29 O30 O31)
   (RESULTS MEM-VALUE
    (CONS RW-
     (CONS STROBE-
      (CONS A0
       (CONS A1
        (CONS A2
         (CONS A3
          (CONS A4
           (CONS A5
            (CONS A6
             (CONS A7
              (CONS A8
               (CONS A9
                (CONS A10
                 (CONS A11
                  (CONS A12
                   (CONS A13
                    (CONS A14
                     (CONS A15
                      (CONS A16
                       (CONS A17
                        (CONS A18
                         (CONS A19
                          (CONS A20
                           (CONS A21
                            (CONS A22
                             (CONS A23
                              (CONS A24
                               (CONS A25
                                (CONS A26
                                 (CONS A27
                                  (CONS A28
                                   (CONS A29
                                    (CONS A30
                                     (CONS
                                      A31
                                      (CONS
                                       D0
                                       (CONS
                                        D1
                                        (CONS
                                         D2
                                         (CONS
                                          D3
                                          (CONS
                                           D4
                                           (CONS
                                            D5
                                            (CONS
                                             D6
                                             (CONS
                                              D7
                                              (CONS
                                               D8
                                               (CONS
                                                D9
                                                (CONS
                                                 D10
                                                 (CONS
                                                  D11
                                                  (CONS
                                                   D12
                                                   (CONS
                                                    D13
                                                    (CONS
                                                     D14
                                                     (CONS
                                                      D15
                                                      (CONS
                                                       D16
                                                       (CONS
                                                        D17
                                                        (CONS
                                                         D18
                                                         (CONS
                                                          D19
                                                          (CONS
                                                           D20
                                                           (CONS
                                                            D21
                                                            (CONS
                                                             D22
                                                             (CONS
                                                              D23
                                                              (CONS
                                                               D24
                                                               (CONS
                                                                D25
                                                                (CONS
                                                                 D26
                                                                 (CONS
                                                                  D27
                                                                  (CONS
                                                                   D28
                                                                   (CONS
                                                                    D29
                                                                    (CONS
                                                                     D30
                                                                     (CONS D31
                                                                                                                                  'NIL))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    STATE)
   (STATE-TYPES (ADDRESSED-STATE 32
                                 (RAM '(BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP BOOLP BOOLP BOOLP BOOLP
                                              BOOLP)))
                NUMBERP NUMBER-LISTP NUMBERP BOOLP BOOLP
                (BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP)
                (BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP BOOLP
                       BOOLP BOOLP BOOLP BOOLP))
   (STATES . STATE)
   (GATES . 0)
   (PRIMITIVES . 1)
   (TRANSISTORS . 0))
 '(RAM-ENABLE-CIRCUIT (DELAYS ((68 12000) (54 12000)))
                      (DRIVES 10)
                      (INPUT-TYPES CLK BOOLP BOOLP BOOLP)
                      (INPUTS CLK TEST-REGFILE- DISABLE-REGFILE- WE)
                      (LOADINGS 1 2 2 2)
                      (LSI-NAME . RAM-ENABLE-CIRCUIT)
                      (OUT-DEPENDS (CLK TEST-REGFILE- DISABLE-REGFILE- WE))
                      (OUTPUT-TYPES LEVEL)
                      (OUTPUTS Z)
                      (RESULTS CONS
                               (F-NAND DISABLE-REGFILE- WE)
                               'NIL)
                      (GATES . 24)
                      (PRIMITIVES . 1)
                      (TRANSISTORS . 97))
 '(T-BUF (DELAYS ((146 313) (57 728)))
         (DRIVES 10)
         (INPUT-TYPES BOOLP BOOLP)
         (INPUTS E A)
         (LOADINGS 2 2)
         (LSI-NAME BTS4 A E)
         (OUT-DEPENDS (A E))
         (OUTPUT-TYPES TRI-STATE)
         (OUTPUTS Z)
         (RESULTS CONS (FT-BUF E A) 'NIL)
         (GATES . 3)
         (PRIMITIVES . 1)
         (TRANSISTORS . 12))
 '(T-WIRE (DELAYS (OR A B))
          (DRIVES (MIN A B))
          (INPUT-TYPES TRI-STATE TRI-STATE)
          (INPUTS A B)
          (LOADINGS 1 1)
          (LSI-NAME . T-WIRE)
          (OUT-DEPENDS (A B))
          (OUTPUT-TYPES TRI-STATE)
          (OUTPUTS Z)
          (RESULTS CONS (FT-WIRE A B) 'NIL)
          (GATES . 0)
          (PRIMITIVES . 0)
          (TRANSISTORS . 0))
 '(PULLUP (DELAYS A)
          (DRIVES A)
          (INPUT-TYPES TRI-STATE)
          (INPUTS A)
          (LOADINGS 1)
          (LSI-NAME . PULLUP)
          (OUT-DEPENDS (A))
          (OUTPUT-TYPES BOOLP)
          (OUTPUTS Z)
          (RESULTS CONS (F-PULLUP A) 'NIL)
          (GATES . 0)
          (PRIMITIVES . 0)
          (TRANSISTORS . 0))
 '(TTL-BIDIRECT (DELAYS (((61 PS-PF) 1633) ((41 PS-PF) 2253))
                        ((43 633) (20 638))
                        ((141 1053) (82 799)))
                (DRIVES (8 MA) 10 10)
                (INPUT-TYPES TTL-TRI-STATE BOOLP BOOLP PARAMETRIC)
                (INPUTS IO A EN PI)
                (LOADINGS (3 PF) 1 1 1)
                (LSI-NAME . BD8TRP)
                (OUT-DEPENDS (EN A)
                             (EN A IO)
                             (EN A IO PI))
                (OUTPUT-TYPES TTL-TRI-STATE BOOLP PARAMETRIC)
                (OUTPUTS IO ZI PO)
                (RESULTS CONS
                         (FT-BUF (F-NOT EN) A)
                         (CONS (F-BUF (FT-WIRE IO (FT-BUF (F-NOT EN) A)))
                               (CONS (F-NAND (FT-WIRE IO (FT-BUF (F-NOT EN) A))
                                             PI)
                                     'NIL)))
                (GATES . 0)
                (PADS . 1)
                (PRIMITIVES . 1)
                (TRANSISTORS . 0))
 '(TTL-CLK-INPUT (DELAYS ((4 1225) (4 1152))
                         ((202 1050) (117 741)))
                 (DRIVES 400 10)
                 (INPUT-TYPES TTL PARAMETRIC)
                 (INPUTS A PI)
                 (LOADINGS (3 PF) 1)
                 (LSI-NAME . DRVT8)
                 (OUT-DEPENDS (A) (A PI))
                 (OUTPUT-TYPES CLK PARAMETRIC)
                 (OUTPUTS Z PO)
                 (RESULTS CONS
                          (F-BUF A)
                          (CONS (F-NAND A PI) 'NIL))
                 (GATES . 0)
                 (PADS . 2)
                 (PRIMITIVES . 1)
                 (TRANSISTORS . 0))
 '(TTL-INPUT (DELAYS ((43 633) (20 638))
                     ((141 1053) (82 799)))
             (DRIVES 10 10)
             (INPUT-TYPES TTL PARAMETRIC)
             (INPUTS A PI)
             (LOADINGS (3 PF) 1)
             (LSI-NAME . TLCHT)
             (OUT-DEPENDS (A) (A PI))
             (OUTPUT-TYPES BOOLP PARAMETRIC)
             (OUTPUTS Z PO)
             (RESULTS CONS
                      (F-BUF A)
                      (CONS (F-NAND A PI) 'NIL))
             (GATES . 0)
             (PADS . 1)
             (PRIMITIVES . 1)
             (TRANSISTORS . 0))
 '(TTL-OUTPUT (DELAYS (((61 PS-PF) 812) ((42 PS-PF) 1155)))
              (DRIVES (8 MA))
              (INPUT-TYPES BOOLP)
              (INPUTS A)
              (LOADINGS 5)
              (LSI-NAME . B8RP)
              (OUT-DEPENDS (A))
              (OUTPUT-TYPES TTL)
              (OUTPUTS Z)
              (RESULTS CONS (F-BUF A) 'NIL)
              (GATES . 0)
              (PADS . 1)
              (PRIMITIVES . 1)
              (TRANSISTORS . 0))
 '(TTL-OUTPUT-PARAMETRIC (DELAYS (((64 PS-PF) 737) ((42 PS-PF) 1125)))
                         (DRIVES (4 MA))
                         (INPUT-TYPES PARAMETRIC)
                         (INPUTS A)
                         (LOADINGS 3)
                         (LSI-NAME . B4)
                         (OUT-DEPENDS (A))
                         (OUTPUT-TYPES TTL)
                         (OUTPUTS Z)
                         (RESULTS CONS (F-BUF A) 'NIL)
                         (GATES . 0)
                         (PADS . 1)
                         (PRIMITIVES . 1)
                         (TRANSISTORS . 0))
 '(TTL-OUTPUT-FAST (DELAYS (((36 PS-PF) 991) ((24 PS-PF) 1488)))
                   (DRIVES (8 MA))
                   (INPUT-TYPES BOOLP)
                   (INPUTS A)
                   (LOADINGS 3)
                   (LSI-NAME . B8)
                   (OUT-DEPENDS (A))
                   (OUTPUT-TYPES TTL)
                   (OUTPUTS Z)
                   (RESULTS CONS (F-BUF A) 'NIL)
                   (GATES . 0)
                   (PADS . 1)
                   (PRIMITIVES . 1)
                   (TRANSISTORS . 0))
 '(TTL-TRI-OUTPUT (DELAYS (((61 PS-PF) 1602) ((41 PS-PF) 2233)))
                  (DRIVES (8 MA))
                  (INPUT-TYPES BOOLP BOOLP)
                  (INPUTS A EN)
                  (LOADINGS 1 1)
                  (LSI-NAME . BT8RP)
                  (OUT-DEPENDS (A EN))
                  (OUTPUT-TYPES TTL-TRI-STATE)
                  (OUTPUTS Z)
                  (RESULTS CONS
                           (FT-BUF (F-NOT EN) A)
                           'NIL)
                  (GATES . 0)
                  (PADS . 1)
                  (PRIMITIVES . 1)
                  (TRANSISTORS . 0))
 '(TTL-TRI-OUTPUT-FAST (DELAYS (((36 PS-PF) 1581) ((24 PS-PF) 2198)))
                       (DRIVES (8 MA))
                       (INPUT-TYPES BOOLP BOOLP)
                       (INPUTS A EN)
                       (LOADINGS 1 1)
                       (LSI-NAME . BT8)
                       (OUT-DEPENDS (A EN))
                       (OUTPUT-TYPES TTL-TRI-STATE)
                       (OUTPUTS Z)
                       (RESULTS CONS
                                (FT-BUF (F-NOT EN) A)
                                'NIL)
                       (GATES . 0)
                       (PADS . 1)
                       (PRIMITIVES . 1)
                       (TRANSISTORS . 0))
 (LIST 'VDD
       '(DELAYS ((0 0) (0 0)))
       '(DRIVES 50)
       '(INPUT-TYPES)
       '(INPUTS)
       '(LOADINGS)
       '(LSI-NAME . VDD)
       '(OUT-DEPENDS NIL)
       '(OUTPUT-TYPES BOOLP)
       '(OUTPUTS Z)
       (LIST 'RESULTS
             'CONS
             (LIST 'QUOTE T)
             ''NIL)
       '(GATES . 0)
       '(PRIMITIVES . 1)
       '(TRANSISTORS . 0))
 (LIST 'VDD-PARAMETRIC
       '(DELAYS ((0 0) (0 0)))
       '(DRIVES 50)
       '(INPUT-TYPES)
       '(INPUTS)
       '(LOADINGS)
       '(LSI-NAME . VDD)
       '(OUT-DEPENDS NIL)
       '(OUTPUT-TYPES PARAMETRIC)
       '(OUTPUTS Z)
       (LIST 'RESULTS
             'CONS
             (LIST 'QUOTE T)
             ''NIL)
       '(GATES . 0)
       '(PRIMITIVES . 1)
       '(TRANSISTORS . 0))
 (LIST 'VSS
       '(DELAYS ((0 0) (0 0)))
       '(DRIVES 50)
       '(INPUT-TYPES)
       '(INPUTS)
       '(LOADINGS)
       '(LSI-NAME . VSS)
       '(OUT-DEPENDS NIL)
       '(OUTPUT-TYPES BOOLP)
       '(OUTPUTS Z)
       (LIST 'RESULTS
             'CONS
             (LIST 'QUOTE F)
             ''NIL)
       '(GATES . 0)
       '(PRIMITIVES . 1)
       '(TRANSISTORS . 0))))

(DEFN LOOKUP-MODULE
      (NAME NETLIST)
      (COND ((NLISTP NETLIST) F)
            ((AND (LISTP (CAR NETLIST))
                  (EQUAL (CAAR NETLIST) NAME))
             (CAR NETLIST))
            (T (LOOKUP-MODULE NAME (CDR NETLIST)))))

(TOGGLE LOOKUP-MODULE-OFF LOOKUP-MODULE T)

(DEFN DELETE-MODULE
      (NAME NETLIST)
      (COND ((NLISTP NETLIST) NETLIST)
            ((AND (LISTP (CAR NETLIST))
                  (EQUAL (CAAR NETLIST) NAME))
             (CDR NETLIST))
            (T (CONS (CAR NETLIST)
                     (DELETE-MODULE NAME (CDR NETLIST))))))

(TOGGLE DELETE-MODULE-OFF DELETE-MODULE T)

(PROVE-LEMMA DELETE-MODULE-LOOKUP-MODULE-COUNT
             (REWRITE)
             (IMPLIES (LOOKUP-MODULE NAME NETLIST)
                      (LESSP (COUNT (DELETE-MODULE NAME NETLIST))
                             (COUNT NETLIST)))
             ((ENABLE LOOKUP-MODULE DELETE-MODULE)))

(DEFN PAIRSTATES
      (STATENAMES STATE)
      (IF (OR (LISTP STATENAMES)
              (EQUAL STATENAMES NIL))
          (PAIRLIST STATENAMES STATE)
          (LIST (CONS STATENAMES STATE))))

(DEFN COLLECT-STATES
      (STATENAMES STATE-BINDINGS)
      (IF (OR (LISTP STATENAMES)
              (EQUAL STATENAMES NIL))
          (COLLECT-VALUE STATENAMES STATE-BINDINGS)
          (VALUE STATENAMES STATE-BINDINGS)))

(DEFN MODULE-NAME
      (MODULE)
      (CAR MODULE))

(DEFN MODULE-INPUTS
      (MODULE)
      (CADR MODULE))

(DEFN MODULE-OUTPUTS
      (MODULE)
      (CADDR MODULE))

(DEFN MODULE-OCCURRENCES
      (MODULE)
      (CADDDR MODULE))

(DEFN MODULE-STATENAMES
      (MODULE)
      (CADDDDR MODULE))

(DEFN MODULE-ANNOTATION
      (MODULE)
      (CADDDDDR MODULE))

(DEFN OCC-NAME
      (OCCURRENCE)
      (CAR OCCURRENCE))

(DEFN OCC-OUTPUTS
      (OCCURRENCE)
      (CADR OCCURRENCE))

(DEFN OCC-FUNCTION
      (OCCURRENCE)
      (CADDR OCCURRENCE))

(DEFN OCC-INPUTS
      (OCCURRENCE)
      (CADDDR OCCURRENCE))

(DEFN OCC-ANNOTATION
      (OCCURRENCE)
      (CADDDDR OCCURRENCE))

(DEFN PRIMP
      (FN)
      (LOOKUP-MODULE FN (PRIMP-DATABASE)))

(TOGGLE PRIMP-OFF PRIMP T)

(PROVE-LEMMA NOT-LITATOM==>NOT-PRIMP
             (REWRITE)
             (IMPLIES (NOT (LITATOM FN))
                      (NOT (PRIMP FN)))
             ((ENABLE LOOKUP-MODULE PRIMP)))

(DEFN PRIMP-LOOKUP
      (FN NAME)
      (LOOKUP-MODULE NAME (CDR (PRIMP FN))))

(DEFN PRIMP2
      (FN NAME)
      (CDR (PRIMP-LOOKUP FN NAME)))

(DEFN DUAL-APPLY-VALUE
      (FN ARGS STATE)
      (EVAL$ T
             (PRIMP2 FN 'RESULTS)
             (APPEND (PAIRLIST (PRIMP2 FN 'INPUTS) ARGS)
                     (PAIRSTATES (PRIMP2 FN 'STATES)
                                 STATE))))

(TOGGLE DUAL-APPLY-VALUE-OFF DUAL-APPLY-VALUE T)

(DEFN DUAL-APPLY-STATE
      (FN ARGS STATE)
      (EVAL$ T
             (PRIMP2 FN 'NEW-STATES)
             (APPEND (PAIRLIST (PRIMP2 FN 'INPUTS) ARGS)
                     (PAIRSTATES (PRIMP2 FN 'STATES)
                                 STATE))))

(TOGGLE DUAL-APPLY-STATE-OFF DUAL-APPLY-STATE T)

(DEFN DUAL-EVAL
 (FLAG X0 X1 X2 NETLIST)
 (CASE FLAG
  (0
   (COND
    ((PRIMP X0)
     (DUAL-APPLY-VALUE X0 X1 X2))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (COLLECT-VALUE
          (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                               X1)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
                                 X2)
                     (DELETE-MODULE X0 NETLIST))))
    (T F)))
  (1
   (IF
    (LISTP X0)
    (DUAL-EVAL 1
              (CDR X0)
              (APPEND (PAIRLIST (OCC-OUTPUTS (CAR X0))
                                (DUAL-EVAL 0
                                           (OCC-FUNCTION (CAR X0))
                                           (COLLECT-VALUE (OCC-INPUTS (CAR X0))
                                                          X1)
                                           (VALUE (OCC-NAME (CAR X0)) X2)
                                           NETLIST))
                      X1)
              X2 NETLIST)
    X1))
  (2
   (COND
    ((PRIMP X0)
     (DUAL-APPLY-STATE X0 X1 X2))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (COLLECT-STATES
      (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
      (DUAL-EVAL 3
          (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                               X1)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
                                 X2)
                     (DELETE-MODULE X0 NETLIST))
          (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
                      X2)
          (DELETE-MODULE X0 NETLIST))))
    (T F)))
  (3 (IF (LISTP X0)
         (CONS (CONS (OCC-NAME (CAR X0))
                     (DUAL-EVAL 2
                                (OCC-FUNCTION (CAR X0))
                                (COLLECT-VALUE (OCC-INPUTS (CAR X0))
                                               X1)
                                (VALUE (OCC-NAME (CAR X0)) X2)
                                NETLIST))
               (DUAL-EVAL 3 (CDR X0) X1 X2 NETLIST))
         NIL))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE DUAL-EVAL-OFF DUAL-EVAL T)

(PROVE-LEMMA EXPAND-TOP-LEVEL-DUAL-EVAL-0-CALLS
 (REWRITE)
 (IMPLIES
  (AND (NOT (PRIMP FN))
       (LISTP (LOOKUP-MODULE FN NETLIST)))
  (EQUAL
   (DUAL-EVAL 0 FN ARGS STATE NETLIST)
   (COLLECT-VALUE
          (MODULE-OUTPUTS (LOOKUP-MODULE FN NETLIST))
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               ARGS)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 STATE)
                     (DELETE-MODULE FN NETLIST)))))
 ((EXPAND (DUAL-EVAL 0 FN ARGS STATE NETLIST))))

(PROVE-LEMMA EXPAND-TOP-LEVEL-DUAL-EVAL-2-CALLS
 (REWRITE)
 (IMPLIES
  (AND (NOT (PRIMP FN))
       (LISTP (LOOKUP-MODULE FN NETLIST)))
  (EQUAL
   (DUAL-EVAL 2 FN ARGS STATE NETLIST)
   (COLLECT-STATES
    (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
    (DUAL-EVAL 3
          (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               ARGS)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 STATE)
                     (DELETE-MODULE FN NETLIST))
          (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                      STATE)
          (DELETE-MODULE FN NETLIST)))))
 ((EXPAND (DUAL-EVAL 2 FN ARGS STATE NETLIST))))

(PROVE-LEMMA OPEN-DUAL-EVAL-WITH-FLAG-1
 (REWRITE)
 (AND
  (IMPLIES (NLISTP BODY)
           (EQUAL (DUAL-EVAL 1 BODY BINDINGS STATE-BINDINGS NETLIST)
                  BINDINGS))
  (IMPLIES
   (LISTP BODY)
   (EQUAL
    (DUAL-EVAL 1 BODY BINDINGS STATE-BINDINGS NETLIST)
    (DUAL-EVAL 1
            (CDR BODY)
            (APPEND (PAIRLIST (OCC-OUTPUTS (CAR BODY))
                              (DUAL-EVAL 0
                                         (OCC-FUNCTION (CAR BODY))
                                         (COLLECT-VALUE (OCC-INPUTS (CAR BODY))
                                                        BINDINGS)
                                         (VALUE (OCC-NAME (CAR BODY))
                                                STATE-BINDINGS)
                                         NETLIST))
                    BINDINGS)
            STATE-BINDINGS NETLIST))))
 ((ENABLE DUAL-EVAL)))

(PROVE-LEMMA OPEN-DUAL-EVAL-WITH-FLAG-3
 (REWRITE)
 (AND
  (IMPLIES (NLISTP BODY)
           (EQUAL (DUAL-EVAL 3 BODY BINDINGS STATE-BINDINGS NETLIST)
                  NIL))
  (IMPLIES (LISTP BODY)
           (EQUAL (DUAL-EVAL 3 BODY BINDINGS STATE-BINDINGS NETLIST)
                  (CONS (CONS (OCC-NAME (CAR BODY))
                              (DUAL-EVAL 2
                                         (OCC-FUNCTION (CAR BODY))
                                         (COLLECT-VALUE (OCC-INPUTS (CAR BODY))
                                                        BINDINGS)
                                         (VALUE (OCC-NAME (CAR BODY))
                                                STATE-BINDINGS)
                                         NETLIST))
                        (DUAL-EVAL 3
                                   (CDR BODY)
                                   BINDINGS STATE-BINDINGS NETLIST)))))
 ((ENABLE DUAL-EVAL)))

(PROVE-LEMMA PROPERP-DUAL-EVAL-0
             (REWRITE)
             (IMPLIES (AND (NOT (PRIMP FN))
                           (LISTP (LOOKUP-MODULE FN NETLIST)))
                      (PROPERP (DUAL-EVAL 0 FN ARGS STATE NETLIST)))
             ((EXPAND (DUAL-EVAL 0 FN ARGS STATE NETLIST))))

(PROVE-LEMMA LENGTH-DUAL-EVAL-0
         (REWRITE)
         (IMPLIES (AND (NOT (PRIMP FN))
                       (LISTP (LOOKUP-MODULE FN NETLIST)))
                  (EQUAL (LENGTH (DUAL-EVAL 0 FN ARGS STATE NETLIST))
                         (LENGTH (MODULE-OUTPUTS (LOOKUP-MODULE FN NETLIST)))))
         ((EXPAND (DUAL-EVAL 0 FN ARGS STATE NETLIST))))

(PROVE-LEMMA PROPERP-DUAL-EVAL-2
        (REWRITE)
        (IMPLIES (AND (NOT (PRIMP FN))
                      (LISTP (LOOKUP-MODULE FN NETLIST))
                      (PROPERP (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))))
                 (PROPERP (DUAL-EVAL 2 FN ARGS STATE NETLIST)))
        ((EXPAND (DUAL-EVAL 2 FN ARGS STATE NETLIST))))

(PROVE-LEMMA LENGTH-DUAL-EVAL-2
      (REWRITE)
      (IMPLIES (AND (NOT (PRIMP FN))
                    (LISTP (LOOKUP-MODULE FN NETLIST))
                    (PROPERP (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))))
               (EQUAL (LENGTH (DUAL-EVAL 2 FN ARGS STATE NETLIST))
                      (LENGTH (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST)))))
      ((EXPAND (DUAL-EVAL 2 FN ARGS STATE NETLIST))))

(DEFN DUAL-EVAL-BODY-BINDINGS
 (N BODY BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  BINDINGS
  (DUAL-EVAL-BODY-BINDINGS
            (SUB1 N)
            (CDR BODY)
            (APPEND (PAIRLIST (OCC-OUTPUTS (CAR BODY))
                              (DUAL-EVAL 0
                                         (OCC-FUNCTION (CAR BODY))
                                         (COLLECT-VALUE (OCC-INPUTS (CAR BODY))
                                                        BINDINGS)
                                         (VALUE (OCC-NAME (CAR BODY))
                                                STATE-BINDINGS)
                                         NETLIST))
                    BINDINGS)
            STATE-BINDINGS NETLIST)))

(TOGGLE DUAL-EVAL-BODY-BINDINGS-OFF DUAL-EVAL-BODY-BINDINGS T)

(PROVE-LEMMA OPEN-DUAL-EVAL-BODY-BINDINGS
 (REWRITE)
 (AND
  (IMPLIES (ZEROP N)
           (EQUAL (DUAL-EVAL-BODY-BINDINGS N BODY BINDINGS STATE-BINDINGS
                                           NETLIST)
                  BINDINGS))
  (IMPLIES
   (NOT (ZEROP N))
   (EQUAL
    (DUAL-EVAL-BODY-BINDINGS N BODY BINDINGS STATE-BINDINGS NETLIST)
    (DUAL-EVAL-BODY-BINDINGS
            (SUB1 N)
            (CDR BODY)
            (APPEND (PAIRLIST (OCC-OUTPUTS (CAR BODY))
                              (DUAL-EVAL 0
                                         (OCC-FUNCTION (CAR BODY))
                                         (COLLECT-VALUE (OCC-INPUTS (CAR BODY))
                                                        BINDINGS)
                                         (VALUE (OCC-NAME (CAR BODY))
                                                STATE-BINDINGS)
                                         NETLIST))
                    BINDINGS)
            STATE-BINDINGS NETLIST))))
 ((ENABLE DUAL-EVAL-BODY-BINDINGS)))

(DEFN SIMULATE
      (FN INPUTS STATE NETLIST)
      (IF (NLISTP INPUTS)
          NIL
          (CONS (LIST (DUAL-EVAL 0 FN
                                 (CAR INPUTS)
                                 STATE NETLIST)
                      (DUAL-EVAL 2 FN
                                 (CAR INPUTS)
                                 STATE NETLIST))
                (SIMULATE FN
                          (CDR INPUTS)
                          (DUAL-EVAL 2 FN
                                     (CAR INPUTS)
                                     STATE NETLIST)
                          NETLIST))))

(DEFN SIMULATE-DUAL-EVAL-2
      (MODULE INPUTS STATE NETLIST N)
      (IF (ZEROP N)
          STATE
          (SIMULATE-DUAL-EVAL-2 MODULE
                                (CDR INPUTS)
                                (DUAL-EVAL 2 MODULE
                                           (CAR INPUTS)
                                           STATE NETLIST)
                                NETLIST
                                (SUB1 N))))

(TOGGLE SIMULATE-DUAL-EVAL-2-OFF SIMULATE-DUAL-EVAL-2 T)

(PROVE-LEMMA OPEN-SIMULATE-DUAL-EVAL-2
             (REWRITE)
             (AND (IMPLIES (ZEROP N)
                           (EQUAL (SIMULATE-DUAL-EVAL-2 MODULE INPUTS STATE
                                                        NETLIST N)
                                  STATE))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (SIMULATE-DUAL-EVAL-2 MODULE INPUTS STATE
                                                        NETLIST N)
                                  (SIMULATE-DUAL-EVAL-2 MODULE
                                                        (CDR INPUTS)
                                                        (DUAL-EVAL 2 MODULE
                                                                   (CAR INPUTS)
                                                                   STATE
                                                                   NETLIST)
                                                        NETLIST
                                                        (SUB1 N)))))
             ((ENABLE SIMULATE-DUAL-EVAL-2)))

(DEFN MIN (X Y) (IF (LESSP Y X) Y X))

(TOGGLE MIN-OFF MIN T)

(DEFN INSERT
      (E X)
      (IF (MEMBER E X) X (CONS E X)))

(TOGGLE INSERT-OFF INSERT T)

(DEFN SET-EQUAL
      (X Y)
      (AND (SUBSET X Y) (SUBSET Y X)))

(TOGGLE SET-EQUAL-OFF SET-EQUAL T)

(DEFN SET-DIFF
      (X Y)
      (IF (LISTP X)
          (IF (MEMBER (CAR X) Y)
              (SET-DIFF (CDR X) Y)
              (CONS (CAR X) (SET-DIFF (CDR X) Y)))
          NIL))

(TOGGLE SET-DIFF-OFF SET-DIFF T)

(DEFN INTERSECTION
      (X Y)
      (IF (LISTP X)
          (IF (MEMBER (CAR X) Y)
              (CONS (CAR X)
                    (INTERSECTION (CDR X) Y))
              (INTERSECTION (CDR X) Y))
          NIL))

(TOGGLE INTERSECTION-OFF INTERSECTION T)

(DEFN LAST-CDR
      (X)
      (IF (LISTP X) (LAST-CDR (CDR X)) X))

(TOGGLE LAST-CDR-OFF LAST-CDR T)

(DEFN LIST-DUPLICATES
      (X DUPLICATES)
      (IF (LISTP X)
          (LIST-DUPLICATES (CDR X)
                           (IF (MEMBER (CAR X) (CDR X))
                               (INSERT (CAR X) DUPLICATES)
                               DUPLICATES))
          DUPLICATES))

(TOGGLE LIST-DUPLICATES-OFF LIST-DUPLICATES T)

(DEFN REMOVE-DUPLICATES
      (X)
      (IF (LISTP X)
          (IF (MEMBER (CAR X) (CDR X))
              (REMOVE-DUPLICATES (CDR X))
              (CONS (CAR X)
                    (REMOVE-DUPLICATES (CDR X))))
          X))

(TOGGLE REMOVE-DUPLICATES-OFF REMOVE-DUPLICATES T)

(DEFN APPEND-LIST
      (X)
      (IF (LISTP X)
          (APPEND (CAR X) (APPEND-LIST (CDR X)))
          NIL))

(TOGGLE APPEND-LIST-OFF APPEND-LIST T)

(DEFN FLATTEN-LIST
      (X)
      (REMOVE-DUPLICATES (APPEND-LIST X)))

(TOGGLE FLATTEN-LIST-OFF FLATTEN-LIST T)

(DEFN IS-HEAD
      (X Y)
      (IF (AND (LISTP X) (LISTP Y))
          (AND (EQUAL (CAR X) (CAR Y))
               (IS-HEAD (CDR X) (CDR Y)))
          (NLISTP X)))

(TOGGLE IS-HEAD-OFF IS-HEAD T)

(DEFN LISTIFY
      (X)
      (IF (LISTP X)
          (CONS (LIST (CAR X))
                (LISTIFY (CDR X)))
          NIL))

(TOGGLE LISTIFY-OFF LISTIFY T)

(DEFN ALISTP
      (X)
      (IF (LISTP X)
          (AND (LISTP (CAR X)) (ALISTP (CDR X)))
          (EQUAL X NIL)))

(TOGGLE ALISTP-OFF ALISTP T)

(DEFN BOUNDP
      (KEY ALIST)
      (LISTP (LOOKUP-MODULE KEY ALIST)))

(DEFN ALIST-ENTRY
      (KEY ALIST)
      (LOOKUP-MODULE KEY ALIST))

(TOGGLE ALIST-ENTRY-OFF ALIST-ENTRY T)

(DEFN UNBIND
      (KEY ALIST)
      (DELETE-MODULE KEY ALIST))

(DEFN SET-VALUE
      (KEY VALUE ALIST)
      (COND ((NLISTP (ALIST-ENTRY KEY ALIST))
             (CONS (CONS KEY VALUE) ALIST))
            ((EQUAL VALUE
                    (CDR (ALIST-ENTRY KEY ALIST)))
             ALIST)
            (T (CONS (CONS KEY VALUE)
                     (UNBIND KEY ALIST)))))

(TOGGLE SET-VALUE-OFF SET-VALUE T)

(DEFN UNION-VALUES
      (KEYS ALIST)
      (IF (LISTP KEYS)
          (UNION (VALUE (CAR KEYS) ALIST)
                 (UNION-VALUES (CDR KEYS) ALIST))
          NIL))

(TOGGLE UNION-VALUES-OFF UNION-VALUES T)

(DEFN LIST-UNION-VALUES
      (LIST-OF-ARGS ALIST)
      (IF (LISTP LIST-OF-ARGS)
          (CONS (UNION-VALUES (CAR LIST-OF-ARGS)
                              ALIST)
                (LIST-UNION-VALUES (CDR LIST-OF-ARGS)
                                   ALIST))
          NIL))

(TOGGLE LIST-UNION-VALUES-OFF LIST-UNION-VALUES T)

(DEFN UNBOUND-KEYS
      (KEYS ALIST)
      (IF (LISTP KEYS)
          (IF (BOUNDP (CAR KEYS) ALIST)
              (UNBOUND-KEYS (CDR KEYS) ALIST)
              (INSERT (CAR KEYS)
                      (UNBOUND-KEYS (CDR KEYS) ALIST)))
          NIL))

(TOGGLE UNBOUND-KEYS-OFF UNBOUND-KEYS T)

(DEFN UNBIND-LIST
      (KEYS ALIST)
      (IF (LISTP KEYS)
          (UNBIND (CAR KEYS)
                  (UNBIND-LIST (CDR KEYS) ALIST))
          ALIST))

(PROVE-LEMMA LOOKUP-MODULE-IN-DELETE-MODULE
             (REWRITE)
             (IMPLIES (AND (NOT (EQUAL K1 K2))
                           (LOOKUP-MODULE K1 M))
                      (LOOKUP-MODULE K1
                                     (DELETE-MODULE K2 M)))
             ((ENABLE DELETE-MODULE LOOKUP-MODULE)))

(PROVE-LEMMA LOOKUP-MODULE-IN-UNBIND-LIST
             (REWRITE)
             (IMPLIES (AND (NOT (MEMBER K U))
                           (LOOKUP-MODULE K M))
                      (LOOKUP-MODULE K (UNBIND-LIST U M))))

(TOGGLE LOOKUP-MODULE-IN-DELETE-MODULE-OFF LOOKUP-MODULE-IN-DELETE-MODULE T)

(PROVE-LEMMA LESSP-UNBIND-LIST-COUNT
             (REWRITE)
             (IMPLIES (AND (NOT (MEMBER K U)) (BOUNDP K M))
                      (LESSP (COUNT (UNBIND-LIST (CONS K U) M))
                             (COUNT (UNBIND-LIST U M)))))

(TOGGLE BOUNDP-OFF BOUNDP T)

(TOGGLE UNBIND-OFF UNBIND T)

(TOGGLE UNBIND-LIST-OFF UNBIND-LIST T)

(TOGGLE LOOKUP-MODULE-IN-UNBIND-LIST-OFF LOOKUP-MODULE-IN-UNBIND-LIST T)

(DEFN M-STATES-LIST
      (M-STATES)
      (IF (OR (LISTP M-STATES)
              (EQUAL M-STATES NIL))
          M-STATES
          (LIST M-STATES)))

(TOGGLE M-STATES-LIST-OFF M-STATES-LIST T)

(DEFN LIST-LESSP
      (X Y)
      (IF (LISTP X)
          (IF (LISTP Y)
              (COND ((LESSP (CAR X) (CAR Y)) T)
                    ((EQUAL (CAR X) (CAR Y))
                     (LIST-LESSP (CDR X) (CDR Y)))
                    (T F))
              F)
          (LISTP Y)))

(TOGGLE LIST-LESSP-OFF LIST-LESSP T)

(DEFN TOKEN-LESSP
      (X Y)
      (COND ((AND (LITATOM X) (LITATOM Y))
             (LIST-LESSP (UNPACK X) (UNPACK Y)))
            ((AND (LITATOM X) (INDEXP Y)) T)
            ((AND (INDEXP X) (LITATOM Y)) F)
            ((AND (INDEXP X) (INDEXP Y))
             (IF (EQUAL (I-NAME X) (I-NAME Y))
                 (LESSP (I-NUM X) (I-NUM Y))
                 (LIST-LESSP (UNPACK (I-NAME X))
                             (UNPACK (I-NAME Y)))))
            (T F)))

(TOGGLE TOKEN-LESSP-OFF TOKEN-LESSP T)

(DEFN MIN-TOKEN-HELP
      (SEED LIST)
      (IF (LISTP LIST)
          (IF (TOKEN-LESSP SEED (CAR LIST))
              (MIN-TOKEN-HELP SEED (CDR LIST))
              (MIN-TOKEN-HELP (CAR LIST)
                              (CDR LIST)))
          SEED))

(TOGGLE MIN-TOKEN-HELP-OFF MIN-TOKEN-HELP T)

(DEFN MIN-TOKEN
      (LIST)
      (IF (LISTP LIST)
          (IF (LISTP (CDR LIST))
              (MIN-TOKEN-HELP (CAR LIST) (CDR LIST))
              (CAR LIST))
          0))

(TOGGLE MIN-TOKEN-OFF MIN-TOKEN T)

(PROVE-LEMMA MIN-TOKEN-HELP-LEMMA NIL
             (OR (EQUAL (MIN-TOKEN-HELP SEED LIST)
                        SEED)
                 (MEMBER (MIN-TOKEN-HELP SEED LIST)
                         LIST))
             ((ENABLE MIN-TOKEN-HELP)))

(PROVE-LEMMA MIN-TOKEN-LEMMA
             (REWRITE)
             (IMPLIES (LISTP LST)
                      (MEMBER (MIN-TOKEN LST) LST))
             ((USE (MIN-TOKEN-HELP-LEMMA (SEED (CAR LST))
                                         (LIST (CDR LST))))
              (ENABLE MIN-TOKEN)))

(PROVE-LEMMA DELETE*-COUNT
             (REWRITE)
             (LESSP (COUNT (DELETE* E X))
                    (COUNT (CONS E X)))
             ((ENABLE DELETE*)))

(PROVE-LEMMA DELETE*-LEMMA
             (REWRITE)
             (IMPLIES (MEMBER E LST)
                      (LESSP (COUNT (DELETE* E LST))
                             (COUNT LST)))
             ((ENABLE DELETE*)))

(DEFN LIST-SORT
      (LIST)
      (IF (LISTP LIST)
          (CONS (MIN-TOKEN LIST)
                (LIST-SORT (DELETE* (MIN-TOKEN LIST) LIST)))
          NIL))

(TOGGLE LIST-SORT-OFF LIST-SORT T)

(DEFN LIST-LIST-SORT
      (LIST)
      (IF (LISTP LIST)
          (CONS (LIST-SORT (CAR LIST))
                (LIST-LIST-SORT (CDR LIST)))
          NIL))

(TOGGLE LIST-LIST-SORT-OFF LIST-LIST-SORT T)

(ADD-SHELL NET-ERROR NIL NET-ERRORP
           ((ERROR-LABEL (NONE-OF) FALSE)
            (ERROR-BODY (NONE-OF) TRUE)))

(DEFN REPORT-ERROR (ERR) ERR)

(TOGGLE REPORT-ERROR-OFF REPORT-ERROR T)

(DEFN PRED-ERROR
      (LABEL BODY)
      (REPORT-ERROR (NET-ERROR LABEL BODY)))

(TOGGLE PRED-ERROR-OFF PRED-ERROR T)

(DEFN ERROR-ENTRY
      (LST LABEL)
      (IF (LISTP LST)
          (IF (NET-ERRORP (CAR LST))
              (IF (EQUAL (ERROR-LABEL (CAR LST)) LABEL)
                  (CAR LST)
                  (ERROR-ENTRY (CDR LST) LABEL))
              (ERROR-ENTRY (CDR LST) LABEL))
          F))

(TOGGLE ERROR-ENTRY-OFF ERROR-ENTRY T)

(DEFN NET-ERRORS
      (LST)
      (IF (LISTP LST)
          (IF (NET-ERRORP (CAR LST))
              (CONS (CAR LST)
                    (NET-ERRORS (CDR LST)))
              (NET-ERRORS (CDR LST)))
          NIL))

(TOGGLE NET-ERRORS-OFF NET-ERRORS T)

(DEFN COLLECT-NET-ERRORS
      (LST)
      (IF (LISTP LST)
          (APPEND (NET-ERRORS (CAR LST))
                  (COLLECT-NET-ERRORS (CDR LST)))
          NIL))

(TOGGLE COLLECT-NET-ERRORS-OFF COLLECT-NET-ERRORS T)

(DEFN ERR-AND
      (LST LABEL)
      (IF (NLISTP (NET-ERRORS LST))
          T
          (PRED-ERROR LABEL (NET-ERRORS LST))))

(TOGGLE ERR-AND-OFF ERR-AND T)

(DEFN T-OR-ERR
      (P LABEL BODY)
      (IF (AND P (NOT (NET-ERRORP P)))
          T
          (PRED-ERROR LABEL BODY)))

(TOGGLE T-OR-ERR-OFF T-OR-ERR T)

(DEFN NLISTP-OR-ERR
      (X LABEL)
      (IF (NLISTP X)
          T
          (PRED-ERROR LABEL X)))

(TOGGLE NLISTP-OR-ERR-OFF NLISTP-OR-ERR T)

(DEFN NIL-OR-ERR
      (X LABEL)
      (IF (EQUAL X NIL)
          T
          (PRED-ERROR LABEL X)))

(TOGGLE NIL-OR-ERR-OFF NIL-OR-ERR T)

(DEFN SUBSET-OR-ERR
      (X Y LABEL)
      (IF (NLISTP (SET-DIFF X Y))
          T
          (PRED-ERROR LABEL (SET-DIFF X Y))))

(TOGGLE SUBSET-OR-ERR-OFF SUBSET-OR-ERR T)

(DEFN NO-DUPLICATES-OR-ERR
      (X LABEL)
      (IF (NLISTP (LIST-DUPLICATES X NIL))
          T
          (PRED-ERROR LABEL
                      (LIST-DUPLICATES X NIL))))

(TOGGLE NO-DUPLICATES-OR-ERR-OFF NO-DUPLICATES-OR-ERR T)

(DEFN DISJOINT-OR-ERR
      (X Y LABEL)
      (IF (NLISTP (INTERSECTION X Y))
          T
          (PRED-ERROR LABEL
                      (INTERSECTION X Y))))

(TOGGLE DISJOINT-OR-ERR-OFF DISJOINT-OR-ERR T)

(DEFN ALL-BOUND-OR-ERR
      (KEYS ALIST LABEL)
      (IF (NLISTP (UNBOUND-KEYS KEYS ALIST))
          T
          (PRED-ERROR LABEL
                      (UNBOUND-KEYS KEYS ALIST))))

(TOGGLE ALL-BOUND-OR-ERR-OFF ALL-BOUND-OR-ERR T)

(DEFN LABEL-ERROR
      (X LABEL)
      (IF (NET-ERRORP X)
          (PRED-ERROR LABEL X)
          X))

(TOGGLE LABEL-ERROR-OFF LABEL-ERROR T)

(DEFN LIST-COLLECT-VALUE
      (LIST-OF-ARGS ALIST)
      (IF (NLISTP LIST-OF-ARGS)
          NIL
          (CONS (FLATTEN-LIST (COLLECT-VALUE (CAR LIST-OF-ARGS)
                                             ALIST))
                (LIST-COLLECT-VALUE (CDR LIST-OF-ARGS)
                                    ALIST))))

(TOGGLE LIST-COLLECT-VALUE-OFF LIST-COLLECT-VALUE T)

(DEFN NAME-SIMPLE-OKP
      (NAME)
      (OR (LITATOM NAME)
          (AND (INDEXP NAME)
               (LITATOM (I-NAME NAME)))))

(TOGGLE NAME-SIMPLE-OKP-OFF NAME-SIMPLE-OKP T)

(DEFN NAME-LIST-SIMPLE-OKP
      (NAME-LIST)
      (IF (NLISTP NAME-LIST)
          (EQUAL NAME-LIST NIL)
          (AND (NAME-SIMPLE-OKP (CAR NAME-LIST))
               (NOT (MEMBER (CAR NAME-LIST)
                            (CDR NAME-LIST)))
               (NAME-LIST-SIMPLE-OKP (CDR NAME-LIST)))))

(TOGGLE NAME-LIST-SIMPLE-OKP-OFF NAME-LIST-SIMPLE-OKP T)

(DEFN OCC-SYNTAX-SIMPLE-OKP
 (OCC NETLIST)
 (AND (OR (EQUAL 4 (LENGTH OCC))
          (AND (EQUAL 5 (LENGTH OCC))
               (ALISTP (OCC-ANNOTATION OCC))))
      (PROPERP OCC)
      (NAME-SIMPLE-OKP (OCC-NAME OCC))
      (NAME-LIST-SIMPLE-OKP (OCC-OUTPUTS OCC))
      (PROPERP (OCC-INPUTS OCC))
      (IF (PRIMP (OCC-FUNCTION OCC))
          (AND (EQUAL (LENGTH (PRIMP2 (OCC-FUNCTION OCC) 'INPUTS))
                      (LENGTH (OCC-INPUTS OCC)))
               (EQUAL (LENGTH (PRIMP2 (OCC-FUNCTION OCC) 'OUTPUTS))
                      (LENGTH (OCC-OUTPUTS OCC))))
          (AND (LISTP (LOOKUP-MODULE (OCC-FUNCTION OCC)
                                     NETLIST))
               (EQUAL (LENGTH (MODULE-INPUTS (LOOKUP-MODULE (OCC-FUNCTION OCC)
                                                            NETLIST)))
                      (LENGTH (OCC-INPUTS OCC)))
               (EQUAL (LENGTH (MODULE-OUTPUTS (LOOKUP-MODULE (OCC-FUNCTION OCC)
                                                             NETLIST)))
                      (LENGTH (OCC-OUTPUTS OCC)))))))

(TOGGLE OCC-SYNTAX-SIMPLE-OKP-OFF OCC-SYNTAX-SIMPLE-OKP T)

(DEFN OCC-BODY-SYNTAX-SIMPLE-OKP
   (BODY SIGNALS NON-DEPENDS OCC-NAMES OUTPUTS STATES NETLIST)
   (COND ((NLISTP BODY)
          (AND (EQUAL BODY NIL)
               (SUBSET OUTPUTS SIGNALS)
               (SUBSET NON-DEPENDS SIGNALS)
               (SUBSET STATES OCC-NAMES)
               (NOT (DUPLICATES? SIGNALS))
               (NOT (DUPLICATES? OCC-NAMES))))
         ((OCC-SYNTAX-SIMPLE-OKP (CAR BODY)
                                 NETLIST)
          (OCC-BODY-SYNTAX-SIMPLE-OKP (CDR BODY)
                                      (APPEND (OCC-OUTPUTS (CAR BODY))
                                              SIGNALS)
                                      (APPEND (SET-DIFF (OCC-INPUTS (CAR BODY))
                                                        SIGNALS)
                                              NON-DEPENDS)
                                      (CONS (OCC-NAME (CAR BODY)) OCC-NAMES)
                                      OUTPUTS STATES NETLIST))
         (T F)))

(TOGGLE OCC-BODY-SYNTAX-SIMPLE-OKP-OFF OCC-BODY-SYNTAX-SIMPLE-OKP T)

(DEFN MODULE-SYNTAX-SIMPLE-OKP
 (NETLIST)
 (AND
  (OR (EQUAL (LENGTH (CAR NETLIST)) 5)
      (AND (EQUAL (LENGTH (CAR NETLIST)) 6)
           (ALISTP (MODULE-ANNOTATION (CAR NETLIST)))))
  (PROPERP (CAR NETLIST))
  (NAME-SIMPLE-OKP (MODULE-NAME (CAR NETLIST)))
  (NOT (LOOKUP-MODULE (MODULE-NAME (CAR NETLIST))
                      (CDR NETLIST)))
  (NOT (PRIMP (MODULE-NAME (CAR NETLIST))))
  (NAME-LIST-SIMPLE-OKP (MODULE-INPUTS (CAR NETLIST)))
  (NAME-LIST-SIMPLE-OKP (MODULE-OUTPUTS (CAR NETLIST)))
  (NAME-LIST-SIMPLE-OKP (M-STATES-LIST (MODULE-STATENAMES (CAR NETLIST))))
  (DISJOINT (MODULE-INPUTS (CAR NETLIST))
            (MODULE-OUTPUTS (CAR NETLIST)))
  (LISTP (MODULE-OCCURRENCES (CAR NETLIST)))
  (OCC-BODY-SYNTAX-SIMPLE-OKP (MODULE-OCCURRENCES (CAR NETLIST))
                              (MODULE-INPUTS (CAR NETLIST))
                              NIL NIL
                              (MODULE-OUTPUTS (CAR NETLIST))
                              (M-STATES-LIST (MODULE-STATENAMES (CAR NETLIST)))
                              (CDR NETLIST))))

(TOGGLE MODULE-SYNTAX-SIMPLE-OKP-OFF MODULE-SYNTAX-SIMPLE-OKP T)

(DEFN NETLIST-SYNTAX-SIMPLE-OKP
      (NETLIST)
      (COND ((NLISTP NETLIST) (EQUAL NETLIST NIL))
            ((MODULE-SYNTAX-SIMPLE-OKP NETLIST)
             (NETLIST-SYNTAX-SIMPLE-OKP (CDR NETLIST)))
            (T F)))

(TOGGLE NETLIST-SYNTAX-SIMPLE-OKP-OFF NETLIST-SYNTAX-SIMPLE-OKP T)

(DEFN OUT-DEPENDS-SIMPLE
 (FLG X0 X1 NETLIST MODULE-DATABASE)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (LIST-COLLECT-VALUE (PRIMP2 X0 'OUT-DEPENDS)
                         (PAIRLIST (PRIMP2 X0 'INPUTS) X1)))
    ((LOOKUP-MODULE 'OUT-DEPENDS
                    (CDR (LOOKUP-MODULE X0 MODULE-DATABASE)))
     (LIST-COLLECT-VALUE
                 (CDR (LOOKUP-MODULE 'OUT-DEPENDS
                                     (CDR (LOOKUP-MODULE X0 MODULE-DATABASE))))
                 (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                           X1)))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (IF
      (AND
       (OUT-DEPENDS-SIMPLE 1
                           (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                           (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                     X1)
                           (DELETE-MODULE X0 NETLIST)
                           MODULE-DATABASE)
       (SUBSET
        (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
        (STRIP-CARS
         (OUT-DEPENDS-SIMPLE 1
                           (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                           (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                     X1)
                           (DELETE-MODULE X0 NETLIST)
                           MODULE-DATABASE))))
      (COLLECT-VALUE
       (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
       (OUT-DEPENDS-SIMPLE 1
                           (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                           (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                     X1)
                           (DELETE-MODULE X0 NETLIST)
                           MODULE-DATABASE))
      F))
    (T F)))
  (1
   (COND
    ((NLISTP X0) X1)
    ((AND
      (SUBSET (FLATTEN-LIST (OUT-DEPENDS-SIMPLE 0
                                                (OCC-FUNCTION (CAR X0))
                                                (LISTIFY (OCC-INPUTS (CAR X0)))
                                                NETLIST MODULE-DATABASE))
              (STRIP-CARS X1))
      (OUT-DEPENDS-SIMPLE 0
                          (OCC-FUNCTION (CAR X0))
                          (LISTIFY (OCC-INPUTS (CAR X0)))
                          NETLIST MODULE-DATABASE))
     (OUT-DEPENDS-SIMPLE 1
      (CDR X0)
      (APPEND
       (PAIRLIST
        (OCC-OUTPUTS (CAR X0))
        (LIST-COLLECT-VALUE (OUT-DEPENDS-SIMPLE 0
                                                (OCC-FUNCTION (CAR X0))
                                                (LISTIFY (OCC-INPUTS (CAR X0)))
                                                NETLIST MODULE-DATABASE)
                            X1))
       X1)
      NETLIST MODULE-DATABASE))
    (T F)))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE OUT-DEPENDS-SIMPLE-OFF OUT-DEPENDS-SIMPLE T)

(DEFN SIMPLE-DEPENDENCY-TABLE
 (NETLIST)
 (COND
  ((NLISTP NETLIST) NIL)
  ((SIMPLE-DEPENDENCY-TABLE (CDR NETLIST))
   (IF
    (OUT-DEPENDS-SIMPLE 0
                        (MODULE-NAME (CAR NETLIST))
                        (LISTIFY (MODULE-INPUTS (CAR NETLIST)))
                        NETLIST
                        (SIMPLE-DEPENDENCY-TABLE (CDR NETLIST)))
    (CONS
     (LIST (MODULE-NAME (CAR NETLIST))
           (CONS 'OUT-DEPENDS
                 (OUT-DEPENDS-SIMPLE 0
                                     (MODULE-NAME (CAR NETLIST))
                                     (LISTIFY (MODULE-INPUTS (CAR NETLIST)))
                                     NETLIST
                                     (SIMPLE-DEPENDENCY-TABLE (CDR NETLIST)))))
     (SIMPLE-DEPENDENCY-TABLE (CDR NETLIST)))
    F))
  (T F)))

(TOGGLE SIMPLE-DEPENDENCY-TABLE-OFF SIMPLE-DEPENDENCY-TABLE T)

(DEFN OUTPUT-DEPENDENCIES-SIMPLE
    (MODULE-NAME ARGS NETLIST)
    (IF (OR (AND (PRIMP MODULE-NAME)
                 (EQUAL (LENGTH ARGS)
                        (LENGTH (PRIMP2 MODULE-NAME 'INPUTS))))
            (AND (LOOKUP-MODULE MODULE-NAME NETLIST)
                 (EQUAL (LENGTH ARGS)
                        (LENGTH (MODULE-INPUTS (LOOKUP-MODULE MODULE-NAME
                                                              NETLIST))))))
        (LIST-LIST-SORT (OUT-DEPENDS-SIMPLE 0 MODULE-NAME ARGS NETLIST
                                            (SIMPLE-DEPENDENCY-TABLE NETLIST)))
        F))

(TOGGLE OUTPUT-DEPENDENCIES-SIMPLE-OFF OUTPUT-DEPENDENCIES-SIMPLE T)

(DEFN TYPE-VALUE-SIMPLE
      (N ALIST DEFAULT)
      (COND ((NLISTP (LOOKUP-MODULE N ALIST))
             (IF DEFAULT 'FREE (LIST N)))
            ((NLISTP (CDR (LOOKUP-MODULE N ALIST)))
             (CDR (LOOKUP-MODULE N ALIST)))
            ((EQUAL (CADR (LOOKUP-MODULE N ALIST))
                    N)
             (IF DEFAULT 'FREE
                 (CDR (LOOKUP-MODULE N ALIST))))
            (T (TYPE-VALUE-SIMPLE (CADR (LOOKUP-MODULE N ALIST))
                                  (DELETE-MODULE N ALIST)
                                  DEFAULT))))

(TOGGLE TYPE-VALUE-SIMPLE-OFF TYPE-VALUE-SIMPLE T)

(DEFN COLLECT-TYPES
      (NAMES ALIST DEFAULT)
      (IF (NLISTP NAMES)
          NIL
          (CONS (TYPE-VALUE-SIMPLE (CAR NAMES)
                                   ALIST DEFAULT)
                (COLLECT-TYPES (CDR NAMES)
                               ALIST DEFAULT))))

(TOGGLE COLLECT-TYPES-OFF COLLECT-TYPES T)

(DEFN ADD-NEW-TYPE
 (NEW-TYPE-ENTRY KNOWN-TYPES)
 (COND ((EQUAL (CDR NEW-TYPE-ENTRY) 'FREE)
        KNOWN-TYPES)
       ((NLISTP (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                               KNOWN-TYPES))
        (CONS NEW-TYPE-ENTRY KNOWN-TYPES))
       ((EQUAL (CDR NEW-TYPE-ENTRY)
               (CDR (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                                   KNOWN-TYPES)))
        KNOWN-TYPES)
       ((LISTP (CDR NEW-TYPE-ENTRY))
        (CONS (CONS (CADR NEW-TYPE-ENTRY)
                    (CDR (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                                        KNOWN-TYPES)))
              KNOWN-TYPES))
       ((LISTP (CDR (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                                   KNOWN-TYPES)))
        (IF (ADD-NEW-TYPE (CONS (CADR (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                                                     KNOWN-TYPES))
                                (CDR NEW-TYPE-ENTRY))
                          (DELETE-MODULE (CAR NEW-TYPE-ENTRY)
                                         KNOWN-TYPES))
            (CONS NEW-TYPE-ENTRY
                  (ADD-NEW-TYPE (CONS (CADR (LOOKUP-MODULE (CAR NEW-TYPE-ENTRY)
                                                           KNOWN-TYPES))
                                      (CDR NEW-TYPE-ENTRY))
                                (DELETE-MODULE (CAR NEW-TYPE-ENTRY)
                                               KNOWN-TYPES)))
            F))
       (T F)))

(TOGGLE ADD-NEW-TYPE-OFF ADD-NEW-TYPE T)

(DEFN UPDATE-KNOWN-TYPES
      (NEW-TYPES KNOWN-TYPES)
      (IF (OR (NLISTP NEW-TYPES)
              (FALSEP KNOWN-TYPES))
          KNOWN-TYPES
          (UPDATE-KNOWN-TYPES (CDR NEW-TYPES)
                              (ADD-NEW-TYPE (CAR NEW-TYPES)
                                            KNOWN-TYPES))))

(TOGGLE UPDATE-KNOWN-TYPES-OFF UPDATE-KNOWN-TYPES T)

(DEFN FIX-DEPENDENT-TYPES
      (TYPES ALIST)
      (COND ((NLISTP TYPES) NIL)
            ((LISTP (CAR TYPES))
             (CONS (VALUE (CAAR TYPES) ALIST)
                   (FIX-DEPENDENT-TYPES (CDR TYPES)
                                        ALIST)))
            (T (CONS (CAR TYPES)
                     (FIX-DEPENDENT-TYPES (CDR TYPES)
                                          ALIST)))))

(TOGGLE FIX-DEPENDENT-TYPES-OFF FIX-DEPENDENT-TYPES T)

(DEFN IO-TYPES-SIMPLE
 (FLG X0 X1 NETLIST TYPE-TABLE)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (CONS (PRIMP2 X0 'INPUT-TYPES)
           (FIX-DEPENDENT-TYPES (PRIMP2 X0 'OUTPUT-TYPES)
                                (PAIRLIST (PRIMP2 X0 'INPUTS) X1))))
    ((AND (LOOKUP-MODULE 'INPUT-TYPES
                         (CDR (LOOKUP-MODULE X0 TYPE-TABLE)))
          (LOOKUP-MODULE 'OUTPUT-TYPES
                         (CDR (LOOKUP-MODULE X0 TYPE-TABLE))))
     (CONS
      (CDR (LOOKUP-MODULE 'INPUT-TYPES
                          (CDR (LOOKUP-MODULE X0 TYPE-TABLE))))
      (FIX-DEPENDENT-TYPES
                      (CDR (LOOKUP-MODULE 'OUTPUT-TYPES
                                          (CDR (LOOKUP-MODULE X0 TYPE-TABLE))))
                      (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                X1))))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (IF
      (IO-TYPES-SIMPLE 1
                       (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                       NIL
                       (DELETE-MODULE X0 NETLIST)
                       TYPE-TABLE)
      (CONS
       (COLLECT-TYPES
               (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
               (IO-TYPES-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL
                                (DELETE-MODULE X0 NETLIST)
                                TYPE-TABLE)
               T)
       (FIX-DEPENDENT-TYPES
        (COLLECT-TYPES
               (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
               (IO-TYPES-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL
                                (DELETE-MODULE X0 NETLIST)
                                TYPE-TABLE)
               F)
        (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                  X1)))
      F))
    (T F)))
  (1
   (COND
    ((NLISTP X0) X1)
    ((LISTP (IO-TYPES-SIMPLE 0
                             (OCC-FUNCTION (CAR X0))
                             (COLLECT-TYPES (OCC-INPUTS (CAR X0))
                                            X1 F)
                             NETLIST TYPE-TABLE))
     (IF
      (UPDATE-KNOWN-TYPES
       (PAIRLIST (OCC-OUTPUTS (CAR X0))
                 (CDR (IO-TYPES-SIMPLE 0
                                       (OCC-FUNCTION (CAR X0))
                                       (COLLECT-TYPES (OCC-INPUTS (CAR X0))
                                                      X1 F)
                                       NETLIST TYPE-TABLE)))
       (UPDATE-KNOWN-TYPES
           (PAIRLIST (OCC-INPUTS (CAR X0))
                     (CAR (IO-TYPES-SIMPLE 0
                                           (OCC-FUNCTION (CAR X0))
                                           (COLLECT-TYPES (OCC-INPUTS (CAR X0))
                                                          X1 F)
                                           NETLIST TYPE-TABLE)))
           X1))
      (IO-TYPES-SIMPLE 1
       (CDR X0)
       (UPDATE-KNOWN-TYPES
        (PAIRLIST (OCC-OUTPUTS (CAR X0))
                  (CDR (IO-TYPES-SIMPLE 0
                                        (OCC-FUNCTION (CAR X0))
                                        (COLLECT-TYPES (OCC-INPUTS (CAR X0))
                                                       X1 F)
                                        NETLIST TYPE-TABLE)))
        (UPDATE-KNOWN-TYPES
           (PAIRLIST (OCC-INPUTS (CAR X0))
                     (CAR (IO-TYPES-SIMPLE 0
                                           (OCC-FUNCTION (CAR X0))
                                           (COLLECT-TYPES (OCC-INPUTS (CAR X0))
                                                          X1 F)
                                           NETLIST TYPE-TABLE)))
           X1))
       NETLIST TYPE-TABLE)
      F))
    (T F)))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE IO-TYPES-SIMPLE-OFF IO-TYPES-SIMPLE T)

(DEFN NETLIST-TYPE-TABLE-SIMPLE
 (NETLIST)
 (COND
  ((NLISTP NETLIST) NIL)
  ((NETLIST-TYPE-TABLE-SIMPLE (CDR NETLIST))
   (IF
    (LISTP (IO-TYPES-SIMPLE 0
                            (MODULE-NAME (CAR NETLIST))
                            (LISTIFY (MODULE-INPUTS (CAR NETLIST)))
                            NETLIST
                            (NETLIST-TYPE-TABLE-SIMPLE (CDR NETLIST))))
    (CONS
     (LIST
      (MODULE-NAME (CAR NETLIST))
      (CONS 'INPUT-TYPES
            (CAR (IO-TYPES-SIMPLE 0
                                  (MODULE-NAME (CAR NETLIST))
                                  (LISTIFY (MODULE-INPUTS (CAR NETLIST)))
                                  NETLIST
                                  (NETLIST-TYPE-TABLE-SIMPLE (CDR NETLIST)))))
      (CONS 'OUTPUT-TYPES
            (CDR (IO-TYPES-SIMPLE 0
                                  (MODULE-NAME (CAR NETLIST))
                                  (LISTIFY (MODULE-INPUTS (CAR NETLIST)))
                                  NETLIST
                                  (NETLIST-TYPE-TABLE-SIMPLE (CDR NETLIST))))))
     (NETLIST-TYPE-TABLE-SIMPLE (CDR NETLIST)))
    F))
  (T F)))

(TOGGLE NETLIST-TYPE-TABLE-SIMPLE-OFF NETLIST-TYPE-TABLE-SIMPLE T)

(DEFN TYPES-ACCEPTABLEP
 (FLG X0 NETLIST ACCEPTABLE-TYPES CHECKED-MODULES)
 (CASE FLG
  (0
   (COND
       ((PRIMP X0)
        (AND (SUBSET (PRIMP2 X0 'INPUT-TYPES)
                     ACCEPTABLE-TYPES)
             (SUBSET (FIX-DEPENDENT-TYPES (PRIMP2 X0 'OUTPUT-TYPES)
                                          (PAIRLIST (PRIMP2 X0 'INPUTS)
                                                    (PRIMP2 X0 'INPUT-TYPES)))
                     ACCEPTABLE-TYPES)))
       ((MEMBER X0 CHECKED-MODULES) T)
       ((LISTP (LOOKUP-MODULE X0 NETLIST))
        (TYPES-ACCEPTABLEP 1
                           (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                           (DELETE-MODULE X0 NETLIST)
                           ACCEPTABLE-TYPES CHECKED-MODULES))
       (T F)))
  (1 (COND ((NLISTP X0) T)
           ((TYPES-ACCEPTABLEP 0
                               (OCC-FUNCTION (CAR X0))
                               NETLIST ACCEPTABLE-TYPES CHECKED-MODULES)
            (TYPES-ACCEPTABLEP 1
                               (CDR X0)
                               NETLIST ACCEPTABLE-TYPES CHECKED-MODULES))
           (T F)))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE TYPES-ACCEPTABLEP-OFF TYPES-ACCEPTABLEP T)

(DEFN NETLIST-TYPES-ACCEPTABLE-LIST
   (NETLIST)
   (COND ((NLISTP NETLIST) NIL)
         ((NETLIST-TYPES-ACCEPTABLE-LIST (CDR NETLIST))
          (IF (TYPES-ACCEPTABLEP 0
                                 (MODULE-NAME (CAR NETLIST))
                                 NETLIST
                                 '(BOOLP CLK LEVEL CLK-10 FREE)
                                 (NETLIST-TYPES-ACCEPTABLE-LIST (CDR NETLIST)))
              (CONS (MODULE-NAME (CAR NETLIST))
                    (NETLIST-TYPES-ACCEPTABLE-LIST (CDR NETLIST)))
              F))
         (T F)))

(TOGGLE NETLIST-TYPES-ACCEPTABLE-LIST-OFF NETLIST-TYPES-ACCEPTABLE-LIST T)

(DEFN NETLIST-TYPE-CHECK-SIMPLE-OKP
      (NETLIST)
      (IF (NETLIST-TYPES-ACCEPTABLE-LIST NETLIST)
          (NETLIST-TYPE-TABLE-SIMPLE NETLIST)
          F))

(TOGGLE NETLIST-TYPE-CHECK-SIMPLE-OKP-OFF NETLIST-TYPE-CHECK-SIMPLE-OKP T)

(DEFN ARG-TYPES-MATCH-SIMPLEP
      (ACTUALS FORMALS)
      (IF (OR (NLISTP ACTUALS) (NLISTP FORMALS))
          (EQUAL ACTUALS FORMALS)
          (AND (OR (EQUAL (CAR ACTUALS) (CAR FORMALS))
                   (EQUAL (CAR FORMALS) 'FREE))
               (ARG-TYPES-MATCH-SIMPLEP (CDR ACTUALS)
                                        (CDR FORMALS)))))

(TOGGLE ARG-TYPES-MATCH-SIMPLEP-OFF ARG-TYPES-MATCH-SIMPLEP T)

(DEFN ARG-TYPES-SIMPLE-OKP
 (FN ARG-TYPES NETLIST)
 (COND
  ((NOT (SUBSET ARG-TYPES
                '(BOOLP CLK LEVEL CLK-10)))
   F)
  ((LISTP (IO-TYPES-SIMPLE 0 FN ARG-TYPES NETLIST
                           (NETLIST-TYPE-TABLE-SIMPLE NETLIST)))
   (ARG-TYPES-MATCH-SIMPLEP ARG-TYPES
                  (CAR (IO-TYPES-SIMPLE 0 FN ARG-TYPES NETLIST
                                        (NETLIST-TYPE-TABLE-SIMPLE NETLIST)))))
  (T F)))

(TOGGLE ARG-TYPES-SIMPLE-OKP-OFF ARG-TYPES-SIMPLE-OKP T)

(DEFN MAKE-RAM-STATE
      (STRUCTURE WIDTH BIT-VALUE)
      (IF (NLISTP STRUCTURE)
          (RAM (MAKE-LIST WIDTH BIT-VALUE))
          (CONS (MAKE-RAM-STATE (CAR STRUCTURE)
                                WIDTH BIT-VALUE)
                (MAKE-RAM-STATE (CDR STRUCTURE)
                                WIDTH BIT-VALUE))))

(TOGGLE MAKE-RAM-STATE-OFF MAKE-RAM-STATE T)

(DEFN STATE-TYPE-REQUIREMENT-SIMPLE
 (FLG X0 X1 NETLIST TYPE-TABLE)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (IF (LOOKUP-MODULE 'STATE-TYPES
                        (CDR (PRIMP X0)))
         (EVAL$ T
                (CDR (LOOKUP-MODULE 'STATE-TYPES
                                    (CDR (PRIMP X0))))
                NIL)
         T))
    ((LOOKUP-MODULE X0 TYPE-TABLE)
     (IF (LOOKUP-MODULE 'STATE-TYPES
                        (CDR (LOOKUP-MODULE X0 TYPE-TABLE)))
         (CDR (LOOKUP-MODULE 'STATE-TYPES
                             (CDR (LOOKUP-MODULE X0 TYPE-TABLE))))
         T))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (IF
      (SET-EQUAL
       (M-STATES-LIST (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST)))
       (STRIP-CARS
        (STATE-TYPE-REQUIREMENT-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL
                                (DELETE-MODULE X0 NETLIST)
                                TYPE-TABLE)))
      (IF
       (EQUAL (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
              NIL)
       T
       (COLLECT-STATES
        (MODULE-STATENAMES (LOOKUP-MODULE X0 NETLIST))
        (STATE-TYPE-REQUIREMENT-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL
                                (DELETE-MODULE X0 NETLIST)
                                TYPE-TABLE)))
      F))
    (T F)))
  (1
   (COND
    ((NLISTP X0) X1)
    ((TRUEP (STATE-TYPE-REQUIREMENT-SIMPLE 0
                                           (OCC-FUNCTION (CAR X0))
                                           NIL NETLIST TYPE-TABLE))
     (STATE-TYPE-REQUIREMENT-SIMPLE 1
                                    (CDR X0)
                                    X1 NETLIST TYPE-TABLE))
    ((STATE-TYPE-REQUIREMENT-SIMPLE 0
                                    (OCC-FUNCTION (CAR X0))
                                    NIL NETLIST TYPE-TABLE)
     (STATE-TYPE-REQUIREMENT-SIMPLE 1
             (CDR X0)
             (CONS (CONS (OCC-NAME (CAR X0))
                         (STATE-TYPE-REQUIREMENT-SIMPLE 0
                                                        (OCC-FUNCTION (CAR X0))
                                                        NIL NETLIST
                                                        TYPE-TABLE))
                   X1)
             NETLIST TYPE-TABLE))
    (T F)))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE STATE-TYPE-REQUIREMENT-SIMPLE-OFF STATE-TYPE-REQUIREMENT-SIMPLE T)

(DEFN NETLIST-STATE-TYPES-SIMPLE
 (NETLIST)
 (COND
  ((NLISTP NETLIST) NIL)
  ((NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST))
   (COND
    ((TRUEP
      (STATE-TYPE-REQUIREMENT-SIMPLE 0
                                   (MODULE-NAME (CAR NETLIST))
                                   NIL NETLIST
                                   (NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST))))
     (NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST)))
    ((STATE-TYPE-REQUIREMENT-SIMPLE 0
                                    (MODULE-NAME (CAR NETLIST))
                                    NIL NETLIST
                                    (NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST)))
     (CONS
      (LIST
       (MODULE-NAME (CAR NETLIST))
       (CONS 'STATE-TYPES
        (STATE-TYPE-REQUIREMENT-SIMPLE 0
                                  (MODULE-NAME (CAR NETLIST))
                                  NIL NETLIST
                                  (NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST)))))
      (NETLIST-STATE-TYPES-SIMPLE (CDR NETLIST))))
    (T F)))
  (T F)))

(TOGGLE NETLIST-STATE-TYPES-SIMPLE-OFF NETLIST-STATE-TYPES-SIMPLE T)

(DEFN STATE-SIMPLE-OKP
      (STATE TYPE)
      (COND ((TRUEP TYPE) (EQUAL STATE NIL))
            ((EQUAL TYPE 'BOOLP) (BOOLP STATE))
            ((RAMP TYPE)
             (AND (RAMP STATE)
                  (STATE-SIMPLE-OKP (RAM-GUTS STATE)
                                    (RAM-GUTS TYPE))))
            ((ROMP TYPE)
             (AND (ROMP STATE)
                  (STATE-SIMPLE-OKP (ROM-GUTS STATE)
                                    (ROM-GUTS TYPE))))
            ((STUBP TYPE)
             (AND (STUBP STATE)
                  (STATE-SIMPLE-OKP (STUB-GUTS STATE)
                                    (STUB-GUTS TYPE))))
            ((LISTP TYPE)
             (AND (LISTP STATE)
                  (STATE-SIMPLE-OKP (CAR STATE)
                                    (CAR TYPE))
                  (STATE-SIMPLE-OKP (CDR STATE)
                                    (CDR TYPE))))
            ((EQUAL TYPE NIL) (EQUAL STATE NIL))
            (T F)))

(TOGGLE STATE-SIMPLE-OKP-OFF STATE-SIMPLE-OKP T)

(DEFN APPLY-STATE-SIMPLE-OKP
 (FN STATE NETLIST)
 (STATE-SIMPLE-OKP STATE
         (STATE-TYPE-REQUIREMENT-SIMPLE 0 FN NIL NETLIST
                                        (NETLIST-STATE-TYPES-SIMPLE NETLIST))))

(TOGGLE APPLY-STATE-SIMPLE-OKP-OFF APPLY-STATE-SIMPLE-OKP T)

(DEFN FIX-DEPENDENT-LDS
      (LDS ALIST)
      (IF (NLISTP LDS)
          LDS
          (CONS (COND ((OR (LITATOM (CAR LDS))
                           (INDEXP (CAR LDS)))
                       (VALUE (CAR LDS) ALIST))
                      ((NLISTP (CAR LDS)) (CAR LDS))
                      (T (FIX-DEPENDENT-LDS (CAR LDS) ALIST)))
                (FIX-DEPENDENT-LDS (CDR LDS) ALIST))))

(TOGGLE FIX-DEPENDENT-LDS-OFF FIX-DEPENDENT-LDS T)

(DEFN PARENT-SYNONYM-SIMPLE
      (NAME SLIST)
      (IF (LISTP (LOOKUP-MODULE NAME SLIST))
          (IF (OR (LITATOM (CDR (LOOKUP-MODULE NAME SLIST)))
                  (INDEXP (CDR (LOOKUP-MODULE NAME SLIST))))
              (PARENT-SYNONYM-SIMPLE (CDR (LOOKUP-MODULE NAME SLIST))
                                     (DELETE-MODULE NAME SLIST))
              NAME)
          NAME))

(TOGGLE PARENT-SYNONYM-SIMPLE-OFF PARENT-SYNONYM-SIMPLE T)

(DEFN ADD-LOADING-SIMPLE
      (NAME LOADING LD-LIST)
      (IF (NLISTP (LOOKUP-MODULE NAME LD-LIST))
          (CONS (CONS NAME
                      (IF (LISTP LOADING)
                          LOADING
                          (LIST LOADING)))
                LD-LIST)
          (CONS (CONS NAME
                      (IF (LISTP LOADING)
                          (APPEND LOADING
                                  (CDR (LOOKUP-MODULE NAME LD-LIST)))
                          (CONS LOADING
                                (CDR (LOOKUP-MODULE NAME LD-LIST)))))
                (DELETE-MODULE NAME LD-LIST))))

(TOGGLE ADD-LOADING-SIMPLE-OFF ADD-LOADING-SIMPLE T)

(DEFN ADD-LOADING-SIMPLES
      (NAMES LOADINGS LD-LIST)
      (IF (NLISTP NAMES)
          LD-LIST
          (ADD-LOADING-SIMPLES (CDR NAMES)
                               (CDR LOADINGS)
                               (ADD-LOADING-SIMPLE (CAR NAMES)
                                                   (CAR LOADINGS)
                                                   LD-LIST))))

(TOGGLE ADD-LOADING-SIMPLES-OFF ADD-LOADING-SIMPLES T)

(DEFN SUM-NUMBERS
      (LST)
      (COND ((NLISTP LST) 0)
            ((NUMBERP (CAR LST))
             (PLUS (CAR LST)
                   (SUM-NUMBERS (CDR LST))))
            (T (SUM-NUMBERS (CDR LST)))))

(TOGGLE SUM-NUMBERS-OFF SUM-NUMBERS T)

(DEFN EXTRACT-NAMES-SIMPLE
      (LST)
      (COND ((NLISTP LST) NIL)
            ((AND (OR (LITATOM (CAR LST))
                      (INDEXP (CAR LST)))
                  (NOT (MEMBER (CAR LST) (CDR LST))))
             (CONS (CAR LST)
                   (EXTRACT-NAMES-SIMPLE (CDR LST))))
            (T (EXTRACT-NAMES-SIMPLE (CDR LST)))))

(TOGGLE EXTRACT-NAMES-SIMPLE-OFF EXTRACT-NAMES-SIMPLE T)

(DEFN SUM-LOADING
      (LD)
      (CONS (CAR LD)
            (COND ((NLISTP (EXTRACT-NAMES-SIMPLE (CDR LD)))
                   (LIST (SUM-NUMBERS (CDR LD))))
                  ((ZEROP (SUM-NUMBERS (CDR LD)))
                   (EXTRACT-NAMES-SIMPLE (CDR LD)))
                  (T (CONS (SUM-NUMBERS (CDR LD))
                           (EXTRACT-NAMES-SIMPLE (CDR LD)))))))

(TOGGLE SUM-LOADING-OFF SUM-LOADING T)

(DEFN SUM-LOADINGS
      (LDS)
      (IF (NLISTP LDS)
          NIL
          (CONS (SUM-LOADING (CAR LDS))
                (SUM-LOADINGS (CDR LDS)))))

(TOGGLE SUM-LOADINGS-OFF SUM-LOADINGS T)

(DEFN FIX-LOADINGS
   (SLIST LDS)
   (COND ((NLISTP SLIST) (SUM-LOADINGS LDS))
         ((OR (LITATOM (CDAR SLIST))
              (INDEXP (CDAR SLIST)))
          (FIX-LOADINGS (CDR SLIST)
                        (ADD-LOADING-SIMPLE (CDAR SLIST)
                                            (VALUE (CAAR SLIST) LDS)
                                            (DELETE-MODULE (CAAR SLIST) LDS))))
         (T (FIX-LOADINGS (CDR SLIST) LDS))))

(TOGGLE FIX-LOADINGS-OFF FIX-LOADINGS T)

(DEFN FIX-DRIVES
      (DRS SLIST)
      (COND ((NLISTP DRS) NIL)
            ((OR (LITATOM (CDAR DRS))
                 (INDEXP (CDAR DRS)))
             (CONS (CONS (CAAR DRS)
                         (PARENT-SYNONYM-SIMPLE (CDAR DRS)
                                                SLIST))
                   (FIX-DRIVES (CDR DRS) SLIST)))
            (T (CONS (CAR DRS)
                     (FIX-DRIVES (CDR DRS) SLIST)))))

(TOGGLE FIX-DRIVES-OFF FIX-DRIVES T)

(DEFN NET-DRIVES
   (DRS LDS)
   (COND ((NLISTP DRS) NIL)
         ((NUMBERP (CDAR DRS))
          (COND ((LESSP (CDAR DRS)
                        (SUM-NUMBERS (VALUE (CAAR DRS) LDS)))
                 F)
                ((NET-DRIVES (CDR DRS) LDS)
                 (CONS (CONS (CAAR DRS)
                             (DIFFERENCE (CDAR DRS)
                                         (SUM-NUMBERS (VALUE (CAAR DRS) LDS))))
                       (NET-DRIVES (CDR DRS) LDS)))
                (T F)))
         ((NET-DRIVES (CDR DRS) LDS)
          (CONS (CAR DRS)
                (NET-DRIVES (CDR DRS) LDS)))
         (T F)))

(TOGGLE NET-DRIVES-OFF NET-DRIVES T)

(DEFN EXTERNAL-LOADING
      (LD-LST EXTERNAL-NAMES)
      (COND ((NLISTP LD-LST) LD-LST)
            ((AND (OR (LITATOM (CAR LD-LST))
                      (INDEXP (CAR LD-LST)))
                  (NOT (MEMBER (CAR LD-LST) EXTERNAL-NAMES)))
             (EXTERNAL-LOADING (CDR LD-LST)
                               EXTERNAL-NAMES))
            (T (CONS (CAR LD-LST)
                     (EXTERNAL-LOADING (CDR LD-LST)
                                       EXTERNAL-NAMES)))))

(TOGGLE EXTERNAL-LOADING-OFF EXTERNAL-LOADING T)

(DEFN COLLECT-LOADINGS-SIMPLE
 (NAMES LOADINGS EXTERNAL-NAMES)
 (COND
      ((NLISTP NAMES) NIL)
      ((LOOKUP-MODULE (CAR NAMES) LOADINGS)
       (CONS (COND ((NLISTP (EXTERNAL-LOADING (VALUE (CAR NAMES) LOADINGS)
                                              EXTERNAL-NAMES))
                    0)
                   ((NLISTP (CDR (EXTERNAL-LOADING (VALUE (CAR NAMES) LOADINGS)
                                                   EXTERNAL-NAMES)))
                    (CAR (EXTERNAL-LOADING (VALUE (CAR NAMES) LOADINGS)
                                           EXTERNAL-NAMES)))
                   (T (EXTERNAL-LOADING (VALUE (CAR NAMES) LOADINGS)
                                        EXTERNAL-NAMES)))
             (COLLECT-LOADINGS-SIMPLE (CDR NAMES)
                                      LOADINGS EXTERNAL-NAMES)))
      (T (CONS 0
               (COLLECT-LOADINGS-SIMPLE (CDR NAMES)
                                        LOADINGS EXTERNAL-NAMES)))))

(TOGGLE COLLECT-LOADINGS-SIMPLE-OFF COLLECT-LOADINGS-SIMPLE T)

(DEFN COLLECT-DRIVES-SIMPLE
 (NAMES DRIVES EXTERNAL-NAMES)
 (COND
  ((NLISTP NAMES) NIL)
  ((OR (NOT (OR (LITATOM (VALUE (CAR NAMES) DRIVES))
                (INDEXP (VALUE (CAR NAMES) DRIVES))))
       (MEMBER (VALUE (CAR NAMES) DRIVES)
               EXTERNAL-NAMES))
   (CONS (VALUE (CAR NAMES) DRIVES)
         (COLLECT-DRIVES-SIMPLE (CDR NAMES)
                                DRIVES EXTERNAL-NAMES)))
  ((EQUAL (PARENT-SYNONYM-SIMPLE (VALUE (CAR NAMES) DRIVES)
                                 DRIVES)
          (VALUE (CAR NAMES) DRIVES))
   (CONS
    (VALUE (VALUE (CAR NAMES) DRIVES)
           DRIVES)
    (COLLECT-DRIVES-SIMPLE
           (CDR NAMES)
           (CONS (CONS (VALUE (CAR NAMES) DRIVES)
                       (CAR NAMES))
                 (CONS (CONS (CAR NAMES)
                             (VALUE (VALUE (CAR NAMES) DRIVES)
                                    DRIVES))
                       (DELETE-MODULE (CAR NAMES)
                                      (DELETE-MODULE (VALUE (CAR NAMES) DRIVES)
                                                     DRIVES))))
           EXTERNAL-NAMES)))
  (T (CONS (PARENT-SYNONYM-SIMPLE (VALUE (CAR NAMES) DRIVES)
                                  DRIVES)
           (COLLECT-DRIVES-SIMPLE (CDR NAMES)
                                  DRIVES EXTERNAL-NAMES)))))

(TOGGLE COLLECT-DRIVES-SIMPLE-OFF COLLECT-DRIVES-SIMPLE T)

(DEFN LOADINGS-AND-DRIVES-SIMPLE
 (FLG X0 X1 X2 NETLIST LDS-TABLE)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (CONS (FIX-DEPENDENT-LDS (PRIMP2 X0 'LOADINGS)
                              (APPEND (PAIRLIST (PRIMP2 X0 'INPUTS) X1)
                                      (PAIRLIST (PRIMP2 X0 'OUTPUTS) X2)))
           (FIX-DEPENDENT-LDS (PRIMP2 X0 'DRIVES)
                              (APPEND (PAIRLIST (PRIMP2 X0 'INPUTS) X1)
                                      (PAIRLIST (PRIMP2 X0 'OUTPUTS)
                                                X2)))))
    ((AND (LOOKUP-MODULE 'LOADINGS
                         (CDR (LOOKUP-MODULE X0 LDS-TABLE)))
          (LOOKUP-MODULE 'DRIVES
                         (CDR (LOOKUP-MODULE X0 LDS-TABLE))))
     (CONS
      (FIX-DEPENDENT-LDS
                  (CDR (LOOKUP-MODULE 'LOADINGS
                                      (CDR (LOOKUP-MODULE X0 LDS-TABLE))))
                  (APPEND (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                    X1)
                          (PAIRLIST (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
                                    X2)))
      (FIX-DEPENDENT-LDS
                  (CDR (LOOKUP-MODULE 'DRIVES
                                      (CDR (LOOKUP-MODULE X0 LDS-TABLE))))
                  (APPEND (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                                    X1)
                          (PAIRLIST (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
                                    X2)))))
    ((LISTP (LOOKUP-MODULE X0 NETLIST))
     (IF
      (LOADINGS-AND-DRIVES-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL NIL
                                (DELETE-MODULE X0 NETLIST)
                                LDS-TABLE)
      (CONS
       (FIX-DEPENDENT-LDS
        (COLLECT-LOADINGS-SIMPLE
         (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
         (CAR
          (LOADINGS-AND-DRIVES-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL NIL
                                (DELETE-MODULE X0 NETLIST)
                                LDS-TABLE))
         (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST)))
        (APPEND (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                          X1)
                (PAIRLIST (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
                          X2)))
       (FIX-DEPENDENT-LDS
        (COLLECT-DRIVES-SIMPLE
         (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
         (CDR
          (LOADINGS-AND-DRIVES-SIMPLE 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NIL NIL
                                (DELETE-MODULE X0 NETLIST)
                                LDS-TABLE))
         (APPEND (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                 (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))))
        (APPEND (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE X0 NETLIST))
                          X1)
                (PAIRLIST (MODULE-OUTPUTS (LOOKUP-MODULE X0 NETLIST))
                          X2))))
      F))
    (T F)))
  (1
   (COND
    ((NLISTP X0)
     (IF (AND (FIX-LOADINGS (FIX-DRIVES X2 X2) X1)
              (NET-DRIVES (FIX-DRIVES X2 X2)
                          (FIX-LOADINGS (FIX-DRIVES X2 X2) X1)))
         (CONS (FIX-LOADINGS (FIX-DRIVES X2 X2) X1)
               (NET-DRIVES (FIX-DRIVES X2 X2)
                           (FIX-LOADINGS (FIX-DRIVES X2 X2) X1)))
         F))
    ((LOADINGS-AND-DRIVES-SIMPLE 0
                                 (OCC-FUNCTION (CAR X0))
                                 (OCC-INPUTS (CAR X0))
                                 (OCC-OUTPUTS (CAR X0))
                                 NETLIST LDS-TABLE)
     (LOADINGS-AND-DRIVES-SIMPLE 1
      (CDR X0)
      (ADD-LOADING-SIMPLES
                       (OCC-INPUTS (CAR X0))
                       (CAR (LOADINGS-AND-DRIVES-SIMPLE 0
                                                        (OCC-FUNCTION (CAR X0))
                                                        (OCC-INPUTS (CAR X0))
                                                        (OCC-OUTPUTS (CAR X0))
                                                        NETLIST LDS-TABLE))
                       X1)
      (APPEND
             (PAIRLIST (OCC-OUTPUTS (CAR X0))
                       (CDR (LOADINGS-AND-DRIVES-SIMPLE 0
                                                        (OCC-FUNCTION (CAR X0))
                                                        (OCC-INPUTS (CAR X0))
                                                        (OCC-OUTPUTS (CAR X0))
                                                        NETLIST LDS-TABLE)))
             X2)
      NETLIST LDS-TABLE))
    (T F)))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE LOADINGS-AND-DRIVES-SIMPLE-OFF LOADINGS-AND-DRIVES-SIMPLE T)

(DEFN NETLIST-LOADINGS-AND-DRIVES-SIMPLE
 (NETLIST)
 (COND
  ((NLISTP NETLIST) NIL)
  ((NETLIST-LOADINGS-AND-DRIVES-SIMPLE (CDR NETLIST))
   (IF
    (LOADINGS-AND-DRIVES-SIMPLE 0
                            (MODULE-NAME (CAR NETLIST))
                            (MODULE-INPUTS (CAR NETLIST))
                            (MODULE-OUTPUTS (CAR NETLIST))
                            NETLIST
                            (NETLIST-LOADINGS-AND-DRIVES-SIMPLE (CDR NETLIST)))
    (CONS
     (LIST
      (MODULE-NAME (CAR NETLIST))
      (CONS 'LOADINGS
       (CAR
        (LOADINGS-AND-DRIVES-SIMPLE 0
                          (MODULE-NAME (CAR NETLIST))
                          (MODULE-INPUTS (CAR NETLIST))
                          (MODULE-OUTPUTS (CAR NETLIST))
                          NETLIST
                          (NETLIST-LOADINGS-AND-DRIVES-SIMPLE (CDR NETLIST)))))
      (CONS 'DRIVES
       (CDR
        (LOADINGS-AND-DRIVES-SIMPLE 0
                         (MODULE-NAME (CAR NETLIST))
                         (MODULE-INPUTS (CAR NETLIST))
                         (MODULE-OUTPUTS (CAR NETLIST))
                         NETLIST
                         (NETLIST-LOADINGS-AND-DRIVES-SIMPLE (CDR NETLIST))))))
     (NETLIST-LOADINGS-AND-DRIVES-SIMPLE (CDR NETLIST)))
    F))
  (T F)))

(TOGGLE NETLIST-LOADINGS-AND-DRIVES-SIMPLE-OFF
        NETLIST-LOADINGS-AND-DRIVES-SIMPLE T)

(DEFN TOP-LEVEL-PREDICATE-SIMPLE
      (NETLIST)
      (COND ((NOT (NETLIST-SYNTAX-SIMPLE-OKP NETLIST))
             'NETLIST-SYNTAX-SIMPLE-OKP-ERROR)
            ((NOT (SIMPLE-DEPENDENCY-TABLE NETLIST))
             'DEPENDENCY-TABLE-SIMPLE-ERROR)
            ((NOT (NETLIST-TYPE-CHECK-SIMPLE-OKP NETLIST))
             'NETLIST-TYPE-CHECK-SIMPLE-OKP-ERROR)
            ((NOT (NETLIST-STATE-TYPES-SIMPLE NETLIST))
             'NETLIST-STATE-TYPES-SIMPLE-ERROR)
            ((NOT (NETLIST-LOADINGS-AND-DRIVES-SIMPLE NETLIST))
             'NETLIST-LOADINGS-AND-DRIVES-SIMPLE-ERROR)
            (T T)))

(DEFN NAME-OKP
      (NAME)
      (IF (LITATOM NAME)
          T
          (AND (INDEXP NAME)
               (LITATOM (I-NAME NAME)))))

(TOGGLE NAME-OKP-OFF NAME-OKP T)

(DEFN BAD-NAMES
      (NAME-LIST)
      (IF (LISTP NAME-LIST)
          (IF (NAME-OKP (CAR NAME-LIST))
              (BAD-NAMES (CDR NAME-LIST))
              (INSERT (CAR NAME-LIST)
                      (BAD-NAMES (CDR NAME-LIST))))
          NIL))

(TOGGLE BAD-NAMES-OFF BAD-NAMES T)

(DEFN NAME-LIST-ERRORS
      (NAME-LIST DUPLICATES-OK?)
      (LIST (NLISTP-OR-ERR (BAD-NAMES NAME-LIST)
                           'BAD-NAMES)
            (IF DUPLICATES-OK? T
                (NO-DUPLICATES-OR-ERR NAME-LIST 'DUPLICATES))
            (NIL-OR-ERR (LAST-CDR NAME-LIST)
                        'NOT-PROPER-LIST)))

(TOGGLE NAME-LIST-ERRORS-OFF NAME-LIST-ERRORS T)

(DEFN NAME-LIST-OK
      (NAME-LIST LABEL DUPLICATES-OK?)
      (ERR-AND (NAME-LIST-ERRORS NAME-LIST DUPLICATES-OK?)
               LABEL))

(TOGGLE NAME-LIST-OK-OFF NAME-LIST-OK T)

(DEFN OCC-ARG-LENGTH-ERROR
      (FN EXPECTED-ARGS ACTUAL-ARGS LABEL)
      (T-OR-ERR (EQUAL (LENGTH EXPECTED-ARGS)
                       (LENGTH ACTUAL-ARGS))
                LABEL
                (LIST 'OCC-FUNCTION
                      FN
                      (LIST 'EXPECTED
                            (LENGTH EXPECTED-ARGS))
                      (LIST 'GOT (LENGTH ACTUAL-ARGS)))))

(TOGGLE OCC-ARG-LENGTH-ERROR-OFF OCC-ARG-LENGTH-ERROR T)

(DEFN OCC-FORM-OK
      (OCC O-LENGTH)
      (ERR-AND (LIST (T-OR-ERR (OR (EQUAL 4 O-LENGTH)
                                   (EQUAL 5 O-LENGTH))
                               'BAD-OCCURRENCE-LENGTH
                               O-LENGTH)
                     (NIL-OR-ERR (LAST-CDR OCC)
                                 'NOT-PROPER-LIST))
               'OCCURRENCE-FORM))

(TOGGLE OCC-FORM-OK-OFF OCC-FORM-OK T)

(DEFN OCC-NAME-OK
      (O-NAME O-LENGTH)
      (IF (IF (LESSP O-LENGTH 1) F T)
          (LABEL-ERROR (T-OR-ERR (NAME-OKP O-NAME)
                                 'BAD-NAME
                                 O-NAME)
                       'OCCURRENCE-NAME)
          T))

(TOGGLE OCC-NAME-OK-OFF OCC-NAME-OK T)

(DEFN OCC-OUTPUTS-OK
      (O-OUTS O-LENGTH)
      (IF (IF (LESSP O-LENGTH 2) F T)
          (NAME-LIST-OK O-OUTS 'OCCURRENCE-OUTPUTS
                        F)
          T))

(TOGGLE OCC-OUTPUTS-OK-OFF OCC-OUTPUTS-OK T)

(DEFN OCC-INPUTS-OK
      (O-INS O-LENGTH)
      (IF (IF (LESSP O-LENGTH 4) F T)
          (NAME-LIST-OK O-INS 'OCCURRENCE-INPUTS
                        T)
          T))

(TOGGLE OCC-INPUTS-OK-OFF OCC-INPUTS-OK T)

(DEFN OCC-FUNCTION-OK
 (O-FN O-INS O-OUTS O-LENGTH NETLIST)
 (COND
  ((LESSP O-LENGTH 3) T)
  ((PRIMP O-FN)
   (ERR-AND (LIST (IF (IF (LESSP O-LENGTH 4) F T)
                      (OCC-ARG-LENGTH-ERROR O-FN
                                            (PRIMP2 O-FN 'INPUTS)
                                            O-INS
                                            'WRONG-NUMBER-OF-INPUTS)
                      T)
                  (OCC-ARG-LENGTH-ERROR O-FN
                                        (PRIMP2 O-FN 'OUTPUTS)
                                        O-OUTS
                                        'WRONG-NUMBER-OF-OUTPUTS))
            'OCCURRENCE-FUNCTION))
  ((LISTP (LOOKUP-MODULE O-FN NETLIST))
   (ERR-AND
    (LIST
         (IF (IF (LESSP O-LENGTH 4) F T)
             (OCC-ARG-LENGTH-ERROR O-FN
                                   (MODULE-INPUTS (LOOKUP-MODULE O-FN NETLIST))
                                   O-INS 'WRONG-NUMBER-OF-INPUTS)
             T)
         (OCC-ARG-LENGTH-ERROR O-FN
                               (MODULE-OUTPUTS (LOOKUP-MODULE O-FN NETLIST))
                               O-OUTS 'WRONG-NUMBER-OF-OUTPUTS))
    'OCCURRENCE-FUNCTION))
  (T (PRED-ERROR 'UNKNOWN-OCCURRENCE-FUNCTION
                 O-FN))))

(TOGGLE OCC-FUNCTION-OK-OFF OCC-FUNCTION-OK T)

(DEFN OCC-ANNOTATION-OK
      (O-ANNO O-LENGTH)
      (IF (EQUAL O-LENGTH 5)
          (LABEL-ERROR (T-OR-ERR (ALISTP O-ANNO)
                                 'NOT-ALIST
                                 O-ANNO)
                       'OCCURRENCE-ANNOTATION)
          T))

(TOGGLE OCC-ANNOTATION-OK-OFF OCC-ANNOTATION-OK T)

(DEFN OCC-SYNTAX-ERRORS
      (OCC NETLIST)
      (LIST (OCC-FORM-OK OCC (LENGTH OCC))
            (OCC-NAME-OK (OCC-NAME OCC)
                         (LENGTH OCC))
            (OCC-OUTPUTS-OK (OCC-OUTPUTS OCC)
                            (LENGTH OCC))
            (OCC-INPUTS-OK (OCC-INPUTS OCC)
                           (LENGTH OCC))
            (OCC-FUNCTION-OK (OCC-FUNCTION OCC)
                             (OCC-INPUTS OCC)
                             (OCC-OUTPUTS OCC)
                             (LENGTH OCC)
                             NETLIST)
            (OCC-ANNOTATION-OK (OCC-ANNOTATION OCC)
                               (LENGTH OCC))))

(TOGGLE OCC-SYNTAX-ERRORS-OFF OCC-SYNTAX-ERRORS T)

(DEFN OCC-SYNTAX-OK
      (OCC NETLIST)
      (ERR-AND (OCC-SYNTAX-ERRORS OCC NETLIST)
               (LIST 'OCCURRENCE (OCC-NAME OCC))))

(TOGGLE OCC-SYNTAX-OK-OFF OCC-SYNTAX-OK T)

(DEFN INITIAL-OCC-SYNTAX-DATA
      (M-INS M-OUTS)
      (CONS (CONS 'SIGNALS M-INS)
            (CONS (CONS 'PENDING-IO
                        (INTERSECTION M-INS M-OUTS))
                  '((NON-DEPENDS) (OCC-NAMES)))))

(TOGGLE INITIAL-OCC-SYNTAX-DATA-OFF INITIAL-OCC-SYNTAX-DATA T)

(DEFN UPDATE-OCC-SYNTAX-DATA
      (OCC OCC-DATA)
      (LIST (CONS 'SIGNALS
                  (APPEND (IF (LISTP (VALUE 'PENDING-IO OCC-DATA))
                              (SET-DIFF (OCC-OUTPUTS OCC)
                                        (VALUE 'PENDING-IO OCC-DATA))
                              (OCC-OUTPUTS OCC))
                          (VALUE 'SIGNALS OCC-DATA)))
            (CONS 'PENDING-IO
                  (SET-DIFF (VALUE 'PENDING-IO OCC-DATA)
                            (OCC-OUTPUTS OCC)))
            (CONS 'NON-DEPENDS
                  (APPEND (SET-DIFF (OCC-INPUTS OCC)
                                    (VALUE 'SIGNALS OCC-DATA))
                          (VALUE 'NON-DEPENDS OCC-DATA)))
            (CONS 'OCC-NAMES
                  (CONS (OCC-NAME OCC)
                        (VALUE 'OCC-NAMES OCC-DATA)))))

(TOGGLE UPDATE-OCC-SYNTAX-DATA-OFF UPDATE-OCC-SYNTAX-DATA T)

(DEFN COMPOSITE-OCC-BODY-SYNTAX-ERRORS
      (BODY OCC-DATA OUTPUTS STATES)
      (LIST (NIL-OR-ERR BODY 'NOT-PROPER-LIST)
            (NLISTP-OR-ERR (VALUE 'PENDING-IO OCC-DATA)
                           'IO-SIGNALS-NOT-IN-OUTPUTS)
            (SUBSET-OR-ERR OUTPUTS
                           (VALUE 'SIGNALS OCC-DATA)
                           'OUTPUTS-NOT-IN-SIGNALS)
            (SUBSET-OR-ERR (VALUE 'NON-DEPENDS OCC-DATA)
                           (VALUE 'SIGNALS OCC-DATA)
                           'NON-DEPENDS-NOT-IN-SIGNALS)
            (SUBSET-OR-ERR STATES
                           (VALUE 'OCC-NAMES OCC-DATA)
                           'STATES-NOT-IN-OCC-NAMES)
            (NO-DUPLICATES-OR-ERR (VALUE 'SIGNALS OCC-DATA)
                                  'DUPLICATES-IN-SIGNALS)
            (NO-DUPLICATES-OR-ERR (VALUE 'OCC-NAMES OCC-DATA)
                                  'DUPLICATES-IN-OCC-NAMES)))

(TOGGLE COMPOSITE-OCC-BODY-SYNTAX-ERRORS-OFF COMPOSITE-OCC-BODY-SYNTAX-ERRORS T)

(DEFN OCC-BODY-SYNTAX-ERRORS
      (BODY OCC-DATA OUTPUTS STATES NETLIST)
      (IF (NLISTP BODY)
          (COMPOSITE-OCC-BODY-SYNTAX-ERRORS BODY OCC-DATA OUTPUTS STATES)
          (CONS (OCC-SYNTAX-OK (CAR BODY) NETLIST)
                (OCC-BODY-SYNTAX-ERRORS (CDR BODY)
                                        (UPDATE-OCC-SYNTAX-DATA (CAR BODY)
                                                                OCC-DATA)
                                        OUTPUTS STATES NETLIST))))

(TOGGLE OCC-BODY-SYNTAX-ERRORS-OFF OCC-BODY-SYNTAX-ERRORS T)

(DEFN MODULE-FORM-OK
      (MODULE M-LENGTH)
      (ERR-AND (LIST (T-OR-ERR (OR (EQUAL M-LENGTH 5)
                                   (EQUAL M-LENGTH 6))
                               'BAD-MODULE-LENGTH
                               M-LENGTH)
                     (NIL-OR-ERR (LAST-CDR MODULE)
                                 'NOT-PROPER-LIST))
               'MODULE-FORM))

(TOGGLE MODULE-FORM-OK-OFF MODULE-FORM-OK T)

(DEFN MODULE-NAME-OK
      (M-NAME M-LENGTH NETLIST)
      (IF (IF (LESSP M-LENGTH 1) F T)
          (ERR-AND (LIST (T-OR-ERR (NAME-OKP M-NAME)
                                   'BAD-NAME
                                   M-NAME)
                         (T-OR-ERR (NOT (LOOKUP-MODULE M-NAME NETLIST))
                                   'DUPLICATE-MODULE-DEFNS
                                   M-NAME)
                         (T-OR-ERR (NOT (PRIMP M-NAME))
                                   'MODULE-NAME-SAME-AS-PRIMITIVE
                                   M-NAME))
                   'MODULE-NAME)
          T))

(TOGGLE MODULE-NAME-OK-OFF MODULE-NAME-OK T)

(DEFN MODULE-INPUTS-OK
      (M-INS M-LENGTH)
      (IF (IF (LESSP M-LENGTH 2) F T)
          (NAME-LIST-OK M-INS 'MODULE-INPUTS F)
          T))

(TOGGLE MODULE-INPUTS-OK-OFF MODULE-INPUTS-OK T)

(DEFN MODULE-OUTPUTS-OK
      (M-OUTS M-LENGTH)
      (IF (IF (LESSP M-LENGTH 3) F T)
          (NAME-LIST-OK M-OUTS 'MODULE-OUTPUTS
                        F)
          T))

(TOGGLE MODULE-OUTPUTS-OK-OFF MODULE-OUTPUTS-OK T)

(DEFN STATES-LIST-OR-NIL
      (M-STATES M-LENGTH)
      (IF (IF (LESSP M-LENGTH 5) F T)
          (M-STATES-LIST M-STATES)
          NIL))

(TOGGLE STATES-LIST-OR-NIL-OFF STATES-LIST-OR-NIL T)

(DEFN MODULE-OCCURRENCES-OK
 (M-OCCS M-INS M-OUTS M-STATES M-LENGTH NETLIST)
 (IF
  (IF (LESSP M-LENGTH 4) F T)
  (ERR-AND (CONS (T-OR-ERR (LISTP M-OCCS)
                           'NO-OCCURRENCES
                           M-OCCS)
                 (OCC-BODY-SYNTAX-ERRORS M-OCCS
                                         (INITIAL-OCC-SYNTAX-DATA M-INS M-OUTS)
                                         M-OUTS
                                         (STATES-LIST-OR-NIL M-STATES M-LENGTH)
                                         NETLIST))
           'MODULE-OCCURRENCES)
  T))

(TOGGLE MODULE-OCCURRENCES-OK-OFF MODULE-OCCURRENCES-OK T)

(DEFN MODULE-STATENAMES-OK
      (M-STATES M-LENGTH)
      (IF (IF (LESSP M-LENGTH 5) F T)
          (ERR-AND (CONS (T-OR-ERR (IF (LISTP M-STATES)
                                       (LISTP (CDR M-STATES))
                                       T)
                                   'LIST-OF-LENGTH-1-NOT-ALLOWED
                                   M-STATES)
                         (NAME-LIST-ERRORS (M-STATES-LIST M-STATES)
                                           F))
                   'MODULE-STATENAMES)
          T))

(TOGGLE MODULE-STATENAMES-OK-OFF MODULE-STATENAMES-OK T)

(DEFN MODULE-ANNOTATION-OK
      (M-ANNO M-LENGTH)
      (IF (EQUAL M-LENGTH 6)
          (LABEL-ERROR (T-OR-ERR (ALISTP M-ANNO)
                                 'NOT-ALIST
                                 M-ANNO)
                       'MODULE-ANNOTATION)
          T))

(TOGGLE MODULE-ANNOTATION-OK-OFF MODULE-ANNOTATION-OK T)

(DEFN MODULE-SYNTAX-ERRORS
      (MODULE NETLIST)
      (LIST (MODULE-FORM-OK MODULE
                            (LENGTH MODULE))
            (MODULE-NAME-OK (MODULE-NAME MODULE)
                            (LENGTH MODULE)
                            NETLIST)
            (MODULE-INPUTS-OK (MODULE-INPUTS MODULE)
                              (LENGTH MODULE))
            (MODULE-OUTPUTS-OK (MODULE-OUTPUTS MODULE)
                               (LENGTH MODULE))
            (MODULE-OCCURRENCES-OK (MODULE-OCCURRENCES MODULE)
                                   (MODULE-INPUTS MODULE)
                                   (MODULE-OUTPUTS MODULE)
                                   (MODULE-STATENAMES MODULE)
                                   (LENGTH MODULE)
                                   NETLIST)
            (MODULE-STATENAMES-OK (MODULE-STATENAMES MODULE)
                                  (LENGTH MODULE))
            (MODULE-ANNOTATION-OK (MODULE-ANNOTATION MODULE)
                                  (LENGTH MODULE))))

(TOGGLE MODULE-SYNTAX-ERRORS-OFF MODULE-SYNTAX-ERRORS T)

(DEFN MODULE-SYNTAX-OK
      (MODULE NETLIST)
      (ERR-AND (MODULE-SYNTAX-ERRORS MODULE NETLIST)
               (LIST 'MODULE (MODULE-NAME MODULE))))

(TOGGLE MODULE-SYNTAX-OK-OFF MODULE-SYNTAX-OK T)

(DEFN NETLIST-SYNTAX-ERRORS
      (NETLIST)
      (IF (LISTP NETLIST)
          (CONS (MODULE-SYNTAX-OK (CAR NETLIST)
                                  (CDR NETLIST))
                (NETLIST-SYNTAX-ERRORS (CDR NETLIST)))
          (LIST (NIL-OR-ERR NETLIST 'NOT-PROPER-LIST))))

(TOGGLE NETLIST-SYNTAX-ERRORS-OFF NETLIST-SYNTAX-ERRORS T)

(DEFN NETLIST-SYNTAX-OK
      (NETLIST)
      (ERR-AND (NETLIST-SYNTAX-ERRORS NETLIST)
               'NETLIST-SYNTAX-ERRORS))

(TOGGLE NETLIST-SYNTAX-OK-OFF NETLIST-SYNTAX-OK T)

(DEFN LETTERP
      (CHAR)
      (MEMBER CHAR
              (UNPACK 'ABCDEFGHIJKLMNOPQRSTUVWXYZ)))

(TOGGLE LETTERP-OFF LETTERP T)

(DEFN DIGITP
      (CHAR)
      (MEMBER CHAR
              (CDR (UNPACK 'A0123456789))))

(TOGGLE DIGITP-OFF DIGITP T)

(DEFN BAD-LSI-NAME-CHARS
      (CHAR-LIST SPECIAL-CHARACTERS)
      (IF (LISTP CHAR-LIST)
          (IF (OR (LETTERP (CAR CHAR-LIST))
                  (DIGITP (CAR CHAR-LIST))
                  (MEMBER (CAR CHAR-LIST)
                          SPECIAL-CHARACTERS))
              (BAD-LSI-NAME-CHARS (CDR CHAR-LIST)
                                  SPECIAL-CHARACTERS)
              (INSERT (CAR CHAR-LIST)
                      (BAD-LSI-NAME-CHARS (CDR CHAR-LIST)
                                          SPECIAL-CHARACTERS)))
          NIL))

(TOGGLE BAD-LSI-NAME-CHARS-OFF BAD-LSI-NAME-CHARS T)

(DEFN LSI-KEYWORDS NIL
      '(ACTION ANGLE ANNOTATIONS BLOAT BLOCK BUS CELL CELSTAT CHKSUM CLK_LINE
               DIRECTION DUMMY END FLIP FUNCTION HM_BIDI HM_INPUT HM_OUTPUT
               LIBRARY NAME NC NET PIN POWERCELLS PRIORITY PSECURED REGION
               SCALE TECHNOLOGY TSECURED VIA WIRE))

(TOGGLE LSI-KEYWORDS-OFF LSI-KEYWORDS T)

(TOGGLE G*1*LSI-KEYWORDS-OFF *1*LSI-KEYWORDS T)

(DEFN LSI-NAME-OK
 (NAME TOKEN-SIZE)
 (COND ((MEMBER NAME (LSI-KEYWORDS))
        (PRED-ERROR 'LSI-NAME-IS-KEYWORD
                    NAME))
       ((LITATOM NAME)
        (ERR-AND (LIST (T-OR-ERR (IF (LESSP TOKEN-SIZE
                                            (LENGTH (UNPACK NAME)))
                                     F T)
                                 'NAME-TOO-LONG
                                 (LIST (LIST 'NAME-LENGTH
                                             (LENGTH (UNPACK NAME)))
                                       (LIST 'MAX-ALLOWED-LENGTH
                                             TOKEN-SIZE)))
                       (T-OR-ERR (LETTERP (CAR (UNPACK NAME)))
                                 'NAME-BEGINS-WITH-NONLETTER
                                 (CAR (UNPACK NAME)))
                       (NLISTP-OR-ERR (BAD-LSI-NAME-CHARS (CDR (UNPACK NAME))
                                                          (CDR (UNPACK 'A-_)))
                                      'ILLEGAL-CHARS-IN-NAME)
                       (T-OR-ERR (EQUAL (LAST-CDR (UNPACK NAME)) 0)
                                 'NOT-STANDARD-LITATOM
                                 (LIST 'LAST-CDR
                                       (LAST-CDR (UNPACK NAME)))))
                 (LIST 'BAD-LSI-NAME NAME)))
       (T (PRED-ERROR 'LSI-NAME-NOT-LITATOM
                      NAME))))

(TOGGLE LSI-NAME-OK-OFF LSI-NAME-OK T)

(DEFN LSI-BAD-NAMES
      (NAME-LIST TOKEN-SIZE)
      (IF (LISTP NAME-LIST)
          (CONS (LSI-NAME-OK (CAR NAME-LIST)
                             TOKEN-SIZE)
                (LSI-BAD-NAMES (CDR NAME-LIST)
                               TOKEN-SIZE))
          NIL))

(TOGGLE LSI-BAD-NAMES-OFF LSI-BAD-NAMES T)

(DEFN LSI-NAME-LIST-ERRORS
      (NAME-LIST TOKEN-SIZE DUPLICATES-OK?)
      (LIST (ERR-AND (LSI-BAD-NAMES NAME-LIST TOKEN-SIZE)
                     'BAD-LSI-NAMES)
            (IF DUPLICATES-OK? T
                (NO-DUPLICATES-OR-ERR NAME-LIST 'DUPLICATES))
            (NIL-OR-ERR (LAST-CDR NAME-LIST)
                        'NOT-PROPER-LIST)))

(TOGGLE LSI-NAME-LIST-ERRORS-OFF LSI-NAME-LIST-ERRORS T)

(DEFN LSI-NAME-LIST-OK
      (NAME-LIST TOKEN-SIZE LABEL DUPLICATES-OK?)
      (ERR-AND (LSI-NAME-LIST-ERRORS NAME-LIST TOKEN-SIZE DUPLICATES-OK?)
               LABEL))

(TOGGLE LSI-NAME-LIST-OK-OFF LSI-NAME-LIST-OK T)

(DEFN LSI-FUNCTION-NAME
      (FNAME)
      (IF (AND (PRIMP FNAME)
               (PRIMP-LOOKUP FNAME 'LSI-NAME))
          (IF (LISTP (PRIMP2 FNAME 'LSI-NAME))
              (CAR (PRIMP2 FNAME 'LSI-NAME))
              (PRIMP2 FNAME 'LSI-NAME))
          FNAME))

(TOGGLE LSI-FUNCTION-NAME-OFF LSI-FUNCTION-NAME T)

(DEFN NAME-LENGTH
      (NAME)
      (LENGTH (UNPACK NAME)))

(TOGGLE NAME-LENGTH-OFF NAME-LENGTH T)

(DEFN HIERARCHICAL-NAME-MAX
      (N1 N2)
      (COND ((AND (NLISTP N1) (NLISTP N2)) 0)
            ((NLISTP N1) N2)
            ((NLISTP N2) N1)
            ((LESSP (CAR N1) (CAR N2)) N2)
            (T N1)))

(TOGGLE HIERARCHICAL-NAME-MAX-OFF HIERARCHICAL-NAME-MAX T)

(DEFN MAX-HIERARCHICAL-LENGTH-AND-NAME
     (NAMES)
     (IF (LISTP NAMES)
         (HIERARCHICAL-NAME-MAX (LIST (ADD1 (NAME-LENGTH (CAR NAMES)))
                                      (CAR NAMES))
                                (MAX-HIERARCHICAL-LENGTH-AND-NAME (CDR NAMES)))
         0))

(TOGGLE MAX-HIERARCHICAL-LENGTH-AND-NAME-OFF MAX-HIERARCHICAL-LENGTH-AND-NAME T)

(DEFN MAX-OCC-HIERARCHICAL-NAME
 (OCC HIERARCHICAL-TABLE HIERARCHICAL-SIZE)
 (IF
  (LISTP (IF (PRIMP (OCC-FUNCTION OCC))
             (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                       (OCC-OUTPUTS OCC)))
             (VALUE (OCC-FUNCTION OCC)
                    HIERARCHICAL-TABLE)))
  (IF
   (IF
    (LESSP HIERARCHICAL-SIZE
     (PLUS
         (ADD1 (NAME-LENGTH (OCC-NAME OCC)))
         (CAR (IF (PRIMP (OCC-FUNCTION OCC))
                  (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                            (OCC-OUTPUTS OCC)))
                  (VALUE (OCC-FUNCTION OCC)
                         HIERARCHICAL-TABLE)))))
    F T)
   (CONS
    (PLUS
         (ADD1 (NAME-LENGTH (OCC-NAME OCC)))
         (CAR (IF (PRIMP (OCC-FUNCTION OCC))
                  (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                            (OCC-OUTPUTS OCC)))
                  (VALUE (OCC-FUNCTION OCC)
                         HIERARCHICAL-TABLE))))
    (CONS
         (OCC-NAME OCC)
         (CDR (IF (PRIMP (OCC-FUNCTION OCC))
                  (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                            (OCC-OUTPUTS OCC)))
                  (VALUE (OCC-FUNCTION OCC)
                         HIERARCHICAL-TABLE)))))
   (PRED-ERROR 'HIERARCHICAL-NAME-TOO-LONG
    (LIST
     (LIST 'NAME-LENGTH
      (PLUS
         (ADD1 (NAME-LENGTH (OCC-NAME OCC)))
         (CAR (IF (PRIMP (OCC-FUNCTION OCC))
                  (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                            (OCC-OUTPUTS OCC)))
                  (VALUE (OCC-FUNCTION OCC)
                         HIERARCHICAL-TABLE)))))
     (LIST 'MAX-ALLOWED-LENGTH
           HIERARCHICAL-SIZE)
     (LIST 'NAME
      (CONS
         (OCC-NAME OCC)
         (CDR (IF (PRIMP (OCC-FUNCTION OCC))
                  (MAX-HIERARCHICAL-LENGTH-AND-NAME (APPEND (OCC-INPUTS OCC)
                                                            (OCC-OUTPUTS OCC)))
                  (VALUE (OCC-FUNCTION OCC)
                         HIERARCHICAL-TABLE))))))))
  0))

(TOGGLE MAX-OCC-HIERARCHICAL-NAME-OFF MAX-OCC-HIERARCHICAL-NAME T)

(DEFN LSI-OCC-NAME-OK
      (O-NAME O-LENGTH O-OUTS OCC-DATA TOKEN-SIZE)
      (IF (IF (LESSP O-LENGTH 1) F T)
          (ERR-AND (LIST (LSI-NAME-OK O-NAME TOKEN-SIZE)
                         (T-OR-ERR (NOT (MEMBER O-NAME
                                                (VALUE 'SIGNALS OCC-DATA)))
                                   'OCC-NAME-IS-SIGNAL
                                   O-NAME)
                         (T-OR-ERR (OR (EQUAL (CDR O-OUTS) NIL)
                                       (NOT (MEMBER O-NAME O-OUTS)))
                                   'OCC-NAME-IS-SAME-AS-OUTPUT-NAME
                                   O-NAME))
                   'OCCURRENCE-NAME)
          T))

(TOGGLE LSI-OCC-NAME-OK-OFF LSI-OCC-NAME-OK T)

(DEFN LSI-OCC-OUTPUTS-OK
      (O-OUTS O-LENGTH OCC-DATA TOKEN-SIZE)
      (IF (IF (LESSP O-LENGTH 2) F T)
          (ERR-AND (LIST (LSI-NAME-LIST-OK O-OUTS TOKEN-SIZE
                                           'OCC-OUTPUTS
                                           F)
                         (DISJOINT-OR-ERR O-OUTS
                                          (VALUE 'OCC-NAMES OCC-DATA)
                                          'OCC-OUTPUTS-IN-OCC-NAMES))
                   'OCCURRENCE-OUTPUTS)
          T))

(TOGGLE LSI-OCC-OUTPUTS-OK-OFF LSI-OCC-OUTPUTS-OK T)

(DEFN LSI-OCC-INPUTS-OK
      (O-INS O-LENGTH TOKEN-SIZE)
      (IF (IF (LESSP O-LENGTH 4) F T)
          (LSI-NAME-LIST-OK O-INS TOKEN-SIZE 'OCCURRENCE-INPUTS
                            T)
          T))

(TOGGLE LSI-OCC-INPUTS-OK-OFF LSI-OCC-INPUTS-OK T)

(DEFN LSI-OCC-SYNTAX-OK
      (OCC HIERARCHICAL-NAME-ERROR OCC-DATA NETLIST TOKEN-SIZE)
      (ERR-AND (LIST (OCC-FORM-OK OCC (LENGTH OCC))
                     (LSI-OCC-NAME-OK (OCC-NAME OCC)
                                      (LENGTH OCC)
                                      (OCC-OUTPUTS OCC)
                                      OCC-DATA TOKEN-SIZE)
                     (LSI-OCC-OUTPUTS-OK (OCC-OUTPUTS OCC)
                                         (LENGTH OCC)
                                         OCC-DATA TOKEN-SIZE)
                     (LSI-OCC-INPUTS-OK (OCC-INPUTS OCC)
                                        (LENGTH OCC)
                                        TOKEN-SIZE)
                     (OCC-FUNCTION-OK (OCC-FUNCTION OCC)
                                      (OCC-INPUTS OCC)
                                      (OCC-OUTPUTS OCC)
                                      (LENGTH OCC)
                                      NETLIST)
                     (OCC-ANNOTATION-OK (OCC-ANNOTATION OCC)
                                        (LENGTH OCC))
                     HIERARCHICAL-NAME-ERROR)
               (LIST 'OCCURRENCE (OCC-NAME OCC))))

(TOGGLE LSI-OCC-SYNTAX-OK-OFF LSI-OCC-SYNTAX-OK T)

(DEFN INITIAL-LSI-OCC-SYNTAX-DATA
      (M-INS M-OUTS)
      (CONS '(OCC-FNS)
            (CONS '(HIERARCHICAL-NAME . 0)
                  (INITIAL-OCC-SYNTAX-DATA M-INS M-OUTS))))

(TOGGLE INITIAL-LSI-OCC-SYNTAX-DATA-OFF INITIAL-LSI-OCC-SYNTAX-DATA T)

(DEFN UPDATE-LSI-OCC-SYNTAX-DATA
  (OCC O-HNAME OCC-DATA)
  (CONS (CONS 'OCC-FNS
              (CONS (LSI-FUNCTION-NAME (OCC-FUNCTION OCC))
                    (VALUE 'OCC-FNS OCC-DATA)))
        (CONS (CONS 'HIERARCHICAL-NAME
                    (HIERARCHICAL-NAME-MAX (VALUE 'HIERARCHICAL-NAME OCC-DATA)
                                           O-HNAME))
              (UPDATE-OCC-SYNTAX-DATA OCC OCC-DATA))))

(TOGGLE UPDATE-LSI-OCC-SYNTAX-DATA-OFF UPDATE-LSI-OCC-SYNTAX-DATA T)

(DEFN LSI-OCC-BODY-SYNTAX-CHECK
 (BODY OCC-DATA OUTPUTS STATES NETLIST TOKEN-SIZE HIERARCHICAL-TABLE
       HIERARCHICAL-SIZE)
 (IF
  (NLISTP BODY)
  (APPEND (COMPOSITE-OCC-BODY-SYNTAX-ERRORS BODY OCC-DATA OUTPUTS STATES)
          (LIST (ALIST-ENTRY 'HIERARCHICAL-NAME
                             OCC-DATA)
                (DISJOINT-OR-ERR (VALUE 'SIGNALS OCC-DATA)
                                 (VALUE 'OCC-FNS OCC-DATA)
                                 'SIGNAL-OCC-FN-OVERLAP)
                (DISJOINT-OR-ERR (VALUE 'OCC-NAMES OCC-DATA)
                                 (VALUE 'OCC-FNS OCC-DATA)
                                 'OCC-NAME-OCC-FN-OVERLAP)))
  (CONS
   (LSI-OCC-SYNTAX-OK (CAR BODY)
                      (MAX-OCC-HIERARCHICAL-NAME (CAR BODY)
                                                 HIERARCHICAL-TABLE
                                                 HIERARCHICAL-SIZE)
                      OCC-DATA NETLIST TOKEN-SIZE)
   (LSI-OCC-BODY-SYNTAX-CHECK
      (CDR BODY)
      (UPDATE-LSI-OCC-SYNTAX-DATA (CAR BODY)
                                  (MAX-OCC-HIERARCHICAL-NAME (CAR BODY)
                                                             HIERARCHICAL-TABLE
                                                             HIERARCHICAL-SIZE)
                                  OCC-DATA)
      OUTPUTS STATES NETLIST TOKEN-SIZE HIERARCHICAL-TABLE HIERARCHICAL-SIZE))))

(TOGGLE LSI-OCC-BODY-SYNTAX-CHECK-OFF LSI-OCC-BODY-SYNTAX-CHECK T)

(DEFN LSI-MODULE-NAME-OK
      (M-NAME M-LENGTH TOKEN-SIZE NETLIST)
      (IF (IF (LESSP M-LENGTH 1) F T)
          (ERR-AND (LIST (LSI-NAME-OK M-NAME TOKEN-SIZE)
                         (T-OR-ERR (NOT (LOOKUP-MODULE M-NAME NETLIST))
                                   'DUPLICATE-MODULE-DEFNS
                                   M-NAME)
                         (T-OR-ERR (NOT (PRIMP M-NAME))
                                   'MODULE-NAME-SAME-AS-PRIMITIVE
                                   M-NAME))
                   'MODULE-NAME)
          T))

(TOGGLE LSI-MODULE-NAME-OK-OFF LSI-MODULE-NAME-OK T)

(DEFN LSI-MODULE-INPUTS-OK
      (M-INS M-LENGTH TOKEN-SIZE)
      (IF (IF (LESSP M-LENGTH 2) F T)
          (LSI-NAME-LIST-OK M-INS TOKEN-SIZE 'MODULE-INPUTS
                            F)
          T))

(TOGGLE LSI-MODULE-INPUTS-OK-OFF LSI-MODULE-INPUTS-OK T)

(DEFN LSI-MODULE-OUTPUTS-OK
      (M-OUTS M-LENGTH TOKEN-SIZE)
      (IF (IF (LESSP M-LENGTH 3) F T)
          (LSI-NAME-LIST-OK M-OUTS TOKEN-SIZE 'MODULE-OUTPUTS
                            F)
          T))

(TOGGLE LSI-MODULE-OUTPUTS-OK-OFF LSI-MODULE-OUTPUTS-OK T)

(DEFN LSI-MODULE-OCCURRENCES-CHECK
    (M-OCCS M-INS M-OUTS M-STATES M-LENGTH NETLIST TOKEN-SIZE
            HIERARCHICAL-TABLE HIERARCHICAL-SIZE)
    (IF (IF (LESSP M-LENGTH 4) F T)
        (CONS (T-OR-ERR (LISTP M-OCCS)
                        'NO-OCCURRENCES
                        M-OCCS)
              (LSI-OCC-BODY-SYNTAX-CHECK M-OCCS
                                         (INITIAL-LSI-OCC-SYNTAX-DATA M-INS
                                                                      M-OUTS)
                                         M-OUTS
                                         (STATES-LIST-OR-NIL M-STATES M-LENGTH)
                                         NETLIST TOKEN-SIZE
                                         HIERARCHICAL-TABLE HIERARCHICAL-SIZE))
        T))

(TOGGLE LSI-MODULE-OCCURRENCES-CHECK-OFF LSI-MODULE-OCCURRENCES-CHECK T)

(DEFN LSI-MODULE-SYNTAX-CHECK
 (MODULE NETLIST TOKEN-SIZE HIERARCHICAL-TABLE HIERARCHICAL-SIZE)
 (LIST
  (CONS (MODULE-NAME MODULE)
        (VALUE 'HIERARCHICAL-NAME
               (LSI-MODULE-OCCURRENCES-CHECK (MODULE-OCCURRENCES MODULE)
                                             (MODULE-INPUTS MODULE)
                                             (MODULE-OUTPUTS MODULE)
                                             (MODULE-STATENAMES MODULE)
                                             (LENGTH MODULE)
                                             NETLIST TOKEN-SIZE
                                             HIERARCHICAL-TABLE
                                             HIERARCHICAL-SIZE)))
  (ERR-AND
       (LIST (MODULE-FORM-OK MODULE
                             (LENGTH MODULE))
             (LSI-MODULE-NAME-OK (MODULE-NAME MODULE)
                                 (LENGTH MODULE)
                                 TOKEN-SIZE NETLIST)
             (LSI-MODULE-INPUTS-OK (MODULE-INPUTS MODULE)
                                   (LENGTH MODULE)
                                   TOKEN-SIZE)
             (LSI-MODULE-OUTPUTS-OK (MODULE-OUTPUTS MODULE)
                                    (LENGTH MODULE)
                                    TOKEN-SIZE)
             (ERR-AND (LSI-MODULE-OCCURRENCES-CHECK (MODULE-OCCURRENCES MODULE)
                                                    (MODULE-INPUTS MODULE)
                                                    (MODULE-OUTPUTS MODULE)
                                                    (MODULE-STATENAMES MODULE)
                                                    (LENGTH MODULE)
                                                    NETLIST TOKEN-SIZE
                                                    HIERARCHICAL-TABLE
                                                    HIERARCHICAL-SIZE)
                      'MODULE-OCCURRENCES)
             (MODULE-STATENAMES-OK (MODULE-STATENAMES MODULE)
                                   (LENGTH MODULE))
             (MODULE-ANNOTATION-OK (MODULE-ANNOTATION MODULE)
                                   (LENGTH MODULE)))
       (LIST 'MODULE
             (MODULE-NAME MODULE)))))

(TOGGLE LSI-MODULE-SYNTAX-CHECK-OFF LSI-MODULE-SYNTAX-CHECK T)

(DEFN LSI-NETLIST-SYNTAX-CHECK
 (NETLIST TOKEN-SIZE HIERARCHICAL-SIZE)
 (IF
  (LISTP NETLIST)
  (APPEND (LSI-MODULE-SYNTAX-CHECK (CAR NETLIST)
                                   (CDR NETLIST)
                                   TOKEN-SIZE
                                   (LSI-NETLIST-SYNTAX-CHECK (CDR NETLIST)
                                                             TOKEN-SIZE
                                                             HIERARCHICAL-SIZE)
                                   HIERARCHICAL-SIZE)
          (LSI-NETLIST-SYNTAX-CHECK (CDR NETLIST)
                                    TOKEN-SIZE HIERARCHICAL-SIZE))
  (LIST (NIL-OR-ERR NETLIST 'NOT-PROPER-LIST))))

(TOGGLE LSI-NETLIST-SYNTAX-CHECK-OFF LSI-NETLIST-SYNTAX-CHECK T)

(DEFN LSI-NETLIST-SYNTAX-OK
      (NETLIST TOKEN-SIZE HIERARCHICAL-SIZE)
      (ERR-AND (LSI-NETLIST-SYNTAX-CHECK NETLIST TOKEN-SIZE HIERARCHICAL-SIZE)
               'LSI-NETLIST-SYNTAX-ERRORS))

(TOGGLE LSI-NETLIST-SYNTAX-OK-OFF LSI-NETLIST-SYNTAX-OK T)

(DEFN PRIMITIVE-PROPERTIES NIL
      '(DELAYS DRIVES INPUT-TYPES INPUTS LOADINGS LSI-NAME NEW-STATES
               OUT-DEPENDS OUTPUT-TYPES OUTPUTS RESULTS STATE-TYPES STATES
               GATES PADS PRIMITIVES TRANSISTORS))

(TOGGLE PRIMITIVE-PROPERTIES-OFF PRIMITIVE-PROPERTIES T)

(TOGGLE G*1*PRIMITIVE-PROPERTIES-OFF *1*PRIMITIVE-PROPERTIES T)

(DEFN ALL-MODULE-PROPS NIL
      '(DELAYS DRIVES INPUT-TYPES INPUTS LOADINGS OUT-DEPENDS OUTPUT-TYPES
               OUTPUTS STATE-TYPES STATES GATES PADS PRIMITIVES TRANSISTORS))

(TOGGLE ALL-MODULE-PROPS-OFF ALL-MODULE-PROPS T)

(TOGGLE G*1*ALL-MODULE-PROPS-OFF *1*ALL-MODULE-PROPS T)

(ADD-SHELL UNKNOWN NIL UNKNOWNP NIL)

(DEFN VALUE-OR-UNKNOWN
      (KEY ALIST)
      (IF (BOUNDP KEY ALIST)
          (VALUE KEY ALIST)
          (UNKNOWN)))

(TOGGLE VALUE-OR-UNKNOWN-OFF VALUE-OR-UNKNOWN T)

(DEFN COLLECT-VALUE-OR-UNKNOWN
      (KEYS ALIST)
      (IF (LISTP KEYS)
          (CONS (VALUE-OR-UNKNOWN (CAR KEYS) ALIST)
                (COLLECT-VALUE-OR-UNKNOWN (CDR KEYS)
                                          ALIST))
          NIL))

(TOGGLE COLLECT-VALUE-OR-UNKNOWN-OFF COLLECT-VALUE-OR-UNKNOWN T)

(ADD-SHELL IO-OUT NIL IO-OUTP
           ((IO-OUT-SIGNAL (NONE-OF) FALSE)))

(DEFN MARK-IO-OUT
      (NAME IO-OUTS)
      (IF (MEMBER NAME IO-OUTS)
          (IO-OUT NAME)
          NAME))

(TOGGLE MARK-IO-OUT-OFF MARK-IO-OUT T)

(DEFN MARK-IO-OUTS-0
      (NAMES IO-OUTS)
      (IF (LISTP NAMES)
          (CONS (MARK-IO-OUT (CAR NAMES) IO-OUTS)
                (MARK-IO-OUTS-0 (CDR NAMES) IO-OUTS))
          NIL))

(TOGGLE MARK-IO-OUTS-0-OFF MARK-IO-OUTS-0 T)

(DEFN MARK-IO-OUTS
      (NAMES IO-OUTS)
      (IF (DISJOINT IO-OUTS NAMES)
          NAMES
          (MARK-IO-OUTS-0 NAMES IO-OUTS)))

(TOGGLE MARK-IO-OUTS-OFF MARK-IO-OUTS T)

(DEFN UNMARK-IO-OUT
      (NAME)
      (IF (IO-OUTP NAME)
          (IO-OUT-SIGNAL NAME)
          NAME))

(TOGGLE UNMARK-IO-OUT-OFF UNMARK-IO-OUT T)

(DEFN UNMARK-IO-OUTS
      (NAMES)
      (IF (LISTP NAMES)
          (IF (AND (EQUAL (UNMARK-IO-OUT (CAR NAMES))
                          (CAR NAMES))
                   (EQUAL (UNMARK-IO-OUTS (CDR NAMES))
                          (CDR NAMES)))
              NAMES
              (CONS (UNMARK-IO-OUT (CAR NAMES))
                    (UNMARK-IO-OUTS (CDR NAMES))))
          NAMES))

(TOGGLE UNMARK-IO-OUTS-OFF UNMARK-IO-OUTS T)

(DEFN VALUE2
      (S IN-MAP OUT-MAP)
      (IF (BOUNDP S IN-MAP)
          (VALUE S IN-MAP)
          (VALUE (UNMARK-IO-OUT S) OUT-MAP)))

(TOGGLE VALUE2-OFF VALUE2 T)

(DEFN COLLECT-VALUE2
      (LST IN-MAP OUT-MAP)
      (IF (LISTP LST)
          (CONS (VALUE2 (CAR LST) IN-MAP OUT-MAP)
                (COLLECT-VALUE2 (CDR LST)
                                IN-MAP OUT-MAP))
          NIL))

(TOGGLE COLLECT-VALUE2-OFF COLLECT-VALUE2 T)

(DEFN SIGNAL-NAMEP
      (X)
      (OR (LITATOM X)
          (INDEXP X)
          (IO-OUTP X)))

(TOGGLE SIGNAL-NAMEP-OFF SIGNAL-NAMEP T)

(DEFN PARENT-SYNONYM0
      (NAME SLIST USED-NAMES)
      (COND ((MEMBER NAME USED-NAMES) NAME)
            ((BOUNDP NAME SLIST)
             (IF (SIGNAL-NAMEP (VALUE NAME SLIST))
                 (PARENT-SYNONYM0 (VALUE NAME SLIST)
                                  SLIST
                                  (CONS NAME USED-NAMES))
                 NAME))
            (T NAME))
      ((LESSP (COUNT (UNBIND-LIST USED-NAMES SLIST)))))

(TOGGLE PARENT-SYNONYM0-OFF PARENT-SYNONYM0 T)

(DEFN PARENT-SYNONYM
      (NAME SLIST)
      (PARENT-SYNONYM0 NAME SLIST NIL))

(TOGGLE PARENT-SYNONYM-OFF PARENT-SYNONYM T)

(DEFN PARENT-SYNONYMS-LIST
      (LST SLIST)
      (IF (LISTP LST)
          (CONS (PARENT-SYNONYM (CAR LST) SLIST)
                (PARENT-SYNONYMS-LIST (CDR LST)
                                      SLIST))
          LST))

(TOGGLE PARENT-SYNONYMS-LIST-OFF PARENT-SYNONYMS-LIST T)

(DEFN EXTRACT-NAMES
      (LST)
      (COND ((NLISTP LST) NIL)
            ((SIGNAL-NAMEP (CAR LST))
             (INSERT (CAR LST)
                     (EXTRACT-NAMES (CDR LST))))
            (T (EXTRACT-NAMES (CDR LST)))))

(TOGGLE EXTRACT-NAMES-OFF EXTRACT-NAMES T)

(DEFN EXTERNALIZE-PARENTS
 (NAMES ALIST INPUTS OUTPUTS)
 (IF
  (LISTP NAMES)
  (EXTERNALIZE-PARENTS
     (CDR NAMES)
     (IF (OR (MEMBER (PARENT-SYNONYM (CAR NAMES) ALIST)
                     INPUTS)
             (MEMBER (PARENT-SYNONYM (CAR NAMES) ALIST)
                     OUTPUTS))
         ALIST
         (CONS (CONS (PARENT-SYNONYM (CAR NAMES) ALIST)
                     (CAR NAMES))
               (CONS (CONS (CAR NAMES)
                           (VALUE-OR-UNKNOWN (PARENT-SYNONYM (CAR NAMES) ALIST)
                                             ALIST))
                     (UNBIND (CAR NAMES)
                             (UNBIND (PARENT-SYNONYM (CAR NAMES) ALIST)
                                     ALIST)))))
     INPUTS OUTPUTS)
  ALIST))

(TOGGLE EXTERNALIZE-PARENTS-OFF EXTERNALIZE-PARENTS T)

(DEFN SUBTYPE
      (X Y)
      (COND ((EQUAL Y 'FREE) T)
            ((EQUAL X 'BOOLP)
             (MEMBER Y
                     '(BOOLP TRI-STATE TTL-TRI-STATE TTL)))
            ((EQUAL X 'TTL-TRI-STATE)
             (MEMBER Y '(TRI-STATE TTL-TRI-STATE)))
            (T (EQUAL X Y))))

(TOGGLE SUBTYPE-OFF SUBTYPE T)

(DEFN TYPES-COMPATIBLEP
      (T1 T2)
      (COND ((EQUAL T1 T2) T)
            ((OR (EQUAL T1 'FREE)
                 (EQUAL T2 'FREE))
             T)
            ((EQUAL T1 'TRI-STATE)
             (EQUAL T2 'TTL-TRI-STATE))
            ((EQUAL T2 'TRI-STATE)
             (EQUAL T1 'TTL-TRI-STATE))
            (T F)))

(TOGGLE TYPES-COMPATIBLEP-OFF TYPES-COMPATIBLEP T)

(DEFN TRI-STATE-TYPEP
      (TYPE)
      (MEMBER TYPE
              '(TRI-STATE TTL-TRI-STATE)))

(TOGGLE TRI-STATE-TYPEP-OFF TRI-STATE-TYPEP T)

(DEFN TYPE-VALUE0
      (N ALIST FREE USED-NAMES)
      (COND ((OR (MEMBER N USED-NAMES)
                 (NOT (BOUNDP N ALIST)))
             (IF FREE 'FREE (LIST N)))
            ((LISTP (VALUE N ALIST))
             (TYPE-VALUE0 (CAR (VALUE N ALIST))
                          ALIST FREE
                          (CONS N USED-NAMES)))
            (T (VALUE N ALIST)))
      ((LESSP (COUNT (UNBIND-LIST USED-NAMES ALIST)))))

(TOGGLE TYPE-VALUE0-OFF TYPE-VALUE0 T)

(DEFN TYPE-VALUE
      (N ALIST FREE)
      (TYPE-VALUE0 N ALIST FREE NIL))

(TOGGLE TYPE-VALUE-OFF TYPE-VALUE T)

(DEFN INPUT-TYPE
      (NAME ALIST)
      (TYPE-VALUE (UNMARK-IO-OUT NAME)
                  ALIST T))

(TOGGLE INPUT-TYPE-OFF INPUT-TYPE T)

(DEFN OUTPUT-TYPE
      (NAME OUT-MAP IN-MAP)
      (IF (LISTP (TYPE-VALUE NAME OUT-MAP F))
          (TYPE-VALUE (CAR (TYPE-VALUE NAME OUT-MAP F))
                      IN-MAP F)
          (TYPE-VALUE NAME OUT-MAP F)))

(TOGGLE OUTPUT-TYPE-OFF OUTPUT-TYPE T)

(DEFN INITIAL-OCC-IN-TYPES NIL NIL)

(DEFN INITIAL-OCC-OUT-TYPES NIL NIL)

(DEFN ADD-IN-TYPE
 (NAME TYPE TYPE-MAP)
 (COND
  ((EQUAL TYPE 'FREE) TYPE-MAP)
  ((BOUNDP (UNMARK-IO-OUT NAME) TYPE-MAP)
   (COND
        ((OR (UNKNOWNP (VALUE (UNMARK-IO-OUT NAME) TYPE-MAP))
             (SUBTYPE (VALUE (UNMARK-IO-OUT NAME) TYPE-MAP)
                      TYPE))
         TYPE-MAP)
        ((OR (UNKNOWNP TYPE)
             (SUBTYPE TYPE
                      (VALUE (UNMARK-IO-OUT NAME)
                             TYPE-MAP)))
         (CONS (CONS (UNMARK-IO-OUT NAME) TYPE)
               (UNBIND (UNMARK-IO-OUT NAME)
                       TYPE-MAP)))
        (T (CONS (PRED-ERROR (LIST 'SIGNAL (UNMARK-IO-OUT NAME))
                             (LIST (LIST 'OLD-TYPE
                                         (VALUE (UNMARK-IO-OUT NAME) TYPE-MAP))
                                   (LIST 'NEW-TYPE TYPE)))
                 (CONS (CONS (UNMARK-IO-OUT NAME) (UNKNOWN))
                       (UNBIND (UNMARK-IO-OUT NAME)
                               TYPE-MAP))))))
  (T (CONS (CONS (UNMARK-IO-OUT NAME) TYPE)
           TYPE-MAP))))

(TOGGLE ADD-IN-TYPE-OFF ADD-IN-TYPE T)

(DEFN ADD-IN-TYPES
      (INPUTS TYPES TYPE-MAP)
      (IF (LISTP INPUTS)
          (ADD-IN-TYPES (CDR INPUTS)
                        (CDR TYPES)
                        (ADD-IN-TYPE (CAR INPUTS)
                                     (CAR TYPES)
                                     TYPE-MAP))
          TYPE-MAP))

(TOGGLE ADD-IN-TYPES-OFF ADD-IN-TYPES T)

(DEFN UPDATE-IN-TYPES
      (IN-TYPES O-INS O-FN-PROPS)
      (ADD-IN-TYPES O-INS
                    (VALUE 'INPUT-TYPES O-FN-PROPS)
                    IN-TYPES))

(TOGGLE UPDATE-IN-TYPES-OFF UPDATE-IN-TYPES T)

(DEFN ADD-OUT-TYPE
      (NAME TYPE ARG-MAP TYPE-MAP)
      (CONS (CONS NAME
                  (IF (LISTP TYPE)
                      (COLLECT-VALUE TYPE ARG-MAP)
                      TYPE))
            TYPE-MAP))

(TOGGLE ADD-OUT-TYPE-OFF ADD-OUT-TYPE T)

(DEFN ADD-OUT-TYPES
      (OUTPUTS TYPES ARG-MAP TYPE-MAP)
      (IF (LISTP OUTPUTS)
          (ADD-OUT-TYPES (CDR OUTPUTS)
                         (CDR TYPES)
                         ARG-MAP
                         (ADD-OUT-TYPE (CAR OUTPUTS)
                                       (CAR TYPES)
                                       ARG-MAP TYPE-MAP))
          TYPE-MAP))

(TOGGLE ADD-OUT-TYPES-OFF ADD-OUT-TYPES T)

(DEFN UPDATE-OUT-TYPES
      (OUT-TYPES O-OUTS O-FN-PROPS IN-MAP)
      (ADD-OUT-TYPES O-OUTS
                     (VALUE 'OUTPUT-TYPES O-FN-PROPS)
                     IN-MAP OUT-TYPES))

(TOGGLE UPDATE-OUT-TYPES-OFF UPDATE-OUT-TYPES T)

(DEFN IO-TYPE-ERROR
      (NAME IN-TYPE OUT-TYPE)
      (PRED-ERROR (LIST (IF (IO-OUTP NAME)
                            'IO-SIGNAL
                            'SIGNAL)
                        (UNMARK-IO-OUT NAME))
                  (LIST (LIST 'INPUT-TYPE IN-TYPE)
                        (LIST 'OUTPUT-TYPE OUT-TYPE))))

(TOGGLE IO-TYPE-ERROR-OFF IO-TYPE-ERROR T)

(DEFN IO-TYPES-COMPATIBLE
      (NAME IN-TYPE OUT-TYPE T-WIRE-INS)
      (COND ((UNKNOWNP IN-TYPE)
             (UNKNOWNP OUT-TYPE))
            ((UNKNOWNP OUT-TYPE)
             (UNKNOWNP IN-TYPE))
            ((IO-OUTP NAME)
             (IF (AND (TRI-STATE-TYPEP OUT-TYPE)
                      (SUBTYPE OUT-TYPE IN-TYPE))
                 T
                 (IO-TYPE-ERROR NAME IN-TYPE OUT-TYPE)))
            ((MEMBER NAME T-WIRE-INS)
             (IF (AND (TRI-STATE-TYPEP IN-TYPE)
                      (TYPES-COMPATIBLEP IN-TYPE OUT-TYPE))
                 T
                 (IO-TYPE-ERROR NAME IN-TYPE OUT-TYPE)))
            ((SUBTYPE OUT-TYPE IN-TYPE) T)
            (T (IO-TYPE-ERROR NAME IN-TYPE OUT-TYPE))))

(TOGGLE IO-TYPES-COMPATIBLE-OFF IO-TYPES-COMPATIBLE T)

(DEFN OK-IN-TYPE
      (OK NAME OUT-TYPE IN-MAP)
      (COND ((OR (NOT OK) (NET-ERRORP OK))
             (SET-VALUE (UNMARK-IO-OUT NAME)
                        (UNKNOWN)
                        IN-MAP))
            ((IO-OUTP NAME)
             (SET-VALUE (UNMARK-IO-OUT NAME)
                        OUT-TYPE IN-MAP))
            (T IN-MAP)))

(TOGGLE OK-IN-TYPE-OFF OK-IN-TYPE T)

(DEFN OK-OUT-TYPE
      (OK NAME OUT-MAP)
      (COND ((NET-ERRORP OK)
             (CONS OK
                   (SET-VALUE NAME (UNKNOWN) OUT-MAP)))
            (OK OUT-MAP)
            (T (SET-VALUE NAME (UNKNOWN) OUT-MAP))))

(TOGGLE OK-OUT-TYPE-OFF OK-OUT-TYPE T)

(DEFN TRANSFER-IN-TYPE
      (NAME OUT-TYPE IN-MAP)
      (IF (LISTP OUT-TYPE)
          (ADD-IN-TYPE (CAR OUT-TYPE)
                       (INPUT-TYPE NAME IN-MAP)
                       IN-MAP)
          IN-MAP))

(TOGGLE TRANSFER-IN-TYPE-OFF TRANSFER-IN-TYPE T)

(DEFN COMPOSE-TYPE
 (NAME TYPE MAPS T-WIRE-INS)
 (CONS
   (OK-IN-TYPE (IO-TYPES-COMPATIBLE NAME
                                    (INPUT-TYPE NAME (CAR MAPS))
                                    (COND ((LISTP (IF (LISTP TYPE)
                                                      (OUTPUT-TYPE (CAR TYPE)
                                                                   (CDR MAPS)
                                                                   (CAR MAPS))
                                                      TYPE))
                                           'FREE)
                                          ((LISTP TYPE)
                                           (OUTPUT-TYPE (CAR TYPE)
                                                        (CDR MAPS)
                                                        (CAR MAPS)))
                                          (T TYPE))
                                    T-WIRE-INS)
               NAME
               (IF (LISTP TYPE)
                   (OUTPUT-TYPE (CAR TYPE)
                                (CDR MAPS)
                                (CAR MAPS))
                   TYPE)
               (CAR MAPS))
   (OK-OUT-TYPE (IO-TYPES-COMPATIBLE NAME
                                     (INPUT-TYPE NAME (CAR MAPS))
                                     (COND ((LISTP (IF (LISTP TYPE)
                                                       (OUTPUT-TYPE (CAR TYPE)
                                                                    (CDR MAPS)
                                                                    (CAR MAPS))
                                                       TYPE))
                                            'FREE)
                                           ((LISTP TYPE)
                                            (OUTPUT-TYPE (CAR TYPE)
                                                         (CDR MAPS)
                                                         (CAR MAPS)))
                                           (T TYPE))
                                     T-WIRE-INS)
                NAME
                (CDR MAPS))))

(TOGGLE COMPOSE-TYPE-OFF COMPOSE-TYPE T)

(DEFN COMPOSED-TYPE-MAPS
      (OUT-TYPES IN-MAP OUT-MAP T-WIRE-INS)
      (IF (LISTP OUT-TYPES)
          (COMPOSE-TYPE (CAAR OUT-TYPES)
                        (CDAR OUT-TYPES)
                        (COMPOSED-TYPE-MAPS (CDR OUT-TYPES)
                                            (TRANSFER-IN-TYPE (CAAR OUT-TYPES)
                                                              (CDAR OUT-TYPES)
                                                              IN-MAP)
                                            OUT-MAP T-WIRE-INS)
                        T-WIRE-INS)
          (CONS IN-MAP OUT-MAP)))

(TOGGLE COMPOSED-TYPE-MAPS-OFF COMPOSED-TYPE-MAPS T)

(DEFN COMPOSE-IO-TYPES
      (IN-MAP OUT-MAP T-WIRE-INS)
      (COMPOSED-TYPE-MAPS OUT-MAP IN-MAP OUT-MAP T-WIRE-INS))

(TOGGLE COMPOSE-IO-TYPES-OFF COMPOSE-IO-TYPES T)

(DEFN COLLECT-IN-TYPES
      (NAMES ALIST)
      (IF (LISTP NAMES)
          (CONS (TYPE-VALUE (CAR NAMES) ALIST T)
                (COLLECT-IN-TYPES (CDR NAMES) ALIST))
          NIL))

(TOGGLE COLLECT-IN-TYPES-OFF COLLECT-IN-TYPES T)

(DEFN COLLECT-OUT-TYPE
      (NAME OUT-MAP INPUTS IN-MAP)
      (IF (AND (LISTP (OUTPUT-TYPE NAME OUT-MAP IN-MAP))
               (NOT (MEMBER (CAR (OUTPUT-TYPE NAME OUT-MAP IN-MAP))
                            INPUTS)))
          (UNKNOWN)
          (OUTPUT-TYPE NAME OUT-MAP IN-MAP)))

(TOGGLE COLLECT-OUT-TYPE-OFF COLLECT-OUT-TYPE T)

(DEFN COLLECT-OUT-TYPES
      (OUTPUTS OUT-MAP INPUTS IN-MAP)
      (IF (LISTP OUTPUTS)
          (CONS (COLLECT-OUT-TYPE (CAR OUTPUTS)
                                  OUT-MAP INPUTS IN-MAP)
                (COLLECT-OUT-TYPES (CDR OUTPUTS)
                                   OUT-MAP INPUTS IN-MAP))
          NIL))

(TOGGLE COLLECT-OUT-TYPES-OFF COLLECT-OUT-TYPES T)

(DEFN IN-TYPES-ERROR
      (IN-MAP)
      (ERR-AND IN-MAP 'INPUT-TYPE-CONFLICTS))

(TOGGLE IN-TYPES-ERROR-OFF IN-TYPES-ERROR T)

(DEFN OUT-TYPES-ERROR
      (OUT-MAP)
      (ERR-AND OUT-MAP 'IO-TYPE-CONFLICTS))

(TOGGLE OUT-TYPES-ERROR-OFF OUT-TYPES-ERROR T)

(DEFN MAP
      (DR)
      (CASE (LENGTH DR)
            (2 (AND (NUMBERP (CAR DR))
                    (EQUAL (CADR DR) 'MA)
                    (EQUAL (CDDR DR) NIL)))
            (3 (AND (NUMBERP (CAR DR))
                    (AND (EQUAL (LENGTH (CADR DR)) 2)
                         (EQUAL (CAADR DR) 'POINT)
                         (NUMBERP (CADADR DR)))
                    (EQUAL (CADDR DR) 'MA)
                    (EQUAL (CDDDR DR) NIL)))
            (OTHERWISE F)))

(TOGGLE MAP-OFF MAP T)

(DEFN PFP
      (LD)
      (IF (EQUAL (LENGTH LD) 2)
          (AND (NUMBERP (CAR LD))
               (EQUAL (CADR LD) 'PF)
               (EQUAL (CDDR LD) NIL))
          F))

(TOGGLE PFP-OFF PFP T)

(DEFN MA-TO-PF
      (X)
      (CONS (PLUS (TIMES (CAR X) 10) (CADADR X))
            '(PF)))

(TOGGLE MA-TO-PF-OFF MA-TO-PF T)

(DEFN PF-TO-MA
      (X)
      (IF (ZEROP (REMAINDER (CAR X) 10))
          (CONS (QUOTIENT (CAR X) 10) '(MA))
          (CONS (QUOTIENT (CAR X) 10)
                (CONS (LIST 'POINT (REMAINDER (CAR X) 10))
                      '(MA)))))

(TOGGLE PF-TO-MA-OFF PF-TO-MA T)

(DEFN STD-LOAD-TO-PF
      (X)
      (CONS (TIMES X 10) '(PF)))

(TOGGLE STD-LOAD-TO-PF-OFF STD-LOAD-TO-PF T)

(DEFN PF-TO-STD-LOAD
      (X)
      (IF (LESSP (REMAINDER (CAR X) 10) 5)
          (QUOTIENT (CAR X) 10)
          (PLUS (QUOTIENT (CAR X) 10) 1)))

(TOGGLE PF-TO-STD-LOAD-OFF PF-TO-STD-LOAD T)

(DEFN MA-TO-STD-DRIVE (X) (CAR X))

(TOGGLE MA-TO-STD-DRIVE-OFF MA-TO-STD-DRIVE T)

(DEFN STD-DRIVE-TO-MA
      (X)
      (CONS X '(MA)))

(TOGGLE STD-DRIVE-TO-MA-OFF STD-DRIVE-TO-MA T)

(DEFN ZERO-LOADINGP
      (A)
      (IF (PFP A)
          (ZEROP (CAR A))
          (ZEROP A)))

(TOGGLE ZERO-LOADINGP-OFF ZERO-LOADINGP T)

(DEFN PF-PLUS
      (A B)
      (CONS (PLUS (CAR A) (CAR B)) '(PF)))

(TOGGLE PF-PLUS-OFF PF-PLUS T)

(DEFN PF-DIFFERENCE
      (A B)
      (CONS (DIFFERENCE (CAR A) (CAR B))
            '(PF)))

(TOGGLE PF-DIFFERENCE-OFF PF-DIFFERENCE T)

(DEFN PF-LESSP
      (A B)
      (LESSP (CAR A) (CAR B)))

(TOGGLE PF-LESSP-OFF PF-LESSP T)

(DEFN MA-LESSP
      (A B)
      (COND ((LESSP (CAR A) (CAR B)) T)
            ((EQUAL (CAR A) (CAR B))
             (LESSP (CADADR A) (CADADR B)))
            (T F)))

(TOGGLE MA-LESSP-OFF MA-LESSP T)

(DEFN LOADING-PLUS
      (X Y)
      (COND ((NUMBERP X)
             (COND ((NUMBERP Y) (PLUS X Y))
                   ((PFP Y)
                    (PF-PLUS (STD-LOAD-TO-PF X) Y))
                   (T X)))
            ((PFP X)
             (COND ((PFP Y) (PF-PLUS X Y))
                   ((NUMBERP Y)
                    (PF-PLUS X (STD-LOAD-TO-PF Y)))
                   (T X)))
            ((OR (NUMBERP Y) (PFP Y)) Y)
            (T 0)))

(TOGGLE LOADING-PLUS-OFF LOADING-PLUS T)

(DEFN INITIAL-OCC-LOADINGS NIL NIL)

(DEFN INITIAL-OCC-DRIVES NIL NIL)

(DEFN ADD-LOADING
      (NAME LOADING LOAD-MAP)
      (COND ((ZERO-LOADINGP LOADING) LOAD-MAP)
            ((BOUNDP NAME LOAD-MAP)
             (CONS (CONS NAME
                         (LOADING-PLUS LOADING
                                       (VALUE NAME LOAD-MAP)))
                   (UNBIND NAME LOAD-MAP)))
            (T (CONS (CONS NAME LOADING) LOAD-MAP))))

(TOGGLE ADD-LOADING-OFF ADD-LOADING T)

(DEFN ADD-LOADINGS
      (NAMES LOADINGS LOAD-MAP)
      (IF (LISTP NAMES)
          (ADD-LOADINGS (CDR NAMES)
                        (CDR LOADINGS)
                        (ADD-LOADING (CAR NAMES)
                                     (CAR LOADINGS)
                                     LOAD-MAP))
          LOAD-MAP))

(TOGGLE ADD-LOADINGS-OFF ADD-LOADINGS T)

(DEFN UPDATE-LOADINGS
      (LOADINGS O-INS O-FN-PROPS)
      (ADD-LOADINGS O-INS
                    (VALUE 'LOADINGS O-FN-PROPS)
                    LOADINGS))

(TOGGLE UPDATE-LOADINGS-OFF UPDATE-LOADINGS T)

(DEFN LOCAL-DRIVE
      (DRIVE LISTP IN-MAP OUT-MAP DRIVE-MAP)
      (COND (LISTP (IF (LISTP DRIVE)
                       (CONS (LOCAL-DRIVE (CAR DRIVE)
                                          F IN-MAP OUT-MAP DRIVE-MAP)
                             (LOCAL-DRIVE (CDR DRIVE)
                                          T IN-MAP OUT-MAP DRIVE-MAP))
                       NIL))
            ((SIGNAL-NAMEP DRIVE)
             (PARENT-SYNONYM (VALUE2 DRIVE IN-MAP OUT-MAP)
                             DRIVE-MAP))
            ((AND (LISTP DRIVE)
                  (EQUAL (CAR DRIVE) 'MIN))
             (CONS 'MIN
                   (LOCAL-DRIVE (CDR DRIVE)
                                T IN-MAP OUT-MAP DRIVE-MAP)))
            (T DRIVE)))

(TOGGLE LOCAL-DRIVE-OFF LOCAL-DRIVE T)

(DEFN ADD-DRIVES
      (OUTPUTS DRIVES IN-MAP OUT-MAP DRIVE-MAP)
      (IF (LISTP OUTPUTS)
          (ADD-DRIVES (CDR OUTPUTS)
                      (CDR DRIVES)
                      IN-MAP OUT-MAP
                      (CONS (CONS (CAR OUTPUTS)
                                  (LOCAL-DRIVE (CAR DRIVES)
                                               F IN-MAP OUT-MAP DRIVE-MAP))
                            DRIVE-MAP))
          DRIVE-MAP))

(TOGGLE ADD-DRIVES-OFF ADD-DRIVES T)

(DEFN UPDATE-DRIVES
      (DRIVES O-OUTS O-FN-PROPS IN-MAP OUT-MAP)
      (ADD-DRIVES O-OUTS
                  (VALUE 'DRIVES O-FN-PROPS)
                  IN-MAP OUT-MAP DRIVES))

(TOGGLE UPDATE-DRIVES-OFF UPDATE-DRIVES T)

(DEFN TRANSFER-LOADING
      (DRIVE LISTP LOAD LOADINGS)
      (COND (LISTP (IF (LISTP DRIVE)
                       (TRANSFER-LOADING (CDR DRIVE)
                                         T LOAD
                                         (TRANSFER-LOADING (CAR DRIVE)
                                                           F LOAD LOADINGS))
                       LOADINGS))
            ((SIGNAL-NAMEP DRIVE)
             (ADD-LOADING DRIVE LOAD LOADINGS))
            ((AND (LISTP DRIVE)
                  (EQUAL (CAR DRIVE) 'MIN))
             (TRANSFER-LOADING (CDR DRIVE)
                               T LOAD LOADINGS))
            (T LOADINGS)))

(TOGGLE TRANSFER-LOADING-OFF TRANSFER-LOADING T)

(DEFN TRANSFER-LOADINGS
      (LOADINGS DRIVES)
      (IF (LISTP DRIVES)
          (TRANSFER-LOADINGS (TRANSFER-LOADING (CDAR DRIVES)
                                               F
                                               (VALUE (CAAR DRIVES) LOADINGS)
                                               LOADINGS)
                             (CDR DRIVES))
          LOADINGS))

(TOGGLE TRANSFER-LOADINGS-OFF TRANSFER-LOADINGS T)

(DEFN LITERAL-NET-DRIVE
 (DRIVE LOAD LABEL)
 (COND
  ((NUMBERP DRIVE)
   (IF
    (LESSP DRIVE
           (COND ((NUMBERP LOAD) LOAD)
                 ((PFP LOAD) (PF-TO-STD-LOAD LOAD))
                 (T 0)))
    (PRED-ERROR LABEL
          (LIST (LIST 'DRIVE DRIVE)
                (CONS 'LOADING
                      (CONS LOAD
                            (IF (EQUAL LOAD
                                       (COND ((NUMBERP LOAD) LOAD)
                                             ((PFP LOAD) (PF-TO-STD-LOAD LOAD))
                                             (T 0)))
                                NIL
                                (LIST (COND ((NUMBERP LOAD) LOAD)
                                            ((PFP LOAD) (PF-TO-STD-LOAD LOAD))
                                            (T 0))))))))
    (DIFFERENCE DRIVE
                (COND ((NUMBERP LOAD) LOAD)
                      ((PFP LOAD) (PF-TO-STD-LOAD LOAD))
                      (T 0)))))
  ((MAP DRIVE)
   (IF
    (PF-LESSP (MA-TO-PF DRIVE)
              (COND ((PFP LOAD) LOAD)
                    ((NUMBERP LOAD) (STD-LOAD-TO-PF LOAD))
                    (T '(0 PF))))
    (PRED-ERROR LABEL
      (LIST (LIST 'DRIVE DRIVE (MA-TO-PF DRIVE))
            (CONS 'LOADING
                  (CONS LOAD
                        (IF (EQUAL LOAD
                                   (COND ((PFP LOAD) LOAD)
                                         ((NUMBERP LOAD) (STD-LOAD-TO-PF LOAD))
                                         (T '(0 PF))))
                            NIL
                            (LIST (COND ((PFP LOAD) LOAD)
                                        ((NUMBERP LOAD) (STD-LOAD-TO-PF LOAD))
                                        (T '(0 PF)))))))))
    (PF-TO-MA (PF-DIFFERENCE (MA-TO-PF DRIVE)
                             (COND ((PFP LOAD) LOAD)
                                   ((NUMBERP LOAD) (STD-LOAD-TO-PF LOAD))
                                   (T '(0 PF)))))))
  (T (UNKNOWN))))

(TOGGLE LITERAL-NET-DRIVE-OFF LITERAL-NET-DRIVE T)

(DEFN NET-MIN-ARGS
      (A LOAD LISTP)
      (COND (LISTP (IF (LISTP A)
                       (UNION (NET-MIN-ARGS (CAR A) LOAD F)
                              (NET-MIN-ARGS (CDR A) LOAD T))
                       NIL))
            ((OR (NUMBERP A) (MAP A))
             (LIST (LITERAL-NET-DRIVE A LOAD 'MIN-ARG)))
            ((AND (LISTP A) (EQUAL (CAR A) 'MIN))
             (NET-MIN-ARGS (CDR A) LOAD T))
            (T (LIST A))))

(TOGGLE NET-MIN-ARGS-OFF NET-MIN-ARGS T)

(DEFN ADD-NET-MIN-DRIVE
 (NAME ARGS LOAD DRIVE-MAP)
 (IF
  (NET-ERRORP (ERR-AND (NET-MIN-ARGS ARGS LOAD T)
                       (LIST 'SIGNAL NAME)))
  (IF
    (LISTP (EXTRACT-NAMES (NET-MIN-ARGS ARGS LOAD T)))
    (CONS (ERR-AND (NET-MIN-ARGS ARGS LOAD T)
                   (LIST 'SIGNAL NAME))
          (CONS (CONS NAME
                      (CONS 'MIN
                            (CONS (UNKNOWN)
                                  (EXTRACT-NAMES (NET-MIN-ARGS ARGS LOAD T)))))
                DRIVE-MAP))
    (CONS (ERR-AND (NET-MIN-ARGS ARGS LOAD T)
                   (LIST 'SIGNAL NAME))
          DRIVE-MAP))
  (CONS (CONS NAME
              (CONS 'MIN
                    (NET-MIN-ARGS ARGS LOAD T)))
        DRIVE-MAP)))

(TOGGLE ADD-NET-MIN-DRIVE-OFF ADD-NET-MIN-DRIVE T)

(DEFN ADD-NET-DRIVE
 (DRIVE LOADINGS DRIVE-MAP)
 (IF
  (LISTP DRIVE)
  (COND ((OR (NUMBERP (CDR DRIVE))
             (MAP (CDR DRIVE)))
         (CONS (IF (NET-ERRORP (LITERAL-NET-DRIVE (CDR DRIVE)
                                                  (VALUE (CAR DRIVE) LOADINGS)
                                                  (LIST 'SIGNAL (CAR DRIVE))))
                   (LITERAL-NET-DRIVE (CDR DRIVE)
                                      (VALUE (CAR DRIVE) LOADINGS)
                                      (LIST 'SIGNAL (CAR DRIVE)))
                   (CONS (CAR DRIVE)
                         (LITERAL-NET-DRIVE (CDR DRIVE)
                                            (VALUE (CAR DRIVE) LOADINGS)
                                            (LIST 'SIGNAL (CAR DRIVE)))))
               DRIVE-MAP))
        ((EQUAL (CADR DRIVE) 'MIN)
         (ADD-NET-MIN-DRIVE (CAR DRIVE)
                            (CDDR DRIVE)
                            (VALUE (CAR DRIVE) LOADINGS)
                            DRIVE-MAP))
        (T (CONS DRIVE DRIVE-MAP)))
  (CONS DRIVE DRIVE-MAP)))

(TOGGLE ADD-NET-DRIVE-OFF ADD-NET-DRIVE T)

(DEFN NET-DRIVES-SIMPLE
      (DRS LDS)
      (IF (LISTP DRS)
          (ADD-NET-DRIVE (CAR DRS)
                         LDS
                         (NET-DRIVES-SIMPLE (CDR DRS) LDS))
          NIL))

(TOGGLE NET-DRIVES-SIMPLE-OFF NET-DRIVES-SIMPLE T)

(DEFN TYPE-LOADING
      (LOAD TYPE)
      (COND ((MEMBER TYPE
                     '(BOOLP CLK LEVEL PARAMETRIC TRI-STATE))
             (IF (PFP LOAD)
                 (PF-TO-STD-LOAD LOAD)
                 LOAD))
            ((MEMBER TYPE '(TTL TTL-TRI-STATE))
             (IF (NUMBERP LOAD)
                 (STD-LOAD-TO-PF LOAD)
                 LOAD))
            (T LOAD)))

(TOGGLE TYPE-LOADING-OFF TYPE-LOADING T)

(DEFN COLLECT-LOADINGS
      (NAMES TYPES LOADINGS)
      (IF (LISTP NAMES)
          (CONS (TYPE-LOADING (VALUE (CAR NAMES) LOADINGS)
                              (CAR TYPES))
                (COLLECT-LOADINGS (CDR NAMES)
                                  (CDR TYPES)
                                  LOADINGS))
          NIL))

(TOGGLE COLLECT-LOADINGS-OFF COLLECT-LOADINGS T)

(DEFN LOADINGS-ERROR
      (LOADINGS)
      (ERR-AND LOADINGS 'BAD-LOADINGS))

(TOGGLE LOADINGS-ERROR-OFF LOADINGS-ERROR T)

(DEFN COLLECT-MIN-ARGS
      (A LISTP DRIVES USED-NAMES INPUTS OUTPUTS)
      (COND (LISTP (IF (LISTP A)
                       (UNION (COLLECT-MIN-ARGS (CAR A)
                                                F DRIVES USED-NAMES INPUTS
                                                OUTPUTS)
                              (COLLECT-MIN-ARGS (CDR A)
                                                T DRIVES USED-NAMES INPUTS
                                                OUTPUTS))
                       NIL))
            ((SIGNAL-NAMEP A)
             (COND ((MEMBER A INPUTS) (LIST A))
                   ((AND (NOT (OR (MEMBER A OUTPUTS)
                                  (MEMBER A USED-NAMES)))
                         (BOUNDP A DRIVES))
                    (COLLECT-MIN-ARGS (VALUE A DRIVES)
                                      F DRIVES
                                      (CONS A USED-NAMES)
                                      INPUTS OUTPUTS))
                   (T (LIST (UNKNOWN)))))
            ((AND (LISTP A) (EQUAL (CAR A) 'MIN))
             (COLLECT-MIN-ARGS (CDR A)
                               T DRIVES USED-NAMES INPUTS OUTPUTS))
            ((OR (NUMBERP A) (MAP A)) (LIST A))
            (T (LIST (UNKNOWN))))
      ((ORD-LESSP (CONS (ADD1 (COUNT (UNBIND-LIST USED-NAMES DRIVES)))
                        (COUNT A)))))

(TOGGLE COLLECT-MIN-ARGS-OFF COLLECT-MIN-ARGS T)

(DEFN NUMERIC-DRIVES
      (DRS)
      (IF (LISTP DRS)
          (IF (OR (NUMBERP (CAR DRS))
                  (MAP (CAR DRS)))
              (CONS (CAR DRS)
                    (NUMERIC-DRIVES (CDR DRS)))
              (NUMERIC-DRIVES (CDR DRS)))
          NIL))

(TOGGLE NUMERIC-DRIVES-OFF NUMERIC-DRIVES T)

(DEFN TYPE-DRIVE
      (DRIVE TYPE)
      (COND ((MEMBER TYPE
                     '(BOOLP CLK LEVEL PARAMETRIC TRI-STATE))
             (IF (MAP DRIVE)
                 (MA-TO-STD-DRIVE DRIVE)
                 DRIVE))
            ((MEMBER TYPE '(TTL TTL-TRI-STATE))
             (IF (NUMBERP DRIVE)
                 (STD-DRIVE-TO-MA DRIVE)
                 DRIVE))
            (T DRIVE)))

(TOGGLE TYPE-DRIVE-OFF TYPE-DRIVE T)

(DEFN DRIVE-LESSP
      (X Y)
      (COND ((AND (NUMBERP X) (NUMBERP Y))
             (LESSP X Y))
            ((AND (MAP X) (MAP Y)) (MA-LESSP X Y))
            (T F)))

(TOGGLE DRIVE-LESSP-OFF DRIVE-LESSP T)

(DEFN DRIVE-MIN
      (LST TYPE)
      (COND ((NLISTP LST) (UNKNOWN))
            ((NLISTP (CDR LST))
             (TYPE-DRIVE (CAR LST) TYPE))
            ((DRIVE-LESSP (TYPE-DRIVE (CAR LST) TYPE)
                          (DRIVE-MIN (CDR LST) TYPE))
             (TYPE-DRIVE (CAR LST) TYPE))
            (T (DRIVE-MIN (CDR LST) TYPE))))

(TOGGLE DRIVE-MIN-OFF DRIVE-MIN T)

(DEFN MAKE-DRIVE-MIN
    (ARGS TYPE DRIVES INPUTS OUTPUTS)
    (COND ((NLISTP (EXTRACT-NAMES (COLLECT-MIN-ARGS ARGS T DRIVES NIL INPUTS
                                                    OUTPUTS)))
           (DRIVE-MIN (NUMERIC-DRIVES (COLLECT-MIN-ARGS ARGS T DRIVES NIL
                                                        INPUTS OUTPUTS))
                      TYPE))
          ((NLISTP (NUMERIC-DRIVES (COLLECT-MIN-ARGS ARGS T DRIVES NIL
                                                     INPUTS OUTPUTS)))
           (IF (LISTP (CDR (EXTRACT-NAMES (COLLECT-MIN-ARGS ARGS T DRIVES
                                                            NIL INPUTS
                                                            OUTPUTS))))
               (CONS 'MIN
                     (EXTRACT-NAMES (COLLECT-MIN-ARGS ARGS T DRIVES NIL
                                                      INPUTS OUTPUTS)))
               (CONS 'MIN
                     (CONS (UNKNOWN)
                           (EXTRACT-NAMES (COLLECT-MIN-ARGS ARGS T DRIVES
                                                            NIL INPUTS
                                                            OUTPUTS))))))
          (T (CONS 'MIN
                   (CONS (DRIVE-MIN (NUMERIC-DRIVES (COLLECT-MIN-ARGS ARGS T
                                                                      DRIVES
                                                                      NIL
                                                                      INPUTS
                                                                      OUTPUTS))
                                    TYPE)
                         (EXTRACT-NAMES (COLLECT-MIN-ARGS ARGS T DRIVES
                                                          NIL INPUTS
                                                          OUTPUTS)))))))

(TOGGLE MAKE-DRIVE-MIN-OFF MAKE-DRIVE-MIN T)

(DEFN COLLECT-DRIVES-0
   (NAMES OUTPUT-TYPES DRIVES INPUTS OUTPUTS)
   (IF (LISTP NAMES)
       (CONS (COND ((OR (NUMBERP (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES))
                        (MAP (VALUE-OR-UNKNOWN (CAR NAMES)
                                               DRIVES)))
                    (TYPE-DRIVE (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES)
                                (CAR OUTPUT-TYPES)))
                   ((SIGNAL-NAMEP (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES))
                    (PARENT-SYNONYM (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES)
                                    DRIVES))
                   ((AND (LISTP (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES))
                         (EQUAL (CAR (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES))
                                'MIN))
                    (MAKE-DRIVE-MIN (CDR (VALUE-OR-UNKNOWN (CAR NAMES) DRIVES))
                                    (CAR OUTPUT-TYPES)
                                    DRIVES INPUTS OUTPUTS))
                   (T (UNKNOWN)))
             (COLLECT-DRIVES-0 (CDR NAMES)
                               (CDR OUTPUT-TYPES)
                               DRIVES INPUTS OUTPUTS))
       NIL))

(TOGGLE COLLECT-DRIVES-0-OFF COLLECT-DRIVES-0 T)

(DEFN COLLECT-DRIVES
      (OUTPUTS OUTPUT-TYPES DRIVES INPUTS)
      (COLLECT-DRIVES-0 OUTPUTS OUTPUT-TYPES
                        (EXTERNALIZE-PARENTS OUTPUTS DRIVES INPUTS OUTPUTS)
                        INPUTS OUTPUTS))

(TOGGLE COLLECT-DRIVES-OFF COLLECT-DRIVES T)

(DEFN DRIVES-ERROR
      (DRIVES)
      (ERR-AND DRIVES 'BAD-DRIVES))

(TOGGLE DRIVES-ERROR-OFF DRIVES-ERROR T)

(DEFN PS-PFP
      (X)
      (AND (PROPERP X)
           (EQUAL (LENGTH X) 2)
           (NUMBERP (CAR X))
           (EQUAL (CADR X) 'PS-PF)))

(TOGGLE PS-PFP-OFF PS-PFP T)

(DEFN DELAY-LH
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CAR D)
          F))

(TOGGLE DELAY-LH-OFF DELAY-LH T)

(DEFN DELAY-HL
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CADR D)
          F))

(TOGGLE DELAY-HL-OFF DELAY-HL T)

(DEFN DELAY-SLOPE-LH
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CAAR D)
          F))

(TOGGLE DELAY-SLOPE-LH-OFF DELAY-SLOPE-LH T)

(DEFN DELAY-SLOPE-HL
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CAADR D)
          F))

(TOGGLE DELAY-SLOPE-HL-OFF DELAY-SLOPE-HL T)

(DEFN DELAY-INTERCEPT-LH
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CADAR D)
          F))

(TOGGLE DELAY-INTERCEPT-LH-OFF DELAY-INTERCEPT-LH T)

(DEFN DELAY-INTERCEPT-HL
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CADADR D)
          F))

(TOGGLE DELAY-INTERCEPT-HL-OFF DELAY-INTERCEPT-HL T)

(DEFN DELAY-DEPENDENCIES
      (D)
      (IF (AND (LISTP D)
               (NOT (EQUAL (CAR D) 'OR)))
          (CDDR D)
          NIL))

(TOGGLE DELAY-DEPENDENCIES-OFF DELAY-DEPENDENCIES T)

(DEFN MAKE-DELAY-0
      (LH HL DEPS)
      (CONS LH (CONS HL DEPS)))

(TOGGLE MAKE-DELAY-0-OFF MAKE-DELAY-0 T)

(DEFN MAKE-DELAY
      (S-LH I-LH S-HL I-HL DEPS)
      (MAKE-DELAY-0 (LIST S-LH I-LH)
                    (LIST S-HL I-HL)
                    DEPS))

(TOGGLE MAKE-DELAY-OFF MAKE-DELAY T)

(DEFN DETERMINED-DELAYP
      (D)
      (AND (LISTP D)
           (NOT (EQUAL (CAR D) 'OR))
           (NLISTP (DELAY-DEPENDENCIES D))))

(TOGGLE DETERMINED-DELAYP-OFF DETERMINED-DELAYP T)

(DEFN MAKE-RANGE
      (LO HI DEPS)
      (IF (AND (EQUAL LO HI) (NLISTP DEPS))
          LO
          (CONS 'RANGE
                (CONS LO (CONS HI DEPS)))))

(TOGGLE MAKE-RANGE-OFF MAKE-RANGE T)

(DEFN RANGEP
      (X)
      (IF (LISTP X)
          (EQUAL (CAR X) 'RANGE)
          F))

(TOGGLE RANGEP-OFF RANGEP T)

(DEFN RANGE-MIN
      (X)
      (IF (RANGEP X) (CADR X) X))

(TOGGLE RANGE-MIN-OFF RANGE-MIN T)

(DEFN RANGE-MAX
      (X)
      (IF (RANGEP X) (CADDR X) X))

(TOGGLE RANGE-MAX-OFF RANGE-MAX T)

(DEFN RANGE-DEPENDENCIES
      (X)
      (IF (RANGEP X) (CDDDR X) NIL))

(TOGGLE RANGE-DEPENDENCIES-OFF RANGE-DEPENDENCIES T)

(DEFN DETERMINED-RANGEP
      (X)
      (IF (RANGEP X)
          (NLISTP (RANGE-DEPENDENCIES X))
          (NUMBERP X)))

(TOGGLE DETERMINED-RANGEP-OFF DETERMINED-RANGEP T)

(DEFN PER-STD-LOAD-DELAY-SLOPE
      (SLOPE)
      (IF (PS-PFP SLOPE)
          (TIMES (CAR SLOPE) 10)
          SLOPE))

(TOGGLE PER-STD-LOAD-DELAY-SLOPE-OFF PER-STD-LOAD-DELAY-SLOPE T)

(DEFN PER-PF-DELAY-SLOPE
      (SLOPE)
      (IF (NUMBERP SLOPE)
          (CONS (IF (LESSP (REMAINDER SLOPE 10) 5)
                    (QUOTIENT SLOPE 10)
                    (ADD1 (QUOTIENT SLOPE 10)))
                '(PS-PF))
          SLOPE))

(TOGGLE PER-PF-DELAY-SLOPE-OFF PER-PF-DELAY-SLOPE T)

(DEFN RANGE-PLUS
      (I1 I2 DEPS)
      (MAKE-RANGE (PLUS (RANGE-MIN I1) (RANGE-MIN I2))
                  (PLUS (RANGE-MAX I1) (RANGE-MAX I2))
                  DEPS))

(TOGGLE RANGE-PLUS-OFF RANGE-PLUS T)

(DEFN SLOPE-TIMES-LOAD
      (SLOPE LOAD)
      (COND ((NUMBERP SLOPE)
             (COND ((NUMBERP LOAD) (TIMES SLOPE LOAD))
                   ((PFP LOAD)
                    (TIMES SLOPE (PF-TO-STD-LOAD LOAD)))
                   (T 0)))
            ((PS-PFP SLOPE)
             (COND ((PFP LOAD)
                    (TIMES (CAR SLOPE) (CAR LOAD)))
                   ((NUMBERP LOAD)
                    (TIMES (CAR SLOPE)
                           (CAR (STD-LOAD-TO-PF LOAD))))
                   (T 0)))
            (T 0)))

(TOGGLE SLOPE-TIMES-LOAD-OFF SLOPE-TIMES-LOAD T)

(DEFN INITIAL-OCC-DELAYS NIL NIL)

(PROVE-LEMMA LOCAL-DELAY-COUNT-HELP-0
             (REWRITE)
             (IMPLIES (LISTP X)
                      (EQUAL (COUNT X)
                             (ADD1 (PLUS (COUNT (CAR X))
                                         (COUNT (CDR X)))))))

(PROVE-LEMMA LOCAL-DELAY-COUNT-HELP
             (REWRITE)
             (IMPLIES (LISTP X)
                      (EQUAL (EQUAL (COUNT X) 0) F)))

(TOGGLE LOCAL-DELAY-COUNT-HELP-0-OFF LOCAL-DELAY-COUNT-HELP-0 T)

(TOGGLE RANGE-DEPENDENCIES-ON RANGE-DEPENDENCIES NIL)

(TOGGLE DELAY-DEPENDENCIES-ON DELAY-DEPENDENCIES NIL)

(DEFN LOCAL-DELAY
      (DELAY OUT-DEPENDS LISTP IN-MAP OUT-MAP DELAY-MAP)
      (COND (LISTP (IF (LISTP DELAY)
                       (CONS (LOCAL-DELAY (CAR DELAY)
                                          OUT-DEPENDS F IN-MAP OUT-MAP
                                          DELAY-MAP)
                             (LOCAL-DELAY (CDR DELAY)
                                          OUT-DEPENDS T IN-MAP OUT-MAP
                                          DELAY-MAP))
                       NIL))
            ((SIGNAL-NAMEP DELAY)
             (PARENT-SYNONYM (VALUE2 DELAY IN-MAP OUT-MAP)
                             DELAY-MAP))
            ((NLISTP DELAY) DELAY)
            ((EQUAL (CAR DELAY) 'OR)
             (CONS 'OR
                   (LOCAL-DELAY (CDR DELAY)
                                F T IN-MAP OUT-MAP DELAY-MAP)))
            ((RANGEP DELAY)
             (IF (LISTP (RANGE-DEPENDENCIES DELAY))
                 (MAKE-RANGE (RANGE-MIN DELAY)
                             (RANGE-MAX DELAY)
                             (LOCAL-DELAY (RANGE-DEPENDENCIES DELAY)
                                          F T IN-MAP OUT-MAP DELAY-MAP))
                 DELAY))
            ((LISTP (IF (LISTP (DELAY-DEPENDENCIES DELAY))
                        (DELAY-DEPENDENCIES DELAY)
                        OUT-DEPENDS))
             (MAKE-DELAY-0 (DELAY-LH DELAY)
                           (DELAY-HL DELAY)
                           (LOCAL-DELAY (IF (LISTP (DELAY-DEPENDENCIES DELAY))
                                            (DELAY-DEPENDENCIES DELAY)
                                            OUT-DEPENDS)
                                        F T IN-MAP OUT-MAP DELAY-MAP)))
            (T DELAY))
      ((ORD-LESSP (CONS (ADD1 (COUNT OUT-DEPENDS))
                        (COUNT DELAY)))))

(TOGGLE LOCAL-DELAY-COUNT-HELP-OFF LOCAL-DELAY-COUNT-HELP T)

(TOGGLE RANGE-DEPENDENCIES-OFF1 RANGE-DEPENDENCIES T)

(TOGGLE DELAY-DEPENDENCIES-OFF1 DELAY-DEPENDENCIES T)

(TOGGLE LOCAL-DELAY-OFF LOCAL-DELAY T)

(DEFN ADD-DELAYS
      (OUTPUTS DELAYS OUT-DEPENDS IN-MAP OUT-MAP DELAY-MAP)
      (IF (LISTP OUTPUTS)
          (ADD-DELAYS (CDR OUTPUTS)
                      (CDR DELAYS)
                      (CDR OUT-DEPENDS)
                      IN-MAP OUT-MAP
                      (CONS (CONS (CAR OUTPUTS)
                                  (LOCAL-DELAY (CAR DELAYS)
                                               (CAR OUT-DEPENDS)
                                               F IN-MAP OUT-MAP DELAY-MAP))
                            DELAY-MAP))
          DELAY-MAP))

(TOGGLE ADD-DELAYS-OFF ADD-DELAYS T)

(DEFN UPDATE-DELAYS
      (DELAYS O-OUTS O-FN-PROPS IN-MAP OUT-MAP)
      (ADD-DELAYS O-OUTS
                  (VALUE 'DELAYS O-FN-PROPS)
                  (VALUE 'OUT-DEPENDS O-FN-PROPS)
                  IN-MAP OUT-MAP DELAYS))

(TOGGLE UPDATE-DELAYS-OFF UPDATE-DELAYS T)

(DEFN ADD-LOAD-DELAY
      (DELAY LOAD)
      (IF (ZERO-LOADINGP LOAD)
          DELAY
          (MAKE-DELAY (DELAY-SLOPE-LH DELAY)
                      (RANGE-PLUS (DELAY-INTERCEPT-LH DELAY)
                                  (SLOPE-TIMES-LOAD (DELAY-SLOPE-LH DELAY)
                                                    LOAD)
                                  NIL)
                      (DELAY-SLOPE-HL DELAY)
                      (RANGE-PLUS (DELAY-INTERCEPT-HL DELAY)
                                  (SLOPE-TIMES-LOAD (DELAY-SLOPE-HL DELAY)
                                                    LOAD)
                                  NIL)
                      (DELAY-DEPENDENCIES DELAY))))

(TOGGLE ADD-LOAD-DELAY-OFF ADD-LOAD-DELAY T)

(DEFN LOADED-DELAY
      (DELAY LOAD LISTP)
      (COND (LISTP (IF (LISTP DELAY)
                       (CONS (LOADED-DELAY (CAR DELAY) LOAD F)
                             (LOADED-DELAY (CDR DELAY) LOAD T))
                       NIL))
            ((NLISTP DELAY) DELAY)
            ((EQUAL (CAR DELAY) 'OR)
             (CONS 'OR
                   (LOADED-DELAY (CDR DELAY) LOAD T)))
            (T (ADD-LOAD-DELAY DELAY LOAD))))

(TOGGLE LOADED-DELAY-OFF LOADED-DELAY T)

(DEFN LOADED-DELAYS
      (DELAYS LOADINGS)
      (IF (LISTP DELAYS)
          (IF (NLISTP (CAR DELAYS))
              (CONS (CAR DELAYS)
                    (LOADED-DELAYS (CDR DELAYS) LOADINGS))
              (CONS (CONS (CAAR DELAYS)
                          (LOADED-DELAY (CDAR DELAYS)
                                        (VALUE (CAAR DELAYS) LOADINGS)
                                        F))
                    (LOADED-DELAYS (CDR DELAYS)
                                   LOADINGS)))
          DELAYS))

(TOGGLE LOADED-DELAYS-OFF LOADED-DELAYS T)

(DEFN MERGE-INPUT-DELAYS
      (R1 R2 OR-ARGS?)
      (COND ((OR (RANGEP R1) (NUMBERP R1))
             (IF (OR (RANGEP R2) (NUMBERP R2))
                 (MAKE-RANGE (IF OR-ARGS?
                                 (MIN (RANGE-MIN R1) (RANGE-MIN R2))
                                 (MAX (RANGE-MIN R1) (RANGE-MIN R2)))
                             (MAX (RANGE-MAX R1) (RANGE-MAX R2))
                             (UNION (RANGE-DEPENDENCIES R1)
                                    (RANGE-DEPENDENCIES R2)))
                 (MAKE-RANGE (RANGE-MIN R1)
                             (RANGE-MAX R1)
                             (INSERT R2 (RANGE-DEPENDENCIES R1)))))
            ((OR (RANGEP R2) (NUMBERP R2))
             (MAKE-RANGE (RANGE-MIN R2)
                         (RANGE-MAX R2)
                         (INSERT R1 (RANGE-DEPENDENCIES R2))))
            (T (MAKE-RANGE 0 0
                           (INSERT R1 (LIST R2))))))

(TOGGLE MERGE-INPUT-DELAYS-OFF MERGE-INPUT-DELAYS T)

(DEFN MERGEABLE-INPUT-DELAY-P
      (D APPROXP)
      (IF APPROXP
          (OR (RANGEP D)
              (NUMBERP D)
              (SIGNAL-NAMEP D))
          (DETERMINED-RANGEP D)))

(TOGGLE MERGEABLE-INPUT-DELAY-P-OFF MERGEABLE-INPUT-DELAY-P T)

(DEFN INSERT-INPUT-DELAY
      (D DLIST OR-ARGS? APPROXP)
      (COND ((UNKNOWNP D) DLIST)
            ((NLISTP DLIST)
             (IF (AND OR-ARGS? (EQUAL (CAR D) 'OR))
                 (CDR D)
                 (LIST D)))
            ((AND OR-ARGS?
                  (LISTP D)
                  (EQUAL (CAR D) 'OR))
             (INSERT-INPUT-DELAY (CADR D)
                                 (INSERT (CAR DLIST)
                                         (UNION (CDDR D) (CDR DLIST)))
                                 OR-ARGS? APPROXP))
            ((MERGEABLE-INPUT-DELAY-P D
                                      (AND APPROXP (NOT OR-ARGS?)))
             (IF (MERGEABLE-INPUT-DELAY-P (CAR DLIST)
                                          (AND APPROXP (NOT OR-ARGS?)))
                 (CONS (MERGE-INPUT-DELAYS D
                                           (CAR DLIST)
                                           OR-ARGS?)
                       (CDR DLIST))
                 (CONS D DLIST)))
            ((MERGEABLE-INPUT-DELAY-P (CAR DLIST)
                                      (AND APPROXP (NOT OR-ARGS?)))
             (CONS (CAR DLIST)
                   (INSERT D (CDR DLIST))))
            (T (INSERT D DLIST))))

(TOGGLE INSERT-INPUT-DELAY-OFF INSERT-INPUT-DELAY T)

(DEFN LITERAL-DELAY-TO-RANGE
      (D)
      (MAKE-RANGE (MIN (RANGE-MIN (DELAY-INTERCEPT-LH D))
                       (RANGE-MIN (DELAY-INTERCEPT-HL D)))
                  (MAX (RANGE-MAX (DELAY-INTERCEPT-LH D))
                       (RANGE-MAX (DELAY-INTERCEPT-HL D)))
                  (DELAY-DEPENDENCIES D)))

(TOGGLE LITERAL-DELAY-TO-RANGE-OFF LITERAL-DELAY-TO-RANGE T)

(DEFN OR-DELAY-ARGS-TO-RANGES
      (ARGS RESULT)
      (IF (LISTP ARGS)
          (COND ((NLISTP (CAR ARGS))
                 (INSERT-INPUT-DELAY (CAR ARGS)
                                     (OR-DELAY-ARGS-TO-RANGES (CDR ARGS)
                                                              RESULT)
                                     T F))
                ((EQUAL (CAAR ARGS) 'OR)
                 (OR-DELAY-ARGS-TO-RANGES (CDAR ARGS)
                                          (OR-DELAY-ARGS-TO-RANGES (CDR ARGS)
                                                                   RESULT)))
                (T (INSERT-INPUT-DELAY (LITERAL-DELAY-TO-RANGE (CAR ARGS))
                                       (OR-DELAY-ARGS-TO-RANGES (CDR ARGS)
                                                                RESULT)
                                       T F)))
          RESULT))

(TOGGLE OR-DELAY-ARGS-TO-RANGES-OFF OR-DELAY-ARGS-TO-RANGES T)

(DEFN MAKE-DELAY-OR
      (ARGS)
      (COND ((NLISTP ARGS) (UNKNOWN))
            ((LISTP (CDR ARGS)) (CONS 'OR ARGS))
            ((SIGNAL-NAMEP (CAR ARGS))
             (CONS 'OR (CONS (UNKNOWN) ARGS)))
            (T (CAR ARGS))))

(TOGGLE MAKE-DELAY-OR-OFF MAKE-DELAY-OR T)

(DEFN DELAY-TO-RANGE
      (D)
      (COND ((NLISTP D) D)
            ((EQUAL (CAR D) 'OR)
             (MAKE-DELAY-OR (OR-DELAY-ARGS-TO-RANGES (CDR D)
                                                     NIL)))
            (T (LITERAL-DELAY-TO-RANGE D))))

(TOGGLE DELAY-TO-RANGE-OFF DELAY-TO-RANGE T)

(TOGGLE RANGE-DEPENDENCIES-ON1 RANGE-DEPENDENCIES NIL)

(DEFN ADDABLE-INPUT-DELAY
      (IN-DELAYS APPROXP)
      (IF (AND (LISTP IN-DELAYS)
               (NLISTP (CDR IN-DELAYS)))
          (IF (IF APPROXP
                  (OR (RANGEP (CAR IN-DELAYS))
                      (NUMBERP (CAR IN-DELAYS)))
                  (DETERMINED-RANGEP (CAR IN-DELAYS)))
              (CAR IN-DELAYS)
              F)
          F))

(TOGGLE ADDABLE-INPUT-DELAY-OFF ADDABLE-INPUT-DELAY T)

(DEFN INPUT-DELAY0
 (DEP DELAYS INPUTS OUTPUTS OR-ARGS? LIST? USED-NAMES APPROXP)
 (COND
  (LIST? (IF (LISTP DEP)
             (INSERT-INPUT-DELAY (INPUT-DELAY0 (CAR DEP)
                                               DELAYS INPUTS OUTPUTS OR-ARGS?
                                               F USED-NAMES APPROXP)
                                 (INPUT-DELAY0 (CDR DEP)
                                               DELAYS INPUTS OUTPUTS OR-ARGS?
                                               T USED-NAMES APPROXP)
                                 OR-ARGS? APPROXP)
             NIL))
  ((NLISTP DEP)
   (COND ((NUMBERP DEP) DEP)
         ((MEMBER DEP INPUTS) DEP)
         ((MEMBER DEP USED-NAMES) (UNKNOWN))
         ((MEMBER DEP OUTPUTS)
          (IF OR-ARGS?
              (UNKNOWN)
              (PARENT-SYNONYM DEP DELAYS)))
         ((BOUNDP DEP DELAYS)
          (INPUT-DELAY0 (DELAY-TO-RANGE (VALUE DEP DELAYS))
                        DELAYS INPUTS OUTPUTS OR-ARGS? F
                        (CONS DEP USED-NAMES)
                        APPROXP))
         (T (UNKNOWN))))
  ((EQUAL (CAR DEP) 'OR)
   (MAKE-DELAY-OR (INPUT-DELAY0 (CDR DEP)
                                DELAYS INPUTS OUTPUTS T T USED-NAMES APPROXP)))
  ((RANGEP DEP)
   (IF
    (ADDABLE-INPUT-DELAY (INPUT-DELAY0 (RANGE-DEPENDENCIES DEP)
                                       DELAYS INPUTS OUTPUTS F T USED-NAMES
                                       APPROXP)
                         APPROXP)
    (RANGE-PLUS DEP
     (ADDABLE-INPUT-DELAY (INPUT-DELAY0 (RANGE-DEPENDENCIES DEP)
                                        DELAYS INPUTS OUTPUTS F T USED-NAMES
                                        APPROXP)
                          APPROXP)
     (RANGE-DEPENDENCIES
                    (ADDABLE-INPUT-DELAY (INPUT-DELAY0 (RANGE-DEPENDENCIES DEP)
                                                       DELAYS INPUTS OUTPUTS F
                                                       T USED-NAMES APPROXP)
                                         APPROXP)))
    (MAKE-RANGE (RANGE-MIN DEP)
                (RANGE-MAX DEP)
                (INPUT-DELAY0 (RANGE-DEPENDENCIES DEP)
                              DELAYS INPUTS OUTPUTS F T USED-NAMES APPROXP))))
  (T (UNKNOWN)))
 ((ORD-LESSP (CONS (ADD1 (COUNT (UNBIND-LIST USED-NAMES DELAYS)))
                   (COUNT DEP)))))

(TOGGLE RANGE-DEPENDENCIES-OFF2 RANGE-DEPENDENCIES T)

(TOGGLE INPUT-DELAY0-OFF INPUT-DELAY0 T)

(DEFN INPUT-DELAY
      (DEP DELAYS INPUTS OUTPUTS OR-ARGS? LIST? USED-NAMES APPROXP)
      (IF (AND (LISTP (INPUT-DELAY0 DEP DELAYS INPUTS OUTPUTS OR-ARGS? LIST?
                                    USED-NAMES APPROXP))
               (RANGEP (CAR (INPUT-DELAY0 DEP DELAYS INPUTS OUTPUTS
                                          OR-ARGS? LIST? USED-NAMES APPROXP))))
          (IF (AND (EQUAL (RANGE-MIN (CAR (INPUT-DELAY0 DEP DELAYS INPUTS
                                                        OUTPUTS OR-ARGS?
                                                        LIST? USED-NAMES
                                                        APPROXP)))
                          0)
                   (EQUAL (RANGE-MAX (CAR (INPUT-DELAY0 DEP DELAYS INPUTS
                                                        OUTPUTS OR-ARGS?
                                                        LIST? USED-NAMES
                                                        APPROXP)))
                          0))
              (UNION (RANGE-DEPENDENCIES (CAR (INPUT-DELAY0 DEP DELAYS
                                                            INPUTS OUTPUTS
                                                            OR-ARGS? LIST?
                                                            USED-NAMES
                                                            APPROXP)))
                     (CDR (INPUT-DELAY0 DEP DELAYS INPUTS OUTPUTS OR-ARGS?
                                        LIST? USED-NAMES APPROXP)))
              (INPUT-DELAY0 DEP DELAYS INPUTS OUTPUTS OR-ARGS? LIST?
                            USED-NAMES APPROXP))
          (INPUT-DELAY0 DEP DELAYS INPUTS OUTPUTS OR-ARGS? LIST? USED-NAMES
                        APPROXP)))

(TOGGLE INPUT-DELAY-OFF INPUT-DELAY T)

(DEFN TYPE-DELAY-SLOPE
      (SLOPE TYPE)
      (COND ((MEMBER TYPE
                     '(BOOLP CLK LEVEL PARAMETRIC TRI-STATE))
             (PER-STD-LOAD-DELAY-SLOPE SLOPE))
            ((MEMBER TYPE '(TTL TTL-TRI-STATE))
             (PER-PF-DELAY-SLOPE SLOPE))
            (T SLOPE)))

(TOGGLE TYPE-DELAY-SLOPE-OFF TYPE-DELAY-SLOPE T)

(DEFN MAKE-OUTPUT-DELAY
      (DELAY TYPE INPUT-DELAY-LIST APPROXP)
      (IF (ADDABLE-INPUT-DELAY INPUT-DELAY-LIST APPROXP)
          (MAKE-DELAY (TYPE-DELAY-SLOPE (DELAY-SLOPE-LH DELAY)
                                        TYPE)
                      (RANGE-PLUS (DELAY-INTERCEPT-LH DELAY)
                                  (ADDABLE-INPUT-DELAY INPUT-DELAY-LIST
                                                       APPROXP)
                                  NIL)
                      (TYPE-DELAY-SLOPE (DELAY-SLOPE-HL DELAY)
                                        TYPE)
                      (RANGE-PLUS (DELAY-INTERCEPT-HL DELAY)
                                  (ADDABLE-INPUT-DELAY INPUT-DELAY-LIST
                                                       APPROXP)
                                  NIL)
                      (RANGE-DEPENDENCIES (ADDABLE-INPUT-DELAY INPUT-DELAY-LIST
                                                               APPROXP)))
          (MAKE-DELAY (TYPE-DELAY-SLOPE (DELAY-SLOPE-LH DELAY)
                                        TYPE)
                      (DELAY-INTERCEPT-LH DELAY)
                      (TYPE-DELAY-SLOPE (DELAY-SLOPE-HL DELAY)
                                        TYPE)
                      (DELAY-INTERCEPT-HL DELAY)
                      INPUT-DELAY-LIST)))

(TOGGLE MAKE-OUTPUT-DELAY-OFF MAKE-OUTPUT-DELAY T)

(DEFN OR-DELAY-ARGS
      (A LISTP TYPE DELAYS USED-NAMES INPUTS OUTPUTS APPROXP)
      (COND (LISTP (IF (LISTP A)
                       (UNION (OR-DELAY-ARGS (CAR A)
                                             F TYPE DELAYS USED-NAMES INPUTS
                                             OUTPUTS APPROXP)
                              (OR-DELAY-ARGS (CDR A)
                                             T TYPE DELAYS USED-NAMES INPUTS
                                             OUTPUTS APPROXP))
                       NIL))
            ((SIGNAL-NAMEP A)
             (COND ((MEMBER A INPUTS) (LIST A))
                   ((AND (NOT (OR (MEMBER A OUTPUTS)
                                  (MEMBER A USED-NAMES)))
                         (BOUNDP A DELAYS))
                    (OR-DELAY-ARGS (VALUE A DELAYS)
                                   F TYPE DELAYS
                                   (CONS A USED-NAMES)
                                   INPUTS OUTPUTS APPROXP))
                   (T (LIST (UNKNOWN)))))
            ((NLISTP A) (LIST (UNKNOWN)))
            ((EQUAL (CAR A) 'OR)
             (OR-DELAY-ARGS (CDR A)
                            T TYPE DELAYS USED-NAMES INPUTS OUTPUTS APPROXP))
            (T (LIST (MAKE-OUTPUT-DELAY A TYPE
                                        (INPUT-DELAY (DELAY-DEPENDENCIES A)
                                                     DELAYS INPUTS OUTPUTS F T
                                                     USED-NAMES APPROXP)
                                        APPROXP))))
      ((ORD-LESSP (CONS (ADD1 (COUNT (UNBIND-LIST USED-NAMES DELAYS)))
                        (COUNT A)))))

(TOGGLE OR-DELAY-ARGS-OFF OR-DELAY-ARGS T)

(DEFN OUTPUT-DELAY
 (NAME TYPE DELAYS INPUTS OUTPUTS APPROXP)
 (COND
  ((SIGNAL-NAMEP (VALUE-OR-UNKNOWN NAME DELAYS))
   (PARENT-SYNONYM (VALUE-OR-UNKNOWN NAME DELAYS)
                   DELAYS))
  ((NLISTP (VALUE-OR-UNKNOWN NAME DELAYS))
   (UNKNOWN))
  ((EQUAL (CAR (VALUE-OR-UNKNOWN NAME DELAYS))
          'OR)
   (MAKE-DELAY-OR (OR-DELAY-ARGS (CDR (VALUE-OR-UNKNOWN NAME DELAYS))
                                 T TYPE DELAYS
                                 (LIST NAME)
                                 INPUTS OUTPUTS APPROXP)))
  (T
   (MAKE-OUTPUT-DELAY
               (VALUE-OR-UNKNOWN NAME DELAYS)
               TYPE
               (INPUT-DELAY (DELAY-DEPENDENCIES (VALUE-OR-UNKNOWN NAME DELAYS))
                            DELAYS INPUTS OUTPUTS F T
                            (LIST NAME)
                            APPROXP)
               APPROXP))))

(TOGGLE OUTPUT-DELAY-OFF OUTPUT-DELAY T)

(DEFN COLLECT-DELAYS-0
      (NAMES TYPES DELAYS INPUTS OUTPUTS APPROXP)
      (IF (LISTP NAMES)
          (CONS (OUTPUT-DELAY (CAR NAMES)
                              (CAR TYPES)
                              DELAYS INPUTS OUTPUTS APPROXP)
                (COLLECT-DELAYS-0 (CDR NAMES)
                                  (CDR TYPES)
                                  DELAYS INPUTS OUTPUTS APPROXP))
          NIL))

(TOGGLE COLLECT-DELAYS-0-OFF COLLECT-DELAYS-0 T)

(DEFN COLLECT-DELAYS
      (OUTPUTS OUTPUT-TYPES DELAYS INPUTS APPROXP)
      (COLLECT-DELAYS-0 OUTPUTS OUTPUT-TYPES
                        (EXTERNALIZE-PARENTS OUTPUTS DELAYS INPUTS OUTPUTS)
                        INPUTS OUTPUTS APPROXP))

(TOGGLE COLLECT-DELAYS-OFF COLLECT-DELAYS T)

(DEFN DELAYS-ERROR
      (DELAYS)
      (ERR-AND DELAYS 'BAD-DELAYS))

(TOGGLE DELAYS-ERROR-OFF DELAYS-ERROR T)

(DEFN INITIAL-OCC-OUT-DEPENDS
      (M-INS M-OUTS)
      (CONS M-OUTS
            (PAIRLIST M-INS (LISTIFY M-INS))))

(TOGGLE INITIAL-OCC-OUT-DEPENDS-OFF INITIAL-OCC-OUT-DEPENDS T)

(DEFN ADD-OUT-DEPENDS
 (OUTPUTS OUT-DEPENDS ARG-MAP DEPS-MAP)
 (IF
  (LISTP OUTPUTS)
  (ADD-OUT-DEPENDS
                 (CDR OUTPUTS)
                 (CDR OUT-DEPENDS)
                 ARG-MAP
                 (CONS (CONS (CAR OUTPUTS)
                             (UNION-VALUES (COLLECT-VALUE (CAR OUT-DEPENDS)
                                                          ARG-MAP)
                                           DEPS-MAP))
                       (CONS (ALL-BOUND-OR-ERR (COLLECT-VALUE (CAR OUT-DEPENDS)
                                                              ARG-MAP)
                                               DEPS-MAP
                                               (LIST 'OUTPUT (CAR OUTPUTS)))
                             DEPS-MAP)))
  DEPS-MAP))

(TOGGLE ADD-OUT-DEPENDS-OFF ADD-OUT-DEPENDS T)

(DEFN UPDATE-OUT-DEPENDS
      (OUT-DEPENDS O-OUTS O-FN-PROPS O-INS ARG-MAP)
      (CONS (UNION O-INS (CAR OUT-DEPENDS))
            (ADD-OUT-DEPENDS O-OUTS
                             (VALUE 'OUT-DEPENDS O-FN-PROPS)
                             ARG-MAP
                             (CDR OUT-DEPENDS))))

(TOGGLE UPDATE-OUT-DEPENDS-OFF UPDATE-OUT-DEPENDS T)

(DEFN COLLECT-OUT-DEPENDS
      (OUTPUTS DEPENDENCIES)
      (COLLECT-VALUE OUTPUTS
                     (CDR DEPENDENCIES)))

(TOGGLE COLLECT-OUT-DEPENDS-OFF COLLECT-OUT-DEPENDS T)

(DEFN COLLECT-OUT-DEPENDS-ERRORS
      (DEPS-MAP USED-SIGNALS)
      (IF (LISTP DEPS-MAP)
          (IF (NET-ERRORP (CAR DEPS-MAP))
              (IF (MEMBER (CADR (ERROR-LABEL (CAR DEPS-MAP)))
                          USED-SIGNALS)
                  (CONS (CAR DEPS-MAP)
                        (COLLECT-OUT-DEPENDS-ERRORS (CDR DEPS-MAP)
                                                    USED-SIGNALS))
                  (COLLECT-OUT-DEPENDS-ERRORS (CDR DEPS-MAP)
                                              USED-SIGNALS))
              (COLLECT-OUT-DEPENDS-ERRORS (CDR DEPS-MAP)
                                          USED-SIGNALS))
          NIL))

(TOGGLE COLLECT-OUT-DEPENDS-ERRORS-OFF COLLECT-OUT-DEPENDS-ERRORS T)

(DEFN OUT-DEPENDS-ERROR
      (DEPENDENCIES)
      (NLISTP-OR-ERR (COLLECT-OUT-DEPENDS-ERRORS (CDR DEPENDENCIES)
                                                 (CAR DEPENDENCIES))
                     'UNBOUND-OUTPUT-DEPENDENCIES))

(TOGGLE OUT-DEPENDS-ERROR-OFF OUT-DEPENDS-ERROR T)

(DEFN INITIAL-OCC-STATE-TYPES NIL NIL)

(DEFN UPDATE-STATE-TYPES
      (STATE-TYPES O-NAME O-FN-PROPS)
      (IF (BOUNDP 'STATE-TYPES O-FN-PROPS)
          (CONS (CONS O-NAME
                      (VALUE 'STATE-TYPES O-FN-PROPS))
                STATE-TYPES)
          STATE-TYPES))

(TOGGLE UPDATE-STATE-TYPES-OFF UPDATE-STATE-TYPES T)

(DEFN COLLECT-STATE-TYPES
      (STATES STATE-TYPES)
      (IF (OR (LISTP STATES) (EQUAL STATES NIL))
          (COLLECT-VALUE-OR-UNKNOWN STATES STATE-TYPES)
          (VALUE-OR-UNKNOWN STATES STATE-TYPES)))

(TOGGLE COLLECT-STATE-TYPES-OFF COLLECT-STATE-TYPES T)

(DEFN STATE-TYPES-ERROR
      (STATE-TYPES STATES)
      (T-OR-ERR (SET-EQUAL (STRIP-CARS STATE-TYPES)
                           (M-STATES-LIST STATES))
                'BAD-STATE-TYPES
                (LIST (LIST 'MODULE-STATES STATES)
                      (LIST 'COMPUTED-STATES
                            (STRIP-CARS STATE-TYPES)))))

(TOGGLE STATE-TYPES-ERROR-OFF STATE-TYPES-ERROR T)

(DEFN INITIAL-OCC-TRI-STATE-DATA
      (M-OUTS)
      (CONS (CONS 'FREE-SIGNALS M-OUTS)
            '((T-WIRE-INS) (SYNONYMS))))

(TOGGLE INITIAL-OCC-TRI-STATE-DATA-OFF INITIAL-OCC-TRI-STATE-DATA T)

(DEFN FUNCTION-T-WIRE-INS
      (FN DATA)
      (COND ((BOUNDP 'TRI-STATE-DATA DATA)
             (VALUE 'T-WIRE-INS
                    (VALUE 'TRI-STATE-DATA DATA)))
            ((EQUAL FN 'T-WIRE)
             (VALUE 'INPUTS DATA))
            (T NIL)))

(TOGGLE FUNCTION-T-WIRE-INS-OFF FUNCTION-T-WIRE-INS T)

(DEFN FUNCTION-SYNONYMS
      (FN DATA)
      (COND ((BOUNDP 'TRI-STATE-DATA DATA)
             (VALUE 'SYNONYMS
                    (VALUE 'TRI-STATE-DATA DATA)))
            ((EQUAL FN 'ID)
             (PAIRLIST (VALUE 'OUTPUTS DATA)
                       (VALUE 'INPUTS DATA)))
            (T NIL)))

(TOGGLE FUNCTION-SYNONYMS-OFF FUNCTION-SYNONYMS T)

(DEFN ADD-SYNONYMS
      (F-SYNONYMS IN-MAP OUT-MAP SLIST)
      (IF (LISTP F-SYNONYMS)
          (ADD-SYNONYMS (CDR F-SYNONYMS)
                        IN-MAP OUT-MAP
                        (CONS (CONS (VALUE (CAAR F-SYNONYMS) OUT-MAP)
                                    (VALUE2 (CDAR F-SYNONYMS)
                                            IN-MAP OUT-MAP))
                              SLIST))
          SLIST))

(TOGGLE ADD-SYNONYMS-OFF ADD-SYNONYMS T)

(DEFN UPDATE-TRI-STATE-DATA
 (DATA O-INS O-FN O-FN-DATA IN-MAP OUT-MAP)
 (LIST
  (CONS 'FREE-SIGNALS
   (UNION (COND ((LISTP (COLLECT-VALUE2 (FUNCTION-T-WIRE-INS O-FN O-FN-DATA)
                                        IN-MAP OUT-MAP))
                 (SET-DIFF O-INS
                           (COLLECT-VALUE2 (FUNCTION-T-WIRE-INS O-FN O-FN-DATA)
                                           IN-MAP OUT-MAP)))
                ((EQUAL O-FN 'ID) NIL)
                (T O-INS))
          (VALUE 'FREE-SIGNALS DATA)))
  (CONS 'T-WIRE-INS
        (APPEND (COLLECT-VALUE2 (FUNCTION-T-WIRE-INS O-FN O-FN-DATA)
                                IN-MAP OUT-MAP)
                (VALUE 'T-WIRE-INS DATA)))
  (CONS 'SYNONYMS
        (ADD-SYNONYMS (FUNCTION-SYNONYMS O-FN O-FN-DATA)
                      IN-MAP OUT-MAP
                      (VALUE 'SYNONYMS DATA)))))

(TOGGLE UPDATE-TRI-STATE-DATA-OFF UPDATE-TRI-STATE-DATA T)

(DEFN IO-SIGNAL-RENAMES
      (SYNONYMS IO-SIGNALS SLIST)
      (IF (LISTP SYNONYMS)
          (IF (AND (OR (IO-OUTP (CAAR SYNONYMS))
                       (IO-OUTP (PARENT-SYNONYM (CDAR SYNONYMS)
                                                SLIST))
                       (MEMBER (PARENT-SYNONYM (CDAR SYNONYMS) SLIST)
                               IO-SIGNALS))
                   (NOT (EQUAL (CAAR SYNONYMS)
                               (PARENT-SYNONYM (CDAR SYNONYMS)
                                               SLIST))))
              (CONS (CONS (CAAR SYNONYMS)
                          (PARENT-SYNONYM (CDAR SYNONYMS)
                                          SLIST))
                    (IO-SIGNAL-RENAMES (CDR SYNONYMS)
                                       IO-SIGNALS SLIST))
              (IO-SIGNAL-RENAMES (CDR SYNONYMS)
                                 IO-SIGNALS SLIST))
          NIL))

(TOGGLE IO-SIGNAL-RENAMES-OFF IO-SIGNAL-RENAMES T)

(DEFN IO-RENAME-ERROR
      (SYNONYMS IO-SIGNALS)
      (NLISTP-OR-ERR (IO-SIGNAL-RENAMES SYNONYMS IO-SIGNALS SYNONYMS)
                     'RENAMED-IO-SIGNALS))

(TOGGLE IO-RENAME-ERROR-OFF IO-RENAME-ERROR T)

(DEFN T-WIRE-ERROR
      (FREE-SIGNALS T-WIRE-INS)
      (ERR-AND (LIST (DISJOINT-OR-ERR (REMOVE-DUPLICATES T-WIRE-INS)
                                      FREE-SIGNALS
                                      'T-WIRE-INS-USED-ELSEWHERE)
                     (NO-DUPLICATES-OR-ERR T-WIRE-INS
                                           'DUPLICATE-T-WIRE-INPUTS))
               'T-WIRE-ERRORS))

(TOGGLE T-WIRE-ERROR-OFF T-WIRE-ERROR T)

(DEFN COMPOSE-TRI-STATE-DATA
      (DATA IO-SIGNALS)
      (LIST (CONS 'FREE-SIGNALS
                  (PARENT-SYNONYMS-LIST (VALUE 'FREE-SIGNALS DATA)
                                        (VALUE 'SYNONYMS DATA)))
            (CONS 'T-WIRE-INS
                  (PARENT-SYNONYMS-LIST (VALUE 'T-WIRE-INS DATA)
                                        (VALUE 'SYNONYMS DATA)))
            (CONS 'SYNONYMS
                  (VALUE 'SYNONYMS DATA))
            (IO-RENAME-ERROR (VALUE 'SYNONYMS DATA)
                             IO-SIGNALS)
            (T-WIRE-ERROR (PARENT-SYNONYMS-LIST (VALUE 'FREE-SIGNALS DATA)
                                                (VALUE 'SYNONYMS DATA))
                          (PARENT-SYNONYMS-LIST (VALUE 'T-WIRE-INS DATA)
                                                (VALUE 'SYNONYMS DATA)))))

(TOGGLE COMPOSE-TRI-STATE-DATA-OFF COMPOSE-TRI-STATE-DATA T)

(DEFN COLLECT-SYNONYMS
      (M-OUTS SYNONYMS)
      (IF (LISTP M-OUTS)
          (IF (EQUAL (CAR M-OUTS)
                     (PARENT-SYNONYM (CAR M-OUTS)
                                     SYNONYMS))
              (COLLECT-SYNONYMS (CDR M-OUTS)
                                SYNONYMS)
              (CONS (CONS (CAR M-OUTS)
                          (PARENT-SYNONYM (CAR M-OUTS)
                                          SYNONYMS))
                    (COLLECT-SYNONYMS (CDR M-OUTS)
                                      SYNONYMS)))
          NIL))

(TOGGLE COLLECT-SYNONYMS-OFF COLLECT-SYNONYMS T)

(DEFN COLLECT-TRI-STATE-DATA
     (M-INS M-OUTS DATA)
     (LIST (CONS 'T-WIRE-INS
                 (INTERSECTION M-INS
                               (VALUE 'T-WIRE-INS DATA)))
           (CONS 'SYNONYMS
                 (COLLECT-SYNONYMS M-OUTS
                                   (EXTERNALIZE-PARENTS M-OUTS
                                                        (VALUE 'SYNONYMS DATA)
                                                        M-INS M-OUTS)))))

(TOGGLE COLLECT-TRI-STATE-DATA-OFF COLLECT-TRI-STATE-DATA T)

(DEFN TRI-STATE-ERRORS
      (DATA)
      (COND ((AND (NET-ERRORP (ERROR-ENTRY DATA 'RENAMED-IO-SIGNALS))
                  (NET-ERRORP (ERROR-ENTRY DATA 'T-WIRE-ERRORS)))
             (LIST (ERROR-ENTRY DATA 'RENAMED-IO-SIGNALS)
                   (ERROR-ENTRY DATA 'T-WIRE-ERRORS)))
            ((NET-ERRORP (ERROR-ENTRY DATA 'RENAMED-IO-SIGNALS))
             (ERROR-ENTRY DATA 'RENAMED-IO-SIGNALS))
            ((NET-ERRORP (ERROR-ENTRY DATA 'T-WIRE-ERRORS))
             (ERROR-ENTRY DATA 'T-WIRE-ERRORS))
            (T NIL)))

(TOGGLE TRI-STATE-ERRORS-OFF TRI-STATE-ERRORS T)

(DEFN INITIAL-OCC-DATA
 (PROPS M-INS M-OUTS)
 (IF
  (LISTP PROPS)
  (IF (LISTP (CASE (CAR PROPS)
                   (DELAYS (CONS 'DELAYS (INITIAL-OCC-DELAYS)))
                   (DRIVES (CONS 'DRIVES (INITIAL-OCC-DRIVES)))
                   (INPUT-TYPES (CONS 'INPUT-TYPES
                                      (INITIAL-OCC-IN-TYPES)))
                   (LOADINGS (CONS 'LOADINGS
                                   (INITIAL-OCC-LOADINGS)))
                   (OUT-DEPENDS (CONS 'OUT-DEPENDS
                                      (INITIAL-OCC-OUT-DEPENDS M-INS M-OUTS)))
                   (OUTPUT-TYPES (CONS 'OUTPUT-TYPES
                                       (INITIAL-OCC-OUT-TYPES)))
                   (STATE-TYPES (CONS 'STATE-TYPES
                                      (INITIAL-OCC-STATE-TYPES)))
                   (TRI-STATE-DATA (CONS 'TRI-STATE-DATA
                                         (INITIAL-OCC-TRI-STATE-DATA M-OUTS)))
                   (OTHERWISE (IF (MEMBER (CAR PROPS)
                                          '(GATES PADS PRIMITIVES TRANSISTORS))
                                  (CONS (CAR PROPS) 0)
                                  NIL))))
      (CONS (CASE (CAR PROPS)
                  (DELAYS (CONS 'DELAYS (INITIAL-OCC-DELAYS)))
                  (DRIVES (CONS 'DRIVES (INITIAL-OCC-DRIVES)))
                  (INPUT-TYPES (CONS 'INPUT-TYPES
                                     (INITIAL-OCC-IN-TYPES)))
                  (LOADINGS (CONS 'LOADINGS
                                  (INITIAL-OCC-LOADINGS)))
                  (OUT-DEPENDS (CONS 'OUT-DEPENDS
                                     (INITIAL-OCC-OUT-DEPENDS M-INS M-OUTS)))
                  (OUTPUT-TYPES (CONS 'OUTPUT-TYPES
                                      (INITIAL-OCC-OUT-TYPES)))
                  (STATE-TYPES (CONS 'STATE-TYPES
                                     (INITIAL-OCC-STATE-TYPES)))
                  (TRI-STATE-DATA (CONS 'TRI-STATE-DATA
                                        (INITIAL-OCC-TRI-STATE-DATA M-OUTS)))
                  (OTHERWISE (IF (MEMBER (CAR PROPS)
                                         '(GATES PADS PRIMITIVES TRANSISTORS))
                                 (CONS (CAR PROPS) 0)
                                 NIL)))
            (INITIAL-OCC-DATA (CDR PROPS)
                              M-INS M-OUTS))
      (INITIAL-OCC-DATA (CDR PROPS)
                        M-INS M-OUTS))
  NIL))

(TOGGLE INITIAL-OCC-DATA-OFF INITIAL-OCC-DATA T)

(DEFN UPDATE-OPROP-BINDING
   (O-NAME O-INS O-OUTS O-FN O-FN-PROPS IN-MAP OUT-MAP BINDING)
   (IF (LISTP BINDING)
       (CONS (CAR BINDING)
             (CASE (CAR BINDING)
                   (DELAYS (UPDATE-DELAYS (CDR BINDING)
                                          O-OUTS O-FN-PROPS IN-MAP OUT-MAP))
                   (DRIVES (UPDATE-DRIVES (CDR BINDING)
                                          O-OUTS O-FN-PROPS IN-MAP OUT-MAP))
                   (INPUT-TYPES (UPDATE-IN-TYPES (CDR BINDING)
                                                 O-INS O-FN-PROPS))
                   (LOADINGS (UPDATE-LOADINGS (CDR BINDING)
                                              O-INS O-FN-PROPS))
                   (OUT-DEPENDS (UPDATE-OUT-DEPENDS (CDR BINDING)
                                                    O-OUTS O-FN-PROPS O-INS
                                                    IN-MAP))
                   (OUTPUT-TYPES (UPDATE-OUT-TYPES (CDR BINDING)
                                                   O-OUTS O-FN-PROPS IN-MAP))
                   (STATE-TYPES (UPDATE-STATE-TYPES (CDR BINDING)
                                                    O-NAME O-FN-PROPS))
                   (TRI-STATE-DATA (UPDATE-TRI-STATE-DATA (CDR BINDING)
                                                          O-INS O-FN
                                                          O-FN-PROPS IN-MAP
                                                          OUT-MAP))
                   (OTHERWISE (IF (MEMBER (CAR BINDING)
                                          '(GATES PADS PRIMITIVES TRANSISTORS))
                                  (PLUS (VALUE (CAR BINDING) O-FN-PROPS)
                                        (CDR BINDING))
                                  (CDR BINDING)))))
       BINDING))

(TOGGLE UPDATE-OPROP-BINDING-OFF UPDATE-OPROP-BINDING T)

(DEFN UPDATE-OCC-BINDINGS
      (O-NAME O-INS O-OUTS O-FN O-FN-PROPS IN-MAP OUT-MAP BINDINGS)
      (IF (LISTP BINDINGS)
          (CONS (UPDATE-OPROP-BINDING O-NAME O-INS O-OUTS O-FN O-FN-PROPS
                                      IN-MAP OUT-MAP
                                      (CAR BINDINGS))
                (UPDATE-OCC-BINDINGS O-NAME O-INS O-OUTS O-FN O-FN-PROPS
                                     IN-MAP OUT-MAP
                                     (CDR BINDINGS)))
          NIL))

(TOGGLE UPDATE-OCC-BINDINGS-OFF UPDATE-OCC-BINDINGS T)

(DEFN FUNCTION-PROPERTIES
      (FN DATABASE)
      (IF (PRIMP FN)
          (CDR (PRIMP FN))
          (VALUE FN DATABASE)))

(TOGGLE FUNCTION-PROPERTIES-OFF FUNCTION-PROPERTIES T)

(DEFN COLLECT-OCCURRENCE-DATA
 (BODY BINDINGS IO-OUTPUTS IO-SIGNALS DATABASE)
 (IF
  (LISTP BODY)
  (COLLECT-OCCURRENCE-DATA
   (CDR BODY)
   (UPDATE-OCC-BINDINGS
                (OCC-NAME (CAR BODY))
                (MARK-IO-OUTS (OCC-INPUTS (CAR BODY))
                              IO-OUTPUTS)
                (MARK-IO-OUTS (OCC-OUTPUTS (CAR BODY))
                              IO-SIGNALS)
                (OCC-FUNCTION (CAR BODY))
                (FUNCTION-PROPERTIES (OCC-FUNCTION (CAR BODY))
                                     DATABASE)
                (PAIRLIST (VALUE 'INPUTS
                                 (FUNCTION-PROPERTIES (OCC-FUNCTION (CAR BODY))
                                                      DATABASE))
                          (MARK-IO-OUTS (OCC-INPUTS (CAR BODY))
                                        IO-OUTPUTS))
                (PAIRLIST (VALUE 'OUTPUTS
                                 (FUNCTION-PROPERTIES (OCC-FUNCTION (CAR BODY))
                                                      DATABASE))
                          (MARK-IO-OUTS (OCC-OUTPUTS (CAR BODY))
                                        IO-SIGNALS))
                BINDINGS)
   (APPEND (INTERSECTION IO-SIGNALS
                         (OCC-OUTPUTS (CAR BODY)))
           IO-OUTPUTS)
   IO-SIGNALS DATABASE)
  BINDINGS))

(TOGGLE COLLECT-OCCURRENCE-DATA-OFF COLLECT-OCCURRENCE-DATA T)

(DEFN COMPOSED-IO-TYPES
      (IN-TYPES OUT-TYPES TRI-STATE-DATA IO-SIGNALS)
      (LIST (CONS 'TRI-STATE-DATA
                  (COMPOSE-TRI-STATE-DATA TRI-STATE-DATA IO-SIGNALS))
            (CONS 'INPUT-TYPES
                  (CAR (COMPOSE-IO-TYPES IN-TYPES OUT-TYPES
                                         (VALUE 'T-WIRE-INS TRI-STATE-DATA))))
            (CONS 'OUTPUT-TYPES
                  (CDR (COMPOSE-IO-TYPES IN-TYPES OUT-TYPES
                                         (VALUE 'T-WIRE-INS
                                                TRI-STATE-DATA))))))

(TOGGLE COMPOSED-IO-TYPES-OFF COMPOSED-IO-TYPES T)

(DEFN COMPOSED-LOADINGS-DRIVES-DELAYS
      (LOADINGS DRIVES DELAYS)
      (LIST (CONS 'DELAYS
                  (LOADED-DELAYS DELAYS
                                 (TRANSFER-LOADINGS LOADINGS DRIVES)))
            (CONS 'DRIVES
                  (NET-DRIVES-SIMPLE DRIVES
                                     (TRANSFER-LOADINGS LOADINGS DRIVES)))
            (CONS 'LOADINGS
                  (TRANSFER-LOADINGS LOADINGS DRIVES))))

(TOGGLE COMPOSED-LOADINGS-DRIVES-DELAYS-OFF COMPOSED-LOADINGS-DRIVES-DELAYS T)

(DEFN ADD-COMPOSED-DATA
    (PROP-NAME BINDINGS IO-SIGNALS RESULT)
    (COND ((OR (BOUNDP PROP-NAME RESULT)
               (NOT (BOUNDP PROP-NAME BINDINGS)))
           RESULT)
          ((MEMBER PROP-NAME
                   '(INPUT-TYPES OUTPUT-TYPES TRI-STATE-DATA))
           (APPEND (COMPOSED-IO-TYPES (VALUE 'INPUT-TYPES BINDINGS)
                                      (VALUE 'OUTPUT-TYPES BINDINGS)
                                      (VALUE 'TRI-STATE-DATA BINDINGS)
                                      IO-SIGNALS)
                   RESULT))
          ((MEMBER PROP-NAME
                   '(LOADINGS DRIVES DELAYS))
           (APPEND (COMPOSED-LOADINGS-DRIVES-DELAYS (VALUE 'LOADINGS BINDINGS)
                                                    (VALUE 'DRIVES BINDINGS)
                                                    (VALUE 'DELAYS BINDINGS))
                   RESULT))
          (T (CONS (ALIST-ENTRY PROP-NAME BINDINGS)
                   RESULT))))

(TOGGLE ADD-COMPOSED-DATA-OFF ADD-COMPOSED-DATA T)

(DEFN COMPOSED-OCCURRENCE-DATA
      (BINDINGS IO-SIGNALS RESULT)
      (IF (LISTP BINDINGS)
          (COMPOSED-OCCURRENCE-DATA (CDR BINDINGS)
                                    IO-SIGNALS
                                    (IF (NLISTP (CAR BINDINGS))
                                        (CONS (CAR BINDINGS) RESULT)
                                        (ADD-COMPOSED-DATA (CAAR BINDINGS)
                                                           BINDINGS
                                                           IO-SIGNALS RESULT)))
          RESULT))

(TOGGLE COMPOSED-OCCURRENCE-DATA-OFF COMPOSED-OCCURRENCE-DATA T)

(DEFN COMPOSE-OCCURRENCE-DATA
      (BINDINGS IO-SIGNALS)
      (COMPOSED-OCCURRENCE-DATA BINDINGS IO-SIGNALS NIL))

(TOGGLE COMPOSE-OCCURRENCE-DATA-OFF COMPOSE-OCCURRENCE-DATA T)

(DEFN OCCURRENCE-DATA
 (PROPS BODY M-INS M-OUTS IO-SIGNALS DATABASE)
 (COMPOSE-OCCURRENCE-DATA
                 (COLLECT-OCCURRENCE-DATA BODY
                                          (INITIAL-OCC-DATA PROPS M-INS M-OUTS)
                                          NIL IO-SIGNALS DATABASE)
                 IO-SIGNALS))

(TOGGLE OCCURRENCE-DATA-OFF OCCURRENCE-DATA T)

(DEFN COLLECT-MODULE-PROP
 (PROP-NAME M-INS IN-TYPES M-OUTS OUT-TYPES M-STATES OBINDINGS
            APPROXIMATE-DELAYS-P)
 (CASE PROP-NAME
  (DELAYS (CONS 'DELAYS
                (COLLECT-DELAYS M-OUTS OUT-TYPES
                                (CDR (ALIST-ENTRY PROP-NAME OBINDINGS))
                                M-INS APPROXIMATE-DELAYS-P)))
  (DRIVES (CONS 'DRIVES
                (COLLECT-DRIVES M-OUTS OUT-TYPES
                                (CDR (ALIST-ENTRY PROP-NAME OBINDINGS))
                                M-INS)))
  (INPUT-TYPES (CONS 'INPUT-TYPES IN-TYPES))
  (INPUTS (CONS 'INPUTS M-INS))
  (LOADINGS (CONS 'LOADINGS
                  (COLLECT-LOADINGS M-INS IN-TYPES
                                    (CDR (ALIST-ENTRY PROP-NAME OBINDINGS)))))
  (OUT-DEPENDS
          (CONS 'OUT-DEPENDS
                (COLLECT-OUT-DEPENDS M-OUTS
                                     (CDR (ALIST-ENTRY PROP-NAME OBINDINGS)))))
  (OUTPUT-TYPES (CONS 'OUTPUT-TYPES OUT-TYPES))
  (OUTPUTS (CONS 'OUTPUTS
                 (UNMARK-IO-OUTS M-OUTS)))
  (STATE-TYPES
     (IF (EQUAL M-STATES NIL)
         NIL
         (CONS 'STATE-TYPES
               (COLLECT-STATE-TYPES M-STATES
                                    (CDR (ALIST-ENTRY PROP-NAME OBINDINGS))))))
  (STATES (IF (EQUAL M-STATES NIL)
              NIL
              (CONS 'STATES M-STATES)))
  (TRI-STATE-DATA
       (CONS 'TRI-STATE-DATA
             (COLLECT-TRI-STATE-DATA M-INS M-OUTS
                                     (CDR (ALIST-ENTRY PROP-NAME OBINDINGS)))))
  (OTHERWISE (ALIST-ENTRY PROP-NAME OBINDINGS))))

(TOGGLE COLLECT-MODULE-PROP-OFF COLLECT-MODULE-PROP T)

(DEFN COLLECT-MODULE-PROPS
      (PROPS M-INS IN-TYPES M-OUTS OUT-TYPES M-STATES OBINDINGS
             APPROXIMATE-DELAYS-P)
      (IF (LISTP PROPS)
          (IF (LISTP (COLLECT-MODULE-PROP (CAR PROPS)
                                          M-INS IN-TYPES M-OUTS OUT-TYPES
                                          M-STATES OBINDINGS
                                          APPROXIMATE-DELAYS-P))
              (CONS (COLLECT-MODULE-PROP (CAR PROPS)
                                         M-INS IN-TYPES M-OUTS OUT-TYPES
                                         M-STATES OBINDINGS
                                         APPROXIMATE-DELAYS-P)
                    (COLLECT-MODULE-PROPS (CDR PROPS)
                                          M-INS IN-TYPES M-OUTS OUT-TYPES
                                          M-STATES OBINDINGS
                                          APPROXIMATE-DELAYS-P))
              (COLLECT-MODULE-PROPS (CDR PROPS)
                                    M-INS IN-TYPES M-OUTS OUT-TYPES M-STATES
                                    OBINDINGS APPROXIMATE-DELAYS-P))
          NIL))

(TOGGLE COLLECT-MODULE-PROPS-OFF COLLECT-MODULE-PROPS T)

(DEFN MODULE-PROP-ERROR
      (OBINDING M-STATES)
      (IF (LISTP OBINDING)
          (CASE (CAR OBINDING)
                (DELAYS (DELAYS-ERROR (CDR OBINDING)))
                (DRIVES (DRIVES-ERROR (CDR OBINDING)))
                (INPUT-TYPES (IN-TYPES-ERROR (CDR OBINDING)))
                (LOADINGS (LOADINGS-ERROR (CDR OBINDING)))
                (OUT-DEPENDS (OUT-DEPENDS-ERROR (CDR OBINDING)))
                (OUTPUT-TYPES (OUT-TYPES-ERROR (CDR OBINDING)))
                (STATE-TYPES (STATE-TYPES-ERROR (CDR OBINDING)
                                                M-STATES))
                (TRI-STATE-DATA (TRI-STATE-ERRORS (CDR OBINDING)))
                (OTHERWISE NIL))
          OBINDING))

(TOGGLE MODULE-PROP-ERROR-OFF MODULE-PROP-ERROR T)

(DEFN COLLECT-MODULE-ERRORS
      (OBINDINGS M-STATES)
      (IF (LISTP OBINDINGS)
          (COND ((NET-ERRORP (MODULE-PROP-ERROR (CAR OBINDINGS)
                                                M-STATES))
                 (CONS (MODULE-PROP-ERROR (CAR OBINDINGS)
                                          M-STATES)
                       (COLLECT-MODULE-ERRORS (CDR OBINDINGS)
                                              M-STATES)))
                ((LISTP (MODULE-PROP-ERROR (CAR OBINDINGS)
                                           M-STATES))
                 (APPEND (MODULE-PROP-ERROR (CAR OBINDINGS)
                                            M-STATES)
                         (COLLECT-MODULE-ERRORS (CDR OBINDINGS)
                                                M-STATES)))
                (T (COLLECT-MODULE-ERRORS (CDR OBINDINGS)
                                          M-STATES)))
          NIL))

(TOGGLE COLLECT-MODULE-ERRORS-OFF COLLECT-MODULE-ERRORS T)

(DEFN COLLECT-MODULE-DATA
 (PROPS M-NAME M-INS M-OUTS M-STATES OBINDINGS APPROXIMATE-DELAYS-P)
 (IF
  (NET-ERRORP (NLISTP-OR-ERR (COLLECT-MODULE-ERRORS OBINDINGS M-STATES)
                             (LIST 'MODULE M-NAME)))
  (CONS M-NAME
   (CONS
    (NLISTP-OR-ERR (COLLECT-MODULE-ERRORS OBINDINGS M-STATES)
                   (LIST 'MODULE M-NAME))
    (COLLECT-MODULE-PROPS PROPS M-INS
                        (IF (MEMBER 'INPUT-TYPES PROPS)
                            (COLLECT-IN-TYPES M-INS
                                              (VALUE 'INPUT-TYPES OBINDINGS))
                            NIL)
                        M-OUTS
                        (IF (MEMBER 'OUTPUT-TYPES PROPS)
                            (COLLECT-OUT-TYPES M-OUTS
                                               (VALUE 'OUTPUT-TYPES OBINDINGS)
                                               M-INS
                                               (VALUE 'INPUT-TYPES OBINDINGS))
                            NIL)
                        M-STATES OBINDINGS APPROXIMATE-DELAYS-P)))
  (CONS M-NAME
   (COLLECT-MODULE-PROPS PROPS M-INS
                        (IF (MEMBER 'INPUT-TYPES PROPS)
                            (COLLECT-IN-TYPES M-INS
                                              (VALUE 'INPUT-TYPES OBINDINGS))
                            NIL)
                        M-OUTS
                        (IF (MEMBER 'OUTPUT-TYPES PROPS)
                            (COLLECT-OUT-TYPES M-OUTS
                                               (VALUE 'OUTPUT-TYPES OBINDINGS)
                                               M-INS
                                               (VALUE 'INPUT-TYPES OBINDINGS))
                            NIL)
                        M-STATES OBINDINGS APPROXIMATE-DELAYS-P))))

(TOGGLE COLLECT-MODULE-DATA-OFF COLLECT-MODULE-DATA T)

(DEFN MODULE-DATA
 (MODULE PROPS DATABASE APPROXIMATE-DELAYS-P)
 (COLLECT-MODULE-DATA PROPS
         (MODULE-NAME MODULE)
         (MODULE-INPUTS MODULE)
         (MARK-IO-OUTS (MODULE-OUTPUTS MODULE)
                       (INTERSECTION (MODULE-INPUTS MODULE)
                                     (MODULE-OUTPUTS MODULE)))
         (MODULE-STATENAMES MODULE)
         (OCCURRENCE-DATA PROPS
                          (MODULE-OCCURRENCES MODULE)
                          (MODULE-INPUTS MODULE)
                          (MARK-IO-OUTS (MODULE-OUTPUTS MODULE)
                                        (INTERSECTION (MODULE-INPUTS MODULE)
                                                      (MODULE-OUTPUTS MODULE)))
                          (INTERSECTION (MODULE-INPUTS MODULE)
                                        (MODULE-OUTPUTS MODULE))
                          DATABASE)
         APPROXIMATE-DELAYS-P))

(TOGGLE MODULE-DATA-OFF MODULE-DATA T)

(DEFN MODULE-DATABASE
      (NETLIST PROPS APPROXIMATE-DELAYS-P)
      (IF (LISTP NETLIST)
          (CONS (MODULE-DATA (CAR NETLIST)
                             PROPS
                             (MODULE-DATABASE (CDR NETLIST)
                                              PROPS APPROXIMATE-DELAYS-P)
                             APPROXIMATE-DELAYS-P)
                (MODULE-DATABASE (CDR NETLIST)
                                 PROPS APPROXIMATE-DELAYS-P))
          NIL))

(TOGGLE MODULE-DATABASE-OFF MODULE-DATABASE T)

(DEFN REQUIRED-FOR-PROP
      (PROP)
      (CASE PROP
            (DELAYS '(DELAYS LOADINGS DRIVES INPUT-TYPES OUTPUT-TYPES INPUTS
                             OUTPUTS TRI-STATE-DATA))
            (DRIVES '(DRIVES LOADINGS INPUT-TYPES OUTPUT-TYPES INPUTS OUTPUTS
                             TRI-STATE-DATA))
            (INPUT-TYPES '(INPUT-TYPES OUTPUT-TYPES INPUTS OUTPUTS
                                       TRI-STATE-DATA))
            (LOADINGS '(LOADINGS DRIVES INPUT-TYPES OUTPUT-TYPES INPUTS
                                 OUTPUTS TRI-STATE-DATA))
            (OUT-DEPENDS '(OUT-DEPENDS INPUTS OUTPUTS))
            (OUTPUT-TYPES '(OUTPUT-TYPES INPUT-TYPES INPUTS OUTPUTS
                                         TRI-STATE-DATA))
            (OTHERWISE (IF (MEMBER PROP (ALL-MODULE-PROPS))
                           (LIST PROP)
                           NIL))))

(TOGGLE REQUIRED-FOR-PROP-OFF REQUIRED-FOR-PROP T)

(DEFN GET-REQUIRED-PROPS
      (PROPS WANTED-PROPS)
      (IF (LISTP PROPS)
          (UNION (REQUIRED-FOR-PROP (CAR PROPS))
                 (GET-REQUIRED-PROPS (CDR PROPS)
                                     WANTED-PROPS))
          WANTED-PROPS))

(TOGGLE GET-REQUIRED-PROPS-OFF GET-REQUIRED-PROPS T)

(DEFN REQUIRED-PROPS
      (PROPS)
      (GET-REQUIRED-PROPS PROPS PROPS))

(TOGGLE REQUIRED-PROPS-OFF REQUIRED-PROPS T)

(DEFN UNBIND-NETLIST-PROPS-0
      (PROPS DATABASE)
      (IF (LISTP DATABASE)
          (CONS (CONS (CAAR DATABASE)
                      (IF (NET-ERRORP (CADAR DATABASE))
                          (CONS (CADAR DATABASE)
                                (UNBIND-LIST PROPS (CDDAR DATABASE)))
                          (UNBIND-LIST PROPS (CDAR DATABASE))))
                (UNBIND-NETLIST-PROPS-0 PROPS
                                        (CDR DATABASE)))
          NIL))

(TOGGLE UNBIND-NETLIST-PROPS-0-OFF UNBIND-NETLIST-PROPS-0 T)

(DEFN UNBIND-NETLIST-PROPS
      (PROPS DATABASE)
      (IF (LISTP PROPS)
          (UNBIND-NETLIST-PROPS-0 (REVERSE PROPS)
                                  DATABASE)
          DATABASE))

(TOGGLE UNBIND-NETLIST-PROPS-OFF UNBIND-NETLIST-PROPS T)

(DEFN NETLIST-PROPERTIES
 (NETLIST PROPS APPROXIMATE-DELAYS-P)
 (COND
     ((NET-ERRORP (SUBSET-OR-ERR PROPS
                                 (ALL-MODULE-PROPS)
                                 'UNKNOWN-PROPERTIES))
      (SUBSET-OR-ERR PROPS
                     (ALL-MODULE-PROPS)
                     'UNKNOWN-PROPERTIES))
     ((LISTP (COLLECT-NET-ERRORS (MODULE-DATABASE NETLIST
                                                  (REQUIRED-PROPS PROPS)
                                                  APPROXIMATE-DELAYS-P)))
      (PRED-ERROR 'NETLIST-ERRORS
                  (COLLECT-NET-ERRORS (MODULE-DATABASE NETLIST
                                                       (REQUIRED-PROPS PROPS)
                                                       APPROXIMATE-DELAYS-P))))
     (T (UNBIND-NETLIST-PROPS (SET-DIFF (REQUIRED-PROPS PROPS)
                                        PROPS)
                              (MODULE-DATABASE NETLIST
                                               (REQUIRED-PROPS PROPS)
                                               APPROXIMATE-DELAYS-P)))))

(TOGGLE NETLIST-PROPERTIES-OFF NETLIST-PROPERTIES T)

(DEFN NETLIST-DATABASE
     (NETLIST APPROXIMATE-DELAYS-P)
     (UNBIND-NETLIST-PROPS (SET-DIFF (REQUIRED-PROPS (ALL-MODULE-PROPS))
                                     (ALL-MODULE-PROPS))
                           (MODULE-DATABASE NETLIST
                                            (REQUIRED-PROPS (ALL-MODULE-PROPS))
                                            APPROXIMATE-DELAYS-P)))

(TOGGLE NETLIST-DATABASE-OFF NETLIST-DATABASE T)

(DEFN PREDICATE-PROPERTIES NIL
      '(DRIVES INPUT-TYPES LOADINGS OUT-DEPENDS OUTPUT-TYPES STATE-TYPES))

(TOGGLE PREDICATE-PROPERTIES-OFF PREDICATE-PROPERTIES T)

(TOGGLE G*1*PREDICATE-PROPERTIES-OFF *1*PREDICATE-PROPERTIES T)

(DEFN TOP-LEVEL-PREDICATE
      (NETLIST)
      (COND ((NET-ERRORP (NETLIST-SYNTAX-OK NETLIST))
             (NETLIST-SYNTAX-OK NETLIST))
            ((NET-ERRORP (NETLIST-PROPERTIES NETLIST
                                             (PREDICATE-PROPERTIES)
                                             T))
             (NETLIST-PROPERTIES NETLIST
                                 (PREDICATE-PROPERTIES)
                                 T))
            (T T)))

(TOGGLE TOP-LEVEL-PREDICATE-OFF TOP-LEVEL-PREDICATE T)

(DEFN LSI-TOP-LEVEL-PREDICATE
      (NETLIST TOKEN-SIZE MAX-HIERARCHICAL-NAME-LENGTH)
      (COND ((NET-ERRORP (LSI-NETLIST-SYNTAX-OK NETLIST TOKEN-SIZE
                                                MAX-HIERARCHICAL-NAME-LENGTH))
             (LSI-NETLIST-SYNTAX-OK NETLIST TOKEN-SIZE
                                    MAX-HIERARCHICAL-NAME-LENGTH))
            ((NET-ERRORP (NETLIST-PROPERTIES NETLIST
                                             (PREDICATE-PROPERTIES)
                                             T))
             (NETLIST-PROPERTIES NETLIST
                                 (PREDICATE-PROPERTIES)
                                 T))
            (T T)))

(TOGGLE LSI-TOP-LEVEL-PREDICATE-OFF LSI-TOP-LEVEL-PREDICATE T)

(DEFN PNAME-LISTP
      (X)
      (IF (LISTP X)
          (AND (NAME-OKP (CAR X))
               (NOT (MEMBER (CAR X) (CDR X)))
               (PNAME-LISTP (CDR X)))
          (EQUAL X NIL)))

(TOGGLE PNAME-LISTP-OFF PNAME-LISTP T)

(DEFN FUNCTION-CALL-OK
      (X NUMBER-OF-ARGS)
      (IF (AND (LISTP X) (LITATOM (CAR X)))
          (IF (PROPERP X)
              (IF (NUMBERP NUMBER-OF-ARGS)
                  (T-OR-ERR (EQUAL (LENGTH (CDR X))
                                   NUMBER-OF-ARGS)
                            (CONS 'FUNCTION
                                  (CONS (CAR X)
                                        (CONS 'HAS
                                              (CONS NUMBER-OF-ARGS '(ARGS)))))
                            (LIST 'IT
                                  'IS
                                  'GIVEN
                                  (LENGTH (CDR X))
                                  'IN
                                  X))
                  T)
              (PRED-ERROR 'ILL-FORMED-FUNCTION-CALL
                          X))
          (PRED-ERROR 'NOT-FUNCTION-CALL X)))

(TOGGLE FUNCTION-CALL-OK-OFF FUNCTION-CALL-OK T)

(DEFN IO-LABEL
      (ARG WHAT)
      (IF (NUMBERP ARG)
          (LIST 'UNKNOWN WHAT ARG)
          (LIST WHAT ARG)))

(TOGGLE IO-LABEL-OFF IO-LABEL T)

(DEFN INPUT-LABEL
      (INPUT)
      (IO-LABEL INPUT 'INPUT))

(TOGGLE INPUT-LABEL-OFF INPUT-LABEL T)

(DEFN OUTPUT-LABEL
      (OUTPUT)
      (IO-LABEL OUTPUT 'OUTPUT))

(TOGGLE OUTPUT-LABEL-OFF OUTPUT-LABEL T)

(DEFN STATE-LABEL
      (STATE)
      (IO-LABEL STATE 'STATE))

(TOGGLE STATE-LABEL-OFF STATE-LABEL T)

(DEFN UCAR
      (X)
      (IF (LISTP X) (CAR X) (UNKNOWN)))

(TOGGLE UCAR-OFF UCAR T)

(DEFN UCDR
      (X)
      (IF (LISTP X) (CDR X) (UNKNOWN)))

(TOGGLE UCDR-OFF UCDR T)

(DEFN IO-CAR
      (ARGS)
      (COND ((LISTP ARGS) (CAR ARGS))
            ((NUMBERP ARGS) ARGS)
            (T 1)))

(TOGGLE IO-CAR-OFF IO-CAR T)

(DEFN IO-CDR
      (ARGS)
      (COND ((NUMBERP ARGS) (ADD1 ARGS))
            ((NLISTP ARGS) 2)
            ((NUMBERP (CDR ARGS)) NIL)
            (T (CDR ARGS))))

(TOGGLE IO-CDR-OFF IO-CDR T)

(DEFN OUT-PROP-SIGNALS
      (OUT-DEPENDS INPUTS)
      (IF (UNKNOWNP OUT-DEPENDS)
          INPUTS OUT-DEPENDS))

(TOGGLE OUT-PROP-SIGNALS-OFF OUT-PROP-SIGNALS T)

(DEFN ID-OUT-PROP-SIGNALS
      (OUTPUT-TYPE OUT-DEPENDS INPUTS)
      (IF (LISTP OUTPUT-TYPE)
          OUTPUT-TYPE
          (OUT-PROP-SIGNALS OUT-DEPENDS INPUTS)))

(TOGGLE ID-OUT-PROP-SIGNALS-OFF ID-OUT-PROP-SIGNALS T)

(DEFN ALL-INPUT-TYPES NIL
      '(BOOLP CLK FREE LEVEL PARAMETRIC TRI-STATE TTL TTL-TRI-STATE))

(TOGGLE ALL-INPUT-TYPES-OFF ALL-INPUT-TYPES T)

(TOGGLE G*1*ALL-INPUT-TYPES-OFF *1*ALL-INPUT-TYPES T)

(DEFN ALL-OUTPUT-TYPES
      (INPUTS)
      (APPEND (LISTIFY INPUTS)
              (DELETE* 'FREE (ALL-INPUT-TYPES))))

(TOGGLE ALL-OUTPUT-TYPES-OFF ALL-OUTPUT-TYPES T)

(DEFN PIN-TYPE-OK
      (TYPE INPUT IO-SIGNALS FNAME)
      (LABEL-ERROR (COND ((EQUAL FNAME 'T-WIRE)
                          (T-OR-ERR (EQUAL TYPE 'TRI-STATE)
                                    'T-WIRE-INPUT-TYPE-NOT-TRI-STATE
                                    TYPE))
                         ((MEMBER INPUT IO-SIGNALS)
                          (T-OR-ERR (TRI-STATE-TYPEP TYPE)
                                    'BAD-IO-SIGNAL-TYPE
                                    TYPE))
                         (T (T-OR-ERR (MEMBER TYPE (ALL-INPUT-TYPES))
                                      'UNKNOWN-TYPE
                                      TYPE)))
                   (INPUT-LABEL INPUT)))

(TOGGLE PIN-TYPE-OK-OFF PIN-TYPE-OK T)

(DEFN PIN-TYPE-ERRORS
      (TYPES INPUTS IO-SIGNALS FNAME)
      (IF (LISTP TYPES)
          (CONS (T-OR-ERR (OR (LISTP INPUTS) (NUMBERP INPUTS))
                          'TOO-MANY-INPUT-TYPES
                          (CONS (LENGTH TYPES) '(EXTRAS)))
                (CONS (PIN-TYPE-OK (CAR TYPES)
                                   (IO-CAR INPUTS)
                                   IO-SIGNALS FNAME)
                      (PIN-TYPE-ERRORS (CDR TYPES)
                                       (IO-CDR INPUTS)
                                       IO-SIGNALS FNAME)))
          (LIST (NIL-OR-ERR TYPES 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR INPUTS 'INPUTS-WITHOUT-TYPES))))

(TOGGLE PIN-TYPE-ERRORS-OFF PIN-TYPE-ERRORS T)

(DEFN PIN-TYPES-OK
      (IN-TYPES ALIST)
      (ERR-AND (PIN-TYPE-ERRORS IN-TYPES
                                (IF (UNKNOWNP (VALUE 'INPUTS ALIST))
                                    1
                                    (VALUE 'INPUTS ALIST))
                                (INTERSECTION (VALUE 'INPUTS ALIST)
                                              (VALUE 'OUTPUTS ALIST))
                                (VALUE 'PRIMP-NAME ALIST))
               'INPUT-TYPES))

(TOGGLE PIN-TYPES-OK-OFF PIN-TYPES-OK T)

(DEFN POUT-TYPE-OK
 (TYPE OUTPUT OUT-DEPENDS INPUTS IO-SIGNALS FNAME IN-TYPE-MAP)
 (LABEL-ERROR
    (COND ((EQUAL FNAME 'T-WIRE)
           (T-OR-ERR (EQUAL TYPE 'TRI-STATE)
                     'T-WIRE-OUTPUT-TYPE-NOT-TRI-STATE
                     TYPE))
          ((MEMBER OUTPUT IO-SIGNALS)
           (IF (TRI-STATE-TYPEP TYPE)
               (T-OR-ERR (OR (NOT (TRI-STATE-TYPEP (VALUE OUTPUT IN-TYPE-MAP)))
                             (EQUAL TYPE
                                    (VALUE OUTPUT IN-TYPE-MAP)))
                         'DIFFERENT-IO-SIGNAL-IN-AND-OUT-TYPES
                         (LIST (LIST 'INPUT-TYPE
                                     (VALUE OUTPUT IN-TYPE-MAP))
                               (LIST 'OUTPUT-TYPE TYPE)))
               (PRED-ERROR 'BAD-IO-SIGNAL-TYPE
                           TYPE)))
          ((LISTP TYPE)
           (T-OR-ERR (AND (PROPERP TYPE)
                          (EQUAL (LENGTH TYPE) 1)
                          (IF (UNKNOWNP (OUT-PROP-SIGNALS OUT-DEPENDS INPUTS))
                              (NAME-OKP (CAR TYPE))
                              (MEMBER (CAR TYPE)
                                      (OUT-PROP-SIGNALS OUT-DEPENDS INPUTS))))
                     'UNKNOWN-TYPE
                     TYPE))
          (T (T-OR-ERR (MEMBER TYPE (ALL-OUTPUT-TYPES NIL))
                       'UNKNOWN-TYPE
                       TYPE)))
    (OUTPUT-LABEL OUTPUT)))

(TOGGLE POUT-TYPE-OK-OFF POUT-TYPE-OK T)

(DEFN POUT-TYPE-ERRORS
      (TYPES OUTPUTS OUT-DEPENDS INPUTS IO-SIGNALS FNAME IN-TYPE-MAP)
      (IF (LISTP TYPES)
          (CONS (T-OR-ERR (OR (LISTP OUTPUTS) (NUMBERP OUTPUTS))
                          'TOO-MANY-OUTPUT-TYPES
                          (CONS (LENGTH TYPES) '(EXTRAS)))
                (CONS (POUT-TYPE-OK (CAR TYPES)
                                    (IO-CAR OUTPUTS)
                                    (UCAR OUT-DEPENDS)
                                    INPUTS IO-SIGNALS FNAME IN-TYPE-MAP)
                      (POUT-TYPE-ERRORS (CDR TYPES)
                                        (IO-CDR OUTPUTS)
                                        (UCDR OUT-DEPENDS)
                                        INPUTS IO-SIGNALS FNAME IN-TYPE-MAP)))
          (LIST (NIL-OR-ERR TYPES 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR OUTPUTS 'OUTPUTS-WITHOUT-TYPES))))

(TOGGLE POUT-TYPE-ERRORS-OFF POUT-TYPE-ERRORS T)

(DEFN POUT-TYPES-OK
      (OUT-TYPES ALIST)
      (ERR-AND (POUT-TYPE-ERRORS OUT-TYPES
                                 (IF (UNKNOWNP (VALUE 'OUTPUTS ALIST))
                                     1
                                     (VALUE 'OUTPUTS ALIST))
                                 (VALUE 'OUT-DEPENDS ALIST)
                                 (VALUE 'INPUTS ALIST)
                                 (INTERSECTION (VALUE 'INPUTS ALIST)
                                               (VALUE 'OUTPUTS ALIST))
                                 (VALUE 'PRIMP-NAME ALIST)
                                 (PAIRLIST (VALUE 'INPUTS ALIST)
                                           (VALUE 'INPUT-TYPES ALIST)))
               'OUTPUT-TYPES))

(TOGGLE POUT-TYPES-OK-OFF POUT-TYPES-OK T)

(DEFN P-NAME-PROP-VALUE-OK
      (NAME OUT-TYPE OUT-DEPENDS INPUTS LABEL)
      (T-OR-ERR (IF (UNKNOWNP (ID-OUT-PROP-SIGNALS OUT-TYPE OUT-DEPENDS
                                                   INPUTS))
                    (NAME-OKP NAME)
                    (MEMBER NAME
                            (ID-OUT-PROP-SIGNALS OUT-TYPE OUT-DEPENDS INPUTS)))
                LABEL NAME))

(TOGGLE P-NAME-PROP-VALUE-OK-OFF P-NAME-PROP-VALUE-OK T)

(DEFN P-T-WIRE-ARGS-OK
      (ARGS OUT-DEPENDS INPUTS LABEL)
      (ERR-AND (IF (UNKNOWNP (OUT-PROP-SIGNALS OUT-DEPENDS INPUTS))
                   (LIST (NAME-LIST-OK ARGS 'ILL-FORMED-ARGS
                                       F))
                   (LIST (SUBSET-OR-ERR ARGS
                                        (OUT-PROP-SIGNALS OUT-DEPENDS INPUTS)
                                        'UNKNOWN-ARGS)
                         (NO-DUPLICATES-OR-ERR ARGS 'DUPLICATE-ARGS)
                         (NIL-OR-ERR (LAST-CDR ARGS)
                                     'NOT-PROPER-LIST)))
               LABEL))

(TOGGLE P-T-WIRE-ARGS-OK-OFF P-T-WIRE-ARGS-OK T)

(DEFN PHALF-DELAY-OK
      (D TYPE LABEL)
      (IF (EQUAL (LENGTH D) 2)
          (ERR-AND (LIST (COND ((MEMBER TYPE
                                        '(BOOLP CLK LEVEL PARAMETRIC
                                                TRI-STATE))
                                (T-OR-ERR (NUMBERP (CAR D))
                                          'SLOPE-NOT-NUMBER
                                          (LIST (LIST 'SLOPE (CAR D))
                                                (LIST 'OUTPUT-TYPE TYPE))))
                               ((MEMBER TYPE '(TTL TTL-TRI-STATE))
                                (T-OR-ERR (PS-PFP (CAR D))
                                          'SLOPE-NOT-PS-PF
                                          (LIST (LIST 'SLOPE (CAR D))
                                                (LIST 'OUTPUT-TYPE TYPE))))
                               (T (T-OR-ERR (OR (NUMBERP (CAR D))
                                                (PS-PFP (CAR D)))
                                            'SLOPE-NOT-NUMBER-OR-PS-PF
                                            (CAR D))))
                         (T-OR-ERR (NUMBERP (CADR D))
                                   'INTERCEPT-NOT-NUMBER
                                   (CADR D))
                         (NIL-OR-ERR (LAST-CDR D)
                                     'NOT-PROPER-LIST))
                   LABEL)
          (PRED-ERROR LABEL
                      (LIST 'LENGTH-NOT-2 D))))

(TOGGLE PHALF-DELAY-OK-OFF PHALF-DELAY-OK T)

(DEFN PDELAY-OK
     (DELAY OUTPUT TYPE OUT-DEPENDS INPUTS)
     (LABEL-ERROR (COND ((OR (LITATOM DELAY) (INDEXP DELAY))
                         (P-NAME-PROP-VALUE-OK DELAY TYPE OUT-DEPENDS INPUTS
                                               'UNKNOWN-DELAY))
                        ((AND (LISTP DELAY)
                              (EQUAL (CAR DELAY) 'OR))
                         (P-T-WIRE-ARGS-OK (CDR DELAY)
                                           OUT-DEPENDS INPUTS
                                           'BAD-OR-DELAY))
                        ((EQUAL (LENGTH DELAY) 2)
                         (ERR-AND (LIST (NLISTP-OR-ERR TYPE
                                                       'EXPECTED-LITERAL-TYPE)
                                        (PHALF-DELAY-OK (CAR DELAY)
                                                        TYPE
                                                        'LOW-TO-HIGH)
                                        (PHALF-DELAY-OK (CADR DELAY)
                                                        TYPE
                                                        'HIGH-TO-LOW)
                                        (NIL-OR-ERR (LAST-CDR DELAY)
                                                    'NOT-PROPER-LIST))
                                  'BAD-LITERAL-DELAY))
                        (T (PRED-ERROR 'UNKNOWN-DELAY DELAY)))
                  (OUTPUT-LABEL OUTPUT)))

(TOGGLE PDELAY-OK-OFF PDELAY-OK T)

(DEFN PDELAYS-ERRORS
      (DELAYS OUTPUTS TYPES OUT-DEPENDS INPUTS)
      (IF (LISTP DELAYS)
          (CONS (T-OR-ERR (OR (LISTP OUTPUTS) (NUMBERP OUTPUTS))
                          'TOO-MANY-DELAYS
                          (CONS (LENGTH DELAYS) '(EXTRAS)))
                (CONS (PDELAY-OK (CAR DELAYS)
                                 (IO-CAR OUTPUTS)
                                 (UCAR TYPES)
                                 (UCAR OUT-DEPENDS)
                                 INPUTS)
                      (PDELAYS-ERRORS (CDR DELAYS)
                                      (IO-CDR OUTPUTS)
                                      (UCDR TYPES)
                                      (UCDR OUT-DEPENDS)
                                      INPUTS)))
          (LIST (NIL-OR-ERR DELAYS 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR OUTPUTS 'OUTPUTS-WITHOUT-DELAYS))))

(TOGGLE PDELAYS-ERRORS-OFF PDELAYS-ERRORS T)

(DEFN PDELAYS-OK
      (DELAYS ALIST)
      (ERR-AND (PDELAYS-ERRORS DELAYS
                               (IF (UNKNOWNP (VALUE 'OUTPUTS ALIST))
                                   1
                                   (VALUE 'OUTPUTS ALIST))
                               (VALUE 'OUTPUT-TYPES ALIST)
                               (VALUE 'OUT-DEPENDS ALIST)
                               (VALUE 'INPUTS ALIST))
               'DELAYS))

(TOGGLE PDELAYS-OK-OFF PDELAYS-OK T)

(DEFN PDRIVE-OK
      (DRIVE OUTPUT TYPE OUT-DEPENDS INPUTS)
      (LABEL-ERROR (COND ((OR (LITATOM DRIVE) (INDEXP DRIVE))
                          (P-NAME-PROP-VALUE-OK DRIVE TYPE OUT-DEPENDS INPUTS
                                                'UNKNOWN-DRIVE))
                         ((AND (LISTP DRIVE)
                               (EQUAL (CAR DRIVE) 'MIN))
                          (P-T-WIRE-ARGS-OK (CDR DRIVE)
                                            OUT-DEPENDS INPUTS
                                            'BAD-MIN-DRIVE))
                         ((MEMBER TYPE
                                  '(BOOLP CLK LEVEL PARAMETRIC TRI-STATE))
                          (T-OR-ERR (NUMBERP DRIVE)
                                    'BAD-DRIVE
                                    (LIST (LIST 'DRIVE DRIVE)
                                          (LIST 'TYPE TYPE))))
                         ((MEMBER TYPE '(TTL TTL-TRI-STATE))
                          (T-OR-ERR (MAP DRIVE)
                                    'BAD-DRIVE
                                    (LIST (LIST 'DRIVE DRIVE)
                                          (LIST 'TYPE TYPE))))
                         ((OR (NUMBERP DRIVE) (MAP DRIVE))
                          (T-OR-ERR (NLISTP TYPE)
                                    'EXPECTED-LITERAL-TYPE
                                    (LIST (LIST 'DRIVE DRIVE)
                                          (LIST 'TYPE TYPE))))
                         (T (PRED-ERROR 'UNKNOWN-DRIVE DRIVE)))
                   (OUTPUT-LABEL OUTPUT)))

(TOGGLE PDRIVE-OK-OFF PDRIVE-OK T)

(DEFN PDRIVES-ERRORS
      (DRIVES OUTPUTS TYPES OUT-DEPENDS INPUTS)
      (IF (LISTP DRIVES)
          (CONS (T-OR-ERR (OR (LISTP OUTPUTS) (NUMBERP OUTPUTS))
                          'TOO-MANY-DRIVES
                          (CONS (LENGTH DRIVES) '(EXTRAS)))
                (CONS (PDRIVE-OK (CAR DRIVES)
                                 (IO-CAR OUTPUTS)
                                 (UCAR TYPES)
                                 (UCAR OUT-DEPENDS)
                                 INPUTS)
                      (PDRIVES-ERRORS (CDR DRIVES)
                                      (IO-CDR OUTPUTS)
                                      (UCDR TYPES)
                                      (UCDR OUT-DEPENDS)
                                      INPUTS)))
          (LIST (NIL-OR-ERR DRIVES 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR OUTPUTS 'OUTPUTS-WITHOUT-DRIVES))))

(TOGGLE PDRIVES-ERRORS-OFF PDRIVES-ERRORS T)

(DEFN PDRIVES-OK
      (DRIVES ALIST)
      (ERR-AND (PDRIVES-ERRORS DRIVES
                               (IF (UNKNOWNP (VALUE 'OUTPUTS ALIST))
                                   1
                                   (VALUE 'OUTPUTS ALIST))
                               (VALUE 'OUTPUT-TYPES ALIST)
                               (VALUE 'OUT-DEPENDS ALIST)
                               (VALUE 'INPUTS ALIST))
               'DRIVES))

(TOGGLE PDRIVES-OK-OFF PDRIVES-OK T)

(DEFN PLOADING-OK
      (LOADING INPUT TYPE)
      (LABEL-ERROR (T-OR-ERR (COND ((MEMBER TYPE
                                            '(BOOLP CLK FREE LEVEL PARAMETRIC
                                                    TRI-STATE))
                                    (NUMBERP LOADING))
                                   ((MEMBER TYPE '(TTL TTL-TRI-STATE))
                                    (PFP LOADING))
                                   (T (OR (NUMBERP LOADING) (PFP LOADING))))
                             'BAD-LOADING
                             (LIST (LIST 'LOADING LOADING)
                                   (LIST 'INPUT-TYPE TYPE)))
                   (INPUT-LABEL INPUT)))

(TOGGLE PLOADING-OK-OFF PLOADING-OK T)

(DEFN PLOADINGS-ERRORS
      (LOADINGS INPUTS TYPES)
      (IF (LISTP LOADINGS)
          (CONS (T-OR-ERR (OR (LISTP INPUTS) (NUMBERP INPUTS))
                          'TOO-MANY-LOADINGS
                          (CONS (LENGTH LOADINGS) '(EXTRAS)))
                (CONS (PLOADING-OK (CAR LOADINGS)
                                   (IO-CAR INPUTS)
                                   (UCAR TYPES))
                      (PLOADINGS-ERRORS (CDR LOADINGS)
                                        (IO-CDR INPUTS)
                                        (UCDR TYPES))))
          (LIST (NIL-OR-ERR LOADINGS 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR INPUTS 'INPUTS-WITHOUT-LOADINGS))))

(TOGGLE PLOADINGS-ERRORS-OFF PLOADINGS-ERRORS T)

(DEFN PLOADINGS-OK
      (LOADINGS ALIST)
      (ERR-AND (PLOADINGS-ERRORS LOADINGS
                                 (IF (UNKNOWNP (VALUE 'INPUTS ALIST))
                                     1
                                     (VALUE 'INPUTS ALIST))
                                 (VALUE 'INPUT-TYPES ALIST))
               'LOADINGS))

(TOGGLE PLOADINGS-OK-OFF PLOADINGS-OK T)

(DEFN PLSI-NAME-OK
 (LSI-NAME-ENTRY ALIST)
 (ERR-AND
    (LIST (LSI-NAME-OK (IF (LISTP LSI-NAME-ENTRY)
                           (CAR LSI-NAME-ENTRY)
                           LSI-NAME-ENTRY)
                       64)
          (IF (OR (NLISTP LSI-NAME-ENTRY)
                  (UNKNOWNP (VALUE 'INPUTS ALIST)))
              T
              (T-OR-ERR (SET-EQUAL (CDR LSI-NAME-ENTRY)
                                   (VALUE 'INPUTS ALIST))
                        'INPUT-CONFLICT
                        (LIST (LIST 'INPUTS (VALUE 'INPUTS ALIST))
                              (LIST 'LSI-INPUTS
                                    (CDR LSI-NAME-ENTRY)))))
          (IF (OR (UNKNOWNP (VALUE 'INPUTS ALIST))
                  (UNKNOWNP (VALUE 'OUTPUTS ALIST)))
              T
              (T-OR-ERR (EQUAL (LISTP (INTERSECTION (VALUE 'INPUTS ALIST)
                                                    (VALUE 'OUTPUTS ALIST)))
                               (IS-HEAD (UNPACK 'BD)
                                        (UNPACK (IF (LISTP LSI-NAME-ENTRY)
                                                    (CAR LSI-NAME-ENTRY)
                                                    LSI-NAME-ENTRY))))
                        'BIDIRECT-CONFLICT
                        (LIST (LIST 'LSI-NAME
                                    (IF (LISTP LSI-NAME-ENTRY)
                                        (CAR LSI-NAME-ENTRY)
                                        LSI-NAME-ENTRY))
                              (LIST 'IO-SIGNALS
                                    (INTERSECTION (VALUE 'INPUTS ALIST)
                                                  (VALUE 'OUTPUTS ALIST)))))))
    'LSI-NAME))

(TOGGLE PLSI-NAME-OK-OFF PLSI-NAME-OK T)

(DEFN POUT-DEPENDS-ONE-OK
      (OUT-DEPENDS OUTPUT INPUTS)
      (IF (UNKNOWNP INPUTS)
          (NAME-LIST-OK OUT-DEPENDS
                        (OUTPUT-LABEL OUTPUT)
                        F)
          (ERR-AND (LIST (SUBSET-OR-ERR OUT-DEPENDS INPUTS
                                        'UNKNOWN-OUTPUT-DEPENDENCIES)
                         (NO-DUPLICATES-OR-ERR OUT-DEPENDS 'DUPLICATES)
                         (NIL-OR-ERR (LAST-CDR OUT-DEPENDS)
                                     'NOT-PROPER-LIST))
                   (OUTPUT-LABEL OUTPUT))))

(TOGGLE POUT-DEPENDS-ONE-OK-OFF POUT-DEPENDS-ONE-OK T)

(DEFN POUT-DEPENDS-ERRORS
      (OUT-DEPENDS OUTPUTS INPUTS)
      (IF (LISTP OUT-DEPENDS)
          (CONS (T-OR-ERR (OR (LISTP OUTPUTS) (NUMBERP OUTPUTS))
                          'TOO-MANY-OUT-DEPENDS
                          (CONS (LENGTH OUT-DEPENDS) '(EXTRAS)))
                (CONS (POUT-DEPENDS-ONE-OK (CAR OUT-DEPENDS)
                                           (IO-CAR OUTPUTS)
                                           INPUTS)
                      (POUT-DEPENDS-ERRORS (CDR OUT-DEPENDS)
                                           (IO-CDR OUTPUTS)
                                           INPUTS)))
          (LIST (NIL-OR-ERR OUT-DEPENDS 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR OUTPUTS 'OUTPUTS-WITHOUT-OUT-DEPENDS))))

(TOGGLE POUT-DEPENDS-ERRORS-OFF POUT-DEPENDS-ERRORS T)

(DEFN POUT-DEPENDS-OK
      (OUT-DEPENDS ALIST)
      (ERR-AND (POUT-DEPENDS-ERRORS OUT-DEPENDS
                                    (IF (UNKNOWNP (VALUE 'OUTPUTS ALIST))
                                        1
                                        (VALUE 'OUTPUTS ALIST))
                                    (VALUE 'INPUTS ALIST))
               'OUT-DEPENDS))

(TOGGLE POUT-DEPENDS-OK-OFF POUT-DEPENDS-OK T)

(DEFN PSTATES-OK
      (STATES)
      (COND ((LISTP STATES)
             (ERR-AND (CONS (T-OR-ERR (LISTP (CDR STATES))
                                      'LIST-OF-LENGTH-1-NOT-ALLOWED
                                      STATES)
                            (NAME-LIST-ERRORS STATES F))
                      'STATES))
            ((EQUAL STATES NIL) T)
            (T (T-OR-ERR (NAME-OKP STATES)
                         'STATES
                         (LIST 'BAD-NAME STATES)))))

(TOGGLE PSTATES-OK-OFF PSTATES-OK T)

(DEFN ADDRESSED-STATE
      (ADDRESS-BITS WORD-VALUE)
      (IF (ZEROP ADDRESS-BITS)
          WORD-VALUE
          (CONS (ADDRESSED-STATE (SUB1 ADDRESS-BITS)
                                 WORD-VALUE)
                (ADDRESSED-STATE (SUB1 ADDRESS-BITS)
                                 WORD-VALUE))))

(TOGGLE ADDRESSED-STATE-OFF ADDRESSED-STATE T)

(DEFN BOOLP-LIST-OK
      (LST LABEL)
      (ERR-AND (LIST (NLISTP-OR-ERR (REMOVE-DUPLICATES (DELETE* 'BOOLP LST))
                                    'NOT-BOOLP)
                     (NIL-OR-ERR (LAST-CDR LST)
                                 'NOT-PROPER-LIST))
               LABEL))

(TOGGLE BOOLP-LIST-OK-OFF BOOLP-LIST-OK T)

(DEFN LITERAL-STATE-TYPE-OK
      (TYPE)
      (COND ((RAMP TYPE)
             (BOOLP-LIST-OK (RAM-GUTS TYPE)
                            'BAD-RAM-TYPE))
            ((ROMP TYPE)
             (BOOLP-LIST-OK (ROM-GUTS TYPE)
                            'BAD-ROM-TYPE))
            ((STUBP TYPE)
             (BOOLP-LIST-OK (STUB-GUTS TYPE)
                            'BAD-STUB-TYPE))
            (T (T-OR-ERR (EQUAL TYPE 'BOOLP)
                         'UNKNOWN-TYPE
                         TYPE))))

(TOGGLE LITERAL-STATE-TYPE-OK-OFF LITERAL-STATE-TYPE-OK T)

(DEFN PMEMORY-WORD-CALL-OK
     (TYPE)
     (IF (AND (LISTP TYPE)
              (MEMBER (CAR TYPE) '(RAM ROM STUB)))
         (IF (NET-ERRORP (FUNCTION-CALL-OK TYPE 1))
             (FUNCTION-CALL-OK TYPE 1)
             (LABEL-ERROR (IF (EQUAL (CAADR TYPE) 'QUOTE)
                              (IF (NET-ERRORP (FUNCTION-CALL-OK (CADR TYPE) 1))
                                  (FUNCTION-CALL-OK (CADR TYPE) 1)
                                  (BOOLP-LIST-OK (CADADR TYPE)
                                                 'BAD-MEMORY-BIT-TYPES))
                              (PRED-ERROR 'UNKNOWN-MEMORY-BITS-CALL
                                          (CADR TYPE)))
                          (CONS 'BAD
                                (CONS (CAR TYPE) '(CALL)))))
         (PRED-ERROR 'NOT-MEMORY-WORD-CALL
                     TYPE)))

(TOGGLE PMEMORY-WORD-CALL-OK-OFF PMEMORY-WORD-CALL-OK T)

(DEFN PADDRESSED-STATE-CALL-OK
      (TYPE)
      (IF (AND (LISTP TYPE)
               (EQUAL (CAR TYPE) 'ADDRESSED-STATE))
          (IF (NET-ERRORP (FUNCTION-CALL-OK TYPE 2))
              (FUNCTION-CALL-OK TYPE 2)
              (ERR-AND (LIST (T-OR-ERR (NUMBERP (CADR TYPE))
                                       'ADDRESS-BITS-NOT-NUMBER
                                       (CADR TYPE))
                             (PMEMORY-WORD-CALL-OK (CADDR TYPE)))
                       '(BAD ADDRESSED-STATE CALL)))
          (PRED-ERROR 'NOT-ADDRESSED-STATE-CALL
                      TYPE)))

(TOGGLE PADDRESSED-STATE-CALL-OK-OFF PADDRESSED-STATE-CALL-OK T)

(DEFN ONE-PSTATE-TYPE-OK
      (TYPE)
      (COND ((NLISTP TYPE)
             (LITERAL-STATE-TYPE-OK TYPE))
            ((MEMBER (CAR TYPE) '(RAM ROM STUB))
             (PMEMORY-WORD-CALL-OK TYPE))
            ((EQUAL (CAR TYPE) 'ADDRESSED-STATE)
             (PADDRESSED-STATE-CALL-OK TYPE))
            (T (BOOLP-LIST-OK TYPE 'BAD-TYPE-LIST))))

(TOGGLE ONE-PSTATE-TYPE-OK-OFF ONE-PSTATE-TYPE-OK T)

(DEFN PSTATE-TYPE-LIST-ERRORS
      (TYPES FNAME)
      (IF (LISTP TYPES)
          (IF (AND (EQUAL FNAME 'MEM-32X32)
                   (MEMBER (CAR TYPES)
                           '(NUMBERP NUMBER-LISTP)))
              (PSTATE-TYPE-LIST-ERRORS (CDR TYPES)
                                       FNAME)
              (INSERT (ONE-PSTATE-TYPE-OK (CAR TYPES))
                      (PSTATE-TYPE-LIST-ERRORS (CDR TYPES)
                                               FNAME)))
          (LIST (NIL-OR-ERR TYPES 'NOT-PROPER-LIST))))

(TOGGLE PSTATE-TYPE-LIST-ERRORS-OFF PSTATE-TYPE-LIST-ERRORS T)

(DEFN PSTATE-TYPE-OK
      (TYPE STATE FNAME)
      (IF (OR (NLISTP TYPE)
              (MEMBER (CAR TYPE)
                      '(RAM ROM STUB ADDRESSED-STATE)))
          (LABEL-ERROR (ONE-PSTATE-TYPE-OK TYPE)
                       (STATE-LABEL STATE))
          (ERR-AND (PSTATE-TYPE-LIST-ERRORS TYPE FNAME)
                   (STATE-LABEL STATE))))

(TOGGLE PSTATE-TYPE-OK-OFF PSTATE-TYPE-OK T)

(DEFN PSTATE-TYPES-ERRORS
      (TYPES STATES FNAME)
      (IF (LISTP TYPES)
          (CONS (T-OR-ERR (OR (LISTP STATES) (NUMBERP STATES))
                          'TOO-MANY-STATE-TYPES
                          (CONS (LENGTH TYPES) '(EXTRAS)))
                (CONS (PSTATE-TYPE-OK (CAR TYPES)
                                      (IO-CAR STATES)
                                      FNAME)
                      (PSTATE-TYPES-ERRORS (CDR TYPES)
                                           (IO-CDR STATES)
                                           FNAME)))
          (LIST (NIL-OR-ERR TYPES 'NOT-PROPER-LIST)
                (NLISTP-OR-ERR STATES 'STATES-WITHOUT-TYPES))))

(TOGGLE PSTATE-TYPES-ERRORS-OFF PSTATE-TYPES-ERRORS T)

(DEFN PSTATE-TYPES-OK
      (STATE-TYPES ALIST)
      (ERR-AND (IF (OR (LISTP (VALUE 'STATES ALIST))
                       (EQUAL (VALUE 'STATES ALIST) NIL))
                   (PSTATE-TYPES-ERRORS STATE-TYPES
                                        (VALUE 'STATES ALIST)
                                        (VALUE 'PRIMP-NAME ALIST))
                   (LIST (PSTATE-TYPE-OK STATE-TYPES
                                         (VALUE 'STATES ALIST)
                                         (VALUE 'PRIMP-NAME ALIST))))
               'STATE-TYPES))

(TOGGLE PSTATE-TYPES-OK-OFF PSTATE-TYPES-OK T)

(DEFN UNKNOWN-ARGS
      (X SIGNALS STATES ARG-LISTP)
      (COND (ARG-LISTP (IF (LISTP X)
                           (UNION (UNKNOWN-ARGS (CAR X)
                                                SIGNALS STATES F)
                                  (UNKNOWN-ARGS (CDR X)
                                                SIGNALS STATES T))
                           NIL))
            ((NLISTP X)
             (COND ((OR (MEMBER X SIGNALS)
                        (MEMBER X STATES))
                    NIL)
                   ((OR (UNKNOWNP SIGNALS)
                        (UNKNOWNP STATES))
                    (IF (NAME-OKP X) NIL (LIST X)))
                   (T (LIST X))))
            ((EQUAL (CAR X) 'QUOTE) NIL)
            ((LITATOM (CAR X))
             (UNKNOWN-ARGS (CDR X)
                           SIGNALS STATES T))
            (T NIL)))

(TOGGLE UNKNOWN-ARGS-OFF UNKNOWN-ARGS T)

(DEFN PRESULT-FORM-ERRORS
     (X ARG-LISTP)
     (COND (ARG-LISTP (COND ((LISTP X)
                             (IF (NET-ERRORP (PRESULT-FORM-ERRORS (CAR X) F))
                                 (CONS (PRESULT-FORM-ERRORS (CAR X) F)
                                       (PRESULT-FORM-ERRORS (CDR X) T))
                                 (APPEND (PRESULT-FORM-ERRORS (CAR X) F)
                                         (PRESULT-FORM-ERRORS (CDR X) T))))
                            ((EQUAL X NIL) NIL)
                            (T (LIST (PRED-ERROR 'NOT-PROPER-LIST X)))))
           ((LISTP X)
            (COND ((NET-ERRORP (FUNCTION-CALL-OK X
                                                 (CASE (CAR X)
                                                       '1
                                                       (CONS 2)
                                                       (OTHERWISE (UNKNOWN)))))
                   (FUNCTION-CALL-OK X
                                     (CASE (CAR X)
                                           '1
                                           (CONS 2)
                                           (OTHERWISE (UNKNOWN)))))
                  ((EQUAL (CAR X) 'QUOTE) NIL)
                  (T (PRESULT-FORM-ERRORS (CDR X) T))))
           (T NIL)))

(TOGGLE PRESULT-FORM-ERRORS-OFF PRESULT-FORM-ERRORS T)

(DEFN PRESULT-OK
      (RESULT SIGNALS STATES LABEL)
      (ERR-AND (CONS (NLISTP-OR-ERR (UNKNOWN-ARGS RESULT SIGNALS STATES F)
                                    'UNKNOWN-ARGS)
                     (PRESULT-FORM-ERRORS (LIST RESULT) T))
               LABEL))

(TOGGLE PRESULT-OK-OFF PRESULT-OK T)

(DEFN RESULTS-LENGTH
      (X)
      (COND ((NLISTP X) 0)
            ((EQUAL (CAR X) 'CONS)
             (ADD1 (RESULTS-LENGTH (CADDR X))))
            (T 0)))

(TOGGLE RESULTS-LENGTH-OFF RESULTS-LENGTH T)

(DEFN PRESULTS-ERRORS
 (RESULTS OUTPUTS OUT-DEPENDS INPUTS STATES LABEL)
 (COND
     ((NLISTP RESULTS)
      (LIST (PRED-ERROR 'UNKNOWN-DUAL-EVAL-FORM
                        RESULTS)))
     ((EQUAL RESULTS ''NIL)
      (LIST (NLISTP-OR-ERR OUTPUTS
                           (CONS 'MISSING
                                 (CONS LABEL '(VALUES))))))
     ((EQUAL (CAR RESULTS) 'CONS)
      (IF (NET-ERRORP (FUNCTION-CALL-OK RESULTS 2))
          (LIST (FUNCTION-CALL-OK RESULTS 2))
          (CONS (T-OR-ERR (OR (LISTP OUTPUTS) (NUMBERP OUTPUTS))
                          'TOO-MANY-VALUES
                          (CONS (RESULTS-LENGTH RESULTS)
                                '(OR MORE EXTRAS)))
                (CONS (PRESULT-OK (CADR RESULTS)
                                  (OUT-PROP-SIGNALS (UCAR OUT-DEPENDS)
                                                    INPUTS)
                                  STATES
                                  (IO-LABEL (IO-CAR OUTPUTS) LABEL))
                      (PRESULTS-ERRORS (CADDR RESULTS)
                                       (IO-CDR OUTPUTS)
                                       (UCDR OUT-DEPENDS)
                                       INPUTS STATES LABEL)))))
     ((OR (LISTP OUTPUTS)
          (EQUAL OUTPUTS NIL))
      (LIST (PRED-ERROR (CONS 'EVALUATION
                              (CONS 'SHOULD
                                    (CONS 'RETURN
                                          (CONS (LENGTH OUTPUTS) '(RESULTS)))))
                        RESULTS)
            (PRESULT-OK RESULTS INPUTS STATES
                        (LIST LABEL 'LIST OUTPUTS))))
     (T (LIST (PRESULT-OK RESULTS INPUTS STATES 'UNKNOWN-OUTPUTS)))))

(TOGGLE PRESULTS-ERRORS-OFF PRESULTS-ERRORS T)

(DEFN PRESULTS-OK
      (RESULTS ALIST)
      (ERR-AND (PRESULTS-ERRORS RESULTS
                                (IF (UNKNOWNP (VALUE 'OUTPUTS ALIST))
                                    1
                                    (VALUE 'OUTPUTS ALIST))
                                (VALUE 'OUT-DEPENDS ALIST)
                                (VALUE 'INPUTS ALIST)
                                (IF (UNKNOWNP (VALUE 'STATES ALIST))
                                    (VALUE 'STATES ALIST)
                                    (M-STATES-LIST (VALUE 'STATES ALIST)))
                                'OUTPUT)
               'RESULTS))

(TOGGLE PRESULTS-OK-OFF PRESULTS-OK T)

(DEFN PNEW-STATES-OK
      (NEW-STATES ALIST)
      (ERR-AND (COND ((OR (LISTP (VALUE 'STATES ALIST))
                          (EQUAL (VALUE 'STATES ALIST) NIL))
                      (PRESULTS-ERRORS NEW-STATES
                                       (VALUE 'STATES ALIST)
                                       (UNKNOWN)
                                       (VALUE 'INPUTS ALIST)
                                       (VALUE 'STATES ALIST)
                                       'STATE))
                     ((OR (LITATOM (VALUE 'STATES ALIST))
                          (INDEXP (VALUE 'STATES ALIST)))
                      (LIST (PRESULT-OK NEW-STATES
                                        (VALUE 'INPUTS ALIST)
                                        (LIST (VALUE 'STATES ALIST))
                                        (STATE-LABEL (VALUE 'STATES ALIST)))))
                     (T (PRESULTS-ERRORS NEW-STATES 1
                                         (UNKNOWN)
                                         (VALUE 'INPUTS ALIST)
                                         (UNKNOWN)
                                         'STATE)))
               'NEW-STATES))

(TOGGLE PNEW-STATES-OK-OFF PNEW-STATES-OK T)

(DEFN PRIMITIVE-PROP-OK
      (PROP ALIST KEYS)
      (IF (LISTP PROP)
          (COND ((MEMBER (CAR PROP) KEYS)
                 (PRED-ERROR 'DUPLICATE-PROPERTY
                             PROP))
                ((EQUAL (CAR PROP) 'DELAYS)
                 (PDELAYS-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'DRIVES)
                 (PDRIVES-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'INPUT-TYPES)
                 (PIN-TYPES-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'INPUTS)
                 (NAME-LIST-OK (CDR PROP) 'INPUTS F))
                ((EQUAL (CAR PROP) 'LOADINGS)
                 (PLOADINGS-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'LSI-NAME)
                 (PLSI-NAME-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'NEW-STATES)
                 (PNEW-STATES-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'OUT-DEPENDS)
                 (POUT-DEPENDS-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'OUTPUT-TYPES)
                 (POUT-TYPES-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'OUTPUTS)
                 (NAME-LIST-OK (CDR PROP) 'OUTPUTS F))
                ((EQUAL (CAR PROP) 'RESULTS)
                 (PRESULTS-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'STATE-TYPES)
                 (PSTATE-TYPES-OK (CDR PROP) ALIST))
                ((EQUAL (CAR PROP) 'STATES)
                 (PSTATES-OK (CDR PROP)))
                ((MEMBER (CAR PROP)
                         '(GATES PADS PRIMITIVES TRANSISTORS))
                 (T-OR-ERR (NUMBERP (CDR PROP))
                           (CAR PROP)
                           (LIST 'VALUE-NOT-NUMBER (CDR PROP))))
                (T (PRED-ERROR 'UNKNOWN-PROPERTY
                               (CAR PROP))))
          (PRED-ERROR 'NOT-KEY-VALUE-PAIR
                      PROP)))

(TOGGLE PRIMITIVE-PROP-OK-OFF PRIMITIVE-PROP-OK T)

(DEFN PRIMITIVE-PROP-ERRORS
 (PROPS ALIST KEYS)
 (IF
  (LISTP PROPS)
  (CONS (PRIMITIVE-PROP-OK (CAR PROPS)
                           ALIST KEYS)
        (PRIMITIVE-PROP-ERRORS (CDR PROPS)
                               ALIST
                               (CONS (CAAR PROPS) KEYS)))
  (LIST
   (NLISTP-OR-ERR (DELETE* 'PADS
                           (IF (SUBSET '(NEW-STATES STATE-TYPES STATES)
                                       (SET-DIFF (PRIMITIVE-PROPERTIES)
                                                 KEYS))
                               (SET-DIFF (SET-DIFF (PRIMITIVE-PROPERTIES) KEYS)
                                         '(NEW-STATES STATE-TYPES STATES))
                               (SET-DIFF (PRIMITIVE-PROPERTIES)
                                         KEYS)))
                  'MISSING-PROPERTIES)
   (NIL-OR-ERR PROPS 'NOT-PROPER-LIST))))

(TOGGLE PRIMITIVE-PROP-ERRORS-OFF PRIMITIVE-PROP-ERRORS T)

(DEFN OK-NAME-LIST
      (PNAME PROPS)
      (IF (PNAME-LISTP (VALUE-OR-UNKNOWN PNAME PROPS))
          (VALUE-OR-UNKNOWN PNAME PROPS)
          (UNKNOWN)))

(TOGGLE OK-NAME-LIST-OFF OK-NAME-LIST T)

(DEFN OK-STATES
      (PROPS)
      (IF (BOUNDP 'STATES PROPS)
          (COND ((OR (LISTP (VALUE 'STATES PROPS))
                     (EQUAL (VALUE 'STATES PROPS) NIL))
                 (IF (PNAME-LISTP (VALUE 'STATES PROPS))
                     (VALUE 'STATES PROPS)
                     (UNKNOWN)))
                ((NAME-OKP (VALUE 'STATES PROPS))
                 (VALUE 'STATES PROPS))
                (T (UNKNOWN)))
          NIL))

(TOGGLE OK-STATES-OFF OK-STATES T)

(DEFN OK-OUT-DEPENDS
      (ODS INPUTS)
      (IF (LISTP ODS)
          (CONS (IF (AND (PNAME-LISTP (CAR ODS))
                         (OR (UNKNOWNP INPUTS)
                             (SUBSET (CAR ODS) INPUTS)))
                    (CAR ODS)
                    (UNKNOWN))
                (OK-OUT-DEPENDS (CDR ODS) INPUTS))
          NIL))

(TOGGLE OK-OUT-DEPENDS-OFF OK-OUT-DEPENDS T)

(DEFN OK-INPUT-TYPES
      (TYPES)
      (IF (LISTP TYPES)
          (CONS (IF (MEMBER (CAR TYPES) (ALL-INPUT-TYPES))
                    (CAR TYPES)
                    (UNKNOWN))
                (OK-INPUT-TYPES (CDR TYPES)))
          NIL))

(TOGGLE OK-INPUT-TYPES-OFF OK-INPUT-TYPES T)

(DEFN OK-OUTPUT-TYPES
      (OUT-TYPES OUT-DEPENDS INPUTS)
      (IF (LISTP OUT-TYPES)
          (CONS (IF (IF (LISTP (CAR OUT-TYPES))
                        (AND (PROPERP (CAR OUT-TYPES))
                             (EQUAL (LENGTH (CAR OUT-TYPES)) 1)
                             (IF (UNKNOWNP (OUT-PROP-SIGNALS (UCAR OUT-DEPENDS)
                                                             INPUTS))
                                 (NAME-OKP (CAAR OUT-TYPES))
                                 (MEMBER (CAAR OUT-TYPES)
                                         (OUT-PROP-SIGNALS (UCAR OUT-DEPENDS)
                                                           INPUTS))))
                        (MEMBER (CAR OUT-TYPES)
                                (ALL-OUTPUT-TYPES NIL)))
                    (CAR OUT-TYPES)
                    (UNKNOWN))
                (OK-OUTPUT-TYPES (CDR OUT-TYPES)
                                 (UCDR OUT-DEPENDS)
                                 INPUTS))
          NIL))

(TOGGLE OK-OUTPUT-TYPES-OFF OK-OUTPUT-TYPES T)

(DEFN PARENT-PROPS-ALIST
 (PRIMP-ENTRY)
 (LIST (CONS 'PRIMP-NAME (CAR PRIMP-ENTRY))
       (CONS 'INPUTS
             (OK-NAME-LIST 'INPUTS
                           (CDR PRIMP-ENTRY)))
       (CONS 'OUTPUTS
             (OK-NAME-LIST 'OUTPUTS
                           (CDR PRIMP-ENTRY)))
       (CONS 'STATES
             (OK-STATES (CDR PRIMP-ENTRY)))
       (CONS 'OUT-DEPENDS
             (OK-OUT-DEPENDS (VALUE 'OUT-DEPENDS
                                    (CDR PRIMP-ENTRY))
                             (OK-NAME-LIST 'INPUTS
                                           (CDR PRIMP-ENTRY))))
       (CONS 'INPUT-TYPES
             (OK-INPUT-TYPES (VALUE 'INPUT-TYPES
                                    (CDR PRIMP-ENTRY))))
       (CONS 'OUTPUT-TYPES
             (OK-OUTPUT-TYPES (VALUE 'OUTPUT-TYPES
                                     (CDR PRIMP-ENTRY))
                              (OK-OUT-DEPENDS (VALUE 'OUT-DEPENDS
                                                     (CDR PRIMP-ENTRY))
                                              (OK-NAME-LIST 'INPUTS
                                                            (CDR PRIMP-ENTRY)))
                              (OK-NAME-LIST 'INPUTS
                                            (CDR PRIMP-ENTRY))))))

(TOGGLE PARENT-PROPS-ALIST-OFF PARENT-PROPS-ALIST T)

(DEFN PRIMITIVE-OK
      (P)
      (IF (LISTP P)
          (ERR-AND (CONS (T-OR-ERR (NAME-OKP (CAR P))
                                   'BAD-PRIMITIVE-NAME
                                   (CAR P))
                         (PRIMITIVE-PROP-ERRORS (CDR P)
                                                (PARENT-PROPS-ALIST P)
                                                NIL))
                   (LIST 'PRIMITIVE (CAR P)))
          (PRED-ERROR 'NOT-A-PRIMITIVE P)))

(TOGGLE PRIMITIVE-OK-OFF PRIMITIVE-OK T)

(DEFN PRIMP-DATABASE-ERRORS
      (D)
      (IF (NLISTP D)
          NIL
          (CONS (PRIMITIVE-OK (CAR D))
                (PRIMP-DATABASE-ERRORS (CDR D)))))

(TOGGLE PRIMP-DATABASE-ERRORS-OFF PRIMP-DATABASE-ERRORS T)

(DEFN PRIMP-DATABASE-PREDICATE NIL
      (ERR-AND (PRIMP-DATABASE-ERRORS (PRIMP-DATABASE))
               'PRIMP-DATABASE-ERRORS))

(TOGGLE PRIMP-DATABASE-PREDICATE-OFF PRIMP-DATABASE-PREDICATE T)

(TOGGLE BOUNDP-ON BOUNDP NIL)

(DEFN SUBNET0
 (FLG X0 NETLIST USED-MODULES RESULT)
 (CASE FLG
       (0 (COND ((OR (LOOKUP-MODULE X0 RESULT)
                     (MEMBER X0 USED-MODULES))
                 RESULT)
                ((LISTP (LOOKUP-MODULE X0 NETLIST))
                 (CONS (LOOKUP-MODULE X0 NETLIST)
                       (SUBNET0 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                NETLIST
                                (CONS X0 USED-MODULES)
                                RESULT)))
                (T RESULT)))
       (1 (IF (NLISTP X0)
              RESULT
              (SUBNET0 1
                       (CDR X0)
                       NETLIST USED-MODULES
                       (SUBNET0 0
                                (OCC-FUNCTION (CAR X0))
                                NETLIST USED-MODULES RESULT))))
       (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT (UNBIND-LIST USED-MODULES NETLIST)))
                   (COUNT X0)))))

(TOGGLE BOUNDP-OFF1 BOUNDP T)

(TOGGLE SUBNET0-OFF SUBNET0 T)

(DEFN SUBNET
      (FLG X0 NETLIST)
      (SUBNET0 FLG X0 NETLIST NIL NIL))

(TOGGLE SUBNET-OFF SUBNET T)

(DEFN DELETE-NULL-ENTRIES
      (DATABASE)
      (IF (LISTP DATABASE)
          (IF (LISTP (CDAR DATABASE))
              (CONS (CAR DATABASE)
                    (DELETE-NULL-ENTRIES (CDR DATABASE)))
              (DELETE-NULL-ENTRIES (CDR DATABASE)))
          NIL))

(TOGGLE DELETE-NULL-ENTRIES-OFF DELETE-NULL-ENTRIES T)

(DEFN PRIMITIVE-COUNT
 (FLG X0 TYPE NETLIST)
 (CASE FLG
       (0 (COND ((PRIMP X0) (PRIMP2 X0 TYPE))
                ((LOOKUP-MODULE X0 NETLIST)
                 (IF (NET-ERRORP (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                     (LIST TYPE)
                                                     T))
                     (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                         (LIST TYPE)
                                         T)
                     (VALUE TYPE
                            (VALUE X0
                                   (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                       (LIST TYPE)
                                                       T)))))
                (T (PRED-ERROR 'UNKNOWN-MODULE X0))))
       (1 (VALUE TYPE
                 (OCCURRENCE-DATA (REQUIRED-PROPS (LIST TYPE))
                                  X0 NIL NIL NIL
                                  (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                                   (REQUIRED-PROPS (LIST TYPE))
                                                   T))))
       (OTHERWISE (PRED-ERROR 'UNKNOWN-FLAG
                              (LIST (LIST 'FLG FLG)
                                    (LIST 'X0 X0))))))

(TOGGLE PRIMITIVE-COUNT-OFF PRIMITIVE-COUNT T)

(DEFN OUT-DEPENDS
 (FLG X0 X1 X2 NETLIST)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (LIST-UNION-VALUES (PRIMP2 X0 'OUT-DEPENDS)
                        (PAIRLIST (PRIMP2 X0 'INPUTS) X1)))
    ((LOOKUP-MODULE X0 NETLIST)
     (IF
      (NET-ERRORP (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                      '(OUT-DEPENDS INPUTS)
                                      T))
      (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                          '(OUT-DEPENDS INPUTS)
                          T)
      (LIST-UNION-VALUES
              (VALUE 'OUT-DEPENDS
                     (VALUE X0
                            (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                '(OUT-DEPENDS INPUTS)
                                                T)))
              (PAIRLIST (VALUE 'INPUTS
                               (VALUE X0
                                      (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                          '(OUT-DEPENDS INPUTS)
                                                          T)))
                        X1))))
    (T (PRED-ERROR 'UNKNOWN-MODULE X0))))
  (1 (VALUE 'OUT-DEPENDS
            (OCCURRENCE-DATA (REQUIRED-PROPS '(OUT-DEPENDS))
                             X0 X1
                             (MARK-IO-OUTS X2 (INTERSECTION X1 X2))
                             (INTERSECTION X1 X2)
                             (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                              (REQUIRED-PROPS '(OUT-DEPENDS))
                                              T))))
  (OTHERWISE (PRED-ERROR 'UNKNOWN-FLAG
                         (LIST (LIST 'FLG FLG)
                               (LIST 'X0 X0)
                               (LIST 'X1 X1)
                               (LIST 'X2 X2))))))

(TOGGLE OUT-DEPENDS-OFF OUT-DEPENDS T)

(DEFN DEPENDENCY-TABLE
      (NETLIST)
      (NETLIST-PROPERTIES NETLIST
                          '(OUT-DEPENDS)
                          T))

(TOGGLE DEPENDENCY-TABLE-OFF DEPENDENCY-TABLE T)

(DEFN OUTPUT-DEPENDENCIES
 (MODULE-NAME ARGS NETLIST)
 (COND
  ((NET-ERRORP
           (COND ((PRIMP MODULE-NAME)
                  (LENGTH (PRIMP2 MODULE-NAME 'INPUTS)))
                 ((LOOKUP-MODULE MODULE-NAME NETLIST)
                  (LENGTH (MODULE-INPUTS (LOOKUP-MODULE MODULE-NAME NETLIST))))
                 (T (PRED-ERROR 'UNKNOWN-MODULE
                                MODULE-NAME))))
   (COND ((PRIMP MODULE-NAME)
          (LENGTH (PRIMP2 MODULE-NAME 'INPUTS)))
         ((LOOKUP-MODULE MODULE-NAME NETLIST)
          (LENGTH (MODULE-INPUTS (LOOKUP-MODULE MODULE-NAME NETLIST))))
         (T (PRED-ERROR 'UNKNOWN-MODULE
                        MODULE-NAME))))
  ((EQUAL (LENGTH ARGS)
          (COND ((PRIMP MODULE-NAME)
                 (LENGTH (PRIMP2 MODULE-NAME 'INPUTS)))
                ((LOOKUP-MODULE MODULE-NAME NETLIST)
                 (LENGTH (MODULE-INPUTS (LOOKUP-MODULE MODULE-NAME NETLIST))))
                (T (PRED-ERROR 'UNKNOWN-MODULE
                               MODULE-NAME))))
   (IF (NET-ERRORP (OUT-DEPENDS 0 MODULE-NAME ARGS NIL NETLIST))
       (OUT-DEPENDS 0 MODULE-NAME ARGS NIL NETLIST)
       (LIST-LIST-SORT (OUT-DEPENDS 0 MODULE-NAME ARGS NIL NETLIST))))
  (T
   (PRED-ERROR 'WRONG-NUMBER-OF-ARGS
    (LIST
     (LIST MODULE-NAME 'EXPECTS
           (COND ((PRIMP MODULE-NAME)
                  (LENGTH (PRIMP2 MODULE-NAME 'INPUTS)))
                 ((LOOKUP-MODULE MODULE-NAME NETLIST)
                  (LENGTH (MODULE-INPUTS (LOOKUP-MODULE MODULE-NAME NETLIST))))
                 (T (PRED-ERROR 'UNKNOWN-MODULE
                                MODULE-NAME))))
     (LIST 'GOT (LENGTH ARGS) ARGS))))))

(TOGGLE OUTPUT-DEPENDENCIES-OFF OUTPUT-DEPENDENCIES T)

(DEFN IO-TYPES-COLLECTOR
      (TYPES ALIST)
      (IF (LISTP TYPES)
          (CONS (IF (LISTP (CAR TYPES))
                    (VALUE (CAAR TYPES) ALIST)
                    (CAR TYPES))
                (IO-TYPES-COLLECTOR (CDR TYPES)
                                    ALIST))
          NIL))

(TOGGLE IO-TYPES-COLLECTOR-OFF IO-TYPES-COLLECTOR T)

(DEFN IO-TYPES
 (FLG X0 X1 X2 NETLIST)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (LIST (PRIMP-LOOKUP X0 'INPUT-TYPES)
           (CONS 'OUTPUT-TYPES
                 (IO-TYPES-COLLECTOR (PRIMP2 X0 'OUTPUT-TYPES)
                                     (PAIRLIST (PRIMP2 X0 'INPUTS) X1)))))
    ((LOOKUP-MODULE X0 NETLIST)
     (IF
      (NET-ERRORP (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                      '(INPUT-TYPES OUTPUT-TYPES INPUTS)
                                      T))
      (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                          '(INPUT-TYPES OUTPUT-TYPES INPUTS)
                          T)
      (LIST
       (ALIST-ENTRY 'INPUT-TYPES
                  (VALUE X0
                         (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                             '(INPUT-TYPES OUTPUT-TYPES INPUTS)
                                             T)))
       (CONS 'OUTPUT-TYPES
        (IO-TYPES-COLLECTOR
         (VALUE 'OUTPUT-TYPES
                (VALUE X0
                       (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                           '(INPUT-TYPES OUTPUT-TYPES INPUTS)
                                           T)))
         (PAIRLIST
           (VALUE 'INPUTS
                  (VALUE X0
                         (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                             '(INPUT-TYPES OUTPUT-TYPES INPUTS)
                                             T)))
           X1))))))
    (T (PRED-ERROR 'UNKNOWN-MODULE X0))))
  (1
   (LIST
    (ALIST-ENTRY 'INPUT-TYPES
     (OCCURRENCE-DATA
                  (REQUIRED-PROPS '(INPUT-TYPES OUTPUT-TYPES))
                  X0 X1
                  (MARK-IO-OUTS X2 (INTERSECTION X1 X2))
                  (INTERSECTION X1 X2)
                  (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                   (REQUIRED-PROPS '(INPUT-TYPES OUTPUT-TYPES))
                                   T)))
    (ALIST-ENTRY 'OUTPUT-TYPES
     (OCCURRENCE-DATA
                  (REQUIRED-PROPS '(INPUT-TYPES OUTPUT-TYPES))
                  X0 X1
                  (MARK-IO-OUTS X2 (INTERSECTION X1 X2))
                  (INTERSECTION X1 X2)
                  (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                   (REQUIRED-PROPS '(INPUT-TYPES OUTPUT-TYPES))
                                   T)))))
  (OTHERWISE (PRED-ERROR 'UNKNOWN-FLAG
                         (LIST (LIST 'FLG FLG)
                               (LIST 'X0 X0)
                               (LIST 'X1 X1)
                               (LIST 'X2 X2))))))

(TOGGLE IO-TYPES-OFF IO-TYPES T)

(DEFN NETLIST-TYPE-TABLE
      (NETLIST)
      (NETLIST-PROPERTIES NETLIST
                          '(INPUT-TYPES OUTPUT-TYPES)
                          T))

(TOGGLE NETLIST-TYPE-TABLE-OFF NETLIST-TYPE-TABLE T)

(DEFN ARG-TYPES-MATCHP
      (ACTUALS FORMALS)
      (COND ((OR (NLISTP ACTUALS) (NLISTP FORMALS))
             (EQUAL ACTUALS FORMALS))
            ((OR (UNKNOWNP (CAR ACTUALS))
                 (UNKNOWNP (CAR FORMALS)))
             F)
            ((TYPES-COMPATIBLEP (CAR ACTUALS)
                                (CAR FORMALS))
             (ARG-TYPES-MATCHP (CDR ACTUALS)
                               (CDR FORMALS)))
            (T F)))

(TOGGLE ARG-TYPES-MATCHP-OFF ARG-TYPES-MATCHP T)

(DEFN ARG-TYPES-OKP
      (FN ARG-TYPES NETLIST)
      (IF (BOUNDP 'INPUT-TYPES
                  (IO-TYPES 0 FN ARG-TYPES NIL NETLIST))
          (ARG-TYPES-MATCHP ARG-TYPES
                            (VALUE 'INPUT-TYPES
                                   (IO-TYPES 0 FN ARG-TYPES NIL NETLIST)))
          F))

(TOGGLE ARG-TYPES-OKP-OFF ARG-TYPES-OKP T)

(DEFN STATE-TYPE-REQUIREMENT
 (FLG X0 NETLIST)
 (CASE FLG
    (0 (COND ((PRIMP X0)
              (IF (PRIMP-LOOKUP X0 'STATE-TYPES)
                  (PRIMP2 X0 'STATE-TYPES)
                  NIL))
             ((LOOKUP-MODULE X0 NETLIST)
              (COND ((NET-ERRORP (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                     '(STATE-TYPES)
                                                     T))
                     (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                         '(STATE-TYPES)
                                         T))
                    ((BOUNDP 'STATE-TYPES
                             (VALUE X0
                                    (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                        '(STATE-TYPES)
                                                        T)))
                     (VALUE 'STATE-TYPES
                            (VALUE X0
                                   (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                                       '(STATE-TYPES)
                                                       T))))
                    (T NIL)))
             (T (PRED-ERROR 'UNKNOWN-MODULE X0))))
    (1 (VALUE 'STATE-TYPES
              (OCCURRENCE-DATA (REQUIRED-PROPS '(STATE-TYPES))
                               X0 NIL NIL NIL
                               (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                                (REQUIRED-PROPS '(STATE-TYPES))
                                                T))))
    (OTHERWISE (PRED-ERROR 'UNKNOWN-FLAG
                           (LIST (LIST 'FLG FLG)
                                 (LIST 'X0 X0))))))

(TOGGLE STATE-TYPE-REQUIREMENT-OFF STATE-TYPE-REQUIREMENT T)

(DEFN NETLIST-STATE-TYPES
      (NETLIST)
      (IF (NET-ERRORP (NETLIST-PROPERTIES NETLIST
                                          '(STATE-TYPES)
                                          T))
          (NETLIST-PROPERTIES NETLIST
                              '(STATE-TYPES)
                              T)
          (DELETE-NULL-ENTRIES (NETLIST-PROPERTIES NETLIST
                                                   '(STATE-TYPES)
                                                   T))))

(TOGGLE NETLIST-STATE-TYPES-OFF NETLIST-STATE-TYPES T)

(DEFN TYPE-COUNT
      (TYPE WORD-TYPE)
      (PLUS (COUNT TYPE) (COUNT WORD-TYPE)))

(PROVE-LEMMA TYPE-COUNT-LESSP1
             (REWRITE)
             (IMPLIES (LISTP TYPE)
                      (LESSP (TYPE-COUNT (CAR TYPE) (CADDR TYPE))
                             (TYPE-COUNT TYPE X))))

(PROVE-LEMMA TYPE-COUNT-LESSP2
             (REWRITE)
             (IMPLIES (LISTP TYPE)
                      (LESSP (TYPE-COUNT (CADR TYPE) F)
                             (TYPE-COUNT TYPE X))))

(PROVE-LEMMA TYPE-COUNT-LESSP3
             (REWRITE)
             (IMPLIES (LESSP (COUNT T2) (COUNT T1))
                      (EQUAL (LESSP (TYPE-COUNT WTYPE T2)
                                    (TYPE-COUNT T1 WTYPE))
                             T)))

(TOGGLE TYPE-COUNT-OFF TYPE-COUNT T)

(DEFN STATE-OKP-0
     (STATE TYPE ADDRESS-BITS WORD-TYPE)
     (CASE TYPE
           (NIL (EQUAL STATE NIL))
           (BOOLP (BOOLP STATE))
           (OTHERWISE (COND ((LISTP TYPE)
                             (CASE (CAR TYPE)
                                   (ADDRESSED-STATE (STATE-OKP-0 STATE
                                                                 (CAR TYPE)
                                                                 (CADR TYPE)
                                                                 (CADDR TYPE)))
                                   (RAM (AND (RAMP STATE)
                                             (STATE-OKP-0 (RAM-GUTS STATE)
                                                          (CADR TYPE)
                                                          0 F)))
                                   (ROM (AND (ROMP STATE)
                                             (STATE-OKP-0 (ROM-GUTS STATE)
                                                          (CADR TYPE)
                                                          0 F)))
                                   (STUB (AND (STUBP STATE)
                                              (STATE-OKP-0 (STUB-GUTS STATE)
                                                           (CADR TYPE)
                                                           0 F)))
                                   '(STATE-OKP-0 STATE (CADR TYPE) 0 F)
                                   (OTHERWISE (IF (LISTP STATE)
                                                  (AND (STATE-OKP-0 (CAR STATE)
                                                                    (CAR TYPE)
                                                                    0 F)
                                                       (STATE-OKP-0 (CDR STATE)
                                                                    (CDR TYPE)
                                                                    0 F))
                                                  F))))
                            ((EQUAL TYPE 'ADDRESSED-STATE)
                             (COND ((ZEROP ADDRESS-BITS)
                                    (STATE-OKP-0 STATE WORD-TYPE 0 F))
                                   ((LISTP STATE)
                                    (AND (STATE-OKP-0 (CAR STATE)
                                                      TYPE
                                                      (SUB1 ADDRESS-BITS)
                                                      WORD-TYPE)
                                         (STATE-OKP-0 (CDR STATE)
                                                      TYPE
                                                      (SUB1 ADDRESS-BITS)
                                                      WORD-TYPE)))
                                   (T F)))
                            ((EQUAL TYPE 'NUMBERP)
                             (NUMBERP STATE))
                            ((EQUAL TYPE 'NUMBER-LISTP)
                             (COND ((NLISTP STATE) (EQUAL STATE NIL))
                                   ((NUMBERP (CAR STATE))
                                    (STATE-OKP-0 (CDR STATE) TYPE 0 F))
                                   (T F)))
                            ((RAMP TYPE)
                             (IF (RAMP STATE)
                                 (STATE-OKP-0 (RAM-GUTS STATE)
                                              (RAM-GUTS TYPE)
                                              0 F)
                                 F))
                            ((ROMP TYPE)
                             (IF (ROMP STATE)
                                 (STATE-OKP-0 (ROM-GUTS STATE)
                                              (ROM-GUTS TYPE)
                                              0 F)
                                 F))
                            ((STUBP TYPE)
                             (IF (STUBP STATE)
                                 (STATE-OKP-0 (STUB-GUTS STATE)
                                              (STUB-GUTS TYPE)
                                              0 F)
                                 F))
                            (T F))))
     ((ORD-LESSP (CONS (ADD1 (COUNT STATE))
                       (TYPE-COUNT TYPE WORD-TYPE)))))

(TOGGLE STATE-OKP-0-OFF STATE-OKP-0 T)

(TOGGLE TYPE-COUNT-LESSP1-OFF TYPE-COUNT-LESSP1 T)

(TOGGLE TYPE-COUNT-LESSP2-OFF TYPE-COUNT-LESSP2 T)

(TOGGLE TYPE-COUNT-LESSP3-OFF TYPE-COUNT-LESSP3 T)

(DEFN STATE-OKP
      (FN STATE NETLIST)
      (STATE-OKP-0 STATE
                   (STATE-TYPE-REQUIREMENT 0 FN NETLIST)
                   0 F))

(TOGGLE STATE-OKP-OFF STATE-OKP T)

(DEFN FIX-DEPENDENT-DRS
      (DRS ALIST)
      (IF (LISTP DRS)
          (CONS (COND ((SIGNAL-NAMEP (CAR DRS))
                       (VALUE (CAR DRS) ALIST))
                      ((AND (LISTP (CAR DRS))
                            (EQUAL (CAAR DRS) 'MIN))
                       (CONS 'MIN
                             (FIX-DEPENDENT-DRS (CDAR DRS) ALIST)))
                      (T (CAR DRS)))
                (FIX-DEPENDENT-DRS (CDR DRS) ALIST))
          NIL))

(TOGGLE FIX-DEPENDENT-DRS-OFF FIX-DEPENDENT-DRS T)

(DEFN LOADINGS-AND-DRIVES
 (FLG X0 X1 X2 NETLIST)
 (CASE FLG
  (0
   (COND
    ((PRIMP X0)
     (LIST (PRIMP-LOOKUP X0 'LOADINGS)
           (CONS 'DRIVES
                 (FIX-DEPENDENT-DRS (PRIMP2 X0 'DRIVES)
                                    (APPEND (PAIRLIST (PRIMP2 X0 'INPUTS) X1)
                                            (PAIRLIST (PRIMP2 X0 'OUTPUTS)
                                                      X2))))))
    ((LOOKUP-MODULE X0 NETLIST)
     (IF
      (NET-ERRORP (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                      '(LOADINGS DRIVES INPUTS OUTPUTS)
                                      T))
      (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                          '(LOADINGS DRIVES INPUTS OUTPUTS)
                          T)
      (LIST
       (ALIST-ENTRY 'LOADINGS
                   (VALUE X0
                          (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                              '(LOADINGS DRIVES INPUTS OUTPUTS)
                                              T)))
       (CONS 'DRIVES
        (FIX-DEPENDENT-DRS
         (VALUE 'DRIVES
                (VALUE X0
                       (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                           '(LOADINGS DRIVES INPUTS OUTPUTS)
                                           T)))
         (APPEND
          (PAIRLIST
            (VALUE 'INPUTS
                   (VALUE X0
                          (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                              '(LOADINGS DRIVES INPUTS OUTPUTS)
                                              T)))
            X1)
          (PAIRLIST
            (VALUE 'OUTPUTS
                   (VALUE X0
                          (NETLIST-PROPERTIES (SUBNET 0 X0 NETLIST)
                                              '(LOADINGS DRIVES INPUTS OUTPUTS)
                                              T)))
            X2)))))))
    (T (PRED-ERROR 'UNKNOWN-MODULE X0))))
  (1
   (LIST
    (ALIST-ENTRY 'LOADINGS
          (OCCURRENCE-DATA (REQUIRED-PROPS '(LOADINGS DRIVES))
                           X0 X1
                           (MARK-IO-OUTS X2 (INTERSECTION X1 X2))
                           (INTERSECTION X1 X2)
                           (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                            (REQUIRED-PROPS '(LOADINGS DRIVES))
                                            T)))
    (ALIST-ENTRY 'DRIVES
          (OCCURRENCE-DATA (REQUIRED-PROPS '(LOADINGS DRIVES))
                           X0 X1
                           (MARK-IO-OUTS X2 (INTERSECTION X1 X2))
                           (INTERSECTION X1 X2)
                           (MODULE-DATABASE (SUBNET 1 X0 NETLIST)
                                            (REQUIRED-PROPS '(LOADINGS DRIVES))
                                            T)))))
  (OTHERWISE (PRED-ERROR 'UNKNOWN-FLAG
                         (LIST (LIST 'FLG FLG)
                               (LIST 'X0 X0)
                               (LIST 'X1 X1)
                               (LIST 'X2 X2))))))

(TOGGLE LOADINGS-AND-DRIVES-OFF LOADINGS-AND-DRIVES T)

(DEFN NETLIST-LOADINGS-AND-DRIVES
      (NETLIST)
      (NETLIST-PROPERTIES NETLIST
                          '(LOADINGS DRIVES)
                          T))

(TOGGLE NETLIST-LOADINGS-AND-DRIVES-OFF NETLIST-LOADINGS-AND-DRIVES T)

(DEFN AO2& (NETLIST) T)

(TOGGLE AO2&-OFF AO2& T)

(DEFN AO2$NETLIST NIL NIL)

(PROVE-LEMMA AO2$VALUE
             (REWRITE)
             (IMPLIES (AO2& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'AO2
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-NOR (F-AND A B) (F-AND C D)))))
             ((ENABLE AO2& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'AO2
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE AO2$VALUE-OFF AO2$VALUE T)

(DEFN AO4& (NETLIST) T)

(TOGGLE AO4&-OFF AO4& T)

(DEFN AO4$NETLIST NIL NIL)

(PROVE-LEMMA AO4$VALUE
             (REWRITE)
             (IMPLIES (AO4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'AO4
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-NAND (F-OR A B) (F-OR C D)))))
             ((ENABLE AO4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'AO4
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE AO4$VALUE-OFF AO4$VALUE T)

(DEFN AO6& (NETLIST) T)

(TOGGLE AO6&-OFF AO6& T)

(DEFN AO6$NETLIST NIL NIL)

(PROVE-LEMMA AO6$VALUE
             (REWRITE)
             (IMPLIES (AO6& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'AO6
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-NOR (F-AND A B) C))))
             ((ENABLE AO6& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'AO6
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE AO6$VALUE-OFF AO6$VALUE T)

(DEFN AO7& (NETLIST) T)

(TOGGLE AO7&-OFF AO7& T)

(DEFN AO7$NETLIST NIL NIL)

(PROVE-LEMMA AO7$VALUE
             (REWRITE)
             (IMPLIES (AO7& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'AO7
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-NAND (F-OR A B) C))))
             ((ENABLE AO7& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'AO7
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE AO7$VALUE-OFF AO7$VALUE T)

(DEFN B-AND& (NETLIST) T)

(TOGGLE B-AND&-OFF B-AND& T)

(DEFN B-AND$NETLIST NIL NIL)

(PROVE-LEMMA B-AND$VALUE
             (REWRITE)
             (IMPLIES (B-AND& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-AND
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-AND A B))))
             ((ENABLE B-AND& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-AND
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-AND$VALUE-OFF B-AND$VALUE T)

(DEFN B-AND3& (NETLIST) T)

(TOGGLE B-AND3&-OFF B-AND3& T)

(DEFN B-AND3$NETLIST NIL NIL)

(PROVE-LEMMA B-AND3$VALUE
             (REWRITE)
             (IMPLIES (B-AND3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-AND3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-AND3 A B C))))
             ((ENABLE B-AND3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-AND3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-AND3$VALUE-OFF B-AND3$VALUE T)

(DEFN B-AND4& (NETLIST) T)

(TOGGLE B-AND4&-OFF B-AND4& T)

(DEFN B-AND4$NETLIST NIL NIL)

(PROVE-LEMMA B-AND4$VALUE
             (REWRITE)
             (IMPLIES (B-AND4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-AND4
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-AND4 A B C D))))
             ((ENABLE B-AND4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-AND4
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE B-AND4$VALUE-OFF B-AND4$VALUE T)

(DEFN B-EQUV& (NETLIST) T)

(TOGGLE B-EQUV&-OFF B-EQUV& T)

(DEFN B-EQUV$NETLIST NIL NIL)

(PROVE-LEMMA B-EQUV$VALUE
             (REWRITE)
             (IMPLIES (B-EQUV& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-EQUV
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-EQUV A B))))
             ((ENABLE B-EQUV& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-EQUV
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-EQUV$VALUE-OFF B-EQUV$VALUE T)

(DEFN B-EQUV3& (NETLIST) T)

(TOGGLE B-EQUV3&-OFF B-EQUV3& T)

(DEFN B-EQUV3$NETLIST NIL NIL)

(PROVE-LEMMA B-EQUV3$VALUE
             (REWRITE)
             (IMPLIES (B-EQUV3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-EQUV3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-EQUV3 A B C))))
             ((ENABLE B-EQUV3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-EQUV3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-EQUV3$VALUE-OFF B-EQUV3$VALUE T)

(DEFN B-IF& (NETLIST) T)

(TOGGLE B-IF&-OFF B-IF& T)

(DEFN B-IF$NETLIST NIL NIL)

(PROVE-LEMMA B-IF$VALUE
             (REWRITE)
             (IMPLIES (B-IF& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-IF
                                        (LIST S A B)
                                        STATE NETLIST)
                             (LIST (F-IF S A B))))
             ((ENABLE B-IF& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-IF
                                 (LIST S A B)
                                 STATE NETLIST))))

(TOGGLE B-IF$VALUE-OFF B-IF$VALUE T)

(DEFN B-NAND& (NETLIST) T)

(TOGGLE B-NAND&-OFF B-NAND& T)

(DEFN B-NAND$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND$VALUE
             (REWRITE)
             (IMPLIES (B-NAND& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-NAND A B))))
             ((ENABLE B-NAND& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-NAND$VALUE-OFF B-NAND$VALUE T)

(DEFN B-NAND3& (NETLIST) T)

(TOGGLE B-NAND3&-OFF B-NAND3& T)

(DEFN B-NAND3$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND3$VALUE
             (REWRITE)
             (IMPLIES (B-NAND3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-NAND3 A B C))))
             ((ENABLE B-NAND3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-NAND3$VALUE-OFF B-NAND3$VALUE T)

(DEFN B-NAND4& (NETLIST) T)

(TOGGLE B-NAND4&-OFF B-NAND4& T)

(DEFN B-NAND4$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND4$VALUE
             (REWRITE)
             (IMPLIES (B-NAND4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND4
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-NAND4 A B C D))))
             ((ENABLE B-NAND4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND4
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE B-NAND4$VALUE-OFF B-NAND4$VALUE T)

(DEFN B-NAND5& (NETLIST) T)

(TOGGLE B-NAND5&-OFF B-NAND5& T)

(DEFN B-NAND5$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND5$VALUE
             (REWRITE)
             (IMPLIES (B-NAND5& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND5
                                        (LIST A B C D E)
                                        STATE NETLIST)
                             (LIST (F-NAND5 A B C D E))))
             ((ENABLE B-NAND5& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND5
                                 (LIST A B C D E)
                                 STATE NETLIST))))

(TOGGLE B-NAND5$VALUE-OFF B-NAND5$VALUE T)

(DEFN B-NAND6& (NETLIST) T)

(TOGGLE B-NAND6&-OFF B-NAND6& T)

(DEFN B-NAND6$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND6$VALUE
             (REWRITE)
             (IMPLIES (B-NAND6& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND6
                                        (LIST A B C D E G)
                                        STATE NETLIST)
                             (LIST (F-NAND6 A B C D E G))))
             ((ENABLE B-NAND6& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND6
                                 (LIST A B C D E G)
                                 STATE NETLIST))))

(TOGGLE B-NAND6$VALUE-OFF B-NAND6$VALUE T)

(DEFN B-NAND8& (NETLIST) T)

(TOGGLE B-NAND8&-OFF B-NAND8& T)

(DEFN B-NAND8$NETLIST NIL NIL)

(PROVE-LEMMA B-NAND8$VALUE
             (REWRITE)
             (IMPLIES (B-NAND8& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NAND8
                                        (LIST A B C D E G H I)
                                        STATE NETLIST)
                             (LIST (F-NAND8 A B C D E G H I))))
             ((ENABLE B-NAND8& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NAND8
                                 (LIST A B C D E G H I)
                                 STATE NETLIST))))

(TOGGLE B-NAND8$VALUE-OFF B-NAND8$VALUE T)

(DEFN B-NBUF& (NETLIST) T)

(TOGGLE B-NBUF&-OFF B-NBUF& T)

(DEFN B-NBUF$NETLIST NIL NIL)

(PROVE-LEMMA B-NBUF$VALUE
             (REWRITE)
             (IMPLIES (B-NBUF& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NBUF
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-NOT A) (F-BUF A))))
             ((ENABLE B-NBUF& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NBUF
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE B-NBUF$VALUE-OFF B-NBUF$VALUE T)

(DEFN B-NOR& (NETLIST) T)

(TOGGLE B-NOR&-OFF B-NOR& T)

(DEFN B-NOR$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR$VALUE
             (REWRITE)
             (IMPLIES (B-NOR& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-NOR A B))))
             ((ENABLE B-NOR& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-NOR$VALUE-OFF B-NOR$VALUE T)

(DEFN B-NOR3& (NETLIST) T)

(TOGGLE B-NOR3&-OFF B-NOR3& T)

(DEFN B-NOR3$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR3$VALUE
             (REWRITE)
             (IMPLIES (B-NOR3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-NOR3 A B C))))
             ((ENABLE B-NOR3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-NOR3$VALUE-OFF B-NOR3$VALUE T)

(DEFN B-NOR4& (NETLIST) T)

(TOGGLE B-NOR4&-OFF B-NOR4& T)

(DEFN B-NOR4$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR4$VALUE
             (REWRITE)
             (IMPLIES (B-NOR4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR4
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-NOR4 A B C D))))
             ((ENABLE B-NOR4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR4
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE B-NOR4$VALUE-OFF B-NOR4$VALUE T)

(DEFN B-NOR5& (NETLIST) T)

(TOGGLE B-NOR5&-OFF B-NOR5& T)

(DEFN B-NOR5$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR5$VALUE
             (REWRITE)
             (IMPLIES (B-NOR5& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR5
                                        (LIST A B C D E)
                                        STATE NETLIST)
                             (LIST (F-NOR5 A B C D E))))
             ((ENABLE B-NOR5& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR5
                                 (LIST A B C D E)
                                 STATE NETLIST))))

(TOGGLE B-NOR5$VALUE-OFF B-NOR5$VALUE T)

(DEFN B-NOR6& (NETLIST) T)

(TOGGLE B-NOR6&-OFF B-NOR6& T)

(DEFN B-NOR6$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR6$VALUE
             (REWRITE)
             (IMPLIES (B-NOR6& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR6
                                        (LIST A B C D E G)
                                        STATE NETLIST)
                             (LIST (F-NOR6 A B C D E G))))
             ((ENABLE B-NOR6& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR6
                                 (LIST A B C D E G)
                                 STATE NETLIST))))

(TOGGLE B-NOR6$VALUE-OFF B-NOR6$VALUE T)

(DEFN B-NOR8& (NETLIST) T)

(TOGGLE B-NOR8&-OFF B-NOR8& T)

(DEFN B-NOR8$NETLIST NIL NIL)

(PROVE-LEMMA B-NOR8$VALUE
             (REWRITE)
             (IMPLIES (B-NOR8& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOR8
                                        (LIST A B C D E G H I)
                                        STATE NETLIST)
                             (LIST (F-NOR8 A B C D E G H I))))
             ((ENABLE B-NOR8& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOR8
                                 (LIST A B C D E G H I)
                                 STATE NETLIST))))

(TOGGLE B-NOR8$VALUE-OFF B-NOR8$VALUE T)

(DEFN B-NOT& (NETLIST) T)

(TOGGLE B-NOT&-OFF B-NOT& T)

(DEFN B-NOT$NETLIST NIL NIL)

(PROVE-LEMMA B-NOT$VALUE
             (REWRITE)
             (IMPLIES (B-NOT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOT
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-NOT A))))
             ((ENABLE B-NOT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOT
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE B-NOT$VALUE-OFF B-NOT$VALUE T)

(DEFN B-NOT-B4IP& (NETLIST) T)

(TOGGLE B-NOT-B4IP&-OFF B-NOT-B4IP& T)

(DEFN B-NOT-B4IP$NETLIST NIL NIL)

(PROVE-LEMMA B-NOT-B4IP$VALUE
             (REWRITE)
             (IMPLIES (B-NOT-B4IP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOT-B4IP
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-NOT A))))
             ((ENABLE B-NOT-B4IP& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOT-B4IP
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE B-NOT-B4IP$VALUE-OFF B-NOT-B4IP$VALUE T)

(DEFN B-NOT-IVAP& (NETLIST) T)

(TOGGLE B-NOT-IVAP&-OFF B-NOT-IVAP& T)

(DEFN B-NOT-IVAP$NETLIST NIL NIL)

(PROVE-LEMMA B-NOT-IVAP$VALUE
             (REWRITE)
             (IMPLIES (B-NOT-IVAP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-NOT-IVAP
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-NOT A))))
             ((ENABLE B-NOT-IVAP& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-NOT-IVAP
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE B-NOT-IVAP$VALUE-OFF B-NOT-IVAP$VALUE T)

(DEFN B-OR& (NETLIST) T)

(TOGGLE B-OR&-OFF B-OR& T)

(DEFN B-OR$NETLIST NIL NIL)

(PROVE-LEMMA B-OR$VALUE
             (REWRITE)
             (IMPLIES (B-OR& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-OR
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-OR A B))))
             ((ENABLE B-OR& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-OR
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-OR$VALUE-OFF B-OR$VALUE T)

(DEFN B-OR3& (NETLIST) T)

(TOGGLE B-OR3&-OFF B-OR3& T)

(DEFN B-OR3$NETLIST NIL NIL)

(PROVE-LEMMA B-OR3$VALUE
             (REWRITE)
             (IMPLIES (B-OR3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-OR3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-OR3 A B C))))
             ((ENABLE B-OR3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-OR3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-OR3$VALUE-OFF B-OR3$VALUE T)

(DEFN B-OR4& (NETLIST) T)

(TOGGLE B-OR4&-OFF B-OR4& T)

(DEFN B-OR4$NETLIST NIL NIL)

(PROVE-LEMMA B-OR4$VALUE
             (REWRITE)
             (IMPLIES (B-OR4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-OR4
                                        (LIST A B C D)
                                        STATE NETLIST)
                             (LIST (F-OR4 A B C D))))
             ((ENABLE B-OR4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-OR4
                                 (LIST A B C D)
                                 STATE NETLIST))))

(TOGGLE B-OR4$VALUE-OFF B-OR4$VALUE T)

(DEFN B-XOR& (NETLIST) T)

(TOGGLE B-XOR&-OFF B-XOR& T)

(DEFN B-XOR$NETLIST NIL NIL)

(PROVE-LEMMA B-XOR$VALUE
             (REWRITE)
             (IMPLIES (B-XOR& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-XOR
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-XOR A B))))
             ((ENABLE B-XOR& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-XOR
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE B-XOR$VALUE-OFF B-XOR$VALUE T)

(DEFN B-XOR3& (NETLIST) T)

(TOGGLE B-XOR3&-OFF B-XOR3& T)

(DEFN B-XOR3$NETLIST NIL NIL)

(PROVE-LEMMA B-XOR3$VALUE
             (REWRITE)
             (IMPLIES (B-XOR3& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-XOR3
                                        (LIST A B C)
                                        STATE NETLIST)
                             (LIST (F-XOR3 A B C))))
             ((ENABLE B-XOR3& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'B-XOR3
                                 (LIST A B C)
                                 STATE NETLIST))))

(TOGGLE B-XOR3$VALUE-OFF B-XOR3$VALUE T)

(DEFN DEL2& (NETLIST) T)

(TOGGLE DEL2&-OFF DEL2& T)

(DEFN DEL2$NETLIST NIL NIL)

(PROVE-LEMMA DEL2$VALUE
             (REWRITE)
             (IMPLIES (DEL2& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DEL2
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE DEL2& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'DEL2
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE DEL2$VALUE-OFF DEL2$VALUE T)

(DEFN DEL4& (NETLIST) T)

(TOGGLE DEL4&-OFF DEL4& T)

(DEFN DEL4$NETLIST NIL NIL)

(PROVE-LEMMA DEL4$VALUE
             (REWRITE)
             (IMPLIES (DEL4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DEL4
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE DEL4& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'DEL4
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE DEL4$VALUE-OFF DEL4$VALUE T)

(DEFN DEL10& (NETLIST) T)

(TOGGLE DEL10&-OFF DEL10& T)

(DEFN DEL10$NETLIST NIL NIL)

(PROVE-LEMMA DEL10$VALUE
             (REWRITE)
             (IMPLIES (DEL10& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DEL10
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE DEL10& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'DEL10
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE DEL10$VALUE-OFF DEL10$VALUE T)

(DEFN PROCMON& (NETLIST) T)

(TOGGLE PROCMON&-OFF PROCMON& T)

(DEFN PROCMON$NETLIST NIL NIL)

(PROVE-LEMMA PROCMON$VALUE
             (REWRITE)
             (IMPLIES (PROCMON& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'PROCMON
                                        (LIST A E S N)
                                        STATE NETLIST)
                             (LIST (F-IF S (F-IF E (F-IF A F F) A) N))))
             ((ENABLE PROCMON& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'PROCMON
                                 (LIST A E S N)
                                 STATE NETLIST))))

(TOGGLE PROCMON$VALUE-OFF PROCMON$VALUE T)

(DEFN DP-RAM-16X32& (NETLIST) T)

(TOGGLE DP-RAM-16X32&-OFF DP-RAM-16X32& T)

(DEFN DP-RAM-16X32$NETLIST NIL NIL)

(PROVE-LEMMA DP-RAM-16X32$VALUE
             (REWRITE)
             (IMPLIES (DP-RAM-16X32& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DP-RAM-16X32
                                        (LIST READ-A0 READ-A1 READ-A2 READ-A3
                                              WRITE-B0 WRITE-B1 WRITE-B2
                                              WRITE-B3 WEN D0 D1 D2 D3 D4 D5
                                              D6 D7 D8 D9 D10 D11 D12 D13 D14
                                              D15 D16 D17 D18 D19 D20 D21 D22
                                              D23 D24 D25 D26 D27 D28 D29 D30
                                              D31)
                                        STATE NETLIST)
                             (DUAL-PORT-RAM-VALUE 32 4
                                                  (LIST READ-A0 READ-A1
                                                        READ-A2 READ-A3
                                                        WRITE-B0 WRITE-B1
                                                        WRITE-B2 WRITE-B3 WEN
                                                        D0 D1 D2 D3 D4 D5 D6
                                                        D7 D8 D9 D10 D11 D12
                                                        D13 D14 D15 D16 D17
                                                        D18 D19 D20 D21 D22
                                                        D23 D24 D25 D26 D27
                                                        D28 D29 D30 D31)
                                                  STATE)))
             ((ENABLE DP-RAM-16X32& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'DP-RAM-16X32
                                 (LIST READ-A0 READ-A1 READ-A2 READ-A3
                                       WRITE-B0 WRITE-B1 WRITE-B2 WRITE-B3 WEN
                                       D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11
                                       D12 D13 D14 D15 D16 D17 D18 D19 D20 D21
                                       D22 D23 D24 D25 D26 D27 D28 D29 D30 D31)
                                 STATE NETLIST))))

(TOGGLE DP-RAM-16X32$VALUE-OFF DP-RAM-16X32$VALUE T)

(DEFN FD1& (NETLIST) T)

(TOGGLE FD1&-OFF FD1& T)

(DEFN FD1$NETLIST NIL NIL)

(PROVE-LEMMA FD1$VALUE
             (REWRITE)
             (IMPLIES (FD1& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FD1
                                        (LIST D CP)
                                        STATE NETLIST)
                             (LIST (F-BUF STATE) (F-NOT STATE))))
             ((ENABLE FD1& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'FD1
                                 (LIST D CP)
                                 STATE NETLIST))))

(TOGGLE FD1$VALUE-OFF FD1$VALUE T)

(DEFN FD1S& (NETLIST) T)

(TOGGLE FD1S&-OFF FD1S& T)

(DEFN FD1S$NETLIST NIL NIL)

(PROVE-LEMMA FD1S$VALUE
             (REWRITE)
             (IMPLIES (FD1S& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FD1S
                                        (LIST D CP TI TE)
                                        STATE NETLIST)
                             (LIST (F-BUF STATE) (F-NOT STATE))))
             ((ENABLE FD1S& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'FD1S
                                 (LIST D CP TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1S$VALUE-OFF FD1S$VALUE T)

(DEFN FD1SP& (NETLIST) T)

(TOGGLE FD1SP&-OFF FD1SP& T)

(DEFN FD1SP$NETLIST NIL NIL)

(PROVE-LEMMA FD1SP$VALUE
             (REWRITE)
             (IMPLIES (FD1SP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FD1SP
                                        (LIST D CP TI TE)
                                        STATE NETLIST)
                             (LIST (F-BUF STATE) (F-NOT STATE))))
             ((ENABLE FD1SP& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'FD1SP
                                 (LIST D CP TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1SP$VALUE-OFF FD1SP$VALUE T)

(DEFN FD1SLP& (NETLIST) T)

(TOGGLE FD1SLP&-OFF FD1SLP& T)

(DEFN FD1SLP$NETLIST NIL NIL)

(PROVE-LEMMA FD1SLP$VALUE
             (REWRITE)
             (IMPLIES (FD1SLP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FD1SLP
                                        (LIST D CP LD TI TE)
                                        STATE NETLIST)
                             (LIST (F-BUF STATE) (F-NOT STATE))))
             ((ENABLE FD1SLP& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'FD1SLP
                                 (LIST D CP LD TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1SLP$VALUE-OFF FD1SLP$VALUE T)

(DEFN ID& (NETLIST) T)

(TOGGLE ID&-OFF ID& T)

(DEFN ID$NETLIST NIL NIL)

(PROVE-LEMMA ID$VALUE
             (REWRITE)
             (IMPLIES (ID& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'ID
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST A)))
             ((ENABLE ID& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'ID
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE ID$VALUE-OFF ID$VALUE T)

(DEFN MEM-32X32& (NETLIST) T)

(TOGGLE MEM-32X32&-OFF MEM-32X32& T)

(DEFN MEM-32X32$NETLIST NIL NIL)

(PROVE-LEMMA MEM-32X32$VALUE
             (REWRITE)
             (IMPLIES (MEM-32X32& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'MEM-32X32
                                        (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6
                                              A7 A8 A9 A10 A11 A12 A13 A14 A15
                                              A16 A17 A18 A19 A20 A21 A22 A23
                                              A24 A25 A26 A27 A28 A29 A30 A31
                                              D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
                                              D10 D11 D12 D13 D14 D15 D16 D17
                                              D18 D19 D20 D21 D22 D23 D24 D25
                                              D26 D27 D28 D29 D30 D31)
                                        STATE NETLIST)
                             (MEM-VALUE (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6
                                              A7 A8 A9 A10 A11 A12 A13 A14 A15
                                              A16 A17 A18 A19 A20 A21 A22 A23
                                              A24 A25 A26 A27 A28 A29 A30 A31
                                              D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
                                              D10 D11 D12 D13 D14 D15 D16 D17
                                              D18 D19 D20 D21 D22 D23 D24 D25
                                              D26 D27 D28 D29 D30 D31)
                                        STATE)))
             ((ENABLE MEM-32X32& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'MEM-32X32
                                 (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8
                                       A9 A10 A11 A12 A13 A14 A15 A16 A17 A18
                                       A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                                       A29 A30 A31 D0 D1 D2 D3 D4 D5 D6 D7 D8
                                       D9 D10 D11 D12 D13 D14 D15 D16 D17 D18
                                       D19 D20 D21 D22 D23 D24 D25 D26 D27 D28
                                       D29 D30 D31)
                                 STATE NETLIST))))

(TOGGLE MEM-32X32$VALUE-OFF MEM-32X32$VALUE T)

(DEFN RAM-ENABLE-CIRCUIT& (NETLIST) T)

(TOGGLE RAM-ENABLE-CIRCUIT&-OFF RAM-ENABLE-CIRCUIT& T)

(DEFN RAM-ENABLE-CIRCUIT$NETLIST NIL NIL)

(PROVE-LEMMA RAM-ENABLE-CIRCUIT$VALUE
             (REWRITE)
             (IMPLIES (RAM-ENABLE-CIRCUIT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'RAM-ENABLE-CIRCUIT
                                        (LIST CLK TEST-REGFILE-
                                              DISABLE-REGFILE- WE)
                                        STATE NETLIST)
                             (LIST (F-NAND DISABLE-REGFILE- WE))))
             ((ENABLE RAM-ENABLE-CIRCUIT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'RAM-ENABLE-CIRCUIT
                                 (LIST CLK TEST-REGFILE- DISABLE-REGFILE- WE)
                                 STATE NETLIST))))

(TOGGLE RAM-ENABLE-CIRCUIT$VALUE-OFF RAM-ENABLE-CIRCUIT$VALUE T)

(DEFN T-BUF& (NETLIST) T)

(TOGGLE T-BUF&-OFF T-BUF& T)

(DEFN T-BUF$NETLIST NIL NIL)

(PROVE-LEMMA T-BUF$VALUE
             (REWRITE)
             (IMPLIES (T-BUF& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'T-BUF
                                        (LIST E A)
                                        STATE NETLIST)
                             (LIST (FT-BUF E A))))
             ((ENABLE T-BUF& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'T-BUF
                                 (LIST E A)
                                 STATE NETLIST))))

(TOGGLE T-BUF$VALUE-OFF T-BUF$VALUE T)

(DEFN T-WIRE& (NETLIST) T)

(TOGGLE T-WIRE&-OFF T-WIRE& T)

(DEFN T-WIRE$NETLIST NIL NIL)

(PROVE-LEMMA T-WIRE$VALUE
             (REWRITE)
             (IMPLIES (T-WIRE& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'T-WIRE
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (FT-WIRE A B))))
             ((ENABLE T-WIRE& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'T-WIRE
                                 (LIST A B)
                                 STATE NETLIST))))

(TOGGLE T-WIRE$VALUE-OFF T-WIRE$VALUE T)

(DEFN PULLUP& (NETLIST) T)

(TOGGLE PULLUP&-OFF PULLUP& T)

(DEFN PULLUP$NETLIST NIL NIL)

(PROVE-LEMMA PULLUP$VALUE
             (REWRITE)
             (IMPLIES (PULLUP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'PULLUP
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-PULLUP A))))
             ((ENABLE PULLUP& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'PULLUP
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE PULLUP$VALUE-OFF PULLUP$VALUE T)

(DEFN TTL-BIDIRECT& (NETLIST) T)

(TOGGLE TTL-BIDIRECT&-OFF TTL-BIDIRECT& T)

(DEFN TTL-BIDIRECT$NETLIST NIL NIL)

(PROVE-LEMMA TTL-BIDIRECT$VALUE
             (REWRITE)
             (IMPLIES (TTL-BIDIRECT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-BIDIRECT
                                        (LIST IO A EN PI)
                                        STATE NETLIST)
                             (LIST (FT-BUF (F-NOT EN) A)
                                   (F-BUF (FT-WIRE IO (FT-BUF (F-NOT EN) A)))
                                   (F-NAND (FT-WIRE IO (FT-BUF (F-NOT EN) A))
                                           PI))))
             ((ENABLE TTL-BIDIRECT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-BIDIRECT
                                 (LIST IO A EN PI)
                                 STATE NETLIST))))

(TOGGLE TTL-BIDIRECT$VALUE-OFF TTL-BIDIRECT$VALUE T)

(DEFN TTL-CLK-INPUT& (NETLIST) T)

(TOGGLE TTL-CLK-INPUT&-OFF TTL-CLK-INPUT& T)

(DEFN TTL-CLK-INPUT$NETLIST NIL NIL)

(PROVE-LEMMA TTL-CLK-INPUT$VALUE
             (REWRITE)
             (IMPLIES (TTL-CLK-INPUT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-CLK-INPUT
                                        (LIST A PI)
                                        STATE NETLIST)
                             (LIST (F-BUF A) (F-NAND A PI))))
             ((ENABLE TTL-CLK-INPUT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-CLK-INPUT
                                 (LIST A PI)
                                 STATE NETLIST))))

(TOGGLE TTL-CLK-INPUT$VALUE-OFF TTL-CLK-INPUT$VALUE T)

(DEFN TTL-INPUT& (NETLIST) T)

(TOGGLE TTL-INPUT&-OFF TTL-INPUT& T)

(DEFN TTL-INPUT$NETLIST NIL NIL)

(PROVE-LEMMA TTL-INPUT$VALUE
             (REWRITE)
             (IMPLIES (TTL-INPUT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-INPUT
                                        (LIST A PI)
                                        STATE NETLIST)
                             (LIST (F-BUF A) (F-NAND A PI))))
             ((ENABLE TTL-INPUT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-INPUT
                                 (LIST A PI)
                                 STATE NETLIST))))

(TOGGLE TTL-INPUT$VALUE-OFF TTL-INPUT$VALUE T)

(DEFN TTL-OUTPUT& (NETLIST) T)

(TOGGLE TTL-OUTPUT&-OFF TTL-OUTPUT& T)

(DEFN TTL-OUTPUT$NETLIST NIL NIL)

(PROVE-LEMMA TTL-OUTPUT$VALUE
             (REWRITE)
             (IMPLIES (TTL-OUTPUT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE TTL-OUTPUT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-OUTPUT
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE TTL-OUTPUT$VALUE-OFF TTL-OUTPUT$VALUE T)

(DEFN TTL-OUTPUT-PARAMETRIC&
      (NETLIST)
      T)

(TOGGLE TTL-OUTPUT-PARAMETRIC&-OFF TTL-OUTPUT-PARAMETRIC& T)

(DEFN TTL-OUTPUT-PARAMETRIC$NETLIST NIL NIL)

(PROVE-LEMMA TTL-OUTPUT-PARAMETRIC$VALUE
             (REWRITE)
             (IMPLIES (TTL-OUTPUT-PARAMETRIC& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT-PARAMETRIC
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE TTL-OUTPUT-PARAMETRIC& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-OUTPUT-PARAMETRIC
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE TTL-OUTPUT-PARAMETRIC$VALUE-OFF TTL-OUTPUT-PARAMETRIC$VALUE T)

(DEFN TTL-OUTPUT-FAST& (NETLIST) T)

(TOGGLE TTL-OUTPUT-FAST&-OFF TTL-OUTPUT-FAST& T)

(DEFN TTL-OUTPUT-FAST$NETLIST NIL NIL)

(PROVE-LEMMA TTL-OUTPUT-FAST$VALUE
             (REWRITE)
             (IMPLIES (TTL-OUTPUT-FAST& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT-FAST
                                        (LIST A)
                                        STATE NETLIST)
                             (LIST (F-BUF A))))
             ((ENABLE TTL-OUTPUT-FAST& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-OUTPUT-FAST
                                 (LIST A)
                                 STATE NETLIST))))

(TOGGLE TTL-OUTPUT-FAST$VALUE-OFF TTL-OUTPUT-FAST$VALUE T)

(DEFN TTL-TRI-OUTPUT& (NETLIST) T)

(TOGGLE TTL-TRI-OUTPUT&-OFF TTL-TRI-OUTPUT& T)

(DEFN TTL-TRI-OUTPUT$NETLIST NIL NIL)

(PROVE-LEMMA TTL-TRI-OUTPUT$VALUE
             (REWRITE)
             (IMPLIES (TTL-TRI-OUTPUT& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-TRI-OUTPUT
                                        (LIST A EN)
                                        STATE NETLIST)
                             (LIST (FT-BUF (F-NOT EN) A))))
             ((ENABLE TTL-TRI-OUTPUT& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-TRI-OUTPUT
                                 (LIST A EN)
                                 STATE NETLIST))))

(TOGGLE TTL-TRI-OUTPUT$VALUE-OFF TTL-TRI-OUTPUT$VALUE T)

(DEFN TTL-TRI-OUTPUT-FAST&
      (NETLIST)
      T)

(TOGGLE TTL-TRI-OUTPUT-FAST&-OFF TTL-TRI-OUTPUT-FAST& T)

(DEFN TTL-TRI-OUTPUT-FAST$NETLIST NIL NIL)

(PROVE-LEMMA TTL-TRI-OUTPUT-FAST$VALUE
             (REWRITE)
             (IMPLIES (TTL-TRI-OUTPUT-FAST& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'TTL-TRI-OUTPUT-FAST
                                        (LIST A EN)
                                        STATE NETLIST)
                             (LIST (FT-BUF (F-NOT EN) A))))
             ((ENABLE TTL-TRI-OUTPUT-FAST& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'TTL-TRI-OUTPUT-FAST
                                 (LIST A EN)
                                 STATE NETLIST))))

(TOGGLE TTL-TRI-OUTPUT-FAST$VALUE-OFF TTL-TRI-OUTPUT-FAST$VALUE T)

(DEFN VDD& (NETLIST) T)

(TOGGLE VDD&-OFF VDD& T)

(DEFN VDD$NETLIST NIL NIL)

(PROVE-LEMMA VDD$VALUE
             (REWRITE)
             (IMPLIES (VDD& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'VDD NIL STATE NETLIST)
                             (LIST T)))
             ((ENABLE VDD& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'VDD
                                 NIL STATE NETLIST))))

(TOGGLE VDD$VALUE-OFF VDD$VALUE T)

(DEFN VDD-PARAMETRIC& (NETLIST) T)

(TOGGLE VDD-PARAMETRIC&-OFF VDD-PARAMETRIC& T)

(DEFN VDD-PARAMETRIC$NETLIST NIL NIL)

(PROVE-LEMMA VDD-PARAMETRIC$VALUE
             (REWRITE)
             (IMPLIES (VDD-PARAMETRIC& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'VDD-PARAMETRIC
                                        NIL STATE NETLIST)
                             (LIST T)))
             ((ENABLE VDD-PARAMETRIC& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'VDD-PARAMETRIC
                                 NIL STATE NETLIST))))

(TOGGLE VDD-PARAMETRIC$VALUE-OFF VDD-PARAMETRIC$VALUE T)

(DEFN VSS& (NETLIST) T)

(TOGGLE VSS&-OFF VSS& T)

(DEFN VSS$NETLIST NIL NIL)

(PROVE-LEMMA VSS$VALUE
             (REWRITE)
             (IMPLIES (VSS& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'VSS NIL STATE NETLIST)
                             (LIST F)))
             ((ENABLE VSS& PRIMP DUAL-APPLY-VALUE)
              (EXPAND (DUAL-EVAL 0 'VSS
                                 NIL STATE NETLIST))))

(TOGGLE VSS$VALUE-OFF VSS$VALUE T)

(PROVE-LEMMA DP-RAM-16X32$STATE
             (REWRITE)
             (IMPLIES (DP-RAM-16X32& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'DP-RAM-16X32
                                        (LIST READ-A0 READ-A1 READ-A2 READ-A3
                                              WRITE-B0 WRITE-B1 WRITE-B2
                                              WRITE-B3 WEN D0 D1 D2 D3 D4 D5
                                              D6 D7 D8 D9 D10 D11 D12 D13 D14
                                              D15 D16 D17 D18 D19 D20 D21 D22
                                              D23 D24 D25 D26 D27 D28 D29 D30
                                              D31)
                                        STATE NETLIST)
                             (DUAL-PORT-RAM-STATE 32 4
                                                  (LIST READ-A0 READ-A1
                                                        READ-A2 READ-A3
                                                        WRITE-B0 WRITE-B1
                                                        WRITE-B2 WRITE-B3 WEN
                                                        D0 D1 D2 D3 D4 D5 D6
                                                        D7 D8 D9 D10 D11 D12
                                                        D13 D14 D15 D16 D17
                                                        D18 D19 D20 D21 D22
                                                        D23 D24 D25 D26 D27
                                                        D28 D29 D30 D31)
                                                  STATE)))
             ((ENABLE DP-RAM-16X32& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'DP-RAM-16X32
                                 (LIST READ-A0 READ-A1 READ-A2 READ-A3
                                       WRITE-B0 WRITE-B1 WRITE-B2 WRITE-B3 WEN
                                       D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11
                                       D12 D13 D14 D15 D16 D17 D18 D19 D20 D21
                                       D22 D23 D24 D25 D26 D27 D28 D29 D30 D31)
                                 STATE NETLIST))))

(TOGGLE DP-RAM-16X32$STATE-OFF DP-RAM-16X32$STATE T)

(PROVE-LEMMA FD1$STATE
             (REWRITE)
             (IMPLIES (FD1& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'FD1
                                        (LIST D CP)
                                        STATE NETLIST)
                             (F-BUF D)))
             ((ENABLE FD1& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'FD1
                                 (LIST D CP)
                                 STATE NETLIST))))

(TOGGLE FD1$STATE-OFF FD1$STATE T)

(PROVE-LEMMA FD1S$STATE
             (REWRITE)
             (IMPLIES (FD1S& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'FD1S
                                        (LIST D CP TI TE)
                                        STATE NETLIST)
                             (F-IF TE TI D)))
             ((ENABLE FD1S& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'FD1S
                                 (LIST D CP TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1S$STATE-OFF FD1S$STATE T)

(PROVE-LEMMA FD1SP$STATE
             (REWRITE)
             (IMPLIES (FD1SP& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'FD1SP
                                        (LIST D CP TI TE)
                                        STATE NETLIST)
                             (F-IF TE TI D)))
             ((ENABLE FD1SP& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'FD1SP
                                 (LIST D CP TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1SP$STATE-OFF FD1SP$STATE T)

(PROVE-LEMMA FD1SLP$STATE
             (REWRITE)
             (IMPLIES (FD1SLP& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'FD1SLP
                                        (LIST D CP LD TI TE)
                                        STATE NETLIST)
                             (F-IF TE TI (F-IF LD D STATE))))
             ((ENABLE FD1SLP& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'FD1SLP
                                 (LIST D CP LD TI TE)
                                 STATE NETLIST))))

(TOGGLE FD1SLP$STATE-OFF FD1SLP$STATE T)

(PROVE-LEMMA MEM-32X32$STATE
             (REWRITE)
             (IMPLIES (MEM-32X32& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'MEM-32X32
                                        (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6
                                              A7 A8 A9 A10 A11 A12 A13 A14 A15
                                              A16 A17 A18 A19 A20 A21 A22 A23
                                              A24 A25 A26 A27 A28 A29 A30 A31
                                              D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
                                              D10 D11 D12 D13 D14 D15 D16 D17
                                              D18 D19 D20 D21 D22 D23 D24 D25
                                              D26 D27 D28 D29 D30 D31)
                                        STATE NETLIST)
                             (MEM-STATE (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6
                                              A7 A8 A9 A10 A11 A12 A13 A14 A15
                                              A16 A17 A18 A19 A20 A21 A22 A23
                                              A24 A25 A26 A27 A28 A29 A30 A31
                                              D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
                                              D10 D11 D12 D13 D14 D15 D16 D17
                                              D18 D19 D20 D21 D22 D23 D24 D25
                                              D26 D27 D28 D29 D30 D31)
                                        STATE)))
             ((ENABLE MEM-32X32& PRIMP DUAL-APPLY-STATE)
              (EXPAND (DUAL-EVAL 2 'MEM-32X32
                                 (LIST RW- STROBE- A0 A1 A2 A3 A4 A5 A6 A7 A8
                                       A9 A10 A11 A12 A13 A14 A15 A16 A17 A18
                                       A19 A20 A21 A22 A23 A24 A25 A26 A27 A28
                                       A29 A30 A31 D0 D1 D2 D3 D4 D5 D6 D7 D8
                                       D9 D10 D11 D12 D13 D14 D15 D16 D17 D18
                                       D19 D20 D21 D22 D23 D24 D25 D26 D27 D28
                                       D29 D30 D31)
                                 STATE NETLIST))))

(TOGGLE MEM-32X32$STATE-OFF MEM-32X32$STATE T)

(DEFN B-BUF* NIL
      '(B-BUF (IN)
              (OUT)
              ((G0 (OUT- OUT) B-NBUF (IN)))
              NIL))

(DEFN B-BUF&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'B-BUF NETLIST)
                  (B-BUF*))
           (B-NBUF& (DELETE-MODULE 'B-BUF NETLIST))))

(TOGGLE B-BUF&-OFF B-BUF& T)

(DEFN B-BUF$NETLIST NIL
      (CONS (B-BUF*) (B-NBUF$NETLIST)))

(PROVE-LEMMA B-BUF$VALUE
             (REWRITE)
             (IMPLIES (B-BUF& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-BUF
                                        (LIST IN)
                                        STATE NETLIST)
                             (LIST (F-BUF IN))))
             ((ENABLE B-BUF& BOOLP-B-GATES B-BUF BOOLP B-NBUF$VALUE)))

(TOGGLE B-BUF$VALUE-OFF B-BUF$VALUE T)

(DEFN B-BUF-PWR* NIL
      '(B-BUF-PWR (IN)
                  (OUT)
                  ((G0 (OUT-) B-NOT (IN))
                   (G1 (OUT) B-NOT-B4IP (OUT-)))
                  NIL))

(DEFN B-BUF-PWR&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'B-BUF-PWR NETLIST)
                  (B-BUF-PWR*))
           (B-NOT& (DELETE-MODULE 'B-BUF-PWR NETLIST))
           (B-NOT-B4IP& (DELETE-MODULE 'B-BUF-PWR NETLIST))))

(TOGGLE B-BUF-PWR&-OFF B-BUF-PWR& T)

(DEFN B-BUF-PWR$NETLIST NIL
      (CONS (B-BUF-PWR*)
            (UNION (B-NOT$NETLIST)
                   (B-NOT-B4IP$NETLIST))))

(PROVE-LEMMA B-BUF-PWR$VALUE
             (REWRITE)
             (IMPLIES (B-BUF-PWR& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'B-BUF-PWR
                                        (LIST IN)
                                        STATE NETLIST)
                             (LIST (F-BUF IN))))
             ((ENABLE B-BUF-PWR& BOOLP-B-GATES B-BUF B-NOT$VALUE
                      B-NOT-B4IP$VALUE)))

(TOGGLE B-BUF-PWR$VALUE-OFF B-BUF-PWR$VALUE T)

(PROVE-LEMMA DP-RAM-16X32-ARGS-CROCK
      (REWRITE)
      (IMPLIES (AND (EQUAL (LENGTH A) 4)
                    (PROPERP A)
                    (EQUAL (LENGTH B) 4)
                    (PROPERP B)
                    (EQUAL (LENGTH C) 32)
                    (PROPERP C))
               (EQUAL (APPEND A (APPEND B (CONS X C)))
                      (APPEND (LIST-AS-COLLECTED-NTH A 4 0)
                              (APPEND (LIST-AS-COLLECTED-NTH B 4 0)
                                      (CONS X
                                            (LIST-AS-COLLECTED-NTH C 32 0))))))
      ((USE (EQUAL-LENGTH-4-AS-COLLECTED-NTH (L A))
            (EQUAL-LENGTH-4-AS-COLLECTED-NTH (L B))
            (EQUAL-LENGTH-32-AS-COLLECTED-NTH (L C)))
       (DISABLE OPEN-LIST-AS-COLLECTED-NTH)))

(TOGGLE DP-RAM-16X32-ARGS-CROCK-OFF DP-RAM-16X32-ARGS-CROCK T)

(PROVE-LEMMA DP-RAM-16X32$STRUCTURED-VALUE
          (REWRITE)
          (IMPLIES (AND (DP-RAM-16X32& NETLIST)
                        (EQUAL (LENGTH A) 4)
                        (PROPERP A)
                        (EQUAL (LENGTH B) 4)
                        (PROPERP B)
                        (EQUAL (LENGTH C) 32)
                        (PROPERP C))
                   (EQUAL (DUAL-EVAL 0 'DP-RAM-16X32
                                     (APPEND A (APPEND B (CONS X C)))
                                     STATE NETLIST)
                          (DUAL-PORT-RAM-VALUE 32 4
                                               (APPEND A (APPEND B (CONS X C)))
                                               STATE)))
          ((ENABLE DP-RAM-16X32-ARGS-CROCK DP-RAM-16X32$VALUE)
           (DISABLE CAR-CDR-ELIM DUAL-PORT-RAM-VALUE)))

(TOGGLE DP-RAM-16X32$STRUCTURED-VALUE-OFF DP-RAM-16X32$STRUCTURED-VALUE T)

(PROVE-LEMMA DP-RAM-16X32$STRUCTURED-STATE
          (REWRITE)
          (IMPLIES (AND (DP-RAM-16X32& NETLIST)
                        (EQUAL (LENGTH A) 4)
                        (PROPERP A)
                        (EQUAL (LENGTH B) 4)
                        (PROPERP B)
                        (EQUAL (LENGTH C) 32)
                        (PROPERP C))
                   (EQUAL (DUAL-EVAL 2 'DP-RAM-16X32
                                     (APPEND A (APPEND B (CONS X C)))
                                     STATE NETLIST)
                          (DUAL-PORT-RAM-STATE 32 4
                                               (APPEND A (APPEND B (CONS X C)))
                                               STATE)))
          ((ENABLE DP-RAM-16X32-ARGS-CROCK DP-RAM-16X32$STATE)
           (DISABLE CAR-CDR-ELIM DUAL-PORT-RAM-STATE)))

(TOGGLE DP-RAM-16X32$STRUCTURED-STATE-OFF DP-RAM-16X32$STRUCTURED-STATE T)

(PROVE-LEMMA MEM-32X32-ARGS-CROCK
     (REWRITE)
     (IMPLIES (AND (EQUAL (LENGTH ADDR) 32)
                   (PROPERP ADDR)
                   (EQUAL (LENGTH DATA) 32)
                   (PROPERP DATA))
              (EQUAL (CONS RW-
                           (CONS STROBE- (APPEND ADDR DATA)))
                     (CONS RW-
                           (CONS STROBE-
                                 (APPEND (LIST-AS-COLLECTED-NTH ADDR 32 0)
                                         (LIST-AS-COLLECTED-NTH DATA 32 0))))))
     ((USE (EQUAL-LENGTH-32-AS-COLLECTED-NTH (L ADDR))
           (EQUAL-LENGTH-32-AS-COLLECTED-NTH (L DATA)))
      (DISABLE OPEN-LIST-AS-COLLECTED-NTH)))

(TOGGLE MEM-32X32-ARGS-CROCK-OFF MEM-32X32-ARGS-CROCK T)

(PROVE-LEMMA LIST-32-NTH-COLLAPSE
             (REWRITE)
             (IMPLIES (AND (PROPERP ARGS)
                           (EQUAL (LENGTH ARGS) 32))
                      (EQUAL (LIST (NTH 0 ARGS)
                                   (NTH 1 ARGS)
                                   (NTH 2 ARGS)
                                   (NTH 3 ARGS)
                                   (NTH 4 ARGS)
                                   (NTH 5 ARGS)
                                   (NTH 6 ARGS)
                                   (NTH 7 ARGS)
                                   (NTH 8 ARGS)
                                   (NTH 9 ARGS)
                                   (NTH 10 ARGS)
                                   (NTH 11 ARGS)
                                   (NTH 12 ARGS)
                                   (NTH 13 ARGS)
                                   (NTH 14 ARGS)
                                   (NTH 15 ARGS)
                                   (NTH 16 ARGS)
                                   (NTH 17 ARGS)
                                   (NTH 18 ARGS)
                                   (NTH 19 ARGS)
                                   (NTH 20 ARGS)
                                   (NTH 21 ARGS)
                                   (NTH 22 ARGS)
                                   (NTH 23 ARGS)
                                   (NTH 24 ARGS)
                                   (NTH 25 ARGS)
                                   (NTH 26 ARGS)
                                   (NTH 27 ARGS)
                                   (NTH 28 ARGS)
                                   (NTH 29 ARGS)
                                   (NTH 30 ARGS)
                                   (NTH 31 ARGS))
                             ARGS))
             ((USE (EQUAL-LENGTH-32-AS-COLLECTED-NTH (L ARGS)))))

(TOGGLE LIST-32-NTH-COLLAPSE-OFF LIST-32-NTH-COLLAPSE T)

(PROVE-LEMMA MEM-32X32$STRUCTURED-VALUE-1
            (REWRITE)
            (IMPLIES (AND (MEM-32X32& NETLIST)
                          (EQUAL (LENGTH ADDR) 32)
                          (PROPERP ADDR)
                          (EQUAL (LENGTH DATA) 32)
                          (PROPERP DATA))
                     (EQUAL (DUAL-EVAL 0 'MEM-32X32
                                       (CONS RW-
                                             (CONS STROBE- (APPEND ADDR DATA)))
                                       STATE NETLIST)
                            (MEMORY-VALUE STATE STROBE- RW-
                                          (LIST (NTH 0 ADDR)
                                                (NTH 1 ADDR)
                                                (NTH 2 ADDR)
                                                (NTH 3 ADDR)
                                                (NTH 4 ADDR)
                                                (NTH 5 ADDR)
                                                (NTH 6 ADDR)
                                                (NTH 7 ADDR)
                                                (NTH 8 ADDR)
                                                (NTH 9 ADDR)
                                                (NTH 10 ADDR)
                                                (NTH 11 ADDR)
                                                (NTH 12 ADDR)
                                                (NTH 13 ADDR)
                                                (NTH 14 ADDR)
                                                (NTH 15 ADDR)
                                                (NTH 16 ADDR)
                                                (NTH 17 ADDR)
                                                (NTH 18 ADDR)
                                                (NTH 19 ADDR)
                                                (NTH 20 ADDR)
                                                (NTH 21 ADDR)
                                                (NTH 22 ADDR)
                                                (NTH 23 ADDR)
                                                (NTH 24 ADDR)
                                                (NTH 25 ADDR)
                                                (NTH 26 ADDR)
                                                (NTH 27 ADDR)
                                                (NTH 28 ADDR)
                                                (NTH 29 ADDR)
                                                (NTH 30 ADDR)
                                                (NTH 31 ADDR))
                                          (LIST (NTH 0 DATA)
                                                (NTH 1 DATA)
                                                (NTH 2 DATA)
                                                (NTH 3 DATA)
                                                (NTH 4 DATA)
                                                (NTH 5 DATA)
                                                (NTH 6 DATA)
                                                (NTH 7 DATA)
                                                (NTH 8 DATA)
                                                (NTH 9 DATA)
                                                (NTH 10 DATA)
                                                (NTH 11 DATA)
                                                (NTH 12 DATA)
                                                (NTH 13 DATA)
                                                (NTH 14 DATA)
                                                (NTH 15 DATA)
                                                (NTH 16 DATA)
                                                (NTH 17 DATA)
                                                (NTH 18 DATA)
                                                (NTH 19 DATA)
                                                (NTH 20 DATA)
                                                (NTH 21 DATA)
                                                (NTH 22 DATA)
                                                (NTH 23 DATA)
                                                (NTH 24 DATA)
                                                (NTH 25 DATA)
                                                (NTH 26 DATA)
                                                (NTH 27 DATA)
                                                (NTH 28 DATA)
                                                (NTH 29 DATA)
                                                (NTH 30 DATA)
                                                (NTH 31 DATA)))))
            ((ENABLE MEM-32X32$VALUE MEM-32X32-ARGS-CROCK MEM-VALUE
                     OPEN-SUBRANGE)
             (DISABLE CAR-CDR-ELIM MEMORY-VALUE)))

(TOGGLE MEM-32X32$STRUCTURED-VALUE-1-OFF MEM-32X32$STRUCTURED-VALUE-1 T)

(PROVE-LEMMA MEM-32X32$STRUCTURED-VALUE
            (REWRITE)
            (IMPLIES (AND (MEM-32X32& NETLIST)
                          (EQUAL (LENGTH ADDR) 32)
                          (PROPERP ADDR)
                          (EQUAL (LENGTH DATA) 32)
                          (PROPERP DATA))
                     (EQUAL (DUAL-EVAL 0 'MEM-32X32
                                       (CONS RW-
                                             (CONS STROBE- (APPEND ADDR DATA)))
                                       STATE NETLIST)
                            (MEMORY-VALUE STATE STROBE- RW- ADDR DATA)))
            ((ENABLE MEM-VALUE LIST-32-NTH-COLLAPSE
                     MEM-32X32$STRUCTURED-VALUE-1)
             (DISABLE CAR-CDR-ELIM MEMORY-VALUE)))

(TOGGLE MEM-32X32$STRUCTURED-VALUE-OFF MEM-32X32$STRUCTURED-VALUE T)

(PROVE-LEMMA MEM-32X32$STRUCTURED-STATE-1
            (REWRITE)
            (IMPLIES (AND (MEM-32X32& NETLIST)
                          (EQUAL (LENGTH ADDR) 32)
                          (PROPERP ADDR)
                          (EQUAL (LENGTH DATA) 32)
                          (PROPERP DATA))
                     (EQUAL (DUAL-EVAL 2 'MEM-32X32
                                       (CONS RW-
                                             (CONS STROBE- (APPEND ADDR DATA)))
                                       STATE NETLIST)
                            (NEXT-MEMORY-STATE STATE STROBE- RW-
                                               (LIST (NTH 0 ADDR)
                                                     (NTH 1 ADDR)
                                                     (NTH 2 ADDR)
                                                     (NTH 3 ADDR)
                                                     (NTH 4 ADDR)
                                                     (NTH 5 ADDR)
                                                     (NTH 6 ADDR)
                                                     (NTH 7 ADDR)
                                                     (NTH 8 ADDR)
                                                     (NTH 9 ADDR)
                                                     (NTH 10 ADDR)
                                                     (NTH 11 ADDR)
                                                     (NTH 12 ADDR)
                                                     (NTH 13 ADDR)
                                                     (NTH 14 ADDR)
                                                     (NTH 15 ADDR)
                                                     (NTH 16 ADDR)
                                                     (NTH 17 ADDR)
                                                     (NTH 18 ADDR)
                                                     (NTH 19 ADDR)
                                                     (NTH 20 ADDR)
                                                     (NTH 21 ADDR)
                                                     (NTH 22 ADDR)
                                                     (NTH 23 ADDR)
                                                     (NTH 24 ADDR)
                                                     (NTH 25 ADDR)
                                                     (NTH 26 ADDR)
                                                     (NTH 27 ADDR)
                                                     (NTH 28 ADDR)
                                                     (NTH 29 ADDR)
                                                     (NTH 30 ADDR)
                                                     (NTH 31 ADDR))
                                               (LIST (NTH 0 DATA)
                                                     (NTH 1 DATA)
                                                     (NTH 2 DATA)
                                                     (NTH 3 DATA)
                                                     (NTH 4 DATA)
                                                     (NTH 5 DATA)
                                                     (NTH 6 DATA)
                                                     (NTH 7 DATA)
                                                     (NTH 8 DATA)
                                                     (NTH 9 DATA)
                                                     (NTH 10 DATA)
                                                     (NTH 11 DATA)
                                                     (NTH 12 DATA)
                                                     (NTH 13 DATA)
                                                     (NTH 14 DATA)
                                                     (NTH 15 DATA)
                                                     (NTH 16 DATA)
                                                     (NTH 17 DATA)
                                                     (NTH 18 DATA)
                                                     (NTH 19 DATA)
                                                     (NTH 20 DATA)
                                                     (NTH 21 DATA)
                                                     (NTH 22 DATA)
                                                     (NTH 23 DATA)
                                                     (NTH 24 DATA)
                                                     (NTH 25 DATA)
                                                     (NTH 26 DATA)
                                                     (NTH 27 DATA)
                                                     (NTH 28 DATA)
                                                     (NTH 29 DATA)
                                                     (NTH 30 DATA)
                                                     (NTH 31 DATA)))))
            ((ENABLE MEM-32X32$STATE MEM-32X32-ARGS-CROCK MEM-STATE
                     OPEN-SUBRANGE)
             (DISABLE CAR-CDR-ELIM NEXT-MEMORY-STATE)))

(TOGGLE MEM-32X32$STRUCTURED-STATE-1-OFF MEM-32X32$STRUCTURED-STATE-1 T)

(PROVE-LEMMA MEM-32X32$STRUCTURED-STATE
            (REWRITE)
            (IMPLIES (AND (MEM-32X32& NETLIST)
                          (EQUAL (LENGTH ADDR) 32)
                          (PROPERP ADDR)
                          (EQUAL (LENGTH DATA) 32)
                          (PROPERP DATA))
                     (EQUAL (DUAL-EVAL 2 'MEM-32X32
                                       (CONS RW-
                                             (CONS STROBE- (APPEND ADDR DATA)))
                                       STATE NETLIST)
                            (NEXT-MEMORY-STATE STATE STROBE- RW- ADDR DATA)))
            ((ENABLE MEM-STATE LIST-32-NTH-COLLAPSE
                     MEM-32X32$STRUCTURED-STATE-1)
             (DISABLE CAR-CDR-ELIM MEMORY-VALUE)))

(TOGGLE MEM-32X32$STRUCTURED-STATE-OFF MEM-32X32$STRUCTURED-STATE T)

(DEFN UNBOUND-IN-BODY
      (NAME BODY)
      (IF (NLISTP BODY)
          T
          (AND (NOT (MEMBER NAME
                            (OCC-OUTPUTS (CAR BODY))))
               (UNBOUND-IN-BODY NAME (CDR BODY)))))

(TOGGLE UNBOUND-IN-BODY-OFF UNBOUND-IN-BODY T)

(PROVE-LEMMA UNBOUND-IN-BODY-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP BODY)
                      (UNBOUND-IN-BODY NAME BODY))
             ((ENABLE UNBOUND-IN-BODY)))

(PROVE-LEMMA UNBOUND-IN-BODY-LISTP
             (REWRITE)
             (EQUAL (UNBOUND-IN-BODY NAME
                                     (CONS OCCURRENCE REST))
                    (AND (NOT (MEMBER NAME
                                      (OCC-OUTPUTS OCCURRENCE)))
                         (UNBOUND-IN-BODY NAME REST)))
             ((ENABLE UNBOUND-IN-BODY)))

(DEFN ALL-UNBOUND-IN-BODY
      (NAMES BODY)
      (IF (NLISTP BODY)
          T
          (AND (DISJOINT NAMES
                         (OCC-OUTPUTS (CAR BODY)))
               (ALL-UNBOUND-IN-BODY NAMES
                                    (CDR BODY)))))

(TOGGLE ALL-UNBOUND-IN-BODY-OFF ALL-UNBOUND-IN-BODY T)

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP BODY)
                      (ALL-UNBOUND-IN-BODY NAMES BODY))
             ((ENABLE ALL-UNBOUND-IN-BODY)))

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-LISTP
             (REWRITE)
             (EQUAL (ALL-UNBOUND-IN-BODY NAMES
                                         (CONS OCCURRENCE REST))
                    (AND (DISJOINT NAMES
                                   (OCC-OUTPUTS OCCURRENCE))
                         (ALL-UNBOUND-IN-BODY NAMES REST)))
             ((ENABLE ALL-UNBOUND-IN-BODY)))

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-APPEND
             (REWRITE)
             (EQUAL (ALL-UNBOUND-IN-BODY (APPEND NAMES1 NAMES2)
                                         BODY)
                    (AND (ALL-UNBOUND-IN-BODY NAMES1 BODY)
                         (ALL-UNBOUND-IN-BODY NAMES2 BODY)))
             ((ENABLE ALL-UNBOUND-IN-BODY APPEND)))

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-CONS
             (REWRITE)
             (EQUAL (ALL-UNBOUND-IN-BODY (CONS NAME NAMES)
                                         BODY)
                    (AND (UNBOUND-IN-BODY NAME BODY)
                         (ALL-UNBOUND-IN-BODY NAMES BODY)))
             ((ENABLE ALL-UNBOUND-IN-BODY UNBOUND-IN-BODY APPEND)))

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-NLISTP-NAMES
             (REWRITE)
             (IMPLIES (NLISTP NAMES)
                      (ALL-UNBOUND-IN-BODY NAMES BODY))
             ((ENABLE ALL-UNBOUND-IN-BODY)))

(PROVE-LEMMA UNBOUND-IN-BODY-DUAL-EVAL-1
             (REWRITE)
             (IMPLIES (AND (EQUAL FLAG 1)
                           (UNBOUND-IN-BODY NAME BODY))
                      (EQUAL (VALUE NAME
                                    (DUAL-EVAL FLAG BODY BINDINGS
                                               STATE-BINDINGS NETLIST))
                             (VALUE NAME BINDINGS)))
             ((INDUCT (DUAL-EVAL FLAG BODY BINDINGS STATE-BINDINGS NETLIST))
              (ENABLE UNBOUND-IN-BODY)))

(PROVE-LEMMA ALL-UNBOUND-IN-BODY-DUAL-EVAL-1
             (REWRITE)
             (IMPLIES (AND (EQUAL FLAG 1)
                           (ALL-UNBOUND-IN-BODY NAMES BODY))
                      (EQUAL (COLLECT-VALUE NAMES
                                            (DUAL-EVAL FLAG BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (COLLECT-VALUE NAMES BINDINGS)))
             ((INDUCT (DUAL-EVAL FLAG BODY BINDINGS STATE-BINDINGS NETLIST))
              (ENABLE ALL-UNBOUND-IN-BODY)))

(DEFN VECTOR-MODULE-INDUCTION
      (BODY M N BINDINGS STATE-BINDINGS NETLIST)
      (IF (ZEROP N)
          T
          (VECTOR-MODULE-INDUCTION (CDR BODY)
                                   (ADD1 M)
                                   (SUB1 N)
                                   (DUAL-EVAL-BODY-BINDINGS 1 BODY BINDINGS
                                                            STATE-BINDINGS
                                                            NETLIST)
                                   STATE-BINDINGS NETLIST)))

(DEFN V-BUF$BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Y M))
                      'B-BUF
                      (LIST (INDEX 'A M)))
                (V-BUF$BODY (ADD1 M) (SUB1 N)))))

(TOGGLE V-BUF$BODY-OFF V-BUF$BODY T)

(DEFN V-BUF*
      (N)
      (CONS (INDEX 'V-BUF N)
            (CONS (INDICES 'A 0 N)
                  (CONS (INDICES 'Y 0 N)
                        (CONS (V-BUF$BODY 0 N) '(NIL))))))

(PROVE-LEMMA V-BUF*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-BUF* N))
                         (INDEX 'V-BUF N))
                  (EQUAL (CADR (V-BUF* N))
                         (INDICES 'A 0 N))
                  (EQUAL (CADDR (V-BUF* N))
                         (INDICES 'Y 0 N))
                  (EQUAL (CADDDR (V-BUF* N))
                         (V-BUF$BODY 0 N))
                  (EQUAL (CADDDDR (V-BUF* N)) NIL)))

(TOGGLE V-BUF*-OFF V-BUF* T)

(TOGGLE V-BUF*$DESTRUCTURE-OFF V-BUF*$DESTRUCTURE T)

(DEFN V-BUF&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-BUF N)
                                 NETLIST)
                  (V-BUF* N))
           (B-BUF& (DELETE-MODULE (INDEX 'V-BUF N)
                                  NETLIST))))

(TOGGLE V-BUF&-OFF V-BUF& T)

(DEFN V-BUF$NETLIST
      (N)
      (CONS (V-BUF* N) (B-BUF$NETLIST)))

(PROVE-LEMMA V-BUF$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'Y L)
                                       (V-BUF$BODY M N)))
             ((ENABLE V-BUF$BODY UNBOUND-IN-BODY)))

(TOGGLE V-BUF$UNBOUND-IN-BODY-OFF V-BUF$UNBOUND-IN-BODY T)

(PROVE-LEMMA V-BUF$BODY-VALUE
             (REWRITE)
             (IMPLIES (AND (B-BUF& NETLIST)
                           (EQUAL BODY (V-BUF$BODY M N)))
                      (EQUAL (COLLECT-VALUE (INDICES 'Y M N)
                                            (DUAL-EVAL 1 BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-THREEFIX (COLLECT-VALUE (INDICES 'A M N)
                                                        BINDINGS))))
             ((INDUCT (VECTOR-MODULE-INDUCTION BODY M N BINDINGS
                                               STATE-BINDINGS NETLIST))
              (DISABLE-THEORY F-GATES)
              (ENABLE V-BUF$BODY B-BUF$VALUE V-BUF$UNBOUND-IN-BODY V-THREEFIX
                      F-BUF)))

(TOGGLE V-BUF$BODY-VALUE-OFF V-BUF$BODY-VALUE T)

(PROVE-LEMMA V-BUF$VALUE
             (REWRITE)
             (IMPLIES (AND (V-BUF& NETLIST N)
                           (PROPERP A)
                           (EQUAL (LENGTH A) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-BUF N)
                                        A STATE NETLIST)
                             (V-THREEFIX A)))
             ((ENABLE V-BUF& V-BUF$BODY-VALUE V-BUF*$DESTRUCTURE)))

(TOGGLE V-BUF$VALUE-OFF V-BUF$VALUE T)

(DEFN V-OR$BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Y M))
                      'B-OR
                      (LIST (INDEX 'A M) (INDEX 'B M)))
                (V-OR$BODY (ADD1 M) (SUB1 N)))))

(TOGGLE V-OR$BODY-OFF V-OR$BODY T)

(DEFN V-OR*
      (N)
      (CONS (INDEX 'V-OR N)
            (CONS (APPEND (INDICES 'A 0 N)
                          (INDICES 'B 0 N))
                  (CONS (INDICES 'Y 0 N)
                        (CONS (V-OR$BODY 0 N) '(NIL))))))

(PROVE-LEMMA V-OR*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-OR* N))
                         (INDEX 'V-OR N))
                  (EQUAL (CADR (V-OR* N))
                         (APPEND (INDICES 'A 0 N)
                                 (INDICES 'B 0 N)))
                  (EQUAL (CADDR (V-OR* N))
                         (INDICES 'Y 0 N))
                  (EQUAL (CADDDR (V-OR* N))
                         (V-OR$BODY 0 N))
                  (EQUAL (CADDDDR (V-OR* N)) NIL)))

(TOGGLE V-OR*-OFF V-OR* T)

(TOGGLE V-OR*$DESTRUCTURE-OFF V-OR*$DESTRUCTURE T)

(DEFN V-OR&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-OR N)
                                 NETLIST)
                  (V-OR* N))
           (B-OR& (DELETE-MODULE (INDEX 'V-OR N)
                                 NETLIST))))

(TOGGLE V-OR&-OFF V-OR& T)

(DEFN V-OR$NETLIST
      (N)
      (CONS (V-OR* N) (B-OR$NETLIST)))

(PROVE-LEMMA V-OR$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'Y L)
                                       (V-OR$BODY M N)))
             ((ENABLE V-OR$BODY UNBOUND-IN-BODY)))

(TOGGLE V-OR$UNBOUND-IN-BODY-OFF V-OR$UNBOUND-IN-BODY T)

(PROVE-LEMMA V-OR$BODY-VALUE
             (REWRITE)
             (IMPLIES (AND (B-OR& NETLIST)
                           (EQUAL BODY (V-OR$BODY M N)))
                      (EQUAL (COLLECT-VALUE (INDICES 'Y M N)
                                            (DUAL-EVAL 1 BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (FV-OR (COLLECT-VALUE (INDICES 'A M N)
                                                   BINDINGS)
                                    (COLLECT-VALUE (INDICES 'B M N)
                                                   BINDINGS))))
             ((INDUCT (VECTOR-MODULE-INDUCTION BODY M N BINDINGS
                                               STATE-BINDINGS NETLIST))
              (DISABLE-THEORY F-GATES)
              (ENABLE V-OR$BODY B-OR$VALUE V-OR$UNBOUND-IN-BODY FV-OR)))

(TOGGLE V-OR$BODY-VALUE-OFF V-OR$BODY-VALUE T)

(PROVE-LEMMA V-OR$VALUE
             (REWRITE)
             (IMPLIES (AND (V-OR& NETLIST N)
                           (AND (PROPERP A) (EQUAL (LENGTH A) N))
                           (PROPERP B)
                           (EQUAL (LENGTH B) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-OR N)
                                        (APPEND A B)
                                        STATE NETLIST)
                             (FV-OR A B)))
             ((ENABLE V-OR& V-OR$BODY-VALUE V-OR*$DESTRUCTURE)))

(TOGGLE V-OR$VALUE-OFF V-OR$VALUE T)

(DEFN V-XOR$BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Y M))
                      'B-XOR
                      (LIST (INDEX 'A M) (INDEX 'B M)))
                (V-XOR$BODY (ADD1 M) (SUB1 N)))))

(TOGGLE V-XOR$BODY-OFF V-XOR$BODY T)

(DEFN V-XOR*
      (N)
      (CONS (INDEX 'V-XOR N)
            (CONS (APPEND (INDICES 'A 0 N)
                          (INDICES 'B 0 N))
                  (CONS (INDICES 'Y 0 N)
                        (CONS (V-XOR$BODY 0 N) '(NIL))))))

(PROVE-LEMMA V-XOR*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-XOR* N))
                         (INDEX 'V-XOR N))
                  (EQUAL (CADR (V-XOR* N))
                         (APPEND (INDICES 'A 0 N)
                                 (INDICES 'B 0 N)))
                  (EQUAL (CADDR (V-XOR* N))
                         (INDICES 'Y 0 N))
                  (EQUAL (CADDDR (V-XOR* N))
                         (V-XOR$BODY 0 N))
                  (EQUAL (CADDDDR (V-XOR* N)) NIL)))

(TOGGLE V-XOR*-OFF V-XOR* T)

(TOGGLE V-XOR*$DESTRUCTURE-OFF V-XOR*$DESTRUCTURE T)

(DEFN V-XOR&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-XOR N)
                                 NETLIST)
                  (V-XOR* N))
           (B-XOR& (DELETE-MODULE (INDEX 'V-XOR N)
                                  NETLIST))))

(TOGGLE V-XOR&-OFF V-XOR& T)

(DEFN V-XOR$NETLIST
      (N)
      (CONS (V-XOR* N) (B-XOR$NETLIST)))

(PROVE-LEMMA V-XOR$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'Y L)
                                       (V-XOR$BODY M N)))
             ((ENABLE V-XOR$BODY UNBOUND-IN-BODY)))

(TOGGLE V-XOR$UNBOUND-IN-BODY-OFF V-XOR$UNBOUND-IN-BODY T)

(PROVE-LEMMA V-XOR$BODY-VALUE
             (REWRITE)
             (IMPLIES (AND (B-XOR& NETLIST)
                           (EQUAL BODY (V-XOR$BODY M N)))
                      (EQUAL (COLLECT-VALUE (INDICES 'Y M N)
                                            (DUAL-EVAL 1 BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (FV-XOR (COLLECT-VALUE (INDICES 'A M N)
                                                    BINDINGS)
                                     (COLLECT-VALUE (INDICES 'B M N)
                                                    BINDINGS))))
             ((INDUCT (VECTOR-MODULE-INDUCTION BODY M N BINDINGS
                                               STATE-BINDINGS NETLIST))
              (DISABLE-THEORY F-GATES)
              (ENABLE V-XOR$BODY B-XOR$VALUE V-XOR$UNBOUND-IN-BODY FV-XOR)))

(TOGGLE V-XOR$BODY-VALUE-OFF V-XOR$BODY-VALUE T)

(PROVE-LEMMA V-XOR$VALUE
             (REWRITE)
             (IMPLIES (AND (V-XOR& NETLIST N)
                           (AND (PROPERP A) (EQUAL (LENGTH A) N))
                           (PROPERP B)
                           (EQUAL (LENGTH B) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-XOR N)
                                        (APPEND A B)
                                        STATE NETLIST)
                             (FV-XOR A B)))
             ((ENABLE V-XOR& V-XOR$BODY-VALUE V-XOR*$DESTRUCTURE)))

(TOGGLE V-XOR$VALUE-OFF V-XOR$VALUE T)

(DEFN V-PULLUP$BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Y M))
                      'PULLUP
                      (LIST (INDEX 'A M)))
                (V-PULLUP$BODY (ADD1 M) (SUB1 N)))))

(TOGGLE V-PULLUP$BODY-OFF V-PULLUP$BODY T)

(DEFN V-PULLUP*
      (N)
      (CONS (INDEX 'V-PULLUP N)
            (CONS (INDICES 'A 0 N)
                  (CONS (INDICES 'Y 0 N)
                        (CONS (V-PULLUP$BODY 0 N) '(NIL))))))

(PROVE-LEMMA V-PULLUP*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-PULLUP* N))
                         (INDEX 'V-PULLUP N))
                  (EQUAL (CADR (V-PULLUP* N))
                         (INDICES 'A 0 N))
                  (EQUAL (CADDR (V-PULLUP* N))
                         (INDICES 'Y 0 N))
                  (EQUAL (CADDDR (V-PULLUP* N))
                         (V-PULLUP$BODY 0 N))
                  (EQUAL (CADDDDR (V-PULLUP* N)) NIL)))

(TOGGLE V-PULLUP*-OFF V-PULLUP* T)

(TOGGLE V-PULLUP*$DESTRUCTURE-OFF V-PULLUP*$DESTRUCTURE T)

(DEFN V-PULLUP&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-PULLUP N)
                                 NETLIST)
                  (V-PULLUP* N))
           (PULLUP& (DELETE-MODULE (INDEX 'V-PULLUP N)
                                   NETLIST))))

(TOGGLE V-PULLUP&-OFF V-PULLUP& T)

(DEFN V-PULLUP$NETLIST
      (N)
      (CONS (V-PULLUP* N) (PULLUP$NETLIST)))

(PROVE-LEMMA V-PULLUP$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'Y L)
                                       (V-PULLUP$BODY M N)))
             ((ENABLE V-PULLUP$BODY UNBOUND-IN-BODY)))

(TOGGLE V-PULLUP$UNBOUND-IN-BODY-OFF V-PULLUP$UNBOUND-IN-BODY T)

(PROVE-LEMMA V-PULLUP$BODY-VALUE
             (REWRITE)
             (IMPLIES (AND (PULLUP& NETLIST)
                           (EQUAL BODY (V-PULLUP$BODY M N)))
                      (EQUAL (COLLECT-VALUE (INDICES 'Y M N)
                                            (DUAL-EVAL 1 BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-PULLUP (COLLECT-VALUE (INDICES 'A M N)
                                                      BINDINGS))))
             ((INDUCT (VECTOR-MODULE-INDUCTION BODY M N BINDINGS
                                               STATE-BINDINGS NETLIST))
              (DISABLE-THEORY F-GATES)
              (ENABLE V-PULLUP$BODY PULLUP$VALUE V-PULLUP$UNBOUND-IN-BODY
                      V-PULLUP)))

(TOGGLE V-PULLUP$BODY-VALUE-OFF V-PULLUP$BODY-VALUE T)

(PROVE-LEMMA V-PULLUP$VALUE
             (REWRITE)
             (IMPLIES (AND (V-PULLUP& NETLIST N)
                           (PROPERP A)
                           (EQUAL (LENGTH A) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-PULLUP N)
                                        A STATE NETLIST)
                             (V-PULLUP A)))
             ((ENABLE V-PULLUP& V-PULLUP$BODY-VALUE V-PULLUP*$DESTRUCTURE)))

(TOGGLE V-PULLUP$VALUE-OFF V-PULLUP$VALUE T)

(DEFN V-WIRE$BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Y M))
                      'T-WIRE
                      (LIST (INDEX 'A M) (INDEX 'B M)))
                (V-WIRE$BODY (ADD1 M) (SUB1 N)))))

(TOGGLE V-WIRE$BODY-OFF V-WIRE$BODY T)

(DEFN V-WIRE*
      (N)
      (CONS (INDEX 'V-WIRE N)
            (CONS (APPEND (INDICES 'A 0 N)
                          (INDICES 'B 0 N))
                  (CONS (INDICES 'Y 0 N)
                        (CONS (V-WIRE$BODY 0 N) '(NIL))))))

(PROVE-LEMMA V-WIRE*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-WIRE* N))
                         (INDEX 'V-WIRE N))
                  (EQUAL (CADR (V-WIRE* N))
                         (APPEND (INDICES 'A 0 N)
                                 (INDICES 'B 0 N)))
                  (EQUAL (CADDR (V-WIRE* N))
                         (INDICES 'Y 0 N))
                  (EQUAL (CADDDR (V-WIRE* N))
                         (V-WIRE$BODY 0 N))
                  (EQUAL (CADDDDR (V-WIRE* N)) NIL)))

(TOGGLE V-WIRE*-OFF V-WIRE* T)

(TOGGLE V-WIRE*$DESTRUCTURE-OFF V-WIRE*$DESTRUCTURE T)

(DEFN V-WIRE&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-WIRE N)
                                 NETLIST)
                  (V-WIRE* N))
           (T-WIRE& (DELETE-MODULE (INDEX 'V-WIRE N)
                                   NETLIST))))

(TOGGLE V-WIRE&-OFF V-WIRE& T)

(DEFN V-WIRE$NETLIST
      (N)
      (CONS (V-WIRE* N) (T-WIRE$NETLIST)))

(PROVE-LEMMA V-WIRE$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'Y L)
                                       (V-WIRE$BODY M N)))
             ((ENABLE V-WIRE$BODY UNBOUND-IN-BODY)))

(TOGGLE V-WIRE$UNBOUND-IN-BODY-OFF V-WIRE$UNBOUND-IN-BODY T)

(PROVE-LEMMA V-WIRE$BODY-VALUE
             (REWRITE)
             (IMPLIES (AND (T-WIRE& NETLIST)
                           (EQUAL BODY (V-WIRE$BODY M N)))
                      (EQUAL (COLLECT-VALUE (INDICES 'Y M N)
                                            (DUAL-EVAL 1 BODY BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-WIRE (COLLECT-VALUE (INDICES 'A M N)
                                                    BINDINGS)
                                     (COLLECT-VALUE (INDICES 'B M N)
                                                    BINDINGS))))
             ((INDUCT (VECTOR-MODULE-INDUCTION BODY M N BINDINGS
                                               STATE-BINDINGS NETLIST))
              (DISABLE-THEORY F-GATES)
              (ENABLE V-WIRE$BODY T-WIRE$VALUE V-WIRE$UNBOUND-IN-BODY V-WIRE)))

(TOGGLE V-WIRE$BODY-VALUE-OFF V-WIRE$BODY-VALUE T)

(PROVE-LEMMA V-WIRE$VALUE
             (REWRITE)
             (IMPLIES (AND (V-WIRE& NETLIST N)
                           (AND (PROPERP A) (EQUAL (LENGTH A) N))
                           (PROPERP B)
                           (EQUAL (LENGTH B) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-WIRE N)
                                        (APPEND A B)
                                        STATE NETLIST)
                             (V-WIRE A B)))
             ((ENABLE V-WIRE& V-WIRE$BODY-VALUE V-WIRE*$DESTRUCTURE)))

(TOGGLE V-WIRE$VALUE-OFF V-WIRE$VALUE T)

(DEFN REV-0 (X) (REV1 X 0))

(DEFN NUMBER-TO-DIGIT
      (NUMBER)
      (NTH NUMBER
           (CDR (UNPACK 'A0123456789))))

(DEFN NUMBER-TO-LIST1
      (NUMBER)
      (IF (ZEROP NUMBER)
          0
          (CONS (NUMBER-TO-DIGIT (REMAINDER NUMBER 10))
                (NUMBER-TO-LIST1 (QUOTIENT NUMBER 10)))))

(DEFN NUMBER-TO-LIST
      (NUMBER)
      (IF (ZEROP NUMBER)
          (CONS (CADR (UNPACK 'A0)) 0)
          (REV-0 (NUMBER-TO-LIST1 NUMBER))))

(DEFN LISP-NETLIST
      (NETLIST)
      (COND ((INDEXP NETLIST)
             (PACK (APPEND (UNPACK (I-NAME NETLIST))
                           (CONS (CADR (UNPACK 'A_))
                                 (NUMBER-TO-LIST (I-NUM NETLIST))))))
            ((NLISTP NETLIST) NETLIST)
            (T (CONS (LISP-NETLIST (CAR NETLIST))
                     (LISP-NETLIST (CDR NETLIST))))))

(DEFN COLLECT-PRIMITIVES
 (FLG X0 NETLIST)
 (CASE FLG
  (0
   (IF
    (OR (PRIMP X0)
        (NOT (LOOKUP-MODULE X0 NETLIST)))
    (LIST X0)
    (FLATTEN-LIST
            (COLLECT-PRIMITIVES 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                (DELETE-MODULE X0 NETLIST)))))
  (1 (IF (NLISTP X0)
         NIL
         (CONS (COLLECT-PRIMITIVES 0
                                   (OCC-FUNCTION (CAR X0))
                                   NETLIST)
               (COLLECT-PRIMITIVES 1
                                   (CDR X0)
                                   NETLIST))))
  (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(DEFN COUNT-PRIMITIVES
 (FLG X0 X1 TYPE NETLIST)
 (CASE FLG
    (0 (COND ((PRIMP X0)
              (IF (PRIMP-LOOKUP X0 TYPE)
                  (PRIMP2 X0 TYPE)
                  F))
             ((LISTP (LOOKUP-MODULE X0 NETLIST))
              (COUNT-PRIMITIVES 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE X0 NETLIST))
                                0 TYPE
                                (DELETE-MODULE X0 NETLIST)))
             (T F)))
    (1 (COND ((NLISTP X0) X1)
             ((COUNT-PRIMITIVES 0
                                (OCC-FUNCTION (CAR X0))
                                NIL TYPE NETLIST)
              (COUNT-PRIMITIVES 1
                                (CDR X0)
                                (PLUS X1
                                      (COUNT-PRIMITIVES 0
                                                        (OCC-FUNCTION (CAR X0))
                                                        NIL TYPE NETLIST))
                                TYPE NETLIST))
             (T F)))
    (OTHERWISE F))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT X0)))))

(TOGGLE COUNT-PRIMITIVES-OFF COUNT-PRIMITIVES T)

(DEFN HALF-ADDER* NIL
      '(HALF-ADDER (A B)
                   (SUM CARRY)
                   ((G0 (SUM) B-XOR (A B))
                    (G1 (CARRY) B-AND (A B)))
                   NIL))

(DEFN HALF-ADDER$NETLIST NIL
      (CONS (HALF-ADDER*)
            (UNION (B-XOR$NETLIST)
                   (B-AND$NETLIST))))

(DEFN HALF-ADDER&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'HALF-ADDER NETLIST)
                  (HALF-ADDER*))
           (B-XOR& (DELETE-MODULE 'HALF-ADDER NETLIST))
           (B-AND& (DELETE-MODULE 'HALF-ADDER
                                  NETLIST))))

(TOGGLE HALF-ADDER&-OFF HALF-ADDER& T)

(PROVE-LEMMA HALF-ADDER$VALUE
             (REWRITE)
             (IMPLIES (HALF-ADDER& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'HALF-ADDER
                                        (LIST A B)
                                        STATE NETLIST)
                             (LIST (F-XOR A B) (F-AND A B))))
             ((ENABLE HALF-ADDER& B-XOR$VALUE B-AND$VALUE)))

(TOGGLE HALF-ADDER$VALUE-OFF HALF-ADDER$VALUE T)

(DEFN FULL-ADDER* NIL
      '(FULL-ADDER (A B C)
                   (SUM CARRY)
                   ((T0 (SUM1 CARRY1) HALF-ADDER (A B))
                    (T1 (SUM CARRY2) HALF-ADDER (SUM1 C))
                    (T2 (CARRY) B-OR (CARRY1 CARRY2)))
                   NIL))

(DEFN FULL-ADDER$NETLIST NIL
      (CONS (FULL-ADDER*)
            (UNION (HALF-ADDER$NETLIST)
                   (B-OR$NETLIST))))

(DEFN FULL-ADDER&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'FULL-ADDER NETLIST)
                  (FULL-ADDER*))
           (HALF-ADDER& (DELETE-MODULE 'FULL-ADDER NETLIST))
           (B-OR& (DELETE-MODULE 'FULL-ADDER
                                 NETLIST))))

(TOGGLE FULL-ADDER&-OFF FULL-ADDER& T)

(DEFN F$FULL-ADDER
      (A B C)
      (LIST (F-XOR (F-XOR A B) C)
            (F-OR (F-AND A B)
                  (F-AND (F-XOR A B) C))))

(PROVE-LEMMA FULL-ADDER$VALUE
             (REWRITE)
             (IMPLIES (FULL-ADDER& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FULL-ADDER
                                        (LIST A B C)
                                        STATE NETLIST)
                             (F$FULL-ADDER A B C)))
             ((ENABLE FULL-ADDER& HALF-ADDER$VALUE B-OR$VALUE)))

(DEFN FULL-ADDER
      (A B C)
      (LIST (B-XOR3 A B C)
            (B-OR (B-AND A (B-OR B C))
                  (B-AND B C))))

(PROVE-LEMMA F$FULL-ADDER=FULL-ADDER
             (REWRITE)
             (IMPLIES (AND (BOOLP A) (BOOLP B) (BOOLP C))
                      (EQUAL (F$FULL-ADDER A B C)
                             (FULL-ADDER A B C))))

(DEFN M1* NIL
      '(M1 (CLK EN SEL D Q)
           (Q)
           ((MUX (B) B-IF (SEL D Q))
            (LATCH (A AN) FD1 (B CLK))
            (TBUF (Q) T-BUF (EN A)))
           LATCH))

(DEFN M1$NETLIST NIL
      (CONS (M1*)
            (UNION (UNION (B-IF$NETLIST) (FD1$NETLIST))
                   (T-BUF$NETLIST))))

(DEFN M1&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'M1 NETLIST)
                  (M1*))
           (B-IF& (DELETE-MODULE 'M1 NETLIST))
           (FD1& (DELETE-MODULE 'M1 NETLIST))
           (T-BUF& (DELETE-MODULE 'M1 NETLIST))))

(TOGGLE M1&-OFF M1& T)

(PROVE-LEMMA M1$VALUE
             (REWRITE)
             (IMPLIES (M1& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'M1
                                        (LIST CLK EN SEL D Q)
                                        STATE NETLIST)
                             (LIST (FT-BUF EN STATE))))
             ((ENABLE M1& B-IF$VALUE FD1$VALUE T-BUF$VALUE FT-BUF F-BUF)))

(TOGGLE M1$VALUE-OFF M1$VALUE T)

(PROVE-LEMMA M1$STATE
             (REWRITE)
             (IMPLIES (M1& NETLIST)
                      (EQUAL (DUAL-EVAL 2 'M1
                                        (LIST CLK EN SEL D Q)
                                        STATE NETLIST)
                             (F-IF SEL D Q)))
             ((ENABLE M1& B-IF$VALUE FD1$VALUE FD1$STATE T-BUF$VALUE F-IF
                      FT-BUF F-BUF)))

(TOGGLE M1$STATE-OFF M1$STATE T)

(DEFN M2* NIL
      '(M2 (CLK EN0 EN1 SEL0 SEL1 D0 D1)
           (Q)
           ((OCC0 (Q0) M1 (CLK EN0 SEL0 D0 Q))
            (OCC1 (Q1) M1 (CLK EN1 SEL1 D1 Q))
            (WIRE (Q) T-WIRE (Q0 Q1)))
           (OCC0 OCC1)))

(DEFN M2$NETLIST NIL
      (CONS (M2*)
            (UNION (M1$NETLIST)
                   (T-WIRE$NETLIST))))

(DEFN M2&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'M2 NETLIST)
                  (M2*))
           (M1& (DELETE-MODULE 'M2 NETLIST))
           (T-WIRE& (DELETE-MODULE 'M2 NETLIST))))

(TOGGLE M2&-OFF M2& T)

(PROVE-LEMMA M2$VALUE
             (REWRITE)
             (IMPLIES (M2& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'M2
                                        (LIST CLK EN0 EN1 SEL0 SEL1 D0 D1)
                                        STATE NETLIST)
                             (LIST (FT-WIRE (FT-BUF EN0 (CAR STATE))
                                            (FT-BUF EN1 (CADR STATE))))))
             ((ENABLE M2& M1$VALUE M1$STATE T-WIRE$VALUE)))

(TOGGLE M2$VALUE-OFF M2$VALUE T)

(PROVE-LEMMA M2$STATE
            (REWRITE)
            (IMPLIES (M2& NETLIST)
                     (EQUAL (DUAL-EVAL 2 'M2
                                       (LIST CLK EN0 EN1 SEL0 SEL1 D0 D1)
                                       STATE NETLIST)
                            (LIST (F-IF SEL0 D0
                                        (FT-WIRE (FT-BUF EN0 (CAR STATE))
                                                 (FT-BUF EN1 (CADR STATE))))
                                  (F-IF SEL1 D1
                                        (FT-WIRE (FT-BUF EN0 (CAR STATE))
                                                 (FT-BUF EN1 (CADR STATE)))))))
            ((ENABLE M2& M1$VALUE M1$STATE T-WIRE$VALUE)))

(TOGGLE M2$STATE-OFF M2$STATE T)

(DEFN BV-ADDER
      (C A B)
      (IF (NLISTP A)
          (LIST C)
          (CONS (XOR C (XOR (CAR A) (CAR B)))
                (BV-ADDER (OR (AND (CAR A) (CAR B))
                              (AND (CAR A) C)
                              (AND (CAR B) C))
                          (CDR A)
                          (CDR B)))))

(DEFN BV-ADDER-BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'SUM M)
                            (INDEX 'CARRY (ADD1 M)))
                      'FULL-ADDER
                      (LIST (INDEX 'A M)
                            (INDEX 'B M)
                            (INDEX 'CARRY M)))
                (BV-ADDER-BODY (ADD1 M) (SUB1 N)))))

(TOGGLE BV-ADDER-BODY-OFF BV-ADDER-BODY T)

(DEFN BV-ADDER*
      (N)
      (CONS (INDEX 'BV-ADDER N)
            (CONS (CONS (INDEX 'CARRY 0)
                        (APPEND (INDICES 'A 0 N)
                                (INDICES 'B 0 N)))
                  (CONS (APPEND (INDICES 'SUM 0 N)
                                (LIST (INDEX 'CARRY N)))
                        (CONS (BV-ADDER-BODY 0 N) '(NIL))))))

(PROVE-LEMMA BV-ADDER*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (BV-ADDER* N))
                         (INDEX 'BV-ADDER N))
                  (EQUAL (CADR (BV-ADDER* N))
                         (CONS (INDEX 'CARRY 0)
                               (APPEND (INDICES 'A 0 N)
                                       (INDICES 'B 0 N))))
                  (EQUAL (CADDR (BV-ADDER* N))
                         (APPEND (INDICES 'SUM 0 N)
                                 (LIST (INDEX 'CARRY N))))
                  (EQUAL (CADDDR (BV-ADDER* N))
                         (BV-ADDER-BODY 0 N))
                  (EQUAL (CADDDDR (BV-ADDER* N)) NIL)))

(TOGGLE BV-ADDER*-OFF BV-ADDER* T)

(TOGGLE BV-ADDER*$DESTRUCTURE-OFF BV-ADDER*$DESTRUCTURE T)

(DEFN BV-ADDER&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'BV-ADDER N)
                                 NETLIST)
                  (BV-ADDER* N))
           (FULL-ADDER& (DELETE-MODULE (INDEX 'BV-ADDER N)
                                       NETLIST))))

(TOGGLE BV-ADDER&-OFF BV-ADDER& T)

(DEFN BV-ADDER$NETLIST
      (N)
      (CONS (BV-ADDER* N)
            (FULL-ADDER$NETLIST)))

(TOGGLE BV-ADDER$NETLIST-OFF BV-ADDER$NETLIST T)

(DEFN BV-ADDER-BODY$INDUCTION
 (M N BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  BINDINGS
  (BV-ADDER-BODY$INDUCTION
           (ADD1 M)
           (SUB1 N)
           (APPEND (PAIRLIST (LIST (INDEX 'SUM M)
                                   (INDEX 'CARRY (ADD1 M)))
                             (DUAL-EVAL 0 'FULL-ADDER
                                        (COLLECT-VALUE (LIST (INDEX 'A M)
                                                             (INDEX 'B M)
                                                             (INDEX 'CARRY M))
                                                       BINDINGS)
                                        (VALUE (INDEX 'G M) STATE-BINDINGS)
                                        NETLIST))
                   BINDINGS)
           STATE-BINDINGS NETLIST)))

(PROVE-LEMMA BV-ADDER$UNBOUND-IN-BODY-SUM
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'SUM L)
                                       (BV-ADDER-BODY M N)))
             ((ENABLE UNBOUND-IN-BODY BV-ADDER-BODY)))

(PROVE-LEMMA BV-ADDER$UNBOUND-IN-BODY-CARRY
             (REWRITE)
             (IMPLIES (LESSP L (ADD1 M))
                      (UNBOUND-IN-BODY (INDEX 'CARRY L)
                                       (BV-ADDER-BODY M N)))
             ((ENABLE UNBOUND-IN-BODY BV-ADDER-BODY)))

(TOGGLE BV-ADDER$UNBOUND-IN-BODY-SUM-OFF BV-ADDER$UNBOUND-IN-BODY-SUM T)

(TOGGLE BV-ADDER$UNBOUND-IN-BODY-CARRY-OFF BV-ADDER$UNBOUND-IN-BODY-CARRY T)

(PROVE-LEMMA BV-ADDER-BODY$VALUE
      (REWRITE)
      (IMPLIES (AND (FULL-ADDER& NETLIST)
                    (BOOLP (VALUE (INDEX 'CARRY M) BINDINGS))
                    (BVP (COLLECT-VALUE (INDICES 'A M N)
                                        BINDINGS))
                    (BVP (COLLECT-VALUE (INDICES 'B M N)
                                        BINDINGS)))
               (EQUAL (COLLECT-VALUE (APPEND (INDICES 'SUM M N)
                                             (LIST (INDEX 'CARRY (PLUS N M))))
                                     (DUAL-EVAL 1
                                                (BV-ADDER-BODY M N)
                                                BINDINGS STATE-BINDINGS
                                                NETLIST))
                      (BV-ADDER (VALUE (INDEX 'CARRY M) BINDINGS)
                                (COLLECT-VALUE (INDICES 'A M N)
                                               BINDINGS)
                                (COLLECT-VALUE (INDICES 'B M N)
                                               BINDINGS))))
      ((ENABLE BV-ADDER-BODY FULL-ADDER$VALUE MAKE-LIST FV-IF-REWRITE
               BV-ADDER$UNBOUND-IN-BODY-SUM BV-ADDER$UNBOUND-IN-BODY-CARRY)
       (INDUCT (BV-ADDER-BODY$INDUCTION M N BINDINGS STATE-BINDINGS NETLIST))))

(PROVE-LEMMA BV-ADDER-BODY-SPECIAL-CASE$VALUE
             (REWRITE)
             (IMPLIES (AND (FULL-ADDER& NETLIST)
                           (BOOLP (VALUE (INDEX 'CARRY 0) BINDINGS))
                           (BVP (COLLECT-VALUE (INDICES 'A 0 N)
                                               BINDINGS))
                           (BVP (COLLECT-VALUE (INDICES 'B 0 N)
                                               BINDINGS)))
                      (EQUAL (COLLECT-VALUE (APPEND (INDICES 'SUM 0 N)
                                                    (LIST (INDEX 'CARRY N)))
                                            (DUAL-EVAL 1
                                                       (BV-ADDER-BODY 0 N)
                                                       BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (BV-ADDER (VALUE (INDEX 'CARRY 0) BINDINGS)
                                       (COLLECT-VALUE (INDICES 'A 0 N)
                                                      BINDINGS)
                                       (COLLECT-VALUE (INDICES 'B 0 N)
                                                      BINDINGS))))
             ((USE (BV-ADDER-BODY$VALUE (M 0)))))

(PROVE-LEMMA BV-ADDER$VALUE
             (REWRITE)
             (IMPLIES (AND (BV-ADDER& NETLIST N)
                           (BOOLP C)
                           (BVP A)
                           (BVP B)
                           (EQUAL (LENGTH A) N)
                           (EQUAL (LENGTH B) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'BV-ADDER N)
                                        (CONS C (APPEND A B))
                                        STATE NETLIST)
                             (BV-ADDER C A B)))
             ((ENABLE BV-ADDER& BV-ADDER*$DESTRUCTURE FULL-ADDER$VALUE)
              (DISABLE COLLECT-VALUE-APPEND)))

(TOGGLE BV-ADDER-BODY-SPECIAL-CASE$VALUE-OFF BV-ADDER-BODY-SPECIAL-CASE$VALUE T)

(TOGGLE BV-ADDER-BODY$VALUE-OFF BV-ADDER-BODY$VALUE T)

(TOGGLE BV-ADDER$VALUE-OFF BV-ADDER$VALUE T)

(DEFN V-SUM
      (C A B)
      (IF (NLISTP A)
          NIL
          (CONS (B-XOR C (B-XOR (CAR A) (CAR B)))
                (V-SUM (B-OR3 (B-AND (CAR A) (CAR B))
                              (B-AND (CAR A) C)
                              (B-AND (CAR B) C))
                       (CDR A)
                       (CDR B)))))

(TOGGLE V-SUM-OFF V-SUM T)

(PROVE-LEMMA BVP-SUM
             (REWRITE)
             (BVP (V-SUM C A B))
             ((ENABLE BVP V-SUM)))

(PROVE-LEMMA LENGTH-SUM
             (REWRITE)
             (EQUAL (LENGTH (V-SUM C A B))
                    (LENGTH A))
             ((ENABLE LENGTH V-SUM)))

(PROVE-LEMMA V-SUM-CONGRUENCE
             (REWRITE)
             (IMPLIES C
                      (EQUAL (EQUAL (V-SUM C A B) (V-SUM T A B))
                             T))
             ((ENABLE V-SUM)))

(PROVE-LEMMA A-1+1=A
             (REWRITE)
             (IMPLIES (AND (BVP A) C)
                      (EQUAL (V-SUM C
                                    (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                    A)
                             A))
             ((ENABLE V-SUM V-NOT NAT-TO-V LENGTH)))

(DEFN V-CARRY
      (C A B)
      (IF (NLISTP A)
          (BOOLFIX C)
          (V-CARRY (OR (AND (CAR A) (CAR B))
                       (AND (OR (CAR A) (CAR B)) C))
                   (CDR A)
                   (CDR B))))

(TOGGLE V-CARRY-OFF V-CARRY T)

(DEFN V-PROPAGATE
      (A B)
      (IF (NLISTP A)
          T
          (AND (OR (CAR A) (CAR B))
               (V-PROPAGATE (CDR A) (CDR B)))))

(TOGGLE V-PROPAGATE-OFF V-PROPAGATE T)

(DEFN V-GENERATE
      (A B)
      (IF (NLISTP A)
          F
          (OR (V-GENERATE (CDR A) (CDR B))
              (AND (CAR A)
                   (CAR B)
                   (V-PROPAGATE (CDR A) (CDR B))))))

(TOGGLE V-GENERATE-OFF V-GENERATE T)

(DEFN F$T-CARRY
      (C PROP GEN)
      (F-OR (F-AND C PROP) GEN))

(TOGGLE F$T-CARRY-OFF F$T-CARRY T)

(DEFN T-CARRY
      (C PROP GEN)
      (B-NOT (AO6 C PROP GEN)))

(TOGGLE T-CARRY-OFF T-CARRY T)

(PROVE-LEMMA F$T-CARRY=T-CARRY
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BOOLP PROP)
                           (BOOLP GEN))
                      (EQUAL (F$T-CARRY C PROP GEN)
                             (T-CARRY C PROP GEN)))
             ((ENABLE F$T-CARRY T-CARRY)))

(PROVE-LEMMA T-CARRY-CONGRUENCE
             (REWRITE)
             (IMPLIES X
                      (EQUAL (EQUAL (T-CARRY X P G)
                                    (T-CARRY T P G))
                             T))
             ((ENABLE T-CARRY)))

(DEFN T-CARRY* NIL
      '(T-CARRY (C PROP GEN)
                (Z)
                ((G0 (Z-) AO6 (C PROP GEN))
                 (G1 (Z) B-NOT (Z-)))
                NIL))

(DEFN T-CARRY&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'T-CARRY NETLIST)
                  (T-CARRY*))
           (AO6& (DELETE-MODULE 'T-CARRY NETLIST))
           (B-NOT& (DELETE-MODULE 'T-CARRY NETLIST))))

(TOGGLE T-CARRY&-OFF T-CARRY& T)

(DEFN T-CARRY$NETLIST NIL
      (CONS (T-CARRY*)
            (UNION (AO6$NETLIST)
                   (B-NOT$NETLIST))))

(PROVE-LEMMA T-CARRY$VALUE
             (REWRITE)
             (IMPLIES (T-CARRY& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'T-CARRY
                                        (LIST C PROP GEN)
                                        STATE NETLIST)
                             (LIST (F$T-CARRY C PROP GEN))))
             ((ENABLE T-CARRY& F$T-CARRY B-NOT$VALUE AO6$VALUE)))

(TOGGLE T-CARRY$VALUE-OFF T-CARRY$VALUE T)

(PROVE-LEMMA V-APPEND-PROPAGATE
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH C))
                      (EQUAL (V-PROPAGATE (APPEND A B)
                                          (APPEND C D))
                             (AND (V-PROPAGATE A C)
                                  (V-PROPAGATE B D))))
             ((ENABLE LENGTH V-PROPAGATE APPEND)))

(PROVE-LEMMA V-PROPAGATE-APPEND
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH C))
                      (EQUAL (B-AND (V-PROPAGATE A C)
                                    (V-PROPAGATE B D))
                             (V-PROPAGATE (APPEND A B)
                                          (APPEND C D)))))

(TOGGLE V-PROPAGATE-APPEND-OFF V-PROPAGATE-APPEND T)

(PROVE-LEMMA GENERATE-APPEND
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (LENGTH C))
                      (EQUAL (T-CARRY (V-GENERATE A C)
                                      (V-PROPAGATE B D)
                                      (V-GENERATE B D))
                             (V-GENERATE (APPEND A B)
                                         (APPEND C D))))
             ((ENABLE LENGTH T-CARRY V-GENERATE V-PROPAGATE APPEND)))

(PROVE-LEMMA APPEND-SUM
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (LENGTH B))
                           (EQUAL C2 (V-CARRY C1 A B)))
                      (EQUAL (APPEND (V-SUM C1 A B) (V-SUM C2 C D))
                             (V-SUM C1 (APPEND A C) (APPEND B D))))
             ((ENABLE LENGTH V-CARRY APPEND V-SUM BOOLFIX)))

(PROVE-LEMMA T-CARRY-P-G-CARRY
             (REWRITE)
             (EQUAL (T-CARRY C
                             (V-PROPAGATE A B)
                             (V-GENERATE A B))
                    (V-CARRY C A B))
             ((ENABLE T-CARRY V-PROPAGATE V-GENERATE V-CARRY BOOLFIX)))

(PROVE-LEMMA V-ADDER-OUTPUT=V-SUM
             (REWRITE)
             (EQUAL (V-ADDER-OUTPUT C A B)
                    (V-SUM C A B))
             ((ENABLE V-ADDER V-SUM FIRSTN LENGTH)))

(PROVE-LEMMA V-ADDER-CARRY-OUT=V-CARRY
             (REWRITE)
             (EQUAL (V-ADDER-CARRY-OUT C A B)
                    (V-CARRY C A B))
             ((ENABLE V-ADDER V-CARRY NTH RESTN LENGTH)))

(DEFN TV-ADDER
 (C A B TREE)
 (IF
  (NLISTP TREE)
  (LIST (B-OR (CAR A) (CAR B))
        (B-AND (CAR A) (CAR B))
        (B-XOR (CAR A) (B-XOR (CAR B) C)))
  (CONS
       (B-AND (CAR (TV-ADDER C
                             (TFIRSTN A TREE)
                             (TFIRSTN B TREE)
                             (CAR TREE)))
              (CAR (TV-ADDER (T-CARRY C
                                      (CAR (TV-ADDER C
                                                     (TFIRSTN A TREE)
                                                     (TFIRSTN B TREE)
                                                     (CAR TREE)))
                                      (CADR (TV-ADDER C
                                                      (TFIRSTN A TREE)
                                                      (TFIRSTN B TREE)
                                                      (CAR TREE))))
                             (TRESTN A TREE)
                             (TRESTN B TREE)
                             (CDR TREE))))
       (CONS (T-CARRY (CADR (TV-ADDER C
                                      (TFIRSTN A TREE)
                                      (TFIRSTN B TREE)
                                      (CAR TREE)))
                      (CAR (TV-ADDER (T-CARRY C
                                              (CAR (TV-ADDER C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             (CAR TREE)))
                                              (CADR (TV-ADDER C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              (CAR TREE))))
                                     (TRESTN A TREE)
                                     (TRESTN B TREE)
                                     (CDR TREE)))
                      (CADR (TV-ADDER (T-CARRY C
                                               (CAR (TV-ADDER C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              (CAR TREE)))
                                               (CADR (TV-ADDER C
                                                               (TFIRSTN A TREE)
                                                               (TFIRSTN B TREE)
                                                               (CAR TREE))))
                                      (TRESTN A TREE)
                                      (TRESTN B TREE)
                                      (CDR TREE))))
             (APPEND (CDDR (TV-ADDER C
                                     (TFIRSTN A TREE)
                                     (TFIRSTN B TREE)
                                     (CAR TREE)))
                     (CDDR (TV-ADDER (T-CARRY C
                                              (CAR (TV-ADDER C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             (CAR TREE)))
                                              (CADR (TV-ADDER C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              (CAR TREE))))
                                     (TRESTN A TREE)
                                     (TRESTN B TREE)
                                     (CDR TREE))))))))

(TOGGLE TV-ADDER-OFF TV-ADDER T)

(PROVE-LEMMA CAR-TV-ADDER-AS-P
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (CAR (TV-ADDER C A B TREE))
                             (V-PROPAGATE A B)))
             ((INDUCT (TV-ADDER C A B TREE))
              (DISABLE B-AND V-APPEND-PROPAGATE)
              (ENABLE V-PROPAGATE-APPEND V-PROPAGATE)
              (EXPAND (TV-ADDER C A B TREE))))

(PROVE-LEMMA CADR-TV-ADDER-AS-G
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (CADR (TV-ADDER C A B TREE))
                             (V-GENERATE A B)))
             ((INDUCT (TV-ADDER C A B TREE))
              (DISABLE B-AND V-APPEND-PROPAGATE T-CARRY-P-G-CARRY)
              (ENABLE V-PROPAGATE V-GENERATE V-PROPAGATE-APPEND)
              (EXPAND (TV-ADDER C A B TREE))))

(PROVE-LEMMA CDDR-TV-ADDER-AS-SUM
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (CDDR (TV-ADDER C A B TREE))
                             (V-SUM C A B)))
             ((INDUCT (TV-ADDER C A B TREE))
              (DISABLE B-AND T-CARRY V-APPEND-PROPAGATE)
              (ENABLE V-SUM V-PROPAGATE-APPEND)
              (EXPAND (TV-ADDER C A B TREE))))

(PROVE-LEMMA EQUALITY-OF-THREE-ELEMENT-LISTS NIL
             (IMPLIES (AND (NOT (EQUAL X 0))
                           (NOT (EQUAL Y 0))
                           (NOT (EQUAL Z 0)))
                      (EQUAL (EQUAL W (CONS X (CONS Y Z)))
                             (AND (EQUAL (CAR W) X)
                                  (EQUAL (CADR W) Y)
                                  (EQUAL (CDDR W) Z)))))

(PROVE-LEMMA TV-ADDER-AS-P-G-SUM
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (TV-ADDER C A B TREE)
                             (CONS (V-PROPAGATE A B)
                                   (CONS (V-GENERATE A B)
                                         (V-SUM C A B)))))
             ((DISABLE TV-ADDER BOOLP)
              (USE (EQUALITY-OF-THREE-ELEMENT-LISTS (W (TV-ADDER C A B TREE))
                                                    (X (V-PROPAGATE A B))
                                                    (Y (V-GENERATE A B))
                                                    (Z (V-SUM C A B))))))

(TOGGLE CAR-TV-ADDER-AS-P-OFF CAR-TV-ADDER-AS-P T)

(TOGGLE CADR-TV-ADDER-AS-G-OFF CADR-TV-ADDER-AS-G T)

(TOGGLE CDDR-TV-ADDER-AS-SUM-OFF CDDR-TV-ADDER-AS-SUM T)

(TOGGLE TV-ADDER-AS-P-G-SUM-OFF TV-ADDER-AS-P-G-SUM T)

(DEFN TV-IF-BODY
 (TREE)
 (IF
    (NLISTP TREE)
    (LIST (LIST 'LEAF
                (LIST (INDEX 'OUT 0))
                'B-IF
                (LIST 'C
                      (INDEX 'A 0)
                      (INDEX 'B 0))))
    (APPEND (IF (ZEROP (REMAINDER (TREE-HEIGHT TREE) 3))
                '((C-BUF (C-BUF) B-BUF (C)))
                NIL)
            (LIST (LIST 'LEFT
                        (TFIRSTN (INDICES 'OUT 0 (TREE-SIZE TREE))
                                 TREE)
                        (INDEX 'TV-IF
                               (TREE-NUMBER (CAR TREE)))
                        (CONS (IF (ZEROP (REMAINDER (TREE-HEIGHT TREE) 3))
                                  'C-BUF
                                  'C)
                              (APPEND (TFIRSTN (INDICES 'A 0 (TREE-SIZE TREE))
                                               TREE)
                                      (TFIRSTN (INDICES 'B 0 (TREE-SIZE TREE))
                                               TREE))))
                  (LIST 'RIGHT
                        (TRESTN (INDICES 'OUT 0 (TREE-SIZE TREE))
                                TREE)
                        (INDEX 'TV-IF
                               (TREE-NUMBER (CDR TREE)))
                        (CONS (IF (ZEROP (REMAINDER (TREE-HEIGHT TREE) 3))
                                  'C-BUF
                                  'C)
                              (APPEND (TRESTN (INDICES 'A 0 (TREE-SIZE TREE))
                                              TREE)
                                      (TRESTN (INDICES 'B 0 (TREE-SIZE TREE))
                                              TREE))))))))

(DEFN TV-IF*
      (TREE)
      (CONS (INDEX 'TV-IF (TREE-NUMBER TREE))
            (CONS (CONS 'C
                        (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                (INDICES 'B 0 (TREE-SIZE TREE))))
                  (CONS (INDICES 'OUT 0 (TREE-SIZE TREE))
                        (CONS (TV-IF-BODY TREE) '(NIL))))))

(PROVE-LEMMA TV-IF*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TV-IF* TREE))
                         (INDEX 'TV-IF (TREE-NUMBER TREE)))
                  (EQUAL (CADR (TV-IF* TREE))
                         (CONS 'C
                               (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                       (INDICES 'B 0 (TREE-SIZE TREE)))))
                  (EQUAL (CADDR (TV-IF* TREE))
                         (INDICES 'OUT 0 (TREE-SIZE TREE)))
                  (EQUAL (CADDDR (TV-IF* TREE))
                         (TV-IF-BODY TREE))
                  (EQUAL (CADDDDR (TV-IF* TREE)) NIL)))

(TOGGLE TV-IF*-OFF TV-IF* T)

(TOGGLE TV-IF*$DESTRUCTURE-OFF TV-IF*$DESTRUCTURE T)

(DEFN TV-IF&
      (NETLIST TREE)
      (IF (NLISTP TREE)
          (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                     NETLIST)
                      (TV-IF* TREE))
               (B-IF& (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                     NETLIST)))
          (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                     NETLIST)
                      (TV-IF* TREE))
               (B-BUF& (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                      NETLIST))
               (TV-IF& (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                      NETLIST)
                       (CAR TREE))
               (TV-IF& (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                      NETLIST)
                       (CDR TREE)))))

(TOGGLE TV-IF&-OFF TV-IF& T)

(DEFN TV-IF$NETLIST
      (TREE)
      (IF (NLISTP TREE)
          (CONS (TV-IF* TREE) (B-IF$NETLIST))
          (CONS (TV-IF* TREE)
                (UNION (TV-IF$NETLIST (CAR TREE))
                       (UNION (TV-IF$NETLIST (CDR TREE))
                              (B-BUF$NETLIST))))))

(DEFN TV-IF-INDUCTION
    (TREE C A B STATE NETLIST)
    (IF (NLISTP TREE)
        T
        (AND (TV-IF-INDUCTION (CAR TREE)
                              C
                              (TFIRSTN A TREE)
                              (TFIRSTN B TREE)
                              0
                              (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                             NETLIST))
             (TV-IF-INDUCTION (CAR TREE)
                              (X)
                              (TFIRSTN A TREE)
                              (TFIRSTN B TREE)
                              0
                              (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                             NETLIST))
             (TV-IF-INDUCTION (CDR TREE)
                              C
                              (TRESTN A TREE)
                              (TRESTN B TREE)
                              0
                              (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                             NETLIST))
             (TV-IF-INDUCTION (CDR TREE)
                              (X)
                              (TRESTN A TREE)
                              (TRESTN B TREE)
                              0
                              (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                             NETLIST)))))

(PROVE-LEMMA TV-IF-LEMMA-CROCK
          (REWRITE)
          (IMPLIES (TV-IF& (DELETE-MODULE (INDEX 'TV-IF (TREE-NUMBER TREE))
                                          NETLIST)
                           (CAR TREE))
                   (EQUAL (COLLECT-VALUE (INDICES 'OUT 0 N)
                                         ALIST)
                          (APPEND (COLLECT-VALUE (FIRSTN (TREE-SIZE (CAR TREE))
                                                         (INDICES 'OUT 0 N))
                                                 ALIST)
                                  (COLLECT-VALUE (RESTN (TREE-SIZE (CAR TREE))
                                                        (INDICES 'OUT 0 N))
                                                 ALIST))))
          ((USE (COLLECT-VALUE-SPLITTING-CROCK (L (INDICES 'OUT 0 N))
                                               (N (TREE-SIZE (CAR TREE)))))))

(TOGGLE TV-IF-LEMMA-CROCK-OFF TV-IF-LEMMA-CROCK T)

(PROVE-LEMMA TV-IF$VALUE
             (REWRITE)
             (IMPLIES (AND (TV-IF& NETLIST TREE)
                           (PROPERP A)
                           (PROPERP B)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TV-IF (TREE-NUMBER TREE))
                                        (CONS C (APPEND A B))
                                        STATE NETLIST)
                             (FV-IF C A B)))
             ((INDUCT (TV-IF-INDUCTION TREE C A B STATE NETLIST))
              (ENABLE TV-IF& TV-IF-LEMMA-CROCK TV-IF*$DESTRUCTURE B-BUF$VALUE
                      B-IF$VALUE FV-IF-REWRITE TREE-SIZE)
              (DISABLE OPEN-INDICES)
              (EXPAND (TV-IF& NETLIST TREE)
                      (FV-IF C A B))))

(TOGGLE TV-IF$VALUE-OFF TV-IF$VALUE T)

(DEFN T-OR-NOR-BODY
      (TREE PARITY)
      (COND ((NLISTP TREE)
             (LIST (LIST 'LEAF
                         '(OUT)
                         (IF PARITY 'B-NOT 'B-BUF)
                         (LIST (INDEX 'A 0)))))
            ((AND (NLISTP (CAR TREE))
                  (NLISTP (CDR TREE)))
             (LIST (LIST 'LEAF
                         '(OUT)
                         (IF PARITY 'B-NOR 'B-OR)
                         (LIST (INDEX 'A 0) (INDEX 'A 1)))))
            (T (LIST (LIST 'LEFT
                           '(LEFT-OUT)
                           (INDEX (IF PARITY 'T-OR 'T-NOR)
                                  (TREE-NUMBER (CAR TREE)))
                           (TFIRSTN (INDICES 'A 0 (TREE-SIZE TREE))
                                    TREE))
                     (LIST 'RIGHT
                           '(RIGHT-OUT)
                           (INDEX (IF PARITY 'T-OR 'T-NOR)
                                  (TREE-NUMBER (CDR TREE)))
                           (TRESTN (INDICES 'A 0 (TREE-SIZE TREE))
                                   TREE))
                     (CONS 'OUTPUT
                           (CONS '(OUT)
                                 (CONS (IF PARITY 'B-NOR 'B-NAND)
                                       '((LEFT-OUT RIGHT-OUT)))))))))

(DEFN T-OR-NOR*
      (TREE PARITY)
      (CONS (INDEX (IF PARITY 'T-NOR 'T-OR)
                   (TREE-NUMBER TREE))
            (CONS (INDICES 'A 0 (TREE-SIZE TREE))
                  (CONS '(OUT)
                        (CONS (T-OR-NOR-BODY TREE PARITY)
                              '(NIL))))))

(PROVE-LEMMA T-OR-NOR*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (T-OR-NOR* TREE PARITY))
                         (INDEX (IF PARITY 'T-NOR 'T-OR)
                                (TREE-NUMBER TREE)))
                  (EQUAL (CADR (T-OR-NOR* TREE PARITY))
                         (INDICES 'A 0 (TREE-SIZE TREE)))
                  (EQUAL (CADDR (T-OR-NOR* TREE PARITY))
                         '(OUT))
                  (EQUAL (CADDDR (T-OR-NOR* TREE PARITY))
                         (T-OR-NOR-BODY TREE PARITY))
                  (EQUAL (CADDDDR (T-OR-NOR* TREE PARITY))
                         NIL)))

(TOGGLE T-OR-NOR*-OFF T-OR-NOR* T)

(TOGGLE T-OR-NOR*$DESTRUCTURE-OFF T-OR-NOR*$DESTRUCTURE T)

(DEFN T-OR-NOR&
      (NETLIST TREE PARITY)
      (IF (OR (NLISTP TREE)
              (AND (NLISTP (CAR TREE))
                   (NLISTP (CDR TREE))))
          (AND (EQUAL (LOOKUP-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                            (TREE-NUMBER TREE))
                                     NETLIST)
                      (T-OR-NOR* TREE PARITY))
               (B-NOT& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-BUF& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-NOR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-OR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                            (TREE-NUMBER TREE))
                                     NETLIST))
               (B-NAND& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                              (TREE-NUMBER TREE))
                                       NETLIST)))
          (AND (EQUAL (LOOKUP-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                            (TREE-NUMBER TREE))
                                     NETLIST)
                      (T-OR-NOR* TREE PARITY))
               (T-OR-NOR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                                (TREE-NUMBER TREE))
                                         NETLIST)
                          (CAR TREE)
                          (NOT PARITY))
               (T-OR-NOR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                                (TREE-NUMBER TREE))
                                         NETLIST)
                          (CDR TREE)
                          (NOT PARITY))
               (B-NOT& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-BUF& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-NOR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (B-OR& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                            (TREE-NUMBER TREE))
                                     NETLIST))
               (B-NAND& (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                              (TREE-NUMBER TREE))
                                       NETLIST)))))

(TOGGLE T-OR-NOR&-OFF T-OR-NOR& T)

(DEFN T-OR-NOR$NETLIST
      (TREE PARITY)
      (IF (OR (NLISTP TREE)
              (AND (NLISTP (CAR TREE))
                   (NLISTP (CDR TREE))))
          (CONS (T-OR-NOR* TREE PARITY)
                (UNION (UNION (UNION (B-NOT$NETLIST)
                                     (B-BUF$NETLIST))
                              (UNION (B-NOR$NETLIST)
                                     (B-OR$NETLIST)))
                       (B-NAND$NETLIST)))
          (CONS (T-OR-NOR* TREE PARITY)
                (UNION (T-OR-NOR$NETLIST (CAR TREE)
                                         (NOT PARITY))
                       (T-OR-NOR$NETLIST (CDR TREE)
                                         (NOT PARITY))))))

(DEFN T-OR-NOR-INDUCTION
  (TREE PARITY CALL-NAME A STATE NETLIST)
  (IF (OR (NLISTP TREE)
          (AND (NLISTP (CAR TREE))
               (NLISTP (CDR TREE))))
      T
      (AND (T-OR-NOR-INDUCTION (CAR TREE)
                               (NOT PARITY)
                               (IF (NOT PARITY) 'T-NOR 'T-OR)
                               (TFIRSTN A TREE)
                               0
                               (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                                     (TREE-NUMBER TREE))
                                              NETLIST))
           (T-OR-NOR-INDUCTION (CDR TREE)
                               (NOT PARITY)
                               (IF (NOT PARITY) 'T-NOR 'T-OR)
                               (TRESTN A TREE)
                               0
                               (DELETE-MODULE (INDEX (IF PARITY 'T-NOR 'T-OR)
                                                     (TREE-NUMBER TREE))
                                              NETLIST)))))

(DEFN TR-OR-NOR
      (A PARITY TREE)
      (COND ((NLISTP TREE)
             (IF PARITY
                 (F-NOT (CAR A))
                 (F-BUF (CAR A))))
            ((AND (NLISTP (CAR TREE))
                  (NLISTP (CDR TREE)))
             (IF PARITY
                 (F-NOR (CAR A) (CADR A))
                 (F-OR (CAR A) (CADR A))))
            (PARITY (F-NOR (TR-OR-NOR (TFIRSTN A TREE)
                                      (NOT PARITY)
                                      (CAR TREE))
                           (TR-OR-NOR (TRESTN A TREE)
                                      (NOT PARITY)
                                      (CDR TREE))))
            (T (F-NAND (TR-OR-NOR (TFIRSTN A TREE)
                                  (NOT PARITY)
                                  (CAR TREE))
                       (TR-OR-NOR (TRESTN A TREE)
                                  (NOT PARITY)
                                  (CDR TREE))))))

(TOGGLE TR-OR-NOR-OFF TR-OR-NOR T)

(PROVE-LEMMA T-OR-NOR$VALUE
             (REWRITE)
             (IMPLIES (AND (T-OR-NOR& NETLIST TREE PARITY)
                           (EQUAL CALL-NAME
                                  (IF PARITY 'T-NOR 'T-OR))
                           (PROPERP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX CALL-NAME (TREE-NUMBER TREE))
                                        A STATE NETLIST)
                             (LIST (TR-OR-NOR A PARITY TREE))))
             ((INDUCT (T-OR-NOR-INDUCTION TREE PARITY CALL-NAME A STATE
                                          NETLIST))
              (ENABLE T-OR-NOR*$DESTRUCTURE B-BUF$VALUE B-NAND$VALUE
                      B-NOT$VALUE B-OR$VALUE B-NOR$VALUE TR-OR-NOR)
              (DISABLE TREE-SIZE-NLISTP)
              (DISABLE-THEORY F-GATES)
              (EXPAND (T-OR-NOR& NETLIST TREE F)
                      (T-OR-NOR& NETLIST TREE PARITY)
                      (TR-OR-NOR A F TREE)
                      (TR-OR-NOR A PARITY TREE))))

(TOGGLE T-OR-NOR$VALUE-OFF T-OR-NOR$VALUE T)

(DEFN BTR-OR-NOR
      (A PARITY TREE)
      (COND ((NLISTP TREE)
             (IF PARITY
                 (B-NOT (CAR A))
                 (B-BUF (CAR A))))
            ((AND (NLISTP (CAR TREE))
                  (NLISTP (CDR TREE)))
             (IF PARITY
                 (B-NOR (CAR A) (CADR A))
                 (B-OR (CAR A) (CADR A))))
            (PARITY (B-NOR (BTR-OR-NOR (TFIRSTN A TREE)
                                       (NOT PARITY)
                                       (CAR TREE))
                           (BTR-OR-NOR (TRESTN A TREE)
                                       (NOT PARITY)
                                       (CDR TREE))))
            (T (B-NAND (BTR-OR-NOR (TFIRSTN A TREE)
                                   (NOT PARITY)
                                   (CAR TREE))
                       (BTR-OR-NOR (TRESTN A TREE)
                                   (NOT PARITY)
                                   (CDR TREE))))))

(TOGGLE BTR-OR-NOR-OFF BTR-OR-NOR T)

(PROVE-LEMMA TR-OR-NOR=BTR-OR-NOR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TR-OR-NOR A PARITY TREE)
                             (BTR-OR-NOR A PARITY TREE)))
             ((DISABLE TREE-SIZE-NLISTP)
              (ENABLE FIRSTN RESTN EXPAND-F-FUNCTIONS BTR-OR-NOR TR-OR-NOR
                      BVP)))

(PROVE-LEMMA BTR-OR-IS-V-NZEROP
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH A) (TREE-SIZE TREE))
                      (EQUAL (BTR-OR-NOR A PARITY TREE)
                             (IF PARITY (V-ZEROP A) (V-NZEROP A))))
             ((INDUCT (BTR-OR-NOR A PARITY TREE))
              (ENABLE BTR-OR-NOR V-NZEROP TREE-SIZE)
              (EXPAND (BTR-OR-NOR A PARITY TREE))))

(DEFN TV-ZEROP*
   (TREE)
   (CONS (INDEX 'TV-ZEROP (TREE-NUMBER TREE))
         (CONS (INDICES 'IN 0 (TREE-SIZE TREE))
               (CONS '(OUT)
                     (CONS (IF (EQUAL (REMAINDER (TREE-HEIGHT TREE) 2)
                                      1)
                               (CONS (LIST 'G0
                                           '(OUT-)
                                           (INDEX 'T-OR (TREE-NUMBER TREE))
                                           (INDICES 'IN 0 (TREE-SIZE TREE)))
                                     '((G1 (OUT) B-NOT (OUT-))))
                               (LIST (LIST 'G0
                                           '(OUT)
                                           (INDEX 'T-NOR (TREE-NUMBER TREE))
                                           (INDICES 'IN 0 (TREE-SIZE TREE)))))
                           '(NIL))))))

(PROVE-LEMMA TV-ZEROP*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TV-ZEROP* TREE))
                         (INDEX 'TV-ZEROP (TREE-NUMBER TREE)))
                  (EQUAL (CADR (TV-ZEROP* TREE))
                         (INDICES 'IN 0 (TREE-SIZE TREE)))
                  (EQUAL (CADDR (TV-ZEROP* TREE))
                         '(OUT))
                  (EQUAL (CADDDR (TV-ZEROP* TREE))
                         (IF (EQUAL (REMAINDER (TREE-HEIGHT TREE) 2)
                                    1)
                             (CONS (LIST 'G0
                                         '(OUT-)
                                         (INDEX 'T-OR (TREE-NUMBER TREE))
                                         (INDICES 'IN 0 (TREE-SIZE TREE)))
                                   '((G1 (OUT) B-NOT (OUT-))))
                             (LIST (LIST 'G0
                                         '(OUT)
                                         (INDEX 'T-NOR (TREE-NUMBER TREE))
                                         (INDICES 'IN 0 (TREE-SIZE TREE))))))
                  (EQUAL (CADDDDR (TV-ZEROP* TREE))
                         NIL)))

(TOGGLE TV-ZEROP*-OFF TV-ZEROP* T)

(TOGGLE TV-ZEROP*$DESTRUCTURE-OFF TV-ZEROP*$DESTRUCTURE T)

(DEFN TV-ZEROP&
      (NETLIST TREE)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-ZEROP (TREE-NUMBER TREE))
                                 NETLIST)
                  (TV-ZEROP* TREE))
           (T-OR-NOR& (DELETE-MODULE (INDEX 'TV-ZEROP (TREE-NUMBER TREE))
                                     NETLIST)
                      TREE
                      (NOT (EQUAL (REMAINDER (TREE-HEIGHT TREE) 2)
                                  1)))
           (B-NOT& (DELETE-MODULE (INDEX 'TV-ZEROP (TREE-NUMBER TREE))
                                  NETLIST))))

(TOGGLE TV-ZEROP&-OFF TV-ZEROP& T)

(DEFN TV-ZEROP$NETLIST
    (TREE)
    (CONS (TV-ZEROP* TREE)
          (UNION (T-OR-NOR$NETLIST TREE
                                   (NOT (EQUAL (REMAINDER (TREE-HEIGHT TREE) 2)
                                               1)))
                 (B-NOT$NETLIST))))

(DEFN F$TV-ZEROP
      (A TREE)
      (IF (EQUAL (REMAINDER (TREE-HEIGHT TREE) 2)
                 1)
          (F-NOT (TR-OR-NOR A F TREE))
          (TR-OR-NOR A T TREE)))

(TOGGLE F$TV-ZEROP-OFF F$TV-ZEROP T)

(PROVE-LEMMA TV-ZEROP$VALUE
             (REWRITE)
             (IMPLIES (AND (TV-ZEROP& NETLIST TREE)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (PROPERP A))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TV-ZEROP (TREE-NUMBER TREE))
                                        A STATE NETLIST)
                             (LIST (F$TV-ZEROP A TREE))))
             ((ENABLE TV-ZEROP& TV-ZEROP*$DESTRUCTURE B-NOT$VALUE
                      T-OR-NOR$VALUE F$TV-ZEROP)
              (DISABLE-THEORY F-GATES)))

(TOGGLE TV-ZEROP$VALUE-OFF TV-ZEROP$VALUE T)

(PROVE-LEMMA F$TV-ZEROP=V-ZEROP
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP A))
                      (EQUAL (F$TV-ZEROP A TREE)
                             (V-ZEROP A)))
             ((ENABLE F$TV-ZEROP)
              (DISABLE-THEORY F-GATES)))

(DEFN F$FAST-ZERO
      (V)
      (F-NOR3 (TR-OR-NOR (FIRSTN (SUB1 (SUB1 (LENGTH V))) V)
                         F
                         (MAKE-TREE (SUB1 (SUB1 (LENGTH V)))))
              (NTH (SUB1 (SUB1 (LENGTH V))) V)
              (NTH (SUB1 (LENGTH V)) V)))

(TOGGLE F$FAST-ZERO-OFF F$FAST-ZERO T)

(PROVE-LEMMA F$FAST-ZERO=TR-OR-NOR NIL
          (IMPLIES (AND (PROPERP V)
                        (IF (LESSP (LENGTH V) 3) F T))
                   (EQUAL (F$FAST-ZERO V)
                          (TR-OR-NOR V T
                                     (CONS (MAKE-TREE (SUB1 (SUB1 (LENGTH V))))
                                           '(0 . 0)))))
          ((ENABLE F$FAST-ZERO TR-OR-NOR F-NOR3 F-NOR NTH-RESTN CDR-RESTN)
           (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$FAST-ZERO=V-ZEROP
             (REWRITE)
             (IMPLIES (AND (BVP V)
                           (IF (LESSP (LENGTH V) 3) F T))
                      (EQUAL (F$FAST-ZERO V) (V-ZEROP V)))
             ((USE (F$FAST-ZERO=TR-OR-NOR))
              (ENABLE TREE-SIZE)))

(DEFN FAST-ZERO*
 (N)
 (CONS
  (INDEX 'FAST-ZERO N)
  (CONS
      (INDICES 'A 0 N)
      (CONS '(Z)
            (CONS (LIST (LIST 'FRONT
                              '(ZFRONT)
                              (INDEX 'T-OR
                                     (TREE-NUMBER (MAKE-TREE (SUB1 (SUB1 N)))))
                              (FIRSTN (SUB1 (SUB1 N))
                                      (INDICES 'A 0 N)))
                        (LIST 'RESULT
                              '(Z)
                              'B-NOR3
                              (LIST 'ZFRONT
                                    (INDEX 'A (SUB1 (SUB1 N)))
                                    (INDEX 'A (SUB1 N)))))
                  '(NIL))))))

(PROVE-LEMMA FAST-ZERO*$DESTRUCTURE
      (REWRITE)
      (AND (EQUAL (CAR (FAST-ZERO* N))
                  (INDEX 'FAST-ZERO N))
           (EQUAL (CADR (FAST-ZERO* N))
                  (INDICES 'A 0 N))
           (EQUAL (CADDR (FAST-ZERO* N)) '(Z))
           (EQUAL (CADDDR (FAST-ZERO* N))
                  (LIST (LIST 'FRONT
                              '(ZFRONT)
                              (INDEX 'T-OR
                                     (TREE-NUMBER (MAKE-TREE (SUB1 (SUB1 N)))))
                              (FIRSTN (SUB1 (SUB1 N))
                                      (INDICES 'A 0 N)))
                        (LIST 'RESULT
                              '(Z)
                              'B-NOR3
                              (LIST 'ZFRONT
                                    (INDEX 'A (SUB1 (SUB1 N)))
                                    (INDEX 'A (SUB1 N))))))
           (EQUAL (CADDDDR (FAST-ZERO* N)) NIL)))

(TOGGLE FAST-ZERO*-OFF FAST-ZERO* T)

(TOGGLE FAST-ZERO*$DESTRUCTURE-OFF FAST-ZERO*$DESTRUCTURE T)

(DEFN FAST-ZERO&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'FAST-ZERO N)
                                 NETLIST)
                  (FAST-ZERO* N))
           (T-OR-NOR& (DELETE-MODULE (INDEX 'FAST-ZERO N)
                                     NETLIST)
                      (MAKE-TREE (SUB1 (SUB1 N)))
                      F)
           (B-NOR3& (DELETE-MODULE (INDEX 'FAST-ZERO N)
                                   NETLIST))))

(TOGGLE FAST-ZERO&-OFF FAST-ZERO& T)

(DEFN FAST-ZERO$NETLIST
      (N)
      (CONS (FAST-ZERO* N)
            (UNION (T-OR-NOR$NETLIST (MAKE-TREE (SUB1 (SUB1 N)))
                                     F)
                   (B-NOR3$NETLIST))))

(PROVE-LEMMA CHECK-FAST-ZERO$NETLIST NIL
             (FAST-ZERO& (FAST-ZERO$NETLIST 5) 5))

(PROVE-LEMMA FAST-ZERO$VALUE
             (REWRITE)
             (IMPLIES (AND (FAST-ZERO& NETLIST N)
                           (PROPERP V)
                           (EQUAL (LENGTH V) N)
                           (IF (LESSP N 3) F T))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'FAST-ZERO N)
                                        V STATE NETLIST)
                             (LIST (F$FAST-ZERO V))))
             ((ENABLE FAST-ZERO& F$FAST-ZERO FAST-ZERO*$DESTRUCTURE
                      T-OR-NOR$VALUE B-NOR3$VALUE)
              (DISABLE OPEN-INDICES)
              (DISABLE-THEORY F-GATES)))

(DEFN V-EQUAL*
      (N)
      (CONS (INDEX 'V-EQUAL N)
            (CONS (APPEND (INDICES 'A 0 N)
                          (INDICES 'B 0 N))
                  (CONS '(EQUAL)
                        (CONS (LIST (LIST 'G0
                                          (INDICES 'X 0 N)
                                          (INDEX 'V-XOR N)
                                          (APPEND (INDICES 'A 0 N)
                                                  (INDICES 'B 0 N)))
                                    (LIST 'G1
                                          '(EQUAL)
                                          (INDEX 'TV-ZEROP
                                                 (TREE-NUMBER (MAKE-TREE N)))
                                          (INDICES 'X 0 N)))
                              '(NIL))))))

(PROVE-LEMMA V-EQUAL*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (V-EQUAL* N))
                         (INDEX 'V-EQUAL N))
                  (EQUAL (CADR (V-EQUAL* N))
                         (APPEND (INDICES 'A 0 N)
                                 (INDICES 'B 0 N)))
                  (EQUAL (CADDR (V-EQUAL* N)) '(EQUAL))
                  (EQUAL (CADDDR (V-EQUAL* N))
                         (LIST (LIST 'G0
                                     (INDICES 'X 0 N)
                                     (INDEX 'V-XOR N)
                                     (APPEND (INDICES 'A 0 N)
                                             (INDICES 'B 0 N)))
                               (LIST 'G1
                                     '(EQUAL)
                                     (INDEX 'TV-ZEROP
                                            (TREE-NUMBER (MAKE-TREE N)))
                                     (INDICES 'X 0 N))))
                  (EQUAL (CADDDDR (V-EQUAL* N)) NIL)))

(TOGGLE V-EQUAL*-OFF V-EQUAL* T)

(TOGGLE V-EQUAL*$DESTRUCTURE-OFF V-EQUAL*$DESTRUCTURE T)

(DEFN V-EQUAL&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'V-EQUAL N)
                                 NETLIST)
                  (V-EQUAL* N))
           (V-XOR& (DELETE-MODULE (INDEX 'V-EQUAL N)
                                  NETLIST)
                   N)
           (TV-ZEROP& (DELETE-MODULE (INDEX 'V-EQUAL N)
                                     NETLIST)
                      (MAKE-TREE N))))

(TOGGLE V-EQUAL&-OFF V-EQUAL& T)

(DEFN V-EQUAL$NETLIST
      (N)
      (CONS (V-EQUAL* N)
            (UNION (V-XOR$NETLIST N)
                   (TV-ZEROP$NETLIST (MAKE-TREE N)))))

(DEFN F$V-EQUAL
      (A B)
      (F$TV-ZEROP (FV-XOR A B)
                  (MAKE-TREE (LENGTH A))))

(TOGGLE F$V-EQUAL-OFF F$V-EQUAL T)

(PROVE-LEMMA V-EQUAL$VALUE
             (REWRITE)
             (IMPLIES (AND (V-EQUAL& NETLIST N)
                           (NOT (ZEROP N))
                           (PROPERP A)
                           (PROPERP B)
                           (EQUAL (LENGTH A) N)
                           (EQUAL (LENGTH B) N))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'V-EQUAL N)
                                        (APPEND A B)
                                        STATE NETLIST)
                             (LIST (F$V-EQUAL A B))))
             ((ENABLE V-EQUAL& V-XOR$VALUE TV-ZEROP$VALUE V-EQUAL*$DESTRUCTURE
                      F$V-EQUAL)
              (DISABLE OPEN-INDICES)))

(TOGGLE V-EQUAL$VALUE-OFF V-EQUAL$VALUE T)

(PROVE-LEMMA F$V-EQUAL=EQUAL*
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP (LENGTH A)))
                           (BVP A)
                           (BVP B)
                           (EQUAL (LENGTH A) (LENGTH B)))
                      (EQUAL (F$V-EQUAL A B) (EQUAL A B)))
             ((ENABLE F$V-EQUAL)))

(DEFN V-INC4
      (A0 A1 A2 A3)
      (LIST (B-NOT A0)
            (B-XOR (B-NOT A1) (B-NOT A0))
            (B-EQUV (B-NOT A2)
                    (B-NOR (B-NOT A0) (B-NOT A1)))
            (B-EQUV (B-NOT A3)
                    (B-NOR3 (B-NOT A0)
                            (B-NOT A1)
                            (B-NOT A2)))))

(DEFN F$V-INC4
      (A0 A1 A2 A3)
      (LIST (F-NOT A0)
            (F-XOR (F-NOT A1) (F-NOT A0))
            (F-EQUV (F-NOT A2)
                    (F-NOR (F-NOT A0) (F-NOT A1)))
            (F-EQUV (F-NOT A3)
                    (F-NOR3 (F-NOT A0)
                            (F-NOT A1)
                            (F-NOT A2)))))

(TOGGLE F$V-INC4-OFF F$V-INC4 T)

(DEFN V-INC4* NIL
      '(V-INC4 (A0 A1 A2 A3)
               (W-10 W-3 W-8 W-14)
               ((G-12 (W-12) B-NOT (A2))
                (G-11 (W-11) B-NOT (A1))
                (G-10 (W-10) B-NOT (A0))
                (G-13 (W-13) B-NOR3 (W-10 W-11 W-12))
                (G-9 (W-9) B-NOT (A3))
                (G-14 (W-14) B-EQUV (W-9 W-13))
                (G-7 (W-7) B-NOR (W-10 W-11))
                (G-8 (W-8) B-EQUV (W-12 W-7))
                (G-3 (W-3) B-XOR (W-11 W-10)))
               NIL))

(DEFN V-INC4&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'V-INC4 NETLIST)
                  (V-INC4*))
           (B-NOR3& (DELETE-MODULE 'V-INC4 NETLIST))
           (B-NOT& (DELETE-MODULE 'V-INC4 NETLIST))
           (B-NOR& (DELETE-MODULE 'V-INC4 NETLIST))
           (B-EQUV& (DELETE-MODULE 'V-INC4 NETLIST))
           (B-XOR& (DELETE-MODULE 'V-INC4 NETLIST))))

(TOGGLE V-INC4&-OFF V-INC4& T)

(DEFN V-INC4$NETLIST NIL
      (CONS (V-INC4*)
            (UNION (UNION (UNION (UNION (B-NOR3$NETLIST)
                                        (B-NOT$NETLIST))
                                 (B-NOR$NETLIST))
                          (B-EQUV$NETLIST))
                   (B-XOR$NETLIST))))

(PROVE-LEMMA V-INC4$VALUE
             (REWRITE)
             (IMPLIES (V-INC4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'V-INC4
                                        (LIST A0 A1 A2 A3)
                                        STATE NETLIST)
                             (F$V-INC4 A0 A1 A2 A3)))
             ((ENABLE V-INC4& F$V-INC4 B-NOR3$VALUE B-NOT$VALUE B-NOR$VALUE
                      B-EQUV$VALUE B-XOR$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE V-INC4$VALUE-OFF V-INC4$VALUE T)

(PROVE-LEMMA F$V-INC4=V-INC4
             (REWRITE)
             (IMPLIES (AND (BOOLP A0)
                           (BOOLP A1)
                           (BOOLP A2)
                           (BOOLP A3))
                      (EQUAL (F$V-INC4 A0 A1 A2 A3)
                             (V-INC4 A0 A1 A2 A3)))
             ((ENABLE BOOLP-B-GATES F$V-INC4 V-INC4)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN F$V-INC4$V
      (A)
      (LIST (F-NOT (CAR A))
            (F-XOR (F-NOT (CADR A))
                   (F-NOT (CAR A)))
            (F-EQUV (F-NOT (CADDR A))
                    (F-NOR (F-NOT (CAR A))
                           (F-NOT (CADR A))))
            (F-EQUV (F-NOT (CADDDR A))
                    (F-NOR3 (F-NOT (CAR A))
                            (F-NOT (CADR A))
                            (F-NOT (CADDR A))))))

(TOGGLE F$V-INC4$V-OFF F$V-INC4$V T)

(PROVE-LEMMA PROPERP-LENGTH-F$V-INC4$V
             (REWRITE)
             (AND (PROPERP (F$V-INC4$V A))
                  (EQUAL (LENGTH (F$V-INC4$V A)) 4))
             ((ENABLE F$V-INC4$V)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA V-INC4$VALUE-AS-V-INC
             (REWRITE)
             (IMPLIES (AND (V-INC4& NETLIST)
                           (PROPERP A)
                           (EQUAL (LENGTH A) 4))
                      (EQUAL (DUAL-EVAL 0 'V-INC4 A STATE NETLIST)
                             (F$V-INC4$V A)))
             ((ENABLE V-INC4$VALUE F$V-INC4 F$V-INC4$V EQUAL-LENGTH-ADD1)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$V-INC4$V=V-INC
             (REWRITE)
             (IMPLIES (AND (BVP A) (EQUAL (LENGTH A) 4))
                      (EQUAL (F$V-INC4$V A) (V-INC A)))
             ((ENABLE F$V-INC4$V V-INC V-SUM EQUAL-LENGTH-ADD1 BOOLP-B-GATES)
              (DISABLE-THEORY F-GATES)))

(DEFN TV-DEC-PASS
   (C A TREE)
   (IF (NLISTP TREE)
       (LIST (B-BUF (CAR A))
             (B-EQUV (CAR A) C))
       (CONS (B-OR (CAR (TV-DEC-PASS C
                                     (TFIRSTN A TREE)
                                     (CAR TREE)))
                   (CAR (TV-DEC-PASS (B-OR C
                                           (CAR (TV-DEC-PASS C
                                                             (TFIRSTN A TREE)
                                                             (CAR TREE))))
                                     (TRESTN A TREE)
                                     (CDR TREE))))
             (APPEND (CDR (TV-DEC-PASS C
                                       (TFIRSTN A TREE)
                                       (CAR TREE)))
                     (CDR (TV-DEC-PASS (B-OR C
                                             (CAR (TV-DEC-PASS C
                                                               (TFIRSTN A TREE)
                                                               (CAR TREE))))
                                       (TRESTN A TREE)
                                       (CDR TREE)))))))

(TOGGLE TV-DEC-PASS-OFF TV-DEC-PASS T)

(PROVE-LEMMA CDR-TV-DEC-PASS-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (CDR (TV-DEC-PASS C A TREE)))
                    (TREE-SIZE TREE))
             ((ENABLE TV-DEC-PASS LENGTH TREE-SIZE)))

(PROVE-LEMMA TV-DEC-PASS-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (TV-DEC-PASS C A TREE))
                    (ADD1 (TREE-SIZE TREE)))
             ((ENABLE LENGTH TV-DEC-PASS TREE-SIZE)))

(PROVE-LEMMA BVP-CDR-TV-DEC-PASS
             (REWRITE)
             (BVP (CDR (TV-DEC-PASS C A TREE)))
             ((ENABLE BVP TV-DEC-PASS)))

(PROVE-LEMMA BVP-TV-DEC-PASS
             (REWRITE)
             (BVP (TV-DEC-PASS C A TREE))
             ((ENABLE BVP TV-DEC-PASS)))

(PROVE-LEMMA BVP-LENGTH-TV-DEC-PASS
             (REWRITE)
             (EQUAL (BVP-LENGTH (TV-DEC-PASS C A TREE) N)
                    (IF (LESSP (ADD1 (TREE-SIZE TREE)) N)
                        F T))
             ((ENABLE BVP-LENGTH)))

(PROVE-LEMMA TV-DEC-PASS-CROCK-1 NIL
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP A))
                      (EQUAL (TV-ADDER C
                                       (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                       A TREE)
                             (CONS T (TV-DEC-PASS C A TREE))))
             ((INDUCT (TV-DEC-PASS C A TREE))
              (DISABLE V-NOT-FIRSTN V-NOT-RESTN)
              (ENABLE FIRSTN-V-NOT RESTN-V-NOT T-CARRY)
              (EXPAND (TV-DEC-PASS C A TREE)
                      (TV-ADDER C
                                (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                A TREE)
                      (TV-DEC-PASS F A TREE)
                      (TV-ADDER F
                                (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                A TREE))))

(PROVE-LEMMA TV-DEC-PASS-CROCK-2 NIL
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP A))
                      (EQUAL (CDR (TV-DEC-PASS C A TREE))
                             (CDDR (TV-ADDER C
                                             (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                             A TREE))))
             ((USE (TV-DEC-PASS-CROCK-1))))

(PROVE-LEMMA TV-DEC-PASS-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP A))
                      (EQUAL (CDR (TV-DEC-PASS C A TREE))
                             (IF C (V-BUF A) (V-DEC A))))
             ((USE (TV-DEC-PASS-CROCK-2))
              (ENABLE TV-ADDER-AS-P-G-SUM V-SUM V-DEC)))

(DEFN TV-DEC-PASS-NG
 (C A TREE MAKE-G)
 (COND
  ((NLISTP TREE)
   (IF MAKE-G
       (LIST (B-BUF (CAR A))
             (B-EQUV (CAR A) C))
       (LIST (B-EQUV (CAR A) C))))
  (MAKE-G
   (CONS
       (B-OR (CAR (TV-DEC-PASS-NG C
                                  (TFIRSTN A TREE)
                                  (CAR TREE)
                                  T))
             (CAR (TV-DEC-PASS-NG (B-OR C
                                        (CAR (TV-DEC-PASS-NG C
                                                             (TFIRSTN A TREE)
                                                             (CAR TREE)
                                                             T)))
                                  (TRESTN A TREE)
                                  (CDR TREE)
                                  MAKE-G)))
       (APPEND (CDR (TV-DEC-PASS-NG C
                                    (TFIRSTN A TREE)
                                    (CAR TREE)
                                    T))
               (CDR (TV-DEC-PASS-NG (B-OR C
                                          (CAR (TV-DEC-PASS-NG C
                                                               (TFIRSTN A TREE)
                                                               (CAR TREE)
                                                               T)))
                                    (TRESTN A TREE)
                                    (CDR TREE)
                                    MAKE-G)))))
  (T (APPEND (CDR (TV-DEC-PASS-NG C
                                  (TFIRSTN A TREE)
                                  (CAR TREE)
                                  T))
             (TV-DEC-PASS-NG (B-OR C
                                   (CAR (TV-DEC-PASS-NG C
                                                        (TFIRSTN A TREE)
                                                        (CAR TREE)
                                                        T)))
                             (TRESTN A TREE)
                             (CDR TREE)
                             MAKE-G)))))

(TOGGLE TV-DEC-PASS-NG-OFF TV-DEC-PASS-NG T)

(PROVE-LEMMA TV-DEC-PASS-NG-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (TV-DEC-PASS-NG C A TREE MAKE-G))
                    (IF MAKE-G
                        (ADD1 (TREE-SIZE TREE))
                        (TREE-SIZE TREE)))
             ((ENABLE TV-DEC-PASS-NG LENGTH TREE-SIZE)))

(PROVE-LEMMA TV-DEC-PASS-NG-LENGTH-1
             (REWRITE)
             (IMPLIES MAKE-G
                      (EQUAL (LENGTH (CDR (TV-DEC-PASS-NG C A TREE MAKE-G)))
                             (TREE-SIZE TREE)))
             ((ENABLE TV-DEC-PASS-NG LENGTH TREE-SIZE)))

(PROVE-LEMMA BVP-TV-DEC-PASS-NG
             (REWRITE)
             (BVP (TV-DEC-PASS-NG C A TREE MAKE-G))
             ((ENABLE BVP TV-DEC-PASS-NG)))

(PROVE-LEMMA BVP-CDR-TV-DEC-PASS-NG
             (REWRITE)
             (IMPLIES MAKE-G
                      (BVP (CDR (TV-DEC-PASS-NG C A TREE MAKE-G))))
             ((ENABLE BVP TV-DEC-PASS-NG)))

(PROVE-LEMMA BVP-LENGTH-TV-DEC-PASS-NG
             (REWRITE)
             (EQUAL (BVP-LENGTH (TV-DEC-PASS-NG C A TREE MAKE-G)
                                N)
                    (IF MAKE-G
                        (IF (LESSP (ADD1 (TREE-SIZE TREE)) N)
                            F T)
                        (LESSP N (ADD1 (TREE-SIZE TREE)))))
             ((ENABLE BVP-LENGTH)))

(PROVE-LEMMA TV-DEC-PASS-NG-IS-CDR-TV-DEC-PASS
             (REWRITE)
             (EQUAL (TV-DEC-PASS-NG C A TREE MAKE-G)
                    (IF MAKE-G
                        (TV-DEC-PASS C A TREE)
                        (CDR (TV-DEC-PASS C A TREE))))
             ((ENABLE TV-DEC-PASS TV-DEC-PASS-NG)
              (DISABLE B-OR TFIRSTN TRESTN)))

(PROVE-LEMMA BOOLP-CAR-TV-DEC-PASS-NG
             (REWRITE)
             (BOOLP (CAR (TV-DEC-PASS-NG C A TREE MAKE-G)))
             ((ENABLE TV-DEC-PASS-NG)))

(PROVE-LEMMA TV-DEC-PASS-NG-WORKS-1
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           MAKE-G)
                      (EQUAL (CDR (TV-DEC-PASS-NG C A TREE MAKE-G))
                             (IF C (V-BUF A) (V-DEC A)))))

(PROVE-LEMMA TV-DEC-PASS-NG-WORKS-2
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (NOT MAKE-G))
                      (EQUAL (TV-DEC-PASS-NG C A TREE MAKE-G)
                             (IF C (V-BUF A) (V-DEC A)))))

(DEFN F$TV-DEC-PASS-NG
 (C A TREE MAKE-G)
 (COND
  ((NLISTP TREE)
   (IF MAKE-G
       (LIST (CAR A) (F-EQUV (CAR A) C))
       (LIST (F-EQUV (CAR A) C))))
  (MAKE-G
   (CONS
    (F-OR (CAR (F$TV-DEC-PASS-NG C
                                 (TFIRSTN A TREE)
                                 (CAR TREE)
                                 T))
          (CAR (F$TV-DEC-PASS-NG (F-OR C
                                       (CAR (F$TV-DEC-PASS-NG C
                                                              (TFIRSTN A TREE)
                                                              (CAR TREE)
                                                              T)))
                                 (TRESTN A TREE)
                                 (CDR TREE)
                                 MAKE-G)))
    (APPEND
           (CDR (F$TV-DEC-PASS-NG C
                                  (TFIRSTN A TREE)
                                  (CAR TREE)
                                  T))
           (CDR (F$TV-DEC-PASS-NG (F-OR C
                                        (CAR (F$TV-DEC-PASS-NG C
                                                               (TFIRSTN A TREE)
                                                               (CAR TREE)
                                                               T)))
                                  (TRESTN A TREE)
                                  (CDR TREE)
                                  MAKE-G)))))
  (T (APPEND (CDR (F$TV-DEC-PASS-NG C
                                    (TFIRSTN A TREE)
                                    (CAR TREE)
                                    T))
             (F$TV-DEC-PASS-NG (F-OR C
                                     (CAR (F$TV-DEC-PASS-NG C
                                                            (TFIRSTN A TREE)
                                                            (CAR TREE)
                                                            T)))
                               (TRESTN A TREE)
                               (CDR TREE)
                               MAKE-G)))))

(TOGGLE F$TV-DEC-PASS-NG-OFF F$TV-DEC-PASS-NG T)

(PROVE-LEMMA F$TV-DEC-PASS-NG-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (F$TV-DEC-PASS-NG C A TREE MAKE-G))
                    (IF MAKE-G
                        (ADD1 (TREE-SIZE TREE))
                        (TREE-SIZE TREE)))
             ((ENABLE F$TV-DEC-PASS-NG LENGTH TREE-SIZE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$TV-DEC-PASS-NG-LENGTH-1
             (REWRITE)
             (IMPLIES MAKE-G
                      (EQUAL (LENGTH (CDR (F$TV-DEC-PASS-NG C A TREE MAKE-G)))
                             (TREE-SIZE TREE)))
             ((ENABLE F$TV-DEC-PASS-NG LENGTH TREE-SIZE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA PROPERP-F$TV-DEC-PASS-NG
             (REWRITE)
             (PROPERP (F$TV-DEC-PASS-NG C A TREE MAKE-G))
             ((ENABLE PROPERP F$TV-DEC-PASS-NG)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA PROPERP-CDR-F$TV-DEC-PASS-NG
             (REWRITE)
             (IMPLIES MAKE-G
                      (PROPERP (CDR (F$TV-DEC-PASS-NG C A TREE MAKE-G))))
             ((ENABLE PROPERP F$TV-DEC-PASS-NG)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$TV-DEC-PASS-NG=TV-DEC-PASS-NG$SUPER-CROCK
             (REWRITE)
             (IMPLIES (EQUAL (F$TV-DEC-PASS-NG C A TREE MAKE-G)
                             (TV-DEC-PASS-NG C A TREE MAKE-G))
                      (BOOLP (CAR (F$TV-DEC-PASS-NG C A TREE MAKE-G)))))

(TOGGLE F$TV-DEC-PASS-NG=TV-DEC-PASS-NG$SUPER-CROCK-OFF
        F$TV-DEC-PASS-NG=TV-DEC-PASS-NG$SUPER-CROCK T)

(PROVE-LEMMA F$TV-DEC-PASS-NG=TV-DEC-PASS-NG
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (F$TV-DEC-PASS-NG C A TREE MAKE-G)
                             (TV-DEC-PASS-NG C A TREE MAKE-G)))
             ((INDUCT (TV-DEC-PASS-NG C A TREE MAKE-G))
              (ENABLE BVP BOOLP-B-GATES B-BUF-X=X
                      F$TV-DEC-PASS-NG=TV-DEC-PASS-NG$SUPER-CROCK)
              (EXPAND (F$TV-DEC-PASS-NG C A TREE MAKE-G)
                      (TV-DEC-PASS-NG C A TREE MAKE-G)
                      (F$TV-DEC-PASS-NG C A TREE F)
                      (TV-DEC-PASS-NG C A TREE F))
              (DISABLE-THEORY F-GATES B-GATES)
              (DISABLE TV-DEC-PASS-NG-IS-CDR-TV-DEC-PASS
                       TV-DEC-PASS-NG-WORKS-1 TV-DEC-PASS-NG-WORKS-2)))

(DEFN DEC-PASS-CELL* NIL
      '(DEC-PASS-CELL (C A)
                      (G Z)
                      ((G0 (G) ID (A))
                       (G1 (Z) B-EQUV (A C)))
                      NIL))

(DEFN DEC-PASS-CELL&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DEC-PASS-CELL
                                 NETLIST)
                  (DEC-PASS-CELL*))
           (ID& (DELETE-MODULE 'DEC-PASS-CELL
                               NETLIST))
           (B-EQUV& (DELETE-MODULE 'DEC-PASS-CELL
                                   NETLIST))))

(TOGGLE DEC-PASS-CELL&-OFF DEC-PASS-CELL& T)

(DEFN DEC-PASS-CELL$NETLIST NIL
      (CONS (DEC-PASS-CELL*)
            (UNION (ID$NETLIST)
                   (B-EQUV$NETLIST))))

(PROVE-LEMMA DEC-PASS-CELL$VALUE
             (REWRITE)
             (IMPLIES (DEC-PASS-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DEC-PASS-CELL
                                        (LIST C A)
                                        STATE NETLIST)
                             (LIST A (F-EQUV A C))))
             ((ENABLE DEC-PASS-CELL& ID$VALUE B-EQUV$VALUE)
              (DISABLE-THEORY F-GATES)))

(DEFN TV-DEC-PASS-NAME
      (TREE MAKE-G)
      (IF MAKE-G
          (INDEX 'TV-DEC-PASS-G
                 (TREE-NUMBER TREE))
          (INDEX 'TV-DEC-PASS-NG
                 (TREE-NUMBER TREE))))

(DEFN TV-DEC-PASS-NG-BODY
 (TREE MAKE-G)
 (COND
  ((NLISTP TREE)
   (LIST (LIST 'LEAF
               (LIST 'G (INDEX 'Z 0))
               'DEC-PASS-CELL
               (LIST 'C (INDEX 'A 0)))))
  (MAKE-G
         (CONS (LIST 'LEFT
                     (CONS 'GL
                           (TFIRSTN (INDICES 'Z 0 (TREE-SIZE TREE))
                                    TREE))
                     (INDEX 'TV-DEC-PASS-G
                            (TREE-NUMBER (CAR TREE)))
                     (CONS 'C
                           (TFIRSTN (INDICES 'A 0 (TREE-SIZE TREE))
                                    TREE)))
               (CONS '(CARRY (CX) B-OR (C GL))
                     (CONS (LIST 'RIGHT
                                 (CONS 'GR
                                       (TRESTN (INDICES 'Z 0 (TREE-SIZE TREE))
                                               TREE))
                                 (INDEX 'TV-DEC-PASS-G
                                        (TREE-NUMBER (CDR TREE)))
                                 (CONS 'CX
                                       (TRESTN (INDICES 'A 0 (TREE-SIZE TREE))
                                               TREE)))
                           '((GENERATE (G) B-OR (GL GR)))))))
  (T (LIST (LIST 'LEFT
                 (CONS 'GL
                       (TFIRSTN (INDICES 'Z 0 (TREE-SIZE TREE))
                                TREE))
                 (INDEX 'TV-DEC-PASS-G
                        (TREE-NUMBER (CAR TREE)))
                 (CONS 'C
                       (TFIRSTN (INDICES 'A 0 (TREE-SIZE TREE))
                                TREE)))
           '(CARRY (CX) B-OR (C GL))
           (LIST 'RIGHT
                 (TRESTN (INDICES 'Z 0 (TREE-SIZE TREE))
                         TREE)
                 (INDEX 'TV-DEC-PASS-NG
                        (TREE-NUMBER (CDR TREE)))
                 (CONS 'CX
                       (TRESTN (INDICES 'A 0 (TREE-SIZE TREE))
                               TREE)))))))

(TOGGLE TV-DEC-PASS-NG-BODY-OFF TV-DEC-PASS-NG-BODY T)

(DEFN TV-DEC-PASS-NG*
      (TREE MAKE-G)
      (CONS (TV-DEC-PASS-NAME TREE MAKE-G)
            (CONS (CONS 'C
                        (INDICES 'A 0 (TREE-SIZE TREE)))
                  (CONS (IF MAKE-G
                            (CONS 'G
                                  (INDICES 'Z 0 (TREE-SIZE TREE)))
                            (INDICES 'Z 0 (TREE-SIZE TREE)))
                        (CONS (TV-DEC-PASS-NG-BODY TREE MAKE-G)
                              '(NIL))))))

(PROVE-LEMMA TV-DEC-PASS-NG*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TV-DEC-PASS-NG* TREE MAKE-G))
                         (TV-DEC-PASS-NAME TREE MAKE-G))
                  (EQUAL (CADR (TV-DEC-PASS-NG* TREE MAKE-G))
                         (CONS 'C
                               (INDICES 'A 0 (TREE-SIZE TREE))))
                  (EQUAL (CADDR (TV-DEC-PASS-NG* TREE MAKE-G))
                         (IF MAKE-G
                             (CONS 'G
                                   (INDICES 'Z 0 (TREE-SIZE TREE)))
                             (INDICES 'Z 0 (TREE-SIZE TREE))))
                  (EQUAL (CADDDR (TV-DEC-PASS-NG* TREE MAKE-G))
                         (TV-DEC-PASS-NG-BODY TREE MAKE-G))
                  (EQUAL (CADDDDR (TV-DEC-PASS-NG* TREE MAKE-G))
                         NIL)))

(TOGGLE TV-DEC-PASS-NG*-OFF TV-DEC-PASS-NG* T)

(TOGGLE TV-DEC-PASS-NG*$DESTRUCTURE-OFF TV-DEC-PASS-NG*$DESTRUCTURE T)

(DEFN TV-DEC-PASS-NG&
      (NETLIST TREE MAKE-G)
      (IF (NLISTP TREE)
          (AND (EQUAL (LOOKUP-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                     NETLIST)
                      (TV-DEC-PASS-NG* TREE MAKE-G))
               (DEC-PASS-CELL& (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                              NETLIST)))
          (AND (EQUAL (LOOKUP-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                     NETLIST)
                      (TV-DEC-PASS-NG* TREE MAKE-G))
               (TV-DEC-PASS-NG& (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                               NETLIST)
                                (CAR TREE)
                                T)
               (TV-DEC-PASS-NG& (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                               NETLIST)
                                (CDR TREE)
                                MAKE-G)
               (B-OR& (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                     NETLIST)))))

(TOGGLE TV-DEC-PASS-NG&-OFF TV-DEC-PASS-NG& T)

(DEFN TV-DEC-PASS-NG-INDUCTION
 (TREE C A MAKE-G NAME STATE NETLIST)
 (IF
   (NLISTP TREE)
   T
   (AND (TV-DEC-PASS-NG-INDUCTION (CAR TREE)
                                  C
                                  (TFIRSTN A TREE)
                                  T
                                  (INDEX 'TV-DEC-PASS-G
                                         (TREE-NUMBER (CAR TREE)))
                                  0
                                  (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                                 NETLIST))
        (TV-DEC-PASS-NG-INDUCTION (CDR TREE)
                                  (F-OR C
                                        (CAR (F$TV-DEC-PASS-NG C
                                                               (TFIRSTN A TREE)
                                                               (CAR TREE)
                                                               T)))
                                  (TRESTN A TREE)
                                  T
                                  (INDEX 'TV-DEC-PASS-G
                                         (TREE-NUMBER (CDR TREE)))
                                  0
                                  (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                                 NETLIST))
        (TV-DEC-PASS-NG-INDUCTION (CDR TREE)
                                  (F-OR C
                                        (CAR (F$TV-DEC-PASS-NG C
                                                               (TFIRSTN A TREE)
                                                               (CAR TREE)
                                                               T)))
                                  (TRESTN A TREE)
                                  F
                                  (INDEX 'TV-DEC-PASS-NG
                                         (TREE-NUMBER (CDR TREE)))
                                  0
                                  (DELETE-MODULE (TV-DEC-PASS-NAME TREE MAKE-G)
                                                 NETLIST)))))

(PROVE-LEMMA TV-DEC-PASS-NG-LEMMA-CROCK
     (REWRITE)
     (AND (IMPLIES (TV-DEC-PASS-NG& (DELETE-MODULE (INDEX 'TV-DEC-PASS-G
                                                          (TREE-NUMBER TREE))
                                                   NETLIST)
                                    (CAR TREE)
                                    MAKE-G)
                   (EQUAL (COLLECT-VALUE (INDICES 'Z 0 N)
                                         BINDINGS)
                          (APPEND (COLLECT-VALUE (FIRSTN (TREE-SIZE (CAR TREE))
                                                         (INDICES 'Z 0 N))
                                                 BINDINGS)
                                  (COLLECT-VALUE (RESTN (TREE-SIZE (CAR TREE))
                                                        (INDICES 'Z 0 N))
                                                 BINDINGS))))
          (IMPLIES (TV-DEC-PASS-NG& (DELETE-MODULE (INDEX 'TV-DEC-PASS-NG
                                                          (TREE-NUMBER TREE))
                                                   NETLIST)
                                    (CAR TREE)
                                    MAKE-G)
                   (EQUAL (COLLECT-VALUE (INDICES 'Z 0 N)
                                         BINDINGS)
                          (APPEND (COLLECT-VALUE (FIRSTN (TREE-SIZE (CAR TREE))
                                                         (INDICES 'Z 0 N))
                                                 BINDINGS)
                                  (COLLECT-VALUE (RESTN (TREE-SIZE (CAR TREE))
                                                        (INDICES 'Z 0 N))
                                                 BINDINGS)))))
     ((USE (COLLECT-VALUE-SPLITTING-CROCK (L (INDICES 'Z 0 N))
                                          (N (TREE-SIZE (CAR TREE)))
                                          (ALIST BINDINGS)))))

(TOGGLE TV-DEC-PASS-NG-LEMMA-CROCK-OFF TV-DEC-PASS-NG-LEMMA-CROCK T)

(PROVE-LEMMA TV-DEC-PASS-NG$VALUE
             (REWRITE)
             (IMPLIES (AND (TV-DEC-PASS-NG& NETLIST TREE MAKE-G)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (PROPERP A)
                           (BOOLP MAKE-G)
                           (EQUAL NAME
                                  (TV-DEC-PASS-NAME TREE MAKE-G)))
                      (EQUAL (DUAL-EVAL 0 NAME
                                        (CONS C A)
                                        STATE NETLIST)
                             (F$TV-DEC-PASS-NG C A TREE MAKE-G)))
             ((INDUCT (TV-DEC-PASS-NG-INDUCTION TREE C A MAKE-G NAME STATE
                                                NETLIST))
              (DISABLE OPEN-INDICES INDICES)
              (ENABLE TV-DEC-PASS-NG*$DESTRUCTURE TV-DEC-PASS-NG-LEMMA-CROCK
                      DEC-PASS-CELL$VALUE B-OR$VALUE TV-DEC-PASS-NG-BODY BOOLP
                      F$TV-DEC-PASS-NG TV-DEC-PASS-NG&)
              (DISABLE-THEORY F-GATES)
              (EXPAND (TV-DEC-PASS-NG& NETLIST TREE F)
                      (TV-DEC-PASS-NG& NETLIST TREE MAKE-G))))

(TOGGLE TV-DEC-PASS-NG$VALUE-OFF TV-DEC-PASS-NG$VALUE T)

(DEFN TV-DEC-PASS-NG$NETLIST
      (TREE MAKE-G)
      (IF (NLISTP TREE)
          (LIST (TV-DEC-PASS-NG* TREE MAKE-G)
                (DEC-PASS-CELL*))
          (CONS (TV-DEC-PASS-NG* TREE MAKE-G)
                (UNION (TV-DEC-PASS-NG$NETLIST (CAR TREE) T)
                       (TV-DEC-PASS-NG$NETLIST (CDR TREE)
                                               MAKE-G)))))

(PROVE-LEMMA CHECK-TV-DEC-PASS-NG$NETLIST NIL
             (IMPLIES (BOOLP MAKE-G)
                      (TV-DEC-PASS-NG& (TV-DEC-PASS-NG$NETLIST '(0 0 . 0)
                                                               MAKE-G)
                                       '(0 0 . 0)
                                       MAKE-G))
             ((ENABLE BOOLP)))

(DEFN DEC-PASS*
      (N)
      (CONS (INDEX 'DEC-PASS N)
            (CONS (CONS 'C (INDICES 'A 0 N))
                  (CONS (INDICES 'Z 0 N)
                        (CONS (LIST '(M0 (CN) B-NOT (C))
                                    (LIST 'M1
                                          (INDICES 'Z 0 N)
                                          (INDEX 'TV-DEC-PASS-NG
                                                 (TREE-NUMBER (MAKE-TREE N)))
                                          (CONS 'CN (INDICES 'A 0 N))))
                              '(NIL))))))

(PROVE-LEMMA DEC-PASS*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (DEC-PASS* N))
                         (INDEX 'DEC-PASS N))
                  (EQUAL (CADR (DEC-PASS* N))
                         (CONS 'C (INDICES 'A 0 N)))
                  (EQUAL (CADDR (DEC-PASS* N))
                         (INDICES 'Z 0 N))
                  (EQUAL (CADDDR (DEC-PASS* N))
                         (LIST '(M0 (CN) B-NOT (C))
                               (LIST 'M1
                                     (INDICES 'Z 0 N)
                                     (INDEX 'TV-DEC-PASS-NG
                                            (TREE-NUMBER (MAKE-TREE N)))
                                     (CONS 'CN (INDICES 'A 0 N)))))
                  (EQUAL (CADDDDR (DEC-PASS* N)) NIL)))

(TOGGLE DEC-PASS*-OFF DEC-PASS* T)

(TOGGLE DEC-PASS*$DESTRUCTURE-OFF DEC-PASS*$DESTRUCTURE T)

(DEFN DEC-PASS&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'DEC-PASS N)
                                 NETLIST)
                  (DEC-PASS* N))
           (B-NOT& (DELETE-MODULE (INDEX 'DEC-PASS N)
                                  NETLIST))
           (TV-DEC-PASS-NG& (DELETE-MODULE (INDEX 'DEC-PASS N)
                                           NETLIST)
                            (MAKE-TREE N)
                            F)))

(TOGGLE DEC-PASS&-OFF DEC-PASS& T)

(DEFN F$DEC-PASS
      (C A)
      (F$TV-DEC-PASS-NG (F-NOT C)
                        A
                        (MAKE-TREE (LENGTH A))
                        F))

(TOGGLE F$DEC-PASS-OFF F$DEC-PASS T)

(PROVE-LEMMA PROPERP-LENGTH-F$DEC-PASS
             (REWRITE)
             (AND (PROPERP (F$DEC-PASS C V))
                  (IMPLIES (NOT (EQUAL (LENGTH V) 0))
                           (EQUAL (LENGTH (F$DEC-PASS C V))
                                  (LENGTH V))))
             ((ENABLE F$DEC-PASS)))

(PROVE-LEMMA F$DEC-PASS=DEC-OR-PASS
             (REWRITE)
             (IMPLIES (AND (BVP V)
                           (BOOLP DEC)
                           (NOT (EQUAL (LENGTH V) 0)))
                      (EQUAL (F$DEC-PASS DEC V)
                             (IF* DEC (V-DEC V) V)))
             ((ENABLE F$DEC-PASS)))

(PROVE-LEMMA DEC-PASS$VALUE
             (REWRITE)
             (IMPLIES (AND (DEC-PASS& NETLIST N)
                           (NOT (ZEROP N))
                           (EQUAL (LENGTH A) N)
                           (PROPERP A))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'DEC-PASS N)
                                        (CONS C A)
                                        STATE NETLIST)
                             (F$DEC-PASS C A)))
             ((ENABLE DEC-PASS& DEC-PASS*$DESTRUCTURE B-NOT$VALUE
                      TV-DEC-PASS-NG$VALUE F$DEC-PASS)
              (DISABLE OPEN-INDICES LENGTH)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DEC-PASS$VALUE-OFF DEC-PASS$VALUE T)

(DEFN DEC-PASS$NETLIST
      (N)
      (CONS (DEC-PASS* N)
            (UNION (B-NOT$NETLIST)
                   (TV-DEC-PASS-NG$NETLIST (MAKE-TREE N)
                                           F))))

(PROVE-LEMMA CHECK-DEC-PASS$NETLIST NIL
             (DEC-PASS& (DEC-PASS$NETLIST 7) 7))

(DEFN REG-BODY
      (M N TI TE)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Q M) (INDEX 'QB M))
                      'FD1S
                      (LIST (INDEX 'D M) 'CLK TI TE))
                (REG-BODY (ADD1 M)
                          (SUB1 N)
                          (INDEX 'Q M)
                          TE))))

(TOGGLE REG-BODY-OFF REG-BODY T)

(DEFN REG*
      (N)
      (LIST (INDEX 'REG N)
            (CONS 'CLK
                  (CONS 'TE
                        (CONS 'TI (INDICES 'D 0 N))))
            (INDICES 'Q 0 N)
            (CONS (CONS 'TE-BUFFER
                        (CONS '(TE-BUF)
                              (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                    '((TE)))))
                  (CONS '(TI-DEL (TI-BUF) DEL4 (TI))
                        (REG-BODY 0 N 'TI-BUF 'TE-BUF)))
            (INDICES 'G 0 N)))

(PROVE-LEMMA REG*$DESTRUCTURE
       (REWRITE)
       (AND (EQUAL (CAR (REG* N)) (INDEX 'REG N))
            (EQUAL (CADR (REG* N))
                   (CONS 'CLK
                         (CONS 'TE
                               (CONS 'TI (INDICES 'D 0 N)))))
            (EQUAL (CADDR (REG* N))
                   (INDICES 'Q 0 N))
            (EQUAL (CADDDR (REG* N))
                   (CONS (CONS 'TE-BUFFER
                               (CONS '(TE-BUF)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((TE)))))
                         (CONS '(TI-DEL (TI-BUF) DEL4 (TI))
                               (REG-BODY 0 N 'TI-BUF 'TE-BUF))))
            (EQUAL (CADDDDR (REG* N))
                   (INDICES 'G 0 N))))

(TOGGLE REG*-OFF REG* T)

(TOGGLE REG*$DESTRUCTURE-OFF REG*$DESTRUCTURE T)

(DEFN REG&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'REG N)
                                 NETLIST)
                  (REG* N))
           (IF (LESSP N 8)
               (B-BUF& (DELETE-MODULE (INDEX 'REG N)
                                      NETLIST))
               (B-BUF-PWR& (DELETE-MODULE (INDEX 'REG N)
                                          NETLIST)))
           (DEL4& (DELETE-MODULE (INDEX 'REG N)
                                 NETLIST))
           (FD1S& (DELETE-MODULE (INDEX 'REG N)
                                 NETLIST))))

(TOGGLE REG&-OFF REG& T)

(DEFN REG$NETLIST
      (N)
      (CONS (REG* N)
            (UNION (IF (LESSP N 8)
                       (B-BUF$NETLIST)
                       (B-BUF-PWR$NETLIST))
                   (UNION (DEL4$NETLIST)
                          (FD1S$NETLIST)))))

(PROVE-LEMMA REG-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (AND (UNBOUND-IN-BODY 'CLK
                                   (REG-BODY M N TI TE))
                  (UNBOUND-IN-BODY 'TI
                                   (REG-BODY M N TI TE))
                  (UNBOUND-IN-BODY 'TI-DEL
                                   (REG-BODY M N TI TE))
                  (UNBOUND-IN-BODY 'TE
                                   (REG-BODY M N TI TE))
                  (UNBOUND-IN-BODY 'TE-BUF
                                   (REG-BODY M N TI TE))
                  (UNBOUND-IN-BODY (INDEX 'D L)
                                   (REG-BODY M N TI TE))
                  (IMPLIES (LESSP L M)
                           (UNBOUND-IN-BODY (INDEX 'Q L)
                                            (REG-BODY M N TI TE))))
             ((ENABLE UNBOUND-IN-BODY REG-BODY)))

(TOGGLE REG-BODY$UNBOUND-IN-BODY-OFF REG-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA REG-BODY$ALL-UNBOUND-IN-BODY
             (REWRITE)
             (ALL-UNBOUND-IN-BODY (INDICES 'D X Y)
                                  (REG-BODY M N TI TE))
             ((ENABLE ALL-UNBOUND-IN-BODY REG-BODY INDICES-AS-APPEND)))

(TOGGLE REG-BODY$ALL-UNBOUND-IN-BODY-OFF REG-BODY$ALL-UNBOUND-IN-BODY T)

(DEFN REG-BODY-INDUCTION
      (M N TI TE BINDINGS STATE-BINDINGS NETLIST)
      (IF (ZEROP N)
          T
          (REG-BODY-INDUCTION (ADD1 M)
                              (SUB1 N)
                              (INDEX 'Q M)
                              TE
                              (DUAL-EVAL-BODY-BINDINGS 1
                                                       (REG-BODY M N TI TE)
                                                       BINDINGS STATE-BINDINGS
                                                       NETLIST)
                              STATE-BINDINGS NETLIST)))

(PROVE-LEMMA REG-BODY$VALUE NIL
             (IMPLIES (FD1S& NETLIST)
                      (EQUAL (COLLECT-VALUE (INDICES 'Q M N)
                                            (DUAL-EVAL 1
                                                       (REG-BODY M N TI TE)
                                                       BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-THREEFIX (COLLECT-VALUE (INDICES 'G M N)
                                                        STATE-BINDINGS))))
             ((INDUCT (REG-BODY-INDUCTION M N TI TE BINDINGS STATE-BINDINGS
                                          NETLIST))
              (ENABLE REG-BODY FD1S$VALUE REG-BODY$UNBOUND-IN-BODY)
              (DISABLE F-NOT THREEFIX)))

(PROVE-LEMMA REG$VALUE
 (REWRITE)
 (IMPLIES (AND (REG& NETLIST N)
               (EQUAL (LENGTH STATE) N)
               (PROPERP STATE))
          (EQUAL (DUAL-EVAL 0
                            (INDEX 'REG N)
                            INPUTS STATE NETLIST)
                 (V-THREEFIX STATE)))
 ((USE
   (REG-BODY$VALUE
    (M 0)
    (TI 'TI-BUF)
    (TE 'TE-BUF)
    (NETLIST (DELETE-MODULE (INDEX 'REG N)
                            NETLIST))
    (BINDINGS (CONS (CONS 'TI-BUF (F-BUF (CADDR INPUTS)))
                    (CONS (CONS 'TE-BUF (F-BUF (CADR INPUTS)))
                          (PAIRLIST (CONS 'CLK
                                          (CONS 'TE
                                                (CONS 'TI (INDICES 'D 0 N))))
                                    INPUTS))))
    (STATE-BINDINGS (PAIRSTATES (INDICES 'G 0 N)
                                STATE))))
  (ENABLE REG& REG*$DESTRUCTURE B-BUF-PWR$VALUE B-BUF$VALUE DEL4$VALUE)
  (DISABLE OPEN-V-THREEFIX OPEN-INDICES)))

(TOGGLE REG$VALUE-OFF REG$VALUE T)

(PROVE-LEMMA REG-BODY$STATE NIL
             (IMPLIES (AND (FD1S& NETLIST)
                           (NOT (VALUE TE BINDINGS)))
                      (EQUAL (COLLECT-VALUE (INDICES 'G M N)
                                            (DUAL-EVAL 3
                                                       (REG-BODY M N TI TE)
                                                       BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-THREEFIX (COLLECT-VALUE (INDICES 'D M N)
                                                        BINDINGS))))
             ((ENABLE REG-BODY FD1S$STATE)
              (DISABLE THREEFIX)))

(PROVE-LEMMA REG$STATE
 (REWRITE)
 (IMPLIES (AND (REG& NETLIST N)
               (EQUAL (LENGTH D) N)
               (PROPERP D)
               (NOT TE))
          (EQUAL (DUAL-EVAL 2
                            (INDEX 'REG N)
                            (CONS CLK (CONS TE (CONS TI D)))
                            STATE NETLIST)
                 (V-THREEFIX D)))
 ((USE
   (REG-BODY$STATE
    (M 0)
    (TI 'TI-BUF)
    (TE 'TE-BUF)
    (NETLIST (DELETE-MODULE (INDEX 'REG N)
                            NETLIST))
    (BINDINGS
     (DUAL-EVAL 1
            (REG-BODY 0 N 'TI-BUF 'TE-BUF)
            (PAIRLIST (CONS 'TI-BUF
                            (CONS 'TE-BUF
                                  (CONS 'CLK
                                        (CONS 'TE
                                              (CONS 'TI (INDICES 'D 0 N))))))
                      (CONS (F-BUF TI)
                            (CONS (F-BUF TE)
                                  (CONS CLK (CONS TE (CONS TI D))))))
            (PAIRSTATES (INDICES 'G 0 N) STATE)
            (DELETE-MODULE (INDEX 'REG N)
                           NETLIST)))
    (STATE-BINDINGS (PAIRSTATES (INDICES 'G 0 N)
                                STATE))))
  (ENABLE REG& REG-BODY$UNBOUND-IN-BODY REG-BODY$ALL-UNBOUND-IN-BODY
          REG*$DESTRUCTURE B-BUF-PWR$VALUE B-BUF$VALUE DEL4$VALUE)
  (DISABLE OPEN-INDICES OPEN-V-THREEFIX V-THREEFIX)))

(TOGGLE REG$STATE-OFF REG$STATE T)

(DEFN WE-REG-BODY
      (M N TI)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'Q M) (INDEX 'QB M))
                      'FD1SLP
                      (CONS (INDEX 'D M)
                            (CONS 'CLK
                                  (CONS 'WE-BUF (CONS TI '(TE-BUF))))))
                (WE-REG-BODY (ADD1 M)
                             (SUB1 N)
                             (INDEX 'Q M)))))

(TOGGLE WE-REG-BODY-OFF WE-REG-BODY T)

(DEFN WE-REG*
      (N)
      (LIST (INDEX 'WE-REG N)
            (CONS 'CLK
                  (CONS 'WE
                        (CONS 'TE
                              (CONS 'TI (INDICES 'D 0 N)))))
            (INDICES 'Q 0 N)
            (CONS (CONS 'WE-BUFFER
                        (CONS '(WE-BUF)
                              (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                    '((WE)))))
                  (CONS (CONS 'TE-BUFFER
                              (CONS '(TE-BUF)
                                    (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                          '((TE)))))
                        (CONS '(TI-DEL (TI-BUF) DEL4 (TI))
                              (WE-REG-BODY 0 N 'TI-BUF))))
            (INDICES 'G 0 N)))

(PROVE-LEMMA WE-REG*$DESTRUCTURE
 (REWRITE)
 (AND (EQUAL (CAR (WE-REG* N))
             (INDEX 'WE-REG N))
      (EQUAL (CADR (WE-REG* N))
             (CONS 'CLK
                   (CONS 'WE
                         (CONS 'TE
                               (CONS 'TI (INDICES 'D 0 N))))))
      (EQUAL (CADDR (WE-REG* N))
             (INDICES 'Q 0 N))
      (EQUAL (CADDDR (WE-REG* N))
             (CONS (CONS 'WE-BUFFER
                         (CONS '(WE-BUF)
                               (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                     '((WE)))))
                   (CONS (CONS 'TE-BUFFER
                               (CONS '(TE-BUF)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((TE)))))
                         (CONS '(TI-DEL (TI-BUF) DEL4 (TI))
                               (WE-REG-BODY 0 N 'TI-BUF)))))
      (EQUAL (CADDDDR (WE-REG* N))
             (INDICES 'G 0 N))))

(TOGGLE WE-REG*-OFF WE-REG* T)

(TOGGLE WE-REG*$DESTRUCTURE-OFF WE-REG*$DESTRUCTURE T)

(DEFN WE-REG&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'WE-REG N)
                                 NETLIST)
                  (WE-REG* N))
           (IF (LESSP N 8)
               (B-BUF& (DELETE-MODULE (INDEX 'WE-REG N)
                                      NETLIST))
               (B-BUF-PWR& (DELETE-MODULE (INDEX 'WE-REG N)
                                          NETLIST)))
           (DEL4& (DELETE-MODULE (INDEX 'WE-REG N)
                                 NETLIST))
           (FD1SLP& (DELETE-MODULE (INDEX 'WE-REG N)
                                   NETLIST))))

(TOGGLE WE-REG&-OFF WE-REG& T)

(DEFN WE-REG$NETLIST
      (N)
      (CONS (WE-REG* N)
            (UNION (IF (LESSP N 8)
                       (B-BUF$NETLIST)
                       (B-BUF-PWR$NETLIST))
                   (UNION (DEL4$NETLIST)
                          (FD1SLP$NETLIST)))))

(PROVE-LEMMA WE-REG-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (AND (UNBOUND-IN-BODY 'CLK
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'WE
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'WE-BUF
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'TI
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'TI-BUF
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'TE
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY 'TE-BUF
                                   (WE-REG-BODY M N TI))
                  (UNBOUND-IN-BODY (INDEX 'D L)
                                   (WE-REG-BODY M N TI))
                  (IMPLIES (LESSP L M)
                           (UNBOUND-IN-BODY (INDEX 'Q L)
                                            (WE-REG-BODY M N TI))))
             ((ENABLE UNBOUND-IN-BODY WE-REG-BODY)))

(TOGGLE WE-REG-BODY$UNBOUND-IN-BODY-OFF WE-REG-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA WE-REG-BODY$ALL-UNBOUND-IN-BODY
             (REWRITE)
             (ALL-UNBOUND-IN-BODY (INDICES 'D X Y)
                                  (WE-REG-BODY M N TI))
             ((ENABLE ALL-UNBOUND-IN-BODY WE-REG-BODY INDICES-AS-APPEND)))

(TOGGLE WE-REG-BODY$ALL-UNBOUND-IN-BODY-OFF WE-REG-BODY$ALL-UNBOUND-IN-BODY T)

(DEFN WE-REG-BODY-INDUCTION
      (M N TI BINDINGS STATE-BINDINGS NETLIST)
      (IF (ZEROP N)
          T
          (WE-REG-BODY-INDUCTION (ADD1 M)
                                 (SUB1 N)
                                 (INDEX 'Q M)
                                 (DUAL-EVAL-BODY-BINDINGS 1
                                                          (WE-REG-BODY M N TI)
                                                          BINDINGS
                                                          STATE-BINDINGS
                                                          NETLIST)
                                 STATE-BINDINGS NETLIST)))

(PROVE-LEMMA WE-REG-BODY$VALUE
             (REWRITE)
             (IMPLIES (FD1SLP& NETLIST)
                      (EQUAL (COLLECT-VALUE (INDICES 'Q M N)
                                            (DUAL-EVAL 1
                                                       (WE-REG-BODY M N TI)
                                                       BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (V-THREEFIX (COLLECT-VALUE (INDICES 'G M N)
                                                        STATE-BINDINGS))))
             ((INDUCT (WE-REG-BODY-INDUCTION M N TI BINDINGS STATE-BINDINGS
                                             NETLIST))
              (ENABLE WE-REG-BODY FD1SLP$VALUE WE-REG-BODY$UNBOUND-IN-BODY)
              (DISABLE F-NOT THREEFIX)))

(TOGGLE WE-REG-BODY$VALUE-OFF WE-REG-BODY$VALUE T)

(PROVE-LEMMA WE-REG$VALUE
             (REWRITE)
             (IMPLIES (AND (WE-REG& NETLIST N)
                           (EQUAL (LENGTH STATE) N)
                           (PROPERP STATE))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'WE-REG N)
                                        INPUTS STATE NETLIST)
                             (V-THREEFIX STATE)))
             ((ENABLE WE-REG& B-BUF$VALUE B-BUF-PWR$VALUE DEL4$VALUE
                      WE-REG-BODY$VALUE WE-REG*$DESTRUCTURE)
              (DISABLE OPEN-INDICES)))

(TOGGLE WE-REG$VALUE-OFF WE-REG$VALUE T)

(PROVE-LEMMA WE-REG-BODY$STATE
             (REWRITE)
             (IMPLIES (AND (FD1SLP& NETLIST)
                           (NOT (VALUE 'TE-BUF BINDINGS)))
                      (EQUAL (COLLECT-VALUE (INDICES 'G M N)
                                            (DUAL-EVAL 3
                                                       (WE-REG-BODY M N TI)
                                                       BINDINGS
                                                       STATE-BINDINGS NETLIST))
                             (FV-IF (VALUE 'WE-BUF BINDINGS)
                                    (COLLECT-VALUE (INDICES 'D M N)
                                                   BINDINGS)
                                    (COLLECT-VALUE (INDICES 'G M N)
                                                   STATE-BINDINGS))))
             ((ENABLE WE-REG-BODY FD1SLP$STATE BOOLP FV-IF)
              (DISABLE THREEFIX)))

(TOGGLE WE-REG-BODY$STATE-OFF WE-REG-BODY$STATE T)

(PROVE-LEMMA WE-REG$STATE
             (REWRITE)
             (IMPLIES (AND (WE-REG& NETLIST N)
                           (EQUAL (LENGTH D) N)
                           (PROPERP D)
                           (EQUAL (LENGTH STATE) N)
                           (PROPERP STATE)
                           (NOT TE))
                      (EQUAL (DUAL-EVAL 2
                                        (INDEX 'WE-REG N)
                                        (CONS CLK
                                              (CONS WE (CONS TE (CONS TI D))))
                                        STATE NETLIST)
                             (FV-IF WE D STATE)))
             ((ENABLE WE-REG& WE-REG-BODY$STATE BOOLP B-BUF-PWR$VALUE
                      B-BUF$VALUE DEL4$VALUE WE-REG-BODY$VALUE WE-REG$VALUE
                      WE-REG-BODY$UNBOUND-IN-BODY
                      WE-REG-BODY$ALL-UNBOUND-IN-BODY WE-REG*$DESTRUCTURE
                      FV-IF-REWRITE)
              (DISABLE-THEORY F-GATES)
              (DISABLE OPEN-INDICES OPEN-V-THREEFIX)))

(TOGGLE WE-REG$STATE-OFF WE-REG$STATE T)

(DEFN CVZBV
      (CARRY OVERFLOW VECTOR)
      (CONS CARRY
            (CONS OVERFLOW
                  (CONS (V-ZEROP VECTOR) VECTOR))))

(DEFN C (CVZBV) (CAR CVZBV))

(DEFN V (CVZBV) (CADR CVZBV))

(DEFN BV (CVZBV) (CDDDR CVZBV))

(DEFN N (CVZBV) (V-NEGP (BV CVZBV)))

(DEFN ZB (CVZBV) (CADDR CVZBV))

(TOGGLE C-OFF C T)

(TOGGLE V-OFF V T)

(TOGGLE N-OFF N T)

(TOGGLE ZB-OFF ZB T)

(TOGGLE BV-OFF BV T)

(PROVE-LEMMA BOOLP-N
             (REWRITE)
             (IMPLIES (BVP (BV V)) (BOOLP (N V)))
             ((ENABLE N)))

(PROVE-LEMMA BOOLP-BVP-CVZBV
             (REWRITE)
             (AND (EQUAL (BOOLP (C (CVZBV C V BV)))
                         (BOOLP C))
                  (EQUAL (BOOLP (V (CVZBV C V BV)))
                         (BOOLP V))
                  (BOOLP (ZB (CVZBV C V BV)))
                  (EQUAL (BVP (BV (CVZBV C V BV)))
                         (BVP BV)))
             ((ENABLE C V ZB BV)))

(PROVE-LEMMA BVP-CVZBV NIL
             (IMPLIES (AND (BOOLP (C CVZBV))
                           (BOOLP (V CVZBV))
                           (BOOLP (ZB CVZBV))
                           (BVP (BV CVZBV)))
                      (BVP CVZBV))
             ((ENABLE C V ZB BV)))

(DEFN CVZBV-V-ROR
      (C A)
      (CVZBV (IF (NLISTP A) C (NTH 0 A))
             F
             (V-ROR A C)))

(DEFN CVZBV-V-ADDER
      (C A B)
      (CVZBV (V-ADDER-CARRY-OUT C A B)
             (V-ADDER-OVERFLOWP C A B)
             (V-ADDER-OUTPUT C A B)))

(DEFN CVZBV-V-LSL
      (A)
      (CVZBV-V-ADDER F A A))

(DEFN CVZBV-V-SUBTRACTER
      (C A B)
      (CVZBV (V-SUBTRACTER-CARRY-OUT C A B)
             (V-SUBTRACTER-OVERFLOWP C A B)
             (V-SUBTRACTER-OUTPUT C A B)))

(DEFN CVZBV-INC
      (A)
      (CVZBV-V-ADDER T A
                     (NAT-TO-V 0 (LENGTH A))))

(DEFN CVZBV-NEG
      (A)
      (CVZBV-V-SUBTRACTER F A
                          (NAT-TO-V 0 (LENGTH A))))

(DEFN CVZBV-DEC
      (A)
      (CVZBV-V-SUBTRACTER T
                          (NAT-TO-V 0 (LENGTH A))
                          A))

(DEFN CVZBV-V-NOT
      (A)
      (CVZBV F F (V-NOT A)))

(DEFN CVZBV-V-ASR
      (A)
      (CVZBV (IF (LISTP A) (NTH 0 A) F)
             F
             (V-ASR A)))

(DEFN CVZBV-V-LSR
      (A)
      (CVZBV (IF (LISTP A) (NTH 0 A) F)
             F
             (V-LSR A)))

(DEFN V-ALU
      (C A B OP)
      (COND ((EQUAL OP (LIST F F F F))
             (CVZBV F F (V-BUF A)))
            ((EQUAL OP (LIST T F F F))
             (CVZBV-INC A))
            ((EQUAL OP (LIST F T F F))
             (CVZBV-V-ADDER C A B))
            ((EQUAL OP (LIST T T F F))
             (CVZBV-V-ADDER F A B))
            ((EQUAL OP (LIST F F T F))
             (CVZBV-NEG A))
            ((EQUAL OP (LIST T F T F))
             (CVZBV-DEC A))
            ((EQUAL OP (LIST F T T F))
             (CVZBV-V-SUBTRACTER C A B))
            ((EQUAL OP (LIST T T T F))
             (CVZBV-V-SUBTRACTER F A B))
            ((EQUAL OP (LIST F F F T))
             (CVZBV-V-ROR C A))
            ((EQUAL OP (LIST T F F T))
             (CVZBV-V-ASR A))
            ((EQUAL OP (LIST F T F T))
             (CVZBV-V-LSR A))
            ((EQUAL OP (LIST T T F T))
             (CVZBV F F (V-XOR A B)))
            ((EQUAL OP (LIST F F T T))
             (CVZBV F F (V-OR A B)))
            ((EQUAL OP (LIST T F T T))
             (CVZBV F F (V-AND A B)))
            ((EQUAL OP (LIST F T T T))
             (CVZBV-V-NOT A))
            (T (CVZBV F F (V-BUF A)))))

(TOGGLE V-ALU-OFF V-ALU T)

(PROVE-LEMMA BOOLP-C-V-ALU
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (BOOLP (C (V-ALU C A B OP))))
             ((ENABLE V-ALU) (DISABLE CVZBV)))

(PROVE-LEMMA BOOLP-V-V-ALU
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (BOOLP (V (V-ALU C A B OP))))
             ((ENABLE V-ALU) (DISABLE CVZBV)))

(PROVE-LEMMA BOOLP-ZB-V-ALU
             (REWRITE)
             (BOOLP (ZB (V-ALU C A B OP)))
             ((ENABLE V-ALU)
              (DISABLE CVZBV V-ADDER-CARRY-OUT V-ADDER-OVERFLOWP
                       V-ADDER-OUTPUT V-SUBTRACTER-CARRY-OUT
                       V-SUBTRACTER-OVERFLOWP V-SUBTRACTER-OUTPUT)))

(PROVE-LEMMA BVP-BV-V-ALU
             (REWRITE)
             (IMPLIES (BVP A)
                      (BVP (BV (V-ALU C A B OP))))
             ((ENABLE V-ALU)
              (DISABLE CVZBV V-ADDER-CARRY-OUT V-ADDER-OVERFLOWP
                       V-ADDER-OUTPUT V-SUBTRACTER-CARRY-OUT
                       V-SUBTRACTER-OVERFLOWP B-NOT)))

(PROVE-LEMMA BVP-V-ALU
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (BOOLP C)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (BVP (V-ALU C A B OP)))
             ((USE (BVP-CVZBV (CVZBV (V-ALU C A B OP))))))

(PROVE-LEMMA LENGTH-CVZBV-SUBTRACTER
             (REWRITE)
             (EQUAL (LENGTH (CVZBV-V-SUBTRACTER C A B))
                    (ADD1 (ADD1 (ADD1 (LENGTH A))))))

(PROVE-LEMMA LENGTH-CVZBV-ADDER
             (REWRITE)
             (EQUAL (LENGTH (CVZBV-V-ADDER C A B))
                    (ADD1 (ADD1 (ADD1 (LENGTH A))))))

(PROVE-LEMMA LENGTH-V-ALU
             (REWRITE)
             (EQUAL (LENGTH (V-ALU C A B OP))
                    (ADD1 (ADD1 (ADD1 (LENGTH A)))))
             ((ENABLE V-ALU)
              (DISABLE CVZBV-V-SUBTRACTER)))

(PROVE-LEMMA BVP-LENGTH-BV
             (REWRITE)
             (AND (EQUAL (LENGTH (BV X))
                         (DIFFERENCE (LENGTH X) 3))
                  (IMPLIES (AND (BVP X)
                                (IF (LESSP (LENGTH X) 3) F T))
                           (BVP (BV X))))
             ((ENABLE BV)))

(DEFN UNARY-OP-CODE-P
      (OP-CODE)
      (OR (EQUAL OP-CODE (LIST F F F F))
          (EQUAL OP-CODE (LIST T F F F))
          (EQUAL OP-CODE (LIST F F T F))
          (EQUAL OP-CODE (LIST T F T F))
          (EQUAL OP-CODE (LIST F F F T))
          (EQUAL OP-CODE (LIST T F F T))
          (EQUAL OP-CODE (LIST F T F T))
          (EQUAL OP-CODE (LIST F T T T))
          (EQUAL OP-CODE (LIST T T T T))))

(TOGGLE UNARY-OP-CODE-P-OFF UNARY-OP-CODE-P T)

(DEFN V-ALU-1
      (C A OP-CODE)
      (V-ALU C A A OP-CODE))

(TOGGLE V-ALU-1-OFF V-ALU-1 T)

(PROVE-LEMMA BVP-V-ALU-1
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (BOOLP C)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (BVP (V-ALU-1 C A OP)))
             ((USE (BVP-CVZBV (CVZBV (V-ALU C A A OP))))
              (ENABLE V-ALU-1)))

(PROVE-LEMMA LENGTH-V-ALU-1
             (REWRITE)
             (EQUAL (LENGTH (V-ALU-1 C A OP))
                    (ADD1 (ADD1 (ADD1 (LENGTH A)))))
             ((ENABLE V-ALU-1)))

(PROVE-LEMMA UNARY-OP-CODE-P->V-ALU=V-ALU-1
             (REWRITE)
             (IMPLIES (UNARY-OP-CODE-P OP-CODE)
                      (EQUAL (V-ALU C A B OP-CODE)
                             (V-ALU-1 C A OP-CODE)))
             ((ENABLE UNARY-OP-CODE-P V-ALU V-ALU-1)))

(TOGGLE UNARY-OP-CODE-P->V-ALU=V-ALU-1-OFF UNARY-OP-CODE-P->V-ALU=V-ALU-1 T)

(DEFN ALU-INC-OP NIL (LIST T F F F))

(TOGGLE ALU-INC-OP-OFF ALU-INC-OP T)

(TOGGLE G*1*ALU-INC-OP-OFF *1*ALU-INC-OP T)

(PROVE-LEMMA BVP-LENGTH-ALU-INC-OP
             (REWRITE)
             (AND (EQUAL (LENGTH (ALU-INC-OP)) 4)
                  (BVP (ALU-INC-OP)))
             ((ENABLE ALU-INC-OP)))

(DEFN ALU-DEC-OP NIL (LIST T F T F))

(TOGGLE ALU-DEC-OP-OFF ALU-DEC-OP T)

(TOGGLE G*1*ALU-DEC-OP-OFF *1*ALU-DEC-OP T)

(PROVE-LEMMA BVP-LENGTH-ALU-DEC-OP
             (REWRITE)
             (AND (EQUAL (LENGTH (ALU-DEC-OP)) 4)
                  (BVP (ALU-DEC-OP)))
             ((ENABLE ALU-DEC-OP)))

(PROVE-LEMMA BV-V-ALU-ALU-INC-ALU-DEC
             (REWRITE)
             (AND (EQUAL (BV (V-ALU C A B (ALU-INC-OP)))
                         (V-INC A))
                  (EQUAL (BV (V-ALU C A B (ALU-DEC-OP)))
                         (V-DEC A)))
             ((ENABLE BV V-ALU V-INC V-DEC ALU-INC-OP ALU-DEC-OP)))

(DEFN DECODE-MODE
      (OP0 OP1 OP2 OP3)
      (B-NOR (B-NOR3 OP0 OP1 OP2) OP3))

(DEFN F$DECODE-MODE
      (OP0 OP1 OP2 OP3)
      (F-NOR (F-NOR3 OP0 OP1 OP2) OP3))

(TOGGLE F$DECODE-MODE-OFF F$DECODE-MODE T)

(DEFN DECODE-MODE* NIL
      '(DECODE-MODE (OP0 OP1 OP2 OP3)
                    (W-1)
                    ((G-0 (W-0) B-NOR3 (OP0 OP1 OP2))
                     (G-1 (W-1) B-NOR (W-0 OP3)))
                    NIL))

(DEFN DECODE-MODE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DECODE-MODE NETLIST)
                  (DECODE-MODE*))
           (B-NOR3& (DELETE-MODULE 'DECODE-MODE NETLIST))
           (B-NOR& (DELETE-MODULE 'DECODE-MODE
                                  NETLIST))))

(TOGGLE DECODE-MODE&-OFF DECODE-MODE& T)

(DEFN DECODE-MODE$NETLIST NIL
      (CONS (DECODE-MODE*)
            (UNION (B-NOR3$NETLIST)
                   (B-NOR$NETLIST))))

(PROVE-LEMMA DECODE-MODE$VALUE
             (REWRITE)
             (IMPLIES (DECODE-MODE& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-MODE
                                        (LIST OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (LIST (F$DECODE-MODE OP0 OP1 OP2 OP3))))
             ((ENABLE DECODE-MODE& F$DECODE-MODE B-NOR3$VALUE B-NOR$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DECODE-MODE$VALUE-OFF DECODE-MODE$VALUE T)

(PROVE-LEMMA F$DECODE-MODE=DECODE-MODE
             (REWRITE)
             (IMPLIES (AND (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$DECODE-MODE OP0 OP1 OP2 OP3)
                             (DECODE-MODE OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$DECODE-MODE DECODE-MODE)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA DECODE-MODE$VALUE-ZERO
             (REWRITE)
             (IMPLIES (DECODE-MODE& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-MODE
                                        (ALU-INC-OP)
                                        STATE NETLIST)
                             (LIST T)))
             ((ENABLE DECODE-MODE& B-NOR$VALUE B-NOR3$VALUE ALU-INC-OP)
              (DISABLE F-AND)))

(TOGGLE DECODE-MODE$VALUE-ZERO-OFF DECODE-MODE$VALUE-ZERO T)

(DEFN DECODE-PROP
      (ZERO SWAP OP0 OP1 OP2 OP3)
      (LIST (B-NAND3 (B-NAND4 (B-NOT OP0)
                              (B-NOT OP1)
                              (B-NOT (B-NOT OP2))
                              (B-NOT (B-NOT OP3)))
                     (B-NAND (B-NOT (B-NOT OP1))
                             (B-NOT OP3))
                     (B-NAND3 (B-NOT OP2)
                              (B-NOT OP3)
                              (B-NOT (B-NOT SWAP))))
            (B-NOR (B-NOT OP2)
                   (B-NOR (B-NOT OP3)
                          (B-NOR (B-NOT (B-NOT OP0))
                                 (B-NOT OP1))))
            (B-AND (B-NAND3 (B-NAND (B-NOT (B-NOT OP3))
                                    (B-EQUV (B-NOT (B-NOT OP0))
                                            (B-NOT (B-NOT OP1))))
                            (B-NAND (B-NOT OP2)
                                    (B-NAND (B-NOT (B-NOT SWAP))
                                            (B-NOT OP3)))
                            (B-NAND4 (B-NOT (B-NOT OP0))
                                     (B-NOT OP1)
                                     (B-NOT (B-NOT OP2))
                                     (B-NOT OP3)))
                   (B-NOT ZERO))))

(DEFN F$DECODE-PROP
      (ZERO SWAP OP0 OP1 OP2 OP3)
      (LIST (F-NAND3 (F-NAND4 (F-NOT OP0)
                              (F-NOT OP1)
                              (F-NOT (F-NOT OP2))
                              (F-NOT (F-NOT OP3)))
                     (F-NAND (F-NOT (F-NOT OP1))
                             (F-NOT OP3))
                     (F-NAND3 (F-NOT OP2)
                              (F-NOT OP3)
                              (F-NOT (F-NOT SWAP))))
            (F-NOR (F-NOT OP2)
                   (F-NOR (F-NOT OP3)
                          (F-NOR (F-NOT (F-NOT OP0))
                                 (F-NOT OP1))))
            (F-AND (F-NAND3 (F-NAND (F-NOT (F-NOT OP3))
                                    (F-EQUV (F-NOT (F-NOT OP0))
                                            (F-NOT (F-NOT OP1))))
                            (F-NAND (F-NOT OP2)
                                    (F-NAND (F-NOT (F-NOT SWAP))
                                            (F-NOT OP3)))
                            (F-NAND4 (F-NOT (F-NOT OP0))
                                     (F-NOT OP1)
                                     (F-NOT (F-NOT OP2))
                                     (F-NOT OP3)))
                   (F-NOT ZERO))))

(TOGGLE F$DECODE-PROP-OFF F$DECODE-PROP T)

(DEFN DECODE-PROP* NIL
      '(DECODE-PROP (ZERO SWAP OP0 OP1 OP2 OP3)
                    (W-16 W-24 W-48)
                    ((G-47 (W-47) B-NOT (ZERO))
                     (G-44 (W-44) B-NOT (OP3))
                     (G-42 (W-42) B-NOT (OP2))
                     (G-43 (W-43) B-NOT (W-42))
                     (G-41 (W-41) B-NOT (OP1))
                     (G-39 (W-39) B-NOT (OP0))
                     (G-40 (W-40) B-NOT (W-39))
                     (G-45 (W-45)
                           B-NAND4
                           (W-40 W-41 W-43 W-44))
                     (G-34 (W-34) B-NOT (SWAP))
                     (G-35 (W-35) B-NOT (W-34))
                     (G-37 (W-37) B-NAND (W-35 W-44))
                     (G-38 (W-38) B-NAND (W-42 W-37))
                     (G-30 (W-30) B-NOT (W-41))
                     (G-31 (W-31) B-EQUV (W-40 W-30))
                     (G-26 (W-26) B-NOT (W-44))
                     (G-32 (W-32) B-NAND (W-26 W-31))
                     (G-46 (W-46) B-NAND3 (W-32 W-38 W-45))
                     (G-48 (W-48) B-AND (W-46 W-47))
                     (G-22 (W-22) B-NOR (W-40 W-41))
                     (G-23 (W-23) B-NOR (W-44 W-22))
                     (G-24 (W-24) B-NOR (W-42 W-23))
                     (G-15 (W-15) B-NAND3 (W-42 W-44 W-35))
                     (G-10 (W-10) B-NAND (W-30 W-44))
                     (G-6 (W-6)
                          B-NAND4
                          (W-39 W-41 W-43 W-26))
                     (G-16 (W-16) B-NAND3 (W-6 W-10 W-15)))
                    NIL))

(DEFN DECODE-PROP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DECODE-PROP NETLIST)
                  (DECODE-PROP*))
           (B-EQUV& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-NOT& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-AND& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-NOR& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-NAND& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-NAND4& (DELETE-MODULE 'DECODE-PROP NETLIST))
           (B-NAND3& (DELETE-MODULE 'DECODE-PROP
                                    NETLIST))))

(TOGGLE DECODE-PROP&-OFF DECODE-PROP& T)

(DEFN DECODE-PROP$NETLIST NIL
      (CONS (DECODE-PROP*)
            (UNION (UNION (UNION (UNION (UNION (UNION (B-EQUV$NETLIST)
                                                      (B-NOT$NETLIST))
                                               (B-AND$NETLIST))
                                        (B-NOR$NETLIST))
                                 (B-NAND$NETLIST))
                          (B-NAND4$NETLIST))
                   (B-NAND3$NETLIST))))

(PROVE-LEMMA DECODE-PROP$VALUE
             (REWRITE)
             (IMPLIES (DECODE-PROP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-PROP
                                        (LIST ZERO SWAP OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (F$DECODE-PROP ZERO SWAP OP0 OP1 OP2 OP3)))
             ((ENABLE DECODE-PROP& F$DECODE-PROP B-EQUV$VALUE B-NOT$VALUE
                      B-AND$VALUE B-NOR$VALUE B-NAND$VALUE B-NAND4$VALUE
                      B-NAND3$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DECODE-PROP$VALUE-OFF DECODE-PROP$VALUE T)

(PROVE-LEMMA F$DECODE-PROP=DECODE-PROP
             (REWRITE)
             (IMPLIES (AND (BOOLP ZERO)
                           (BOOLP SWAP)
                           (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$DECODE-PROP ZERO SWAP OP0 OP1 OP2 OP3)
                             (DECODE-PROP ZERO SWAP OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$DECODE-PROP DECODE-PROP)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA DECODE-PROP$VALUE-ZERO
             (REWRITE)
             (IMPLIES (DECODE-PROP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-PROP
                                        (CONS T (CONS F (ALU-INC-OP)))
                                        STATE NETLIST)
                             (LIST F F F)))
             ((ENABLE DECODE-PROP& B-AND$VALUE B-NOT$VALUE B-NAND$VALUE
                      B-NAND3$VALUE B-NAND4$VALUE B-NOR$VALUE B-EQUV$VALUE
                      ALU-INC-OP F-AND-REWRITE F-NOT-REWRITE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DECODE-PROP$VALUE-ZERO-OFF DECODE-PROP$VALUE-ZERO T)

(DEFN DECODE-GEN
      (ZERO SWAP OP0 OP1 OP2 OP3)
      (LIST (B-NAND3 (B-NAND3 (B-NOT (B-NOT OP0))
                              (B-NOT (B-NOT OP3))
                              (B-XOR (B-NOT (B-NOT OP1))
                                     (B-NOT (B-NOT OP2))))
                     (B-NAND3 (B-NOT (B-NOT OP2))
                              (B-NOT OP3)
                              (B-NAND (B-NOT OP1) (B-NOT SWAP)))
                     (B-NAND3 (B-NOT (B-NOT OP1))
                              (B-NOT OP2)
                              (B-NOT OP3)))
            (B-NOR (B-NAND (B-NAND4 (B-NOT (B-NOT OP0))
                                    (B-NOT (B-NOT OP1))
                                    (B-NOT OP2)
                                    (B-NOT (B-NOT OP3)))
                           (B-NAND3 (B-NOT (B-NOT OP2))
                                    (B-NOT OP3)
                                    (B-NAND (B-NOT OP1) (B-NOT SWAP))))
                   (B-NOT (B-NOT ZERO)))
            (B-NOR (B-NAND3 (B-NAND3 (B-NOT (B-NOT OP0))
                                     (B-NOT (B-NOT OP3))
                                     (B-XOR (B-NOT (B-NOT OP1))
                                            (B-NOT (B-NOT OP2))))
                            (B-NAND3 (B-NOT (B-NOT OP0))
                                     (B-NOT OP1)
                                     (B-NOT (B-NOT OP2)))
                            (B-NAND3 (B-NOT (B-NOT OP1))
                                     (B-NOT OP2)
                                     (B-NOT OP3)))
                   (B-NOT (B-NOT ZERO)))))

(DEFN F$DECODE-GEN
      (ZERO SWAP OP0 OP1 OP2 OP3)
      (LIST (F-NAND3 (F-NAND3 (F-NOT (F-NOT OP0))
                              (F-NOT (F-NOT OP3))
                              (F-XOR (F-NOT (F-NOT OP1))
                                     (F-NOT (F-NOT OP2))))
                     (F-NAND3 (F-NOT (F-NOT OP2))
                              (F-NOT OP3)
                              (F-NAND (F-NOT OP1) (F-NOT SWAP)))
                     (F-NAND3 (F-NOT (F-NOT OP1))
                              (F-NOT OP2)
                              (F-NOT OP3)))
            (F-NOR (F-NAND (F-NAND4 (F-NOT (F-NOT OP0))
                                    (F-NOT (F-NOT OP1))
                                    (F-NOT OP2)
                                    (F-NOT (F-NOT OP3)))
                           (F-NAND3 (F-NOT (F-NOT OP2))
                                    (F-NOT OP3)
                                    (F-NAND (F-NOT OP1) (F-NOT SWAP))))
                   (F-NOT (F-NOT ZERO)))
            (F-NOR (F-NAND3 (F-NAND3 (F-NOT (F-NOT OP0))
                                     (F-NOT (F-NOT OP3))
                                     (F-XOR (F-NOT (F-NOT OP1))
                                            (F-NOT (F-NOT OP2))))
                            (F-NAND3 (F-NOT (F-NOT OP0))
                                     (F-NOT OP1)
                                     (F-NOT (F-NOT OP2)))
                            (F-NAND3 (F-NOT (F-NOT OP1))
                                     (F-NOT OP2)
                                     (F-NOT OP3)))
                   (F-NOT (F-NOT ZERO)))))

(TOGGLE F$DECODE-GEN-OFF F$DECODE-GEN T)

(DEFN DECODE-GEN* NIL
      '(DECODE-GEN (ZERO SWAP OP0 OP1 OP2 OP3)
                   (W-22 W-41 W-66)
                   ((G-64 (W-64) B-NOT (ZERO))
                    (G-65 (W-65) B-NOT (W-64))
                    (G-61 (W-61) B-NOT (OP3))
                    (G-60 (W-60) B-NOT (OP2))
                    (G-58 (W-58) B-NOT (OP1))
                    (G-59 (W-59) B-NOT (W-58))
                    (G-62 (W-62) B-NAND3 (W-59 W-60 W-61))
                    (G-56 (W-56) B-NOT (W-60))
                    (G-52 (W-52) B-NOT (OP0))
                    (G-53 (W-53) B-NOT (W-52))
                    (G-57 (W-57) B-NAND3 (W-53 W-58 W-56))
                    (G-50 (W-50) B-XOR (W-59 W-56))
                    (G-45 (W-45) B-NOT (W-61))
                    (G-51 (W-51) B-NAND3 (W-53 W-45 W-50))
                    (G-63 (W-63) B-NAND3 (W-51 W-57 W-62))
                    (G-66 (W-66) B-NOR (W-63 W-65))
                    (G-35 (W-35) B-NOT (SWAP))
                    (G-36 (W-36) B-NAND (W-58 W-35))
                    (G-37 (W-37) B-NAND3 (W-56 W-61 W-36))
                    (G-30 (W-30)
                          B-NAND4
                          (W-53 W-59 W-60 W-45))
                    (G-38 (W-38) B-NAND (W-30 W-37))
                    (G-41 (W-41) B-NOR (W-38 W-65))
                    (G-22 (W-22)
                          B-NAND3
                          (W-51 W-37 W-62)))
                   NIL))

(DEFN DECODE-GEN&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DECODE-GEN NETLIST)
                  (DECODE-GEN*))
           (B-XOR& (DELETE-MODULE 'DECODE-GEN NETLIST))
           (B-NOT& (DELETE-MODULE 'DECODE-GEN NETLIST))
           (B-NAND4& (DELETE-MODULE 'DECODE-GEN NETLIST))
           (B-NAND& (DELETE-MODULE 'DECODE-GEN NETLIST))
           (B-NOR& (DELETE-MODULE 'DECODE-GEN NETLIST))
           (B-NAND3& (DELETE-MODULE 'DECODE-GEN
                                    NETLIST))))

(TOGGLE DECODE-GEN&-OFF DECODE-GEN& T)

(DEFN DECODE-GEN$NETLIST NIL
      (CONS (DECODE-GEN*)
            (UNION (UNION (UNION (UNION (UNION (B-XOR$NETLIST)
                                               (B-NOT$NETLIST))
                                        (B-NAND4$NETLIST))
                                 (B-NAND$NETLIST))
                          (B-NOR$NETLIST))
                   (B-NAND3$NETLIST))))

(PROVE-LEMMA DECODE-GEN$VALUE
             (REWRITE)
             (IMPLIES (DECODE-GEN& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-GEN
                                        (LIST ZERO SWAP OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (F$DECODE-GEN ZERO SWAP OP0 OP1 OP2 OP3)))
             ((ENABLE DECODE-GEN& F$DECODE-GEN B-XOR$VALUE B-NOT$VALUE
                      B-NAND4$VALUE B-NAND$VALUE B-NOR$VALUE B-NAND3$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DECODE-GEN$VALUE-OFF DECODE-GEN$VALUE T)

(PROVE-LEMMA F$DECODE-GEN=DECODE-GEN
             (REWRITE)
             (IMPLIES (AND (BOOLP ZERO)
                           (BOOLP SWAP)
                           (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$DECODE-GEN ZERO SWAP OP0 OP1 OP2 OP3)
                             (DECODE-GEN ZERO SWAP OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$DECODE-GEN DECODE-GEN)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA DECODE-GEN$VALUE-ZERO
             (REWRITE)
             (IMPLIES (DECODE-GEN& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-GEN
                                        (CONS T (CONS F (ALU-INC-OP)))
                                        STATE NETLIST)
                             (LIST F F F)))
             ((ENABLE DECODE-GEN& B-AND$VALUE B-NOT$VALUE B-NOR$VALUE
                      B-NAND3$VALUE B-NAND$VALUE B-XOR$VALUE F-AND-REWRITE
                      F-NOT-REWRITE F-NOR F-OR ALU-INC-OP)
              (DISABLE-THEORY F-GATES)))

(TOGGLE DECODE-GEN$VALUE-ZERO-OFF DECODE-GEN$VALUE-ZERO T)

(DEFN F$MPG
      (ZSOP)
      (APPEND (F$DECODE-GEN (CAR ZSOP)
                            (CADR ZSOP)
                            (CADDR ZSOP)
                            (CADDDR ZSOP)
                            (CADDDDR ZSOP)
                            (CADDDDDR ZSOP))
              (APPEND (F$DECODE-PROP (CAR ZSOP)
                                     (CADR ZSOP)
                                     (CADDR ZSOP)
                                     (CADDDR ZSOP)
                                     (CADDDDR ZSOP)
                                     (CADDDDDR ZSOP))
                      (LIST (F$DECODE-MODE (CADDR ZSOP)
                                           (CADDDR ZSOP)
                                           (CADDDDR ZSOP)
                                           (CADDDDDR ZSOP))))))

(TOGGLE F$MPG-OFF F$MPG T)

(DEFN MPG
      (ZSOP)
      (APPEND (DECODE-GEN (CAR ZSOP)
                          (CADR ZSOP)
                          (CADDR ZSOP)
                          (CADDDR ZSOP)
                          (CADDDDR ZSOP)
                          (CADDDDDR ZSOP))
              (APPEND (DECODE-PROP (CAR ZSOP)
                                   (CADR ZSOP)
                                   (CADDR ZSOP)
                                   (CADDDR ZSOP)
                                   (CADDDDR ZSOP)
                                   (CADDDDDR ZSOP))
                      (LIST (DECODE-MODE (CADDR ZSOP)
                                         (CADDDR ZSOP)
                                         (CADDDDR ZSOP)
                                         (CADDDDDR ZSOP))))))

(TOGGLE MPG-OFF MPG T)

(PROVE-LEMMA F$MPG=MPG
             (REWRITE)
             (IMPLIES (AND (BVP ZSOP)
                           (EQUAL (LENGTH ZSOP) 6))
                      (EQUAL (F$MPG ZSOP) (MPG ZSOP)))
             ((ENABLE F$MPG MPG BVP-LENGTH)))

(PROVE-LEMMA PROPERP-LENGTH-F$MPG
             (REWRITE)
             (AND (PROPERP (F$MPG ZSOP))
                  (EQUAL (LENGTH (F$MPG ZSOP)) 7))
             ((ENABLE F$MPG F$DECODE-GEN F$DECODE-PROP F$DECODE-MODE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA LENGTH-MPG
             (REWRITE)
             (EQUAL (LENGTH (MPG ZSOP)) 7)
             ((ENABLE MPG)))

(PROVE-LEMMA BVP-MPG
             (REWRITE)
             (BVP (MPG ZSOP))
             ((ENABLE MPG)))

(PROVE-LEMMA PROPERP-MPG
             (REWRITE)
             (PROPERP (MPG ZSOP))
             ((ENABLE MPG)))

(PROVE-LEMMA MPG-IF-OP-CODE
             (REWRITE)
             (EQUAL (MPG (CONS A (CONS B (IF C D E))))
                    (IF C
                        (MPG (CONS A (CONS B D)))
                        (MPG (CONS A (CONS B E))))))

(PROVE-LEMMA MPG-ZERO
             (REWRITE)
             (EQUAL (MPG (CONS T (CONS F (ALU-INC-OP))))
                    (LIST F F F F F F T))
             ((ENABLE MPG ALU-INC-OP)))

(TOGGLE MPG-ZERO-OFF MPG-ZERO T)

(DEFN MPG* NIL
      '(MPG (ZERO SWAP OP0 OP1 OP2 OP3)
            (GBN GAN GA PB PAN PA MODE)
            ((M (MODE)
                DECODE-MODE
                (OP0 OP1 OP2 OP3))
             (P (PB PAN PA)
                DECODE-PROP
                (ZERO SWAP OP0 OP1 OP2 OP3))
             (G (GBN GAN GA)
                DECODE-GEN
                (ZERO SWAP OP0 OP1 OP2 OP3)))
            NIL))

(DEFN MPG&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'MPG NETLIST)
                  (MPG*))
           (DECODE-MODE& (DELETE-MODULE 'MPG NETLIST))
           (DECODE-PROP& (DELETE-MODULE 'MPG NETLIST))
           (DECODE-GEN& (DELETE-MODULE 'MPG NETLIST))))

(TOGGLE MPG&-OFF MPG& T)

(DEFN MPG$NETLIST NIL
      (CONS (MPG*)
            (UNION (UNION (DECODE-MODE$NETLIST)
                          (DECODE-PROP$NETLIST))
                   (DECODE-GEN$NETLIST))))

(PROVE-LEMMA MPG$VALUE
             (REWRITE)
             (IMPLIES (AND (MPG& NETLIST)
                           (PROPERP ZSOP)
                           (EQUAL (LENGTH ZSOP) 6))
                      (EQUAL (DUAL-EVAL 0 'MPG ZSOP STATE NETLIST)
                             (F$MPG ZSOP)))
             ((ENABLE F$MPG MPG& DECODE-MODE$VALUE DECODE-PROP$VALUE
                      DECODE-GEN$VALUE F$DECODE-MODE F$DECODE-GEN
                      F$DECODE-PROP)
              (DISABLE-THEORY F-GATES)))

(TOGGLE MPG$VALUE-OFF MPG$VALUE T)

(PROVE-LEMMA MPG$VALUE-ZERO
             (REWRITE)
             (IMPLIES (AND (MPG& NETLIST)
                           (EQUAL ZSOP
                                  (CONS T (CONS F (ALU-INC-OP)))))
                      (EQUAL (DUAL-EVAL 0 'MPG ZSOP STATE NETLIST)
                             (LIST F F F F F F T)))
             ((ENABLE MPG MPG& DECODE-MODE$VALUE DECODE-PROP$VALUE
                      DECODE-GEN$VALUE ALU-INC-OP)))

(TOGGLE MPG$VALUE-ZERO-OFF MPG$VALUE-ZERO T)

(DEFN CARRY-IN-HELP
      (CZOP)
      (B-OR (B-NAND3 (B-NAND3 (B-NOT (CADDDR CZOP))
                              (B-NOT (CADDDDR CZOP))
                              (B-NOT (CADDDDDR CZOP)))
                     (B-NAND3 (B-NOT (CADDR CZOP))
                              (B-NOT (CADDDR CZOP))
                              (B-NOT (B-NOT (CADDDDR CZOP))))
                     (B-NAND3 (B-NOT (B-NOT (CADDR CZOP)))
                              (B-NOT (B-NOT (CADDDR CZOP)))
                              (B-NOT (B-NOT (CADDDDR CZOP)))))
            (B-NAND3 (B-NAND (B-NOT (B-NOT (CADDDDDR CZOP)))
                             (B-NOT (B-NOT (CAR CZOP))))
                     (B-NAND3 (B-NOT (CADDR CZOP))
                              (B-NOT (CADDDDR CZOP))
                              (B-NOT (B-NOT (CAR CZOP))))
                     (B-NAND3 (B-NOT (CADDR CZOP))
                              (B-NOT (B-NOT (CADDDDR CZOP)))
                              (B-NOT (CAR CZOP))))))

(TOGGLE CARRY-IN-HELP-OFF CARRY-IN-HELP T)

(DEFN F$CARRY-IN-HELP
      (CZOP)
      (F-OR (F-NAND3 (F-NAND3 (F-NOT (CADDDR CZOP))
                              (F-NOT (CADDDDR CZOP))
                              (F-NOT (CADDDDDR CZOP)))
                     (F-NAND3 (F-NOT (CADDR CZOP))
                              (F-NOT (CADDDR CZOP))
                              (F-NOT (F-NOT (CADDDDR CZOP))))
                     (F-NAND3 (F-NOT (F-NOT (CADDR CZOP)))
                              (F-NOT (F-NOT (CADDDR CZOP)))
                              (F-NOT (F-NOT (CADDDDR CZOP)))))
            (F-NAND3 (F-NAND (F-NOT (F-NOT (CADDDDDR CZOP)))
                             (F-NOT (F-NOT (CAR CZOP))))
                     (F-NAND3 (F-NOT (CADDR CZOP))
                              (F-NOT (CADDDDR CZOP))
                              (F-NOT (F-NOT (CAR CZOP))))
                     (F-NAND3 (F-NOT (CADDR CZOP))
                              (F-NOT (F-NOT (CADDDDR CZOP)))
                              (F-NOT (CAR CZOP))))))

(TOGGLE F$CARRY-IN-HELP-OFF F$CARRY-IN-HELP T)

(PROVE-LEMMA F$CARRY-IN-HELP=CARRY-IN-HELP
             (REWRITE)
             (IMPLIES (AND (BVP CZOP)
                           (EQUAL (LENGTH CZOP) 6))
                      (EQUAL (F$CARRY-IN-HELP CZOP)
                             (CARRY-IN-HELP CZOP)))
             ((ENABLE CARRY-IN-HELP F$CARRY-IN-HELP BOOLP-B-GATES
                      EQUAL-LENGTH-ADD1)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN CARRY-IN-HELP* NIL
      '(CARRY-IN-HELP (CIN Z OP0IN OP1IN OP2IN OP3IN)
                      (COUT)
                      ((G0 (C- C) B-NBUF (CIN))
                       (G1 (OP0- OP0) B-NBUF (OP0IN))
                       (G2 (OP1- OP1) B-NBUF (OP1IN))
                       (G3 (OP2- OP2) B-NBUF (OP2IN))
                       (G4 (OP3- OP3) B-NBUF (OP3IN))
                       (G5 (S5) B-NAND3 (OP1- OP2- OP3-))
                       (G6 (S6) B-NAND3 (OP0- OP1- OP2))
                       (G7 (S7) B-NAND3 (OP0 OP1 OP2))
                       (G8 (S8) B-NAND3 (S5 S6 S7))
                       (G9 (S9) B-NAND (OP3 C))
                       (G10 (S10) B-NAND3 (OP0- OP2- C))
                       (G11 (S11) B-NAND3 (OP0- OP2 C-))
                       (G12 (S12) B-NAND3 (S9 S10 S11))
                       (G13 (COUT) B-OR (S8 S12)))
                      NIL))

(DEFN CARRY-IN-HELP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CARRY-IN-HELP
                                 NETLIST)
                  (CARRY-IN-HELP*))
           (B-NBUF& (DELETE-MODULE 'CARRY-IN-HELP
                                   NETLIST))
           (B-NAND& (DELETE-MODULE 'CARRY-IN-HELP
                                   NETLIST))
           (B-NAND3& (DELETE-MODULE 'CARRY-IN-HELP
                                    NETLIST))
           (B-OR& (DELETE-MODULE 'CARRY-IN-HELP
                                 NETLIST))))

(TOGGLE CARRY-IN-HELP&-OFF CARRY-IN-HELP& T)

(DEFN CARRY-IN-HELP$NETLIST NIL
      (CONS (CARRY-IN-HELP*)
            (UNION (UNION (UNION (B-NBUF$NETLIST)
                                 (B-NAND$NETLIST))
                          (B-NAND3$NETLIST))
                   (B-OR$NETLIST))))

(PROVE-LEMMA CARRY-IN-HELP-ZERO
             (REWRITE)
             (EQUAL (CARRY-IN-HELP (CONS C (CONS T (ALU-INC-OP))))
                    T)
             ((ENABLE CARRY-IN-HELP ALU-INC-OP)))

(TOGGLE CARRY-IN-HELP-ZERO-OFF CARRY-IN-HELP-ZERO T)

(PROVE-LEMMA CARRY-IN-HELP-IF-OP-CODE
             (REWRITE)
             (EQUAL (CARRY-IN-HELP (CONS A (CONS B (IF C D E))))
                    (IF C
                        (CARRY-IN-HELP (CONS A (CONS B D)))
                        (CARRY-IN-HELP (CONS A (CONS B E))))))

(PROVE-LEMMA CARRY-IN-HELP$VALUE
             (REWRITE)
             (IMPLIES (CARRY-IN-HELP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'CARRY-IN-HELP
                                        CZOP STATE NETLIST)
                             (LIST (F$CARRY-IN-HELP CZOP))))
             ((ENABLE F$CARRY-IN-HELP CARRY-IN-HELP& B-NBUF$VALUE B-NAND$VALUE
                      B-NAND3$VALUE B-NAND4$VALUE B-OR$VALUE EQUAL-LENGTH-ADD1
                      F-NOT-F-NOT=F-BUF)
              (DISABLE-THEORY F-GATES)))

(TOGGLE CARRY-IN-HELP$VALUE-OFF CARRY-IN-HELP$VALUE T)

(PROVE-LEMMA CARRY-IN-HELP$VALUE-ZERO
             (REWRITE)
             (IMPLIES (AND (CARRY-IN-HELP& NETLIST)
                           (EQUAL CZOP
                                  (CONS C (CONS T (ALU-INC-OP)))))
                      (EQUAL (DUAL-EVAL 0 'CARRY-IN-HELP
                                        CZOP STATE NETLIST)
                             (LIST T)))
             ((ENABLE F$CARRY-IN-HELP CARRY-IN-HELP& B-NBUF$VALUE B-NAND$VALUE
                      B-NAND3$VALUE B-NAND4$VALUE B-OR$VALUE EQUAL-LENGTH-ADD1
                      F-NOT-F-NOT=F-BUF ALU-INC-OP BOOLP-B-GATES)
              (DISABLE-THEORY F-GATES)))

(TOGGLE CARRY-IN-HELP$VALUE-ZERO-OFF CARRY-IN-HELP$VALUE-ZERO T)

(DEFN P-CELL
      (A AN B PA PAN PB)
      (B-NAND3 (B-NAND A PA)
               (B-NAND AN PAN)
               (B-NAND B PB)))

(DEFN F$P-CELL
      (A AN B PA PAN PB)
      (F-NAND3 (F-NAND A PA)
               (F-NAND AN PAN)
               (F-NAND B PB)))

(TOGGLE F$P-CELL-OFF F$P-CELL T)

(DEFN P-CELL* NIL
      '(P-CELL (A AN B PA PAN PB)
               (W-3)
               ((G-2 (W-2) B-NAND (B PB))
                (G-1 (W-1) B-NAND (AN PAN))
                (G-0 (W-0) B-NAND (A PA))
                (G-3 (W-3) B-NAND3 (W-0 W-1 W-2)))
               NIL))

(DEFN P-CELL&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'P-CELL NETLIST)
                  (P-CELL*))
           (B-NAND& (DELETE-MODULE 'P-CELL NETLIST))
           (B-NAND3& (DELETE-MODULE 'P-CELL NETLIST))))

(TOGGLE P-CELL&-OFF P-CELL& T)

(DEFN P-CELL$NETLIST NIL
      (CONS (P-CELL*)
            (UNION (B-NAND$NETLIST)
                   (B-NAND3$NETLIST))))

(PROVE-LEMMA P-CELL$VALUE
             (REWRITE)
             (IMPLIES (P-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'P-CELL
                                        (LIST A AN B PA PAN PB)
                                        STATE NETLIST)
                             (LIST (F$P-CELL A AN B PA PAN PB))))
             ((ENABLE P-CELL& F$P-CELL B-NAND$VALUE B-NAND3$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE P-CELL$VALUE-OFF P-CELL$VALUE T)

(PROVE-LEMMA F$P-CELL=P-CELL
             (REWRITE)
             (IMPLIES (AND (BOOLP A)
                           (BOOLP AN)
                           (BOOLP B)
                           (BOOLP PA)
                           (BOOLP PAN)
                           (BOOLP PB))
                      (EQUAL (F$P-CELL A AN B PA PAN PB)
                             (P-CELL A AN B PA PAN PB)))
             ((ENABLE BOOLP-B-GATES F$P-CELL P-CELL)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA P-CELL$VALUE-ZERO
             (REWRITE)
             (IMPLIES (P-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'P-CELL
                                        (LIST A AN B F F F)
                                        STATE NETLIST)
                             (LIST F)))
             ((ENABLE P-CELL& B-NAND3$VALUE B-NAND$VALUE)))

(DEFN G-CELL
      (A AN BN GA GAN GBN)
      (B-AND3 (B-NAND A GA)
              (B-NAND AN GAN)
              (B-NAND BN GBN)))

(DEFN F$G-CELL
      (A AN BN GA GAN GBN)
      (F-AND3 (F-NAND A GA)
              (F-NAND AN GAN)
              (F-NAND BN GBN)))

(TOGGLE F$G-CELL-OFF F$G-CELL T)

(DEFN G-CELL* NIL
      '(G-CELL (A AN BN GA GAN GBN)
               (W-3)
               ((G-2 (W-2) B-NAND (BN GBN))
                (G-1 (W-1) B-NAND (AN GAN))
                (G-0 (W-0) B-NAND (A GA))
                (G-3 (W-3) B-AND3 (W-0 W-1 W-2)))
               NIL))

(DEFN G-CELL&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'G-CELL NETLIST)
                  (G-CELL*))
           (B-NAND& (DELETE-MODULE 'G-CELL NETLIST))
           (B-AND3& (DELETE-MODULE 'G-CELL NETLIST))))

(TOGGLE G-CELL&-OFF G-CELL& T)

(DEFN G-CELL$NETLIST NIL
      (CONS (G-CELL*)
            (UNION (B-NAND$NETLIST)
                   (B-AND3$NETLIST))))

(PROVE-LEMMA G-CELL$VALUE
             (REWRITE)
             (IMPLIES (G-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'G-CELL
                                        (LIST A AN BN GA GAN GBN)
                                        STATE NETLIST)
                             (LIST (F$G-CELL A AN BN GA GAN GBN))))
             ((ENABLE G-CELL& F$G-CELL B-NAND$VALUE B-AND3$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE G-CELL$VALUE-OFF G-CELL$VALUE T)

(PROVE-LEMMA F$G-CELL=G-CELL
             (REWRITE)
             (IMPLIES (AND (BOOLP A)
                           (BOOLP AN)
                           (BOOLP BN)
                           (BOOLP GA)
                           (BOOLP GAN)
                           (BOOLP GBN))
                      (EQUAL (F$G-CELL A AN BN GA GAN GBN)
                             (G-CELL A AN BN GA GAN GBN)))
             ((ENABLE BOOLP-B-GATES F$G-CELL G-CELL)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA G-CELL$VALUE-ZERO
             (REWRITE)
             (IMPLIES (G-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'G-CELL
                                        (LIST A AN BN F F F)
                                        STATE NETLIST)
                             (LIST T)))
             ((ENABLE G-CELL& B-AND3$VALUE B-NAND$VALUE)))

(DEFN ALU-CELL
      (C A B MPG)
      (LIST (P-CELL A
                    (B-NOT A)
                    B
                    (CADDDDDR MPG)
                    (CADDDDR MPG)
                    (CADDDR MPG))
            (G-CELL A
                    (B-NOT A)
                    (B-NOT B)
                    (CADDR MPG)
                    (CADR MPG)
                    (CAR MPG))
            (B-EQUV3 (B-NAND C (CADDDDDDR MPG))
                     (P-CELL A
                             (B-NOT A)
                             B
                             (CADDDDDR MPG)
                             (CADDDDR MPG)
                             (CADDDR MPG))
                     (G-CELL A
                             (B-NOT A)
                             (B-NOT B)
                             (CADDR MPG)
                             (CADR MPG)
                             (CAR MPG)))))

(DEFN F$ALU-CELL
      (C A B MPG)
      (LIST (F$P-CELL A
                      (F-NOT A)
                      B
                      (CADDDDDR MPG)
                      (CADDDDR MPG)
                      (CADDDR MPG))
            (F$G-CELL A
                      (F-NOT A)
                      (F-NOT B)
                      (CADDR MPG)
                      (CADR MPG)
                      (CAR MPG))
            (F-EQUV3 (F-NAND C (CADDDDDDR MPG))
                     (F$P-CELL A
                               (F-NOT A)
                               B
                               (CADDDDDR MPG)
                               (CADDDDR MPG)
                               (CADDDR MPG))
                     (F$G-CELL A
                               (F-NOT A)
                               (F-NOT B)
                               (CADDR MPG)
                               (CADR MPG)
                               (CAR MPG)))))

(TOGGLE F$ALU-CELL-OFF F$ALU-CELL T)

(PROVE-LEMMA F$ALU-CELL=ALU-CELL
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BOOLP A)
                           (BOOLP B)
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (EQUAL (F$ALU-CELL C A B MPG)
                             (ALU-CELL C A B MPG)))
             ((ENABLE F$ALU-CELL BVP-LENGTH BOOLP-B-GATES)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN ALU-CELL* NIL
      '(ALU-CELL (C A B GBN GAN GA PB PAN PA M)
                 (P G Z)
                 ((N0 (AN) B-NOT (A))
                  (N1 (BN) B-NOT (B))
                  (P0 (P) P-CELL (A AN B PA PAN PB))
                  (G0 (G) G-CELL (A AN BN GA GAN GBN))
                  (M0 (MC) B-NAND (C M))
                  (Z0 (Z) B-EQUV3 (MC P G)))
                 NIL))

(DEFN ALU-CELL&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'ALU-CELL NETLIST)
                  (ALU-CELL*))
           (B-NOT& (DELETE-MODULE 'ALU-CELL NETLIST))
           (P-CELL& (DELETE-MODULE 'ALU-CELL NETLIST))
           (G-CELL& (DELETE-MODULE 'ALU-CELL NETLIST))
           (B-NAND& (DELETE-MODULE 'ALU-CELL NETLIST))
           (B-EQUV3& (DELETE-MODULE 'ALU-CELL NETLIST))))

(TOGGLE ALU-CELL&-OFF ALU-CELL& T)

(DEFN ALU-CELL$NETLIST NIL
      (CONS (ALU-CELL*)
            (UNION (UNION (UNION (UNION (B-NOT$NETLIST)
                                        (P-CELL$NETLIST))
                                 (G-CELL$NETLIST))
                          (B-NAND$NETLIST))
                   (B-EQUV3$NETLIST))))

(PROVE-LEMMA ALU-CELL$VALUE
             (REWRITE)
             (IMPLIES (ALU-CELL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'ALU-CELL
                                        (CONS C (CONS A (CONS B MPG)))
                                        STATE NETLIST)
                             (F$ALU-CELL C A B MPG)))
             ((ENABLE F$ALU-CELL ALU-CELL& B-NOT$VALUE P-CELL$VALUE
                      G-CELL$VALUE B-NAND$VALUE B-EQUV3$VALUE BVP-LENGTH)
              (DISABLE-THEORY F-GATES)))

(TOGGLE ALU-CELL$VALUE-OFF ALU-CELL$VALUE T)

(PROVE-LEMMA ALU-CELL$VALUE-ZERO
             (REWRITE)
             (IMPLIES (AND (ALU-CELL& NETLIST)
                           (EQUAL MPG (LIST F F F F F F T)))
                      (EQUAL (DUAL-EVAL 0 'ALU-CELL
                                        (CONS T (CONS A (CONS B MPG)))
                                        STATE NETLIST)
                             (LIST F T F)))
             ((ENABLE ALU-CELL& BVP-LENGTH P-CELL$VALUE-ZERO
                      G-CELL$VALUE-ZERO B-NAND$VALUE B-EQUV3$VALUE)))

(TOGGLE ALU-CELL$VALUE-ZERO-OFF ALU-CELL$VALUE-ZERO T)

(PROVE-LEMMA F$ALU-CELL-V-THREEFIX-MPG
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH MPG) 7)
                      (EQUAL (F$ALU-CELL C A B (V-THREEFIX MPG))
                             (F$ALU-CELL C A B MPG)))
             ((ENABLE F$ALU-CELL F$P-CELL F$G-CELL V-THREEFIX
                      EQUAL-LENGTH-ADD1 F-GATE-THREEFIX-CONGRUENCE-LEMMAS)
              (DISABLE THREEFIX)
              (DISABLE-THEORY F-GATES)))

(DEFN TV-ALU-HELP
 (C A B MPG TREE)
 (IF
  (NLISTP TREE)
  (ALU-CELL C (CAR A) (CAR B) MPG)
  (CONS
   (B-AND (CAR (TV-ALU-HELP C
                            (TFIRSTN A TREE)
                            (TFIRSTN B TREE)
                            MPG
                            (CAR TREE)))
          (CAR (TV-ALU-HELP (T-CARRY C
                                     (CAR (TV-ALU-HELP C
                                                       (TFIRSTN A TREE)
                                                       (TFIRSTN B TREE)
                                                       MPG
                                                       (CAR TREE)))
                                     (CADR (TV-ALU-HELP C
                                                        (TFIRSTN A TREE)
                                                        (TFIRSTN B TREE)
                                                        MPG
                                                        (CAR TREE))))
                            (TRESTN A TREE)
                            (TRESTN B TREE)
                            MPG
                            (CDR TREE))))
   (CONS
       (T-CARRY (CADR (TV-ALU-HELP C
                                   (TFIRSTN A TREE)
                                   (TFIRSTN B TREE)
                                   MPG
                                   (CAR TREE)))
                (CAR (TV-ALU-HELP (T-CARRY C
                                           (CAR (TV-ALU-HELP C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             MPG
                                                             (CAR TREE)))
                                           (CADR (TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE))))
                                  (TRESTN A TREE)
                                  (TRESTN B TREE)
                                  MPG
                                  (CDR TREE)))
                (CADR (TV-ALU-HELP (T-CARRY C
                                            (CAR (TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE)))
                                            (CADR (TV-ALU-HELP C
                                                               (TFIRSTN A TREE)
                                                               (TFIRSTN B TREE)
                                                               MPG
                                                               (CAR TREE))))
                                   (TRESTN A TREE)
                                   (TRESTN B TREE)
                                   MPG
                                   (CDR TREE))))
       (APPEND (CDDR (TV-ALU-HELP C
                                  (TFIRSTN A TREE)
                                  (TFIRSTN B TREE)
                                  MPG
                                  (CAR TREE)))
               (CDDR (TV-ALU-HELP (T-CARRY C
                                           (CAR (TV-ALU-HELP C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             MPG
                                                             (CAR TREE)))
                                           (CADR (TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE))))
                                  (TRESTN A TREE)
                                  (TRESTN B TREE)
                                  MPG
                                  (CDR TREE))))))))

(TOGGLE TV-ALU-HELP-OFF TV-ALU-HELP T)

(PROVE-LEMMA CDDR-TV-ALU-HELP-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (CDDR (TV-ALU-HELP C A B MPG TREE)))
                    (TREE-SIZE TREE))
             ((ENABLE TV-ALU-HELP LENGTH TREE-SIZE)))

(PROVE-LEMMA TV-ALU-HELP-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (TV-ALU-HELP C A B MPG TREE))
                    (ADD1 (ADD1 (TREE-SIZE TREE))))
             ((ENABLE LENGTH TV-ALU-HELP TREE-SIZE)))

(PROVE-LEMMA BVP-CDDR-TV-ALU-HELP
             (REWRITE)
             (BVP (CDDR (TV-ALU-HELP C A B MPG TREE)))
             ((ENABLE BVP TV-ALU-HELP)))

(PROVE-LEMMA BVP-TV-ALU-HELP
             (REWRITE)
             (BVP (TV-ALU-HELP C A B MPG TREE))
             ((ENABLE BVP TV-ALU-HELP)))

(PROVE-LEMMA BVP-LENGTH-TV-ALU-HELP
             (REWRITE)
             (EQUAL (BVP-LENGTH (TV-ALU-HELP C A B MPG TREE)
                                N)
                    (IF (LESSP (ADD1 (ADD1 (TREE-SIZE TREE)))
                               N)
                        F T))
             ((ENABLE BVP-LENGTH)))

(PROVE-LEMMA TV-ALU-HELP-ZERO
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F F F F F F T))
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL C T))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (CONS F
                                   (CONS T (MAKE-LIST (LENGTH A) F)))))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (ENABLE TV-ALU-HELP MAKE-LIST MAKE-LIST-APPEND-TREE-CROCK)
              (EXPAND (TV-ALU-HELP T A B
                                   (LIST F F F F F F T)
                                   TREE))))

(TOGGLE TV-ALU-HELP-ZERO-OFF TV-ALU-HELP-ZERO T)

(PROVE-LEMMA TV-ALU-HELP-V-AND-WORKS
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (EQUAL MPG (LIST T T F F F F F)))
                      (EQUAL (CDDR (TV-ALU-HELP C A B MPG TREE))
                             (V-AND A B)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST T T F F F F F)
                                   TREE))
              (ENABLE V-AND)))

(TOGGLE TV-ALU-HELP-V-AND-WORKS-OFF TV-ALU-HELP-V-AND-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-V-OR-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T T F T F))
                           (BV2P A B)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (CDDR (TV-ALU-HELP C A B MPG TREE))
                             (V-OR A B)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T T F T F)
                                   TREE))
              (ENABLE V-OR)))

(TOGGLE TV-ALU-HELP-V-OR-WORKS-OFF TV-ALU-HELP-V-OR-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-V-XOR-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST T F F F F T F))
                           (BV2P A B)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (CDDR (TV-ALU-HELP C A B MPG TREE))
                             (V-XOR A B)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST T F F F F T F)
                                   TREE))
              (ENABLE V-XOR)))

(TOGGLE TV-ALU-HELP-V-XOR-WORKS-OFF TV-ALU-HELP-V-XOR-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-V-NOT-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T F T F F))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (CDDR (TV-ALU-HELP C A B MPG TREE))
                             (V-NOT A)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T F T F F)
                                   TREE))
              (ENABLE V-NOT)))

(TOGGLE TV-ALU-HELP-V-NOT-WORKS-OFF TV-ALU-HELP-V-NOT-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-V-BUF-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T F F T F))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (CDDR (TV-ALU-HELP C A B MPG TREE))
                             (V-BUF A)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T F F T F)
                                   TREE))
              (ENABLE V-BUF)))

(TOGGLE TV-ALU-HELP-V-BUF-WORKS-OFF TV-ALU-HELP-V-BUF-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-ADDER-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST T T F T F T T))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C A B TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST T T F T F T T)
                                   TREE)
                      (TV-ADDER C A B TREE))))

(TOGGLE TV-ALU-HELP-TV-ADDER-WORKS-OFF TV-ALU-HELP-TV-ADDER-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-SUBTRACTER-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST T F T T T F T))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C (V-NOT A) B TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST T F T T T F T)
                                   TREE)
                      (TV-ADDER C (V-NOT A) B TREE))
              (ENABLE V-NOT)))

(TOGGLE TV-ALU-HELP-TV-SUBTRACTER-WORKS-OFF TV-ALU-HELP-TV-SUBTRACTER-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-INC-A-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T F F T T))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C A
                                       (NAT-TO-V 0 (LENGTH A))
                                       TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T F F T T)
                                   TREE)
                      (TV-ADDER C A
                                (NAT-TO-V 0 (LENGTH A))
                                TREE))))

(TOGGLE TV-ALU-HELP-TV-INC-A-WORKS-OFF TV-ALU-HELP-TV-INC-A-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-INC-B-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T T F F T))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C B
                                       (NAT-TO-V 0 (LENGTH B))
                                       TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T T F F T)
                                   TREE)
                      (TV-ADDER C B
                                (NAT-TO-V 0 (LENGTH B))
                                TREE))))

(TOGGLE TV-ALU-HELP-TV-INC-B-WORKS-OFF TV-ALU-HELP-TV-INC-B-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-DEC-A-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T F F T T T))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C
                                       (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                       A TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (DISABLE V-NOT-FIRSTN V-NOT-RESTN)
              (ENABLE FIRSTN-V-NOT RESTN-V-NOT)
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T F F T T T)
                                   TREE)
                      (TV-ADDER C
                                (V-NOT (NAT-TO-V 0 (LENGTH A)))
                                A TREE))))

(TOGGLE TV-ALU-HELP-TV-DEC-A-WORKS-OFF TV-ALU-HELP-TV-DEC-A-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-DEC-B-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST T F F F T T T))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C
                                       (V-NOT (NAT-TO-V 0 (LENGTH B)))
                                       B TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (DISABLE V-NOT-FIRSTN V-NOT-RESTN)
              (ENABLE FIRSTN-V-NOT RESTN-V-NOT)
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST T F F F T T T)
                                   TREE)
                      (TV-ADDER C
                                (V-NOT (NAT-TO-V 0 (LENGTH B)))
                                B TREE))))

(TOGGLE TV-ALU-HELP-TV-DEC-B-WORKS-OFF TV-ALU-HELP-TV-DEC-B-WORKS T)

(PROVE-LEMMA TV-ALU-HELP-TV-NEG-WORKS
             (REWRITE)
             (IMPLIES (AND (EQUAL MPG (LIST F T T F T F T))
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE)))
                      (EQUAL (TV-ALU-HELP C A B MPG TREE)
                             (TV-ADDER C
                                       (V-NOT A)
                                       (NAT-TO-V 0 (LENGTH A))
                                       TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (EXPAND (TV-ALU-HELP C A B
                                   (LIST F T T F T F T)
                                   TREE)
                      (TV-ADDER C
                                (V-NOT A)
                                (NAT-TO-V 0 (LENGTH A))
                                TREE))
              (ENABLE V-NOT)))

(TOGGLE TV-ALU-HELP-TV-NEG-WORKS-OFF TV-ALU-HELP-TV-NEG-WORKS T)

(DEFN F$TV-ALU-HELP
 (C A B MPG TREE)
 (IF
  (NLISTP TREE)
  (F$ALU-CELL C (CAR A) (CAR B) MPG)
  (CONS
   (F-AND (CAR (F$TV-ALU-HELP C
                              (TFIRSTN A TREE)
                              (TFIRSTN B TREE)
                              MPG
                              (CAR TREE)))
          (CAR (F$TV-ALU-HELP (F$T-CARRY C
                                         (CAR (F$TV-ALU-HELP C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             MPG
                                                             (CAR TREE)))
                                         (CADR (F$TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE))))
                              (TRESTN A TREE)
                              (TRESTN B TREE)
                              MPG
                              (CDR TREE))))
   (CONS
    (F$T-CARRY
          (CADR (F$TV-ALU-HELP C
                               (TFIRSTN A TREE)
                               (TFIRSTN B TREE)
                               MPG
                               (CAR TREE)))
          (CAR (F$TV-ALU-HELP (F$T-CARRY C
                                         (CAR (F$TV-ALU-HELP C
                                                             (TFIRSTN A TREE)
                                                             (TFIRSTN B TREE)
                                                             MPG
                                                             (CAR TREE)))
                                         (CADR (F$TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE))))
                              (TRESTN A TREE)
                              (TRESTN B TREE)
                              MPG
                              (CDR TREE)))
          (CADR (F$TV-ALU-HELP (F$T-CARRY C
                                          (CAR (F$TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE)))
                                          (CADR (F$TV-ALU-HELP C
                                                               (TFIRSTN A TREE)
                                                               (TFIRSTN B TREE)
                                                               MPG
                                                               (CAR TREE))))
                               (TRESTN A TREE)
                               (TRESTN B TREE)
                               MPG
                               (CDR TREE))))
    (APPEND
          (CDDR (F$TV-ALU-HELP C
                               (TFIRSTN A TREE)
                               (TFIRSTN B TREE)
                               MPG
                               (CAR TREE)))
          (CDDR (F$TV-ALU-HELP (F$T-CARRY C
                                          (CAR (F$TV-ALU-HELP C
                                                              (TFIRSTN A TREE)
                                                              (TFIRSTN B TREE)
                                                              MPG
                                                              (CAR TREE)))
                                          (CADR (F$TV-ALU-HELP C
                                                               (TFIRSTN A TREE)
                                                               (TFIRSTN B TREE)
                                                               MPG
                                                               (CAR TREE))))
                               (TRESTN A TREE)
                               (TRESTN B TREE)
                               MPG
                               (CDR TREE))))))))

(TOGGLE F$TV-ALU-HELP-OFF F$TV-ALU-HELP T)

(PROVE-LEMMA CDDR-F$TV-ALU-HELP-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (CDDR (F$TV-ALU-HELP C A B MPG TREE)))
                    (TREE-SIZE TREE))
             ((ENABLE F$TV-ALU-HELP F$ALU-CELL LENGTH TREE-SIZE)))

(PROVE-LEMMA F$TV-ALU-HELP-LENGTH
             (REWRITE)
             (EQUAL (LENGTH (F$TV-ALU-HELP C A B MPG TREE))
                    (ADD1 (ADD1 (TREE-SIZE TREE))))
             ((ENABLE LENGTH F$TV-ALU-HELP F$ALU-CELL TREE-SIZE)))

(PROVE-LEMMA PROPERP-CDDR-F$TV-ALU-HELP
             (REWRITE)
             (PROPERP (CDDR (F$TV-ALU-HELP C A B MPG TREE)))
             ((ENABLE PROPERP F$ALU-CELL)
              (INDUCT (F$TV-ALU-HELP C A B MPG TREE))
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA PROPERP-F$TV-ALU-HELP
             (REWRITE)
             (PROPERP (F$TV-ALU-HELP C A B MPG TREE))
             ((ENABLE PROPERP F$ALU-CELL)
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA BOOLP-CAR-F$TV-ALU-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (AND (BOOLP (CAR (F$TV-ALU-HELP C A B MPG TREE)))
                           (BOOLP (CADR (F$TV-ALU-HELP C A B MPG TREE)))))
             ((INDUCT (F$TV-ALU-HELP C A B MPG TREE))
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)
              (ENABLE BOOLP-B-GATES)))

(PROVE-LEMMA BVP-CDDR-F$TV-ALU-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (BVP (CDDR (F$TV-ALU-HELP C A B MPG TREE))))
             ((ENABLE BVP BOOLP-B-GATES)
              (INDUCT (F$TV-ALU-HELP C A B MPG TREE))
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA BVP-F$TV-ALU-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (BVP (F$TV-ALU-HELP C A B MPG TREE)))
             ((ENABLE BVP BOOLP-B-GATES)
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA F$TV-ALU-HELP=TV-ALU-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (EQUAL (F$TV-ALU-HELP C A B MPG TREE)
                             (TV-ALU-HELP C A B MPG TREE)))
             ((INDUCT (TV-ALU-HELP C A B MPG TREE))
              (ENABLE BOOLP-B-GATES BVP-LENGTH)
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE)
                      (TV-ALU-HELP C A B MPG TREE))
              (DISABLE-THEORY F-GATES B-GATES)
              (DISABLE ALU-CELL MPG T-CARRY)))

(DEFN TV-ALU-HELP-BODY
 (TREE)
 (IF
  (NLISTP TREE)
  (LIST (LIST 'LEAF
              (LIST 'P 'G (INDEX 'OUT 0))
              'ALU-CELL
              (CONS 'C
                    (CONS (INDEX 'A 0)
                          (CONS (INDEX 'B 0)
                                (INDICES 'MPG 0 7))))))
  (APPEND
   (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                         3)
              0)
       (LIST (LIST 'BUFFERMPG
                   (INDICES 'MPG- 0 7)
                   (INDEX 'V-BUF 7)
                   (INDICES 'MPG 0 7)))
       NIL)
   (CONS
    (LIST 'LHS
          (CONS 'PL
                (CONS 'GL
                      (TFIRSTN (INDICES 'OUT 0 (TREE-SIZE TREE))
                               TREE)))
          (INDEX 'TV-ALU-HELP
                 (TREE-NUMBER (CAR TREE)))
          (CONS 'C
                (APPEND (TFIRSTN (INDICES 'A 0 (TREE-SIZE TREE))
                                 TREE)
                        (APPEND (TFIRSTN (INDICES 'B 0 (TREE-SIZE TREE))
                                         TREE)
                                (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                                                      3)
                                           0)
                                    (INDICES 'MPG- 0 7)
                                    (INDICES 'MPG 0 7))))))
    (CONS
     '(LHS-CARRY (CL) T-CARRY (C PL GL))
     (CONS
      (LIST 'RHS
          (CONS 'PR
                (CONS 'GR
                      (TRESTN (INDICES 'OUT 0 (TREE-SIZE TREE))
                              TREE)))
          (INDEX 'TV-ALU-HELP
                 (TREE-NUMBER (CDR TREE)))
          (CONS 'CL
                (APPEND (TRESTN (INDICES 'A 0 (TREE-SIZE TREE))
                                TREE)
                        (APPEND (TRESTN (INDICES 'B 0 (TREE-SIZE TREE))
                                        TREE)
                                (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                                                      3)
                                           0)
                                    (INDICES 'MPG- 0 7)
                                    (INDICES 'MPG 0 7))))))
      '((P (P) B-AND (PL PR))
        (G (G) T-CARRY (GL PR GR)))))))))

(DEFN TV-ALU-HELP*
      (TREE)
      (CONS (INDEX 'TV-ALU-HELP
                   (TREE-NUMBER TREE))
            (CONS (CONS 'C
                        (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                                        (INDICES 'MPG 0 7))))
                  (CONS (CONS 'P
                              (CONS 'G
                                    (INDICES 'OUT 0 (TREE-SIZE TREE))))
                        (CONS (TV-ALU-HELP-BODY TREE)
                              '(NIL))))))

(PROVE-LEMMA TV-ALU-HELP*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TV-ALU-HELP* TREE))
                         (INDEX 'TV-ALU-HELP
                                (TREE-NUMBER TREE)))
                  (EQUAL (CADR (TV-ALU-HELP* TREE))
                         (CONS 'C
                               (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                       (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                                               (INDICES 'MPG 0 7)))))
                  (EQUAL (CADDR (TV-ALU-HELP* TREE))
                         (CONS 'P
                               (CONS 'G
                                     (INDICES 'OUT 0 (TREE-SIZE TREE)))))
                  (EQUAL (CADDDR (TV-ALU-HELP* TREE))
                         (TV-ALU-HELP-BODY TREE))
                  (EQUAL (CADDDDR (TV-ALU-HELP* TREE))
                         NIL)))

(TOGGLE TV-ALU-HELP*-OFF TV-ALU-HELP* T)

(TOGGLE TV-ALU-HELP*$DESTRUCTURE-OFF TV-ALU-HELP*$DESTRUCTURE T)

(DEFN TV-ALU-HELP&
      (NETLIST TREE)
      (IF (NLISTP TREE)
          (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-ALU-HELP
                                            (TREE-NUMBER TREE))
                                     NETLIST)
                      (TV-ALU-HELP* TREE))
               (ALU-CELL& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                                (TREE-NUMBER TREE))
                                         NETLIST)))
          (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-ALU-HELP
                                            (TREE-NUMBER TREE))
                                     NETLIST)
                      (TV-ALU-HELP* TREE))
               (T-CARRY& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                               (TREE-NUMBER TREE))
                                        NETLIST))
               (B-AND& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                             (TREE-NUMBER TREE))
                                      NETLIST))
               (V-BUF& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                             (TREE-NUMBER TREE))
                                      NETLIST)
                       7)
               (TV-ALU-HELP& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                                   (TREE-NUMBER TREE))
                                            NETLIST)
                             (CAR TREE))
               (TV-ALU-HELP& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                                   (TREE-NUMBER TREE))
                                            NETLIST)
                             (CDR TREE)))))

(TOGGLE TV-ALU-HELP&-OFF TV-ALU-HELP& T)

(DEFN TV-ALU-HELP$NETLIST
      (TREE)
      (IF (NLISTP TREE)
          (CONS (TV-ALU-HELP* TREE)
                (ALU-CELL$NETLIST))
          (CONS (TV-ALU-HELP* TREE)
                (UNION (TV-ALU-HELP$NETLIST (CAR TREE))
                       (UNION (TV-ALU-HELP$NETLIST (CDR TREE))
                              (UNION (T-CARRY$NETLIST)
                                     (UNION (B-AND$NETLIST)
                                            (V-BUF$NETLIST 7))))))))

(DEFN TV-ALU-HELP-INDUCTION
 (TREE C A B MPG STATE NETLIST)
 (IF
  (NLISTP TREE)
  T
  (AND
   (TV-ALU-HELP-INDUCTION (CAR TREE)
                          C
                          (TFIRSTN A TREE)
                          (TFIRSTN B TREE)
                          (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                                                3)
                                     0)
                              (V-THREEFIX MPG)
                              MPG)
                          0
                          (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                                (TREE-NUMBER TREE))
                                         NETLIST))
   (TV-ALU-HELP-INDUCTION
    (CDR TREE)
    (F$T-CARRY C
           (CAR (F$TV-ALU-HELP C
                               (TFIRSTN A TREE)
                               (TFIRSTN B TREE)
                               (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                                                     3)
                                          0)
                                   (V-THREEFIX MPG)
                                   MPG)
                               (CAR TREE)))
           (CADR (F$TV-ALU-HELP C
                                (TFIRSTN A TREE)
                                (TFIRSTN B TREE)
                                (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                                                      3)
                                           0)
                                    (V-THREEFIX MPG)
                                    MPG)
                                (CAR TREE))))
    (TRESTN A TREE)
    (TRESTN B TREE)
    (IF (EQUAL (REMAINDER (SUB1 (TREE-HEIGHT TREE))
                          3)
               0)
        (V-THREEFIX MPG)
        MPG)
    0
    (DELETE-MODULE (INDEX 'TV-ALU-HELP
                          (TREE-NUMBER TREE))
                   NETLIST)))))

(PROVE-LEMMA TV-ALU-HELP-LEMMA-CROCK
          (REWRITE)
          (IMPLIES (TV-ALU-HELP& (DELETE-MODULE (INDEX 'TV-ALU-HELP
                                                       (TREE-NUMBER TREE))
                                                NETLIST)
                                 (CAR TREE))
                   (EQUAL (COLLECT-VALUE (INDICES 'OUT 0 N)
                                         BINDINGS)
                          (APPEND (COLLECT-VALUE (FIRSTN (TREE-SIZE (CAR TREE))
                                                         (INDICES 'OUT 0 N))
                                                 BINDINGS)
                                  (COLLECT-VALUE (RESTN (TREE-SIZE (CAR TREE))
                                                        (INDICES 'OUT 0 N))
                                                 BINDINGS))))
          ((USE (COLLECT-VALUE-SPLITTING-CROCK (L (INDICES 'OUT 0 N))
                                               (N (TREE-SIZE (CAR TREE)))
                                               (ALIST BINDINGS)))))

(TOGGLE TV-ALU-HELP-LEMMA-CROCK-OFF TV-ALU-HELP-LEMMA-CROCK T)

(PROVE-LEMMA TV-ALU-HELP$VALUE-BASE-CASE
             (REWRITE)
             (IMPLIES (AND (NLISTP TREE)
                           (TV-ALU-HELP& NETLIST TREE)
                           (EQUAL (LENGTH A) 1)
                           (PROPERP A)
                           (EQUAL (LENGTH B) 1)
                           (PROPERP B)
                           (EQUAL (LENGTH MPG) 7)
                           (PROPERP MPG))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TV-ALU-HELP
                                               (TREE-NUMBER TREE))
                                        (CONS C (APPEND A (APPEND B MPG)))
                                        STATE NETLIST)
                             (F$TV-ALU-HELP C A B MPG TREE)))
             ((DISABLE F-AND *1*INDICES OPEN-INDICES)
              (ENABLE ALU-CELL$VALUE F$ALU-CELL TV-ALU-HELP*$DESTRUCTURE)
              (EXPAND (TV-ALU-HELP& NETLIST TREE)
                      (F$TV-ALU-HELP C A B MPG TREE)
                      (APPEND B MPG)
                      (APPEND A (CONS (CAR B) MPG))
                      (INDICES 'OUT 0 1)
                      (INDICES 'A 0 1)
                      (INDICES 'B 0 1))))

(TOGGLE TV-ALU-HELP$VALUE-BASE-CASE-OFF TV-ALU-HELP$VALUE-BASE-CASE T)

(PROVE-LEMMA F$TV-ALU-HELP-V-THREEFIX-MPG
             (REWRITE)
             (IMPLIES (EQUAL (LENGTH MPG) 7)
                      (EQUAL (F$TV-ALU-HELP C A B
                                            (V-THREEFIX MPG)
                                            TREE)
                             (F$TV-ALU-HELP C A B MPG TREE)))
             ((INDUCT (F$TV-ALU-HELP C A B MPG TREE))
              (EXPAND (F$TV-ALU-HELP C A B MPG TREE)
                      (F$TV-ALU-HELP C A B
                                     (V-THREEFIX MPG)
                                     TREE))
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA TV-ALU-HELP$VALUE
             (REWRITE)
             (IMPLIES (AND (TV-ALU-HELP& NETLIST TREE)
                           (PROPERP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (PROPERP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (PROPERP MPG)
                           (EQUAL (LENGTH MPG) 7))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TV-ALU-HELP
                                               (TREE-NUMBER TREE))
                                        (CONS C (APPEND A (APPEND B MPG)))
                                        STATE NETLIST)
                             (F$TV-ALU-HELP C A B MPG TREE)))
             ((INDUCT (TV-ALU-HELP-INDUCTION TREE C A B MPG STATE NETLIST))
              (ENABLE TV-ALU-HELP-LEMMA-CROCK T-CARRY$VALUE B-AND$VALUE
                      V-BUF$VALUE TV-ALU-HELP$VALUE-BASE-CASE
                      TV-ALU-HELP*$DESTRUCTURE)
              (DISABLE INDICES *1*INDICES OPEN-INDICES F-AND TREE-NUMBER
                       T-CARRY-P-G-CARRY)
              (EXPAND (TV-ALU-HELP& NETLIST TREE)
                      (F$TV-ALU-HELP C A B MPG TREE))))

(TOGGLE TV-ALU-HELP$VALUE-OFF TV-ALU-HELP$VALUE T)

(DEFN CARRY-OUT-HELP
      (A0 RESULT ZERO OP0 OP1 OP2 OP3)
      (B-AND (B-NAND3 (B-NAND4 (B-NOT OP3)
                               (B-NAND (B-NOT OP0) (B-NOT OP1))
                               (B-NOT OP2)
                               RESULT)
                      (B-NAND3 (B-NOT OP3)
                               (B-NOT (B-NOT OP2))
                               (B-NOT RESULT))
                      (B-NAND4 (B-NOT (B-NOT OP3))
                               (B-NOT OP2)
                               (B-NAND (B-NOT (B-NOT OP0))
                                       (B-NOT (B-NOT OP1)))
                               A0))
             (B-NOT ZERO)))

(DEFN F$CARRY-OUT-HELP
      (A0 RESULT ZERO OP0 OP1 OP2 OP3)
      (F-AND (F-NAND3 (F-NAND4 (F-NOT OP3)
                               (F-NAND (F-NOT OP0) (F-NOT OP1))
                               (F-NOT OP2)
                               RESULT)
                      (F-NAND3 (F-NOT OP3)
                               (F-NOT (F-NOT OP2))
                               (F-NOT RESULT))
                      (F-NAND4 (F-NOT (F-NOT OP3))
                               (F-NOT OP2)
                               (F-NAND (F-NOT (F-NOT OP0))
                                       (F-NOT (F-NOT OP1)))
                               A0))
             (F-NOT ZERO)))

(TOGGLE F$CARRY-OUT-HELP-OFF F$CARRY-OUT-HELP T)

(DEFN CARRY-OUT-HELP* NIL
      '(CARRY-OUT-HELP (A0 RESULT ZERO OP0 OP1 OP2 OP3)
                       (W-22)
                       ((G-21 (W-21) B-NOT (ZERO))
                        (G-16 (W-16) B-NOT (OP1))
                        (G-17 (W-17) B-NOT (W-16))
                        (G-14 (W-14) B-NOT (OP0))
                        (G-15 (W-15) B-NOT (W-14))
                        (G-18 (W-18) B-NAND (W-15 W-17))
                        (G-13 (W-13) B-NOT (OP2))
                        (G-11 (W-11) B-NOT (OP3))
                        (G-12 (W-12) B-NOT (W-11))
                        (G-19 (W-19)
                              B-NAND4
                              (W-12 W-13 W-18 A0))
                        (G-9 (W-9) B-NOT (RESULT))
                        (G-8 (W-8) B-NOT (W-13))
                        (G-10 (W-10) B-NAND3 (W-11 W-8 W-9))
                        (G-3 (W-3) B-NAND (W-14 W-16))
                        (G-5 (W-5)
                             B-NAND4
                             (W-11 W-3 W-13 RESULT))
                        (G-20 (W-20) B-NAND3 (W-5 W-10 W-19))
                        (G-22 (W-22) B-AND (W-20 W-21)))
                       NIL))

(DEFN CARRY-OUT-HELP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CARRY-OUT-HELP
                                 NETLIST)
                  (CARRY-OUT-HELP*))
           (B-NOT& (DELETE-MODULE 'CARRY-OUT-HELP
                                  NETLIST))
           (B-NAND& (DELETE-MODULE 'CARRY-OUT-HELP
                                   NETLIST))
           (B-NAND4& (DELETE-MODULE 'CARRY-OUT-HELP
                                    NETLIST))
           (B-NAND3& (DELETE-MODULE 'CARRY-OUT-HELP
                                    NETLIST))
           (B-AND& (DELETE-MODULE 'CARRY-OUT-HELP
                                  NETLIST))))

(TOGGLE CARRY-OUT-HELP&-OFF CARRY-OUT-HELP& T)

(DEFN CARRY-OUT-HELP$NETLIST NIL
      (CONS (CARRY-OUT-HELP*)
            (UNION (UNION (UNION (UNION (B-NOT$NETLIST)
                                        (B-NAND$NETLIST))
                                 (B-NAND4$NETLIST))
                          (B-NAND3$NETLIST))
                   (B-AND$NETLIST))))

(PROVE-LEMMA CARRY-OUT-HELP$VALUE
             (REWRITE)
             (IMPLIES (CARRY-OUT-HELP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'CARRY-OUT-HELP
                                        (LIST A0 RESULT ZERO OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (LIST (F$CARRY-OUT-HELP A0 RESULT ZERO OP0 OP1
                                                     OP2 OP3))))
             ((ENABLE CARRY-OUT-HELP& F$CARRY-OUT-HELP B-NOT$VALUE
                      B-NAND$VALUE B-NAND4$VALUE B-NAND3$VALUE B-AND$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE CARRY-OUT-HELP$VALUE-OFF CARRY-OUT-HELP$VALUE T)

(PROVE-LEMMA F$CARRY-OUT-HELP=CARRY-OUT-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP A0)
                           (BOOLP RESULT)
                           (BOOLP ZERO)
                           (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$CARRY-OUT-HELP A0 RESULT ZERO OP0 OP1 OP2 OP3)
                             (CARRY-OUT-HELP A0 RESULT ZERO OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$CARRY-OUT-HELP CARRY-OUT-HELP)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA CARRY-OUT-HELP-CONGRUENCE
             (REWRITE)
             (IMPLIES X
                      (EQUAL (EQUAL (CARRY-OUT-HELP X A ZERO OP0 OP1 OP2 OP3)
                                    (CARRY-OUT-HELP T A ZERO OP0 OP1 OP2 OP3))
                             T)))

(PROVE-LEMMA CARRY-OUT-HELP$VALUE-ZERO
             (REWRITE)
             (IMPLIES (CARRY-OUT-HELP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'CARRY-OUT-HELP
                                        (LIST A0 RESULT T OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (LIST F)))
             ((ENABLE CARRY-OUT-HELP& B-NOT$VALUE B-AND$VALUE B-NOT
                      F-AND-REWRITE)
              (DISABLE-THEORY F-GATES B-GATES)))

(TOGGLE CARRY-OUT-HELP$VALUE-ZERO-OFF CARRY-OUT-HELP$VALUE-ZERO T)

(DEFN OVERFLOW-HELP
    (RN AN BN ZERO OP0 OP1 OP2 OP3)
    (B-IF RN
          (B-NOR (B-NAND (B-NOR (B-NAND3 (B-NOT OP3)
                                         (B-OR3 (B-NOT OP1)
                                                (B-NOT OP2)
                                                (B-XOR (B-NOT (B-NOT AN)) BN))
                                         (B-NAND3 (B-NOT OP1)
                                                  (B-NOT (B-NOT OP2))
                                                  (B-NOT AN)))
                                (B-NAND (B-NAND3 OP1
                                                 (B-NOT OP2)
                                                 (B-XOR (B-NOT (B-NOT AN)) BN))
                                        (B-NAND3 (B-NOT OP1)
                                                 (B-NOT OP2)
                                                 (B-NOT (B-NOT AN)))))
                         (B-NOT ZERO))
                 (B-NAND3 (B-NAND (B-NOT (B-NOT OP2))
                                  (B-NOT AN))
                          (B-NAND3 OP0
                                   (B-NOT OP1)
                                   (B-NOT (B-NOT AN)))
                          (B-NAND (B-NOT OP2)
                                  (B-NOT (B-NOT AN)))))
          (B-NOR (B-NAND (B-NOR (B-NAND3 (B-NOT OP3)
                                         (B-OR3 (B-NOT OP1)
                                                (B-NOT OP2)
                                                (B-XOR (B-NOT (B-NOT AN)) BN))
                                         (B-NAND3 (B-NOT OP1)
                                                  (B-NOT (B-NOT OP2))
                                                  (B-NOT AN)))
                                (B-NAND (B-NAND3 OP1
                                                 (B-NOT OP2)
                                                 (B-XOR (B-NOT (B-NOT AN)) BN))
                                        (B-NAND3 (B-NOT OP1)
                                                 (B-NOT OP2)
                                                 (B-NOT (B-NOT AN)))))
                         (B-NOT ZERO))
                 (B-NOT (B-NAND3 (B-NAND (B-NOT (B-NOT OP2))
                                         (B-NOT AN))
                                 (B-NAND3 OP0
                                          (B-NOT OP1)
                                          (B-NOT (B-NOT AN)))
                                 (B-NAND (B-NOT OP2)
                                         (B-NOT (B-NOT AN))))))))

(DEFN F$OVERFLOW-HELP
    (RN AN BN ZERO OP0 OP1 OP2 OP3)
    (F-IF RN
          (F-NOR (F-NAND (F-NOR (F-NAND3 (F-NOT OP3)
                                         (F-OR3 (F-NOT OP1)
                                                (F-NOT OP2)
                                                (F-XOR (F-NOT (F-NOT AN)) BN))
                                         (F-NAND3 (F-NOT OP1)
                                                  (F-NOT (F-NOT OP2))
                                                  (F-NOT AN)))
                                (F-NAND (F-NAND3 OP1
                                                 (F-NOT OP2)
                                                 (F-XOR (F-NOT (F-NOT AN)) BN))
                                        (F-NAND3 (F-NOT OP1)
                                                 (F-NOT OP2)
                                                 (F-NOT (F-NOT AN)))))
                         (F-NOT ZERO))
                 (F-NAND3 (F-NAND (F-NOT (F-NOT OP2))
                                  (F-NOT AN))
                          (F-NAND3 OP0
                                   (F-NOT OP1)
                                   (F-NOT (F-NOT AN)))
                          (F-NAND (F-NOT OP2)
                                  (F-NOT (F-NOT AN)))))
          (F-NOR (F-NAND (F-NOR (F-NAND3 (F-NOT OP3)
                                         (F-OR3 (F-NOT OP1)
                                                (F-NOT OP2)
                                                (F-XOR (F-NOT (F-NOT AN)) BN))
                                         (F-NAND3 (F-NOT OP1)
                                                  (F-NOT (F-NOT OP2))
                                                  (F-NOT AN)))
                                (F-NAND (F-NAND3 OP1
                                                 (F-NOT OP2)
                                                 (F-XOR (F-NOT (F-NOT AN)) BN))
                                        (F-NAND3 (F-NOT OP1)
                                                 (F-NOT OP2)
                                                 (F-NOT (F-NOT AN)))))
                         (F-NOT ZERO))
                 (F-NOT (F-NAND3 (F-NAND (F-NOT (F-NOT OP2))
                                         (F-NOT AN))
                                 (F-NAND3 OP0
                                          (F-NOT OP1)
                                          (F-NOT (F-NOT AN)))
                                 (F-NAND (F-NOT OP2)
                                         (F-NOT (F-NOT AN))))))))

(TOGGLE F$OVERFLOW-HELP-OFF F$OVERFLOW-HELP T)

(DEFN OVERFLOW-HELP* NIL
      '(OVERFLOW-HELP (RN AN BN ZERO OP0 OP1 OP2 OP3)
                      (W-83)
                      ((G-77 (W-77) B-NOT (AN))
                       (G-78 (W-78) B-NOT (W-77))
                       (G-76 (W-76) B-NOT (OP2))
                       (G-79 (W-79) B-NAND (W-76 W-78))
                       (G-72 (W-72) B-NOT (OP1))
                       (G-75 (W-75) B-NAND3 (OP0 W-72 W-78))
                       (G-69 (W-69) B-NOT (W-76))
                       (G-71 (W-71) B-NAND (W-69 W-77))
                       (G-80 (W-80) B-NAND3 (W-71 W-75 W-79))
                       (G-81 (W-81) B-NOT (W-80))
                       (G-66 (W-66) B-NOT (ZERO))
                       (G-63 (W-63) B-NAND3 (W-72 W-76 W-78))
                       (G-57 (W-57) B-XOR (W-78 BN))
                       (G-58 (W-58) B-NAND3 (OP1 W-76 W-57))
                       (G-64 (W-64) B-NAND (W-58 W-63))
                       (G-52 (W-52) B-NAND3 (W-72 W-69 W-77))
                       (G-47 (W-47) B-OR3 (W-72 W-76 W-57))
                       (G-41 (W-41) B-NOT (OP3))
                       (G-53 (W-53) B-NAND3 (W-41 W-47 W-52))
                       (G-65 (W-65) B-NOR (W-53 W-64))
                       (G-67 (W-67) B-NAND (W-65 W-66))
                       (G-82 (W-82) B-NOR (W-67 W-81))
                       (G-40 (W-40) B-NOR (W-67 W-80))
                       (G-83 (W-83) B-IF (RN W-40 W-82)))
                      NIL))

(DEFN OVERFLOW-HELP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'OVERFLOW-HELP
                                 NETLIST)
                  (OVERFLOW-HELP*))
           (B-XOR& (DELETE-MODULE 'OVERFLOW-HELP
                                  NETLIST))
           (B-OR3& (DELETE-MODULE 'OVERFLOW-HELP
                                  NETLIST))
           (B-NOT& (DELETE-MODULE 'OVERFLOW-HELP
                                  NETLIST))
           (B-NAND3& (DELETE-MODULE 'OVERFLOW-HELP
                                    NETLIST))
           (B-NAND& (DELETE-MODULE 'OVERFLOW-HELP
                                   NETLIST))
           (B-NOR& (DELETE-MODULE 'OVERFLOW-HELP
                                  NETLIST))
           (B-IF& (DELETE-MODULE 'OVERFLOW-HELP
                                 NETLIST))))

(TOGGLE OVERFLOW-HELP&-OFF OVERFLOW-HELP& T)

(DEFN OVERFLOW-HELP$NETLIST NIL
      (CONS (OVERFLOW-HELP*)
            (UNION (UNION (UNION (UNION (UNION (UNION (B-XOR$NETLIST)
                                                      (B-OR3$NETLIST))
                                               (B-NOT$NETLIST))
                                        (B-NAND3$NETLIST))
                                 (B-NAND$NETLIST))
                          (B-NOR$NETLIST))
                   (B-IF$NETLIST))))

(PROVE-LEMMA OVERFLOW-HELP$VALUE
             (REWRITE)
             (IMPLIES (OVERFLOW-HELP& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'OVERFLOW-HELP
                                        (LIST RN AN BN ZERO OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (LIST (F$OVERFLOW-HELP RN AN BN ZERO OP0 OP1
                                                    OP2 OP3))))
             ((ENABLE OVERFLOW-HELP& F$OVERFLOW-HELP B-XOR$VALUE B-OR3$VALUE
                      B-NOT$VALUE B-NAND3$VALUE B-NAND$VALUE B-NOR$VALUE
                      B-IF$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE OVERFLOW-HELP$VALUE-OFF OVERFLOW-HELP$VALUE T)

(PROVE-LEMMA F$OVERFLOW-HELP=OVERFLOW-HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP RN)
                           (BOOLP AN)
                           (BOOLP BN)
                           (BOOLP ZERO)
                           (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$OVERFLOW-HELP RN AN BN ZERO OP0 OP1 OP2 OP3)
                             (OVERFLOW-HELP RN AN BN ZERO OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$OVERFLOW-HELP OVERFLOW-HELP)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA OVERFLOW-HELP$VALUE-ZERO
             (REWRITE)
             (IMPLIES (AND (OVERFLOW-HELP& NETLIST)
                           (BOOLP RN))
                      (EQUAL (DUAL-EVAL 0 'OVERFLOW-HELP
                                        (LIST RN AN BN T OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (LIST F)))
             ((ENABLE OVERFLOW-HELP& B-NAND$VALUE B-NOT$VALUE B-NOR$VALUE
                      F-NAND F-NOR B-IF$VALUE B-NOT F-AND3 F-AND-REWRITE BOOLP
                      B-IF)
              (DISABLE-THEORY F-GATES B-GATES)))

(TOGGLE OVERFLOW-HELP$VALUE-ZERO-OFF OVERFLOW-HELP$VALUE-ZERO T)

(DEFN V-SHIFT-RIGHT-NAMES
      (A SI)
      (IF (NLISTP A)
          NIL
          (APPEND (CDR A) (LIST SI))))

(PROVE-LEMMA LENGTH-V-SHIFT-RIGHT-NAMES
             (REWRITE)
             (EQUAL (LENGTH (V-SHIFT-RIGHT-NAMES A SI))
                    (LENGTH A))
             ((ENABLE LENGTH)))

(PROVE-LEMMA PROPERP-SHIFT-RIGHT-NAMES
             (REWRITE)
             (PROPERP (V-SHIFT-RIGHT-NAMES A SI))
             ((ENABLE PROPERP)))

(PROVE-LEMMA COLLECT-VALUE-V-SHIFT-RIGHT
             (REWRITE)
             (EQUAL (V-THREEFIX (COLLECT-VALUE (V-SHIFT-RIGHT-NAMES A SI)
                                               ALIST))
                    (FV-SHIFT-RIGHT (COLLECT-VALUE A ALIST)
                                    (VALUE SI ALIST)))
             ((ENABLE COLLECT-VALUE APPEND FV-SHIFT-RIGHT V-THREEFIX)))

(DEFN SHIFT-OR-BUF-CNTL
      (C AN ZERO OP0 OP1 OP2 OP3)
      (LIST (B-OR3 (B-AND OP0 OP1)
                   (B-NAND (B-NOT OP2) OP3)
                   ZERO)
            (B-OR (B-AND OP0 AN)
                  (B-AND (B-AND (B-NOT OP0) (B-NOT OP1))
                         C))))

(DEFN F$SHIFT-OR-BUF-CNTL
      (C AN ZERO OP0 OP1 OP2 OP3)
      (LIST (F-OR3 (F-AND OP0 OP1)
                   (F-NAND (F-NOT OP2) OP3)
                   ZERO)
            (F-OR (F-AND OP0 AN)
                  (F-AND (F-AND (F-NOT OP0) (F-NOT OP1))
                         C))))

(TOGGLE F$SHIFT-OR-BUF-CNTL-OFF F$SHIFT-OR-BUF-CNTL T)

(DEFN SHIFT-OR-BUF-CNTL* NIL
      '(SHIFT-OR-BUF-CNTL (C AN ZERO OP0 OP1 OP2 OP3)
                          (W-3 W-9)
                          ((G-6 (W-6) B-NOT (OP1))
                           (G-5 (W-5) B-NOT (OP0))
                           (G-7 (W-7) B-AND (W-5 W-6))
                           (G-8 (W-8) B-AND (W-7 C))
                           (G-4 (W-4) B-AND (OP0 AN))
                           (G-9 (W-9) B-OR (W-4 W-8))
                           (G-1 (W-1) B-NOT (OP2))
                           (G-2 (W-2) B-NAND (W-1 OP3))
                           (G-0 (W-0) B-AND (OP0 OP1))
                           (G-3 (W-3) B-OR3 (W-0 W-2 ZERO)))
                          NIL))

(DEFN SHIFT-OR-BUF-CNTL&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'SHIFT-OR-BUF-CNTL
                                 NETLIST)
                  (SHIFT-OR-BUF-CNTL*))
           (B-OR& (DELETE-MODULE 'SHIFT-OR-BUF-CNTL
                                 NETLIST))
           (B-NOT& (DELETE-MODULE 'SHIFT-OR-BUF-CNTL
                                  NETLIST))
           (B-NAND& (DELETE-MODULE 'SHIFT-OR-BUF-CNTL
                                   NETLIST))
           (B-AND& (DELETE-MODULE 'SHIFT-OR-BUF-CNTL
                                  NETLIST))
           (B-OR3& (DELETE-MODULE 'SHIFT-OR-BUF-CNTL
                                  NETLIST))))

(TOGGLE SHIFT-OR-BUF-CNTL&-OFF SHIFT-OR-BUF-CNTL& T)

(DEFN SHIFT-OR-BUF-CNTL$NETLIST NIL
      (CONS (SHIFT-OR-BUF-CNTL*)
            (UNION (UNION (UNION (UNION (B-OR$NETLIST) (B-NOT$NETLIST))
                                 (B-NAND$NETLIST))
                          (B-AND$NETLIST))
                   (B-OR3$NETLIST))))

(PROVE-LEMMA SHIFT-OR-BUF-CNTL$VALUE
             (REWRITE)
             (IMPLIES (SHIFT-OR-BUF-CNTL& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'SHIFT-OR-BUF-CNTL
                                        (LIST C AN ZERO OP0 OP1 OP2 OP3)
                                        STATE NETLIST)
                             (F$SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2 OP3)))
             ((ENABLE SHIFT-OR-BUF-CNTL& F$SHIFT-OR-BUF-CNTL B-OR$VALUE
                      B-NOT$VALUE B-NAND$VALUE B-AND$VALUE B-OR3$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE SHIFT-OR-BUF-CNTL$VALUE-OFF SHIFT-OR-BUF-CNTL$VALUE T)

(PROVE-LEMMA F$SHIFT-OR-BUF-CNTL=SHIFT-OR-BUF-CNTL
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BOOLP AN)
                           (BOOLP ZERO)
                           (BOOLP OP0)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3))
                      (EQUAL (F$SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2 OP3)
                             (SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2 OP3)))
             ((ENABLE BOOLP-B-GATES F$SHIFT-OR-BUF-CNTL SHIFT-OR-BUF-CNTL)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA SHIFT-OR-BUF-CNTL$VALUE-ZERO
             (REWRITE)
             (IMPLIES (SHIFT-OR-BUF-CNTL& NETLIST)
                      (EQUAL (CAR (DUAL-EVAL 0 'SHIFT-OR-BUF-CNTL
                                             (LIST C AN T OP0 OP1 OP2 OP3)
                                             STATE NETLIST))
                             T))
             ((ENABLE SHIFT-OR-BUF-CNTL& B-OR3$VALUE F-OR3 F-OR-REWRITE)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN F$SHIFT-OR-BUF
      (C A AN ZERO OP0 OP1 OP2 OP3)
      (FV-IF (CAR (F$SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2 OP3))
             A
             (FV-SHIFT-RIGHT A
                             (CADR (F$SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1
                                                        OP2 OP3)))))

(TOGGLE F$SHIFT-OR-BUF-OFF F$SHIFT-OR-BUF T)

(DEFN SHIFT-OR-BUF
      (C A AN ZERO OP0 OP1 OP2 OP3)
      (V-IF (CAR (SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2 OP3))
            A
            (V-SHIFT-RIGHT A
                           (CADR (SHIFT-OR-BUF-CNTL C AN ZERO OP0 OP1 OP2
                                                    OP3)))))

(TOGGLE SHIFT-OR-BUF-OFF SHIFT-OR-BUF T)

(PROVE-LEMMA PROPERP-LENGTH-F$SHIFT-OR-BUF
             (REWRITE)
             (AND (PROPERP (F$SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3))
                  (EQUAL (LENGTH (F$SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3))
                         (LENGTH A)))
             ((ENABLE F$SHIFT-OR-BUF)))

(PROVE-LEMMA LENGTH-SHIFT-OR-BUF
             (REWRITE)
             (EQUAL (LENGTH (SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4))
                    (LENGTH A))
             ((EXPAND (SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4))))

(PROVE-LEMMA BVP-SHIFT-OR-BUF
             (REWRITE)
             (BVP (SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4))
             ((EXPAND (SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4))))

(PROVE-LEMMA F$SHIFT-OR-BUF=SHIFT-OR-BUF
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BOOLP AN)
                           (BOOLP ZERO)
                           (BOOLP OP1)
                           (BOOLP OP2)
                           (BOOLP OP3)
                           (BOOLP OP4)
                           (BVP A))
                      (EQUAL (F$SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4)
                             (SHIFT-OR-BUF C A AN ZERO OP1 OP2 OP3 OP4)))
             ((ENABLE F$SHIFT-OR-BUF SHIFT-OR-BUF)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA SHIFT-OR-BUF-IS-BUF
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (OR (AND OP0 OP1) OP2 (NOT OP3) ZERO))
                      (EQUAL (SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3)
                             A))
             ((ENABLE SHIFT-OR-BUF)
              (DISABLE V-SHIFT-RIGHT)))

(PROVE-LEMMA SHIFT-OR-BUF-IS-ASR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL AN (NTH (SUB1 (LENGTH A)) A))
                           OP0
                           (NOT OP1)
                           (NOT OP2)
                           OP3
                           (NOT ZERO))
                      (EQUAL (SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3)
                             (V-ASR A)))
             ((ENABLE SHIFT-OR-BUF V-SHIFT-RIGHT)))

(PROVE-LEMMA SHIFT-OR-BUF-IS-ROR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (BOOLP C)
                           (NOT OP0)
                           (NOT OP1)
                           (NOT OP2)
                           OP3
                           (NOT ZERO))
                      (EQUAL (SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3)
                             (V-ROR A C)))
             ((ENABLE SHIFT-OR-BUF V-SHIFT-RIGHT)))

(PROVE-LEMMA SHIFT-OR-BUF-IS-LSR
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT OP0)
                           OP1
                           (NOT OP2)
                           OP3
                           (NOT ZERO))
                      (EQUAL (SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3)
                             (V-LSR A)))
             ((ENABLE SHIFT-OR-BUF)))

(DEFN TV-SHIFT-OR-BUF*
 (TREE)
 (CONS
  (INDEX 'TV-SHIFT-OR-BUF
         (TREE-NUMBER TREE))
  (CONS
   (CONS 'C
         (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                 '(AN ZERO OP0 OP1 OP2 OP3)))
   (CONS
    (INDICES 'OUT 0 (TREE-SIZE TREE))
    (CONS
     (LIST
      '(CNTL (CTL SI)
             SHIFT-OR-BUF-CNTL
             (C AN ZERO OP0 OP1 OP2 OP3))
      (LIST 'MUX
            (INDICES 'OUT 0 (TREE-SIZE TREE))
            (INDEX 'TV-IF (TREE-NUMBER TREE))
            (CONS 'CTL
                  (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                          (V-SHIFT-RIGHT-NAMES (INDICES 'A 0 (TREE-SIZE TREE))
                                               'SI)))))
     '(NIL))))))

(PROVE-LEMMA TV-SHIFT-OR-BUF*$DESTRUCTURE
 (REWRITE)
 (AND
  (EQUAL (CAR (TV-SHIFT-OR-BUF* TREE))
         (INDEX 'TV-SHIFT-OR-BUF
                (TREE-NUMBER TREE)))
  (EQUAL (CADR (TV-SHIFT-OR-BUF* TREE))
         (CONS 'C
               (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                       '(AN ZERO OP0 OP1 OP2 OP3))))
  (EQUAL (CADDR (TV-SHIFT-OR-BUF* TREE))
         (INDICES 'OUT 0 (TREE-SIZE TREE)))
  (EQUAL
   (CADDDR (TV-SHIFT-OR-BUF* TREE))
   (LIST
      '(CNTL (CTL SI)
             SHIFT-OR-BUF-CNTL
             (C AN ZERO OP0 OP1 OP2 OP3))
      (LIST 'MUX
            (INDICES 'OUT 0 (TREE-SIZE TREE))
            (INDEX 'TV-IF (TREE-NUMBER TREE))
            (CONS 'CTL
                  (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                          (V-SHIFT-RIGHT-NAMES (INDICES 'A 0 (TREE-SIZE TREE))
                                               'SI))))))
  (EQUAL (CADDDDR (TV-SHIFT-OR-BUF* TREE))
         NIL)))

(TOGGLE TV-SHIFT-OR-BUF*-OFF TV-SHIFT-OR-BUF* T)

(TOGGLE TV-SHIFT-OR-BUF*$DESTRUCTURE-OFF TV-SHIFT-OR-BUF*$DESTRUCTURE T)

(DEFN TV-SHIFT-OR-BUF&
      (NETLIST TREE)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TV-SHIFT-OR-BUF
                                        (TREE-NUMBER TREE))
                                 NETLIST)
                  (TV-SHIFT-OR-BUF* TREE))
           (SHIFT-OR-BUF-CNTL& (DELETE-MODULE (INDEX 'TV-SHIFT-OR-BUF
                                                     (TREE-NUMBER TREE))
                                              NETLIST))
           (TV-IF& (DELETE-MODULE (INDEX 'TV-SHIFT-OR-BUF
                                         (TREE-NUMBER TREE))
                                  NETLIST)
                   TREE)))

(TOGGLE TV-SHIFT-OR-BUF&-OFF TV-SHIFT-OR-BUF& T)

(DEFN TV-SHIFT-OR-BUF$NETLIST
      (TREE)
      (CONS (TV-SHIFT-OR-BUF* TREE)
            (UNION (TV-IF$NETLIST TREE)
                   (SHIFT-OR-BUF-CNTL$NETLIST))))

(PROVE-LEMMA TV-SHIFT-OR-BUF$VALUE
      (REWRITE)
      (IMPLIES (AND (TV-SHIFT-OR-BUF& NETLIST TREE)
                    (EQUAL (LENGTH A) (TREE-SIZE TREE))
                    (PROPERP A))
               (EQUAL (DUAL-EVAL 0
                                 (INDEX 'TV-SHIFT-OR-BUF
                                        (TREE-NUMBER TREE))
                                 (CONS C
                                       (APPEND A
                                               (LIST AN ZERO OP0 OP1 OP2 OP3)))
                                 STATE NETLIST)
                      (F$SHIFT-OR-BUF C A AN ZERO OP0 OP1 OP2 OP3)))
      ((ENABLE F$SHIFT-OR-BUF TV-SHIFT-OR-BUF& SHIFT-OR-BUF-CNTL$VALUE
               TV-IF$VALUE TV-SHIFT-OR-BUF*$DESTRUCTURE FV-IF-REWRITE)
       (DISABLE-THEORY F-GATES)
       (DISABLE FV-SHIFT-RIGHT V-SHIFT-RIGHT-NAMES)))

(TOGGLE TV-SHIFT-OR-BUF$VALUE-OFF TV-SHIFT-OR-BUF$VALUE T)

(PROVE-LEMMA TV-SHIFT-OR-BUF$VALUE-ZERO
         (REWRITE)
         (IMPLIES (AND (TV-SHIFT-OR-BUF& NETLIST TREE)
                       (EQUAL (LENGTH A) (TREE-SIZE TREE))
                       (BVP A))
                  (EQUAL (DUAL-EVAL 0
                                    (INDEX 'TV-SHIFT-OR-BUF
                                           (TREE-NUMBER TREE))
                                    (CONS C
                                          (APPEND A
                                                  (LIST AN T OP0 OP1 OP2 OP3)))
                                    STATE NETLIST)
                         A))
         ((ENABLE TV-SHIFT-OR-BUF& TV-IF$VALUE TV-SHIFT-OR-BUF*$DESTRUCTURE
                  SHIFT-OR-BUF-CNTL$VALUE-ZERO)
          (DISABLE-THEORY F-GATES B-GATES)
          (DISABLE V-SHIFT-RIGHT V-SHIFT-RIGHT-NAMES)))

(TOGGLE TV-SHIFT-OR-BUF$VALUE-ZERO-OFF TV-SHIFT-OR-BUF$VALUE-ZERO T)

(DEFN F$CORE-ALU
 (C A B ZERO MPG OP TREE)
 (CONS
  (F$CARRY-OUT-HELP (NTH 0 A)
                    (F$T-CARRY C
                               (CAR (F$TV-ALU-HELP C A B MPG TREE))
                               (CADR (F$TV-ALU-HELP C A B MPG TREE)))
                    ZERO
                    (CAR OP)
                    (CADR OP)
                    (CADDR OP)
                    (CADDDR OP))
  (CONS
       (F$OVERFLOW-HELP (NTH (SUB1 (LENGTH A))
                             (CDDR (F$TV-ALU-HELP C A B MPG TREE)))
                        (NTH (SUB1 (LENGTH A)) A)
                        (NTH (SUB1 (LENGTH A)) B)
                        ZERO
                        (CAR OP)
                        (CADR OP)
                        (CADDR OP)
                        (CADDDR OP))
       (CONS (F$FAST-ZERO (F$SHIFT-OR-BUF C
                                          (CDDR (F$TV-ALU-HELP C A B MPG TREE))
                                          (NTH (SUB1 (LENGTH A)) A)
                                          ZERO
                                          (CAR OP)
                                          (CADR OP)
                                          (CADDR OP)
                                          (CADDDR OP)))
             (F$SHIFT-OR-BUF C
                             (CDDR (F$TV-ALU-HELP C A B MPG TREE))
                             (NTH (SUB1 (LENGTH A)) A)
                             ZERO
                             (CAR OP)
                             (CADR OP)
                             (CADDR OP)
                             (CADDDR OP))))))

(TOGGLE F$CORE-ALU-OFF F$CORE-ALU T)

(DEFN CORE-ALU
   (C A B ZERO MPG OP TREE)
   (CONS (CARRY-OUT-HELP (NTH 0 A)
                         (T-CARRY C
                                  (CAR (TV-ALU-HELP C A B MPG TREE))
                                  (CADR (TV-ALU-HELP C A B MPG TREE)))
                         ZERO
                         (CAR OP)
                         (CADR OP)
                         (CADDR OP)
                         (CADDDR OP))
         (CONS (OVERFLOW-HELP (NTH (SUB1 (LENGTH A))
                                   (CDDR (TV-ALU-HELP C A B MPG TREE)))
                              (NTH (SUB1 (LENGTH A)) A)
                              (NTH (SUB1 (LENGTH A)) B)
                              ZERO
                              (CAR OP)
                              (CADR OP)
                              (CADDR OP)
                              (CADDDR OP))
               (CONS (V-ZEROP (SHIFT-OR-BUF C
                                            (CDDR (TV-ALU-HELP C A B MPG TREE))
                                            (NTH (SUB1 (LENGTH A)) A)
                                            ZERO
                                            (CAR OP)
                                            (CADR OP)
                                            (CADDR OP)
                                            (CADDDR OP)))
                     (SHIFT-OR-BUF C
                                   (CDDR (TV-ALU-HELP C A B MPG TREE))
                                   (NTH (SUB1 (LENGTH A)) A)
                                   ZERO
                                   (CAR OP)
                                   (CADR OP)
                                   (CADDR OP)
                                   (CADDDR OP))))))

(TOGGLE CORE-ALU-OFF CORE-ALU T)

(PROVE-LEMMA PROPERP-LENGTH-F$CORE-ALU
             (REWRITE)
             (AND (PROPERP (F$CORE-ALU C A B ZERO MPG OP TREE))
                  (EQUAL (LENGTH (F$CORE-ALU C A B ZERO MPG OP TREE))
                         (ADD1 (ADD1 (ADD1 (TREE-SIZE TREE))))))
             ((ENABLE F$CORE-ALU)))

(PROVE-LEMMA F$CORE-ALU=CORE-ALU
             (REWRITE)
             (IMPLIES (AND (BOOLP C)
                           (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (BVP B)
                           (EQUAL (LENGTH B) (TREE-SIZE TREE))
                           (IF (LESSP (LENGTH A) 3) F T)
                           (BOOLP ZERO)
                           (BVP MPG)
                           (EQUAL (LENGTH MPG) 7)
                           (BVP OP)
                           (EQUAL (LENGTH OP) 4))
                      (EQUAL (F$CORE-ALU C A B ZERO MPG OP TREE)
                             (CORE-ALU C A B ZERO MPG OP TREE)))
             ((ENABLE CORE-ALU F$CORE-ALU BVP-LENGTH)))

(PROVE-LEMMA LENGTH-CORE-ALU
             (REWRITE)
             (EQUAL (LENGTH (CORE-ALU C A B ZERO MPG OP TREE))
                    (ADD1 (ADD1 (ADD1 (TREE-SIZE TREE)))))
             ((ENABLE CORE-ALU)))

(PROVE-LEMMA BOOLP-BVP-CORE-ALU
             (REWRITE)
             (AND (BOOLP (C (CORE-ALU C A B ZERO MPG OP TREE)))
                  (BOOLP (V (CORE-ALU C A B ZERO MPG OP TREE)))
                  (BOOLP (ZB (CORE-ALU C A B ZERO MPG OP TREE)))
                  (BVP (BV (CORE-ALU C A B ZERO MPG OP TREE)))
                  (BVP (CORE-ALU C A B ZERO MPG OP TREE)))
             ((ENABLE CORE-ALU BVP C V ZB BV)
              (DISABLE CARRY-IN-HELP CARRY-OUT-HELP OVERFLOW-HELP
                       SHIFT-OR-BUF V-ZEROP)))

(PROVE-LEMMA CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES$CROCK
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           (NTH 0 A))
                      (EQUAL (NTH 0 A) T))
             ((ENABLE OPEN-NTH BVP)))

(TOGGLE CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES$CROCK-OFF
        CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES$CROCK T)

(PROVE-LEMMA CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES
             (REWRITE)
             (AND (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F F F F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F F F F))
                                            A B F
                                            (MPG (LIST F F F F F F))
                                            (LIST F F F F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T F F F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T F F F))
                                            A B F
                                            (MPG (LIST F F T F F F))
                                            (LIST T F F F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F T F F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F T F F))
                                            A B F
                                            (MPG (LIST F F F T F F))
                                            (LIST F T F F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T T F F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T T F F))
                                            A B F
                                            (MPG (LIST F F T T F F))
                                            (LIST T T F F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F F T F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F F T F))
                                            A B F
                                            (MPG (LIST F F F F T F))
                                            (LIST F F T F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T F T F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T F T F))
                                            A B F
                                            (MPG (LIST F F T F T F))
                                            (LIST T F T F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F T T F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F T T F))
                                            A B F
                                            (MPG (LIST F F F T T F))
                                            (LIST F T T F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T T T F))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T T T F))
                                            A B F
                                            (MPG (LIST F F T T T F))
                                            (LIST T T T F)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F F F T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F F F T))
                                            A B F
                                            (MPG (LIST F F F F F T))
                                            (LIST F F F T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T F F T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T F F T))
                                            A B F
                                            (MPG (LIST F F T F F T))
                                            (LIST T F F T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F T F T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F T F T))
                                            A B F
                                            (MPG (LIST F F F T F T))
                                            (LIST F T F T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T T F T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T T F T))
                                            A B F
                                            (MPG (LIST F F T T F T))
                                            (LIST T T F T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F F T T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F F T T))
                                            A B F
                                            (MPG (LIST F F F F T T))
                                            (LIST F F T T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T F T T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T F T T))
                                            A B F
                                            (MPG (LIST F F T F T T))
                                            (LIST T F T T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST F T T T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F F T T T))
                                            A B F
                                            (MPG (LIST F F F T T T))
                                            (LIST F T T T)
                                            TREE)))
                  (IMPLIES (AND (BV2P A B)
                                (EQUAL (LENGTH A) (TREE-SIZE TREE))
                                (BOOLP C))
                           (EQUAL (V-ALU C A B (LIST T T T T))
                                  (CORE-ALU (CARRY-IN-HELP (LIST C F T T T T))
                                            A B F
                                            (MPG (LIST F F T T T T))
                                            (LIST T T T T)
                                            TREE))))
             ((DISABLE T-CARRY TV-ALU-HELP)
              (ENABLE CORE-ALU V-ALU BOOLP MPG CARRY-IN-HELP
                      TV-ALU-HELP-TV-NEG-WORKS TV-ALU-HELP-V-AND-WORKS
                      TV-ALU-HELP-V-OR-WORKS TV-ALU-HELP-V-XOR-WORKS
                      TV-ALU-HELP-V-NOT-WORKS TV-ALU-HELP-V-BUF-WORKS
                      TV-ALU-HELP-TV-ADDER-WORKS
                      TV-ALU-HELP-TV-SUBTRACTER-WORKS
                      TV-ALU-HELP-TV-INC-A-WORKS TV-ALU-HELP-TV-DEC-A-WORKS
                      TV-ALU-HELP-TV-NEG-WORKS TV-ADDER-AS-P-G-SUM
                      CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES$CROCK)))

(TOGGLE CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES-OFF
        CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES T)

(PROVE-LEMMA CASES-ON-A-4-BIT-BVP NIL
             (IMPLIES (AND (BVP OP)
                           (EQUAL (LENGTH OP) 4)
                           (COND ((EQUAL OP (LIST F F F F)) P)
                                 ((EQUAL OP (LIST T F F F)) P)
                                 ((EQUAL OP (LIST F T F F)) P)
                                 ((EQUAL OP (LIST T T F F)) P)
                                 ((EQUAL OP (LIST F F T F)) P)
                                 ((EQUAL OP (LIST T F T F)) P)
                                 ((EQUAL OP (LIST F T T F)) P)
                                 ((EQUAL OP (LIST T T T F)) P)
                                 ((EQUAL OP (LIST F F F T)) P)
                                 ((EQUAL OP (LIST T F F T)) P)
                                 ((EQUAL OP (LIST F T F T)) P)
                                 ((EQUAL OP (LIST T T F T)) P)
                                 ((EQUAL OP (LIST F F T T)) P)
                                 ((EQUAL OP (LIST T F T T)) P)
                                 ((EQUAL OP (LIST F T T T)) P)
                                 ((EQUAL OP (LIST T T T T)) P)
                                 (T T)))
                      P)
             ((ENABLE EQUAL-LENGTH-ADD1)))

(PROVE-LEMMA CORE-ALU-IS-V-ALU
 (REWRITE)
 (IMPLIES (AND (BV2P A B)
               (EQUAL (LENGTH A) (TREE-SIZE TREE))
               (BVP OP)
               (EQUAL (LENGTH OP) 4)
               (NOT ZERO)
               (EQUAL MPG
                      (MPG (CONS ZERO (CONS F OP))))
               (BOOLP C))
          (EQUAL (CORE-ALU (CARRY-IN-HELP (CONS C (CONS F OP)))
                           A B ZERO MPG OP TREE)
                 (V-ALU C A B OP)))
 ((USE
   (CASES-ON-A-4-BIT-BVP
                       (P (EQUAL (CORE-ALU (CARRY-IN-HELP (CONS C (CONS F OP)))
                                           A B ZERO MPG OP TREE)
                                 (V-ALU C A B OP)))))
  (DISABLE BOOLP-LEMMAS BV2P BVP LENGTH CORE-ALU V-ALU TREE-SIZE MPG *1*MPG)
  (ENABLE CORE-ALU-WORKS-FOR-ALL-NORMAL-CASES)))

(PROVE-LEMMA CORE-ALU-WORKS-FOR-ZERO-CASE
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH A) (TREE-SIZE TREE))
                           ZERO)
                      (EQUAL (CORE-ALU T A B ZERO
                                       (LIST F F F F F F T)
                                       OP TREE)
                             (CVZBV F F (MAKE-LIST (LENGTH A) F))))
             ((ENABLE CORE-ALU TV-ALU-HELP-ZERO)))

(PROVE-LEMMA CORE-ALU-WORKS-AS-INC-B
 (REWRITE)
 (IMPLIES
         (AND (BV2P A B)
              (EQUAL (LENGTH A) (TREE-SIZE TREE))
              (NOT ZERO)
              SWAP)
         (EQUAL (BV (CORE-ALU (CARRY-IN-HELP (CONS C (CONS ZERO (ALU-INC-OP))))
                              A B ZERO
                              (MPG (CONS ZERO (CONS SWAP (ALU-INC-OP))))
                              (ALU-INC-OP)
                              TREE))
                (V-INC B)))
 ((DISABLE TV-ALU-HELP)
  (ENABLE ALU-INC-OP V-INC BV CORE-ALU MPG CARRY-IN-HELP
          TV-ALU-HELP-TV-INC-B-WORKS TV-ADDER-AS-P-G-SUM)))

(PROVE-LEMMA CORE-ALU-WORKS-AS-DEC-B
 (REWRITE)
 (IMPLIES
         (AND (BV2P A B)
              (EQUAL (LENGTH A) (TREE-SIZE TREE))
              (NOT ZERO)
              SWAP)
         (EQUAL (BV (CORE-ALU (CARRY-IN-HELP (CONS C (CONS ZERO (ALU-DEC-OP))))
                              A B ZERO
                              (MPG (CONS ZERO (CONS SWAP (ALU-DEC-OP))))
                              (ALU-DEC-OP)
                              TREE))
                (V-DEC B)))
 ((DISABLE TV-ALU-HELP)
  (ENABLE ALU-DEC-OP V-DEC BV CORE-ALU MPG CARRY-IN-HELP
          TV-ALU-HELP-TV-DEC-B-WORKS TV-ADDER-AS-P-G-SUM)))

(DEFN CORE-ALU*
 (TREE)
 (CONS
  (INDEX 'CORE-ALU (TREE-NUMBER TREE))
  (CONS
   (CONS 'C
         (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                 (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                         (CONS 'ZERO
                               (APPEND (INDICES 'MPG 0 7)
                                       (INDICES 'OP 0 4))))))
   (CONS
      (CONS 'CARRY
            (CONS 'OVERFLOW
                  (CONS 'ZEROP
                        (INDICES 'OUT 0 (TREE-SIZE TREE)))))
      (CONS (LIST (LIST 'M-ALU
                        (CONS 'P
                              (CONS 'G
                                    (INDICES 'ALU-OUT
                                             0
                                             (TREE-SIZE TREE))))
                        (INDEX 'TV-ALU-HELP
                               (TREE-NUMBER TREE))
                        (CONS 'C
                              (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                      (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                                              (INDICES 'MPG 0 7)))))
                  '(M-ALU-CARRY (ALU-CARRY)
                                T-CARRY
                                (C P G))
                  (LIST 'M-CARRY-OUT-HELP
                        '(CARRY)
                        'CARRY-OUT-HELP
                        (LIST (INDEX 'A 0)
                              'ALU-CARRY
                              'ZERO
                              (INDEX 'OP 0)
                              (INDEX 'OP 1)
                              (INDEX 'OP 2)
                              (INDEX 'OP 3)))
                  (LIST 'M-OVERFLOW-HELP
                        '(OVERFLOW)
                        'OVERFLOW-HELP
                        (LIST (INDEX 'ALU-OUT
                                     (SUB1 (TREE-SIZE TREE)))
                              (INDEX 'A (SUB1 (TREE-SIZE TREE)))
                              (INDEX 'B (SUB1 (TREE-SIZE TREE)))
                              'ZERO
                              (INDEX 'OP 0)
                              (INDEX 'OP 1)
                              (INDEX 'OP 2)
                              (INDEX 'OP 3)))
                  (LIST 'M-SHIFT
                        (INDICES 'OUT 0 (TREE-SIZE TREE))
                        (INDEX 'TV-SHIFT-OR-BUF
                               (TREE-NUMBER TREE))
                        (CONS 'C
                              (APPEND (INDICES 'ALU-OUT 0 (TREE-SIZE TREE))
                                      (LIST (INDEX 'A (SUB1 (TREE-SIZE TREE)))
                                            'ZERO
                                            (INDEX 'OP 0)
                                            (INDEX 'OP 1)
                                            (INDEX 'OP 2)
                                            (INDEX 'OP 3)))))
                  (LIST 'M-ZEROP
                        '(ZEROP)
                        (INDEX 'FAST-ZERO (TREE-SIZE TREE))
                        (INDICES 'OUT 0 (TREE-SIZE TREE))))
            '(NIL))))))

(PROVE-LEMMA CORE-ALU*$DESTRUCTURE
 (REWRITE)
 (AND
     (EQUAL (CAR (CORE-ALU* TREE))
            (INDEX 'CORE-ALU (TREE-NUMBER TREE)))
     (EQUAL (CADR (CORE-ALU* TREE))
            (CONS 'C
                  (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                          (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                                  (CONS 'ZERO
                                        (APPEND (INDICES 'MPG 0 7)
                                                (INDICES 'OP 0 4)))))))
     (EQUAL (CADDR (CORE-ALU* TREE))
            (CONS 'CARRY
                  (CONS 'OVERFLOW
                        (CONS 'ZEROP
                              (INDICES 'OUT 0 (TREE-SIZE TREE))))))
     (EQUAL (CADDDR (CORE-ALU* TREE))
            (LIST (LIST 'M-ALU
                        (CONS 'P
                              (CONS 'G
                                    (INDICES 'ALU-OUT
                                             0
                                             (TREE-SIZE TREE))))
                        (INDEX 'TV-ALU-HELP
                               (TREE-NUMBER TREE))
                        (CONS 'C
                              (APPEND (INDICES 'A 0 (TREE-SIZE TREE))
                                      (APPEND (INDICES 'B 0 (TREE-SIZE TREE))
                                              (INDICES 'MPG 0 7)))))
                  '(M-ALU-CARRY (ALU-CARRY)
                                T-CARRY
                                (C P G))
                  (LIST 'M-CARRY-OUT-HELP
                        '(CARRY)
                        'CARRY-OUT-HELP
                        (LIST (INDEX 'A 0)
                              'ALU-CARRY
                              'ZERO
                              (INDEX 'OP 0)
                              (INDEX 'OP 1)
                              (INDEX 'OP 2)
                              (INDEX 'OP 3)))
                  (LIST 'M-OVERFLOW-HELP
                        '(OVERFLOW)
                        'OVERFLOW-HELP
                        (LIST (INDEX 'ALU-OUT
                                     (SUB1 (TREE-SIZE TREE)))
                              (INDEX 'A (SUB1 (TREE-SIZE TREE)))
                              (INDEX 'B (SUB1 (TREE-SIZE TREE)))
                              'ZERO
                              (INDEX 'OP 0)
                              (INDEX 'OP 1)
                              (INDEX 'OP 2)
                              (INDEX 'OP 3)))
                  (LIST 'M-SHIFT
                        (INDICES 'OUT 0 (TREE-SIZE TREE))
                        (INDEX 'TV-SHIFT-OR-BUF
                               (TREE-NUMBER TREE))
                        (CONS 'C
                              (APPEND (INDICES 'ALU-OUT 0 (TREE-SIZE TREE))
                                      (LIST (INDEX 'A (SUB1 (TREE-SIZE TREE)))
                                            'ZERO
                                            (INDEX 'OP 0)
                                            (INDEX 'OP 1)
                                            (INDEX 'OP 2)
                                            (INDEX 'OP 3)))))
                  (LIST 'M-ZEROP
                        '(ZEROP)
                        (INDEX 'FAST-ZERO (TREE-SIZE TREE))
                        (INDICES 'OUT 0 (TREE-SIZE TREE)))))
     (EQUAL (CADDDDR (CORE-ALU* TREE))
            NIL)))

(TOGGLE CORE-ALU*-OFF CORE-ALU* T)

(TOGGLE CORE-ALU*$DESTRUCTURE-OFF CORE-ALU*$DESTRUCTURE T)

(DEFN CORE-ALU&
    (NETLIST TREE)
    (AND (EQUAL (LOOKUP-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                               NETLIST)
                (CORE-ALU* TREE))
         (TV-ALU-HELP& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                      NETLIST)
                       TREE)
         (T-CARRY& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                  NETLIST))
         (CARRY-OUT-HELP& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                         NETLIST))
         (OVERFLOW-HELP& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                        NETLIST))
         (TV-SHIFT-OR-BUF& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                          NETLIST)
                           TREE)
         (FAST-ZERO& (DELETE-MODULE (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                                    NETLIST)
                     (TREE-SIZE TREE))))

(TOGGLE CORE-ALU&-OFF CORE-ALU& T)

(DEFN CORE-ALU$NETLIST
 (TREE)
 (CONS
  (CORE-ALU* TREE)
  (UNION
        (TV-ALU-HELP$NETLIST TREE)
        (UNION (T-CARRY$NETLIST)
               (UNION (CARRY-OUT-HELP$NETLIST)
                      (UNION (OVERFLOW-HELP$NETLIST)
                             (UNION (TV-SHIFT-OR-BUF$NETLIST TREE)
                                    (FAST-ZERO$NETLIST (TREE-SIZE TREE)))))))))

(PROVE-LEMMA CORE-ALU$VALUE
 (REWRITE)
 (IMPLIES
         (AND (CORE-ALU& NETLIST TREE)
              (EQUAL (LENGTH A) (TREE-SIZE TREE))
              (EQUAL (LENGTH B) (TREE-SIZE TREE))
              (IF (LESSP (LENGTH A) 3) F T)
              (PROPERP A)
              (PROPERP B)
              (PROPERP OP)
              (EQUAL (LENGTH OP) 4)
              (PROPERP MPG)
              (EQUAL (LENGTH MPG) 7))
         (EQUAL (DUAL-EVAL 0
                           (INDEX 'CORE-ALU (TREE-NUMBER TREE))
                           (CONS C
                                 (APPEND A
                                         (APPEND B
                                                 (CONS ZERO (APPEND MPG OP)))))
                           STATE NETLIST)
                (F$CORE-ALU C A B ZERO MPG OP TREE)))
 ((ENABLE F$CORE-ALU CORE-ALU& TV-SHIFT-OR-BUF$VALUE CORE-ALU*$DESTRUCTURE
          TV-ALU-HELP$VALUE T-CARRY$VALUE CARRY-OUT-HELP$VALUE
          OVERFLOW-HELP$VALUE FAST-ZERO$VALUE OPEN-NTH)
  (DISABLE *1*INDICES OPEN-INDICES INDICES)))

(TOGGLE CORE-ALU$VALUE-OFF CORE-ALU$VALUE T)

(DEFN REG-SIZE NIL 4)

(DEFN A-IMMEDIATE-P
      (INSTRUCTION)
      (NTH 9 INSTRUCTION))

(DEFN A-IMMEDIATE
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 0 8))

(DEFN RN-A
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 0 3))

(DEFN MODE-A
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 4 5))

(DEFN RN-B
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 10 13))

(DEFN MODE-B
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 14 15))

(DEFN SET-FLAGS
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 16 19))

(DEFN STORE-CC
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 20 23))

(DEFN OP-CODE
      (INSTRUCTION)
      (SUBRANGE INSTRUCTION 24 27))

(TOGGLE A-IMMEDIATE-P-OFF A-IMMEDIATE-P T)

(TOGGLE A-IMMEDIATE-OFF A-IMMEDIATE T)

(TOGGLE RN-A-OFF RN-A T)

(TOGGLE RN-B-OFF RN-B T)

(TOGGLE MODE-A-OFF MODE-A T)

(TOGGLE MODE-B-OFF MODE-B T)

(TOGGLE SET-FLAGS-OFF SET-FLAGS T)

(TOGGLE STORE-CC-OFF STORE-CC T)

(TOGGLE OP-CODE-OFF OP-CODE T)

(DEFTHEORY IR-FIELDS-THEORY
           (A-IMMEDIATE-P A-IMMEDIATE RN-A MODE-A RN-B MODE-B SET-FLAGS
                          STORE-CC OP-CODE))

(DEFN Z-SET
      (SET-FLAGS)
      (NTH 0 SET-FLAGS))

(DEFN N-SET
      (SET-FLAGS)
      (NTH 1 SET-FLAGS))

(DEFN V-SET
      (SET-FLAGS)
      (NTH 2 SET-FLAGS))

(DEFN C-SET
      (SET-FLAGS)
      (NTH 3 SET-FLAGS))

(TOGGLE Z-SET-OFF Z-SET T)

(TOGGLE N-SET-OFF N-SET T)

(TOGGLE V-SET-OFF V-SET T)

(TOGGLE C-SET-OFF C-SET T)

(DEFTHEORY SET-FLAGS-THEORY
           (Z-SET N-SET V-SET C-SET))

(DEFN Z-FLAG (FLAGS) (NTH 0 FLAGS))

(DEFN N-FLAG (FLAGS) (NTH 1 FLAGS))

(DEFN V-FLAG (FLAGS) (NTH 2 FLAGS))

(DEFN C-FLAG (FLAGS) (NTH 3 FLAGS))

(TOGGLE Z-FLAG-OFF Z-FLAG T)

(TOGGLE N-FLAG-OFF N-FLAG T)

(TOGGLE V-FLAG-OFF V-FLAG T)

(TOGGLE C-FLAG-OFF C-FLAG T)

(DEFTHEORY FLAGS-THEORY
           (Z-FLAG N-FLAG V-FLAG C-FLAG))

(DEFN REG-DIRECT-P
      (MODE)
      (EQUAL MODE (LIST F F)))

(DEFN REG-INDIRECT-P
      (MODE)
      (EQUAL MODE (LIST T F)))

(DEFN PRE-DEC-P
      (MODE)
      (EQUAL MODE (LIST F T)))

(DEFN POST-INC-P
      (MODE)
      (EQUAL MODE (LIST T T)))

(TOGGLE REG-DIRECT-P-OFF REG-DIRECT-P T)

(TOGGLE REG-INDIRECT-P-OFF REG-INDIRECT-P T)

(TOGGLE PRE-DEC-P-OFF PRE-DEC-P T)

(TOGGLE POST-INC-P-OFF POST-INC-P T)

(DEFTHEORY REG-MODE-THEORY
           (REG-DIRECT-P REG-INDIRECT-P PRE-DEC-P POST-INC-P))

(DEFN STORE-RESULTP
      (STORE-CC FLAGS)
      (COND ((EQUAL STORE-CC (LIST F F F F))
             (NOT (C-FLAG FLAGS)))
            ((EQUAL STORE-CC (LIST T F F F))
             (C-FLAG FLAGS))
            ((EQUAL STORE-CC (LIST F T F F))
             (NOT (V-FLAG FLAGS)))
            ((EQUAL STORE-CC (LIST T T F F))
             (V-FLAG FLAGS))
            ((EQUAL STORE-CC (LIST F F T F))
             (NOT (N-FLAG FLAGS)))
            ((EQUAL STORE-CC (LIST T F T F))
             (N-FLAG FLAGS))
            ((EQUAL STORE-CC (LIST F T T F))
             (NOT (Z-FLAG FLAGS)))
            ((EQUAL STORE-CC (LIST T T T F))
             (Z-FLAG FLAGS))
            ((EQUAL STORE-CC (LIST F F F T))
             (AND (NOT (C-FLAG FLAGS))
                  (NOT (Z-FLAG FLAGS))))
            ((EQUAL STORE-CC (LIST T F F T))
             (OR (C-FLAG FLAGS) (Z-FLAG FLAGS)))
            ((EQUAL STORE-CC (LIST F T F T))
             (OR (AND (N-FLAG FLAGS) (V-FLAG FLAGS))
                 (AND (NOT (N-FLAG FLAGS))
                      (NOT (V-FLAG FLAGS)))))
            ((EQUAL STORE-CC (LIST T T F T))
             (OR (AND (N-FLAG FLAGS)
                      (NOT (V-FLAG FLAGS)))
                 (AND (NOT (N-FLAG FLAGS))
                      (V-FLAG FLAGS))))
            ((EQUAL STORE-CC (LIST F F T T))
             (OR (AND (N-FLAG FLAGS)
                      (V-FLAG FLAGS)
                      (NOT (Z-FLAG FLAGS)))
                 (AND (NOT (N-FLAG FLAGS))
                      (NOT (V-FLAG FLAGS))
                      (NOT (Z-FLAG FLAGS)))))
            ((EQUAL STORE-CC (LIST T F T T))
             (OR (Z-FLAG FLAGS)
                 (AND (N-FLAG FLAGS)
                      (NOT (V-FLAG FLAGS)))
                 (AND (NOT (N-FLAG FLAGS))
                      (V-FLAG FLAGS))))
            ((EQUAL STORE-CC (LIST F T T T)) T)
            (T F)))

(TOGGLE STORE-RESULTP-OFF STORE-RESULTP T)

(DEFN UPDATE-FLAGS
      (FLAGS SET-FLAGS CVZBV)
      (LIST (B-IF (Z-SET SET-FLAGS)
                  (ZB CVZBV)
                  (Z-FLAG FLAGS))
            (B-IF (N-SET SET-FLAGS)
                  (N CVZBV)
                  (N-FLAG FLAGS))
            (B-IF (V-SET SET-FLAGS)
                  (V CVZBV)
                  (V-FLAG FLAGS))
            (B-IF (C-SET SET-FLAGS)
                  (C CVZBV)
                  (C-FLAG FLAGS))))

(TOGGLE UPDATE-FLAGS-OFF UPDATE-FLAGS T)

(DEFN REGS (STATE) (NTH 0 STATE))

(DEFN FLAGS (STATE) (NTH 1 STATE))

(TOGGLE REGS-OFF REGS T)

(TOGGLE FLAGS-OFF FLAGS T)

(DEFN FM9001-ALU-OPERATION
      (REGS FLAGS MEM INS OPERAND-A OPERAND-B B-ADDRESS)
      (LIST (LIST (IF (AND (STORE-RESULTP (STORE-CC INS) FLAGS)
                           (REG-DIRECT-P (MODE-B INS)))
                      (WRITE-MEM (RN-B INS)
                                 REGS
                                 (BV (V-ALU (C-FLAG FLAGS)
                                            OPERAND-A OPERAND-B
                                            (OP-CODE INS))))
                      REGS)
                  (UPDATE-FLAGS FLAGS
                                (SET-FLAGS INS)
                                (V-ALU (C-FLAG FLAGS)
                                       OPERAND-A OPERAND-B
                                       (OP-CODE INS))))
            (IF (AND (STORE-RESULTP (STORE-CC INS) FLAGS)
                     (NOT (REG-DIRECT-P (MODE-B INS))))
                (WRITE-MEM B-ADDRESS MEM
                           (BV (V-ALU (C-FLAG FLAGS)
                                      OPERAND-A OPERAND-B
                                      (OP-CODE INS))))
                MEM)))

(DEFN FM9001-OPERAND-B
   (REGS FLAGS MEM INS OPERAND-A)
   (FM9001-ALU-OPERATION (COND ((PRE-DEC-P (MODE-B INS))
                                (WRITE-MEM (RN-B INS)
                                           REGS
                                           (V-DEC (READ-MEM (RN-B INS) REGS))))
                               ((POST-INC-P (MODE-B INS))
                                (WRITE-MEM (RN-B INS)
                                           REGS
                                           (V-INC (READ-MEM (RN-B INS) REGS))))
                               (T REGS))
                         FLAGS MEM INS OPERAND-A
                         (IF (REG-DIRECT-P (MODE-B INS))
                             (READ-MEM (RN-B INS) REGS)
                             (READ-MEM (IF (PRE-DEC-P (MODE-B INS))
                                           (V-DEC (READ-MEM (RN-B INS) REGS))
                                           (READ-MEM (RN-B INS) REGS))
                                       MEM))
                         (IF (PRE-DEC-P (MODE-B INS))
                             (V-DEC (READ-MEM (RN-B INS) REGS))
                             (READ-MEM (RN-B INS) REGS))))

(DEFN FM9001-OPERAND-A
      (REGS FLAGS MEM INS)
      (FM9001-OPERAND-B (COND ((A-IMMEDIATE-P INS) REGS)
                              ((PRE-DEC-P (MODE-A INS))
                               (WRITE-MEM (RN-A INS)
                                          REGS
                                          (V-DEC (READ-MEM (RN-A INS) REGS))))
                              ((POST-INC-P (MODE-A INS))
                               (WRITE-MEM (RN-A INS)
                                          REGS
                                          (V-INC (READ-MEM (RN-A INS) REGS))))
                              (T REGS))
                        FLAGS MEM INS
                        (COND ((A-IMMEDIATE-P INS)
                               (SIGN-EXTEND (A-IMMEDIATE INS) 32))
                              ((REG-DIRECT-P (MODE-A INS))
                               (READ-MEM (RN-A INS) REGS))
                              ((PRE-DEC-P (MODE-A INS))
                               (READ-MEM (V-DEC (READ-MEM (RN-A INS) REGS))
                                         MEM))
                              (T (READ-MEM (READ-MEM (RN-A INS) REGS)
                                           MEM)))))

(DEFN FM9001-FETCH
      (REGS FLAGS MEM PC-REG)
      (FM9001-OPERAND-A (WRITE-MEM PC-REG REGS
                                   (V-INC (READ-MEM PC-REG REGS)))
                        FLAGS MEM
                        (READ-MEM (READ-MEM PC-REG REGS)
                                  MEM)))

(DEFN FM9001-STEP
      (STATE PC-REG)
      (FM9001-FETCH (REGS (CAR STATE))
                    (FLAGS (CAR STATE))
                    (CADR STATE)
                    PC-REG))

(TOGGLE FM9001-STEP-OFF FM9001-STEP T)

(DEFN FM9001
      (STATE N)
      (IF (ZEROP N)
          STATE
          (FM9001 (FM9001-STEP STATE
                               (NAT-TO-V 15 (REG-SIZE)))
                  (SUB1 N))))

(TOGGLE FM9001-OFF FM9001 T)

(DEFN FM9001-INTERPRETER
      (STATE PC-REG N)
      (IF (ZEROP N)
          STATE
          (FM9001-INTERPRETER (FM9001-STEP STATE PC-REG)
                              PC-REG
                              (SUB1 N))))

(TOGGLE FM9001-INTERPRETER-OFF FM9001-INTERPRETER T)

(PROVE-LEMMA OPEN-FM9001-INTERPRETER
            (REWRITE)
            (AND (IMPLIES (ZEROP N)
                          (EQUAL (FM9001-INTERPRETER STATE PC-REG N)
                                 STATE))
                 (IMPLIES (NOT (ZEROP N))
                          (EQUAL (FM9001-INTERPRETER STATE PC-REG N)
                                 (FM9001-INTERPRETER (FM9001-STEP STATE PC-REG)
                                                     PC-REG
                                                     (SUB1 N)))))
            ((ENABLE FM9001-INTERPRETER)))

(DEFN FM9001-INTR
      (STATE PC-REG-INPUT)
      (IF (NLISTP PC-REG-INPUT)
          STATE
          (FM9001-INTR (FM9001-STEP STATE (CAR PC-REG-INPUT))
                       (CDR PC-REG-INPUT))))

(TOGGLE FM9001-INTR-OFF FM9001-INTR T)

(PROVE-LEMMA PROPERP-LENGTH-IR-ACCESSORS
             (REWRITE)
             (AND (PROPERP (A-IMMEDIATE I-REG))
                  (EQUAL (LENGTH (A-IMMEDIATE I-REG)) 9)
                  (PROPERP (RN-A I-REG))
                  (EQUAL (LENGTH (RN-A I-REG)) 4)
                  (PROPERP (MODE-A I-REG))
                  (EQUAL (LENGTH (MODE-A I-REG)) 2)
                  (PROPERP (RN-B I-REG))
                  (EQUAL (LENGTH (RN-B I-REG)) 4)
                  (PROPERP (MODE-B I-REG))
                  (EQUAL (LENGTH (MODE-B I-REG)) 2)
                  (PROPERP (SET-FLAGS I-REG))
                  (EQUAL (LENGTH (SET-FLAGS I-REG)) 4)
                  (PROPERP (STORE-CC I-REG))
                  (EQUAL (LENGTH (STORE-CC I-REG)) 4)
                  (PROPERP (OP-CODE I-REG))
                  (EQUAL (LENGTH (OP-CODE I-REG)) 4))
             ((ENABLE A-IMMEDIATE RN-A RN-B MODE-A MODE-B SET-FLAGS STORE-CC
                      OP-CODE)))

(PROVE-LEMMA BVP-IR-ACCESSORS
             (REWRITE)
             (IMPLIES (AND (BVP I-REG)
                           (EQUAL (LENGTH I-REG) 32))
                      (AND (BVP (A-IMMEDIATE I-REG))
                           (BVP (RN-A I-REG))
                           (BVP (MODE-A I-REG))
                           (BVP (RN-B I-REG))
                           (BVP (MODE-B I-REG))
                           (BVP (SET-FLAGS I-REG))
                           (BVP (STORE-CC I-REG))
                           (BVP (OP-CODE I-REG))))
             ((ENABLE A-IMMEDIATE RN-A RN-B MODE-A MODE-B SET-FLAGS STORE-CC
                      OP-CODE)))

(PROVE-LEMMA BOOLP-A-IMMEDIATE-P
             (REWRITE)
             (IMPLIES (AND (BVP IR) (EQUAL (LENGTH IR) 32))
                      (BOOLP (A-IMMEDIATE-P IR)))
             ((ENABLE A-IMMEDIATE-P)))

(PROVE-LEMMA BVP-LENGTH-UPDATE-FLAGS
             (REWRITE)
             (AND (BVP (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV))
                  (EQUAL (LENGTH (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV))
                         4))
             ((ENABLE BVP UPDATE-FLAGS LENGTH)))

(PROVE-LEMMA BOOLP-C-FLAG-UPDATE-FLAGS
             (REWRITE)
             (BOOLP (C-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
             ((ENABLE C-FLAG UPDATE-FLAGS)))

(PROVE-LEMMA BVP-A-IMMEDIATE
             (REWRITE)
             (IMPLIES (AND (BVP IR) (LESSP 8 (LENGTH IR)))
                      (BVP (A-IMMEDIATE IR)))
             ((ENABLE A-IMMEDIATE)))

(PROVE-LEMMA REG-DIRECT->NOT-REG-INDIRECT
             (REWRITE)
             (IMPLIES (REG-DIRECT-P MODE)
                      (AND (EQUAL (REG-INDIRECT-P MODE) F)
                           (EQUAL (PRE-DEC-P MODE) F)
                           (EQUAL (POST-INC-P MODE) F)))
             ((ENABLE-THEORY REG-MODE-THEORY)))

(PROVE-LEMMA BOOLP-STORE-RESULT-P
             (REWRITE)
             (IMPLIES (AND (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4))
                      (BOOLP (STORE-RESULTP STORE-CC FLAGS)))
             ((ENABLE STORE-RESULTP OPEN-NTH C-FLAG V-FLAG N-FLAG Z-FLAG)))

(PROVE-LEMMA UNARY-OP-CODE-P-OP-CODE->V-ALU=V-ALU-1
             (REWRITE)
             (IMPLIES (UNARY-OP-CODE-P (OP-CODE I-REG))
                      (EQUAL (V-ALU C A B (OP-CODE I-REG))
                             (V-ALU-1 C A (OP-CODE I-REG))))
             ((ENABLE UNARY-OP-CODE-P->V-ALU=V-ALU-1)))

(DEFN INTP
      (X)
      (OR (NUMBERP X) (NEGATIVEP X)))

(DEFN INT-TO-BV
      (X SIZE)
      (IF (NEGATIVEP X)
          (V-SUBTRACTER-OUTPUT F
                               (NAT-TO-V (NEGATIVE-GUTS X) SIZE)
                               (NAT-TO-V 0 SIZE))
          (NAT-TO-V X SIZE)))

(DEFN BV-TO-INT
      (X)
      (IF (NTH (SUB1 (LENGTH X)) X)
          (MINUS (V-TO-NAT (V-INC (V-NOT X))))
          (V-TO-NAT X)))

(DEFN C10-TF
      (X)
      (IF (NLISTP X)
          NIL
          (CONS (IF (EQUAL (CAR X) 0) F T)
                (C10-TF (CDR X)))))

(DEFN C10-INT
      (X)
      (BV-TO-INT (C10-TF X)))

(DEFN ADD
      (X Y)
      (COND ((NEGATIVEP X)
             (COND ((NEGATIVEP Y)
                    (MINUS (PLUS (NEGATIVE-GUTS X)
                                 (NEGATIVE-GUTS Y))))
                   ((LESSP Y (NEGATIVE-GUTS X))
                    (MINUS (DIFFERENCE (NEGATIVE-GUTS X) Y)))
                   (T (DIFFERENCE Y (NEGATIVE-GUTS X)))))
            ((NEGATIVEP Y)
             (IF (LESSP X (NEGATIVE-GUTS Y))
                 (MINUS (DIFFERENCE (NEGATIVE-GUTS Y) X))
                 (DIFFERENCE X (NEGATIVE-GUTS Y))))
            (T (PLUS X Y))))

(DEFN INTEGER-MINUS
      (X)
      (COND ((NEGATIVEP X) (NEGATIVE-GUTS X))
            ((ZEROP X) 0)
            (T (MINUS X))))

(DEFN SUB
      (X Y)
      (ADD X (INTEGER-MINUS Y)))

(DEFN EXP2
      (Y)
      (IF (ZEROP Y)
          1
          (TIMES 2 (EXP2 (SUB1 Y)))))

(PROVE-LEMMA QUOTIENT-STUFF
             (REWRITE)
             (IMPLIES (AND (NOT (EQUAL N 0)) (NUMBERP N))
                      (LESSP (QUOTIENT N 2) N)))

(DEFN LOG2
      (N)
      (IF (OR (ZEROP N) (EQUAL N 1))
          0
          (ADD1 (LOG2 (QUOTIENT N 2)))))

(DEFN ASM-REGISTER
      (X)
      (CASE X
            (R0 (LIST F F F F F F))
            (R1 (LIST T F F F F F))
            (R2 (LIST F T F F F F))
            (R3 (LIST T T F F F F))
            (R4 (LIST F F T F F F))
            (R5 (LIST T F T F F F))
            (R6 (LIST F T T F F F))
            (R7 (LIST T T T F F F))
            (R8 (LIST F F F T F F))
            (R9 (LIST T F F T F F))
            (R10 (LIST F T F T F F))
            (R11 (LIST T T F T F F))
            (R12 (LIST F F T T F F))
            (R13 (LIST T F T T F F))
            (LNK (LIST T F T T F F))
            (R14 (LIST F T T T F F))
            (TOS (LIST F T T T F F))
            (R15 (LIST T T T T F F))
            (PC (LIST T T T T F F))
            ((R0) (LIST F F F F T F))
            ((R1) (LIST T F F F T F))
            ((R2) (LIST F T F F T F))
            ((R3) (LIST T T F F T F))
            ((R4) (LIST F F T F T F))
            ((R5) (LIST T F T F T F))
            ((R6) (LIST F T T F T F))
            ((R7) (LIST T T T F T F))
            ((R8) (LIST F F F T T F))
            ((R9) (LIST T F F T T F))
            ((R10) (LIST F T F T T F))
            ((R11) (LIST T T F T T F))
            ((R12) (LIST F F T T T F))
            ((R13) (LIST T F T T T F))
            ((LNK) (LIST T F T T T F))
            ((R14) (LIST F T T T T F))
            ((TOS) (LIST F T T T T F))
            ((R15) (LIST T T T T T F))
            ((PC) (LIST T T T T T F))
            ((R0-) (LIST F F F F F T))
            ((R1-) (LIST T F F F F T))
            ((R2-) (LIST F T F F F T))
            ((R3-) (LIST T T F F F T))
            ((R4-) (LIST F F T F F T))
            ((R5-) (LIST T F T F F T))
            ((R6-) (LIST F T T F F T))
            ((R7-) (LIST T T T F F T))
            ((R8-) (LIST F F F T F T))
            ((R9-) (LIST T F F T F T))
            ((R10-) (LIST F T F T F T))
            ((R11-) (LIST T T F T F T))
            ((R12-) (LIST F F T T F T))
            ((R13-) (LIST T F T T F T))
            ((LNK-) (LIST T F T T F T))
            ((R14-) (LIST F T T T F T))
            ((TOS-) (LIST F T T T F T))
            ((R15-) (LIST T T T T F T))
            ((PC-) (LIST T T T T F T))
            ((R0+) (LIST F F F F T T))
            ((R1+) (LIST T F F F T T))
            ((R2+) (LIST F T F F T T))
            ((R3+) (LIST T T F F T T))
            ((R4+) (LIST F F T F T T))
            ((R5+) (LIST T F T F T T))
            ((R6+) (LIST F T T F T T))
            ((R7+) (LIST T T T F T T))
            ((R8+) (LIST F F F T T T))
            ((R9+) (LIST T F F T T T))
            ((R10+) (LIST F T F T T T))
            ((R11+) (LIST T T F T T T))
            ((R12+) (LIST F F T T T T))
            ((R13+) (LIST T F T T T T))
            ((LNK+) (LIST T F T T T T))
            ((R14+) (LIST F T T T T T))
            ((TOS+) (LIST F T T T T T))
            ((R15+) (LIST T T T T T T))
            ((PC+) (LIST T T T T T T))
            (OTHERWISE (LIST F F F F F F))))

(DEFN ASM-REGISTER-A
      (X)
      (IF (INTP X)
          (APPEND (INT-TO-BV X 9) (LIST T))
          (APPEND (ASM-REGISTER X)
                  (LIST F F F F))))

(DEFN ASM-OP-CODE
      (X)
      (CASE X
            (MOVE (LIST F F F F))
            (INC (LIST T F F F))
            (ADDC (LIST F T F F))
            (ADD (LIST T T F F))
            (NEG (LIST F F T F))
            (DEC (LIST T F T F))
            (SUBB (LIST F T T F))
            (SUB (LIST T T T F))
            (ROR (LIST F F F T))
            (ASR (LIST T F F T))
            (LSR (LIST F T F T))
            (XOR (LIST T T F T))
            (OR (LIST F F T T))
            (AND (LIST T F T T))
            (NOT (LIST F T T T))
            (M15 (LIST T T T T))
            (OTHERWISE (LIST F F F F))))

(DEFN ASM-STORE-CC
      (X)
      (CASE X
            (CC (LIST F F F F))
            (CS (LIST T F F F))
            (VC (LIST F T F F))
            (VS (LIST T T F F))
            (PL (LIST F F T F))
            (NC (LIST F F T F))
            (MI (LIST T F T F))
            (NS (LIST T F T F))
            (NE (LIST F T T F))
            (ZC (LIST F T T F))
            (EQ (LIST T T T F))
            (ZS (LIST T T T F))
            (HI (LIST F F F T))
            (LS (LIST T F F T))
            (GE (LIST F T F T))
            (LT (LIST T T F T))
            (GT (LIST F F T T))
            (LE (LIST T F T T))
            (T (LIST F T T T))
            (F (LIST T T T T))
            (OTHERWISE (LIST F F F F))))

(DEFN ASM-FLAGS
      (X)
      (IF (EQUAL X 'T)
          (LIST T T T T)
          (LIST (MEMBER (CAR (UNPACK 'Z)) (UNPACK X))
                (MEMBER (CAR (UNPACK 'N)) (UNPACK X))
                (MEMBER (CAR (UNPACK 'V)) (UNPACK X))
                (MEMBER (CAR (UNPACK 'C))
                        (UNPACK X)))))

(DEFN RESOLVE-NAMES
      (LIST CNT ALIST)
      (COND ((NLISTP LIST) ALIST)
            ((LITATOM (CAR LIST))
             (RESOLVE-NAMES (CDR LIST)
                            CNT
                            (CONS (CONS (CAR LIST) CNT) ALIST)))
            (T (RESOLVE-NAMES (CDR LIST)
                              (ADD1 CNT)
                              ALIST))))

(DEFN UPDATE-LIST
      (LIST ALIST)
      (IF (NLISTP LIST)
          NIL
          (CONS (IF (AND (LISTP (CAR LIST))
                         (EQUAL (CAAR LIST) 'VALUE))
                    (EVAL$ T (CADAR LIST) ALIST)
                    (CAR LIST))
                (UPDATE-LIST (CDR LIST) ALIST))))

(DEFN ASM-LINE
      (LINE)
      (IF (INTP LINE)
          (INT-TO-BV LINE 32)
          (APPEND (ASM-REGISTER-A (CADDDDR LINE))
                  (APPEND (ASM-REGISTER (CADDDR LINE))
                          (APPEND (ASM-FLAGS (CADDR LINE))
                                  (APPEND (ASM-STORE-CC (CADR LINE))
                                          (APPEND (ASM-OP-CODE (CAR LINE))
                                                  (LIST F F F F))))))))

(DEFN ASM-LIST
      (LIST)
      (COND ((NLISTP LIST) NIL)
            ((LITATOM (CAR LIST))
             (ASM-LIST (CDR LIST)))
            (T (CONS (ASM-LINE (CAR LIST))
                     (ASM-LIST (CDR LIST))))))

(DEFN ASM
      (LIST)
      (ASM-LIST (UPDATE-LIST LIST
                             (RESOLVE-NAMES LIST 0 NIL))))

(DEFN T-AND-F-TO-1-AND-0
      (LIST)
      (IF (NLISTP LIST)
          NIL
          (CONS (IF (FALSEP (CAR LIST)) 0 1)
                (T-AND-F-TO-1-AND-0 (CDR LIST)))))

(DEFN ASM-TO-1-AND-0
      (LIST)
      (IF (NLISTP LIST)
          NIL
          (CONS (T-AND-F-TO-1-AND-0 (CAR LIST))
                (ASM-TO-1-AND-0 (CDR LIST)))))

(DEFN V-TO-NAT-ALL
      (X)
      (IF (NLISTP X)
          NIL
          (CONS (V-TO-NAT (CAR X))
                (V-TO-NAT-ALL (CDR X)))))

(DEFN V-TO-0S-THROUGH-FS
      (X COLLECT)
      (IF (NLISTP X)
          COLLECT
          (V-TO-0S-THROUGH-FS (CDDDDR X)
                              (CONS (CASE (V-TO-NAT (FIRSTN 4 X))
                                          (0 (CADR (UNPACK 'X0)))
                                          (1 (CADR (UNPACK 'X1)))
                                          (2 (CADR (UNPACK 'X2)))
                                          (3 (CADR (UNPACK 'X3)))
                                          (4 (CADR (UNPACK 'X4)))
                                          (5 (CADR (UNPACK 'X5)))
                                          (6 (CADR (UNPACK 'X6)))
                                          (7 (CADR (UNPACK 'X7)))
                                          (8 (CADR (UNPACK 'X8)))
                                          (9 (CADR (UNPACK 'X9)))
                                          (10 (CADR (UNPACK 'XA)))
                                          (11 (CADR (UNPACK 'XB)))
                                          (12 (CADR (UNPACK 'XC)))
                                          (13 (CADR (UNPACK 'XD)))
                                          (14 (CADR (UNPACK 'XE)))
                                          (OTHERWISE (CADR (UNPACK 'XF))))
                                    COLLECT))))

(DEFN V-TO-HEX
      (X)
      (PACK (CONS (CAR (UNPACK 'X))
                  (V-TO-0S-THROUGH-FS X 0))))

(DEFN V-TO-HEX-ALL
      (X)
      (IF (NLISTP X)
          NIL
          (CONS (V-TO-HEX (CAR X))
                (V-TO-HEX-ALL (CDR X)))))

(DEFN MAKE-PAIRS
      (LIST)
      (IF (OR (NLISTP LIST) (NLISTP (CDR LIST)))
          NIL
          (CONS (CONS (CAR LIST) (CADR LIST))
                (MAKE-PAIRS (CDDR LIST)))))

(DEFN ADD-RAM-MARKER
      (LIST-MEM)
      (IF (NLISTP LIST-MEM)
          NIL
          (CONS (RAM (CAR LIST-MEM))
                (ADD-RAM-MARKER (CDR LIST-MEM)))))

(DEFN LIST-TO-MEM3
      (MEM DEPTH)
      (IF (ZEROP DEPTH)
          MEM
          (LIST-TO-MEM3 (MAKE-PAIRS MEM)
                        (SUB1 DEPTH))))

(DEFN LIST-TO-MEM2
      (MEM DEPTH)
      (CAR (LIST-TO-MEM3 MEM DEPTH)))

(DEFN LIST-TO-MEM1
 (MEM DEFAULT)
 (LIST-TO-MEM2
  (ADD-RAM-MARKER
               (APPEND MEM
                       (MAKE-LIST (DIFFERENCE (EXP2 (ADD1 (LOG2 (LENGTH MEM))))
                                              (LENGTH MEM))
                                  DEFAULT)))
  (ADD1 (LOG2 (LENGTH MEM)))))

(DEFN STUB-RIGHT
      (MEM LEVELS DEFAULT)
      (IF (ZEROP LEVELS)
          MEM
          (CONS (STUB-RIGHT MEM (SUB1 LEVELS) DEFAULT)
                (STUB DEFAULT))))

(DEFN LIST-TO-MEM
      (MEM SIZE DEFAULT)
      (IF (LESSP SIZE
                 (ADD1 (LOG2 (LENGTH MEM))))
          '(LIST-TO-MEM= INSUFFICIENT-SIZE)
          (STUB-RIGHT (LIST-TO-MEM1 MEM DEFAULT)
                      (DIFFERENCE SIZE
                                  (ADD1 (LOG2 (LENGTH MEM))))
                      DEFAULT)))

(DEFN LIST-TO-TREE-MEM
      (MEM)
      (LIST-TO-MEM MEM 32 (MAKE-LIST 32 F)))

(DEFN MEM-TO-LIST
      (MEM)
      (COND ((LISTP MEM)
             (APPEND (MEM-TO-LIST (CAR MEM))
                     (MEM-TO-LIST (CDR MEM))))
            ((STUBP MEM) NIL)
            ((RAMP MEM) (LIST (RAM-GUTS MEM)))
            ((ROMP MEM) (LIST (ROM-GUTS MEM)))
            (T MEM)))

(DEFN UN-FM9001
      (STATE)
      (LIST (LIST (V-TO-NAT-ALL (MEM-TO-LIST (REGS (CAR STATE))))
                  (Z-FLAG (FLAGS (CAR STATE)))
                  (N-FLAG (FLAGS (CAR STATE)))
                  (V-FLAG (FLAGS (CAR STATE)))
                  (C-FLAG (FLAGS (CAR STATE))))
            (V-TO-HEX-ALL (MEM-TO-LIST (CADR STATE)))))

(DEFN EXECUTE-FM9001
     (N TREE-PGM)
     (UN-FM9001 (FM9001 (LIST (LIST (LIST-TO-MEM (MAKE-LIST 15 (NAT-TO-V 0 32))
                                                 4
                                                 (MAKE-LIST 32 F))
                                    (LIST T F F F))
                              TREE-PGM)
                        N)))

(DEFN ASM-AND-FM9001
      (N PROGRAM)
      (EXECUTE-FM9001 N
                      (LIST-TO-MEM (ASM PROGRAM)
                                   32
                                   (MAKE-LIST 32 F))))

(DEFN STORE-RESULTP-MUX
      (S0 S1 S2 D0 D1 D2 D3 D4 D5 D6)
      (AO2 (B-NOT S2)
           (AO2 (B-NOT S1)
                (AO2 (B-NOT S0) D0 S0 D1)
                S1
                (AO2 (B-NOT S0) D2 S0 D3))
           S2
           (AO2 (B-NOT S1)
                (AO2 (B-NOT S0) D4 S0 D5)
                S1
                (B-NAND (B-NOT S0) D6))))

(DEFN F$STORE-RESULTP-MUX
      (S0 S1 S2 D0 D1 D2 D3 D4 D5 D6)
      (F$AO2 (F-NOT S2)
             (F$AO2 (F-NOT S1)
                    (F$AO2 (F-NOT S0) D0 S0 D1)
                    S1
                    (F$AO2 (F-NOT S0) D2 S0 D3))
             S2
             (F$AO2 (F-NOT S1)
                    (F$AO2 (F-NOT S0) D4 S0 D5)
                    S1
                    (F-NAND (F-NOT S0) D6))))

(TOGGLE F$STORE-RESULTP-MUX-OFF F$STORE-RESULTP-MUX T)

(DEFN STORE-RESULTP-MUX* NIL
      '(STORE-RESULTP-MUX (S0 S1 S2 D0 D1 D2 D3 D4 D5 D6)
                          (W-13)
                          ((G-10 (W-10) B-NOT (S0))
                           (G-11 (W-11) B-NAND (W-10 D6))
                           (G-9 (W-9) AO2 (W-10 D4 S0 D5))
                           (G-7 (W-7) B-NOT (S1))
                           (G-12 (W-12) AO2 (W-7 W-9 S1 W-11))
                           (G-5 (W-5) AO2 (W-10 D2 S0 D3))
                           (G-3 (W-3) AO2 (W-10 D0 S0 D1))
                           (G-6 (W-6) AO2 (W-7 W-3 S1 W-5))
                           (G-0 (W-0) B-NOT (S2))
                           (G-13 (W-13) AO2 (W-0 W-6 S2 W-12)))
                          NIL))

(DEFN STORE-RESULTP-MUX&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'STORE-RESULTP-MUX
                                 NETLIST)
                  (STORE-RESULTP-MUX*))
           (B-NAND& (DELETE-MODULE 'STORE-RESULTP-MUX
                                   NETLIST))
           (B-NOT& (DELETE-MODULE 'STORE-RESULTP-MUX
                                  NETLIST))
           (AO2& (DELETE-MODULE 'STORE-RESULTP-MUX
                                NETLIST))))

(TOGGLE STORE-RESULTP-MUX&-OFF STORE-RESULTP-MUX& T)

(DEFN STORE-RESULTP-MUX$NETLIST NIL
      (CONS (STORE-RESULTP-MUX*)
            (UNION (UNION (B-NAND$NETLIST)
                          (B-NOT$NETLIST))
                   (AO2$NETLIST))))

(PROVE-LEMMA STORE-RESULTP-MUX$VALUE
             (REWRITE)
             (IMPLIES (STORE-RESULTP-MUX& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'STORE-RESULTP-MUX
                                        (LIST S0 S1 S2 D0 D1 D2 D3 D4 D5 D6)
                                        STATE NETLIST)
                             (LIST (F$STORE-RESULTP-MUX S0 S1 S2 D0 D1 D2
                                                        D3 D4 D5 D6))))
             ((ENABLE STORE-RESULTP-MUX& F$STORE-RESULTP-MUX B-NAND$VALUE
                      B-NOT$VALUE AO2$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE STORE-RESULTP-MUX$VALUE-OFF STORE-RESULTP-MUX$VALUE T)

(PROVE-LEMMA F$STORE-RESULTP-MUX=STORE-RESULTP-MUX
             (REWRITE)
             (IMPLIES (AND (BOOLP S0)
                           (BOOLP S1)
                           (BOOLP S2)
                           (BOOLP D0)
                           (BOOLP D1)
                           (BOOLP D2)
                           (BOOLP D3)
                           (BOOLP D4)
                           (BOOLP D5)
                           (BOOLP D6))
                      (EQUAL (F$STORE-RESULTP-MUX S0 S1 S2 D0 D1 D2 D3 D4 D5
                                                  D6)
                             (STORE-RESULTP-MUX S0 S1 S2 D0 D1 D2 D3 D4 D5
                                                D6)))
             ((ENABLE BOOLP-B-GATES F$STORE-RESULTP-MUX STORE-RESULTP-MUX)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN B-STORE-RESULTP
      (STORE-CC FLAGS)
      (B-XOR (CAR STORE-CC)
             (STORE-RESULTP-MUX (CADR STORE-CC)
                                (CADDR STORE-CC)
                                (CADDDR STORE-CC)
                                (CADDDR FLAGS)
                                (CADDR FLAGS)
                                (CADR FLAGS)
                                (CAR FLAGS)
                                (B-OR (CADDDR FLAGS) (CAR FLAGS))
                                (B-XOR (CADR FLAGS) (CADDR FLAGS))
                                (B-OR (CAR FLAGS)
                                      (B-XOR (CADR FLAGS) (CADDR FLAGS))))))

(TOGGLE B-STORE-RESULTP-OFF B-STORE-RESULTP T)

(DEFN F$B-STORE-RESULTP
      (STORE-CC FLAGS)
      (F-XOR (CAR STORE-CC)
             (F$STORE-RESULTP-MUX (CADR STORE-CC)
                                  (CADDR STORE-CC)
                                  (CADDDR STORE-CC)
                                  (CADDDR FLAGS)
                                  (CADDR FLAGS)
                                  (CADR FLAGS)
                                  (CAR FLAGS)
                                  (F-OR (CADDDR FLAGS) (CAR FLAGS))
                                  (F-XOR (CADR FLAGS) (CADDR FLAGS))
                                  (F-OR (CAR FLAGS)
                                        (F-XOR (CADR FLAGS) (CADDR FLAGS))))))

(TOGGLE F$B-STORE-RESULTP-OFF F$B-STORE-RESULTP T)

(PROVE-LEMMA F$B-STORE-RESULTP=B-STORE-RESULTP
             (REWRITE)
             (IMPLIES (AND (BVP STORE-CC)
                           (EQUAL (LENGTH STORE-CC) 4)
                           (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4))
                      (EQUAL (F$B-STORE-RESULTP STORE-CC FLAGS)
                             (B-STORE-RESULTP STORE-CC FLAGS)))
             ((ENABLE F$B-STORE-RESULTP B-STORE-RESULTP BOOLP-B-GATES
                      BVP-LENGTH)
              (DISABLE-THEORY F-GATES)))

(DEFN B-STORE-RESULTP* NIL
      '(B-STORE-RESULTP (S0 S1 S2 S3 Z N V C)
                        (RESULT)
                        ((G0 (CZ) B-OR (C Z))
                         (G1 (NV) B-XOR (N V))
                         (G2 (ZNV) B-OR (Z NV))
                         (G3 (MUX)
                             STORE-RESULTP-MUX
                             (S1 S2 S3 C V N Z CZ NV ZNV))
                         (G4 (RESULT) B-XOR (S0 MUX)))
                        NIL))

(DEFN B-STORE-RESULTP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'B-STORE-RESULTP
                                 NETLIST)
                  (B-STORE-RESULTP*))
           (B-OR& (DELETE-MODULE 'B-STORE-RESULTP
                                 NETLIST))
           (STORE-RESULTP-MUX& (DELETE-MODULE 'B-STORE-RESULTP
                                              NETLIST))
           (B-XOR& (DELETE-MODULE 'B-STORE-RESULTP
                                  NETLIST))))

(TOGGLE B-STORE-RESULTP&-OFF B-STORE-RESULTP& T)

(DEFN B-STORE-RESULTP$NETLIST NIL
      (CONS (B-STORE-RESULTP*)
            (UNION (UNION (B-OR$NETLIST)
                          (STORE-RESULTP-MUX$NETLIST))
                   (B-XOR$NETLIST))))

(PROVE-LEMMA B-STORE-RESULTP=STORE-RESULTP$HELP
             (REWRITE)
             (IMPLIES (AND (BOOLP S0)
                           (BOOLP S1)
                           (BOOLP S2)
                           (BOOLP S3)
                           (BOOLP S4)
                           (BOOLP S5)
                           (BOOLP S6)
                           (BOOLP S7))
                      (EQUAL (B-STORE-RESULTP (LIST S0 S1 S2 S3)
                                              (LIST S4 S5 S6 S7))
                             (STORE-RESULTP (LIST S0 S1 S2 S3)
                                            (LIST S4 S5 S6 S7))))
             ((ENABLE B-STORE-RESULTP STORE-RESULTP BOOLP)))

(PROVE-LEMMA B-STORE-RESULTP=STORE-RESULTP
             (REWRITE)
             (IMPLIES (AND (BVP STORE-CC)
                           (EQUAL (LENGTH STORE-CC) 4)
                           (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4))
                      (EQUAL (B-STORE-RESULTP STORE-CC FLAGS)
                             (STORE-RESULTP STORE-CC FLAGS)))
             ((ENABLE BVP EQUAL-LENGTH-ADD1)))

(PROVE-LEMMA B-STORE-RESULTP$VALUE
             (REWRITE)
             (IMPLIES (AND (B-STORE-RESULTP& NETLIST)
                           (PROPERP STORE-CC)
                           (EQUAL (LENGTH STORE-CC) 4)
                           (PROPERP STORE-CC)
                           (EQUAL (LENGTH FLAGS) 4))
                      (EQUAL (DUAL-EVAL 0 'B-STORE-RESULTP
                                        (APPEND STORE-CC FLAGS)
                                        STATE NETLIST)
                             (LIST (F$B-STORE-RESULTP STORE-CC FLAGS))))
             ((ENABLE B-STORE-RESULTP& F$B-STORE-RESULTP
                      STORE-RESULTP-MUX$VALUE B-OR$VALUE B-XOR$VALUE
                      EQUAL-LENGTH-ADD1)
              (DISABLE-THEORY F-GATES)))

(DEFN F$UNARY-OP-CODE-P
      (OP)
      (F-NAND4 (F-NAND (F-NOT (CADDDR OP))
                       (F-NOT (CADR OP)))
               (F-NAND (F-NOT (CADDR OP))
                       (F-NOT (CADR OP)))
               (F-NAND3 (CADDDR OP)
                        (CADR OP)
                        (F-NOT (CAR OP)))
               (F-NAND3 (CADDDR OP)
                        (CADDR OP)
                        (CADR OP))))

(TOGGLE F$UNARY-OP-CODE-P-OFF F$UNARY-OP-CODE-P T)

(PROVE-LEMMA F$UNARY-OP-CODE-P=UNARY-OP-CODE-P
             (REWRITE)
             (IMPLIES (AND (BVP OP) (EQUAL (LENGTH OP) 4))
                      (EQUAL (F$UNARY-OP-CODE-P OP)
                             (UNARY-OP-CODE-P OP)))
             ((ENABLE F$UNARY-OP-CODE-P UNARY-OP-CODE-P BVP-LENGTH BVP
                      EQUAL-LENGTH-ADD1)
              (DISABLE-THEORY F-GATES)))

(DEFN UNARY-OP-CODE-P* NIL
      '(UNARY-OP-CODE-P (OP0 OP1 OP2 OP3)
                        (Z)
                        ((G0 (OP0-) B-NOT (OP0))
                         (G1 (OP1-) B-NOT (OP1))
                         (G2 (OP2-) B-NOT (OP2))
                         (G3 (OP3-) B-NOT (OP3))
                         (G4 (S0) B-NAND (OP3- OP1-))
                         (G5 (S1) B-NAND (OP2- OP1-))
                         (G6 (S2) B-NAND3 (OP3 OP1 OP0-))
                         (G7 (S3) B-NAND3 (OP3 OP2 OP1))
                         (G8 (Z) B-NAND4 (S0 S1 S2 S3)))
                        NIL))

(DEFN UNARY-OP-CODE-P&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'UNARY-OP-CODE-P
                                 NETLIST)
                  (UNARY-OP-CODE-P*))
           (B-NOT& (DELETE-MODULE 'UNARY-OP-CODE-P
                                  NETLIST))
           (B-NAND& (DELETE-MODULE 'UNARY-OP-CODE-P
                                   NETLIST))
           (B-NAND3& (DELETE-MODULE 'UNARY-OP-CODE-P
                                    NETLIST))
           (B-NAND4& (DELETE-MODULE 'UNARY-OP-CODE-P
                                    NETLIST))))

(TOGGLE UNARY-OP-CODE-P&-OFF UNARY-OP-CODE-P& T)

(DEFN UNARY-OP-CODE-P$NETLIST NIL
      (CONS (UNARY-OP-CODE-P*)
            (UNION (UNION (UNION (B-NOT$NETLIST)
                                 (B-NAND$NETLIST))
                          (B-NAND3$NETLIST))
                   (B-NAND4$NETLIST))))

(PROVE-LEMMA UNARY-OP-CODE-P$VALUE
             (REWRITE)
             (IMPLIES (UNARY-OP-CODE-P& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'UNARY-OP-CODE-P
                                        OP-CODE STATE NETLIST)
                             (LIST (F$UNARY-OP-CODE-P OP-CODE))))
             ((ENABLE UNARY-OP-CODE-P& F$UNARY-OP-CODE-P B-NOT$VALUE
                      B-NAND$VALUE B-NAND3$VALUE B-NAND4$VALUE LIST-ELIM-4)
              (DISABLE-THEORY F-GATES)))

(TOGGLE UNARY-OP-CODE-P$VALUE-OFF UNARY-OP-CODE-P$VALUE T)

(DEFN F$DECODE-REG-MODE
      (M)
      (LIST (F-NOR (CAR M) (CADR M))
            (F-NOR (CAR M) (F-NOT (CADR M)))
            (ID (CADR M))))

(TOGGLE F$DECODE-REG-MODE-OFF F$DECODE-REG-MODE T)

(DEFN DECODE-REG-MODE* NIL
      '(DECODE-REG-MODE (M0 M1)
                        (DIRECT PRE-DEC SIDE-EFFECT)
                        ((G0 (DIRECT) B-NOR (M0 M1))
                         (G1 (M1-) B-NOT (M1))
                         (G2 (PRE-DEC) B-NOR (M0 M1-))
                         (G3 (SIDE-EFFECT) ID (M1)))
                        NIL))

(DEFN DECODE-REG-MODE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DECODE-REG-MODE
                                 NETLIST)
                  (DECODE-REG-MODE*))
           (B-NOT& (DELETE-MODULE 'DECODE-REG-MODE
                                  NETLIST))
           (B-NOR& (DELETE-MODULE 'DECODE-REG-MODE
                                  NETLIST))
           (ID& (DELETE-MODULE 'DECODE-REG-MODE
                               NETLIST))))

(TOGGLE DECODE-REG-MODE&-OFF DECODE-REG-MODE& T)

(DEFN DECODE-REG-MODE$NETLIST NIL
      (CONS (DECODE-REG-MODE*)
            (UNION (UNION (B-NOT$NETLIST)
                          (B-NOR$NETLIST))
                   (ID$NETLIST))))

(PROVE-LEMMA DECODE-REG-MODE$VALUE
             (REWRITE)
             (IMPLIES (DECODE-REG-MODE& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'DECODE-REG-MODE
                                        MODE STATE NETLIST)
                             (F$DECODE-REG-MODE MODE)))
             ((ENABLE DECODE-REG-MODE& B-NOR$VALUE ID$VALUE B-NOT$VALUE
                      F$DECODE-REG-MODE)))

(TOGGLE DECODE-REG-MODE$VALUE-OFF DECODE-REG-MODE$VALUE T)

(PROVE-LEMMA F$DECODE-REG-MODE-AS-REG-MODE
             (REWRITE)
             (IMPLIES (AND (BVP MODE)
                           (EQUAL (LENGTH MODE) 2))
                      (EQUAL (F$DECODE-REG-MODE MODE)
                             (LIST (REG-DIRECT-P MODE)
                                   (PRE-DEC-P MODE)
                                   (OR (PRE-DEC-P MODE)
                                       (POST-INC-P MODE)))))
             ((ENABLE-THEORY REG-MODE-THEORY)
              (ENABLE F$DECODE-REG-MODE EQUAL-LENGTH-ADD1 BVP)))

(DEFN F$SELECT-OP-CODE
      (SELECT DEC OP)
      (LIST (F-NAND SELECT (F-NOT (CAR OP)))
            (F-AND SELECT (CADR OP))
            (F-IF SELECT (CADDR OP) DEC)
            (F-AND SELECT (CADDDR OP))))

(TOGGLE F$SELECT-OP-CODE-OFF F$SELECT-OP-CODE T)

(PROVE-LEMMA PROPERP-LENGTH-F$SELECT-OP-CODE
             (REWRITE)
             (AND (PROPERP (F$SELECT-OP-CODE SELECT DEC OP))
                  (EQUAL (LENGTH (F$SELECT-OP-CODE SELECT DEC OP))
                         4))
             ((ENABLE F$SELECT-OP-CODE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$SELECT-OP-CODE-SELECTS
             (REWRITE)
             (IMPLIES (AND (BOOLP SELECT)
                           (BOOLP DEC)
                           (BVP OP)
                           (EQUAL (LENGTH OP) 4))
                      (EQUAL (F$SELECT-OP-CODE SELECT DEC OP)
                             (V-IF SELECT OP
                                   (V-IF DEC
                                         (ALU-DEC-OP)
                                         (ALU-INC-OP)))))
             ((ENABLE F$SELECT-OP-CODE BVP-LENGTH EQUAL-LENGTH-ADD1
                      BOOLP-B-GATES ALU-INC-OP ALU-DEC-OP V-IF)
              (DISABLE-THEORY F-GATES)))

(DEFN SELECT-OP-CODE* NIL
      '(SELECT-OP-CODE (SELECT DEC OP0 OP1 OP2 OP3)
                       (Z0 Z1 Z2 Z3)
                       ((I0 (OP0-) B-NOT (OP0))
                        (G0 (Z0) B-NAND (SELECT OP0-))
                        (G1 (Z1) B-AND (SELECT OP1))
                        (G2 (Z2) B-IF (SELECT OP2 DEC))
                        (G3 (Z3) B-AND (SELECT OP3)))
                       NIL))

(DEFN SELECT-OP-CODE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'SELECT-OP-CODE
                                 NETLIST)
                  (SELECT-OP-CODE*))
           (B-NOT& (DELETE-MODULE 'SELECT-OP-CODE
                                  NETLIST))
           (B-NAND& (DELETE-MODULE 'SELECT-OP-CODE
                                   NETLIST))
           (B-IF& (DELETE-MODULE 'SELECT-OP-CODE
                                 NETLIST))
           (B-AND& (DELETE-MODULE 'SELECT-OP-CODE
                                  NETLIST))))

(TOGGLE SELECT-OP-CODE&-OFF SELECT-OP-CODE& T)

(DEFN SELECT-OP-CODE$NETLIST NIL
      (CONS (SELECT-OP-CODE*)
            (UNION (UNION (UNION (B-NOT$NETLIST)
                                 (B-NAND$NETLIST))
                          (B-IF$NETLIST))
                   (B-AND$NETLIST))))

(PROVE-LEMMA SELECT-OP-CODE$VALUE
             (REWRITE)
             (IMPLIES (AND (SELECT-OP-CODE& NETLIST)
                           (PROPERP OP)
                           (EQUAL (LENGTH OP) 4))
                      (EQUAL (DUAL-EVAL 0 'SELECT-OP-CODE
                                        (CONS SELECT (CONS DEC OP))
                                        STATE NETLIST)
                             (F$SELECT-OP-CODE SELECT DEC OP)))
             ((ENABLE SELECT-OP-CODE& F$SELECT-OP-CODE BVP-LENGTH
                      EQUAL-LENGTH-ADD1 B-NOT$VALUE B-AND$VALUE B-NAND$VALUE
                      B-IF$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE SELECT-OP-CODE$VALUE-OFF SELECT-OP-CODE$VALUE T)

(DEFN V-IF-F-4* NIL
      '(V-IF-F-4 (C A0 A1 A2 A3)
                 (Z0 Z1 Z2 Z3)
                 ((CB (C-) B-NOT (C))
                  (G0 (Z0) B-AND (C- A0))
                  (G1 (Z1) B-AND (C- A1))
                  (G2 (Z2) B-AND (C- A2))
                  (G3 (Z3) B-AND (C- A3)))
                 NIL))

(DEFN V-IF-F-4&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'V-IF-F-4 NETLIST)
                  (V-IF-F-4*))
           (B-NOT& (DELETE-MODULE 'V-IF-F-4 NETLIST))
           (B-AND& (DELETE-MODULE 'V-IF-F-4 NETLIST))))

(TOGGLE V-IF-F-4&-OFF V-IF-F-4& T)

(DEFN V-IF-F-4$NETLIST NIL
      (CONS (V-IF-F-4*)
            (UNION (B-NOT$NETLIST)
                   (B-AND$NETLIST))))

(DEFN F$V-IF-F-4
      (C A)
      (LIST (F-AND (F-NOT C) (CAR A))
            (F-AND (F-NOT C) (CADR A))
            (F-AND (F-NOT C) (CADDR A))
            (F-AND (F-NOT C) (CADDDR A))))

(TOGGLE F$V-IF-F-4-OFF F$V-IF-F-4 T)

(PROVE-LEMMA PROPERP-LENGTH-F$V-IF-F-4
             (REWRITE)
             (AND (PROPERP (F$V-IF-F-4 C A))
                  (EQUAL (LENGTH (F$V-IF-F-4 C A)) 4))
             ((ENABLE F$V-IF-F-4)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA V-IF-F-4$VALUE
             (REWRITE)
             (IMPLIES (V-IF-F-4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'V-IF-F-4
                                        (CONS C A)
                                        STATE NETLIST)
                             (F$V-IF-F-4 C A)))
             ((ENABLE V-IF-F-4& B-NOT$VALUE B-AND$VALUE F$V-IF-F-4)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA F$V-IF-F-4=FV-IF
             (REWRITE)
             (IMPLIES (BOOLP C)
                      (EQUAL (F$V-IF-F-4 C A)
                             (FV-IF C (MAKE-LIST 4 F) A)))
             ((ENABLE F$V-IF-F-4 FV-IF BOOLP-B-GATES)))

(PROVE-LEMMA V-IF-F-4$RESET-VALUE
             (REWRITE)
             (IMPLIES (V-IF-F-4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'V-IF-F-4
                                        (CONS T A)
                                        STATE NETLIST)
                             (MAKE-LIST 4 F)))
             ((ENABLE V-IF-F-4& B-NOT$VALUE B-AND$VALUE)))

(TOGGLE V-IF-F-4$RESET-VALUE-OFF V-IF-F-4$RESET-VALUE T)

(DEFN FANOUT-4* NIL
      '(FANOUT-4 (A)
                 (Z0 Z1 Z2 Z3)
                 ((AA (AA) B-BUF (A))
                  (G0 (Z0) ID (AA))
                  (G1 (Z1) ID (AA))
                  (G2 (Z2) ID (AA))
                  (G3 (Z3) ID (AA)))
                 NIL))

(DEFN FANOUT-4&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'FANOUT-4 NETLIST)
                  (FANOUT-4*))
           (B-BUF& (DELETE-MODULE 'FANOUT-4 NETLIST))
           (ID& (DELETE-MODULE 'FANOUT-4 NETLIST))))

(TOGGLE FANOUT-4&-OFF FANOUT-4& T)

(DEFN FANOUT-4$NETLIST NIL
      (CONS (FANOUT-4*)
            (UNION (B-BUF$NETLIST) (ID$NETLIST))))

(PROVE-LEMMA FANOUT-4$VALUE
             (REWRITE)
             (IMPLIES (FANOUT-4& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FANOUT-4
                                        (LIST A)
                                        STATE NETLIST)
                             (MAKE-LIST 4 (THREEFIX A))))
             ((ENABLE FANOUT-4& B-BUF$VALUE ID$VALUE OPEN-MAKE-LIST)))

(TOGGLE FANOUT-4$VALUE-OFF FANOUT-4$VALUE T)

(DEFN FANOUT-5* NIL
      '(FANOUT-5 (A)
                 (Z0 Z1 Z2 Z3 Z4)
                 ((AA (AA) B-BUF (A))
                  (G0 (Z0) ID (AA))
                  (G1 (Z1) ID (AA))
                  (G2 (Z2) ID (AA))
                  (G3 (Z3) ID (AA))
                  (G4 (Z4) ID (AA)))
                 NIL))

(DEFN FANOUT-5&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'FANOUT-5 NETLIST)
                  (FANOUT-5*))
           (B-BUF& (DELETE-MODULE 'FANOUT-5 NETLIST))
           (ID& (DELETE-MODULE 'FANOUT-5 NETLIST))))

(TOGGLE FANOUT-5&-OFF FANOUT-5& T)

(DEFN FANOUT-5$NETLIST NIL
      (CONS (FANOUT-5*)
            (UNION (B-BUF$NETLIST) (ID$NETLIST))))

(PROVE-LEMMA FANOUT-5$VALUE
             (REWRITE)
             (IMPLIES (FANOUT-5& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FANOUT-5
                                        (LIST A)
                                        STATE NETLIST)
                             (MAKE-LIST 5 (THREEFIX A))))
             ((ENABLE FANOUT-5& B-BUF$VALUE ID$VALUE OPEN-MAKE-LIST)))

(TOGGLE FANOUT-5$VALUE-OFF FANOUT-5$VALUE T)

(DEFN FANOUT-32* NIL
      '(FANOUT-32 (A)
                  (S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 S16
                      S17 S18 S19 S20 S21 S22 S23 S24 S25 S26 S27 S28 S29 S30
                      S31)
                  ((GA (AA) B-BUF-PWR (A))
                   (G0 (S0) ID (AA))
                   (G1 (S1) ID (AA))
                   (G2 (S2) ID (AA))
                   (G3 (S3) ID (AA))
                   (G4 (S4) ID (AA))
                   (G5 (S5) ID (AA))
                   (G6 (S6) ID (AA))
                   (G7 (S7) ID (AA))
                   (G8 (S8) ID (AA))
                   (G9 (S9) ID (AA))
                   (G10 (S10) ID (AA))
                   (G11 (S11) ID (AA))
                   (G12 (S12) ID (AA))
                   (G13 (S13) ID (AA))
                   (G14 (S14) ID (AA))
                   (G15 (S15) ID (AA))
                   (G16 (S16) ID (AA))
                   (G17 (S17) ID (AA))
                   (G18 (S18) ID (AA))
                   (G19 (S19) ID (AA))
                   (G20 (S20) ID (AA))
                   (G21 (S21) ID (AA))
                   (G22 (S22) ID (AA))
                   (G23 (S23) ID (AA))
                   (G24 (S24) ID (AA))
                   (G25 (S25) ID (AA))
                   (G26 (S26) ID (AA))
                   (G27 (S27) ID (AA))
                   (G28 (S28) ID (AA))
                   (G29 (S29) ID (AA))
                   (G30 (S30) ID (AA))
                   (G31 (S31) ID (AA)))
                  NIL))

(DEFN FANOUT-32&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'FANOUT-32 NETLIST)
                  (FANOUT-32*))
           (B-BUF-PWR& (DELETE-MODULE 'FANOUT-32 NETLIST))
           (ID& (DELETE-MODULE 'FANOUT-32 NETLIST))))

(TOGGLE FANOUT-32&-OFF FANOUT-32& T)

(DEFN FANOUT-32$NETLIST NIL
      (CONS (FANOUT-32*)
            (UNION (B-BUF-PWR$NETLIST)
                   (ID$NETLIST))))

(PROVE-LEMMA FANOUT-32$VALUE
             (REWRITE)
             (IMPLIES (FANOUT-32& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'FANOUT-32
                                        (LIST A)
                                        STATE NETLIST)
                             (MAKE-LIST 32 (THREEFIX A))))
             ((ENABLE FANOUT-32& B-BUF-PWR$VALUE ID$VALUE OPEN-MAKE-LIST)))

(TOGGLE FANOUT-32$VALUE-OFF FANOUT-32$VALUE T)

(DEFN F$DECODE-5
      (S)
      (LIST (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (CADDDDR S))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (CADDDR S))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (CADDR S))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (CADR S)))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (CAR S))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))
            (F-NOR (F-NAND (F-NOT (F-NOT (CAR S)))
                           (F-NOT (F-NOT (CADR S))))
                   (F-NAND3 (F-NOT (F-NOT (CADDR S)))
                            (F-NOT (F-NOT (CADDDR S)))
                            (F-NOT (F-NOT (CADDDDR S)))))))

(TOGGLE F$DECODE-5-OFF F$DECODE-5 T)

(DEFN DECODE-5
      (S)
      (LIST (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (CADDDDR S))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (CADDDR S))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (CADDR S))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (CADR S)))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (CAR S))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))
            (B-NOR (B-NAND (B-NOT (B-NOT (CAR S)))
                           (B-NOT (B-NOT (CADR S))))
                   (B-NAND3 (B-NOT (B-NOT (CADDR S)))
                            (B-NOT (B-NOT (CADDDR S)))
                            (B-NOT (B-NOT (CADDDDR S)))))))

(TOGGLE DECODE-5-OFF DECODE-5 T)

(PROVE-LEMMA BVP-LENGTH-DECODE-5
             (REWRITE)
             (AND (BVP (DECODE-5 S))
                  (EQUAL (LENGTH (DECODE-5 S)) 32))
             ((ENABLE DECODE-5 BOOLP-B-GATES)
              (DISABLE-THEORY B-GATES)))

(DEFN DECODE-5* NIL
      '(DECODE-5 (S0 S1 S2 S3 S4)
                 (X00 X10 X20 X30 X01 X11 X21 X31 X02 X12 X22 X32 X03 X13 X23
                      X33 X04 X14 X24 X34 X05 X15 X25 X35 X06 X16 X26 X36 X07
                      X17 X27 X37)
                 ((GS0- (S0-) B-NOT (S0))
                  (GS1- (S1-) B-NOT (S1))
                  (GS2- (S2-) B-NOT (S2))
                  (GS3- (S3-) B-NOT (S3))
                  (GS4- (S4-) B-NOT (S4))
                  (GS0 (BS0) B-NOT (S0-))
                  (GS1 (BS1) B-NOT (S1-))
                  (GS2 (BS2) B-NOT (S2-))
                  (GS3 (BS3) B-NOT (S3-))
                  (GS4 (BS4) B-NOT (S4-))
                  (GL0 (L0) B-NAND (S0- S1-))
                  (GL1 (L1) B-NAND (BS0 S1-))
                  (GL2 (L2) B-NAND (S0- BS1))
                  (GL3 (L3) B-NAND (BS0 BS1))
                  (GH0 (H0) B-NAND3 (S2- S3- S4-))
                  (GH1 (H1) B-NAND3 (BS2 S3- S4-))
                  (GH2 (H2) B-NAND3 (S2- BS3 S4-))
                  (GH3 (H3) B-NAND3 (BS2 BS3 S4-))
                  (GH4 (H4) B-NAND3 (S2- S3- BS4))
                  (GH5 (H5) B-NAND3 (BS2 S3- BS4))
                  (GH6 (H6) B-NAND3 (S2- BS3 BS4))
                  (GH7 (H7) B-NAND3 (BS2 BS3 BS4))
                  (GX00 (X00) B-NOR (L0 H0))
                  (GX10 (X10) B-NOR (L1 H0))
                  (GX20 (X20) B-NOR (L2 H0))
                  (GX30 (X30) B-NOR (L3 H0))
                  (GX01 (X01) B-NOR (L0 H1))
                  (GX11 (X11) B-NOR (L1 H1))
                  (GX21 (X21) B-NOR (L2 H1))
                  (GX31 (X31) B-NOR (L3 H1))
                  (GX02 (X02) B-NOR (L0 H2))
                  (GX12 (X12) B-NOR (L1 H2))
                  (GX22 (X22) B-NOR (L2 H2))
                  (GX32 (X32) B-NOR (L3 H2))
                  (GX03 (X03) B-NOR (L0 H3))
                  (GX13 (X13) B-NOR (L1 H3))
                  (GX23 (X23) B-NOR (L2 H3))
                  (GX33 (X33) B-NOR (L3 H3))
                  (GX04 (X04) B-NOR (L0 H4))
                  (GX14 (X14) B-NOR (L1 H4))
                  (GX24 (X24) B-NOR (L2 H4))
                  (GX34 (X34) B-NOR (L3 H4))
                  (GX05 (X05) B-NOR (L0 H5))
                  (GX15 (X15) B-NOR (L1 H5))
                  (GX25 (X25) B-NOR (L2 H5))
                  (GX35 (X35) B-NOR (L3 H5))
                  (GX06 (X06) B-NOR (L0 H6))
                  (GX16 (X16) B-NOR (L1 H6))
                  (GX26 (X26) B-NOR (L2 H6))
                  (GX36 (X36) B-NOR (L3 H6))
                  (GX07 (X07) B-NOR (L0 H7))
                  (GX17 (X17) B-NOR (L1 H7))
                  (GX27 (X27) B-NOR (L2 H7))
                  (GX37 (X37) B-NOR (L3 H7)))
                 NIL))

(DEFN DECODE-5&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'DECODE-5 NETLIST)
                  (DECODE-5*))
           (B-NOT& (DELETE-MODULE 'DECODE-5 NETLIST))
           (B-NAND& (DELETE-MODULE 'DECODE-5 NETLIST))
           (B-NAND3& (DELETE-MODULE 'DECODE-5 NETLIST))
           (B-NOR& (DELETE-MODULE 'DECODE-5 NETLIST))))

(TOGGLE DECODE-5&-OFF DECODE-5& T)

(DEFN DECODE-5$NETLIST NIL
      (CONS (DECODE-5*)
            (UNION (UNION (UNION (B-NOT$NETLIST)
                                 (B-NAND$NETLIST))
                          (B-NAND3$NETLIST))
                   (B-NOR$NETLIST))))

(PROVE-LEMMA PROPERP-LENGTH-F$DECODE-5
             (REWRITE)
             (AND (PROPERP (F$DECODE-5 S))
                  (EQUAL (LENGTH (F$DECODE-5 S)) 32))
             ((ENABLE F$DECODE-5)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA DECODE-5$VALUE
             (REWRITE)
             (IMPLIES (AND (DECODE-5& NETLIST)
                           (EQUAL (LENGTH S) 5))
                      (EQUAL (DUAL-EVAL 0 'DECODE-5
                                        S STATE NETLIST)
                             (F$DECODE-5 S)))
             ((ENABLE F$DECODE-5 DECODE-5& EQUAL-LENGTH-ADD1 B-NOT$VALUE
                      B-NAND$VALUE B-NAND3$VALUE B-NOR$VALUE)
              (DISABLE-THEORY F-GATES B-GATES)
              (DISABLE CONS-EQUAL)))

(PROVE-LEMMA F$DECODE-5=DECODE-5
             (REWRITE)
             (IMPLIES (AND (BVP S) (EQUAL (LENGTH S) 5))
                      (EQUAL (F$DECODE-5 S) (DECODE-5 S)))
             ((ENABLE F$DECODE-5 DECODE-5 BOOLP-B-GATES EQUAL-LENGTH-ADD1 BVP)
              (DISABLE-THEORY F-GATES B-GATES)
              (DISABLE CONS-EQUAL)))

(TOGGLE DECODE-5$VALUE-OFF DECODE-5$VALUE T)

(DEFN ENCODE-32
      (S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 S16 S17 S18 S19
          S20 S21 S22 S23 S24 S25 S26 S27 S28 S29 S30 S31)
      (LIST (B-NAND4 (B-NOR4 S1 S3 S5 S7)
                     (B-NOR4 S9 S11 S13 S15)
                     (B-NOR4 S17 S19 S21 S23)
                     (B-NOR S25 S29))
            (B-NAND4 (B-NOR4 S2 S3 S6 S7)
                     (B-NOR4 S10 S11 S14 S15)
                     (B-NOR4 S18 S19 S22 S23)
                     (B-NOT S30))
            (B-NAND4 (B-NOR4 S4 S5 S6 S7)
                     (B-NOR4 S12 S13 S14 S15)
                     (B-NOR4 S20 S21 S22 S23)
                     (B-NOR3 S28 S29 S30))
            (B-NAND4 (B-NOR4 S8 S9 S10 S11)
                     (B-NOR4 S12 S13 S14 S15)
                     (B-NOR S24 S25)
                     (B-NOR3 S28 S29 S30))
            (B-NAND4 (B-NOR4 S16 S17 S18 S19)
                     (B-NOR4 S20 S21 S22 S23)
                     (B-NOR S24 S25)
                     (B-NOR3 S28 S29 S30))))

(TOGGLE ENCODE-32-OFF ENCODE-32 T)

(DEFN F$ENCODE-32
      (S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 S16 S17 S18 S19
          S20 S21 S22 S23 S24 S25 S26 S27 S28 S29 S30 S31)
      (LIST (F-NAND4 (F-NOR4 S1 S3 S5 S7)
                     (F-NOR4 S9 S11 S13 S15)
                     (F-NOR4 S17 S19 S21 S23)
                     (F-NOR S25 S29))
            (F-NAND4 (F-NOR4 S2 S3 S6 S7)
                     (F-NOR4 S10 S11 S14 S15)
                     (F-NOR4 S18 S19 S22 S23)
                     (F-NOT S30))
            (F-NAND4 (F-NOR4 S4 S5 S6 S7)
                     (F-NOR4 S12 S13 S14 S15)
                     (F-NOR4 S20 S21 S22 S23)
                     (F-NOR3 S28 S29 S30))
            (F-NAND4 (F-NOR4 S8 S9 S10 S11)
                     (F-NOR4 S12 S13 S14 S15)
                     (F-NOR S24 S25)
                     (F-NOR3 S28 S29 S30))
            (F-NAND4 (F-NOR4 S16 S17 S18 S19)
                     (F-NOR4 S20 S21 S22 S23)
                     (F-NOR S24 S25)
                     (F-NOR3 S28 S29 S30))))

(TOGGLE F$ENCODE-32-OFF F$ENCODE-32 T)

(DEFN ENCODE-32* NIL
      '(ENCODE-32 (S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 S16
                      S17 S18 S19 S20 S21 S22 S23 S24 S25 S26 S27 S28 S29 S30
                      S31)
                  (W-4 W-9 W-14 W-19 W-24)
                  ((G-23 (W-23) B-NOR3 (S28 S29 S30))
                   (G-22 (W-22) B-NOR (S24 S25))
                   (G-21 (W-21) B-NOR4 (S20 S21 S22 S23))
                   (G-20 (W-20) B-NOR4 (S16 S17 S18 S19))
                   (G-24 (W-24)
                         B-NAND4
                         (W-20 W-21 W-22 W-23))
                   (G-16 (W-16) B-NOR4 (S12 S13 S14 S15))
                   (G-15 (W-15) B-NOR4 (S8 S9 S10 S11))
                   (G-19 (W-19)
                         B-NAND4
                         (W-15 W-16 W-22 W-23))
                   (G-10 (W-10) B-NOR4 (S4 S5 S6 S7))
                   (G-14 (W-14)
                         B-NAND4
                         (W-10 W-16 W-21 W-23))
                   (G-8 (W-8) B-NOT (S30))
                   (G-7 (W-7) B-NOR4 (S18 S19 S22 S23))
                   (G-6 (W-6) B-NOR4 (S10 S11 S14 S15))
                   (G-5 (W-5) B-NOR4 (S2 S3 S6 S7))
                   (G-9 (W-9) B-NAND4 (W-5 W-6 W-7 W-8))
                   (G-3 (W-3) B-NOR (S25 S29))
                   (G-2 (W-2) B-NOR4 (S17 S19 S21 S23))
                   (G-1 (W-1) B-NOR4 (S9 S11 S13 S15))
                   (G-0 (W-0) B-NOR4 (S1 S3 S5 S7))
                   (G-4 (W-4) B-NAND4 (W-0 W-1 W-2 W-3)))
                  NIL))

(DEFN ENCODE-32&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'ENCODE-32 NETLIST)
                  (ENCODE-32*))
           (B-NOR3& (DELETE-MODULE 'ENCODE-32 NETLIST))
           (B-NOT& (DELETE-MODULE 'ENCODE-32 NETLIST))
           (B-NOR& (DELETE-MODULE 'ENCODE-32 NETLIST))
           (B-NOR4& (DELETE-MODULE 'ENCODE-32 NETLIST))
           (B-NAND4& (DELETE-MODULE 'ENCODE-32 NETLIST))))

(TOGGLE ENCODE-32&-OFF ENCODE-32& T)

(DEFN ENCODE-32$NETLIST NIL
      (CONS (ENCODE-32*)
            (UNION (UNION (UNION (UNION (B-NOR3$NETLIST)
                                        (B-NOT$NETLIST))
                                 (B-NOR$NETLIST))
                          (B-NOR4$NETLIST))
                   (B-NAND4$NETLIST))))

(PROVE-LEMMA ENCODE-32$VALUE
             (REWRITE)
             (IMPLIES (ENCODE-32& NETLIST)
                      (EQUAL (DUAL-EVAL 0 'ENCODE-32
                                        (LIST S0 S1 S2 S3 S4 S5 S6 S7 S8 S9
                                              S10 S11 S12 S13 S14 S15 S16 S17
                                              S18 S19 S20 S21 S22 S23 S24 S25
                                              S26 S27 S28 S29 S30 S31)
                                        STATE NETLIST)
                             (F$ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10
                                          S11 S12 S13 S14 S15 S16 S17 S18
                                          S19 S20 S21 S22 S23 S24 S25 S26
                                          S27 S28 S29 S30 S31)))
             ((ENABLE ENCODE-32& F$ENCODE-32 B-NOR3$VALUE B-NOT$VALUE
                      B-NOR$VALUE B-NOR4$VALUE B-NAND4$VALUE)
              (DISABLE-THEORY F-GATES)))

(TOGGLE ENCODE-32$VALUE-OFF ENCODE-32$VALUE T)

(PROVE-LEMMA F$ENCODE-32=ENCODE-32
             (REWRITE)
             (IMPLIES (AND (BOOLP S0)
                           (BOOLP S1)
                           (BOOLP S2)
                           (BOOLP S3)
                           (BOOLP S4)
                           (BOOLP S5)
                           (BOOLP S6)
                           (BOOLP S7)
                           (BOOLP S8)
                           (BOOLP S9)
                           (BOOLP S10)
                           (BOOLP S11)
                           (BOOLP S12)
                           (BOOLP S13)
                           (BOOLP S14)
                           (BOOLP S15)
                           (BOOLP S16)
                           (BOOLP S17)
                           (BOOLP S18)
                           (BOOLP S19)
                           (BOOLP S20)
                           (BOOLP S21)
                           (BOOLP S22)
                           (BOOLP S23)
                           (BOOLP S24)
                           (BOOLP S25)
                           (BOOLP S26)
                           (BOOLP S27)
                           (BOOLP S28)
                           (BOOLP S29)
                           (BOOLP S30)
                           (BOOLP S31))
                      (EQUAL (F$ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10
                                          S11 S12 S13 S14 S15 S16 S17 S18 S19
                                          S20 S21 S22 S23 S24 S25 S26 S27 S28
                                          S29 S30 S31)
                             (ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10
                                        S11 S12 S13 S14 S15 S16 S17 S18 S19
                                        S20 S21 S22 S23 S24 S25 S26 S27 S28
                                        S29 S30 S31)))
             ((ENABLE BOOLP-B-GATES F$ENCODE-32 ENCODE-32)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA BVP-LENGTH-ENCODE-32
             (REWRITE)
             (AND (BVP (ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12
                                  S13 S14 S15 S16 S17 S18 S19 S20 S21 S22 S23
                                  S24 S25 S26 S27 S28 S29 S30 S31))
                  (EQUAL (LENGTH (ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10
                                            S11 S12 S13 S14 S15 S16 S17 S18
                                            S19 S20 S21 S22 S23 S24 S25 S26
                                            S27 S28 S29 S30 S31))
                         5))
             ((ENABLE ENCODE-32)))

(PROVE-LEMMA PROPERP-LENGTH-F$ENCODE-32
             (REWRITE)
             (AND (PROPERP (F$ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11
                                        S12 S13 S14 S15 S16 S17 S18 S19 S20
                                        S21 S22 S23 S24 S25 S26 S27 S28 S29
                                        S30 S31))
                  (EQUAL (LENGTH (F$ENCODE-32 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9
                                              S10 S11 S12 S13 S14 S15 S16 S17
                                              S18 S19 S20 S21 S22 S23 S24 S25
                                              S26 S27 S28 S29 S30 S31))
                         5))
             ((ENABLE F$ENCODE-32)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA DUAL-EVAL-ON-COLLECTED-NTH-32 NIL
             (IMPLIES (AND (EQUAL (LENGTH ARGS) 32)
                           (PROPERP ARGS))
                      (EQUAL (DUAL-EVAL FLAG NAME ARGS STATE NETLIST)
                             (DUAL-EVAL FLAG NAME
                                        (LIST (NTH 0 ARGS)
                                              (NTH 1 ARGS)
                                              (NTH 2 ARGS)
                                              (NTH 3 ARGS)
                                              (NTH 4 ARGS)
                                              (NTH 5 ARGS)
                                              (NTH 6 ARGS)
                                              (NTH 7 ARGS)
                                              (NTH 8 ARGS)
                                              (NTH 9 ARGS)
                                              (NTH 10 ARGS)
                                              (NTH 11 ARGS)
                                              (NTH 12 ARGS)
                                              (NTH 13 ARGS)
                                              (NTH 14 ARGS)
                                              (NTH 15 ARGS)
                                              (NTH 16 ARGS)
                                              (NTH 17 ARGS)
                                              (NTH 18 ARGS)
                                              (NTH 19 ARGS)
                                              (NTH 20 ARGS)
                                              (NTH 21 ARGS)
                                              (NTH 22 ARGS)
                                              (NTH 23 ARGS)
                                              (NTH 24 ARGS)
                                              (NTH 25 ARGS)
                                              (NTH 26 ARGS)
                                              (NTH 27 ARGS)
                                              (NTH 28 ARGS)
                                              (NTH 29 ARGS)
                                              (NTH 30 ARGS)
                                              (NTH 31 ARGS))
                                        STATE NETLIST)))
             ((USE (EQUAL-LENGTH-32-AS-COLLECTED-NTH (L ARGS)))))

(PROVE-LEMMA ENCODE-32$VALUE-ON-A-VECTOR
             (REWRITE)
             (IMPLIES (AND (ENCODE-32& NETLIST)
                           (PROPERP ARGS)
                           (EQUAL (LENGTH ARGS) 32))
                      (EQUAL (DUAL-EVAL 0 'ENCODE-32
                                        ARGS STATE NETLIST)
                             (F$ENCODE-32 (NTH 0 ARGS)
                                          (NTH 1 ARGS)
                                          (NTH 2 ARGS)
                                          (NTH 3 ARGS)
                                          (NTH 4 ARGS)
                                          (NTH 5 ARGS)
                                          (NTH 6 ARGS)
                                          (NTH 7 ARGS)
                                          (NTH 8 ARGS)
                                          (NTH 9 ARGS)
                                          (NTH 10 ARGS)
                                          (NTH 11 ARGS)
                                          (NTH 12 ARGS)
                                          (NTH 13 ARGS)
                                          (NTH 14 ARGS)
                                          (NTH 15 ARGS)
                                          (NTH 16 ARGS)
                                          (NTH 17 ARGS)
                                          (NTH 18 ARGS)
                                          (NTH 19 ARGS)
                                          (NTH 20 ARGS)
                                          (NTH 21 ARGS)
                                          (NTH 22 ARGS)
                                          (NTH 23 ARGS)
                                          (NTH 24 ARGS)
                                          (NTH 25 ARGS)
                                          (NTH 26 ARGS)
                                          (NTH 27 ARGS)
                                          (NTH 28 ARGS)
                                          (NTH 29 ARGS)
                                          (NTH 30 ARGS)
                                          (NTH 31 ARGS))))
             ((DISABLE F$ENCODE-32 *1*ENCODE-32)
              (ENABLE ENCODE-32$VALUE)
              (USE (DUAL-EVAL-ON-COLLECTED-NTH-32 (FLAG 0)
                                                  (NAME 'ENCODE-32)
                                                  (ARGS ARGS)
                                                  (STATE STATE)
                                                  (NETLIST NETLIST)))))

(TOGGLE ENCODE-32$VALUE-ON-A-VECTOR-OFF ENCODE-32$VALUE-ON-A-VECTOR T)

(DEFN SET-SOME-FLAGS
      (SET-FLAGS)
      (OR (Z-SET SET-FLAGS)
          (N-SET SET-FLAGS)
          (V-SET SET-FLAGS)
          (C-SET SET-FLAGS)))

(TOGGLE SET-SOME-FLAGS-OFF SET-SOME-FLAGS T)

(PROVE-LEMMA NOT-SET-SOME-FLAGS-MAKE-LIST-4-F
             (REWRITE)
             (NOT (SET-SOME-FLAGS (MAKE-LIST 4 F))))

(DEFN FLAGS-HYPS
      (FLAGS)
      (AND (EQUAL (LENGTH FLAGS) 4)
           (BVP FLAGS)))

(PROVE-LEMMA NOT-SET-SOME-FLAGS-UPDATE-FLAGS
             (REWRITE)
             (IMPLIES (AND (FLAGS-HYPS FLAGS)
                           (NOT (SET-SOME-FLAGS SET-FLAGS)))
                      (EQUAL (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)
                             FLAGS))
             ((ENABLE SET-SOME-FLAGS UPDATE-FLAGS OPEN-NTH C-FLAG V-FLAG
                      N-FLAG Z-FLAG EQUAL-LENGTH-ADD1)))

(PROVE-LEMMA BOOLP-C-FLAG
             (REWRITE)
             (IMPLIES (FLAGS-HYPS FLAGS)
                      (BOOLP (C-FLAG FLAGS)))
             ((ENABLE C-FLAG)))

(DEFN F$SET-SOME-FLAGS
      (SET-FLAGS)
      (F-OR4 (CAR SET-FLAGS)
             (CADR SET-FLAGS)
             (CADDR SET-FLAGS)
             (CADDDR SET-FLAGS)))

(TOGGLE F$SET-SOME-FLAGS-OFF F$SET-SOME-FLAGS T)

(PROVE-LEMMA F$SET-SOME-FLAGS=SET-SOME=FLAGS
             (REWRITE)
             (IMPLIES (AND (BVP SET-FLAGS)
                           (EQUAL (LENGTH SET-FLAGS) 4))
                      (EQUAL (F$SET-SOME-FLAGS SET-FLAGS)
                             (SET-SOME-FLAGS SET-FLAGS)))
             ((ENABLE F$SET-SOME-FLAGS SET-SOME-FLAGS EQUAL-LENGTH-ADD1
                      OPEN-NTH C-SET V-SET N-SET Z-SET BOOLP-B-GATES)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA B-OR4$VALUE-AS-F$SET-SOME-FLAGS
             (REWRITE)
             (IMPLIES (AND (B-OR4& NETLIST)
                           (PROPERP SET-FLAGS)
                           (EQUAL (LENGTH SET-FLAGS) 4))
                      (EQUAL (DUAL-EVAL 0 'B-OR4
                                        SET-FLAGS STATE NETLIST)
                             (LIST (F$SET-SOME-FLAGS SET-FLAGS))))
             ((ENABLE B-OR4$VALUE EQUAL-LENGTH-ADD1 F$SET-SOME-FLAGS)))

(TOGGLE B-OR4$VALUE-AS-F$SET-SOME-FLAGS-OFF B-OR4$VALUE-AS-F$SET-SOME-FLAGS T)

(DEFN F$ALL-T-REGS-ADDRESS
      (REGS-ADDRESS)
      (F-AND4 (CAR REGS-ADDRESS)
              (CADR REGS-ADDRESS)
              (CADDR REGS-ADDRESS)
              (CADDDR REGS-ADDRESS)))

(TOGGLE F$ALL-T-REGS-ADDRESS-OFF F$ALL-T-REGS-ADDRESS T)

(PROVE-LEMMA F$ALL-T-REGS-ADDRESS=SET-SOME=FLAGS
             (REWRITE)
             (IMPLIES (AND (BVP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4))
                      (EQUAL (F$ALL-T-REGS-ADDRESS REGS-ADDRESS)
                             (EQUAL REGS-ADDRESS (MAKE-LIST 4 T))))
             ((ENABLE F$ALL-T-REGS-ADDRESS EQUAL-LENGTH-ADD1 BOOLP-B-GATES
                      OPEN-MAKE-LIST)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA B-AND4$VALUE-AS-F$ALL-T-REGS-ADDRESS
             (REWRITE)
             (IMPLIES (AND (B-AND4& NETLIST)
                           (PROPERP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4))
                      (EQUAL (DUAL-EVAL 0 'B-AND4
                                        REGS-ADDRESS STATE NETLIST)
                             (LIST (F$ALL-T-REGS-ADDRESS REGS-ADDRESS))))
             ((ENABLE B-AND4& B-AND4$VALUE EQUAL-LENGTH-ADD1
                      F$ALL-T-REGS-ADDRESS PROPERP)))

(TOGGLE B-AND4$VALUE-AS-F$ALL-T-REGS-ADDRESS-OFF
        B-AND4$VALUE-AS-F$ALL-T-REGS-ADDRESS T)

(DEFN CV-HYPS
      (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
      (AND (BOOLP RW-)
           (EQUAL (LENGTH REGS-ADDRESS) 4)
           (BVP REGS-ADDRESS)
           (EQUAL (LENGTH I-REG) 32)
           (BVP I-REG)
           (FLAGS-HYPS FLAGS)
           (EQUAL (LENGTH PC-REG) 4)
           (BVP PC-REG)))

(DEFN V_FETCH0 NIL (LIST F F F F F))

(TOGGLE V_FETCH0-OFF V_FETCH0 T)

(TOGGLE G*1*V_FETCH0-OFF *1*V_FETCH0 T)

(DEFN N_FETCH0 NIL
      (V-TO-NAT (LIST F F F F F)))

(TOGGLE N_FETCH0-OFF N_FETCH0 T)

(TOGGLE G*1*N_FETCH0-OFF *1*N_FETCH0 T)

(DEFN V_FETCH1 NIL (LIST T F F F F))

(TOGGLE V_FETCH1-OFF V_FETCH1 T)

(TOGGLE G*1*V_FETCH1-OFF *1*V_FETCH1 T)

(DEFN N_FETCH1 NIL
      (V-TO-NAT (LIST T F F F F)))

(TOGGLE N_FETCH1-OFF N_FETCH1 T)

(TOGGLE G*1*N_FETCH1-OFF *1*N_FETCH1 T)

(DEFN V_FETCH2 NIL (LIST F T F F F))

(TOGGLE V_FETCH2-OFF V_FETCH2 T)

(TOGGLE G*1*V_FETCH2-OFF *1*V_FETCH2 T)

(DEFN N_FETCH2 NIL
      (V-TO-NAT (LIST F T F F F)))

(TOGGLE N_FETCH2-OFF N_FETCH2 T)

(TOGGLE G*1*N_FETCH2-OFF *1*N_FETCH2 T)

(DEFN V_FETCH3 NIL (LIST T T F F F))

(TOGGLE V_FETCH3-OFF V_FETCH3 T)

(TOGGLE G*1*V_FETCH3-OFF *1*V_FETCH3 T)

(DEFN N_FETCH3 NIL
      (V-TO-NAT (LIST T T F F F)))

(TOGGLE N_FETCH3-OFF N_FETCH3 T)

(TOGGLE G*1*N_FETCH3-OFF *1*N_FETCH3 T)

(DEFN V_DECODE NIL (LIST F F T F F))

(TOGGLE V_DECODE-OFF V_DECODE T)

(TOGGLE G*1*V_DECODE-OFF *1*V_DECODE T)

(DEFN N_DECODE NIL
      (V-TO-NAT (LIST F F T F F)))

(TOGGLE N_DECODE-OFF N_DECODE T)

(TOGGLE G*1*N_DECODE-OFF *1*N_DECODE T)

(DEFN V_REGA NIL (LIST T F T F F))

(TOGGLE V_REGA-OFF V_REGA T)

(TOGGLE G*1*V_REGA-OFF *1*V_REGA T)

(DEFN N_REGA NIL
      (V-TO-NAT (LIST T F T F F)))

(TOGGLE N_REGA-OFF N_REGA T)

(TOGGLE G*1*N_REGA-OFF *1*N_REGA T)

(DEFN V_REGB NIL (LIST F T T F F))

(TOGGLE V_REGB-OFF V_REGB T)

(TOGGLE G*1*V_REGB-OFF *1*V_REGB T)

(DEFN N_REGB NIL
      (V-TO-NAT (LIST F T T F F)))

(TOGGLE N_REGB-OFF N_REGB T)

(TOGGLE G*1*N_REGB-OFF *1*N_REGB T)

(DEFN V_UPDATE NIL (LIST T T T F F))

(TOGGLE V_UPDATE-OFF V_UPDATE T)

(TOGGLE G*1*V_UPDATE-OFF *1*V_UPDATE T)

(DEFN N_UPDATE NIL
      (V-TO-NAT (LIST T T T F F)))

(TOGGLE N_UPDATE-OFF N_UPDATE T)

(TOGGLE G*1*N_UPDATE-OFF *1*N_UPDATE T)

(DEFN V_READA0 NIL (LIST F F F T F))

(TOGGLE V_READA0-OFF V_READA0 T)

(TOGGLE G*1*V_READA0-OFF *1*V_READA0 T)

(DEFN N_READA0 NIL
      (V-TO-NAT (LIST F F F T F)))

(TOGGLE N_READA0-OFF N_READA0 T)

(TOGGLE G*1*N_READA0-OFF *1*N_READA0 T)

(DEFN V_READA1 NIL (LIST T F F T F))

(TOGGLE V_READA1-OFF V_READA1 T)

(TOGGLE G*1*V_READA1-OFF *1*V_READA1 T)

(DEFN N_READA1 NIL
      (V-TO-NAT (LIST T F F T F)))

(TOGGLE N_READA1-OFF N_READA1 T)

(TOGGLE G*1*N_READA1-OFF *1*N_READA1 T)

(DEFN V_READA2 NIL (LIST F T F T F))

(TOGGLE V_READA2-OFF V_READA2 T)

(TOGGLE G*1*V_READA2-OFF *1*V_READA2 T)

(DEFN N_READA2 NIL
      (V-TO-NAT (LIST F T F T F)))

(TOGGLE N_READA2-OFF N_READA2 T)

(TOGGLE G*1*N_READA2-OFF *1*N_READA2 T)

(DEFN V_READA3 NIL (LIST T T F T F))

(TOGGLE V_READA3-OFF V_READA3 T)

(TOGGLE G*1*V_READA3-OFF *1*V_READA3 T)

(DEFN N_READA3 NIL
      (V-TO-NAT (LIST T T F T F)))

(TOGGLE N_READA3-OFF N_READA3 T)

(TOGGLE G*1*N_READA3-OFF *1*N_READA3 T)

(DEFN V_READB0 NIL (LIST F F T T F))

(TOGGLE V_READB0-OFF V_READB0 T)

(TOGGLE G*1*V_READB0-OFF *1*V_READB0 T)

(DEFN N_READB0 NIL
      (V-TO-NAT (LIST F F T T F)))

(TOGGLE N_READB0-OFF N_READB0 T)

(TOGGLE G*1*N_READB0-OFF *1*N_READB0 T)

(DEFN V_READB1 NIL (LIST T F T T F))

(TOGGLE V_READB1-OFF V_READB1 T)

(TOGGLE G*1*V_READB1-OFF *1*V_READB1 T)

(DEFN N_READB1 NIL
      (V-TO-NAT (LIST T F T T F)))

(TOGGLE N_READB1-OFF N_READB1 T)

(TOGGLE G*1*N_READB1-OFF *1*N_READB1 T)

(DEFN V_READB2 NIL (LIST F T T T F))

(TOGGLE V_READB2-OFF V_READB2 T)

(TOGGLE G*1*V_READB2-OFF *1*V_READB2 T)

(DEFN N_READB2 NIL
      (V-TO-NAT (LIST F T T T F)))

(TOGGLE N_READB2-OFF N_READB2 T)

(TOGGLE G*1*N_READB2-OFF *1*N_READB2 T)

(DEFN V_READB3 NIL (LIST T T T T F))

(TOGGLE V_READB3-OFF V_READB3 T)

(TOGGLE G*1*V_READB3-OFF *1*V_READB3 T)

(DEFN N_READB3 NIL
      (V-TO-NAT (LIST T T T T F)))

(TOGGLE N_READB3-OFF N_READB3 T)

(TOGGLE G*1*N_READB3-OFF *1*N_READB3 T)

(DEFN V_WRITE0 NIL (LIST F F F F T))

(TOGGLE V_WRITE0-OFF V_WRITE0 T)

(TOGGLE G*1*V_WRITE0-OFF *1*V_WRITE0 T)

(DEFN N_WRITE0 NIL
      (V-TO-NAT (LIST F F F F T)))

(TOGGLE N_WRITE0-OFF N_WRITE0 T)

(TOGGLE G*1*N_WRITE0-OFF *1*N_WRITE0 T)

(DEFN V_WRITE1 NIL (LIST T F F F T))

(TOGGLE V_WRITE1-OFF V_WRITE1 T)

(TOGGLE G*1*V_WRITE1-OFF *1*V_WRITE1 T)

(DEFN N_WRITE1 NIL
      (V-TO-NAT (LIST T F F F T)))

(TOGGLE N_WRITE1-OFF N_WRITE1 T)

(TOGGLE G*1*N_WRITE1-OFF *1*N_WRITE1 T)

(DEFN V_WRITE2 NIL (LIST F T F F T))

(TOGGLE V_WRITE2-OFF V_WRITE2 T)

(TOGGLE G*1*V_WRITE2-OFF *1*V_WRITE2 T)

(DEFN N_WRITE2 NIL
      (V-TO-NAT (LIST F T F F T)))

(TOGGLE N_WRITE2-OFF N_WRITE2 T)

(TOGGLE G*1*N_WRITE2-OFF *1*N_WRITE2 T)

(DEFN V_WRITE3 NIL (LIST T T F F T))

(TOGGLE V_WRITE3-OFF V_WRITE3 T)

(TOGGLE G*1*V_WRITE3-OFF *1*V_WRITE3 T)

(DEFN N_WRITE3 NIL
      (V-TO-NAT (LIST T T F F T)))

(TOGGLE N_WRITE3-OFF N_WRITE3 T)

(TOGGLE G*1*N_WRITE3-OFF *1*N_WRITE3 T)

(DEFN V_SEFA0 NIL (LIST F F T F T))

(TOGGLE V_SEFA0-OFF V_SEFA0 T)

(TOGGLE G*1*V_SEFA0-OFF *1*V_SEFA0 T)

(DEFN N_SEFA0 NIL
      (V-TO-NAT (LIST F F T F T)))

(TOGGLE N_SEFA0-OFF N_SEFA0 T)

(TOGGLE G*1*N_SEFA0-OFF *1*N_SEFA0 T)

(DEFN V_SEFA1 NIL (LIST T F T F T))

(TOGGLE V_SEFA1-OFF V_SEFA1 T)

(TOGGLE G*1*V_SEFA1-OFF *1*V_SEFA1 T)

(DEFN N_SEFA1 NIL
      (V-TO-NAT (LIST T F T F T)))

(TOGGLE N_SEFA1-OFF N_SEFA1 T)

(TOGGLE G*1*N_SEFA1-OFF *1*N_SEFA1 T)

(DEFN V_SEFB0 NIL (LIST F T T F T))

(TOGGLE V_SEFB0-OFF V_SEFB0 T)

(TOGGLE G*1*V_SEFB0-OFF *1*V_SEFB0 T)

(DEFN N_SEFB0 NIL
      (V-TO-NAT (LIST F T T F T)))

(TOGGLE N_SEFB0-OFF N_SEFB0 T)

(TOGGLE G*1*N_SEFB0-OFF *1*N_SEFB0 T)

(DEFN V_SEFB1 NIL (LIST T T T F T))

(TOGGLE V_SEFB1-OFF V_SEFB1 T)

(TOGGLE G*1*V_SEFB1-OFF *1*V_SEFB1 T)

(DEFN N_SEFB1 NIL
      (V-TO-NAT (LIST T T T F T)))

(TOGGLE N_SEFB1-OFF N_SEFB1 T)

(TOGGLE G*1*N_SEFB1-OFF *1*N_SEFB1 T)

(DEFN V_HOLD0 NIL (LIST F F F T T))

(TOGGLE V_HOLD0-OFF V_HOLD0 T)

(TOGGLE G*1*V_HOLD0-OFF *1*V_HOLD0 T)

(DEFN N_HOLD0 NIL
      (V-TO-NAT (LIST F F F T T)))

(TOGGLE N_HOLD0-OFF N_HOLD0 T)

(TOGGLE G*1*N_HOLD0-OFF *1*N_HOLD0 T)

(DEFN V_HOLD1 NIL (LIST T F F T T))

(TOGGLE V_HOLD1-OFF V_HOLD1 T)

(TOGGLE G*1*V_HOLD1-OFF *1*V_HOLD1 T)

(DEFN N_HOLD1 NIL
      (V-TO-NAT (LIST T F F T T)))

(TOGGLE N_HOLD1-OFF N_HOLD1 T)

(TOGGLE G*1*N_HOLD1-OFF *1*N_HOLD1 T)

(DEFN V_V11010 NIL (LIST F T F T T))

(TOGGLE V_V11010-OFF V_V11010 T)

(TOGGLE G*1*V_V11010-OFF *1*V_V11010 T)

(DEFN N_V11010 NIL
      (V-TO-NAT (LIST F T F T T)))

(TOGGLE N_V11010-OFF N_V11010 T)

(TOGGLE G*1*N_V11010-OFF *1*N_V11010 T)

(DEFN V_V11011 NIL (LIST T T F T T))

(TOGGLE V_V11011-OFF V_V11011 T)

(TOGGLE G*1*V_V11011-OFF *1*V_V11011 T)

(DEFN N_V11011 NIL
      (V-TO-NAT (LIST T T F T T)))

(TOGGLE N_V11011-OFF N_V11011 T)

(TOGGLE G*1*N_V11011-OFF *1*N_V11011 T)

(DEFN V_RESET0 NIL (LIST F F T T T))

(TOGGLE V_RESET0-OFF V_RESET0 T)

(TOGGLE G*1*V_RESET0-OFF *1*V_RESET0 T)

(DEFN N_RESET0 NIL
      (V-TO-NAT (LIST F F T T T)))

(TOGGLE N_RESET0-OFF N_RESET0 T)

(TOGGLE G*1*N_RESET0-OFF *1*N_RESET0 T)

(DEFN V_RESET1 NIL (LIST T F T T T))

(TOGGLE V_RESET1-OFF V_RESET1 T)

(TOGGLE G*1*V_RESET1-OFF *1*V_RESET1 T)

(DEFN N_RESET1 NIL
      (V-TO-NAT (LIST T F T T T)))

(TOGGLE N_RESET1-OFF N_RESET1 T)

(TOGGLE G*1*N_RESET1-OFF *1*N_RESET1 T)

(DEFN V_RESET2 NIL (LIST F T T T T))

(TOGGLE V_RESET2-OFF V_RESET2 T)

(TOGGLE G*1*V_RESET2-OFF *1*V_RESET2 T)

(DEFN N_RESET2 NIL
      (V-TO-NAT (LIST F T T T T)))

(TOGGLE N_RESET2-OFF N_RESET2 T)

(TOGGLE G*1*N_RESET2-OFF *1*N_RESET2 T)

(DEFN V_V11111 NIL (LIST T T T T T))

(TOGGLE V_V11111-OFF V_V11111 T)

(TOGGLE G*1*V_V11111-OFF *1*V_V11111 T)

(DEFN N_V11111 NIL
      (V-TO-NAT (LIST T T T T T)))

(TOGGLE N_V11111-OFF N_V11111 T)

(TOGGLE G*1*N_V11111-OFF *1*N_V11111 T)

(DEFTHEORY VECTOR-STATE-THEORY
           (V_FETCH0 V_FETCH1 V_FETCH2 V_FETCH3 V_DECODE V_REGA V_REGB
                     V_UPDATE V_READA0 V_READA1 V_READA2 V_READA3 V_READB0
                     V_READB1 V_READB2 V_READB3 V_WRITE0 V_WRITE1 V_WRITE2
                     V_WRITE3 V_SEFA0 V_SEFA1 V_SEFB0 V_SEFB1 V_HOLD0 V_HOLD1
                     V_V11010 V_V11011 V_RESET0 V_RESET1 V_RESET2 V_V11111))

(DEFTHEORY NATURAL-STATE-THEORY
           (N_FETCH0 N_FETCH1 N_FETCH2 N_FETCH3 N_DECODE N_REGA N_REGB
                     N_UPDATE N_READA0 N_READA1 N_READA2 N_READA3 N_READB0
                     N_READB1 N_READB2 N_READB3 N_WRITE0 N_WRITE1 N_WRITE2
                     N_WRITE3 N_SEFA0 N_SEFA1 N_SEFB0 N_SEFB1 N_HOLD0 N_HOLD1
                     N_V11010 N_V11011 N_RESET0 N_RESET1 N_RESET2 N_V11111))

(PROVE-LEMMA BVP-LENGTH-STATE-VECTORS
             (REWRITE)
             (AND (EQUAL (LENGTH (V_FETCH0)) 5)
                  (BVP (V_FETCH0))
                  (EQUAL (LENGTH (V_FETCH1)) 5)
                  (BVP (V_FETCH1))
                  (EQUAL (LENGTH (V_FETCH2)) 5)
                  (BVP (V_FETCH2))
                  (EQUAL (LENGTH (V_FETCH3)) 5)
                  (BVP (V_FETCH3))
                  (EQUAL (LENGTH (V_DECODE)) 5)
                  (BVP (V_DECODE))
                  (EQUAL (LENGTH (V_REGA)) 5)
                  (BVP (V_REGA))
                  (EQUAL (LENGTH (V_REGB)) 5)
                  (BVP (V_REGB))
                  (EQUAL (LENGTH (V_UPDATE)) 5)
                  (BVP (V_UPDATE))
                  (EQUAL (LENGTH (V_READA0)) 5)
                  (BVP (V_READA0))
                  (EQUAL (LENGTH (V_READA1)) 5)
                  (BVP (V_READA1))
                  (EQUAL (LENGTH (V_READA2)) 5)
                  (BVP (V_READA2))
                  (EQUAL (LENGTH (V_READA3)) 5)
                  (BVP (V_READA3))
                  (EQUAL (LENGTH (V_READB0)) 5)
                  (BVP (V_READB0))
                  (EQUAL (LENGTH (V_READB1)) 5)
                  (BVP (V_READB1))
                  (EQUAL (LENGTH (V_READB2)) 5)
                  (BVP (V_READB2))
                  (EQUAL (LENGTH (V_READB3)) 5)
                  (BVP (V_READB3))
                  (EQUAL (LENGTH (V_WRITE0)) 5)
                  (BVP (V_WRITE0))
                  (EQUAL (LENGTH (V_WRITE1)) 5)
                  (BVP (V_WRITE1))
                  (EQUAL (LENGTH (V_WRITE2)) 5)
                  (BVP (V_WRITE2))
                  (EQUAL (LENGTH (V_WRITE3)) 5)
                  (BVP (V_WRITE3))
                  (EQUAL (LENGTH (V_SEFA0)) 5)
                  (BVP (V_SEFA0))
                  (EQUAL (LENGTH (V_SEFA1)) 5)
                  (BVP (V_SEFA1))
                  (EQUAL (LENGTH (V_SEFB0)) 5)
                  (BVP (V_SEFB0))
                  (EQUAL (LENGTH (V_SEFB1)) 5)
                  (BVP (V_SEFB1))
                  (EQUAL (LENGTH (V_HOLD0)) 5)
                  (BVP (V_HOLD0))
                  (EQUAL (LENGTH (V_HOLD1)) 5)
                  (BVP (V_HOLD1))
                  (EQUAL (LENGTH (V_V11010)) 5)
                  (BVP (V_V11010))
                  (EQUAL (LENGTH (V_V11011)) 5)
                  (BVP (V_V11011))
                  (EQUAL (LENGTH (V_RESET0)) 5)
                  (BVP (V_RESET0))
                  (EQUAL (LENGTH (V_RESET1)) 5)
                  (BVP (V_RESET1))
                  (EQUAL (LENGTH (V_RESET2)) 5)
                  (BVP (V_RESET2))
                  (EQUAL (LENGTH (V_V11111)) 5)
                  (BVP (V_V11111)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY)))

(TOGGLE BVP-LENGTH-STATE-VECTORS-OFF BVP-LENGTH-STATE-VECTORS T)

(DEFN RW-
      (CNTL-STATE)
      (NTH 0 CNTL-STATE))

(TOGGLE RW--OFF RW- T)

(DEFN STROBE-
      (CNTL-STATE)
      (NTH 1 CNTL-STATE))

(TOGGLE STROBE--OFF STROBE- T)

(DEFN HDACK-
      (CNTL-STATE)
      (NTH 2 CNTL-STATE))

(TOGGLE HDACK--OFF HDACK- T)

(DEFN WE-REGS
      (CNTL-STATE)
      (NTH 3 CNTL-STATE))

(TOGGLE WE-REGS-OFF WE-REGS T)

(DEFN WE-A-REG
      (CNTL-STATE)
      (NTH 4 CNTL-STATE))

(TOGGLE WE-A-REG-OFF WE-A-REG T)

(DEFN WE-B-REG
      (CNTL-STATE)
      (NTH 5 CNTL-STATE))

(TOGGLE WE-B-REG-OFF WE-B-REG T)

(DEFN WE-I-REG
      (CNTL-STATE)
      (NTH 6 CNTL-STATE))

(TOGGLE WE-I-REG-OFF WE-I-REG T)

(DEFN WE-DATA-OUT
      (CNTL-STATE)
      (NTH 7 CNTL-STATE))

(TOGGLE WE-DATA-OUT-OFF WE-DATA-OUT T)

(DEFN WE-ADDR-OUT
      (CNTL-STATE)
      (NTH 8 CNTL-STATE))

(TOGGLE WE-ADDR-OUT-OFF WE-ADDR-OUT T)

(DEFN WE-HOLD-
      (CNTL-STATE)
      (NTH 9 CNTL-STATE))

(TOGGLE WE-HOLD--OFF WE-HOLD- T)

(DEFN WE-PC-REG
      (CNTL-STATE)
      (NTH 10 CNTL-STATE))

(TOGGLE WE-PC-REG-OFF WE-PC-REG T)

(DEFN DATA-IN-SELECT
      (CNTL-STATE)
      (NTH 11 CNTL-STATE))

(TOGGLE DATA-IN-SELECT-OFF DATA-IN-SELECT T)

(DEFN DEC-ADDR-OUT
      (CNTL-STATE)
      (NTH 12 CNTL-STATE))

(TOGGLE DEC-ADDR-OUT-OFF DEC-ADDR-OUT T)

(DEFN SELECT-IMMEDIATE
      (CNTL-STATE)
      (NTH 13 CNTL-STATE))

(TOGGLE SELECT-IMMEDIATE-OFF SELECT-IMMEDIATE T)

(DEFN ALU-C
      (CNTL-STATE)
      (NTH 14 CNTL-STATE))

(TOGGLE ALU-C-OFF ALU-C T)

(DEFN ALU-ZERO
      (CNTL-STATE)
      (NTH 15 CNTL-STATE))

(TOGGLE ALU-ZERO-OFF ALU-ZERO T)

(DEFN STATE
      (CNTL-STATE)
      (SUBRANGE CNTL-STATE 16 20))

(TOGGLE STATE-OFF STATE T)

(DEFN WE-FLAGS
      (CNTL-STATE)
      (SUBRANGE CNTL-STATE 21 24))

(TOGGLE WE-FLAGS-OFF WE-FLAGS T)

(DEFN REGS-ADDRESS
      (CNTL-STATE)
      (SUBRANGE CNTL-STATE 25 28))

(TOGGLE REGS-ADDRESS-OFF REGS-ADDRESS T)

(DEFN ALU-OP
      (CNTL-STATE)
      (SUBRANGE CNTL-STATE 29 32))

(TOGGLE ALU-OP-OFF ALU-OP T)

(DEFN ALU-MPG
      (CNTL-STATE)
      (SUBRANGE CNTL-STATE 33 39))

(TOGGLE ALU-MPG-OFF ALU-MPG T)

(DEFTHEORY CONTROL-STATE-ACCESSOR-THEORY
           (RW- STROBE- HDACK- WE-REGS WE-A-REG WE-B-REG WE-I-REG WE-DATA-OUT
                WE-ADDR-OUT WE-HOLD- WE-PC-REG DATA-IN-SELECT DEC-ADDR-OUT
                SELECT-IMMEDIATE ALU-C ALU-ZERO STATE WE-FLAGS REGS-ADDRESS
                ALU-OP ALU-MPG))

(DEFN CV_FETCH0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS RW-
  (CONS T
   (CONS T
    (CONS F
     (CONS T
      (CONS F
       (CONS F
        (CONS F
         (CONS T
          (CONS T
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS T (ALU-INC-OP))))
                (CONS T
                 (APPEND
                  (V_FETCH0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                           (APPEND (ALU-INC-OP)
                                   (APPEND (MPG (CONS T (CONS F (ALU-INC-OP))))
                                           NIL))))))))))))))))))))))

(TOGGLE CV_FETCH0-OFF CV_FETCH0 T)

(PROVE-LEMMA CV_FETCH0$DESTRUCTURE
             (REWRITE)
             (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                      (AND (EQUAL (RW- (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                                  RW-)
                           (EQUAL (STROBE- (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (HDACK- (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-REGS (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-A-REG (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-B-REG (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-I-REG (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-DATA-OUT (CV_FETCH0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-ADDR-OUT (CV_FETCH0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-HOLD- (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-PC-REG (CV_FETCH0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (DATA-IN-SELECT (CV_FETCH0 RW- REGS-ADDRESS
                                                             I-REG FLAGS
                                                             PC-REG))
                                  F)
                           (EQUAL (DEC-ADDR-OUT (CV_FETCH0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (SELECT-IMMEDIATE (CV_FETCH0 RW-
                                                               REGS-ADDRESS
                                                               I-REG FLAGS
                                                               PC-REG))
                                  F)
                           (EQUAL (ALU-C (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS T (ALU-INC-OP)))))
                           (EQUAL (ALU-ZERO (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (STATE (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (V_FETCH0))
                           (EQUAL (WE-FLAGS (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (REGS-ADDRESS (CV_FETCH0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  PC-REG)
                           (EQUAL (ALU-OP (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  (ALU-INC-OP))
                           (EQUAL (ALU-MPG (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  (MPG (CONS T (CONS F (ALU-INC-OP)))))))
             ((ENABLE CV_FETCH0 V_FETCH0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                      SET-FLAGS RN-A RN-B)
              (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
              (DISABLE MPG)))

(TOGGLE CV_FETCH0$DESTRUCTURE-OFF CV_FETCH0$DESTRUCTURE T)

(DEFN CV_FETCH1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_FETCH1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_FETCH1-OFF CV_FETCH1 T)

(PROVE-LEMMA CV_FETCH1$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_FETCH1 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_FETCH1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_FETCH1 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_FETCH1))
                        (EQUAL (WE-FLAGS (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_FETCH1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_FETCH1 V_FETCH1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_FETCH1$DESTRUCTURE-OFF CV_FETCH1$DESTRUCTURE T)

(DEFN CV_FETCH2
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS T
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (ALU-INC-OP))))
                (CONS F
                 (APPEND
                  (V_FETCH2)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                           (APPEND (ALU-INC-OP)
                                   (APPEND (MPG (CONS F (CONS F (ALU-INC-OP))))
                                           NIL))))))))))))))))))))))

(TOGGLE CV_FETCH2-OFF CV_FETCH2 T)

(PROVE-LEMMA CV_FETCH2$DESTRUCTURE
             (REWRITE)
             (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                      (AND (EQUAL (RW- (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                                  T)
                           (EQUAL (STROBE- (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  F)
                           (EQUAL (HDACK- (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-REGS (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-A-REG (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-B-REG (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-I-REG (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-DATA-OUT (CV_FETCH2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-ADDR-OUT (CV_FETCH2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-HOLD- (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-PC-REG (CV_FETCH2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (DATA-IN-SELECT (CV_FETCH2 RW- REGS-ADDRESS
                                                             I-REG FLAGS
                                                             PC-REG))
                                  F)
                           (EQUAL (DEC-ADDR-OUT (CV_FETCH2 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (SELECT-IMMEDIATE (CV_FETCH2 RW-
                                                               REGS-ADDRESS
                                                               I-REG FLAGS
                                                               PC-REG))
                                  F)
                           (EQUAL (ALU-C (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                           (EQUAL (ALU-ZERO (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (STATE (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (V_FETCH2))
                           (EQUAL (WE-FLAGS (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (REGS-ADDRESS (CV_FETCH2 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  PC-REG)
                           (EQUAL (ALU-OP (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  (ALU-INC-OP))
                           (EQUAL (ALU-MPG (CV_FETCH2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))))
             ((ENABLE CV_FETCH2 V_FETCH2 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                      SET-FLAGS RN-A RN-B)
              (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
              (DISABLE MPG)))

(TOGGLE CV_FETCH2$DESTRUCTURE-OFF CV_FETCH2$DESTRUCTURE T)

(DEFN CV_FETCH3
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS T
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS T
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_FETCH3)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_FETCH3-OFF CV_FETCH3 T)

(PROVE-LEMMA CV_FETCH3$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-DATA-OUT (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_FETCH3 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               T)
                        (EQUAL (DEC-ADDR-OUT (CV_FETCH3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_FETCH3 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_FETCH3))
                        (EQUAL (WE-FLAGS (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_FETCH3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_FETCH3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_FETCH3 V_FETCH3 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_FETCH3$DESTRUCTURE-OFF CV_FETCH3$DESTRUCTURE T)

(DEFN CV_DECODE
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_DECODE)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_DECODE-OFF CV_DECODE T)

(PROVE-LEMMA CV_DECODE$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_DECODE RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_DECODE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_DECODE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_DECODE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_DECODE RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_DECODE RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_DECODE RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_DECODE RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_DECODE RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_DECODE RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_DECODE RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_DECODE RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_DECODE))
                        (EQUAL (WE-FLAGS (CV_DECODE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_DECODE RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_DECODE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_DECODE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_DECODE V_DECODE OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_DECODE$DESTRUCTURE-OFF CV_DECODE$DESTRUCTURE T)

(DEFN CV_REGA
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS T
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS
               (A-IMMEDIATE-P I-REG)
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_REGA)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-A I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_REGA-OFF CV_REGA T)

(PROVE-LEMMA CV_REGA$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-B-REG (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_REGA RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_REGA RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_REGA RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_REGA RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_REGA RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_REGA RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               (A-IMMEDIATE-P I-REG))
                        (EQUAL (ALU-C (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               (V_REGA))
                        (EQUAL (WE-FLAGS (CV_REGA RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_REGA RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               (RN-A I-REG))
                        (EQUAL (ALU-OP (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_REGA V_REGA OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_REGA$DESTRUCTURE-OFF CV_REGA$DESTRUCTURE T)

(DEFN CV_REGB
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_REGB)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_REGB-OFF CV_REGB T)

(PROVE-LEMMA CV_REGB$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_REGB RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_REGB RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_REGB RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_REGB RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_REGB RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_REGB RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               (V_REGB))
                        (EQUAL (WE-FLAGS (CV_REGB RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_REGB RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_REGB V_REGB OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_REGB$DESTRUCTURE-OFF CV_REGB$DESTRUCTURE T)

(DEFN CV_UPDATE
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS
     (STORE-RESULTP (STORE-CC I-REG) FLAGS)
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_UPDATE)
                  (APPEND
                   (SET-FLAGS I-REG)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_UPDATE-OFF CV_UPDATE T)

(PROVE-LEMMA CV_UPDATE$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (STORE-RESULTP (STORE-CC I-REG)
                                              FLAGS))
                        (EQUAL (WE-A-REG (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_UPDATE RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_UPDATE RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_UPDATE RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_UPDATE))
                        (EQUAL (WE-FLAGS (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (SET-FLAGS I-REG))
                        (EQUAL (REGS-ADDRESS (CV_UPDATE RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_UPDATE V_UPDATE OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_UPDATE$DESTRUCTURE-OFF CV_UPDATE$DESTRUCTURE T)

(DEFN CV_READA0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS T
      (CONS F
       (CONS F
        (CONS F
         (CONS T
          (CONS F
           (CONS F
            (CONS F
             (CONS
              (PRE-DEC-P (MODE-A I-REG))
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READA0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-A I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READA0-OFF CV_READA0 T)

(PROVE-LEMMA CV_READA0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READA0 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_READA0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-B-REG (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READA0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READA0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               T)
                        (EQUAL (WE-HOLD- (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READA0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READA0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_READA0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (PRE-DEC-P (MODE-A I-REG)))
                        (EQUAL (SELECT-IMMEDIATE (CV_READA0 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_READA0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READA0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READA0))
                        (EQUAL (WE-FLAGS (CV_READA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READA0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-A I-REG))
                        (EQUAL (ALU-OP (CV_READA0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READA0 V_READA0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READA0$DESTRUCTURE-OFF CV_READA0$DESTRUCTURE T)

(DEFN CV_READA1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS
     (AND* (NOT* (A-IMMEDIATE-P I-REG))
           (OR* (PRE-DEC-P (MODE-A I-REG))
                (POST-INC-P (MODE-A I-REG))))
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (IF* (PRE-DEC-P (MODE-A I-REG))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-DEC-OP))))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-INC-OP)))))
                (CONS F
                 (APPEND
                  (V_READA1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                     (RN-A I-REG)
                     (APPEND (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (APPEND (IF* (PRE-DEC-P (MODE-A I-REG))
                                          (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                          (MPG (CONS F (CONS F (ALU-INC-OP)))))
                                     NIL))))))))))))))))))))))

(TOGGLE CV_READA1-OFF CV_READA1 T)

(PROVE-LEMMA CV_READA1$DESTRUCTURE
       (REWRITE)
       (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                (AND (EQUAL (RW- (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG))
                            T)
                     (EQUAL (STROBE- (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            T)
                     (EQUAL (HDACK- (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (WE-REGS (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (AND* (NOT* (A-IMMEDIATE-P I-REG))
                                  (OR* (PRE-DEC-P (MODE-A I-REG))
                                       (POST-INC-P (MODE-A I-REG)))))
                     (EQUAL (WE-A-REG (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-B-REG (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-I-REG (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-DATA-OUT (CV_READA1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-ADDR-OUT (CV_READA1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-HOLD- (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-PC-REG (CV_READA1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                            F)
                     (EQUAL (DATA-IN-SELECT (CV_READA1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                            F)
                     (EQUAL (DEC-ADDR-OUT (CV_READA1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            F)
                     (EQUAL (SELECT-IMMEDIATE (CV_READA1 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                            F)
                     (EQUAL (ALU-C (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-DEC-OP))))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-INC-OP))))))
                     (EQUAL (ALU-ZERO (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (STATE (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (V_READA1))
                     (EQUAL (WE-FLAGS (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            (MAKE-LIST 4 F))
                     (EQUAL (REGS-ADDRESS (CV_READA1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            (RN-A I-REG))
                     (EQUAL (ALU-OP (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (EQUAL (ALU-MPG (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                 (MPG (CONS F (CONS F (ALU-INC-OP))))))))
       ((ENABLE CV_READA1 V_READA1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                SET-FLAGS RN-A RN-B)
        (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
        (DISABLE MPG)))

(TOGGLE CV_READA1$DESTRUCTURE-OFF CV_READA1$DESTRUCTURE T)

(DEFN CV_READA2
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READA2)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READA2-OFF CV_READA2 T)

(PROVE-LEMMA CV_READA2$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READA2 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READA2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_READA2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READA2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READA2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READA2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READA2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READA2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_READA2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_READA2 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_READA2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READA2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READA2))
                        (EQUAL (WE-FLAGS (CV_READA2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READA2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_READA2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READA2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READA2 V_READA2 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READA2$DESTRUCTURE-OFF CV_READA2$DESTRUCTURE T)

(DEFN CV_READA3
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS F
     (CONS T
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS T
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READA3)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READA3-OFF CV_READA3 T)

(PROVE-LEMMA CV_READA3$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READA3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_READA3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READA3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-B-REG (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READA3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READA3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READA3 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READA3 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               T)
                        (EQUAL (DEC-ADDR-OUT (CV_READA3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_READA3 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READA3))
                        (EQUAL (WE-FLAGS (CV_READA3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READA3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_READA3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READA3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READA3 V_READA3 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READA3$DESTRUCTURE-OFF CV_READA3$DESTRUCTURE T)

(DEFN CV_READB0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS T
          (CONS F
           (CONS F
            (CONS F
             (CONS
              (PRE-DEC-P (MODE-B I-REG))
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READB0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READB0-OFF CV_READB0 T)

(PROVE-LEMMA CV_READB0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READB0 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_READB0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READB0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READB0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               T)
                        (EQUAL (WE-HOLD- (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READB0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READB0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_READB0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (PRE-DEC-P (MODE-B I-REG)))
                        (EQUAL (SELECT-IMMEDIATE (CV_READB0 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_READB0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READB0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READB0))
                        (EQUAL (WE-FLAGS (CV_READB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READB0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_READB0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READB0 V_READB0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READB0$DESTRUCTURE-OFF CV_READB0$DESTRUCTURE T)

(DEFN CV_READB1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS
      (OR* (A-IMMEDIATE-P I-REG)
           (REG-DIRECT-P (MODE-A I-REG)))
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS
               (A-IMMEDIATE-P I-REG)
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READB1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-A I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READB1-OFF CV_READB1 T)

(PROVE-LEMMA CV_READB1$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READB1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READB1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_READB1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READB1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (OR* (A-IMMEDIATE-P I-REG)
                                    (REG-DIRECT-P (MODE-A I-REG))))
                        (EQUAL (WE-B-REG (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READB1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READB1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READB1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READB1 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_READB1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_READB1 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               (A-IMMEDIATE-P I-REG))
                        (EQUAL (ALU-C (CV_READB1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READB1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READB1))
                        (EQUAL (WE-FLAGS (CV_READB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READB1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-A I-REG))
                        (EQUAL (ALU-OP (CV_READB1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READB1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READB1 V_READB1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READB1$DESTRUCTURE-OFF CV_READB1$DESTRUCTURE T)

(DEFN CV_READB2
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS
     (AND* (NOT* (STORE-RESULTP (STORE-CC I-REG)
                                FLAGS))
           (OR* (PRE-DEC-P (MODE-B I-REG))
                (POST-INC-P (MODE-B I-REG))))
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (IF* (PRE-DEC-P (MODE-B I-REG))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-DEC-OP))))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-INC-OP)))))
                (CONS F
                 (APPEND
                  (V_READB2)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                     (RN-B I-REG)
                     (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                          (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                          (MPG (CONS F (CONS T (ALU-INC-OP)))))
                                     NIL))))))))))))))))))))))

(TOGGLE CV_READB2-OFF CV_READB2 T)

(PROVE-LEMMA CV_READB2$DESTRUCTURE
       (REWRITE)
       (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                (AND (EQUAL (RW- (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG))
                            T)
                     (EQUAL (STROBE- (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (HDACK- (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (WE-REGS (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (AND* (NOT* (STORE-RESULTP (STORE-CC I-REG)
                                                       FLAGS))
                                  (OR* (PRE-DEC-P (MODE-B I-REG))
                                       (POST-INC-P (MODE-B I-REG)))))
                     (EQUAL (WE-A-REG (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-B-REG (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-I-REG (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-DATA-OUT (CV_READB2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-ADDR-OUT (CV_READB2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-HOLD- (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-PC-REG (CV_READB2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                            F)
                     (EQUAL (DATA-IN-SELECT (CV_READB2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                            F)
                     (EQUAL (DEC-ADDR-OUT (CV_READB2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            F)
                     (EQUAL (SELECT-IMMEDIATE (CV_READB2 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                            F)
                     (EQUAL (ALU-C (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-DEC-OP))))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-INC-OP))))))
                     (EQUAL (ALU-ZERO (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (STATE (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (V_READB2))
                     (EQUAL (WE-FLAGS (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            (MAKE-LIST 4 F))
                     (EQUAL (REGS-ADDRESS (CV_READB2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            (RN-B I-REG))
                     (EQUAL (ALU-OP (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (EQUAL (ALU-MPG (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                 (MPG (CONS F (CONS T (ALU-INC-OP))))))))
       ((ENABLE CV_READB2 V_READB2 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                SET-FLAGS RN-A RN-B)
        (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
        (DISABLE MPG)))

(TOGGLE CV_READB2$DESTRUCTURE-OFF CV_READB2$DESTRUCTURE T)

(DEFN CV_READB3
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS F
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS T
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_READB3)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_READB3-OFF CV_READB3 T)

(PROVE-LEMMA CV_READB3$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_READB3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_READB3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_READB3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_READB3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_READB3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_READB3 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_READB3 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               T)
                        (EQUAL (DEC-ADDR-OUT (CV_READB3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_READB3 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_READB3))
                        (EQUAL (WE-FLAGS (CV_READB3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_READB3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_READB3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_READB3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_READB3 V_READB3 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_READB3$DESTRUCTURE-OFF CV_READB3$DESTRUCTURE T)

(DEFN CV_WRITE0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS T
         (CONS T
          (CONS F
           (CONS F
            (CONS F
             (CONS
              (PRE-DEC-P (MODE-B I-REG))
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_WRITE0)
                  (APPEND
                   (SET-FLAGS I-REG)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_WRITE0-OFF CV_WRITE0 T)

(PROVE-LEMMA CV_WRITE0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               T)
                        (EQUAL (WE-ADDR-OUT (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               T)
                        (EQUAL (WE-HOLD- (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_WRITE0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_WRITE0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (PRE-DEC-P (MODE-B I-REG)))
                        (EQUAL (SELECT-IMMEDIATE (CV_WRITE0 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_WRITE0))
                        (EQUAL (WE-FLAGS (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (SET-FLAGS I-REG))
                        (EQUAL (REGS-ADDRESS (CV_WRITE0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_WRITE0 V_WRITE0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_WRITE0$DESTRUCTURE-OFF CV_WRITE0$DESTRUCTURE T)

(DEFN CV_WRITE1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS F
  (CONS T
   (CONS T
    (CONS
     (OR* (PRE-DEC-P (MODE-B I-REG))
          (POST-INC-P (MODE-B I-REG)))
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (IF* (PRE-DEC-P (MODE-B I-REG))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-DEC-OP))))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-INC-OP)))))
                (CONS F
                 (APPEND
                  (V_WRITE1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                     (RN-B I-REG)
                     (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                          (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                          (MPG (CONS F (CONS T (ALU-INC-OP)))))
                                     NIL))))))))))))))))))))))

(TOGGLE CV_WRITE1-OFF CV_WRITE1 T)

(PROVE-LEMMA CV_WRITE1$DESTRUCTURE
       (REWRITE)
       (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                (AND (EQUAL (RW- (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG))
                            F)
                     (EQUAL (STROBE- (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            T)
                     (EQUAL (HDACK- (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (WE-REGS (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (OR* (PRE-DEC-P (MODE-B I-REG))
                                 (POST-INC-P (MODE-B I-REG))))
                     (EQUAL (WE-A-REG (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-B-REG (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-I-REG (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-DATA-OUT (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-ADDR-OUT (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (WE-HOLD- (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (WE-PC-REG (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                            F)
                     (EQUAL (DATA-IN-SELECT (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                            F)
                     (EQUAL (DEC-ADDR-OUT (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            F)
                     (EQUAL (SELECT-IMMEDIATE (CV_WRITE1 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                            F)
                     (EQUAL (ALU-C (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-DEC-OP))))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-INC-OP))))))
                     (EQUAL (ALU-ZERO (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (STATE (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (V_WRITE1))
                     (EQUAL (WE-FLAGS (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            (MAKE-LIST 4 F))
                     (EQUAL (REGS-ADDRESS (CV_WRITE1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                            (RN-B I-REG))
                     (EQUAL (ALU-OP (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (EQUAL (ALU-MPG (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                 (MPG (CONS F (CONS T (ALU-INC-OP))))))))
       ((ENABLE CV_WRITE1 V_WRITE1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                SET-FLAGS RN-A RN-B)
        (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
        (DISABLE MPG)))

(TOGGLE CV_WRITE1$DESTRUCTURE-OFF CV_WRITE1$DESTRUCTURE T)

(DEFN CV_WRITE2
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS F
  (CONS F
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_WRITE2)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_WRITE2-OFF CV_WRITE2 T)

(PROVE-LEMMA CV_WRITE2$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_WRITE2 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               F)
                        (EQUAL (STROBE- (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_WRITE2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_WRITE2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_WRITE2 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_WRITE2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_WRITE2 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_WRITE2))
                        (EQUAL (WE-FLAGS (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_WRITE2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_WRITE2 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_WRITE2 V_WRITE2 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_WRITE2$DESTRUCTURE-OFF CV_WRITE2$DESTRUCTURE T)

(DEFN CV_WRITE3
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS F
  (CONS F
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_WRITE3)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_WRITE3-OFF CV_WRITE3 T)

(PROVE-LEMMA CV_WRITE3$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               F)
                        (EQUAL (STROBE- (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (HDACK- (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_WRITE3 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_WRITE3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_WRITE3 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_WRITE3))
                        (EQUAL (WE-FLAGS (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_WRITE3 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_WRITE3 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_WRITE3 V_WRITE3 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_WRITE3$DESTRUCTURE-OFF CV_WRITE3$DESTRUCTURE T)

(DEFN CV_SEFA0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS T
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_SEFA0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-A I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_SEFA0-OFF CV_SEFA0 T)

(PROVE-LEMMA CV_SEFA0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (WE-B-REG (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_SEFA0 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_SEFA0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (V_SEFA0))
                        (EQUAL (WE-FLAGS (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               (RN-A I-REG))
                        (EQUAL (ALU-OP (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_SEFA0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_SEFA0 V_SEFA0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_SEFA0$DESTRUCTURE-OFF CV_SEFA0$DESTRUCTURE T)

(DEFN CV_SEFA1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS T
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (IF* (PRE-DEC-P (MODE-A I-REG))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-DEC-OP))))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-INC-OP)))))
                (CONS F
                 (APPEND
                  (V_SEFA1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                     (RN-A I-REG)
                     (APPEND (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (APPEND (IF* (PRE-DEC-P (MODE-A I-REG))
                                          (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                          (MPG (CONS F (CONS F (ALU-INC-OP)))))
                                     NIL))))))))))))))))))))))

(TOGGLE CV_SEFA1-OFF CV_SEFA1 T)

(PROVE-LEMMA CV_SEFA1$DESTRUCTURE
       (REWRITE)
       (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                (AND (EQUAL (RW- (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                            T)
                     (EQUAL (STROBE- (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (HDACK- (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            T)
                     (EQUAL (WE-REGS (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (WE-A-REG (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-B-REG (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-I-REG (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-DATA-OUT (CV_SEFA1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                            F)
                     (EQUAL (WE-ADDR-OUT (CV_SEFA1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                            F)
                     (EQUAL (WE-HOLD- (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-PC-REG (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (DATA-IN-SELECT (CV_SEFA1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                            F)
                     (EQUAL (DEC-ADDR-OUT (CV_SEFA1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (SELECT-IMMEDIATE (CV_SEFA1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                            F)
                     (EQUAL (ALU-C (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-DEC-OP))))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-INC-OP))))))
                     (EQUAL (ALU-ZERO (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (STATE (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                            (V_SEFA1))
                     (EQUAL (WE-FLAGS (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (MAKE-LIST 4 F))
                     (EQUAL (REGS-ADDRESS (CV_SEFA1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            (RN-A I-REG))
                     (EQUAL (ALU-OP (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (EQUAL (ALU-MPG (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            (IF* (PRE-DEC-P (MODE-A I-REG))
                                 (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                 (MPG (CONS F (CONS F (ALU-INC-OP))))))))
       ((ENABLE CV_SEFA1 V_SEFA1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                SET-FLAGS RN-A RN-B)
        (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
        (DISABLE MPG)))

(TOGGLE CV_SEFA1$DESTRUCTURE-OFF CV_SEFA1$DESTRUCTURE T)

(DEFN CV_SEFB0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS T
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_SEFB0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                        (RN-B I-REG)
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_SEFB0-OFF CV_SEFB0 T)

(PROVE-LEMMA CV_SEFB0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (WE-I-REG (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_SEFB0 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_SEFB0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (V_SEFB0))
                        (EQUAL (WE-FLAGS (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               (RN-B I-REG))
                        (EQUAL (ALU-OP (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_SEFB0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_SEFB0 V_SEFB0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_SEFB0$DESTRUCTURE-OFF CV_SEFB0$DESTRUCTURE T)

(DEFN CV_SEFB1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS T
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (IF* (PRE-DEC-P (MODE-B I-REG))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-DEC-OP))))
                     (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                          (CONS F (ALU-INC-OP)))))
                (CONS F
                 (APPEND
                  (V_SEFB1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND
                     (RN-B I-REG)
                     (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (APPEND (IF* (PRE-DEC-P (MODE-B I-REG))
                                          (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                          (MPG (CONS F (CONS T (ALU-INC-OP)))))
                                     NIL))))))))))))))))))))))

(TOGGLE CV_SEFB1-OFF CV_SEFB1 T)

(PROVE-LEMMA CV_SEFB1$DESTRUCTURE
       (REWRITE)
       (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                (AND (EQUAL (RW- (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                            T)
                     (EQUAL (STROBE- (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (HDACK- (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            T)
                     (EQUAL (WE-REGS (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            T)
                     (EQUAL (WE-A-REG (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-B-REG (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-I-REG (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-DATA-OUT (CV_SEFB1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                            F)
                     (EQUAL (WE-ADDR-OUT (CV_SEFB1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                            F)
                     (EQUAL (WE-HOLD- (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (WE-PC-REG (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                            F)
                     (EQUAL (DATA-IN-SELECT (CV_SEFB1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                            F)
                     (EQUAL (DEC-ADDR-OUT (CV_SEFB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            F)
                     (EQUAL (SELECT-IMMEDIATE (CV_SEFB1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                            F)
                     (EQUAL (ALU-C (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-DEC-OP))))
                                 (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                      (CONS F (ALU-INC-OP))))))
                     (EQUAL (ALU-ZERO (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            F)
                     (EQUAL (STATE (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))
                            (V_SEFB1))
                     (EQUAL (WE-FLAGS (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                            (MAKE-LIST 4 F))
                     (EQUAL (REGS-ADDRESS (CV_SEFB1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                            (RN-B I-REG))
                     (EQUAL (ALU-OP (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (EQUAL (ALU-MPG (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                            (IF* (PRE-DEC-P (MODE-B I-REG))
                                 (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                 (MPG (CONS F (CONS T (ALU-INC-OP))))))))
       ((ENABLE CV_SEFB1 V_SEFB1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                SET-FLAGS RN-A RN-B)
        (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
        (DISABLE MPG)))

(TOGGLE CV_SEFB1$DESTRUCTURE-OFF CV_SEFB1$DESTRUCTURE T)

(DEFN CV_HOLD0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS F
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS T
           (CONS T
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_HOLD0)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_HOLD0-OFF CV_HOLD0 T)

(PROVE-LEMMA CV_HOLD0$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               F)
                        (EQUAL (WE-REGS (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (WE-PC-REG (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               T)
                        (EQUAL (DATA-IN-SELECT (CV_HOLD0 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_HOLD0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (V_HOLD0))
                        (EQUAL (WE-FLAGS (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_HOLD0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_HOLD0 V_HOLD0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_HOLD0$DESTRUCTURE-OFF CV_HOLD0$DESTRUCTURE T)

(DEFN CV_HOLD1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_HOLD1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_HOLD1-OFF CV_HOLD1 T)

(PROVE-LEMMA CV_HOLD1$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_HOLD1 RW- REGS-ADDRESS
                                                         I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_HOLD1 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                               (V_HOLD1))
                        (EQUAL (WE-FLAGS (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_HOLD1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_HOLD1 V_HOLD1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_HOLD1$DESTRUCTURE-OFF CV_HOLD1$DESTRUCTURE T)

(DEFN CV_V11010
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_V11010)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_V11010-OFF CV_V11010 T)

(PROVE-LEMMA CV_V11010$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_V11010 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_V11010 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_V11010 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_V11010 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_V11010 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_V11010 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_V11010 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_V11010 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_V11010 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_V11010 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_V11010 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_V11010 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_V11010))
                        (EQUAL (WE-FLAGS (CV_V11010 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_V11010 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_V11010 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_V11010 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_V11010 V_V11010 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_V11010$DESTRUCTURE-OFF CV_V11010$DESTRUCTURE T)

(DEFN CV_V11011
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_V11011)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_V11011-OFF CV_V11011 T)

(PROVE-LEMMA CV_V11011$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_V11011 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_V11011 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_V11011 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_V11011 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_V11011 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_V11011 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_V11011 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_V11011 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_V11011 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_V11011 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_V11011 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_V11011 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_V11011))
                        (EQUAL (WE-FLAGS (CV_V11011 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_V11011 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_V11011 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_V11011 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_V11011 V_V11011 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_V11011$DESTRUCTURE-OFF CV_V11011$DESTRUCTURE T)

(DEFN CV_RESET0
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS T
     (CONS F
      (CONS F
       (CONS F
        (CONS T
         (CONS F
          (CONS T
           (CONS T
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS T (ALU-INC-OP))))
                (CONS T
                 (APPEND
                  (V_RESET0)
                  (APPEND
                   (MAKE-LIST 4 T)
                   (APPEND (MAKE-LIST 4 F)
                           (APPEND (ALU-INC-OP)
                                   (APPEND (MPG (CONS T (CONS F (ALU-INC-OP))))
                                           NIL))))))))))))))))))))))

(TOGGLE CV_RESET0-OFF CV_RESET0 T)

(PROVE-LEMMA CV_RESET0$DESTRUCTURE
             (REWRITE)
             (IMPLIES T
                      (AND (EQUAL (RW- (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                                  T)
                           (EQUAL (STROBE- (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (HDACK- (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-REGS (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-A-REG (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-B-REG (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-I-REG (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-DATA-OUT (CV_RESET0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-ADDR-OUT (CV_RESET0 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-HOLD- (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-PC-REG (CV_RESET0 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                                  T)
                           (EQUAL (DATA-IN-SELECT (CV_RESET0 RW- REGS-ADDRESS
                                                             I-REG FLAGS
                                                             PC-REG))
                                  F)
                           (EQUAL (DEC-ADDR-OUT (CV_RESET0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (SELECT-IMMEDIATE (CV_RESET0 RW-
                                                               REGS-ADDRESS
                                                               I-REG FLAGS
                                                               PC-REG))
                                  F)
                           (EQUAL (ALU-C (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS T (ALU-INC-OP)))))
                           (EQUAL (ALU-ZERO (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (STATE (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (V_RESET0))
                           (EQUAL (WE-FLAGS (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  (MAKE-LIST 4 T))
                           (EQUAL (REGS-ADDRESS (CV_RESET0 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (ALU-OP (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  (ALU-INC-OP))
                           (EQUAL (ALU-MPG (CV_RESET0 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  (MPG (CONS T (CONS F (ALU-INC-OP)))))))
             ((ENABLE CV_RESET0 V_RESET0 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                      SET-FLAGS RN-A RN-B)
              (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
              (DISABLE MPG)))

(TOGGLE CV_RESET0$DESTRUCTURE-OFF CV_RESET0$DESTRUCTURE T)

(DEFN CV_RESET1
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS T
      (CONS T
       (CONS T
        (CONS F
         (CONS T
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS T (ALU-INC-OP))))
                (CONS T
                 (APPEND
                  (V_RESET1)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND (MAKE-LIST 4 F)
                           (APPEND (ALU-INC-OP)
                                   (APPEND (MPG (CONS T (CONS F (ALU-INC-OP))))
                                           NIL))))))))))))))))))))))

(TOGGLE CV_RESET1-OFF CV_RESET1 T)

(PROVE-LEMMA CV_RESET1$DESTRUCTURE
             (REWRITE)
             (IMPLIES T
                      (AND (EQUAL (RW- (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                                  T)
                           (EQUAL (STROBE- (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (HDACK- (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-REGS (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-A-REG (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-B-REG (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-I-REG (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-DATA-OUT (CV_RESET1 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-ADDR-OUT (CV_RESET1 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-HOLD- (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-PC-REG (CV_RESET1 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (DATA-IN-SELECT (CV_RESET1 RW- REGS-ADDRESS
                                                             I-REG FLAGS
                                                             PC-REG))
                                  F)
                           (EQUAL (DEC-ADDR-OUT (CV_RESET1 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (SELECT-IMMEDIATE (CV_RESET1 RW-
                                                               REGS-ADDRESS
                                                               I-REG FLAGS
                                                               PC-REG))
                                  F)
                           (EQUAL (ALU-C (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS T (ALU-INC-OP)))))
                           (EQUAL (ALU-ZERO (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (STATE (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (V_RESET1))
                           (EQUAL (WE-FLAGS (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (REGS-ADDRESS (CV_RESET1 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (ALU-OP (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  (ALU-INC-OP))
                           (EQUAL (ALU-MPG (CV_RESET1 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  (MPG (CONS T (CONS F (ALU-INC-OP)))))))
             ((ENABLE CV_RESET1 V_RESET1 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                      SET-FLAGS RN-A RN-B)
              (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
              (DISABLE MPG)))

(TOGGLE CV_RESET1$DESTRUCTURE-OFF CV_RESET1$DESTRUCTURE T)

(DEFN CV_RESET2
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS T
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS T (ALU-INC-OP))))
                (CONS T
                 (APPEND
                  (V_RESET2)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND (V-INC REGS-ADDRESS)
                           (APPEND (ALU-INC-OP)
                                   (APPEND (MPG (CONS T (CONS F (ALU-INC-OP))))
                                           NIL))))))))))))))))))))))

(TOGGLE CV_RESET2-OFF CV_RESET2 T)

(PROVE-LEMMA CV_RESET2$DESTRUCTURE
             (REWRITE)
             (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                      (AND (EQUAL (RW- (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                                  T)
                           (EQUAL (STROBE- (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (HDACK- (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-REGS (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  T)
                           (EQUAL (WE-A-REG (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-B-REG (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-I-REG (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-DATA-OUT (CV_RESET2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-ADDR-OUT (CV_RESET2 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-HOLD- (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  F)
                           (EQUAL (WE-PC-REG (CV_RESET2 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (DATA-IN-SELECT (CV_RESET2 RW- REGS-ADDRESS
                                                             I-REG FLAGS
                                                             PC-REG))
                                  F)
                           (EQUAL (DEC-ADDR-OUT (CV_RESET2 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  F)
                           (EQUAL (SELECT-IMMEDIATE (CV_RESET2 RW-
                                                               REGS-ADDRESS
                                                               I-REG FLAGS
                                                               PC-REG))
                                  F)
                           (EQUAL (ALU-C (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS T (ALU-INC-OP)))))
                           (EQUAL (ALU-ZERO (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  T)
                           (EQUAL (STATE (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                  (V_RESET2))
                           (EQUAL (WE-FLAGS (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                                  (MAKE-LIST 4 F))
                           (EQUAL (REGS-ADDRESS (CV_RESET2 RW- REGS-ADDRESS
                                                           I-REG FLAGS PC-REG))
                                  (V-INC REGS-ADDRESS))
                           (EQUAL (ALU-OP (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  (ALU-INC-OP))
                           (EQUAL (ALU-MPG (CV_RESET2 RW- REGS-ADDRESS I-REG
                                                      FLAGS PC-REG))
                                  (MPG (CONS T (CONS F (ALU-INC-OP)))))))
             ((ENABLE CV_RESET2 V_RESET2 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                      SET-FLAGS RN-A RN-B)
              (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
              (DISABLE MPG)))

(TOGGLE CV_RESET2$DESTRUCTURE-OFF CV_RESET2$DESTRUCTURE T)

(DEFN CV_V11111
 (RW- REGS-ADDRESS I-REG FLAGS PC-REG)
 (CONS T
  (CONS T
   (CONS T
    (CONS F
     (CONS F
      (CONS F
       (CONS F
        (CONS F
         (CONS F
          (CONS F
           (CONS F
            (CONS F
             (CONS F
              (CONS F
               (CONS
                (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                     (CONS F (OP-CODE I-REG))))
                (CONS F
                 (APPEND
                  (V_V11111)
                  (APPEND
                   (MAKE-LIST 4 F)
                   (APPEND PC-REG
                        (APPEND (OP-CODE I-REG)
                                (APPEND (MPG (CONS F (CONS F (OP-CODE I-REG))))
                                        NIL))))))))))))))))))))))

(TOGGLE CV_V11111-OFF CV_V11111 T)

(PROVE-LEMMA CV_V11111$DESTRUCTURE
          (REWRITE)
          (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                   (AND (EQUAL (RW- (CV_V11111 RW- REGS-ADDRESS I-REG FLAGS
                                               PC-REG))
                               T)
                        (EQUAL (STROBE- (CV_V11111 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               T)
                        (EQUAL (HDACK- (CV_V11111 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               T)
                        (EQUAL (WE-REGS (CV_V11111 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               F)
                        (EQUAL (WE-A-REG (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-B-REG (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-I-REG (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-DATA-OUT (CV_V11111 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-ADDR-OUT (CV_V11111 RW- REGS-ADDRESS I-REG
                                                       FLAGS PC-REG))
                               F)
                        (EQUAL (WE-HOLD- (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (WE-PC-REG (CV_V11111 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                               F)
                        (EQUAL (DATA-IN-SELECT (CV_V11111 RW- REGS-ADDRESS
                                                          I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (DEC-ADDR-OUT (CV_V11111 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               F)
                        (EQUAL (SELECT-IMMEDIATE (CV_V11111 RW- REGS-ADDRESS
                                                            I-REG FLAGS
                                                            PC-REG))
                               F)
                        (EQUAL (ALU-C (CV_V11111 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                    (CONS F (OP-CODE I-REG)))))
                        (EQUAL (ALU-ZERO (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               F)
                        (EQUAL (STATE (CV_V11111 RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG))
                               (V_V11111))
                        (EQUAL (WE-FLAGS (CV_V11111 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                               (MAKE-LIST 4 F))
                        (EQUAL (REGS-ADDRESS (CV_V11111 RW- REGS-ADDRESS
                                                        I-REG FLAGS PC-REG))
                               PC-REG)
                        (EQUAL (ALU-OP (CV_V11111 RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG))
                               (OP-CODE I-REG))
                        (EQUAL (ALU-MPG (CV_V11111 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                               (MPG (CONS F (CONS F (OP-CODE I-REG)))))))
          ((ENABLE CV_V11111 V_V11111 OPEN-NTH NTH-IF SUBRANGE-CONS OP-CODE
                   SET-FLAGS RN-A RN-B)
           (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
           (DISABLE MPG)))

(TOGGLE CV_V11111$DESTRUCTURE-OFF CV_V11111$DESTRUCTURE T)

(DEFTHEORY CV-THEORY
           (CV_FETCH0 CV_FETCH1 CV_FETCH2 CV_FETCH3 CV_DECODE CV_REGA CV_REGB
                      CV_UPDATE CV_READA0 CV_READA1 CV_READA2 CV_READA3
                      CV_READB0 CV_READB1 CV_READB2 CV_READB3 CV_WRITE0
                      CV_WRITE1 CV_WRITE2 CV_WRITE3 CV_SEFA0 CV_SEFA1 CV_SEFB0
                      CV_SEFB1 CV_HOLD0 CV_HOLD1 CV_V11010 CV_V11011 CV_RESET0
                      CV_RESET1 CV_RESET2 CV_V11111))

(DEFTHEORY CV-DESTRUCTURE-THEORY
           (CV_FETCH0$DESTRUCTURE CV_FETCH1$DESTRUCTURE CV_FETCH2$DESTRUCTURE
                                  CV_FETCH3$DESTRUCTURE CV_DECODE$DESTRUCTURE
                                  CV_REGA$DESTRUCTURE CV_REGB$DESTRUCTURE
                                  CV_UPDATE$DESTRUCTURE CV_READA0$DESTRUCTURE
                                  CV_READA1$DESTRUCTURE CV_READA2$DESTRUCTURE
                                  CV_READA3$DESTRUCTURE CV_READB0$DESTRUCTURE
                                  CV_READB1$DESTRUCTURE CV_READB2$DESTRUCTURE
                                  CV_READB3$DESTRUCTURE CV_WRITE0$DESTRUCTURE
                                  CV_WRITE1$DESTRUCTURE CV_WRITE2$DESTRUCTURE
                                  CV_WRITE3$DESTRUCTURE CV_SEFA0$DESTRUCTURE
                                  CV_SEFA1$DESTRUCTURE CV_SEFB0$DESTRUCTURE
                                  CV_SEFB1$DESTRUCTURE CV_HOLD0$DESTRUCTURE
                                  CV_HOLD1$DESTRUCTURE CV_V11010$DESTRUCTURE
                                  CV_V11011$DESTRUCTURE CV_RESET0$DESTRUCTURE
                                  CV_RESET1$DESTRUCTURE CV_RESET2$DESTRUCTURE
                                  CV_V11111$DESTRUCTURE))

(PROVE-LEMMA BVP-CV-VECTORS
             (REWRITE)
             (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                      (AND (BVP (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_FETCH2 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_DECODE RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_REGA RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_REGB RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READA0 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READA2 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READB0 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READB1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_WRITE2 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                           (BVP (CV_V11010 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_V11011 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_RESET0 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_RESET1 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_RESET2 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))
                           (BVP (CV_V11111 RW- REGS-ADDRESS I-REG FLAGS
                                           PC-REG))))
             ((ENABLE-THEORY CV-THEORY)
              (ENABLE BVP-LENGTH-STATE-VECTORS)))

(TOGGLE BVP-CV-VECTORS-OFF BVP-CV-VECTORS T)

(PROVE-LEMMA CV_FETCH1$RW-DOAN-MATTA
             (REWRITE)
             (EQUAL (CV_FETCH1 F REGS-ADDRESS I-REG FLAGS PC-REG)
                    (CV_FETCH1 T REGS-ADDRESS I-REG FLAGS PC-REG))
             ((ENABLE CV_FETCH1)))

(PROVE-LEMMA PROPERP-LENGTH-CV_FETCH1
             (REWRITE)
             (AND (IMPLIES (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                           (EQUAL (LENGTH (CV_FETCH1 RW- REGS-ADDRESS I-REG
                                                     FLAGS PC-REG))
                                  40))
                  (PROPERP (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE CV_FETCH1 V_FETCH1)))

(DEFN F$CONTROL-LET
      (I-REG FLAGS REGS-ADDRESS)
      (LIST (ID (A-IMMEDIATE-P I-REG))
            (F$B-STORE-RESULTP (STORE-CC I-REG)
                               FLAGS)
            (F$SET-SOME-FLAGS (SET-FLAGS I-REG))
            (F-OR (ID (A-IMMEDIATE-P I-REG))
                  (CAR (F$DECODE-REG-MODE (MODE-A I-REG))))
            (CAR (F$DECODE-REG-MODE (MODE-B I-REG)))
            (F$UNARY-OP-CODE-P (OP-CODE I-REG))
            (CADR (F$DECODE-REG-MODE (MODE-A I-REG)))
            (CADR (F$DECODE-REG-MODE (MODE-B I-REG)))
            (ID (C-FLAG FLAGS))
            (F$ALL-T-REGS-ADDRESS REGS-ADDRESS)
            (F-AND (F-NOT (ID (A-IMMEDIATE-P I-REG)))
                   (CADDR (F$DECODE-REG-MODE (MODE-A I-REG))))
            (CADDR (F$DECODE-REG-MODE (MODE-B I-REG)))))

(TOGGLE F$CONTROL-LET-OFF F$CONTROL-LET T)

(DEFN CONTROL-LET* NIL
 (CONS 'CONTROL-LET
  (CONS
   (APPEND (INDICES 'I-REG 0 32)
           (APPEND (INDICES 'FLAGS 0 4)
                   (INDICES 'REGS-ADDRESS 0 4)))
   (CONS
    '(A-IMMEDIATE-P STORE SET-SOME-FLAGS DIRECT-A DIRECT-B UNARY PRE-DEC-A
                    PRE-DEC-B C ALL-T-REGS-ADDRESS SIDE-EFFECT-A SIDE-EFFECT-B)
    (CONS
     (CONS
      (LIST 'G0
            '(A-IMMEDIATE-P)
            'ID
            (LIST (A-IMMEDIATE-P (INDICES 'I-REG 0 32))))
      (CONS
       '(G1 (A-IMMEDIATE-P-)
            B-NOT
            (A-IMMEDIATE-P))
       (CONS
        (LIST 'G2
              '(STORE)
              'B-STORE-RESULTP
              (APPEND (STORE-CC (INDICES 'I-REG 0 32))
                      (INDICES 'FLAGS 0 4)))
        (CONS
         (LIST 'G3
               '(SET-SOME-FLAGS)
               'B-OR4
               (SET-FLAGS (INDICES 'I-REG 0 32)))
         (CONS
          (LIST 'G4
                '(ALMOST-DIRECT-A PRE-DEC-A ALMOST-SIDE-EFFECT-A)
                'DECODE-REG-MODE
                (MODE-A (INDICES 'I-REG 0 32)))
          (CONS
             (LIST 'G5
                   '(DIRECT-B PRE-DEC-B SIDE-EFFECT-B)
                   'DECODE-REG-MODE
                   (MODE-B (INDICES 'I-REG 0 32)))
             (CONS (LIST 'G6
                         '(UNARY)
                         'UNARY-OP-CODE-P
                         (OP-CODE (INDICES 'I-REG 0 32)))
                   (CONS (LIST 'G7
                               '(C)
                               'ID
                               (LIST (C-FLAG (INDICES 'FLAGS 0 4))))
                         (CONS (LIST 'G8
                                     '(ALL-T-REGS-ADDRESS)
                                     'B-AND4
                                     (INDICES 'REGS-ADDRESS 0 4))
                               '((G9 (SIDE-EFFECT-A)
                                     B-AND
                                     (A-IMMEDIATE-P- ALMOST-SIDE-EFFECT-A))
                                 (GA (DIRECT-A)
                                     B-OR
                                     (A-IMMEDIATE-P ALMOST-DIRECT-A))))))))))))
     '(NIL))))))

(DEFN CONTROL-LET&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CONTROL-LET NETLIST)
                  (CONTROL-LET*))
           (B-NOT& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (B-STORE-RESULTP& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (B-OR4& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (DECODE-REG-MODE& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (UNARY-OP-CODE-P& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (ID& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (B-AND4& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (B-AND& (DELETE-MODULE 'CONTROL-LET NETLIST))
           (B-OR& (DELETE-MODULE 'CONTROL-LET
                                 NETLIST))))

(TOGGLE CONTROL-LET&-OFF CONTROL-LET& T)

(DEFN CONTROL-LET$NETLIST NIL
 (CONS
  (CONTROL-LET*)
  (UNION
    (UNION (UNION (UNION (UNION (UNION (UNION (UNION (B-NOT$NETLIST)
                                                     (B-STORE-RESULTP$NETLIST))
                                              (B-OR4$NETLIST))
                                       (DECODE-REG-MODE$NETLIST))
                                (UNARY-OP-CODE-P$NETLIST))
                         (ID$NETLIST))
                  (B-AND4$NETLIST))
           (B-AND$NETLIST))
    (B-OR$NETLIST))))

(PROVE-LEMMA CONTROL-LET$VALUE
             (REWRITE)
             (IMPLIES (AND (CONTROL-LET& NETLIST)
                           (PROPERP I-REG)
                           (EQUAL (LENGTH I-REG) 32)
                           (PROPERP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4)
                           (PROPERP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4))
                      (EQUAL (DUAL-EVAL 0 'CONTROL-LET
                                        (APPEND I-REG
                                                (APPEND FLAGS REGS-ADDRESS))
                                        STATE NETLIST)
                             (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS)))
             ((ENABLE F$CONTROL-LET CONTROL-LET& NTH-INDICES C-FLAG
                      B-OR4$VALUE-AS-F$SET-SOME-FLAGS
                      B-AND4$VALUE-AS-F$ALL-T-REGS-ADDRESS B-NOT$VALUE
                      B-STORE-RESULTP$VALUE B-OR4$VALUE DECODE-REG-MODE$VALUE
                      UNARY-OP-CODE-P$VALUE ID$VALUE B-AND4$VALUE B-AND$VALUE
                      B-OR$VALUE)
              (DISABLE OPEN-INDICES *1*INDICES INDICES)
              (ENABLE-THEORY IR-FIELDS-THEORY)
              (DISABLE-THEORY F-GATES)))

(TOGGLE CONTROL-LET$VALUE-OFF CONTROL-LET$VALUE T)

(PROVE-LEMMA F$CONTROL-LET=CONTROL-LET
             (REWRITE)
             (IMPLIES (AND (BVP I-REG)
                           (EQUAL (LENGTH I-REG) 32)
                           (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4)
                           (BVP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4))
                      (EQUAL (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS)
                             (LIST (A-IMMEDIATE-P I-REG)
                                   (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                   (SET-SOME-FLAGS (SET-FLAGS I-REG))
                                   (OR* (A-IMMEDIATE-P I-REG)
                                        (REG-DIRECT-P (MODE-A I-REG)))
                                   (REG-DIRECT-P (MODE-B I-REG))
                                   (UNARY-OP-CODE-P (OP-CODE I-REG))
                                   (PRE-DEC-P (MODE-A I-REG))
                                   (PRE-DEC-P (MODE-B I-REG))
                                   (C-FLAG FLAGS)
                                   (EQUAL REGS-ADDRESS (LIST T T T T))
                                   (AND* (NOT* (A-IMMEDIATE-P I-REG))
                                         (OR* (PRE-DEC-P (MODE-A I-REG))
                                              (POST-INC-P (MODE-A I-REG))))
                                   (OR* (PRE-DEC-P (MODE-B I-REG))
                                        (POST-INC-P (MODE-B I-REG))))))
             ((ENABLE F$CONTROL-LET BOOLP-B-GATES EXPAND-*-CONNECTIVES
                      NTH-INDICES BVP-LENGTH C-FLAG)
              (DISABLE OPEN-INDICES *1*INDICES INDICES)
              (ENABLE-THEORY IR-FIELDS-THEORY)
              (DISABLE-THEORY F-GATES)))

(DEFN NEXT-STATE
      (DECODED-STATE STORE SET-SOME-FLAGS UNARY DIRECT-A DIRECT-B
                     SIDE-EFFECT-A SIDE-EFFECT-B ALL-T-REGS-ADDRESS DTACK-
                     HOLD-)
      (LIST (B-NAND (B-AND4 (B-NAND ALL-T-REGS-ADDRESS
                                    (NTH 30 DECODED-STATE))
                            (B-NOT (NTH 25 DECODED-STATE))
                            (B-NOT (NTH 23 DECODED-STATE))
                            (B-NAND (B-NOT SIDE-EFFECT-B)
                                    (NTH 21 DECODED-STATE)))
                    (B-AND3 (B-NAND (B-NOT DTACK-)
                                    (NTH 19 DECODED-STATE))
                            (B-NAND (B-NOT (B-AND SIDE-EFFECT-B UNARY))
                                    (NTH 7 DECODED-STATE))
                            (B-NAND4 (B-NOT SIDE-EFFECT-B)
                                     (B-NOT SIDE-EFFECT-A)
                                     (B-NOT (B-OR STORE SET-SOME-FLAGS))
                                     (NTH 4 DECODED-STATE))))
            (NTH 0 DECODED-STATE)
            (B-AND HOLD- (NTH 1 DECODED-STATE))
            (B-NAND (B-NAND DTACK- (NTH 3 DECODED-STATE))
                    (B-NOT (NTH 2 DECODED-STATE)))
            (B-AND (B-NOT DTACK-)
                   (NTH 3 DECODED-STATE))
            (B-AND4 (B-OR DIRECT-B UNARY)
                    DIRECT-A
                    (B-OR STORE SET-SOME-FLAGS)
                    (NTH 4 DECODED-STATE))
            (B-AND3 (B-NOT UNARY)
                    DIRECT-B
                    (NTH 5 DECODED-STATE))
            (B-NAND6 (B-NAND3 (B-NOT STORE)
                              (B-NOT DTACK-)
                              (NTH 15 DECODED-STATE))
                     (B-NAND5 (B-NOT STORE)
                              UNARY
                              (B-NOT DIRECT-B)
                              (B-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (B-NAND3 DIRECT-B
                              (B-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (B-NOT (NTH 6 DECODED-STATE))
                     (B-NAND3 (B-NOT STORE)
                              (B-NOT DIRECT-B)
                              (NTH 5 DECODED-STATE))
                     (B-NAND3 UNARY DIRECT-B
                              (NTH 5 DECODED-STATE)))
            (B-AND3 (B-NOT DIRECT-A)
                    (B-OR STORE SET-SOME-FLAGS)
                    (NTH 4 DECODED-STATE))
            (NTH 8 DECODED-STATE)
            (NTH 9 DECODED-STATE)
            (B-NAND (B-NAND DTACK- (NTH 11 DECODED-STATE))
                    (B-NOT (NTH 10 DECODED-STATE)))
            (B-NAND (B-NAND4 (B-NOT UNARY)
                             (B-NOT DIRECT-B)
                             (B-NOT DTACK-)
                             (NTH 11 DECODED-STATE))
                    (B-NAND4 (B-NOT (B-OR DIRECT-B UNARY))
                             DIRECT-A
                             (B-OR STORE SET-SOME-FLAGS)
                             (NTH 4 DECODED-STATE)))
            (NTH 12 DECODED-STATE)
            (NTH 13 DECODED-STATE)
            (B-NAND (B-NAND DTACK- (NTH 15 DECODED-STATE))
                    (B-NOT (NTH 14 DECODED-STATE)))
            (B-NAND3 (B-NAND3 STORE
                              (B-NOT DTACK-)
                              (NTH 15 DECODED-STATE))
                     (B-NAND5 STORE UNARY
                              (B-NOT DIRECT-B)
                              (B-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (B-NAND3 STORE
                              (B-NOT DIRECT-B)
                              (NTH 5 DECODED-STATE)))
            (NTH 16 DECODED-STATE)
            (NTH 17 DECODED-STATE)
            (B-NAND (B-NAND DTACK- (NTH 19 DECODED-STATE))
                    (B-NOT (NTH 18 DECODED-STATE)))
            (B-AND3 SIDE-EFFECT-A
                    (B-NOT (B-OR STORE SET-SOME-FLAGS))
                    (NTH 4 DECODED-STATE))
            (NTH 20 DECODED-STATE)
            (B-NAND (B-NAND SIDE-EFFECT-B
                            (NTH 21 DECODED-STATE))
                    (B-NAND4 SIDE-EFFECT-B
                             (B-NOT SIDE-EFFECT-A)
                             (B-NOT (B-OR STORE SET-SOME-FLAGS))
                             (NTH 4 DECODED-STATE)))
            (B-NAND (B-NOT (NTH 22 DECODED-STATE))
                    (B-NAND (B-AND SIDE-EFFECT-B UNARY)
                            (NTH 7 DECODED-STATE)))
            (B-NAND (B-NAND (B-NOT HOLD-)
                            (NTH 24 DECODED-STATE))
                    (B-NAND (B-NOT HOLD-)
                            (NTH 1 DECODED-STATE)))
            (B-AND HOLD- (NTH 24 DECODED-STATE))
            (VSS)
            (VSS)
            (B-NAND3 (B-NOT (NTH 31 DECODED-STATE))
                     (B-NOT (NTH 27 DECODED-STATE))
                     (B-NOT (NTH 26 DECODED-STATE)))
            (NTH 28 DECODED-STATE)
            (B-NAND (B-NAND (B-NOT ALL-T-REGS-ADDRESS)
                            (NTH 30 DECODED-STATE))
                    (B-NOT (NTH 29 DECODED-STATE)))
            (VSS)))

(DEFN F$NEXT-STATE
      (DECODED-STATE STORE SET-SOME-FLAGS UNARY DIRECT-A DIRECT-B
                     SIDE-EFFECT-A SIDE-EFFECT-B ALL-T-REGS-ADDRESS DTACK-
                     HOLD-)
      (LIST (F-NAND (F-AND4 (F-NAND ALL-T-REGS-ADDRESS
                                    (NTH 30 DECODED-STATE))
                            (F-NOT (NTH 25 DECODED-STATE))
                            (F-NOT (NTH 23 DECODED-STATE))
                            (F-NAND (F-NOT SIDE-EFFECT-B)
                                    (NTH 21 DECODED-STATE)))
                    (F-AND3 (F-NAND (F-NOT DTACK-)
                                    (NTH 19 DECODED-STATE))
                            (F-NAND (F-NOT (F-AND SIDE-EFFECT-B UNARY))
                                    (NTH 7 DECODED-STATE))
                            (F-NAND4 (F-NOT SIDE-EFFECT-B)
                                     (F-NOT SIDE-EFFECT-A)
                                     (F-NOT (F-OR STORE SET-SOME-FLAGS))
                                     (NTH 4 DECODED-STATE))))
            (NTH 0 DECODED-STATE)
            (F-AND HOLD- (NTH 1 DECODED-STATE))
            (F-NAND (F-NAND DTACK- (NTH 3 DECODED-STATE))
                    (F-NOT (NTH 2 DECODED-STATE)))
            (F-AND (F-NOT DTACK-)
                   (NTH 3 DECODED-STATE))
            (F-AND4 (F-OR DIRECT-B UNARY)
                    DIRECT-A
                    (F-OR STORE SET-SOME-FLAGS)
                    (NTH 4 DECODED-STATE))
            (F-AND3 (F-NOT UNARY)
                    DIRECT-B
                    (NTH 5 DECODED-STATE))
            (F-NAND6 (F-NAND3 (F-NOT STORE)
                              (F-NOT DTACK-)
                              (NTH 15 DECODED-STATE))
                     (F-NAND5 (F-NOT STORE)
                              UNARY
                              (F-NOT DIRECT-B)
                              (F-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (F-NAND3 DIRECT-B
                              (F-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (F-NOT (NTH 6 DECODED-STATE))
                     (F-NAND3 (F-NOT STORE)
                              (F-NOT DIRECT-B)
                              (NTH 5 DECODED-STATE))
                     (F-NAND3 UNARY DIRECT-B
                              (NTH 5 DECODED-STATE)))
            (F-AND3 (F-NOT DIRECT-A)
                    (F-OR STORE SET-SOME-FLAGS)
                    (NTH 4 DECODED-STATE))
            (NTH 8 DECODED-STATE)
            (NTH 9 DECODED-STATE)
            (F-NAND (F-NAND DTACK- (NTH 11 DECODED-STATE))
                    (F-NOT (NTH 10 DECODED-STATE)))
            (F-NAND (F-NAND4 (F-NOT UNARY)
                             (F-NOT DIRECT-B)
                             (F-NOT DTACK-)
                             (NTH 11 DECODED-STATE))
                    (F-NAND4 (F-NOT (F-OR DIRECT-B UNARY))
                             DIRECT-A
                             (F-OR STORE SET-SOME-FLAGS)
                             (NTH 4 DECODED-STATE)))
            (NTH 12 DECODED-STATE)
            (NTH 13 DECODED-STATE)
            (F-NAND (F-NAND DTACK- (NTH 15 DECODED-STATE))
                    (F-NOT (NTH 14 DECODED-STATE)))
            (F-NAND3 (F-NAND3 STORE
                              (F-NOT DTACK-)
                              (NTH 15 DECODED-STATE))
                     (F-NAND5 STORE UNARY
                              (F-NOT DIRECT-B)
                              (F-NOT DTACK-)
                              (NTH 11 DECODED-STATE))
                     (F-NAND3 STORE
                              (F-NOT DIRECT-B)
                              (NTH 5 DECODED-STATE)))
            (NTH 16 DECODED-STATE)
            (NTH 17 DECODED-STATE)
            (F-NAND (F-NAND DTACK- (NTH 19 DECODED-STATE))
                    (F-NOT (NTH 18 DECODED-STATE)))
            (F-AND3 SIDE-EFFECT-A
                    (F-NOT (F-OR STORE SET-SOME-FLAGS))
                    (NTH 4 DECODED-STATE))
            (NTH 20 DECODED-STATE)
            (F-NAND (F-NAND SIDE-EFFECT-B
                            (NTH 21 DECODED-STATE))
                    (F-NAND4 SIDE-EFFECT-B
                             (F-NOT SIDE-EFFECT-A)
                             (F-NOT (F-OR STORE SET-SOME-FLAGS))
                             (NTH 4 DECODED-STATE)))
            (F-NAND (F-NOT (NTH 22 DECODED-STATE))
                    (F-NAND (F-AND SIDE-EFFECT-B UNARY)
                            (NTH 7 DECODED-STATE)))
            (F-NAND (F-NAND (F-NOT HOLD-)
                            (NTH 24 DECODED-STATE))
                    (F-NAND (F-NOT HOLD-)
                            (NTH 1 DECODED-STATE)))
            (F-AND HOLD- (NTH 24 DECODED-STATE))
            (VSS)
            (VSS)
            (F-NAND3 (F-NOT (NTH 31 DECODED-STATE))
                     (F-NOT (NTH 27 DECODED-STATE))
                     (F-NOT (NTH 26 DECODED-STATE)))
            (NTH 28 DECODED-STATE)
            (F-NAND (F-NAND (F-NOT ALL-T-REGS-ADDRESS)
                            (NTH 30 DECODED-STATE))
                    (F-NOT (NTH 29 DECODED-STATE)))
            (VSS)))

(TOGGLE F$NEXT-STATE-OFF F$NEXT-STATE T)

(PROVE-LEMMA F$NEXT-STATE=NEXT-STATE
             (REWRITE)
             (IMPLIES (AND (BVP DECODED-STATE)
                           (EQUAL (LENGTH DECODED-STATE) 32)
                           (BOOLP STORE)
                           (BOOLP SET-SOME-FLAGS)
                           (BOOLP UNARY)
                           (BOOLP DIRECT-A)
                           (BOOLP DIRECT-B)
                           (BOOLP SIDE-EFFECT-A)
                           (BOOLP SIDE-EFFECT-B)
                           (BOOLP ALL-T-REGS-ADDRESS)
                           (BOOLP DTACK-)
                           (BOOLP HOLD-))
                      (EQUAL (F$NEXT-STATE DECODED-STATE STORE SET-SOME-FLAGS
                                           UNARY DIRECT-A DIRECT-B
                                           SIDE-EFFECT-A SIDE-EFFECT-B
                                           ALL-T-REGS-ADDRESS DTACK- HOLD-)
                             (NEXT-STATE DECODED-STATE STORE SET-SOME-FLAGS
                                         UNARY DIRECT-A DIRECT-B
                                         SIDE-EFFECT-A SIDE-EFFECT-B
                                         ALL-T-REGS-ADDRESS DTACK- HOLD-)))
             ((ENABLE F$NEXT-STATE NEXT-STATE BOOLP-B-GATES)
              (DISABLE-THEORY F-GATES B-GATES)))

(DEFN NEXT-STATE* NIL
      (CONS 'NEXT-STATE
            (CONS (APPEND (INDICES 'S 0 32)
                          '(STORE SET-SOME-FLAGS UNARY DIRECT-A DIRECT-B
                                  SIDE-EFFECT-A SIDE-EFFECT-B
                                  ALL-T-REGS-ADDRESS DTACK- HOLD-))
                  (CONS '(W-17 W-18 W-19 W-22 W-24 W-27 W-29 W-44 W-47 W-48
                               W-49 W-52 W-61 W-62 W-63 W-66 W-74 W-75 W-76
                               W-79 W-82 W-83 W-89 W-93 W-98 W-99 W-112 W-113
                               W-105 W-106 W-110 W-111)
                        (CONS (APPEND (LIST (LIST 'R-0
                                                  '(FETCH0)
                                                  'ID
                                                  (LIST (INDEX 'S 0)))
                                            (LIST 'R-1
                                                  '(FETCH1)
                                                  'ID
                                                  (LIST (INDEX 'S 1)))
                                            (LIST 'R-2
                                                  '(FETCH2)
                                                  'ID
                                                  (LIST (INDEX 'S 2)))
                                            (LIST 'R-3
                                                  '(FETCH3)
                                                  'ID
                                                  (LIST (INDEX 'S 3)))
                                            (LIST 'R-4
                                                  '(DECODE)
                                                  'ID
                                                  (LIST (INDEX 'S 4)))
                                            (LIST 'R-5
                                                  '(REGA)
                                                  'ID
                                                  (LIST (INDEX 'S 5)))
                                            (LIST 'R-6
                                                  '(REGB)
                                                  'ID
                                                  (LIST (INDEX 'S 6)))
                                            (LIST 'R-7
                                                  '(UPDATE)
                                                  'ID
                                                  (LIST (INDEX 'S 7)))
                                            (LIST 'R-8
                                                  '(READA0)
                                                  'ID
                                                  (LIST (INDEX 'S 8)))
                                            (LIST 'R-9
                                                  '(READA1)
                                                  'ID
                                                  (LIST (INDEX 'S 9)))
                                            (LIST 'R-10
                                                  '(READA2)
                                                  'ID
                                                  (LIST (INDEX 'S 10)))
                                            (LIST 'R-11
                                                  '(READA3)
                                                  'ID
                                                  (LIST (INDEX 'S 11)))
                                            (LIST 'R-12
                                                  '(READB0)
                                                  'ID
                                                  (LIST (INDEX 'S 12)))
                                            (LIST 'R-13
                                                  '(READB1)
                                                  'ID
                                                  (LIST (INDEX 'S 13)))
                                            (LIST 'R-14
                                                  '(READB2)
                                                  'ID
                                                  (LIST (INDEX 'S 14)))
                                            (LIST 'R-15
                                                  '(READB3)
                                                  'ID
                                                  (LIST (INDEX 'S 15)))
                                            (LIST 'R-16
                                                  '(WRITE0)
                                                  'ID
                                                  (LIST (INDEX 'S 16)))
                                            (LIST 'R-17
                                                  '(WRITE1)
                                                  'ID
                                                  (LIST (INDEX 'S 17)))
                                            (LIST 'R-18
                                                  '(WRITE2)
                                                  'ID
                                                  (LIST (INDEX 'S 18)))
                                            (LIST 'R-19
                                                  '(WRITE3)
                                                  'ID
                                                  (LIST (INDEX 'S 19)))
                                            (LIST 'R-20
                                                  '(SEFA0)
                                                  'ID
                                                  (LIST (INDEX 'S 20)))
                                            (LIST 'R-21
                                                  '(SEFA1)
                                                  'ID
                                                  (LIST (INDEX 'S 21)))
                                            (LIST 'R-22
                                                  '(SEFB0)
                                                  'ID
                                                  (LIST (INDEX 'S 22)))
                                            (LIST 'R-23
                                                  '(SEFB1)
                                                  'ID
                                                  (LIST (INDEX 'S 23)))
                                            (LIST 'R-24
                                                  '(HOLD0)
                                                  'ID
                                                  (LIST (INDEX 'S 24)))
                                            (LIST 'R-25
                                                  '(HOLD1)
                                                  'ID
                                                  (LIST (INDEX 'S 25)))
                                            (LIST 'R-26
                                                  '(V11010)
                                                  'ID
                                                  (LIST (INDEX 'S 26)))
                                            (LIST 'R-27
                                                  '(V11011)
                                                  'ID
                                                  (LIST (INDEX 'S 27)))
                                            (LIST 'R-28
                                                  '(RESET0)
                                                  'ID
                                                  (LIST (INDEX 'S 28)))
                                            (LIST 'R-29
                                                  '(RESET1)
                                                  'ID
                                                  (LIST (INDEX 'S 29)))
                                            (LIST 'R-30
                                                  '(RESET2)
                                                  'ID
                                                  (LIST (INDEX 'S 30)))
                                            (LIST 'R-31
                                                  '(V11111)
                                                  'ID
                                                  (LIST (INDEX 'S 31))))
                                      '((G-111 (W-111) VSS NIL)
                                        (G-109 (W-109) B-NOT (RESET1))
                                        (G-107 (W-107)
                                               B-NOT
                                               (ALL-T-REGS-ADDRESS))
                                        (G-108 (W-108) B-NAND (W-107 RESET2))
                                        (G-110 (W-110) B-NAND (W-108 W-109))
                                        (G-106 (W-106) ID (RESET0))
                                        (G-104 (W-104) B-NOT (V11010))
                                        (G-103 (W-103) B-NOT (V11011))
                                        (G-102 (W-102) B-NOT (V11111))
                                        (G-105 (W-105)
                                               B-NAND3
                                               (W-102 W-103 W-104))
                                        (G-99 (W-99) B-AND (HOLD- HOLD0))
                                        (G-96 (W-96) B-NOT (HOLD-))
                                        (G-97 (W-97) B-NAND (W-96 FETCH1))
                                        (G-95 (W-95) B-NAND (W-96 HOLD0))
                                        (G-98 (W-98) B-NAND (W-95 W-97))
                                        (G-91 (W-91)
                                              B-AND
                                              (SIDE-EFFECT-B UNARY))
                                        (G-92 (W-92) B-NAND (W-91 UPDATE))
                                        (G-90 (W-90) B-NOT (SEFB0))
                                        (G-93 (W-93) B-NAND (W-90 W-92))
                                        (G-86 (W-86)
                                              B-OR
                                              (STORE SET-SOME-FLAGS))
                                        (G-87 (W-87) B-NOT (W-86))
                                        (G-85 (W-85) B-NOT (SIDE-EFFECT-A))
                                        (G-88 (W-88)
                                              B-NAND4
                                              (SIDE-EFFECT-B W-85 W-87 DECODE))
                                        (G-84 (W-84)
                                              B-NAND
                                              (SIDE-EFFECT-B SEFA1))
                                        (G-89 (W-89) B-NAND (W-84 W-88))
                                        (G-83 (W-83) ID (SEFA0))
                                        (G-82 (W-82)
                                              B-AND3
                                              (SIDE-EFFECT-A W-87 DECODE))
                                        (G-78 (W-78) B-NOT (WRITE2))
                                        (G-77 (W-77) B-NAND (DTACK- WRITE3))
                                        (G-79 (W-79) B-NAND (W-77 W-78))
                                        (G-76 (W-76) ID (WRITE1))
                                        (G-75 (W-75) ID (WRITE0))
                                        (G-72 (W-72) B-NOT (DIRECT-B))
                                        (G-73 (W-73)
                                              B-NAND3
                                              (STORE W-72 REGA))
                                        (G-70 (W-70) B-NOT (DTACK-))
                                        (G-71 (W-71)
                                              B-NAND5
                                              (STORE UNARY W-72 W-70 READA3))
                                        (G-68 (W-68)
                                              B-NAND3
                                              (STORE W-70 READB3))
                                        (G-74 (W-74) B-NAND3 (W-68 W-71 W-73))
                                        (G-65 (W-65) B-NOT (READB2))
                                        (G-64 (W-64) B-NAND (DTACK- READB3))
                                        (G-66 (W-66) B-NAND (W-64 W-65))
                                        (G-63 (W-63) ID (READB1))
                                        (G-62 (W-62) ID (READB0))
                                        (G-57 (W-57) B-OR (DIRECT-B UNARY))
                                        (G-58 (W-58) B-NOT (W-57))
                                        (G-60 (W-60)
                                              B-NAND4
                                              (W-58 DIRECT-A W-86 DECODE))
                                        (G-53 (W-53) B-NOT (UNARY))
                                        (G-56 (W-56)
                                              B-NAND4
                                              (W-53 W-72 W-70 READA3))
                                        (G-61 (W-61) B-NAND (W-56 W-60))
                                        (G-51 (W-51) B-NOT (READA2))
                                        (G-50 (W-50) B-NAND (DTACK- READA3))
                                        (G-52 (W-52) B-NAND (W-50 W-51))
                                        (G-49 (W-49) ID (READA1))
                                        (G-48 (W-48) ID (READA0))
                                        (G-45 (W-45) B-NOT (DIRECT-A))
                                        (G-47 (W-47)
                                              B-AND3
                                              (W-45 W-86 DECODE))
                                        (G-43 (W-43)
                                              B-NAND3
                                              (UNARY DIRECT-B REGA))
                                        (G-40 (W-40) B-NOT (STORE))
                                        (G-42 (W-42) B-NAND3 (W-40 W-72 REGA))
                                        (G-39 (W-39) B-NOT (REGB))
                                        (G-38 (W-38)
                                              B-NAND3
                                              (DIRECT-B W-70 READA3))
                                        (G-36 (W-36)
                                              B-NAND5
                                              (W-40 UNARY W-72 W-70 READA3))
                                        (G-32 (W-32)
                                              B-NAND3
                                              (W-40 W-70 READB3))
                                        (G-44 (W-44)
                                              B-NAND6
                                              (W-32 W-36 W-38 W-39 W-42 W-43))
                                        (G-29 (W-29)
                                              B-AND3
                                              (W-53 DIRECT-B REGA))
                                        (G-27 (W-27)
                                              B-AND4
                                              (W-57 DIRECT-A W-86 DECODE))
                                        (G-24 (W-24) B-AND (W-70 FETCH3))
                                        (G-21 (W-21) B-NOT (FETCH2))
                                        (G-20 (W-20) B-NAND (DTACK- FETCH3))
                                        (G-22 (W-22) B-NAND (W-20 W-21))
                                        (G-19 (W-19) B-AND (HOLD- FETCH1))
                                        (G-18 (W-18) ID (FETCH0))
                                        (G-11 (W-11) B-NOT (SIDE-EFFECT-B))
                                        (G-15 (W-15)
                                              B-NAND4
                                              (W-11 W-85 W-87 DECODE))
                                        (G-9 (W-9) B-NOT (W-91))
                                        (G-10 (W-10) B-NAND (W-9 UPDATE))
                                        (G-7 (W-7) B-NAND (W-70 WRITE3))
                                        (G-16 (W-16) B-AND3 (W-7 W-10 W-15))
                                        (G-4 (W-4) B-NAND (W-11 SEFA1))
                                        (G-2 (W-2) B-NOT (SEFB1))
                                        (G-1 (W-1) B-NOT (HOLD1))
                                        (G-0 (W-0)
                                             B-NAND
                                             (ALL-T-REGS-ADDRESS RESET2))
                                        (G-5 (W-5) B-AND4 (W-0 W-1 W-2 W-4))
                                        (G-17 (W-17) B-NAND (W-5 W-16))
                                        (G-112 (W-112) ID (W-111))
                                        (G-113 (W-113) ID (W-111))))
                              '(NIL))))))

(DEFN NEXT-STATE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'NEXT-STATE NETLIST)
                  (NEXT-STATE*))
           (VSS& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-OR& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NAND5& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NAND3& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NAND6& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-AND& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NAND4& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-AND3& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NOT& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-AND4& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (B-NAND& (DELETE-MODULE 'NEXT-STATE NETLIST))
           (ID& (DELETE-MODULE 'NEXT-STATE
                               NETLIST))))

(TOGGLE NEXT-STATE&-OFF NEXT-STATE& T)

(DEFN NEXT-STATE$NETLIST NIL
 (CONS
  (NEXT-STATE*)
  (UNION
   (UNION
    (UNION
     (UNION
      (UNION
        (UNION (UNION (UNION (UNION (UNION (UNION (VSS$NETLIST) (B-OR$NETLIST))
                                           (B-NAND5$NETLIST))
                                    (B-NAND3$NETLIST))
                             (B-NAND6$NETLIST))
                      (B-AND$NETLIST))
               (B-NAND4$NETLIST))
        (B-AND3$NETLIST))
      (B-NOT$NETLIST))
     (B-AND4$NETLIST))
    (B-NAND$NETLIST))
   (ID$NETLIST))))

(PROVE-LEMMA BVP-LENGTH-NEXT-STATE
             (REWRITE)
             (AND (EQUAL (LENGTH (NEXT-STATE DECODED-STATE STORE
                                             SET-SOME-FLAGS UNARY DIRECT-A
                                             DIRECT-B SIDE-EFFECT-A
                                             SIDE-EFFECT-B ALL-T-REGS-ADDRESS
                                             DTACK- HOLD-))
                         32)
                  (IMPLIES (AND (BVP DECODED-STATE)
                                (EQUAL (LENGTH DECODED-STATE) 32))
                           (BVP (NEXT-STATE DECODED-STATE STORE
                                            SET-SOME-FLAGS UNARY DIRECT-A
                                            DIRECT-B SIDE-EFFECT-A
                                            SIDE-EFFECT-B
                                            ALL-T-REGS-ADDRESS DTACK- HOLD-))))
             ((ENABLE BVP NEXT-STATE)))

(PROVE-LEMMA PROPERP-LENGTH-F$NEXT-STATE
             (REWRITE)
             (AND (EQUAL (LENGTH (F$NEXT-STATE DECODED-STATE STORE
                                               SET-SOME-FLAGS UNARY DIRECT-A
                                               DIRECT-B SIDE-EFFECT-A
                                               SIDE-EFFECT-B
                                               ALL-T-REGS-ADDRESS DTACK-
                                               HOLD-))
                         32)
                  (PROPERP (F$NEXT-STATE DECODED-STATE STORE SET-SOME-FLAGS
                                         UNARY DIRECT-A DIRECT-B
                                         SIDE-EFFECT-A SIDE-EFFECT-B
                                         ALL-T-REGS-ADDRESS DTACK- HOLD-)))
             ((ENABLE F$NEXT-STATE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA NEXT-STATE$VALUE
             (REWRITE)
             (IMPLIES (AND (NEXT-STATE& NETLIST)
                           (PROPERP DECODED-STATE)
                           (EQUAL (LENGTH DECODED-STATE) 32))
                      (EQUAL (DUAL-EVAL 0 'NEXT-STATE
                                        (APPEND DECODED-STATE
                                                (LIST STORE SET-SOME-FLAGS
                                                      UNARY DIRECT-A DIRECT-B
                                                      SIDE-EFFECT-A
                                                      SIDE-EFFECT-B
                                                      ALL-T-REGS-ADDRESS
                                                      DTACK- HOLD-))
                                        STATE NETLIST)
                             (F$NEXT-STATE DECODED-STATE STORE
                                           SET-SOME-FLAGS UNARY DIRECT-A
                                           DIRECT-B SIDE-EFFECT-A
                                           SIDE-EFFECT-B ALL-T-REGS-ADDRESS
                                           DTACK- HOLD-)))
             ((ENABLE NEXT-STATE& F$NEXT-STATE VSS$VALUE B-OR$VALUE
                      B-NAND5$VALUE B-NAND3$VALUE B-NAND6$VALUE B-AND$VALUE
                      B-NAND4$VALUE B-AND3$VALUE B-NOT$VALUE B-AND4$VALUE
                      B-NAND$VALUE ID$VALUE)
              (DISABLE OPEN-INDICES *1*INDICES INDICES)
              (DISABLE-THEORY F-GATES)))

(TOGGLE NEXT-STATE$VALUE-OFF NEXT-STATE$VALUE T)

(DEFN CV
 (DECODED-STATE RN-A RN-B OP-CODE PC-REG REGS-ADDRESS SET-FLAGS STORE C
                A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A SIDE-EFFECT-B
                PRE-DEC-A PRE-DEC-B)
 (CONS
  (B-AND (B-NAND (B-NOT RW-)
                 (NTH 0 DECODED-STATE))
         (B-NOR3 (NTH 17 DECODED-STATE)
                 (NTH 18 DECODED-STATE)
                 (NTH 19 DECODED-STATE)))
  (CONS
   (B-NOR8 (NTH 2 DECODED-STATE)
           (NTH 3 DECODED-STATE)
           (NTH 10 DECODED-STATE)
           (NTH 11 DECODED-STATE)
           (NTH 14 DECODED-STATE)
           (NTH 15 DECODED-STATE)
           (NTH 18 DECODED-STATE)
           (NTH 19 DECODED-STATE))
   (CONS
    (B-NOT (NTH 24 DECODED-STATE))
    (CONS
     (B-NAND5 (B-NAND STORE (NTH 7 DECODED-STATE))
              (B-NAND SIDE-EFFECT-A
                      (NTH 9 DECODED-STATE))
              (B-NAND3 (B-NOT STORE)
                       SIDE-EFFECT-B
                       (NTH 14 DECODED-STATE))
              (B-NAND SIDE-EFFECT-B
                      (NTH 17 DECODED-STATE))
              (B-NOR5 (NTH 2 DECODED-STATE)
                      (NTH 21 DECODED-STATE)
                      (NTH 23 DECODED-STATE)
                      (NTH 28 DECODED-STATE)
                      (NTH 30 DECODED-STATE)))
     (CONS
      (B-NAND (B-NAND DIRECT-A
                      (NTH 13 DECODED-STATE))
              (B-NOR6 (NTH 0 DECODED-STATE)
                      (NTH 5 DECODED-STATE)
                      (NTH 8 DECODED-STATE)
                      (NTH 11 DECODED-STATE)
                      (NTH 20 DECODED-STATE)
                      (NTH 29 DECODED-STATE)))
      (CONS
       (B-NAND (B-NOR4 (NTH 6 DECODED-STATE)
                       (NTH 7 DECODED-STATE)
                       (NTH 10 DECODED-STATE)
                       (NTH 12 DECODED-STATE))
               (B-NOR4 (NTH 15 DECODED-STATE)
                       (NTH 16 DECODED-STATE)
                       (NTH 22 DECODED-STATE)
                       (NTH 29 DECODED-STATE)))
       (CONS
        (B-OR (NTH 3 DECODED-STATE)
              (NTH 29 DECODED-STATE))
        (CONS
         (B-OR (NTH 16 DECODED-STATE)
               (NTH 28 DECODED-STATE))
         (CONS
          (B-NAND (B-NOR3 (NTH 0 DECODED-STATE)
                          (NTH 8 DECODED-STATE)
                          (NTH 12 DECODED-STATE))
                  (B-NOR (NTH 16 DECODED-STATE)
                         (NTH 29 DECODED-STATE)))
          (CONS
           (B-OR3 (NTH 0 DECODED-STATE)
                  (NTH 24 DECODED-STATE)
                  (NTH 28 DECODED-STATE))
           (CONS
            (B-OR (NTH 24 DECODED-STATE)
                  (NTH 28 DECODED-STATE))
            (CONS
             (B-OR3 (NTH 3 DECODED-STATE)
                    (NTH 11 DECODED-STATE)
                    (NTH 15 DECODED-STATE))
             (CONS
              (B-NAND (B-NAND PRE-DEC-A
                              (NTH 8 DECODED-STATE))
                      (B-NAND PRE-DEC-B
                              (B-OR (NTH 12 DECODED-STATE)
                                    (NTH 16 DECODED-STATE))))
              (CONS
               (B-AND A-IMMEDIATE-P
                      (B-OR (NTH 5 DECODED-STATE)
                            (NTH 13 DECODED-STATE)))
               (CONS
                (CARRY-IN-HELP
                 (CONS C
                  (CONS
                     (B-OR4 (NTH 0 DECODED-STATE)
                            (NTH 28 DECODED-STATE)
                            (NTH 29 DECODED-STATE)
                            (NTH 30 DECODED-STATE))
                     (V-IF (B-NOR4 (NTH 2 DECODED-STATE)
                                   (B-OR (NTH 9 DECODED-STATE)
                                         (NTH 21 DECODED-STATE))
                                   (B-OR3 (NTH 14 DECODED-STATE)
                                          (NTH 17 DECODED-STATE)
                                          (NTH 23 DECODED-STATE))
                                   (B-OR4 (NTH 0 DECODED-STATE)
                                          (NTH 28 DECODED-STATE)
                                          (NTH 29 DECODED-STATE)
                                          (NTH 30 DECODED-STATE)))
                           OP-CODE
                           (V-IF (B-NAND (B-NAND (B-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (B-NAND (B-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP))))))
                (CONS
                 (B-OR4 (NTH 0 DECODED-STATE)
                        (NTH 28 DECODED-STATE)
                        (NTH 29 DECODED-STATE)
                        (NTH 30 DECODED-STATE))
                 (APPEND
                  (ENCODE-32 (NTH 0 DECODED-STATE)
                             (NTH 1 DECODED-STATE)
                             (NTH 2 DECODED-STATE)
                             (NTH 3 DECODED-STATE)
                             (NTH 4 DECODED-STATE)
                             (NTH 5 DECODED-STATE)
                             (NTH 6 DECODED-STATE)
                             (NTH 7 DECODED-STATE)
                             (NTH 8 DECODED-STATE)
                             (NTH 9 DECODED-STATE)
                             (NTH 10 DECODED-STATE)
                             (NTH 11 DECODED-STATE)
                             (NTH 12 DECODED-STATE)
                             (NTH 13 DECODED-STATE)
                             (NTH 14 DECODED-STATE)
                             (NTH 15 DECODED-STATE)
                             (NTH 16 DECODED-STATE)
                             (NTH 17 DECODED-STATE)
                             (NTH 18 DECODED-STATE)
                             (NTH 19 DECODED-STATE)
                             (NTH 20 DECODED-STATE)
                             (NTH 21 DECODED-STATE)
                             (NTH 22 DECODED-STATE)
                             (NTH 23 DECODED-STATE)
                             (NTH 24 DECODED-STATE)
                             (NTH 25 DECODED-STATE)
                             (NTH 26 DECODED-STATE)
                             (NTH 27 DECODED-STATE)
                             (NTH 28 DECODED-STATE)
                             (NTH 29 DECODED-STATE)
                             (NTH 30 DECODED-STATE)
                             (NTH 31 DECODED-STATE))
                  (APPEND
                   (V-IF (B-NOR (NTH 7 DECODED-STATE)
                                (NTH 16 DECODED-STATE))
                         (V-IF (NTH 28 DECODED-STATE)
                               (MAKE-LIST 4 T)
                               (MAKE-LIST 4 F))
                         SET-FLAGS)
                   (APPEND
                    (V-IF (B-NAND (B-NOR3 (NTH 5 DECODED-STATE)
                                          (NTH 8 DECODED-STATE)
                                          (NTH 9 DECODED-STATE))
                                  (B-NOR3 (NTH 13 DECODED-STATE)
                                          (NTH 20 DECODED-STATE)
                                          (NTH 21 DECODED-STATE)))
                          RN-A
                          (V-IF (B-NAND (B-NOR5 (NTH 6 DECODED-STATE)
                                                (NTH 7 DECODED-STATE)
                                                (NTH 10 DECODED-STATE)
                                                (NTH 12 DECODED-STATE)
                                                (NTH 14 DECODED-STATE))
                                        (B-NOR4 (NTH 16 DECODED-STATE)
                                                (NTH 17 DECODED-STATE)
                                                (NTH 22 DECODED-STATE)
                                                (NTH 23 DECODED-STATE)))
                                RN-B
                                (V-IF (B-OR (NTH 28 DECODED-STATE)
                                            (NTH 29 DECODED-STATE))
                                      (MAKE-LIST 4 F)
                                      (V-IF (NTH 30 DECODED-STATE)
                                            (V-INC REGS-ADDRESS)
                                            PC-REG))))
                    (APPEND
                     (V-IF (B-NOR4 (NTH 2 DECODED-STATE)
                                   (B-OR (NTH 9 DECODED-STATE)
                                         (NTH 21 DECODED-STATE))
                                   (B-OR3 (NTH 14 DECODED-STATE)
                                          (NTH 17 DECODED-STATE)
                                          (NTH 23 DECODED-STATE))
                                   (B-OR4 (NTH 0 DECODED-STATE)
                                          (NTH 28 DECODED-STATE)
                                          (NTH 29 DECODED-STATE)
                                          (NTH 30 DECODED-STATE)))
                           OP-CODE
                           (V-IF (B-NAND (B-NAND (B-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (B-NAND (B-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))
                     (MPG
                      (CONS
                       (B-OR4 (NTH 0 DECODED-STATE)
                              (NTH 28 DECODED-STATE)
                              (NTH 29 DECODED-STATE)
                              (NTH 30 DECODED-STATE))
                       (CONS
                        (B-OR3 (NTH 14 DECODED-STATE)
                               (NTH 17 DECODED-STATE)
                               (NTH 23 DECODED-STATE))
                        (V-IF
                           (B-NOR4 (NTH 2 DECODED-STATE)
                                   (B-OR (NTH 9 DECODED-STATE)
                                         (NTH 21 DECODED-STATE))
                                   (B-OR3 (NTH 14 DECODED-STATE)
                                          (NTH 17 DECODED-STATE)
                                          (NTH 23 DECODED-STATE))
                                   (B-OR4 (NTH 0 DECODED-STATE)
                                          (NTH 28 DECODED-STATE)
                                          (NTH 29 DECODED-STATE)
                                          (NTH 30 DECODED-STATE)))
                           OP-CODE
                           (V-IF (B-NAND (B-NAND (B-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (B-NAND (B-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 (ALU-DEC-OP)
                                 (ALU-INC-OP)))))))))))))))))))))))))))

(TOGGLE CV-OFF CV T)

(DEFN F$CV
 (DECODED-STATE RN-A RN-B OP-CODE PC-REG REGS-ADDRESS SET-FLAGS STORE C
                A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A SIDE-EFFECT-B
                PRE-DEC-A PRE-DEC-B)
 (CONS
  (F-AND (F-NAND (F-NOT RW-)
                 (NTH 0 DECODED-STATE))
         (F-NOR3 (NTH 17 DECODED-STATE)
                 (NTH 18 DECODED-STATE)
                 (NTH 19 DECODED-STATE)))
  (CONS
   (F-NOR8 (NTH 2 DECODED-STATE)
           (NTH 3 DECODED-STATE)
           (NTH 10 DECODED-STATE)
           (NTH 11 DECODED-STATE)
           (NTH 14 DECODED-STATE)
           (NTH 15 DECODED-STATE)
           (NTH 18 DECODED-STATE)
           (NTH 19 DECODED-STATE))
   (CONS
    (F-NOT (NTH 24 DECODED-STATE))
    (CONS
     (F-NAND5 (F-NAND STORE (NTH 7 DECODED-STATE))
              (F-NAND SIDE-EFFECT-A
                      (NTH 9 DECODED-STATE))
              (F-NAND3 (F-NOT STORE)
                       SIDE-EFFECT-B
                       (NTH 14 DECODED-STATE))
              (F-NAND SIDE-EFFECT-B
                      (NTH 17 DECODED-STATE))
              (F-NOR5 (NTH 2 DECODED-STATE)
                      (NTH 21 DECODED-STATE)
                      (NTH 23 DECODED-STATE)
                      (NTH 28 DECODED-STATE)
                      (NTH 30 DECODED-STATE)))
     (CONS
      (F-NAND (F-NAND DIRECT-A
                      (NTH 13 DECODED-STATE))
              (F-NOR6 (NTH 0 DECODED-STATE)
                      (NTH 5 DECODED-STATE)
                      (NTH 8 DECODED-STATE)
                      (NTH 11 DECODED-STATE)
                      (NTH 20 DECODED-STATE)
                      (NTH 29 DECODED-STATE)))
      (CONS
       (F-NAND (F-NOR4 (NTH 6 DECODED-STATE)
                       (NTH 7 DECODED-STATE)
                       (NTH 10 DECODED-STATE)
                       (NTH 12 DECODED-STATE))
               (F-NOR4 (NTH 15 DECODED-STATE)
                       (NTH 16 DECODED-STATE)
                       (NTH 22 DECODED-STATE)
                       (NTH 29 DECODED-STATE)))
       (CONS
        (F-OR (NTH 3 DECODED-STATE)
              (NTH 29 DECODED-STATE))
        (CONS
         (F-OR (NTH 16 DECODED-STATE)
               (NTH 28 DECODED-STATE))
         (CONS
          (F-NAND (F-NOR3 (NTH 0 DECODED-STATE)
                          (NTH 8 DECODED-STATE)
                          (NTH 12 DECODED-STATE))
                  (F-NOR (NTH 16 DECODED-STATE)
                         (NTH 29 DECODED-STATE)))
          (CONS
           (F-OR3 (NTH 0 DECODED-STATE)
                  (NTH 24 DECODED-STATE)
                  (NTH 28 DECODED-STATE))
           (CONS
            (F-OR (NTH 24 DECODED-STATE)
                  (NTH 28 DECODED-STATE))
            (CONS
             (F-OR3 (NTH 3 DECODED-STATE)
                    (NTH 11 DECODED-STATE)
                    (NTH 15 DECODED-STATE))
             (CONS
              (F-NAND (F-NAND PRE-DEC-A
                              (NTH 8 DECODED-STATE))
                      (F-NAND PRE-DEC-B
                              (F-OR (NTH 12 DECODED-STATE)
                                    (NTH 16 DECODED-STATE))))
              (CONS
               (F-AND A-IMMEDIATE-P
                      (F-OR (NTH 5 DECODED-STATE)
                            (NTH 13 DECODED-STATE)))
               (CONS
                (F$CARRY-IN-HELP
                 (CONS C
                  (CONS
                   (F-OR4 (NTH 0 DECODED-STATE)
                          (NTH 28 DECODED-STATE)
                          (NTH 29 DECODED-STATE)
                          (NTH 30 DECODED-STATE))
                   (F$SELECT-OP-CODE
                                 (F-NOR4 (NTH 2 DECODED-STATE)
                                         (F-OR (NTH 9 DECODED-STATE)
                                               (NTH 21 DECODED-STATE))
                                         (F-OR3 (NTH 14 DECODED-STATE)
                                                (NTH 17 DECODED-STATE)
                                                (NTH 23 DECODED-STATE))
                                         (F-OR4 (NTH 0 DECODED-STATE)
                                                (NTH 28 DECODED-STATE)
                                                (NTH 29 DECODED-STATE)
                                                (NTH 30 DECODED-STATE)))
                                 (F-NAND (F-NAND (F-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (F-NAND (F-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 OP-CODE))))
                (CONS
                 (F-OR4 (NTH 0 DECODED-STATE)
                        (NTH 28 DECODED-STATE)
                        (NTH 29 DECODED-STATE)
                        (NTH 30 DECODED-STATE))
                 (APPEND
                  (F$ENCODE-32 (NTH 0 DECODED-STATE)
                               (NTH 1 DECODED-STATE)
                               (NTH 2 DECODED-STATE)
                               (NTH 3 DECODED-STATE)
                               (NTH 4 DECODED-STATE)
                               (NTH 5 DECODED-STATE)
                               (NTH 6 DECODED-STATE)
                               (NTH 7 DECODED-STATE)
                               (NTH 8 DECODED-STATE)
                               (NTH 9 DECODED-STATE)
                               (NTH 10 DECODED-STATE)
                               (NTH 11 DECODED-STATE)
                               (NTH 12 DECODED-STATE)
                               (NTH 13 DECODED-STATE)
                               (NTH 14 DECODED-STATE)
                               (NTH 15 DECODED-STATE)
                               (NTH 16 DECODED-STATE)
                               (NTH 17 DECODED-STATE)
                               (NTH 18 DECODED-STATE)
                               (NTH 19 DECODED-STATE)
                               (NTH 20 DECODED-STATE)
                               (NTH 21 DECODED-STATE)
                               (NTH 22 DECODED-STATE)
                               (NTH 23 DECODED-STATE)
                               (NTH 24 DECODED-STATE)
                               (NTH 25 DECODED-STATE)
                               (NTH 26 DECODED-STATE)
                               (NTH 27 DECODED-STATE)
                               (NTH 28 DECODED-STATE)
                               (NTH 29 DECODED-STATE)
                               (NTH 30 DECODED-STATE)
                               (NTH 31 DECODED-STATE))
                  (APPEND
                   (FV-IF (F-NOR (NTH 7 DECODED-STATE)
                                 (NTH 16 DECODED-STATE))
                          (MAKE-LIST 4
                                     (THREEFIX (NTH 28 DECODED-STATE)))
                          SET-FLAGS)
                   (APPEND
                    (FV-IF (F-NAND (F-NOR3 (NTH 5 DECODED-STATE)
                                           (NTH 8 DECODED-STATE)
                                           (NTH 9 DECODED-STATE))
                                   (F-NOR3 (NTH 13 DECODED-STATE)
                                           (NTH 20 DECODED-STATE)
                                           (NTH 21 DECODED-STATE)))
                           RN-A
                           (FV-IF (F-NAND (F-NOR5 (NTH 6 DECODED-STATE)
                                                  (NTH 7 DECODED-STATE)
                                                  (NTH 10 DECODED-STATE)
                                                  (NTH 12 DECODED-STATE)
                                                  (NTH 14 DECODED-STATE))
                                          (F-NOR4 (NTH 16 DECODED-STATE)
                                                  (NTH 17 DECODED-STATE)
                                                  (NTH 22 DECODED-STATE)
                                                  (NTH 23 DECODED-STATE)))
                                  RN-B
                                  (F$V-IF-F-4 (F-OR (NTH 28 DECODED-STATE)
                                                    (NTH 29 DECODED-STATE))
                                              (FV-IF (NTH 30 DECODED-STATE)
                                                     (F$V-INC4$V REGS-ADDRESS)
                                                     PC-REG))))
                    (APPEND
                     (F$SELECT-OP-CODE
                                 (F-NOR4 (NTH 2 DECODED-STATE)
                                         (F-OR (NTH 9 DECODED-STATE)
                                               (NTH 21 DECODED-STATE))
                                         (F-OR3 (NTH 14 DECODED-STATE)
                                                (NTH 17 DECODED-STATE)
                                                (NTH 23 DECODED-STATE))
                                         (F-OR4 (NTH 0 DECODED-STATE)
                                                (NTH 28 DECODED-STATE)
                                                (NTH 29 DECODED-STATE)
                                                (NTH 30 DECODED-STATE)))
                                 (F-NAND (F-NAND (F-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (F-NAND (F-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 OP-CODE)
                     (F$MPG
                      (CONS
                       (F-OR4 (NTH 0 DECODED-STATE)
                              (NTH 28 DECODED-STATE)
                              (NTH 29 DECODED-STATE)
                              (NTH 30 DECODED-STATE))
                       (CONS
                        (F-OR3 (NTH 14 DECODED-STATE)
                               (NTH 17 DECODED-STATE)
                               (NTH 23 DECODED-STATE))
                        (F$SELECT-OP-CODE
                                 (F-NOR4 (NTH 2 DECODED-STATE)
                                         (F-OR (NTH 9 DECODED-STATE)
                                               (NTH 21 DECODED-STATE))
                                         (F-OR3 (NTH 14 DECODED-STATE)
                                                (NTH 17 DECODED-STATE)
                                                (NTH 23 DECODED-STATE))
                                         (F-OR4 (NTH 0 DECODED-STATE)
                                                (NTH 28 DECODED-STATE)
                                                (NTH 29 DECODED-STATE)
                                                (NTH 30 DECODED-STATE)))
                                 (F-NAND (F-NAND (F-OR (NTH 9 DECODED-STATE)
                                                       (NTH 21 DECODED-STATE))
                                                 PRE-DEC-A)
                                         (F-NAND (F-OR3 (NTH 14 DECODED-STATE)
                                                        (NTH 17 DECODED-STATE)
                                                        (NTH 23 DECODED-STATE))
                                                 PRE-DEC-B))
                                 OP-CODE)))))))))))))))))))))))))

(TOGGLE F$CV-OFF F$CV T)

(PROVE-LEMMA MAKE-LIST-CROCK-FOR-F$CV=CV
             (REWRITE)
             (IMPLIES (BOOLP V)
                      (EQUAL (MAKE-LIST 4 V)
                             (IF V (LIST T T T T) (LIST F F F F))))
             ((ENABLE OPEN-MAKE-LIST BOOLP)))

(TOGGLE MAKE-LIST-CROCK-FOR-F$CV=CV-OFF MAKE-LIST-CROCK-FOR-F$CV=CV T)

(PROVE-LEMMA F$CV=CV
             (REWRITE)
             (IMPLIES (AND (BVP DECODED-STATE)
                           (EQUAL (LENGTH DECODED-STATE) 32)
                           (BVP RN-A)
                           (EQUAL (LENGTH RN-A) 4)
                           (BVP RN-B)
                           (EQUAL (LENGTH RN-B) 4)
                           (BVP OP-CODE)
                           (EQUAL (LENGTH OP-CODE) 4)
                           (BVP PC-REG)
                           (EQUAL (LENGTH PC-REG) 4)
                           (BVP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4)
                           (BVP SET-FLAGS)
                           (EQUAL (LENGTH SET-FLAGS) 4)
                           (BOOLP STORE)
                           (BOOLP C)
                           (BOOLP A-IMMEDIATE-P)
                           (BOOLP RW-)
                           (BOOLP DIRECT-A)
                           (BOOLP SIDE-EFFECT-A)
                           (BOOLP SIDE-EFFECT-B)
                           (BOOLP PRE-DEC-A)
                           (BOOLP PRE-DEC-B))
                      (EQUAL (F$CV DECODED-STATE RN-A RN-B OP-CODE PC-REG
                                   REGS-ADDRESS SET-FLAGS STORE C
                                   A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A
                                   SIDE-EFFECT-B PRE-DEC-A PRE-DEC-B)
                             (CV DECODED-STATE RN-A RN-B OP-CODE PC-REG
                                 REGS-ADDRESS SET-FLAGS STORE C
                                 A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A
                                 SIDE-EFFECT-B PRE-DEC-A PRE-DEC-B)))
             ((ENABLE F$CV CV BOOLP-B-GATES IF* MAKE-LIST-CROCK-FOR-F$CV=CV)
              (DISABLE IF*-CONS IF*-C-X-X OPEN-V-THREEFIX)
              (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA BVP-LENGTH-CV
             (REWRITE)
             (AND (IMPLIES (AND (EQUAL (LENGTH SET-FLAGS) 4)
                                (EQUAL (LENGTH RN-A) 4)
                                (EQUAL (LENGTH RN-B) 4)
                                (EQUAL (LENGTH OP-CODE) 4))
                           (EQUAL (LENGTH (CV DECODED-STATE RN-A RN-B OP-CODE
                                              PC-REG REGS-ADDRESS SET-FLAGS
                                              STORE C A-IMMEDIATE-P RW-
                                              DIRECT-A SIDE-EFFECT-A
                                              SIDE-EFFECT-B PRE-DEC-A
                                              PRE-DEC-B))
                                  40))
                  (IMPLIES (AND (BVP DECODED-STATE)
                                (EQUAL (LENGTH DECODED-STATE) 32))
                           (BVP (CV DECODED-STATE RN-A RN-B OP-CODE PC-REG
                                    REGS-ADDRESS SET-FLAGS STORE C
                                    A-IMMEDIATE-P RW- DIRECT-A
                                    SIDE-EFFECT-A SIDE-EFFECT-B PRE-DEC-A
                                    PRE-DEC-B))))
             ((ENABLE CV)))

(PROVE-LEMMA PROPERP-LENGTH-F$CV
             (REWRITE)
             (AND (IMPLIES (AND (EQUAL (LENGTH SET-FLAGS) 4)
                                (EQUAL (LENGTH RN-A) 4)
                                (EQUAL (LENGTH RN-B) 4)
                                (EQUAL (LENGTH OP-CODE) 4))
                           (EQUAL (LENGTH (F$CV DECODED-STATE RN-A RN-B
                                                OP-CODE PC-REG REGS-ADDRESS
                                                SET-FLAGS STORE C
                                                A-IMMEDIATE-P RW- DIRECT-A
                                                SIDE-EFFECT-A SIDE-EFFECT-B
                                                PRE-DEC-A PRE-DEC-B))
                                  40))
                  (IMPLIES (AND (PROPERP DECODED-STATE)
                                (EQUAL (LENGTH DECODED-STATE) 32))
                           (PROPERP (F$CV DECODED-STATE RN-A RN-B OP-CODE
                                          PC-REG REGS-ADDRESS SET-FLAGS
                                          STORE C A-IMMEDIATE-P RW-
                                          DIRECT-A SIDE-EFFECT-A
                                          SIDE-EFFECT-B PRE-DEC-A PRE-DEC-B))))
             ((ENABLE F$CV)
              (DISABLE-THEORY F-GATES)))

(DEFN CV* NIL
 (CONS 'CV
  (CONS
       (APPEND8 (INDICES 'DECODED-STATE 0 32)
                (INDICES 'RN-A 0 4)
                (INDICES 'RN-B 0 4)
                (INDICES 'OP-CODE 0 4)
                (INDICES 'PC-REG 0 4)
                (INDICES 'REGS-ADDRESS 0 4)
                (INDICES 'SET-FLAGS 0 4)
                '(STORE C A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A
                        SIDE-EFFECT-B PRE-DEC-A PRE-DEC-B))
       (CONS (APPEND6 '(NEW-RW- STROBE- HDACK- WE-REGS WE-A-REG WE-B-REG
                                WE-I-REG WE-DATA-OUT WE-ADDR-OUT WE-HOLD-
                                WE-PC-REG DATA-IN-SELECT DEC-ADDR-OUT
                                SELECT-IMMEDIATE ALU-C ALU-ZERO)
                      (INDICES 'STATE 0 5)
                      (INDICES 'WE-FLAGS 0 4)
                      (INDICES 'NEW-REGS-ADDRESS 0 4)
                      (INDICES 'ALU-OP 0 4)
                      (INDICES 'ALU-MPG 0 7))
             (CONS (LIST (LIST 'G-FETCH0
                               '(FETCH0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 0)))
                         (LIST 'G-FETCH1
                               '(FETCH1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 1)))
                         (LIST 'G-FETCH2
                               '(FETCH2)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 2)))
                         (LIST 'G-FETCH3
                               '(FETCH3)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 3)))
                         (LIST 'G-DECODE
                               '(DECODE)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 4)))
                         (LIST 'G-REGA
                               '(REGA)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 5)))
                         (LIST 'G-REGB
                               '(REGB)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 6)))
                         (LIST 'G-UPDATE
                               '(UPDATE)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 7)))
                         (LIST 'G-READA0
                               '(READA0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 8)))
                         (LIST 'G-READA1
                               '(READA1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 9)))
                         (LIST 'G-READA2
                               '(READA2)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 10)))
                         (LIST 'G-READA3
                               '(READA3)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 11)))
                         (LIST 'G-READB0
                               '(READB0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 12)))
                         (LIST 'G-READB1
                               '(READB1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 13)))
                         (LIST 'G-READB2
                               '(READB2)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 14)))
                         (LIST 'G-READB3
                               '(READB3)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 15)))
                         (LIST 'G-WRITE0
                               '(WRITE0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 16)))
                         (LIST 'G-WRITE1
                               '(WRITE1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 17)))
                         (LIST 'G-WRITE2
                               '(WRITE2)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 18)))
                         (LIST 'G-WRITE3
                               '(WRITE3)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 19)))
                         (LIST 'G-SEFA0
                               '(SEFA0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 20)))
                         (LIST 'G-SEFA1
                               '(SEFA1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 21)))
                         (LIST 'G-SEFB0
                               '(SEFB0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 22)))
                         (LIST 'G-SEFB1
                               '(SEFB1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 23)))
                         (LIST 'G-HOLD0
                               '(HOLD0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 24)))
                         (LIST 'G-HOLD1
                               '(HOLD1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 25)))
                         (LIST 'G-V11010
                               '(V11010)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 26)))
                         (LIST 'G-V11011
                               '(V11011)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 27)))
                         (LIST 'G-RESET0
                               '(RESET0)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 28)))
                         (LIST 'G-RESET1
                               '(RESET1)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 29)))
                         (LIST 'G-RESET2
                               '(RESET2)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 30)))
                         (LIST 'G-V11111
                               '(V11111)
                               'ID
                               (LIST (INDEX 'DECODED-STATE 31)))
                         '(G0 (STORE-) B-NOT (STORE))
                         '(G1 (ALU-ZERO)
                              B-OR4
                              (FETCH0 RESET0 RESET1 RESET2))
                         '(G2 (ALU-SWAP)
                              B-OR3
                              (READB2 WRITE1 SEFB1))
                         '(G3 (INCDECA) B-OR (READA1 SEFA1))
                         '(G4 (S4)
                              B-NOR4
                              (FETCH2 INCDECA ALU-SWAP ALU-ZERO))
                         '(G5 (S5) B-NAND (INCDECA PRE-DEC-A))
                         '(G6 (S6) B-NAND (ALU-SWAP PRE-DEC-B))
                         '(G7 (S7) B-NAND (S5 S6))
                         (LIST 'G8
                               (INDICES 'ALU-OP 0 4)
                               'SELECT-OP-CODE
                               (CONS 'S4
                                     (CONS 'S7 (INDICES 'OP-CODE 0 4))))
                         '(G10 (S10) B-NOT (RW-))
                         '(G11 (S11) B-NAND (S10 FETCH0))
                         '(G12 (S12)
                               B-NOR3
                               (WRITE1 WRITE2 WRITE3))
                         '(G13 (NEW-RW-) B-AND (S11 S12))
                         '(G14 (STROBE-)
                               B-NOR8
                               (FETCH2 FETCH3 READA2 READA3 READB2 READB3
                                       WRITE2 WRITE3))
                         '(G15 (HDACK-) B-NOT (HOLD0))
                         '(G17 (S17) B-NAND (STORE UPDATE))
                         '(G18 (S18)
                               B-NAND
                               (SIDE-EFFECT-A READA1))
                         '(G19 (S19)
                               B-NAND3
                               (STORE- SIDE-EFFECT-B READB2))
                         '(G20 (S20)
                               B-NAND
                               (SIDE-EFFECT-B WRITE1))
                         '(G21 (S21)
                               B-NOR5
                               (FETCH2 SEFA1 SEFB1 RESET0 RESET2))
                         '(G22 (WE-REGS)
                               B-NAND5
                               (S17 S18 S19 S20 S21))
                         '(G23 (S23) B-NAND (DIRECT-A READB1))
                         '(G24 (S24)
                               B-NOR6
                               (FETCH0 REGA READA0 READA3 SEFA0 RESET1))
                         '(G25 (WE-A-REG) B-NAND (S23 S24))
                         '(G26 (S26)
                               B-NOR4
                               (REGB UPDATE READA2 READB0))
                         '(G27 (S27)
                               B-NOR4
                               (READB3 WRITE0 SEFB0 RESET1))
                         '(G28 (WE-B-REG) B-NAND (S26 S27))
                         '(G29 (WE-I-REG) B-OR (FETCH3 RESET1))
                         '(G30 (WE-DATA-OUT)
                               B-OR
                               (WRITE0 RESET0))
                         '(G31 (S31)
                               B-NOR3
                               (FETCH0 READA0 READB0))
                         '(G32 (S32) B-NOR (WRITE0 RESET1))
                         '(G33 (WE-ADDR-OUT) B-NAND (S31 S32))
                         '(G34 (WE-HOLD-)
                               B-OR3
                               (FETCH0 HOLD0 RESET0))
                         '(G35 (WE-PC-REG) B-OR (HOLD0 RESET0))
                         '(G36 (DATA-IN-SELECT)
                               B-OR3
                               (FETCH3 READA3 READB3))
                         '(G37 (S37) B-NAND (PRE-DEC-A READA0))
                         '(G38 (S38) B-OR (READB0 WRITE0))
                         '(G39 (S39) B-NAND (PRE-DEC-B S38))
                         '(G40 (DEC-ADDR-OUT) B-NAND (S37 S39))
                         '(G41 (S41) B-OR (REGA READB1))
                         '(G42 (SELECT-IMMEDIATE)
                               B-AND
                               (A-IMMEDIATE-P S41))
                         (LIST 'G43
                               '(ALU-C)
                               'CARRY-IN-HELP
                               (CONS 'C
                                     (CONS 'ALU-ZERO
                                           (INDICES 'ALU-OP 0 4))))
                         (LIST 'G44
                               (INDICES 'STATE 0 5)
                               'ENCODE-32
                               (INDICES 'DECODED-STATE 0 32))
                         (CONS 'G45
                               (CONS (INDICES 'FANOUT-RESET0 0 4)
                                     '(FANOUT-4 (RESET0))))
                         '(G46 (S46) B-NOR (UPDATE WRITE0))
                         (LIST 'G47
                               (INDICES 'WE-FLAGS 0 4)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 4)))
                               (CONS 'S46
                                     (APPEND (INDICES 'FANOUT-RESET0 0 4)
                                             (INDICES 'SET-FLAGS 0 4))))
                         '(G48 (S48)
                               B-NOR3
                               (REGA READA0 READA1))
                         '(G49 (S49)
                               B-NOR3
                               (READB1 SEFA0 SEFA1))
                         '(G50 (SELECT-RN-A) B-NAND (S48 S49))
                         '(G51 (S51)
                               B-NOR5
                               (REGB UPDATE READA2 READB0 READB2))
                         '(G52 (S52)
                               B-NOR4
                               (WRITE0 WRITE1 SEFB0 SEFB1))
                         '(G53 (SELECT-RN-B) B-NAND (S51 S52))
                         '(G54 (SELECT-ALL-F)
                               B-OR
                               (RESET0 RESET1))
                         (LIST 'G55
                               (INDICES 'V-INC-REGS-ADDRESS 0 4)
                               'V-INC4
                               (INDICES 'REGS-ADDRESS 0 4))
                         (LIST 'G56
                               (INDICES 'S56 0 4)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 4)))
                               (CONS 'RESET2
                                     (APPEND (INDICES 'V-INC-REGS-ADDRESS 0 4)
                                             (INDICES 'PC-REG 0 4))))
                         (LIST 'G57
                               (INDICES 'S57 0 4)
                               'V-IF-F-4
                               (CONS 'SELECT-ALL-F
                                     (INDICES 'S56 0 4)))
                         (LIST 'G58
                               (INDICES 'S58 0 4)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 4)))
                               (CONS 'SELECT-RN-B
                                     (APPEND (INDICES 'RN-B 0 4)
                                             (INDICES 'S57 0 4))))
                         (LIST 'G59
                               (INDICES 'NEW-REGS-ADDRESS 0 4)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 4)))
                               (CONS 'SELECT-RN-A
                                     (APPEND (INDICES 'RN-A 0 4)
                                             (INDICES 'S58 0 4))))
                         (LIST 'G60
                               (INDICES 'ALU-MPG 0 7)
                               'MPG
                               (CONS 'ALU-ZERO
                                     (CONS 'ALU-SWAP
                                           (INDICES 'ALU-OP 0 4)))))
                   '(NIL))))))

(DEFN CV&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CV NETLIST)
                  (CV*))
           (ID& (DELETE-MODULE 'CV NETLIST))
           (B-NOT& (DELETE-MODULE 'CV NETLIST))
           (B-OR& (DELETE-MODULE 'CV NETLIST))
           (B-OR3& (DELETE-MODULE 'CV NETLIST))
           (B-OR4& (DELETE-MODULE 'CV NETLIST))
           (B-NAND& (DELETE-MODULE 'CV NETLIST))
           (B-NAND3& (DELETE-MODULE 'CV NETLIST))
           (B-NAND5& (DELETE-MODULE 'CV NETLIST))
           (B-NOR& (DELETE-MODULE 'CV NETLIST))
           (B-NOR3& (DELETE-MODULE 'CV NETLIST))
           (B-NOR4& (DELETE-MODULE 'CV NETLIST))
           (B-NOR5& (DELETE-MODULE 'CV NETLIST))
           (B-NOR6& (DELETE-MODULE 'CV NETLIST))
           (B-NOR8& (DELETE-MODULE 'CV NETLIST))
           (B-AND& (DELETE-MODULE 'CV NETLIST))
           (SELECT-OP-CODE& (DELETE-MODULE 'CV NETLIST))
           (TV-IF& (DELETE-MODULE 'CV NETLIST)
                   (MAKE-TREE 4))
           (CARRY-IN-HELP& (DELETE-MODULE 'CV NETLIST))
           (ENCODE-32& (DELETE-MODULE 'CV NETLIST))
           (FANOUT-4& (DELETE-MODULE 'CV NETLIST))
           (V-INC4& (DELETE-MODULE 'CV NETLIST))
           (V-IF-F-4& (DELETE-MODULE 'CV NETLIST))
           (MPG& (DELETE-MODULE 'CV NETLIST))))

(TOGGLE CV&-OFF CV& T)

(DEFN CV$NETLIST NIL
      (CONS (CV*)
            (UNION (UNION (UNION (UNION (UNION (ID$NETLIST) (B-NOT$NETLIST))
                                        (UNION (B-OR$NETLIST)
                                               (UNION (B-OR3$NETLIST)
                                                      (B-OR4$NETLIST))))
                                 (UNION (UNION (B-NAND$NETLIST)
                                               (B-NAND3$NETLIST))
                                        (UNION (B-NOR$NETLIST)
                                               (B-NOR3$NETLIST))))
                          (UNION (UNION (UNION (B-NOR4$NETLIST)
                                               (B-NOR5$NETLIST))
                                        (UNION (B-NOR6$NETLIST)
                                               (B-NOR8$NETLIST)))
                                 (UNION (UNION (B-AND$NETLIST)
                                               (SELECT-OP-CODE$NETLIST))
                                        (UNION (TV-IF$NETLIST (MAKE-TREE 4))
                                               (CARRY-IN-HELP$NETLIST)))))
                   (UNION (UNION (UNION (ENCODE-32$NETLIST)
                                        (FANOUT-4$NETLIST))
                                 (UNION (V-INC4$NETLIST)
                                        (V-IF-F-4$NETLIST)))
                          (UNION (MPG$NETLIST)
                                 (B-NAND5$NETLIST))))))

(PROVE-LEMMA CHECK-CV$NETLIST NIL
             (CV& (CV$NETLIST)))

(PROVE-LEMMA CV$VALUE
 (REWRITE)
 (IMPLIES
  (AND (CV& NETLIST)
       (PROPERP DECODED-STATE)
       (EQUAL (LENGTH DECODED-STATE) 32)
       (PROPERP RN-A)
       (EQUAL (LENGTH RN-A) 4)
       (PROPERP RN-B)
       (EQUAL (LENGTH RN-B) 4)
       (PROPERP OP-CODE)
       (EQUAL (LENGTH OP-CODE) 4)
       (PROPERP PC-REG)
       (EQUAL (LENGTH PC-REG) 4)
       (PROPERP REGS-ADDRESS)
       (EQUAL (LENGTH REGS-ADDRESS) 4)
       (PROPERP SET-FLAGS)
       (EQUAL (LENGTH SET-FLAGS) 4))
  (EQUAL
   (DUAL-EVAL 0 'CV
    (APPEND DECODED-STATE
        (APPEND RN-A
                (APPEND RN-B
                        (APPEND OP-CODE
                                (APPEND PC-REG
                                        (APPEND REGS-ADDRESS
                                                (APPEND SET-FLAGS
                                                        (LIST STORE C
                                                              A-IMMEDIATE-P
                                                              RW-
                                                              DIRECT-A
                                                              SIDE-EFFECT-A
                                                              SIDE-EFFECT-B
                                                              PRE-DEC-A
                                                              PRE-DEC-B))))))))
    STATE NETLIST)
   (F$CV DECODED-STATE RN-A RN-B OP-CODE PC-REG REGS-ADDRESS SET-FLAGS STORE
         C A-IMMEDIATE-P RW- DIRECT-A SIDE-EFFECT-A SIDE-EFFECT-B PRE-DEC-A
         PRE-DEC-B)))
 ((ENABLE F$CV CV& ID$VALUE B-NOT$VALUE B-OR$VALUE B-OR3$VALUE B-OR4$VALUE
          B-NAND$VALUE B-NAND5$VALUE B-NAND3$VALUE B-NOR$VALUE B-NOR3$VALUE
          B-NOR4$VALUE B-NOR5$VALUE B-NOR6$VALUE B-NOR8$VALUE B-AND$VALUE
          SELECT-OP-CODE$VALUE TV-IF$VALUE CARRY-IN-HELP$VALUE
          ENCODE-32$VALUE-ON-A-VECTOR FANOUT-4$VALUE V-INC4$VALUE
          V-IF-F-4$VALUE MPG$VALUE)
  (DISABLE F-GATES=B-GATES OPEN-INDICES *1*INDICES INDICES MPG *1*MPG
           ENCODE-32 *1*ENCODE-32 TREE-NUMBER *1*TREE-NUMBER MAKE-TREE
           *1*MAKE-TREE)
  (DISABLE-THEORY F-GATES)))

(TOGGLE CV$VALUE-OFF CV$VALUE T)

(DEFN NEXT-CNTL-STATE
      (RESET- DTACK- HOLD- RW- STATE I-REG FLAGS PC-REG REGS-ADDRESS)
      (CV (NEXT-STATE (DECODE-5 (V-IF RESET- STATE (V_V11111)))
                      (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                      (SET-SOME-FLAGS (SET-FLAGS I-REG))
                      (UNARY-OP-CODE-P (OP-CODE I-REG))
                      (OR* (A-IMMEDIATE-P I-REG)
                           (REG-DIRECT-P (MODE-A I-REG)))
                      (REG-DIRECT-P (MODE-B I-REG))
                      (AND* (NOT* (A-IMMEDIATE-P I-REG))
                            (OR* (PRE-DEC-P (MODE-A I-REG))
                                 (POST-INC-P (MODE-A I-REG))))
                      (OR* (PRE-DEC-P (MODE-B I-REG))
                           (POST-INC-P (MODE-B I-REG)))
                      (EQUAL REGS-ADDRESS (LIST T T T T))
                      DTACK- HOLD-)
          (RN-A I-REG)
          (RN-B I-REG)
          (OP-CODE I-REG)
          PC-REG REGS-ADDRESS
          (SET-FLAGS I-REG)
          (STORE-RESULTP (STORE-CC I-REG) FLAGS)
          (C-FLAG FLAGS)
          (A-IMMEDIATE-P I-REG)
          RW-
          (OR* (A-IMMEDIATE-P I-REG)
               (REG-DIRECT-P (MODE-A I-REG)))
          (AND* (NOT* (A-IMMEDIATE-P I-REG))
                (OR* (PRE-DEC-P (MODE-A I-REG))
                     (POST-INC-P (MODE-A I-REG))))
          (OR* (PRE-DEC-P (MODE-B I-REG))
               (POST-INC-P (MODE-B I-REG)))
          (PRE-DEC-P (MODE-A I-REG))
          (PRE-DEC-P (MODE-B I-REG))))

(TOGGLE NEXT-CNTL-STATE-OFF NEXT-CNTL-STATE T)

(PROVE-LEMMA BVP-LENGTH-NEXT-CNTL-STATE
             (REWRITE)
             (AND (EQUAL (LENGTH (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                                  STATE I-REG FLAGS PC-REG
                                                  REGS-ADDRESS))
                         40)
                  (BVP (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW- STATE I-REG
                                        FLAGS PC-REG REGS-ADDRESS)))
             ((ENABLE NEXT-CNTL-STATE)))

(DEFN F$NEXT-CNTL-STATE
      (RESET- DTACK- HOLD- RW- STATE I-REG FLAGS PC-REG REGS-ADDRESS)
      (F$CV (F$NEXT-STATE (F$DECODE-5 (FV-OR (MAKE-LIST 5 (F-NOT RESET-))
                                             STATE))
                          (CADR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
                          (CADDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
                          (CADDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
                          (CADDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
                          (CADDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
                          (CADDDDDDDDDDR (F$CONTROL-LET I-REG FLAGS
                                                        REGS-ADDRESS))
                          (CADDDDDDDDDDDR (F$CONTROL-LET I-REG FLAGS
                                                         REGS-ADDRESS))
                          (CADDDDDDDDDR (F$CONTROL-LET I-REG FLAGS
                                                       REGS-ADDRESS))
                          DTACK- HOLD-)
            (RN-A I-REG)
            (RN-B I-REG)
            (OP-CODE I-REG)
            PC-REG REGS-ADDRESS
            (SET-FLAGS I-REG)
            (CADR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CADDDDDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CAR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            RW-
            (CADDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CADDDDDDDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CADDDDDDDDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CADDDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))
            (CADDDDDDDR (F$CONTROL-LET I-REG FLAGS REGS-ADDRESS))))

(TOGGLE F$NEXT-CNTL-STATE-OFF F$NEXT-CNTL-STATE T)

(PROVE-LEMMA PROPERP-LENGTH-F$NEXT-CNTL-STATE
             (REWRITE)
             (AND (EQUAL (LENGTH (F$NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                                    STATE I-REG FLAGS PC-REG
                                                    REGS-ADDRESS))
                         40)
                  (PROPERP (F$NEXT-CNTL-STATE RESET- DTACK- HOLD- RW- STATE
                                              I-REG FLAGS PC-REG
                                              REGS-ADDRESS)))
             ((ENABLE F$NEXT-CNTL-STATE)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA V-OR-CROCK-FOR-F$NEXT-CNTL-STATE
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH STATE) 5)
                           (BVP STATE))
                      (AND (EQUAL (V-OR (LIST F F F F F) STATE)
                                  STATE)
                           (EQUAL (V-OR (LIST T T T T T) STATE)
                                  (LIST T T T T T))))
             ((ENABLE V-OR EQUAL-LENGTH-ADD1)))

(TOGGLE V-OR-CROCK-FOR-F$NEXT-CNTL-STATE-OFF V-OR-CROCK-FOR-F$NEXT-CNTL-STATE T)

(PROVE-LEMMA F$NEXT-CNTL-STATE=NEXT-CNTL-STATE
             (REWRITE)
             (IMPLIES (AND (BOOLP RESET-)
                           (BOOLP DTACK-)
                           (BOOLP HOLD-)
                           (BOOLP RW-)
                           (BVP STATE)
                           (EQUAL (LENGTH STATE) 5)
                           (BVP I-REG)
                           (EQUAL (LENGTH I-REG) 32)
                           (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4)
                           (BVP PC-REG)
                           (EQUAL (LENGTH PC-REG) 4)
                           (BVP REGS-ADDRESS)
                           (EQUAL (LENGTH REGS-ADDRESS) 4))
                      (EQUAL (F$NEXT-CNTL-STATE RESET- DTACK- HOLD- RW- STATE
                                                I-REG FLAGS PC-REG
                                                REGS-ADDRESS)
                             (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW- STATE
                                              I-REG FLAGS PC-REG
                                              REGS-ADDRESS)))
             ((ENABLE F$NEXT-CNTL-STATE NEXT-CNTL-STATE BOOLP-B-GATES
                      FV-IF-REWRITE V_V11111 V-OR-CROCK-FOR-F$NEXT-CNTL-STATE)
              (DISABLE NEXT-STATE)
              (ENABLE-THEORY IR-FIELDS-THEORY)
              (DISABLE-THEORY F-GATES)))

(DEFN NEXT-CNTL-STATE* NIL
 (CONS 'NEXT-CNTL-STATE
  (CONS (APPEND6 '(RESET- DTACK- HOLD- RW-)
                 (INDICES 'STATE 0 5)
                 (INDICES 'I-REG 0 32)
                 (INDICES 'FLAGS 0 4)
                 (INDICES 'PC-REG 0 4)
                 (INDICES 'REGS-ADDRESS 0 4))
        (CONS (INDICES 'NEXT-CNTL-STATE 0 40)
              (CONS (LIST (LIST 'CONTROL-SIGNALS
                                '(A-IMMEDIATE-P STORE SET-SOME-FLAGS DIRECT-A
                                                DIRECT-B UNARY PRE-DEC-A
                                                PRE-DEC-B C ALL-T-REGS-ADDRESS
                                                SIDE-EFFECT-A SIDE-EFFECT-B)
                                'CONTROL-LET
                                (APPEND (INDICES 'I-REG 0 32)
                                        (APPEND (INDICES 'FLAGS 0 4)
                                                (INDICES 'REGS-ADDRESS 0 4))))
                          '(NOT-RESET (RESET) B-NOT (RESET-))
                          (CONS 'RESET5X
                                (CONS (INDICES 'RESET5X 0 5)
                                      '(FANOUT-5 (RESET))))
                          (LIST 'XSTATE
                                (INDICES 'XSTATE 0 5)
                                (INDEX 'V-OR 5)
                                (APPEND (INDICES 'RESET5X 0 5)
                                        (INDICES 'STATE 0 5)))
                          (LIST 'DSTATE
                                (INDICES 'DECODED-STATE 0 32)
                                'DECODE-5
                                (INDICES 'XSTATE 0 5))
                          (LIST 'NXSTATE
                                (INDICES 'NEXT-STATE 0 32)
                                'NEXT-STATE
                                (APPEND (INDICES 'DECODED-STATE 0 32)
                                        '(STORE SET-SOME-FLAGS UNARY
                                                DIRECT-A DIRECT-B
                                                SIDE-EFFECT-A SIDE-EFFECT-B
                                                ALL-T-REGS-ADDRESS DTACK-
                                                HOLD-)))
                          (LIST 'CVECTOR
                                (INDICES 'NEXT-CNTL-STATE 0 40)
                                'CV
                                (APPEND8 (INDICES 'NEXT-STATE 0 32)
                                         (RN-A (INDICES 'I-REG 0 32))
                                         (RN-B (INDICES 'I-REG 0 32))
                                         (OP-CODE (INDICES 'I-REG 0 32))
                                         (INDICES 'PC-REG 0 4)
                                         (INDICES 'REGS-ADDRESS 0 4)
                                         (SET-FLAGS (INDICES 'I-REG 0 32))
                                         '(STORE C A-IMMEDIATE-P RW-
                                                 DIRECT-A SIDE-EFFECT-A
                                                 SIDE-EFFECT-B PRE-DEC-A
                                                 PRE-DEC-B))))
                    '(NIL))))))

(DEFN NEXT-CNTL-STATE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'NEXT-CNTL-STATE
                                 NETLIST)
                  (NEXT-CNTL-STATE*))
           (CONTROL-LET& (DELETE-MODULE 'NEXT-CNTL-STATE
                                        NETLIST))
           (B-NOT& (DELETE-MODULE 'NEXT-CNTL-STATE
                                  NETLIST))
           (FANOUT-5& (DELETE-MODULE 'NEXT-CNTL-STATE
                                     NETLIST))
           (V-OR& (DELETE-MODULE 'NEXT-CNTL-STATE
                                 NETLIST)
                  5)
           (DECODE-5& (DELETE-MODULE 'NEXT-CNTL-STATE
                                     NETLIST))
           (NEXT-STATE& (DELETE-MODULE 'NEXT-CNTL-STATE
                                       NETLIST))
           (CV& (DELETE-MODULE 'NEXT-CNTL-STATE
                               NETLIST))))

(TOGGLE NEXT-CNTL-STATE&-OFF NEXT-CNTL-STATE& T)

(DEFN NEXT-CNTL-STATE$NETLIST NIL
      (CONS (NEXT-CNTL-STATE*)
            (UNION (UNION (UNION (UNION (CONTROL-LET$NETLIST)
                                        (B-NOT$NETLIST))
                                 (UNION (FANOUT-5$NETLIST)
                                        (V-OR$NETLIST 5)))
                          (UNION (DECODE-5$NETLIST)
                                 (NEXT-STATE$NETLIST)))
                   (CV$NETLIST))))

(PROVE-LEMMA CHECK-NEXT-CNTL-STATE$NETLIST NIL
             (NEXT-CNTL-STATE& (NEXT-CNTL-STATE$NETLIST)))

(PROVE-LEMMA NEXT-CNTL-STATE$VALUE
 (REWRITE)
 (IMPLIES
  (AND (NEXT-CNTL-STATE& NETLIST)
       (PROPERP STATE)
       (EQUAL (LENGTH STATE) 5)
       (PROPERP I-REG)
       (EQUAL (LENGTH I-REG) 32)
       (PROPERP FLAGS)
       (EQUAL (LENGTH FLAGS) 4)
       (PROPERP PC-REG)
       (EQUAL (LENGTH PC-REG) 4)
       (PROPERP REGS-ADDRESS)
       (EQUAL (LENGTH REGS-ADDRESS) 4))
  (EQUAL
   (DUAL-EVAL 0 'NEXT-CNTL-STATE
    (CONS RESET-
     (CONS DTACK-
        (CONS HOLD-
              (CONS RW-
                    (APPEND STATE
                            (APPEND I-REG
                                    (APPEND FLAGS
                                            (APPEND PC-REG REGS-ADDRESS))))))))
    DUAL-EVAL-STATE NETLIST)
   (F$NEXT-CNTL-STATE RESET- DTACK- HOLD- RW- STATE I-REG FLAGS PC-REG
                      REGS-ADDRESS)))
 ((ENABLE NEXT-CNTL-STATE& F$NEXT-CNTL-STATE CONTROL-LET$VALUE B-NOT$VALUE
          FANOUT-5$VALUE V-OR$VALUE DECODE-5$VALUE NEXT-STATE$VALUE CV$VALUE
          C-FLAG V_V11111)
  (ENABLE-THEORY IR-FIELDS-THEORY)
  (DISABLE INDICES *1*INDICES OPEN-INDICES DECODE-5 *1*DECODE-5 CV *1*CV
           F$NEXT-STATE *1*F$NEXT-STATE)))

(TOGGLE NEXT-CNTL-STATE$VALUE-OFF NEXT-CNTL-STATE$VALUE T)

(PROVE-LEMMA NEXT-CNTL-STATE$FETCH0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_FETCH0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_FETCH1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$FETCH1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_FETCH1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* HOLD-
                                  (CV_FETCH2 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                  (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$FETCH2
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_FETCH2)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$FETCH3
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_FETCH3)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* DTACK-
                                  (CV_FETCH3 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                  (CV_DECODE RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$DECODE
         (REWRITE)
         (IMPLIES (AND (EQUAL RESET- T)
                       (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                  (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                          (V_DECODE)
                                          I-REG FLAGS PC-REG REGS-ADDRESS)
                         (IF* (OR* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                   (SET-SOME-FLAGS (SET-FLAGS I-REG)))
                              (IF* (OR* (A-IMMEDIATE-P I-REG)
                                        (REG-DIRECT-P (MODE-A I-REG)))
                                   (IF* (OR* (REG-DIRECT-P (MODE-B I-REG))
                                             (UNARY-OP-CODE-P (OP-CODE I-REG)))
                                        (CV_REGA RW- REGS-ADDRESS I-REG FLAGS
                                                 PC-REG)
                                        (CV_READB0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))
                                   (CV_READA0 RW- REGS-ADDRESS I-REG FLAGS
                                              PC-REG))
                              (IF* (AND* (NOT* (A-IMMEDIATE-P I-REG))
                                         (OR* (PRE-DEC-P (MODE-A I-REG))
                                              (POST-INC-P (MODE-A I-REG))))
                                   (CV_SEFA0 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                   (IF* (OR* (PRE-DEC-P (MODE-B I-REG))
                                             (POST-INC-P (MODE-B I-REG)))
                                        (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                                  PC-REG)
                                        (CV_FETCH0 RW- REGS-ADDRESS I-REG
                                                   FLAGS PC-REG))))))
         ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
          (ENABLE CV NEXT-CNTL-STATE IF*)
          (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$REGA
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_REGA)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* (REG-DIRECT-P (MODE-B I-REG))
                                  (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
                                       (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS
                                                  PC-REG)
                                       (CV_REGB RW- REGS-ADDRESS I-REG FLAGS
                                                PC-REG))
                                  (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                       (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                                  PC-REG)
                                       (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG)))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$REGB
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_REGB)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$UPDATE
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_UPDATE)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* (AND* (OR* (PRE-DEC-P (MODE-B I-REG))
                                             (POST-INC-P (MODE-B I-REG)))
                                        (UNARY-OP-CODE-P (OP-CODE I-REG)))
                                  (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG)
                                  (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READA0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READA0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READA1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READA1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READA1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READA2 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READA2
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READA2)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READA3
     (REWRITE)
     (IMPLIES (AND (EQUAL RESET- T)
                   (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
              (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                      (V_READA3)
                                      I-REG FLAGS PC-REG REGS-ADDRESS)
                     (IF* DTACK-
                          (CV_READA3 RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                          (IF* (REG-DIRECT-P (MODE-B I-REG))
                               (CV_UPDATE RW- REGS-ADDRESS I-REG FLAGS PC-REG)
                               (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
                                    (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                         (CV_WRITE0 RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG)
                                         (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                    FLAGS PC-REG))
                                    (CV_READB0 RW- REGS-ADDRESS I-REG
                                               FLAGS PC-REG))))))
     ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
      (ENABLE CV NEXT-CNTL-STATE IF*)
      (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READB0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READB0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READB1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READB1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READB1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READB2 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READB2
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READB2)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$READB3
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_READB3)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* DTACK-
                                  (CV_READB3 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                  (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                       (CV_WRITE0 RW- REGS-ADDRESS I-REG FLAGS
                                                  PC-REG)
                                       (CV_UPDATE RW- REGS-ADDRESS I-REG
                                                  FLAGS PC-REG)))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$WRITE0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_WRITE0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_WRITE1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$WRITE1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_WRITE1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_WRITE2 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$WRITE2
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_WRITE2)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$WRITE3
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_WRITE3)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* DTACK-
                                  (CV_WRITE3 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                  (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$SEFA0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_SEFA0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_SEFA1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$SEFA1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_SEFA1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* (OR* (PRE-DEC-P (MODE-B I-REG))
                                       (POST-INC-P (MODE-B I-REG)))
                                  (CV_SEFB0 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG)
                                  (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$SEFB0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_SEFB0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_SEFB1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$SEFB1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_SEFB1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$HOLD0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_HOLD0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* HOLD-
                                  (CV_HOLD1 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG)
                                  (CV_HOLD0 RW- REGS-ADDRESS I-REG FLAGS
                                            PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$HOLD1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_HOLD1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$V11010
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_V11010)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_RESET0 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$V11011
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_V11011)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_RESET0 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$RESET0
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_RESET0)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_RESET1 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$RESET1
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_RESET1)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_RESET2 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$RESET2
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_RESET2)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (IF* (EQUAL REGS-ADDRESS (LIST T T T T))
                                  (CV_FETCH0 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG)
                                  (CV_RESET2 RW- REGS-ADDRESS I-REG FLAGS
                                             PC-REG))))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(PROVE-LEMMA NEXT-CNTL-STATE$V11111
             (REWRITE)
             (IMPLIES (AND (EQUAL RESET- T)
                           (CV-HYPS RW- REGS-ADDRESS I-REG FLAGS PC-REG))
                      (EQUAL (NEXT-CNTL-STATE RESET- DTACK- HOLD- RW-
                                              (V_V11111)
                                              I-REG FLAGS PC-REG REGS-ADDRESS)
                             (CV_RESET0 RW- REGS-ADDRESS I-REG FLAGS PC-REG)))
             ((ENABLE-THEORY VECTOR-STATE-THEORY CV-THEORY IR-FIELDS-THEORY)
              (ENABLE CV NEXT-CNTL-STATE IF*)
              (DISABLE *1*CARRY-IN-HELP *1*MPG)))

(DEFN READ-REGS
      (ADDRESS REGS)
      (IF (AND (CADR REGS)
               (V-IFF ADDRESS (CADDDR REGS)))
          (CADDR REGS)
          (READ-MEM ADDRESS (CAR REGS))))

(TOGGLE READ-REGS-OFF READ-REGS T)

(DEFN WRITE-REGS
      (WE ADDRESS REGS DATA)
      (LIST (IF (CADR REGS)
                (WRITE-MEM (CADDDR REGS)
                           (CAR REGS)
                           (CADDR REGS))
                (CAR REGS))
            WE
            (IF WE DATA (CADDR REGS))
            (IF WE ADDRESS (CADDDR REGS))))

(TOGGLE WRITE-REGS-OFF WRITE-REGS T)

(PROVE-LEMMA WRITE-REGS-F-WRITE-REGS-F
             (REWRITE)
             (EQUAL (WRITE-REGS F ADDR1
                                (WRITE-REGS F ADDR2 REGS DATA2)
                                DATA1)
                    (WRITE-REGS F ADDR1 REGS DATA1))
             ((ENABLE WRITE-REGS)))

(PROVE-LEMMA WRITE-REGS-F-BV-CROCK
             (REWRITE)
             (EQUAL (WRITE-REGS F ADDR REGS (BV X))
                    (WRITE-REGS F 0 REGS 0))
             ((ENABLE WRITE-REGS)))

(PROVE-LEMMA PROPERP-LENGTH-WRITE-REGS
             (REWRITE)
             (AND (PROPERP (WRITE-REGS WE ADDRESS REGS DATA))
                  (EQUAL (LENGTH (WRITE-REGS WE ADDRESS REGS DATA))
                         4))
             ((ENABLE WRITE-REGS)))

(PROVE-LEMMA WRITE-REGS-IF
             (REWRITE)
             (EQUAL (WRITE-REGS (IF C A B)
                                ADDRESS REGS DATA)
                    (IF C
                        (WRITE-REGS A ADDRESS REGS DATA)
                        (WRITE-REGS B ADDRESS REGS DATA))))

(PROVE-LEMMA WRITE-REGS-OK
             (REWRITE)
             (AND (EQUAL (MEMORY-OKP N M
                                     (CAR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (IF (CADR REGS)
                             (MEMORY-OKP N M
                                         (WRITE-MEM (CADDDR REGS)
                                                    (CAR REGS)
                                                    (CADDR REGS)))
                             (MEMORY-OKP N M (CAR REGS))))
                  (EQUAL (BOOLP (CADR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (BOOLP WE))
                  (EQUAL (BVP (CADDR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (IF WE (BVP DATA) (BVP (CADDR REGS))))
                  (EQUAL (LENGTH (CADDR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (IF WE
                             (LENGTH DATA)
                             (LENGTH (CADDR REGS))))
                  (EQUAL (BVP (CADDDR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (IF WE
                             (BVP ADDRESS)
                             (BVP (CADDDR REGS))))
                  (EQUAL (LENGTH (CADDDR (WRITE-REGS WE ADDRESS REGS DATA)))
                         (IF WE
                             (LENGTH ADDRESS)
                             (LENGTH (CADDDR REGS)))))
             ((ENABLE WRITE-REGS)))

(PROVE-LEMMA READ-REGS-WRITE-REGS-F
             (REWRITE)
             (IMPLIES (AND (ALL-RAMP-MEM (LENGTH ADDR)
                                         (CAR REGS))
                           (EQUAL (LENGTH ADDR)
                                  (LENGTH (CADDDR REGS)))
                           (BVP ADDR))
                      (EQUAL (READ-REGS ADDR
                                        (WRITE-REGS F ADDRESS REGS VALUE))
                             (READ-REGS ADDR REGS)))
             ((ENABLE READ-REGS WRITE-REGS)
              (USE (READ-MEM-WRITE-MEM (V-ADDR1 ADDR)
                                       (V-ADDR2 (CADDDR REGS))
                                       (VALUE (CADDR REGS))
                                       (MEM (CAR REGS))))))

(PROVE-LEMMA ALL-RAMP-MEM-AFTER-WRITE-REGS
             (REWRITE)
             (IMPLIES (AND (ALL-RAMP-MEM N (CAR REGS))
                           (EQUAL (LENGTH (CADDDR REGS)) N))
                      (ALL-RAMP-MEM N
                                    (CAR (WRITE-REGS WE ADDRESS REGS DATA))))
             ((ENABLE WRITE-REGS)))

(PROVE-LEMMA READ-REGS=READ-MEM
             (REWRITE)
             (IMPLIES (NOT (CADR REGS))
                      (EQUAL (READ-REGS V-ADDR REGS)
                             (READ-MEM V-ADDR (CAR REGS))))
             ((ENABLE READ-REGS)))

(PROVE-LEMMA READ-REGS=READ-MEM-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (ALL-RAMP-MEM (LENGTH V-ADDR1)
                                         (CAR REGS))
                           (EQUAL (LENGTH V-ADDR1)
                                  (LENGTH (CADDDR REGS)))
                           (CADR REGS))
                      (EQUAL (READ-REGS V-ADDR1 REGS)
                             (READ-MEM V-ADDR1
                                       (WRITE-MEM (CADDDR REGS)
                                                  (CAR REGS)
                                                  (CADDR REGS)))))
             ((USE (READ-MEM-WRITE-MEM (MEM (CAR REGS))
                                       (V-ADDR2 (CADDDR REGS))
                                       (VALUE (CADDR REGS))))
              (ENABLE READ-REGS)))

(PROVE-LEMMA BVP-LENGTH-READ-REGS-32
             (REWRITE)
             (IMPLIES (AND (MEMORY-OKP (LENGTH V-ADDR)
                                       32
                                       (CAR REGS))
                           (BVP (CADDR REGS))
                           (EQUAL (LENGTH (CADDR REGS)) 32))
                      (AND (BVP (READ-REGS V-ADDR REGS))
                           (EQUAL (LENGTH (READ-REGS V-ADDR REGS))
                                  32)))
             ((ENABLE READ-REGS)))

(DEFN REGFILE* NIL
 (CONS 'REGFILE
  (CONS
   (CONS 'CLK
         (CONS 'TE
               (CONS 'TI
                     (CONS 'WE
                           (CONS 'DISABLE-REGFILE-
                                 (CONS 'TEST-REGFILE-
                                       (APPEND (INDICES 'ADDRESS 0 4)
                                               (INDICES 'DATA 0 32))))))))
   (CONS
       (CONS 'TO (INDICES 'OUT 0 32))
       (CONS (LIST '(WE-LATCH (WE-DP-RAM WE-DP-RAM-)
                              FD1S
                              (WE CLK TI TE))
                   (LIST 'ADDRESS-LATCH
                         (INDICES 'ADDRESS-DP-RAM 0 4)
                         (INDEX 'WE-REG 4)
                         (CONS 'CLK
                               (CONS 'WE
                                     (CONS 'TE
                                           (CONS 'WE-DP-RAM
                                                 (INDICES 'ADDRESS 0 4))))))
                   (LIST 'DATA-LATCH
                         (INDICES 'DATA-DP-RAM 0 32)
                         (INDEX 'WE-REG 32)
                         (CONS 'CLK
                               (CONS 'WE
                                     (CONS 'TE
                                           (CONS (INDEX 'ADDRESS-DP-RAM 3)
                                                 (INDICES 'DATA 0 32))))))
                   '(REG-EN-CIRCUIT (WE-)
                                    RAM-ENABLE-CIRCUIT
                                    (CLK TEST-REGFILE- DISABLE-REGFILE-
                                         WE-DP-RAM))
                   (LIST 'RAM
                         (INDICES 'RAMOUT 0 32)
                         'DP-RAM-16X32
                         (APPEND (INDICES 'ADDRESS 0 4)
                                 (APPEND (INDICES 'ADDRESS-DP-RAM 0 4)
                                         (CONS 'WE-
                                               (INDICES 'DATA-DP-RAM 0 32)))))
                   (LIST 'COMPARE
                         '(READ-EQUAL-WRITE)
                         (INDEX 'V-EQUAL 4)
                         (APPEND (INDICES 'ADDRESS 0 4)
                                 (INDICES 'ADDRESS-DP-RAM 0 4)))
                   '(MUX-CONTROL (S)
                                 B-AND3
                                 (WE-DP-RAM READ-EQUAL-WRITE TEST-REGFILE-))
                   (LIST 'MUX
                         (INDICES 'OUT 0 32)
                         (INDEX 'TV-IF
                                (TREE-NUMBER (MAKE-TREE 32)))
                         (CONS 'S
                               (APPEND (INDICES 'DATA-DP-RAM 0 32)
                                       (INDICES 'RAMOUT 0 32))))
                   (LIST 'SCANOUT
                         '(TO)
                         'ID
                         (LIST (INDEX 'DATA-DP-RAM 31))))
             '((RAM WE-LATCH DATA-LATCH ADDRESS-LATCH)))))))

(PROVE-LEMMA REGFILE*$DESTRUCTURE
 (REWRITE)
 (AND
  (EQUAL (CAR (REGFILE*)) 'REGFILE)
  (EQUAL
      (CADR (REGFILE*))
      (CONS 'CLK
            (CONS 'TE
                  (CONS 'TI
                        (CONS 'WE
                              (CONS 'DISABLE-REGFILE-
                                    (CONS 'TEST-REGFILE-
                                          (APPEND (INDICES 'ADDRESS 0 4)
                                                  (INDICES 'DATA 0 32)))))))))
  (EQUAL (CADDR (REGFILE*))
         (CONS 'TO (INDICES 'OUT 0 32)))
  (EQUAL (CADDDR (REGFILE*))
         (LIST '(WE-LATCH (WE-DP-RAM WE-DP-RAM-)
                          FD1S
                          (WE CLK TI TE))
               (LIST 'ADDRESS-LATCH
                     (INDICES 'ADDRESS-DP-RAM 0 4)
                     (INDEX 'WE-REG 4)
                     (CONS 'CLK
                           (CONS 'WE
                                 (CONS 'TE
                                       (CONS 'WE-DP-RAM
                                             (INDICES 'ADDRESS 0 4))))))
               (LIST 'DATA-LATCH
                     (INDICES 'DATA-DP-RAM 0 32)
                     (INDEX 'WE-REG 32)
                     (CONS 'CLK
                           (CONS 'WE
                                 (CONS 'TE
                                       (CONS (INDEX 'ADDRESS-DP-RAM 3)
                                             (INDICES 'DATA 0 32))))))
               '(REG-EN-CIRCUIT (WE-)
                                RAM-ENABLE-CIRCUIT
                                (CLK TEST-REGFILE- DISABLE-REGFILE- WE-DP-RAM))
               (LIST 'RAM
                     (INDICES 'RAMOUT 0 32)
                     'DP-RAM-16X32
                     (APPEND (INDICES 'ADDRESS 0 4)
                             (APPEND (INDICES 'ADDRESS-DP-RAM 0 4)
                                     (CONS 'WE-
                                           (INDICES 'DATA-DP-RAM 0 32)))))
               (LIST 'COMPARE
                     '(READ-EQUAL-WRITE)
                     (INDEX 'V-EQUAL 4)
                     (APPEND (INDICES 'ADDRESS 0 4)
                             (INDICES 'ADDRESS-DP-RAM 0 4)))
               '(MUX-CONTROL (S)
                             B-AND3
                             (WE-DP-RAM READ-EQUAL-WRITE TEST-REGFILE-))
               (LIST 'MUX
                     (INDICES 'OUT 0 32)
                     (INDEX 'TV-IF
                            (TREE-NUMBER (MAKE-TREE 32)))
                     (CONS 'S
                           (APPEND (INDICES 'DATA-DP-RAM 0 32)
                                   (INDICES 'RAMOUT 0 32))))
               (LIST 'SCANOUT
                     '(TO)
                     'ID
                     (LIST (INDEX 'DATA-DP-RAM 31)))))
  (EQUAL (CADDDDR (REGFILE*))
         '(RAM WE-LATCH DATA-LATCH ADDRESS-LATCH))))

(TOGGLE REGFILE*-OFF REGFILE* T)

(TOGGLE REGFILE*$DESTRUCTURE-OFF REGFILE*$DESTRUCTURE T)

(TOGGLE G*1*REGFILE*-OFF *1*REGFILE* T)

(DEFN REGFILE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'REGFILE NETLIST)
                  (REGFILE*))
           (FD1S& (DELETE-MODULE 'REGFILE NETLIST))
           (WE-REG& (DELETE-MODULE 'REGFILE NETLIST)
                    4)
           (WE-REG& (DELETE-MODULE 'REGFILE NETLIST)
                    32)
           (RAM-ENABLE-CIRCUIT& (DELETE-MODULE 'REGFILE NETLIST))
           (DP-RAM-16X32& (DELETE-MODULE 'REGFILE NETLIST))
           (V-EQUAL& (DELETE-MODULE 'REGFILE NETLIST)
                     4)
           (B-AND3& (DELETE-MODULE 'REGFILE NETLIST))
           (TV-IF& (DELETE-MODULE 'REGFILE NETLIST)
                   (MAKE-TREE 32))
           (ID& (DELETE-MODULE 'REGFILE NETLIST))))

(TOGGLE REGFILE&-OFF REGFILE& T)

(DEFN REGFILE$NETLIST NIL
      (CONS (REGFILE*)
            (UNION (UNION (UNION (UNION (FD1S$NETLIST)
                                        (WE-REG$NETLIST 4))
                                 (UNION (WE-REG$NETLIST 32)
                                        (RAM-ENABLE-CIRCUIT$NETLIST)))
                          (UNION (DP-RAM-16X32$NETLIST)
                                 (UNION (V-EQUAL$NETLIST 4)
                                        (B-AND3$NETLIST))))
                   (UNION (TV-IF$NETLIST (MAKE-TREE 32))
                          (ID$NETLIST)))))

(PROVE-LEMMA CHECK-REGFILE$NETLIST NIL
             (REGFILE& (REGFILE$NETLIST))
             ((EXPAND (REGFILE*))))

(DEFN F$READ-REGS
 (ADDRESS REGS)
 (FV-IF
      (F-AND3 (F-BUF (CADR REGS))
              (F$V-EQUAL ADDRESS
                         (V-THREEFIX (CADDDR REGS)))
              T)
      (V-THREEFIX (CADDR REGS))
      (DUAL-PORT-RAM-VALUE 32 4
                           (APPEND ADDRESS
                                   (APPEND (V-THREEFIX (CADDDR REGS))
                                           (CONS (F-NAND T (F-BUF (CADR REGS)))
                                                 (V-THREEFIX (CADDR REGS)))))
                           (CAR REGS))))

(TOGGLE F$READ-REGS-OFF F$READ-REGS T)

(PROVE-LEMMA PROPERP-LENGTH-F$READ-REGS
             (REWRITE)
             (AND (PROPERP (F$READ-REGS ADDRESS MEM))
                  (IMPLIES (EQUAL (LENGTH (CADDR MEM)) 32)
                           (EQUAL (LENGTH (F$READ-REGS ADDRESS MEM))
                                  32)))
             ((ENABLE F$READ-REGS)))

(PROVE-LEMMA F$READ-REGS=READ-REGS
             (REWRITE)
             (IMPLIES (AND (MEMORY-OKP 4 32 (CAR REGS))
                           (BOOLP (CADR REGS))
                           (BVP (CADDR REGS))
                           (EQUAL (LENGTH (CADDR REGS)) 32)
                           (BVP (CADDDR REGS))
                           (EQUAL (LENGTH (CADDDR REGS)) 4)
                           (BVP ADDRESS)
                           (EQUAL (LENGTH ADDRESS) 4))
                      (EQUAL (F$READ-REGS ADDRESS REGS)
                             (READ-REGS ADDRESS REGS)))
             ((ENABLE READ-REGS F$READ-REGS BOOLP-B-GATES OPEN-NTH)
              (DISABLE *1*MAKE-LIST)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA REGFILE$VALUE
 (REWRITE)
 (IMPLIES
  (AND (REGFILE& NETLIST)
       (EQUAL TEST-REGFILE- T)
       (EQUAL DISABLE-REGFILE- T)
       (MEMORY-PROPERP 4 32 MEM)
       (PROPERP LAST-DATA)
       (EQUAL (LENGTH LAST-DATA) 32)
       (PROPERP ADDRESS)
       (EQUAL (LENGTH ADDRESS) 4)
       (PROPERP LAST-ADDRESS)
       (EQUAL (LENGTH LAST-ADDRESS) 4))
  (EQUAL
   (CDR
     (DUAL-EVAL 0 'REGFILE
                (CONS CLK
                      (CONS TE
                            (CONS TI
                                  (CONS WE
                                        (CONS DISABLE-REGFILE-
                                              (CONS TEST-REGFILE-
                                                    (APPEND ADDRESS DATA)))))))
                (LIST MEM LAST-WE LAST-DATA LAST-ADDRESS)
                NETLIST))
   (F$READ-REGS ADDRESS
                (LIST MEM LAST-WE LAST-DATA LAST-ADDRESS))))
 ((ENABLE REGFILE& F$READ-REGS REGFILE*$DESTRUCTURE OPEN-NTH FD1S$VALUE
          WE-REG$VALUE RAM-ENABLE-CIRCUIT$VALUE DP-RAM-16X32$STRUCTURED-VALUE
          V-EQUAL$VALUE B-AND3$VALUE TV-IF$VALUE ID$VALUE)
  (DISABLE INDICES *1*INDICES OPEN-INDICES OPEN-V-THREEFIX MAKE-TREE
           *1*MAKE-TREE MAKE-LIST *1*MAKE-LIST THREEFIX DUAL-PORT-RAM-VALUE)
  (DISABLE-THEORY F-GATES)))

(TOGGLE REGFILE$VALUE-OFF REGFILE$VALUE T)

(DEFN F$WRITE-REGS
 (WE ADDRESS REGS DATA)
 (LIST
      (DUAL-PORT-RAM-STATE 32 4
                           (APPEND ADDRESS
                                   (APPEND (V-THREEFIX (CADDDR REGS))
                                           (CONS (F-NAND T (F-BUF (CADR REGS)))
                                                 (V-THREEFIX (CADDR REGS)))))
                           (CAR REGS))
      (THREEFIX WE)
      (FV-IF WE DATA (CADDR REGS))
      (FV-IF WE ADDRESS (CADDDR REGS))))

(TOGGLE F$WRITE-REGS-OFF F$WRITE-REGS T)

(PROVE-LEMMA PROPERP-LENGTH-F$WRITE-REGS
             (REWRITE)
             (AND (PROPERP (F$WRITE-REGS WE ADDRESS REGS DATA))
                  (EQUAL (LENGTH (F$WRITE-REGS WE ADDRESS REGS DATA))
                         4))
             ((ENABLE F$WRITE-REGS)
              (DISABLE DUAL-PORT-RAM-STATE THREEFIX)))

(PROVE-LEMMA F$WRITE-REGS=WRITE-REGS
             (REWRITE)
             (IMPLIES (AND (BOOLP WE)
                           (BOOLP (CADR REGS))
                           (BVP (CADDR REGS))
                           (EQUAL (LENGTH (CADDR REGS)) 32)
                           (BVP (CADDDR REGS))
                           (EQUAL (LENGTH (CADDDR REGS)) 4)
                           (BVP ADDRESS)
                           (EQUAL (LENGTH ADDRESS) 4)
                           (BVP DATA)
                           (EQUAL (LENGTH DATA) 32))
                      (EQUAL (F$WRITE-REGS WE ADDRESS REGS DATA)
                             (WRITE-REGS WE ADDRESS REGS DATA)))
             ((ENABLE F$WRITE-REGS WRITE-REGS BOOLP-B-GATES OPEN-NTH
                      SUBRANGE-CONS)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA REGFILE$STATE
 (REWRITE)
 (IMPLIES
  (AND (REGFILE& NETLIST)
       (NOT TE)
       (EQUAL TEST-REGFILE- T)
       (EQUAL DISABLE-REGFILE- T)
       (PROPERP DATA)
       (EQUAL (LENGTH DATA) 32)
       (PROPERP LAST-DATA)
       (EQUAL (LENGTH LAST-DATA) 32)
       (PROPERP ADDRESS)
       (EQUAL (LENGTH ADDRESS) 4)
       (PROPERP LAST-ADDRESS)
       (EQUAL (LENGTH LAST-ADDRESS) 4))
  (EQUAL
     (DUAL-EVAL 2 'REGFILE
                (CONS CLK
                      (CONS TE
                            (CONS TI
                                  (CONS WE
                                        (CONS DISABLE-REGFILE-
                                              (CONS TEST-REGFILE-
                                                    (APPEND ADDRESS DATA)))))))
                (LIST REGFILE LAST-WE LAST-DATA LAST-ADDRESS)
                NETLIST)
     (F$WRITE-REGS WE ADDRESS
                   (LIST REGFILE LAST-WE LAST-DATA LAST-ADDRESS)
                   DATA)))
 ((ENABLE REGFILE& F$WRITE-REGS REGFILE*$DESTRUCTURE OPEN-NTH FD1S$STATE
          FD1S$VALUE WE-REG$STATE WE-REG$VALUE RAM-ENABLE-CIRCUIT$VALUE
          DP-RAM-16X32$STRUCTURED-STATE V-EQUAL$VALUE B-AND3$VALUE TV-IF$VALUE
          ID$VALUE)
  (DISABLE INDICES *1*INDICES OPEN-INDICES OPEN-V-THREEFIX MAKE-TREE
           *1*MAKE-TREE MAKE-LIST *1*MAKE-LIST THREEFIX DUAL-PORT-RAM-STATE)
  (EXPAND (F-IF F TI WE) (F-BUF WE))
  (DISABLE-THEORY F-GATES)))

(TOGGLE REGFILE$STATE-OFF REGFILE$STATE T)

(DEFN FLAGS* NIL
 (CONS 'FLAGS
  (CONS
    (CONS 'CLK
          (CONS 'TE
                (CONS 'TI
                      (APPEND (INDICES 'SET-FLAGS 0 4)
                              (INDICES 'CVZBV 0 35)))))
    (CONS '(Z N V C)
          (CONS (LIST (LIST 'Z-LATCH
                            '(Z ZB)
                            'FD1SLP
                            (CONS (ZB (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (Z-SET (INDICES 'SET-FLAGS 0 4))
                                              '(TI TE)))))
                      (LIST 'N-LATCH
                            '(N NB)
                            'FD1SLP
                            (CONS (INDEX 'CVZBV 34)
                                  (CONS 'CLK
                                        (CONS (N-SET (INDICES 'SET-FLAGS 0 4))
                                              '(Z TE)))))
                      (LIST 'V-LATCH
                            '(V VB)
                            'FD1SLP
                            (CONS (V (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (V-SET (INDICES 'SET-FLAGS 0 4))
                                              '(N TE)))))
                      (LIST 'C-LATCH
                            '(C CB)
                            'FD1SLP
                            (CONS (C (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (C-SET (INDICES 'SET-FLAGS 0 4))
                                              '(V TE))))))
                '((Z-LATCH N-LATCH V-LATCH C-LATCH)))))))

(PROVE-LEMMA FLAGS*$DESTRUCTURE
    (REWRITE)
    (AND (EQUAL (CAR (FLAGS*)) 'FLAGS)
         (EQUAL (CADR (FLAGS*))
                (CONS 'CLK
                      (CONS 'TE
                            (CONS 'TI
                                  (APPEND (INDICES 'SET-FLAGS 0 4)
                                          (INDICES 'CVZBV 0 35))))))
         (EQUAL (CADDR (FLAGS*)) '(Z N V C))
         (EQUAL (CADDDR (FLAGS*))
                (LIST (LIST 'Z-LATCH
                            '(Z ZB)
                            'FD1SLP
                            (CONS (ZB (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (Z-SET (INDICES 'SET-FLAGS 0 4))
                                              '(TI TE)))))
                      (LIST 'N-LATCH
                            '(N NB)
                            'FD1SLP
                            (CONS (INDEX 'CVZBV 34)
                                  (CONS 'CLK
                                        (CONS (N-SET (INDICES 'SET-FLAGS 0 4))
                                              '(Z TE)))))
                      (LIST 'V-LATCH
                            '(V VB)
                            'FD1SLP
                            (CONS (V (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (V-SET (INDICES 'SET-FLAGS 0 4))
                                              '(N TE)))))
                      (LIST 'C-LATCH
                            '(C CB)
                            'FD1SLP
                            (CONS (C (INDICES 'CVZBV 0 35))
                                  (CONS 'CLK
                                        (CONS (C-SET (INDICES 'SET-FLAGS 0 4))
                                              '(V TE)))))))
         (EQUAL (CADDDDR (FLAGS*))
                '(Z-LATCH N-LATCH V-LATCH C-LATCH))))

(TOGGLE FLAGS*-OFF FLAGS* T)

(TOGGLE FLAGS*$DESTRUCTURE-OFF FLAGS*$DESTRUCTURE T)

(TOGGLE G*1*FLAGS*-OFF *1*FLAGS* T)

(DEFN FLAGS&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'FLAGS NETLIST)
                  (FLAGS*))
           (FD1SLP& (DELETE-MODULE 'FLAGS NETLIST))))

(TOGGLE FLAGS&-OFF FLAGS& T)

(DEFN FLAGS$NETLIST NIL
      (CONS (FLAGS*) (FD1SLP$NETLIST)))

(PROVE-LEMMA CHECK-FLAGS$NETLIST NIL
             (FLAGS& (FLAGS$NETLIST))
             ((EXPAND (FLAGS*))))

(PROVE-LEMMA FLAGS$VALUE
    (REWRITE)
    (IMPLIES (AND (FLAGS& NETLIST)
                  (PROPERP FLAGS)
                  (EQUAL (LENGTH FLAGS) 4))
             (EQUAL (DUAL-EVAL 0 'FLAGS
                               (CONS CLK
                                     (CONS TE
                                           (CONS TI (APPEND SET-FLAGS CVZBV))))
                               FLAGS NETLIST)
                    (V-THREEFIX FLAGS)))
    ((ENABLE FLAGS& FLAGS*$DESTRUCTURE FD1SLP$VALUE C-SET V-SET N-SET Z-SET C
             V ZB OPEN-NTH EQUAL-LENGTH-ADD1)
     (DISABLE INDICES *1*INDICES OPEN-INDICES)))

(TOGGLE FLAGS$VALUE-OFF FLAGS$VALUE T)

(DEFN F$UPDATE-FLAGS
      (FLAGS SET-FLAGS CVZBV)
      (LIST (F-IF (Z-SET SET-FLAGS)
                  (ZB CVZBV)
                  (Z-FLAG FLAGS))
            (F-IF (N-SET SET-FLAGS)
                  (N CVZBV)
                  (N-FLAG FLAGS))
            (F-IF (V-SET SET-FLAGS)
                  (V CVZBV)
                  (V-FLAG FLAGS))
            (F-IF (C-SET SET-FLAGS)
                  (C CVZBV)
                  (C-FLAG FLAGS))))

(TOGGLE F$UPDATE-FLAGS-OFF F$UPDATE-FLAGS T)

(PROVE-LEMMA PROPERP-LENGTH-F$UPDATE-FLAGS
             (REWRITE)
             (AND (PROPERP (F$UPDATE-FLAGS FLAGS SET-FLAGS CVZBV))
                  (EQUAL (LENGTH (F$UPDATE-FLAGS FLAGS SET-FLAGS CVZBV))
                         4))
             ((ENABLE F$UPDATE-FLAGS)))

(PROVE-LEMMA F$UPDATE-FLAGS=UPDATE-FLAGS
             (REWRITE)
             (IMPLIES (AND (BVP FLAGS)
                           (EQUAL (LENGTH FLAGS) 4)
                           (BVP SET-FLAGS)
                           (EQUAL (LENGTH SET-FLAGS) 4)
                           (BVP CVZBV)
                           (EQUAL (LENGTH CVZBV) 35))
                      (EQUAL (F$UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)
                             (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
             ((ENABLE F$UPDATE-FLAGS UPDATE-FLAGS Z-SET ZB Z-FLAG N-SET N
                      N-FLAG V-SET V V-FLAG C-SET C C-FLAG)
              (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA FLAGS$STATE-HELP
    (REWRITE)
    (IMPLIES (AND (FLAGS& NETLIST)
                  (PROPERP FLAGS)
                  (EQUAL (LENGTH FLAGS) 4)
                  (EQUAL SET-FLAGS
                         (LIST SET-Z SET-N SET-V SET-C))
                  (EQUAL CVZBV
                         (CONS C (CONS V (CONS Z BV))))
                  (PROPERP CVZBV)
                  (EQUAL (LENGTH CVZBV) 35)
                  (NOT TE))
             (EQUAL (DUAL-EVAL 2 'FLAGS
                               (CONS CLK
                                     (CONS TE
                                           (CONS TI (APPEND SET-FLAGS CVZBV))))
                               FLAGS NETLIST)
                    (F$UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
    ((ENABLE FLAGS& F$UPDATE-FLAGS FLAGS*$DESTRUCTURE FD1SLP$STATE C-SET V-SET
             N-SET Z-SET C-FLAG V-FLAG N-FLAG Z-FLAG C V ZB N BV UPDATE-FLAGS
             NTH V-NEGP-AS-NTH)
     (DISABLE INDICES *1*INDICES OPEN-INDICES)
     (EXPAND (INDICES 'SET-FLAGS 0 4)
             (INDICES 'SET-FLAGS 1 3)
             (INDICES 'SET-FLAGS 2 2)
             (INDICES 'SET-FLAGS 3 1)
             (INDICES 'CVZBV 0 35)
             (INDICES 'CVZBV 1 34)
             (INDICES 'CVZBV 2 33))))

(TOGGLE FLAGS$STATE-HELP-OFF FLAGS$STATE-HELP T)

(PROVE-LEMMA FLAGS$STATE
    (REWRITE)
    (IMPLIES (AND (FLAGS& NETLIST)
                  (PROPERP FLAGS)
                  (EQUAL (LENGTH FLAGS) 4)
                  (PROPERP SET-FLAGS)
                  (EQUAL (LENGTH SET-FLAGS) 4)
                  (PROPERP CVZBV)
                  (EQUAL (LENGTH CVZBV) 35)
                  (NOT TE))
             (EQUAL (DUAL-EVAL 2 'FLAGS
                               (CONS CLK
                                     (CONS TE
                                           (CONS TI (APPEND SET-FLAGS CVZBV))))
                               FLAGS NETLIST)
                    (F$UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
    ((USE (FLAGS$STATE-HELP (SET-Z (CAR SET-FLAGS))
                            (SET-N (CADR SET-FLAGS))
                            (SET-V (CADDR SET-FLAGS))
                            (SET-C (CADDDR SET-FLAGS))
                            (C (CAR CVZBV))
                            (V (CADR CVZBV))
                            (Z (CADDR CVZBV))
                            (BV (CDDDR CVZBV))))))

(TOGGLE FLAGS$STATE-OFF FLAGS$STATE T)

(PROVE-LEMMA FLAGS$PARTIAL-STATE-HELP
    (REWRITE)
    (IMPLIES (AND (FLAGS& NETLIST)
                  (PROPERP FLAGS)
                  (EQUAL (LENGTH FLAGS) 4)
                  (EQUAL SET-FLAGS (MAKE-LIST 4 T))
                  (EQUAL CVZBV
                         (CONS C (CONS V (CONS Z BV))))
                  (BVP CVZBV)
                  (EQUAL (LENGTH CVZBV) 35)
                  (NOT TE))
             (EQUAL (DUAL-EVAL 2 'FLAGS
                               (CONS CLK
                                     (CONS TE
                                           (CONS TI (APPEND SET-FLAGS CVZBV))))
                               FLAGS NETLIST)
                    (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
    ((ENABLE FLAGS& FLAGS*$DESTRUCTURE FD1SLP$STATE C-SET V-SET N-SET Z-SET
             C-FLAG V-FLAG N-FLAG Z-FLAG C V ZB N BV UPDATE-FLAGS NTH
             V-NEGP-AS-NTH)
     (DISABLE INDICES *1*INDICES OPEN-INDICES)
     (EXPAND (INDICES 'SET-FLAGS 0 4)
             (INDICES 'SET-FLAGS 1 3)
             (INDICES 'SET-FLAGS 2 2)
             (INDICES 'SET-FLAGS 3 1)
             (INDICES 'CVZBV 0 35)
             (INDICES 'CVZBV 1 34)
             (INDICES 'CVZBV 2 33))))

(TOGGLE FLAGS$PARTIAL-STATE-HELP-OFF FLAGS$PARTIAL-STATE-HELP T)

(PROVE-LEMMA FLAGS$PARTIAL-STATE
    (REWRITE)
    (IMPLIES (AND (FLAGS& NETLIST)
                  (PROPERP FLAGS)
                  (EQUAL (LENGTH FLAGS) 4)
                  (EQUAL SET-FLAGS (MAKE-LIST 4 T))
                  (BVP CVZBV)
                  (EQUAL (LENGTH CVZBV) 35)
                  (NOT TE))
             (EQUAL (DUAL-EVAL 2 'FLAGS
                               (CONS CLK
                                     (CONS TE
                                           (CONS TI (APPEND SET-FLAGS CVZBV))))
                               FLAGS NETLIST)
                    (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
    ((USE (FLAGS$PARTIAL-STATE-HELP (C (CAR CVZBV))
                                    (V (CADR CVZBV))
                                    (Z (CADDR CVZBV))
                                    (BV (CDDDR CVZBV))))
     (DISABLE *1*MAKE-LIST)))

(TOGGLE FLAGS$PARTIAL-STATE-OFF FLAGS$PARTIAL-STATE T)

(DEFN EXTEND-IMMEDIATE* NIL
 (CONS 'EXTEND-IMMEDIATE
  (CONS
       (CONS 'SELECT-IMMEDIATE
             (APPEND (INDICES 'IMMEDIATE 0 9)
                     (INDICES 'REG-DATA 0 32)))
       (CONS (INDICES 'Z 0 32)
             (CONS (LIST (LIST 'BUFFER
                               '(SIGN-BIT)
                               'B-BUF-PWR
                               (LIST (INDEX 'IMMEDIATE 8)))
                         (LIST 'MUX
                               (INDICES 'Z 0 32)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 32)))
                               (CONS 'SELECT-IMMEDIATE
                                     (APPEND (APPEND (INDICES 'IMMEDIATE 0 9)
                                                     (MAKE-LIST 23 'SIGN-BIT))
                                             (INDICES 'REG-DATA 0 32)))))
                   '(NIL))))))

(PROVE-LEMMA EXTEND-IMMEDIATE*$DESTRUCTURE
       (REWRITE)
       (AND (EQUAL (CAR (EXTEND-IMMEDIATE*))
                   'EXTEND-IMMEDIATE)
            (EQUAL (CADR (EXTEND-IMMEDIATE*))
                   (CONS 'SELECT-IMMEDIATE
                         (APPEND (INDICES 'IMMEDIATE 0 9)
                                 (INDICES 'REG-DATA 0 32))))
            (EQUAL (CADDR (EXTEND-IMMEDIATE*))
                   (INDICES 'Z 0 32))
            (EQUAL (CADDDR (EXTEND-IMMEDIATE*))
                   (LIST (LIST 'BUFFER
                               '(SIGN-BIT)
                               'B-BUF-PWR
                               (LIST (INDEX 'IMMEDIATE 8)))
                         (LIST 'MUX
                               (INDICES 'Z 0 32)
                               (INDEX 'TV-IF
                                      (TREE-NUMBER (MAKE-TREE 32)))
                               (CONS 'SELECT-IMMEDIATE
                                     (APPEND (APPEND (INDICES 'IMMEDIATE 0 9)
                                                     (MAKE-LIST 23 'SIGN-BIT))
                                             (INDICES 'REG-DATA 0 32))))))
            (EQUAL (CADDDDR (EXTEND-IMMEDIATE*))
                   NIL)))

(TOGGLE EXTEND-IMMEDIATE*-OFF EXTEND-IMMEDIATE* T)

(TOGGLE EXTEND-IMMEDIATE*$DESTRUCTURE-OFF EXTEND-IMMEDIATE*$DESTRUCTURE T)

(TOGGLE G*1*EXTEND-IMMEDIATE*-OFF *1*EXTEND-IMMEDIATE* T)

(DEFN EXTEND-IMMEDIATE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'EXTEND-IMMEDIATE
                                 NETLIST)
                  (EXTEND-IMMEDIATE*))
           (B-BUF-PWR& (DELETE-MODULE 'EXTEND-IMMEDIATE
                                      NETLIST))
           (TV-IF& (DELETE-MODULE 'EXTEND-IMMEDIATE
                                  NETLIST)
                   (MAKE-TREE 32))))

(TOGGLE EXTEND-IMMEDIATE&-OFF EXTEND-IMMEDIATE& T)

(DEFN EXTEND-IMMEDIATE$NETLIST NIL
      (CONS (EXTEND-IMMEDIATE*)
            (UNION (B-BUF-PWR$NETLIST)
                   (TV-IF$NETLIST (MAKE-TREE 32)))))

(PROVE-LEMMA CHECK-EXTEND-IMMEDIATE$NETLIST NIL
             (EXTEND-IMMEDIATE& (EXTEND-IMMEDIATE$NETLIST))
             ((EXPAND (EXTEND-IMMEDIATE*))))

(DEFN F$EXTEND-IMMEDIATE
      (SELECT-IMMEDIATE IMMEDIATE REG-DATA)
      (FV-IF SELECT-IMMEDIATE
             (APPEND IMMEDIATE
                     (IF (BOOLP (NTH 8 IMMEDIATE))
                         (MAKE-LIST 23 (NTH 8 IMMEDIATE))
                         (MAKE-LIST 23 (X))))
             REG-DATA))

(TOGGLE F$EXTEND-IMMEDIATE-OFF F$EXTEND-IMMEDIATE T)

(PROVE-LEMMA PROPERP-LENGTH-F$EXTEND-IMMEDIATE
             (REWRITE)
             (AND (PROPERP (F$EXTEND-IMMEDIATE SELECT-IMMEDIATE IMMEDIATE
                                               REG-BUS))
                  (IMPLIES (EQUAL (LENGTH IMMEDIATE) 9)
                           (EQUAL (LENGTH (F$EXTEND-IMMEDIATE SELECT-IMMEDIATE
                                                              IMMEDIATE
                                                              REG-BUS))
                                  32)))
             ((ENABLE F$EXTEND-IMMEDIATE)))

(PROVE-LEMMA F$EXTEND-IMMEDIATE=EXTEND-IMMEDIATE
             (REWRITE)
             (IMPLIES (AND (BVP IMMEDIATE)
                           (EQUAL (LENGTH IMMEDIATE) 9)
                           (BVP REG-DATA)
                           (EQUAL (LENGTH REG-DATA) 32)
                           (BOOLP SELECT-IMMEDIATE))
                      (EQUAL (F$EXTEND-IMMEDIATE SELECT-IMMEDIATE IMMEDIATE
                                                 REG-DATA)
                             (IF* SELECT-IMMEDIATE
                                  (SIGN-EXTEND IMMEDIATE 32)
                                  REG-DATA)))
             ((ENABLE F$EXTEND-IMMEDIATE SIGN-EXTEND-AS-APPEND IF*)
              (DISABLE ASSOCIATIVITY-OF-APPEND MAKE-LIST *1*MAKE-LIST INDICES
                       *1*INDICES OPEN-INDICES MAKE-TREE *1*MAKE-TREE)))

(PROVE-LEMMA EXTEND-IMMEDIATE$VALUE
             (REWRITE)
             (IMPLIES (AND (EXTEND-IMMEDIATE& NETLIST)
                           (PROPERP IMMEDIATE)
                           (EQUAL (LENGTH IMMEDIATE) 9)
                           (PROPERP REG-DATA)
                           (EQUAL (LENGTH REG-DATA) 32))
                      (EQUAL (DUAL-EVAL 0 'EXTEND-IMMEDIATE
                                        (CONS SELECT-IMMEDIATE
                                              (APPEND IMMEDIATE REG-DATA))
                                        STATE NETLIST)
                             (F$EXTEND-IMMEDIATE SELECT-IMMEDIATE IMMEDIATE
                                                 REG-DATA)))
             ((ENABLE F$EXTEND-IMMEDIATE EXTEND-IMMEDIATE&
                      EXTEND-IMMEDIATE*$DESTRUCTURE B-BUF-PWR$VALUE
                      TV-IF$VALUE)
              (DISABLE ASSOCIATIVITY-OF-APPEND MAKE-LIST *1*MAKE-LIST INDICES
                       *1*INDICES OPEN-INDICES MAKE-TREE *1*MAKE-TREE)))

(TOGGLE EXTEND-IMMEDIATE$VALUE-OFF EXTEND-IMMEDIATE$VALUE T)

(DEFN TTL-INPUT-PADS-BODY
      (M N PI)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'OUT M) (INDEX 'PO M))
                      'TTL-INPUT
                      (LIST (INDEX 'IN M) PI))
                (CONS (LIST (INDEX 'B M)
                            (LIST (INDEX 'B-OUT M))
                            'B-BUF
                            (LIST (INDEX 'OUT M)))
                      (TTL-INPUT-PADS-BODY (ADD1 M)
                                           (SUB1 N)
                                           (INDEX 'PO M))))))

(TOGGLE TTL-INPUT-PADS-BODY-OFF TTL-INPUT-PADS-BODY T)

(DEFN TTL-INPUT-PADS-BODY$INDUCTION
 (M N PI BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  T
  (TTL-INPUT-PADS-BODY$INDUCTION
                          (ADD1 M)
                          (SUB1 N)
                          (INDEX 'PO M)
                          (DUAL-EVAL-BODY-BINDINGS 2
                                                   (TTL-INPUT-PADS-BODY M N PI)
                                                   BINDINGS STATE-BINDINGS
                                                   NETLIST)
                          STATE-BINDINGS NETLIST)))

(DEFN TTL-INPUT-PADS*
      (N)
      (CONS (INDEX 'TTL-INPUT-PADS N)
            (CONS (CONS 'PI (INDICES 'IN 0 N))
                  (CONS (CONS (INDEX 'PO (SUB1 N))
                              (INDICES 'B-OUT 0 N))
                        (CONS (TTL-INPUT-PADS-BODY 0 N 'PI)
                              '(NIL))))))

(PROVE-LEMMA TTL-INPUT-PADS*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TTL-INPUT-PADS* N))
                         (INDEX 'TTL-INPUT-PADS N))
                  (EQUAL (CADR (TTL-INPUT-PADS* N))
                         (CONS 'PI (INDICES 'IN 0 N)))
                  (EQUAL (CADDR (TTL-INPUT-PADS* N))
                         (CONS (INDEX 'PO (SUB1 N))
                               (INDICES 'B-OUT 0 N)))
                  (EQUAL (CADDDR (TTL-INPUT-PADS* N))
                         (TTL-INPUT-PADS-BODY 0 N 'PI))
                  (EQUAL (CADDDDR (TTL-INPUT-PADS* N))
                         NIL)))

(TOGGLE TTL-INPUT-PADS*-OFF TTL-INPUT-PADS* T)

(TOGGLE TTL-INPUT-PADS*$DESTRUCTURE-OFF TTL-INPUT-PADS*$DESTRUCTURE T)

(DEFN TTL-INPUT-PADS&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TTL-INPUT-PADS N)
                                 NETLIST)
                  (TTL-INPUT-PADS* N))
           (TTL-INPUT& (DELETE-MODULE (INDEX 'TTL-INPUT-PADS N)
                                      NETLIST))
           (B-BUF& (DELETE-MODULE (INDEX 'TTL-INPUT-PADS N)
                                  NETLIST))))

(TOGGLE TTL-INPUT-PADS&-OFF TTL-INPUT-PADS& T)

(DEFN TTL-INPUT-PADS$NETLIST
      (N)
      (CONS (TTL-INPUT-PADS* N)
            (UNION (TTL-INPUT$NETLIST)
                   (B-BUF$NETLIST))))

(PROVE-LEMMA TTL-INPUT-PADS-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'B-OUT L)
                                       (TTL-INPUT-PADS-BODY M N PI)))
             ((ENABLE UNBOUND-IN-BODY TTL-INPUT-PADS-BODY)))

(TOGGLE TTL-INPUT-PADS-BODY$UNBOUND-IN-BODY-OFF
        TTL-INPUT-PADS-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA TTL-INPUT-PADS-BODY$VALUE
         (REWRITE)
         (IMPLIES (AND (TTL-INPUT& NETLIST)
                       (B-BUF& NETLIST))
                  (EQUAL (COLLECT-VALUE (INDICES 'B-OUT M N)
                                        (DUAL-EVAL 1
                                                   (TTL-INPUT-PADS-BODY M N PI)
                                                   BINDINGS STATE-BINDINGS
                                                   NETLIST))
                         (V-THREEFIX (COLLECT-VALUE (INDICES 'IN M N)
                                                    BINDINGS))))
         ((ENABLE TTL-INPUT-PADS-BODY TTL-INPUT-PADS-BODY$UNBOUND-IN-BODY
                  V-THREEFIX TTL-INPUT$VALUE B-BUF$VALUE)
          (INDUCT (TTL-INPUT-PADS-BODY$INDUCTION M N PI BINDINGS
                                                 STATE-BINDINGS NETLIST))))

(TOGGLE TTL-INPUT-PADS-BODY$VALUE-OFF TTL-INPUT-PADS-BODY$VALUE T)

(PROVE-LEMMA TTL-INPUT-PADS$VALUE
             (REWRITE)
             (IMPLIES (AND (TTL-INPUT-PADS& NETLIST N)
                           (EQUAL (LENGTH INPUTS) N)
                           (PROPERP INPUTS))
                      (EQUAL (CDR (DUAL-EVAL 0
                                             (INDEX 'TTL-INPUT-PADS N)
                                             (CONS PI INPUTS)
                                             STATE NETLIST))
                             (V-THREEFIX INPUTS)))
             ((ENABLE TTL-INPUT-PADS& TTL-INPUT-PADS-BODY$VALUE
                      TTL-INPUT-PADS*$DESTRUCTURE)
              (DISABLE V-THREEFIX OPEN-INDICES)))

(TOGGLE TTL-INPUT-PADS$VALUE-OFF TTL-INPUT-PADS$VALUE T)

(DEFN TTL-OUTPUT-PADS-BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'B M)
                      (LIST (INDEX 'B-IN M))
                      'B-BUF
                      (LIST (INDEX 'IN M)))
                (CONS (LIST (INDEX 'G M)
                            (LIST (INDEX 'OUT M))
                            'TTL-OUTPUT
                            (LIST (INDEX 'B-IN M)))
                      (TTL-OUTPUT-PADS-BODY (ADD1 M)
                                            (SUB1 N))))))

(TOGGLE TTL-OUTPUT-PADS-BODY-OFF TTL-OUTPUT-PADS-BODY T)

(DEFN TTL-OUTPUT-PADS-BODY$INDUCTION
 (M N BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  T
  (TTL-OUTPUT-PADS-BODY$INDUCTION
                            (ADD1 M)
                            (SUB1 N)
                            (DUAL-EVAL-BODY-BINDINGS 2
                                                     (TTL-OUTPUT-PADS-BODY M N)
                                                     BINDINGS STATE-BINDINGS
                                                     NETLIST)
                            STATE-BINDINGS NETLIST)))

(DEFN TTL-OUTPUT-PADS*
      (N)
      (CONS (INDEX 'TTL-OUTPUT-PADS N)
            (CONS (INDICES 'IN 0 N)
                  (CONS (INDICES 'OUT 0 N)
                        (CONS (TTL-OUTPUT-PADS-BODY 0 N)
                              '(NIL))))))

(PROVE-LEMMA TTL-OUTPUT-PADS*$DESTRUCTURE
             (REWRITE)
             (AND (EQUAL (CAR (TTL-OUTPUT-PADS* N))
                         (INDEX 'TTL-OUTPUT-PADS N))
                  (EQUAL (CADR (TTL-OUTPUT-PADS* N))
                         (INDICES 'IN 0 N))
                  (EQUAL (CADDR (TTL-OUTPUT-PADS* N))
                         (INDICES 'OUT 0 N))
                  (EQUAL (CADDDR (TTL-OUTPUT-PADS* N))
                         (TTL-OUTPUT-PADS-BODY 0 N))
                  (EQUAL (CADDDDR (TTL-OUTPUT-PADS* N))
                         NIL)))

(TOGGLE TTL-OUTPUT-PADS*-OFF TTL-OUTPUT-PADS* T)

(TOGGLE TTL-OUTPUT-PADS*$DESTRUCTURE-OFF TTL-OUTPUT-PADS*$DESTRUCTURE T)

(DEFN TTL-OUTPUT-PADS&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TTL-OUTPUT-PADS N)
                                 NETLIST)
                  (TTL-OUTPUT-PADS* N))
           (TTL-OUTPUT& (DELETE-MODULE (INDEX 'TTL-OUTPUT-PADS N)
                                       NETLIST))
           (B-BUF& (DELETE-MODULE (INDEX 'TTL-OUTPUT-PADS N)
                                  NETLIST))))

(TOGGLE TTL-OUTPUT-PADS&-OFF TTL-OUTPUT-PADS& T)

(DEFN TTL-OUTPUT-PADS$NETLIST
      (N)
      (CONS (TTL-OUTPUT-PADS* N)
            (UNION (TTL-OUTPUT$NETLIST)
                   (B-BUF$NETLIST))))

(PROVE-LEMMA TTL-OUTPUT-PADS-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'OUT L)
                                       (TTL-OUTPUT-PADS-BODY M N)))
             ((ENABLE UNBOUND-IN-BODY TTL-OUTPUT-PADS-BODY)))

(TOGGLE TTL-OUTPUT-PADS-BODY$UNBOUND-IN-BODY-OFF
        TTL-OUTPUT-PADS-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA TTL-OUTPUT-PADS-BODY$VALUE
           (REWRITE)
           (IMPLIES (AND (TTL-OUTPUT& NETLIST)
                         (B-BUF& NETLIST))
                    (EQUAL (COLLECT-VALUE (INDICES 'OUT M N)
                                          (DUAL-EVAL 1
                                                     (TTL-OUTPUT-PADS-BODY M N)
                                                     BINDINGS STATE-BINDINGS
                                                     NETLIST))
                           (V-THREEFIX (COLLECT-VALUE (INDICES 'IN M N)
                                                      BINDINGS))))
           ((ENABLE TTL-OUTPUT-PADS-BODY TTL-OUTPUT-PADS-BODY$UNBOUND-IN-BODY
                    V-THREEFIX TTL-OUTPUT$VALUE B-BUF$VALUE)
            (INDUCT (TTL-OUTPUT-PADS-BODY$INDUCTION M N BINDINGS
                                                    STATE-BINDINGS NETLIST))))

(TOGGLE TTL-OUTPUT-PADS-BODY$VALUE-OFF TTL-OUTPUT-PADS-BODY$VALUE T)

(PROVE-LEMMA TTL-OUTPUT-PADS$VALUE
             (REWRITE)
             (IMPLIES (AND (TTL-OUTPUT-PADS& NETLIST N)
                           (EQUAL (LENGTH INPUTS) N)
                           (PROPERP INPUTS))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TTL-OUTPUT-PADS N)
                                        INPUTS STATE NETLIST)
                             (V-THREEFIX INPUTS)))
             ((ENABLE TTL-OUTPUT-PADS& TTL-OUTPUT-PADS*$DESTRUCTURE
                      TTL-OUTPUT-PADS-BODY$VALUE)
              (DISABLE V-THREEFIX OPEN-INDICES)))

(DEFN TTL-TRI-OUTPUT-PADS-BODY
      (M N)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'OUT M))
                      'TTL-TRI-OUTPUT
                      (CONS (INDEX 'IN M) '(ENABLE-BUF)))
                (TTL-TRI-OUTPUT-PADS-BODY (ADD1 M)
                                          (SUB1 N)))))

(TOGGLE TTL-TRI-OUTPUT-PADS-BODY-OFF TTL-TRI-OUTPUT-PADS-BODY T)

(DEFN TTL-TRI-OUTPUT-PADS-BODY$INDUCTION
 (M N BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  T
  (TTL-TRI-OUTPUT-PADS-BODY$INDUCTION
                        (ADD1 M)
                        (SUB1 N)
                        (DUAL-EVAL-BODY-BINDINGS 1
                                                 (TTL-TRI-OUTPUT-PADS-BODY M N)
                                                 BINDINGS STATE-BINDINGS
                                                 NETLIST)
                        STATE-BINDINGS NETLIST)))

(DEFN TTL-TRI-OUTPUT-PADS*
 (N)
 (CONS
  (INDEX 'TTL-TRI-OUTPUT-PADS N)
  (CONS
       (CONS 'ENABLE (INDICES 'IN 0 N))
       (CONS (INDICES 'OUT 0 N)
             (CONS (CONS (CONS 'ENABLE-BUFFER
                               (CONS '(ENABLE-BUF)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((ENABLE)))))
                         (TTL-TRI-OUTPUT-PADS-BODY 0 N))
                   '(NIL))))))

(PROVE-LEMMA TTL-TRI-OUTPUT-PADS*$DESTRUCTURE
       (REWRITE)
       (AND (EQUAL (CAR (TTL-TRI-OUTPUT-PADS* N))
                   (INDEX 'TTL-TRI-OUTPUT-PADS N))
            (EQUAL (CADR (TTL-TRI-OUTPUT-PADS* N))
                   (CONS 'ENABLE (INDICES 'IN 0 N)))
            (EQUAL (CADDR (TTL-TRI-OUTPUT-PADS* N))
                   (INDICES 'OUT 0 N))
            (EQUAL (CADDDR (TTL-TRI-OUTPUT-PADS* N))
                   (CONS (CONS 'ENABLE-BUFFER
                               (CONS '(ENABLE-BUF)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((ENABLE)))))
                         (TTL-TRI-OUTPUT-PADS-BODY 0 N)))
            (EQUAL (CADDDDR (TTL-TRI-OUTPUT-PADS* N))
                   NIL)))

(TOGGLE TTL-TRI-OUTPUT-PADS*-OFF TTL-TRI-OUTPUT-PADS* T)

(TOGGLE TTL-TRI-OUTPUT-PADS*$DESTRUCTURE-OFF TTL-TRI-OUTPUT-PADS*$DESTRUCTURE T)

(DEFN TTL-TRI-OUTPUT-PADS&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TTL-TRI-OUTPUT-PADS N)
                                 NETLIST)
                  (TTL-TRI-OUTPUT-PADS* N))
           (TTL-TRI-OUTPUT& (DELETE-MODULE (INDEX 'TTL-TRI-OUTPUT-PADS N)
                                           NETLIST))
           (IF (LESSP N 8)
               (B-BUF& (DELETE-MODULE (INDEX 'TTL-TRI-OUTPUT-PADS N)
                                      NETLIST))
               (B-BUF-PWR& (DELETE-MODULE (INDEX 'TTL-TRI-OUTPUT-PADS N)
                                          NETLIST)))))

(TOGGLE TTL-TRI-OUTPUT-PADS&-OFF TTL-TRI-OUTPUT-PADS& T)

(DEFN TTL-TRI-OUTPUT-PADS$NETLIST
      (N)
      (CONS (TTL-TRI-OUTPUT-PADS* N)
            (UNION (IF (LESSP N 8)
                       (B-BUF$NETLIST)
                       (B-BUF-PWR$NETLIST))
                   (TTL-TRI-OUTPUT$NETLIST))))

(PROVE-LEMMA TTL-TRI-OUTPUT-PADS-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (UNBOUND-IN-BODY (INDEX 'OUT L)
                                       (TTL-TRI-OUTPUT-PADS-BODY M N)))
             ((ENABLE UNBOUND-IN-BODY TTL-TRI-OUTPUT-PADS-BODY)))

(TOGGLE TTL-TRI-OUTPUT-PADS-BODY$UNBOUND-IN-BODY-OFF
        TTL-TRI-OUTPUT-PADS-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA TTL-TRI-OUTPUT-PADS-BODY$VALUE
       (REWRITE)
       (IMPLIES (TTL-TRI-OUTPUT& NETLIST)
                (EQUAL (COLLECT-VALUE (INDICES 'OUT M N)
                                      (DUAL-EVAL 1
                                                 (TTL-TRI-OUTPUT-PADS-BODY M N)
                                                 BINDINGS STATE-BINDINGS
                                                 NETLIST))
                       (VFT-BUF (F-NOT (VALUE 'ENABLE-BUF BINDINGS))
                                (COLLECT-VALUE (INDICES 'IN M N)
                                               BINDINGS))))
       ((ENABLE TTL-TRI-OUTPUT-PADS-BODY
                TTL-TRI-OUTPUT-PADS-BODY$UNBOUND-IN-BODY V-THREEFIX
                TTL-TRI-OUTPUT$VALUE MAKE-LIST VFT-BUF-REWRITE)
        (INDUCT (TTL-TRI-OUTPUT-PADS-BODY$INDUCTION M N BINDINGS
                                                    STATE-BINDINGS NETLIST))))

(TOGGLE TTL-TRI-OUTPUT-PADS-BODY$VALUE-OFF TTL-TRI-OUTPUT-PADS-BODY$VALUE T)

(PROVE-LEMMA TTL-TRI-OUTPUT-PADS$VALUE
             (REWRITE)
             (IMPLIES (AND (TTL-TRI-OUTPUT-PADS& NETLIST N)
                           (EQUAL (LENGTH INPUTS) N)
                           (PROPERP INPUTS))
                      (EQUAL (DUAL-EVAL 0
                                        (INDEX 'TTL-TRI-OUTPUT-PADS N)
                                        (CONS ENABLE INPUTS)
                                        STATE NETLIST)
                             (VFT-BUF (F-NOT ENABLE) INPUTS)))
             ((ENABLE TTL-TRI-OUTPUT-PADS& TTL-TRI-OUTPUT-PADS*$DESTRUCTURE
                      TTL-TRI-OUTPUT-PADS-BODY$VALUE B-BUF$VALUE
                      B-BUF-PWR$VALUE)
              (DISABLE V-THREEFIX OPEN-INDICES)))

(TOGGLE TTL-TRI-OUTPUT-PADS$VALUE-OFF TTL-TRI-OUTPUT-PADS$VALUE T)

(DEFN TTL-BIDIRECT-PADS-BODY
      (M N PI)
      (IF (ZEROP N)
          NIL
          (CONS (LIST (INDEX 'G M)
                      (LIST (INDEX 'DATA M)
                            (INDEX 'OUT M)
                            (INDEX 'PO M))
                      'TTL-BIDIRECT
                      (LIST (INDEX 'DATA M)
                            (INDEX 'IN M)
                            'BUF-ENABLE
                            PI))
                (TTL-BIDIRECT-PADS-BODY (ADD1 M)
                                        (SUB1 N)
                                        (INDEX 'PO M)))))

(TOGGLE TTL-BIDIRECT-PADS-BODY-OFF TTL-BIDIRECT-PADS-BODY T)

(DEFN TTL-BIDIRECT-PADS-BODY$INDUCTION
 (M N PI BINDINGS STATE-BINDINGS NETLIST)
 (IF
  (ZEROP N)
  T
  (TTL-BIDIRECT-PADS-BODY$INDUCTION
                       (ADD1 M)
                       (SUB1 N)
                       (INDEX 'PO M)
                       (DUAL-EVAL-BODY-BINDINGS 1
                                                (TTL-BIDIRECT-PADS-BODY M N PI)
                                                BINDINGS STATE-BINDINGS
                                                NETLIST)
                       STATE-BINDINGS NETLIST)))

(DEFN TTL-BIDIRECT-PADS*
 (N)
 (CONS
  (INDEX 'TTL-BIDIRECT-PADS N)
  (CONS
       (CONS 'ENABLE
             (CONS 'PI
                   (APPEND (INDICES 'DATA 0 N)
                           (INDICES 'IN 0 N))))
       (CONS (CONS (INDEX 'PO (SUB1 N))
                   (APPEND (INDICES 'DATA 0 N)
                           (INDICES 'OUT 0 N)))
             (CONS (CONS (CONS 'ENABLE-BUF
                               (CONS '(BUF-ENABLE)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((ENABLE)))))
                         (TTL-BIDIRECT-PADS-BODY 0 N 'PI))
                   '(NIL))))))

(PROVE-LEMMA TTL-BIDIRECT-PADS*$DESTRUCTURE
       (REWRITE)
       (AND (EQUAL (CAR (TTL-BIDIRECT-PADS* N))
                   (INDEX 'TTL-BIDIRECT-PADS N))
            (EQUAL (CADR (TTL-BIDIRECT-PADS* N))
                   (CONS 'ENABLE
                         (CONS 'PI
                               (APPEND (INDICES 'DATA 0 N)
                                       (INDICES 'IN 0 N)))))
            (EQUAL (CADDR (TTL-BIDIRECT-PADS* N))
                   (CONS (INDEX 'PO (SUB1 N))
                         (APPEND (INDICES 'DATA 0 N)
                                 (INDICES 'OUT 0 N))))
            (EQUAL (CADDDR (TTL-BIDIRECT-PADS* N))
                   (CONS (CONS 'ENABLE-BUF
                               (CONS '(BUF-ENABLE)
                                     (CONS (IF (LESSP N 8) 'B-BUF 'B-BUF-PWR)
                                           '((ENABLE)))))
                         (TTL-BIDIRECT-PADS-BODY 0 N 'PI)))
            (EQUAL (CADDDDR (TTL-BIDIRECT-PADS* N))
                   NIL)))

(TOGGLE TTL-BIDIRECT-PADS*-OFF TTL-BIDIRECT-PADS* T)

(TOGGLE TTL-BIDIRECT-PADS*$DESTRUCTURE-OFF TTL-BIDIRECT-PADS*$DESTRUCTURE T)

(DEFN TTL-BIDIRECT-PADS&
      (NETLIST N)
      (AND (EQUAL (LOOKUP-MODULE (INDEX 'TTL-BIDIRECT-PADS N)
                                 NETLIST)
                  (TTL-BIDIRECT-PADS* N))
           (TTL-BIDIRECT& (DELETE-MODULE (INDEX 'TTL-BIDIRECT-PADS N)
                                         NETLIST))
           (IF (LESSP N 8)
               (B-BUF& (DELETE-MODULE (INDEX 'TTL-BIDIRECT-PADS N)
                                      NETLIST))
               (B-BUF-PWR& (DELETE-MODULE (INDEX 'TTL-BIDIRECT-PADS N)
                                          NETLIST)))))

(TOGGLE TTL-BIDIRECT-PADS&-OFF TTL-BIDIRECT-PADS& T)

(DEFN TTL-BIDIRECT-PADS$NETLIST
      (N)
      (CONS (TTL-BIDIRECT-PADS* N)
            (UNION (TTL-BIDIRECT$NETLIST)
                   (IF (LESSP N 8)
                       (B-BUF$NETLIST)
                       (B-BUF-PWR$NETLIST)))))

(PROVE-LEMMA TTL-BIDIRECT-PADS-BODY$UNBOUND-IN-BODY
             (REWRITE)
             (IMPLIES (LESSP L M)
                      (AND (UNBOUND-IN-BODY (INDEX 'DATA L)
                                            (TTL-BIDIRECT-PADS-BODY M N PI))
                           (UNBOUND-IN-BODY (INDEX 'OUT L)
                                            (TTL-BIDIRECT-PADS-BODY M N PI))
                           (UNBOUND-IN-BODY (INDEX 'PO L)
                                            (TTL-BIDIRECT-PADS-BODY M N PI))
                           (UNBOUND-IN-BODY (INDEX 'IN L)
                                            (TTL-BIDIRECT-PADS-BODY M N PI))))
             ((ENABLE UNBOUND-IN-BODY TTL-BIDIRECT-PADS-BODY)))

(TOGGLE TTL-BIDIRECT-PADS-BODY$UNBOUND-IN-BODY-OFF
        TTL-BIDIRECT-PADS-BODY$UNBOUND-IN-BODY T)

(PROVE-LEMMA TTL-BIDIRECT-PADS-BODY$VALUE
 (REWRITE)
 (IMPLIES
  (TTL-BIDIRECT& NETLIST)
  (AND
   (EQUAL (COLLECT-VALUE (INDICES 'DATA M N)
                         (DUAL-EVAL 1
                                    (TTL-BIDIRECT-PADS-BODY M N PI)
                                    BINDINGS STATE-BINDINGS NETLIST))
          (COND ((EQUAL (VALUE 'BUF-ENABLE BINDINGS)
                        F)
                 (V-THREEFIX (COLLECT-VALUE (INDICES 'IN M N)
                                            BINDINGS)))
                ((EQUAL (VALUE 'BUF-ENABLE BINDINGS)
                        T)
                 (MAKE-LIST N (Z)))
                (T (MAKE-LIST N (X)))))
   (EQUAL
       (COLLECT-VALUE (INDICES 'OUT M N)
                      (DUAL-EVAL 1
                                 (TTL-BIDIRECT-PADS-BODY M N PI)
                                 BINDINGS STATE-BINDINGS NETLIST))
       (COND ((EQUAL (VALUE 'BUF-ENABLE BINDINGS)
                     F)
              (V-THREEFIX (V-WIRE (COLLECT-VALUE (INDICES 'DATA M N)
                                                 BINDINGS)
                                  (V-THREEFIX (COLLECT-VALUE (INDICES 'IN M N)
                                                             BINDINGS)))))
             ((EQUAL (VALUE 'BUF-ENABLE BINDINGS)
                     T)
              (V-THREEFIX (COLLECT-VALUE (INDICES 'DATA M N)
                                         BINDINGS)))
             (T (MAKE-LIST N (X)))))))
 ((ENABLE TTL-BIDIRECT-PADS-BODY TTL-BIDIRECT-PADS-BODY$UNBOUND-IN-BODY
          V-THREEFIX V-WIRE TTL-BIDIRECT$VALUE MAKE-LIST F-BUF F-NOT
          THREEFIX=X FT-BUF-REWRITE FT-WIRE-REWRITE)
  (DISABLE-THEORY F-GATES)
  (DISABLE THREEFIX)
  (INDUCT (TTL-BIDIRECT-PADS-BODY$INDUCTION M N PI BINDINGS STATE-BINDINGS
                                            NETLIST))))

(TOGGLE TTL-BIDIRECT-PADS-BODY$VALUE-OFF TTL-BIDIRECT-PADS-BODY$VALUE T)

(PROVE-LEMMA TTL-BIDIRECT-PADS$VALUE
 (REWRITE)
 (IMPLIES
        (AND (TTL-BIDIRECT-PADS& NETLIST N)
             (EQUAL (LENGTH DATA) N)
             (PROPERP DATA)
             (EQUAL (LENGTH INPUTS) N)
             (PROPERP INPUTS))
        (EQUAL (CDR (DUAL-EVAL 0
                               (INDEX 'TTL-BIDIRECT-PADS N)
                               (CONS ENABLE
                                     (CONS PI (APPEND DATA INPUTS)))
                               STATE-BINDINGS NETLIST))
               (APPEND (VFT-BUF (F-NOT ENABLE) INPUTS)
                       (V-THREEFIX (V-WIRE DATA
                                           (VFT-BUF (F-NOT ENABLE) INPUTS))))))
 ((ENABLE TTL-BIDIRECT-PADS& TTL-BIDIRECT-PADS-BODY$VALUE
          TTL-BIDIRECT-PADS*$DESTRUCTURE B-BUF-PWR$VALUE B-BUF$VALUE
          VFT-BUF-REWRITE)
  (DISABLE V-THREEFIX OPEN-INDICES APPEND-V-THREEFIX)))

(TOGGLE TTL-BIDIRECT-PADS$VALUE-OFF TTL-BIDIRECT-PADS$VALUE T)

(DEFN A-REG (STATE) (NTH 2 STATE))

(DEFN B-REG (STATE) (NTH 3 STATE))

(DEFN I-REG (STATE) (NTH 4 STATE))

(DEFN DATA-OUT (STATE) (NTH 5 STATE))

(DEFN ADDR-OUT (STATE) (NTH 6 STATE))

(DEFN RESET- (STATE) (NTH 7 STATE))

(DEFN DTACK- (STATE) (NTH 8 STATE))

(DEFN HOLD- (STATE) (NTH 9 STATE))

(DEFN PC-REG (STATE) (NTH 10 STATE))

(DEFN CNTL-STATE
      (STATE)
      (NTH 11 STATE))

(TOGGLE A-REG-OFF A-REG T)

(TOGGLE B-REG-OFF B-REG T)

(TOGGLE I-REG-OFF I-REG T)

(TOGGLE DATA-OUT-OFF DATA-OUT T)

(TOGGLE ADDR-OUT-OFF ADDR-OUT T)

(TOGGLE RESET--OFF RESET- T)

(TOGGLE DTACK--OFF DTACK- T)

(TOGGLE HOLD--OFF HOLD- T)

(TOGGLE PC-REG-OFF PC-REG T)

(TOGGLE CNTL-STATE-OFF CNTL-STATE T)

(DEFTHEORY FM9001-HARDWARE-STATE-ACCESSORS
           (REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT RESET- DTACK- HOLD-
                 PC-REG CNTL-STATE))

(DEFN RESET--INPUT
      (EXT-IN)
      (NTH 0 EXT-IN))

(DEFN HOLD--INPUT
      (EXT-IN)
      (NTH 1 EXT-IN))

(DEFN PC-REG-INPUT
      (EXT-IN)
      (SUBRANGE EXT-IN 2 5))

(TOGGLE RESET--INPUT-OFF RESET--INPUT T)

(TOGGLE HOLD--INPUT-OFF HOLD--INPUT T)

(TOGGLE PC-REG-INPUT-OFF PC-REG-INPUT T)

(DEFTHEORY FM9001-EXTERNAL-INPUT-ACCESSORS
           (RESET--INPUT HOLD--INPUT PC-REG-INPUT))

(DEFN FM9001-NEXT-STATE
 (TOTAL-STATE EXTERNAL-INPUTS)
 (LIST
  (LIST
   (F$WRITE-REGS
         (WE-REGS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
         (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
         (REGS (CAR TOTAL-STATE))
         (BV (F$CORE-ALU (ALU-C (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (V-THREEFIX (A-REG (CAR TOTAL-STATE)))
                         (V-THREEFIX (B-REG (CAR TOTAL-STATE)))
                         (ALU-ZERO (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-MPG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-OP (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (MAKE-TREE 32))))
   (F$UPDATE-FLAGS
             (FLAGS (CAR TOTAL-STATE))
             (WE-FLAGS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
             (F$CORE-ALU (ALU-C (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (V-THREEFIX (A-REG (CAR TOTAL-STATE)))
                         (V-THREEFIX (B-REG (CAR TOTAL-STATE)))
                         (ALU-ZERO (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-MPG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-OP (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (MAKE-TREE 32)))
   (FV-IF
    (WE-A-REG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
    (FV-IF
     (F-NAND (DATA-IN-SELECT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
             (F-NOT (DTACK- (CAR TOTAL-STATE))))
     (F$EXTEND-IMMEDIATE
        (SELECT-IMMEDIATE (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
        (A-IMMEDIATE (V-THREEFIX (I-REG (CAR TOTAL-STATE))))
        (F$READ-REGS (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                     (REGS (CAR TOTAL-STATE))))
     (V-THREEFIX
      (V-WIRE
       (V-PULLUP
        (V-WIRE
         (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE))))
         (CDR
          (MEMORY-VALUE
           (CADR TOTAL-STATE)
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
           (V-PULLUP
            (VFT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
           (MAKE-LIST 32 (X))))))
       (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE)))))))
    (A-REG (CAR TOTAL-STATE)))
   (FV-IF
    (WE-B-REG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
    (FV-IF
     (F-NAND (DATA-IN-SELECT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
             (F-NOT (DTACK- (CAR TOTAL-STATE))))
     (F$EXTEND-IMMEDIATE
        (SELECT-IMMEDIATE (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
        (A-IMMEDIATE (V-THREEFIX (I-REG (CAR TOTAL-STATE))))
        (F$READ-REGS (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                     (REGS (CAR TOTAL-STATE))))
     (V-THREEFIX
      (V-WIRE
       (V-PULLUP
        (V-WIRE
         (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE))))
         (CDR
          (MEMORY-VALUE
           (CADR TOTAL-STATE)
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
           (V-PULLUP
            (VFT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
           (MAKE-LIST 32 (X))))))
       (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE)))))))
    (B-REG (CAR TOTAL-STATE)))
   (FV-IF
    (WE-I-REG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
    (FV-IF
     (F-NAND (DATA-IN-SELECT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
             (F-NOT (DTACK- (CAR TOTAL-STATE))))
     (F$EXTEND-IMMEDIATE
        (SELECT-IMMEDIATE (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
        (A-IMMEDIATE (V-THREEFIX (I-REG (CAR TOTAL-STATE))))
        (F$READ-REGS (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                     (REGS (CAR TOTAL-STATE))))
     (V-THREEFIX
      (V-WIRE
       (V-PULLUP
        (V-WIRE
         (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE))))
         (CDR
          (MEMORY-VALUE
           (CADR TOTAL-STATE)
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
           (F-PULLUP
            (FT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
           (V-PULLUP
            (VFT-BUF
                   (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
           (MAKE-LIST 32 (X))))))
       (VFT-BUF
              (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE)))))))
    (I-REG (CAR TOTAL-STATE)))
   (FV-IF
         (WE-DATA-OUT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
         (BV (F$CORE-ALU (ALU-C (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (V-THREEFIX (A-REG (CAR TOTAL-STATE)))
                         (V-THREEFIX (B-REG (CAR TOTAL-STATE)))
                         (ALU-ZERO (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-MPG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (ALU-OP (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                         (MAKE-TREE 32)))
         (DATA-OUT (CAR TOTAL-STATE)))
   (FV-IF
    (WE-ADDR-OUT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
    (F$DEC-PASS
     (DEC-ADDR-OUT (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
     (F$EXTEND-IMMEDIATE
        (SELECT-IMMEDIATE (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
        (A-IMMEDIATE (V-THREEFIX (I-REG (CAR TOTAL-STATE))))
        (F$READ-REGS (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                     (REGS (CAR TOTAL-STATE)))))
    (ADDR-OUT (CAR TOTAL-STATE)))
   (F-BUF (RESET--INPUT EXTERNAL-INPUTS))
   (F-OR
    (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
    (F-BUF
     (CAR
      (MEMORY-VALUE
       (CADR TOTAL-STATE)
       (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
       (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
       (V-PULLUP
          (VFT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
       (MAKE-LIST 32 (X))))))
   (F-IF (WE-HOLD- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
         (F-BUF (HOLD--INPUT EXTERNAL-INPUTS))
         (HOLD- (CAR TOTAL-STATE)))
   (FV-IF (WE-PC-REG (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
          (PC-REG-INPUT EXTERNAL-INPUTS)
          (PC-REG (CAR TOTAL-STATE)))
   (V-THREEFIX
    (F$NEXT-CNTL-STATE
                  (F-BUF (RESET- (CAR TOTAL-STATE)))
                  (F-BUF (DTACK- (CAR TOTAL-STATE)))
                  (F-BUF (HOLD- (CAR TOTAL-STATE)))
                  (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                  (STATE (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))
                  (V-THREEFIX (I-REG (CAR TOTAL-STATE)))
                  (V-THREEFIX (FLAGS (CAR TOTAL-STATE)))
                  (V-THREEFIX (PC-REG (CAR TOTAL-STATE)))
                  (REGS-ADDRESS (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
  (NEXT-MEMORY-STATE
   (CADR TOTAL-STATE)
   (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
   (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
   (V-PULLUP
          (VFT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
   (V-PULLUP
    (V-WIRE
     (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
              (V-THREEFIX (DATA-OUT (CAR TOTAL-STATE))))
     (CDR
      (MEMORY-VALUE
       (CADR TOTAL-STATE)
       (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (STROBE- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE))))))
       (F-PULLUP
           (FT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (F-BUF (RW- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))))
       (V-PULLUP
          (VFT-BUF (F-BUF (HDACK- (V-THREEFIX (CNTL-STATE (CAR TOTAL-STATE)))))
                   (V-THREEFIX (ADDR-OUT (CAR TOTAL-STATE)))))
       (MAKE-LIST 32 (X)))))))))

(TOGGLE FM9001-NEXT-STATE-OFF FM9001-NEXT-STATE T)

(DEFN RUN-FM9001
      (STATE INPUTS N)
      (IF (ZEROP N)
          STATE
          (RUN-FM9001 (FM9001-NEXT-STATE STATE (CAR INPUTS))
                      (CDR INPUTS)
                      (SUB1 N))))

(TOGGLE RUN-FM9001-OFF RUN-FM9001 T)

(PROVE-LEMMA RUN-FM9001-BASE-CASE
             (REWRITE)
             (IMPLIES (ZEROP N)
                      (EQUAL (RUN-FM9001 STATE INPUTS N)
                             STATE))
             ((ENABLE RUN-FM9001)))

(PROVE-LEMMA RUN-FM9001-STEP-CASE
             (REWRITE)
             (IMPLIES (NOT (ZEROP N))
                      (EQUAL (RUN-FM9001 STATE INPUTS N)
                             (RUN-FM9001 (FM9001-NEXT-STATE STATE (CAR INPUTS))
                                         (CDR INPUTS)
                                         (SUB1 N))))
             ((ENABLE RUN-FM9001)))

(TOGGLE RUN-FM9001-STEP-CASE-OFF RUN-FM9001-STEP-CASE T)

(PROVE-LEMMA RUN-FM9001-PLUS
             (REWRITE)
             (EQUAL (RUN-FM9001 STATE INPUTS (PLUS N M))
                    (RUN-FM9001 (RUN-FM9001 STATE INPUTS N)
                                (NTHCDR N INPUTS)
                                M))
             ((ENABLE RUN-FM9001 NTHCDR PLUS)))

(DEFN FM9001-STATE-STRUCTURE
      (STATE)
      (AND (EQUAL (LENGTH STATE) 2)
           (PROPERP STATE)
           (EQUAL (LENGTH (CAR STATE)) 12)
           (PROPERP (CAR STATE))
           (EQUAL (LENGTH (CADR STATE)) 8)
           (PROPERP (CADR STATE))
           (EQUAL (LENGTH (CAAR STATE)) 4)
           (PROPERP (CAAR STATE))))

(PROVE-LEMMA FM9001-STATE-STRUCTURE$STEP
         (REWRITE)
         (IMPLIES (FM9001-STATE-STRUCTURE STATE)
                  (FM9001-STATE-STRUCTURE (FM9001-NEXT-STATE STATE
                                                             EXTERNAL-INPUTS)))
         ((ENABLE FM9001-NEXT-STATE)
          (DISABLE-THEORY F-GATES)
          (DISABLE MAKE-LIST *1*MAKE-LIST *1*MAKE-TREE)))

(PROVE-LEMMA FM9001-STATE-STRUCTURE$INDUCTION
             (REWRITE)
             (IMPLIES (FM9001-STATE-STRUCTURE STATE)
                      (FM9001-STATE-STRUCTURE (RUN-FM9001 STATE INPUTS STEPS)))
             ((ENABLE RUN-FM9001)))

(PROVE-LEMMA FM9001-STATE-AS-A-LIST NIL
             (IMPLIES (FM9001-STATE-STRUCTURE STATE)
                      (EQUAL STATE
                             (LIST (LIST (LIST (CAAAR STATE)
                                               (CADAAR STATE)
                                               (CADDAAR STATE)
                                               (CADDDAAR STATE))
                                         (CADAR STATE)
                                         (CADDAR STATE)
                                         (CADDDAR STATE)
                                         (CADDDDAR STATE)
                                         (CADDDDDAR STATE)
                                         (CADDDDDDAR STATE)
                                         (CADDDDDDDAR STATE)
                                         (CADDDDDDDDAR STATE)
                                         (CADDDDDDDDDAR STATE)
                                         (CADDDDDDDDDDAR STATE)
                                         (CADDDDDDDDDDDAR STATE))
                                   (LIST (CAADR STATE)
                                         (CADADR STATE)
                                         (CADDADR STATE)
                                         (CADDDADR STATE)
                                         (CADDDDADR STATE)
                                         (CADDDDDADR STATE)
                                         (CADDDDDDADR STATE)
                                         (CADDDDDDDADR STATE)))))
             ((ENABLE EQUAL-LENGTH-ADD1 PROPERP)))

(DEFN CHIP-MODULE* NIL
 (CONS 'CHIP-MODULE
  (CONS
   (CONS 'CLK
    (CONS 'TI
     (CONS 'TE
        (CONS 'DTACK-
              (CONS 'RESET-
                    (CONS 'HOLD-
                          (CONS 'DISABLE-REGFILE-
                                (CONS 'TEST-REGFILE-
                                      (APPEND (INDICES 'PC-REG-IN 0 4)
                                              (INDICES 'DATA-IN 0 32))))))))))
   (CONS
    (CONS 'TO
     (CONS 'TIMING
      (CONS 'HDACK-
       (CONS 'EN-ADDR-OUT-
        (CONS 'RW-
         (CONS 'STROBE-
               (APPEND (INDICES 'ADDR-OUT 0 32)
                       (APPEND (INDICES 'DATA-OUT 0 32)
                               (APPEND (INDICES 'FLAGS 0 4)
                                       (APPEND (INDICES 'CNTL-STATE 0 5)
                                               (SUBRANGE (INDICES 'I-REG 0 32)
                                                         28 31)))))))))))
    (CONS
     (LIST
      (LIST 'CNTL-STATE
       (CONS 'RW-SIG-
        (CONS 'STROBE-
         (CONS 'HDACK-
          (CONS 'WE-REGS
           (CONS 'WE-A-REG
            (CONS 'WE-B-REG
             (CONS 'WE-I-REG
              (CONS 'WE-DATA-OUT
               (CONS 'WE-ADDR-OUT
                (CONS 'WE-HOLD-
                 (CONS 'WE-PC-REG
                  (CONS 'DATA-IN-SELECT
                   (CONS 'DEC-ADDR-OUT
                    (CONS 'SELECT-IMMEDIATE
                     (CONS 'ALU-C
                      (CONS 'ALU-ZERO
                       (APPEND
                        (INDICES 'CNTL-STATE 0 5)
                        (APPEND (INDICES 'WE-FLAGS 0 4)
                                (APPEND (INDICES 'REGS-ADDRESS 0 4)
                                        (APPEND (INDICES 'ALU-OP 0 4)
                                                (INDICES 'ALU-MPG
                                                         0
                                                         7)))))))))))))))))))))
       (INDEX 'REG 40)
       (CONS 'CLK
             (CONS 'TE-SIG
                   (CONS 'TI
                         (INDICES 'NEXT-STATE 0 40)))))
      (LIST 'REGS
       (CONS 'REGFILE-TO
             (INDICES 'REGFILE-OUT 0 32))
       'REGFILE
       (CONS 'CLK
        (CONS 'TE-SIG
          (CONS (INDEX 'ALU-MPG 6)
                (CONS 'WE-REGS
                      (CONS 'DISABLE-REGFILE-
                            (CONS 'TEST-REGFILE-
                                  (APPEND (INDICES 'REGS-ADDRESS 0 4)
                                          (BV (INDICES 'ALU-BUS 0 35))))))))))
      (LIST 'CVNZ-FLAGS
            (INDICES 'FLAGS 0 4)
            'FLAGS
            (CONS 'CLK
                  (CONS 'TE-SIG
                        (CONS 'REGFILE-TO
                              (APPEND (INDICES 'WE-FLAGS 0 4)
                                      (INDICES 'ALU-BUS 0 35))))))
      (LIST 'A-REG
            (INDICES 'A-REG 0 32)
            (INDEX 'WE-REG 32)
            (CONS 'CLK
                  (CONS 'WE-A-REG
                        (CONS 'TE-SIG
                              (CONS (INDEX 'FLAGS 3)
                                    (INDICES 'ABI-BUS 0 32))))))
      (LIST 'B-REG
            (INDICES 'B-REG 0 32)
            (INDEX 'WE-REG 32)
            (CONS 'CLK
                  (CONS 'WE-B-REG
                        (CONS 'TE-SIG
                              (CONS (INDEX 'A-REG 31)
                                    (INDICES 'ABI-BUS 0 32))))))
      (LIST 'I-REG
            (INDICES 'I-REG 0 32)
            (INDEX 'WE-REG 32)
            (CONS 'CLK
                  (CONS 'WE-I-REG
                        (CONS 'TE-SIG
                              (CONS (INDEX 'B-REG 31)
                                    (INDICES 'ABI-BUS 0 32))))))
      (LIST 'DATA-OUT
            (INDICES 'DATA-OUT 0 32)
            (INDEX 'WE-REG 32)
            (CONS 'CLK
                  (CONS 'WE-DATA-OUT
                        (CONS 'TE-SIG
                              (CONS (INDEX 'I-REG 31)
                                    (BV (INDICES 'ALU-BUS 0 35)))))))
      (LIST 'ADDR-OUT
            (INDICES 'ADDR-OUT 0 32)
            (INDEX 'WE-REG 32)
            (CONS 'CLK
                  (CONS 'WE-ADDR-OUT
                        (CONS 'TE-SIG
                              (CONS (INDEX 'DATA-OUT 31)
                                    (INDICES 'ADDR-OUT-BUS 0 32))))))
      (LIST 'RESET-LATCH
            '(LAST-RESET- LAST-RESET-INV)
            'FD1S
            (LIST 'RESET-
                  'CLK
                  (INDEX 'ADDR-OUT 31)
                  'TE-SIG))
      '(DTACK--OR (DTACK--OR-STROBE-)
                  B-OR
                  (STROBE- DTACK-))
      '(DTACK-LATCH (LAST-DTACK- LAST-DTACK-INV)
                    FD1S
                    (DTACK--OR-STROBE- CLK LAST-RESET- TE-SIG))
      '(HOLD-LATCH (LAST-HOLD- LAST-HOLD-INV)
                   FD1SLP
                   (HOLD- CLK WE-HOLD- LAST-DTACK- TE-SIG))
      (LIST 'PC-REG
            (INDICES 'PC-REG 0 4)
            (INDEX 'WE-REG 4)
            (CONS 'CLK
                  (CONS 'WE-PC-REG
                        (CONS 'TE-SIG
                              (CONS 'LAST-HOLD-
                                    (INDICES 'PC-REG-IN 0 4))))))
      (LIST 'IMMEDIATE-PASS
            (INDICES 'REG-BUS 0 32)
            'EXTEND-IMMEDIATE
            (CONS 'SELECT-IMMEDIATE
                  (APPEND (A-IMMEDIATE (INDICES 'I-REG 0 32))
                          (INDICES 'REGFILE-OUT 0 32))))
      (LIST 'DEC-PASS
            (INDICES 'ADDR-OUT-BUS 0 32)
            (INDEX 'DEC-PASS 32)
            (CONS 'DEC-ADDR-OUT
                  (INDICES 'REG-BUS 0 32)))
      '(MUX-CNTL (ABI-CNTL)
                 B-NAND
                 (DATA-IN-SELECT LAST-DTACK-INV))
      (LIST 'DATA-IN-MUX
            (INDICES 'ABI-BUS 0 32)
            (INDEX 'TV-IF
                   (TREE-NUMBER (MAKE-TREE 32)))
            (CONS 'ABI-CNTL
                  (APPEND (INDICES 'REG-BUS 0 32)
                          (INDICES 'DATA-IN 0 32))))
      (LIST 'ALU
            (INDICES 'ALU-BUS 0 35)
            (INDEX 'CORE-ALU
                   (TREE-NUMBER (MAKE-TREE 32)))
            (CONS 'ALU-C
                  (APPEND (INDICES 'A-REG 0 32)
                          (APPEND (INDICES 'B-REG 0 32)
                                  (CONS 'ALU-ZERO
                                        (APPEND (INDICES 'ALU-MPG 0 7)
                                                (INDICES 'ALU-OP 0 4)))))))
      (LIST 'NEXT-STATE
       (INDICES 'NEXT-STATE 0 40)
       'NEXT-CNTL-STATE
       (CONS 'LAST-RESET-
        (CONS 'LAST-DTACK-
         (CONS 'LAST-HOLD-
          (CONS 'RW-SIG-
           (APPEND
                  (INDICES 'CNTL-STATE 0 5)
                  (APPEND (INDICES 'I-REG 0 32)
                          (APPEND (INDICES 'FLAGS 0 4)
                                  (APPEND (INDICES 'PC-REG 0 4)
                                          (INDICES 'REGS-ADDRESS 0 4))))))))))
      '(TE-BUFFER (TE-SIG) B-BUF-PWR (TE))
      '(RW-BUFFER (RW-) B-BUF (RW-SIG-))
      '(EN-ADDR-OUT-GATE (EN-ADDR-OUT-)
                         B-NOT
                         (HDACK-))
      (LIST 'TIMING-GATE
            '(TIMING)
            'ID
            (LIST (INDEX 'ALU-BUS 2)))
      (LIST 'SCANOUT
            '(TO)
            'ID
            (LIST (INDEX 'PC-REG 3))))
     '((REGS CVNZ-FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT RESET-LATCH
             DTACK-LATCH HOLD-LATCH PC-REG CNTL-STATE)))))))

(PROVE-LEMMA CHIP-MODULE*$DESTRUCTURE
 (REWRITE)
 (AND
  (EQUAL (CAR (CHIP-MODULE*))
         'CHIP-MODULE)
  (EQUAL
   (CADR (CHIP-MODULE*))
   (CONS 'CLK
    (CONS 'TI
     (CONS 'TE
       (CONS 'DTACK-
             (CONS 'RESET-
                   (CONS 'HOLD-
                         (CONS 'DISABLE-REGFILE-
                               (CONS 'TEST-REGFILE-
                                     (APPEND (INDICES 'PC-REG-IN 0 4)
                                             (INDICES 'DATA-IN 0 32)))))))))))
  (EQUAL
   (CADDR (CHIP-MODULE*))
   (CONS 'TO
    (CONS 'TIMING
     (CONS 'HDACK-
      (CONS 'EN-ADDR-OUT-
       (CONS 'RW-
         (CONS 'STROBE-
               (APPEND (INDICES 'ADDR-OUT 0 32)
                       (APPEND (INDICES 'DATA-OUT 0 32)
                               (APPEND (INDICES 'FLAGS 0 4)
                                       (APPEND (INDICES 'CNTL-STATE 0 5)
                                               (SUBRANGE (INDICES 'I-REG 0 32)
                                                         28 31))))))))))))
  (EQUAL
   (CADDDR (CHIP-MODULE*))
   (LIST
    (LIST 'CNTL-STATE
     (CONS 'RW-SIG-
      (CONS 'STROBE-
       (CONS 'HDACK-
        (CONS 'WE-REGS
         (CONS 'WE-A-REG
          (CONS 'WE-B-REG
           (CONS 'WE-I-REG
            (CONS 'WE-DATA-OUT
             (CONS 'WE-ADDR-OUT
              (CONS 'WE-HOLD-
               (CONS 'WE-PC-REG
                (CONS 'DATA-IN-SELECT
                 (CONS 'DEC-ADDR-OUT
                  (CONS 'SELECT-IMMEDIATE
                   (CONS 'ALU-C
                    (CONS 'ALU-ZERO
                     (APPEND
                        (INDICES 'CNTL-STATE 0 5)
                        (APPEND (INDICES 'WE-FLAGS 0 4)
                                (APPEND (INDICES 'REGS-ADDRESS 0 4)
                                        (APPEND (INDICES 'ALU-OP 0 4)
                                                (INDICES 'ALU-MPG
                                                         0
                                                         7)))))))))))))))))))))
     (INDEX 'REG 40)
     (CONS 'CLK
           (CONS 'TE-SIG
                 (CONS 'TI
                       (INDICES 'NEXT-STATE 0 40)))))
    (LIST 'REGS
     (CONS 'REGFILE-TO
           (INDICES 'REGFILE-OUT 0 32))
     'REGFILE
     (CONS 'CLK
      (CONS 'TE-SIG
          (CONS (INDEX 'ALU-MPG 6)
                (CONS 'WE-REGS
                      (CONS 'DISABLE-REGFILE-
                            (CONS 'TEST-REGFILE-
                                  (APPEND (INDICES 'REGS-ADDRESS 0 4)
                                          (BV (INDICES 'ALU-BUS 0 35))))))))))
    (LIST 'CVNZ-FLAGS
          (INDICES 'FLAGS 0 4)
          'FLAGS
          (CONS 'CLK
                (CONS 'TE-SIG
                      (CONS 'REGFILE-TO
                            (APPEND (INDICES 'WE-FLAGS 0 4)
                                    (INDICES 'ALU-BUS 0 35))))))
    (LIST 'A-REG
          (INDICES 'A-REG 0 32)
          (INDEX 'WE-REG 32)
          (CONS 'CLK
                (CONS 'WE-A-REG
                      (CONS 'TE-SIG
                            (CONS (INDEX 'FLAGS 3)
                                  (INDICES 'ABI-BUS 0 32))))))
    (LIST 'B-REG
          (INDICES 'B-REG 0 32)
          (INDEX 'WE-REG 32)
          (CONS 'CLK
                (CONS 'WE-B-REG
                      (CONS 'TE-SIG
                            (CONS (INDEX 'A-REG 31)
                                  (INDICES 'ABI-BUS 0 32))))))
    (LIST 'I-REG
          (INDICES 'I-REG 0 32)
          (INDEX 'WE-REG 32)
          (CONS 'CLK
                (CONS 'WE-I-REG
                      (CONS 'TE-SIG
                            (CONS (INDEX 'B-REG 31)
                                  (INDICES 'ABI-BUS 0 32))))))
    (LIST 'DATA-OUT
          (INDICES 'DATA-OUT 0 32)
          (INDEX 'WE-REG 32)
          (CONS 'CLK
                (CONS 'WE-DATA-OUT
                      (CONS 'TE-SIG
                            (CONS (INDEX 'I-REG 31)
                                  (BV (INDICES 'ALU-BUS 0 35)))))))
    (LIST 'ADDR-OUT
          (INDICES 'ADDR-OUT 0 32)
          (INDEX 'WE-REG 32)
          (CONS 'CLK
                (CONS 'WE-ADDR-OUT
                      (CONS 'TE-SIG
                            (CONS (INDEX 'DATA-OUT 31)
                                  (INDICES 'ADDR-OUT-BUS 0 32))))))
    (LIST 'RESET-LATCH
          '(LAST-RESET- LAST-RESET-INV)
          'FD1S
          (LIST 'RESET-
                'CLK
                (INDEX 'ADDR-OUT 31)
                'TE-SIG))
    '(DTACK--OR (DTACK--OR-STROBE-)
                B-OR
                (STROBE- DTACK-))
    '(DTACK-LATCH (LAST-DTACK- LAST-DTACK-INV)
                  FD1S
                  (DTACK--OR-STROBE- CLK LAST-RESET- TE-SIG))
    '(HOLD-LATCH (LAST-HOLD- LAST-HOLD-INV)
                 FD1SLP
                 (HOLD- CLK WE-HOLD- LAST-DTACK- TE-SIG))
    (LIST 'PC-REG
          (INDICES 'PC-REG 0 4)
          (INDEX 'WE-REG 4)
          (CONS 'CLK
                (CONS 'WE-PC-REG
                      (CONS 'TE-SIG
                            (CONS 'LAST-HOLD-
                                  (INDICES 'PC-REG-IN 0 4))))))
    (LIST 'IMMEDIATE-PASS
          (INDICES 'REG-BUS 0 32)
          'EXTEND-IMMEDIATE
          (CONS 'SELECT-IMMEDIATE
                (APPEND (A-IMMEDIATE (INDICES 'I-REG 0 32))
                        (INDICES 'REGFILE-OUT 0 32))))
    (LIST 'DEC-PASS
          (INDICES 'ADDR-OUT-BUS 0 32)
          (INDEX 'DEC-PASS 32)
          (CONS 'DEC-ADDR-OUT
                (INDICES 'REG-BUS 0 32)))
    '(MUX-CNTL (ABI-CNTL)
               B-NAND
               (DATA-IN-SELECT LAST-DTACK-INV))
    (LIST 'DATA-IN-MUX
          (INDICES 'ABI-BUS 0 32)
          (INDEX 'TV-IF
                 (TREE-NUMBER (MAKE-TREE 32)))
          (CONS 'ABI-CNTL
                (APPEND (INDICES 'REG-BUS 0 32)
                        (INDICES 'DATA-IN 0 32))))
    (LIST 'ALU
          (INDICES 'ALU-BUS 0 35)
          (INDEX 'CORE-ALU
                 (TREE-NUMBER (MAKE-TREE 32)))
          (CONS 'ALU-C
                (APPEND (INDICES 'A-REG 0 32)
                        (APPEND (INDICES 'B-REG 0 32)
                                (CONS 'ALU-ZERO
                                      (APPEND (INDICES 'ALU-MPG 0 7)
                                              (INDICES 'ALU-OP 0 4)))))))
    (LIST 'NEXT-STATE
     (INDICES 'NEXT-STATE 0 40)
     'NEXT-CNTL-STATE
     (CONS 'LAST-RESET-
      (CONS 'LAST-DTACK-
       (CONS 'LAST-HOLD-
        (CONS 'RW-SIG-
          (APPEND (INDICES 'CNTL-STATE 0 5)
                  (APPEND (INDICES 'I-REG 0 32)
                          (APPEND (INDICES 'FLAGS 0 4)
                                  (APPEND (INDICES 'PC-REG 0 4)
                                          (INDICES 'REGS-ADDRESS 0 4))))))))))
    '(TE-BUFFER (TE-SIG) B-BUF-PWR (TE))
    '(RW-BUFFER (RW-) B-BUF (RW-SIG-))
    '(EN-ADDR-OUT-GATE (EN-ADDR-OUT-)
                       B-NOT
                       (HDACK-))
    (LIST 'TIMING-GATE
          '(TIMING)
          'ID
          (LIST (INDEX 'ALU-BUS 2)))
    (LIST 'SCANOUT
          '(TO)
          'ID
          (LIST (INDEX 'PC-REG 3)))))
  (EQUAL (CADDDDR (CHIP-MODULE*))
         '(REGS CVNZ-FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT RESET-LATCH
                DTACK-LATCH HOLD-LATCH PC-REG CNTL-STATE))))

(TOGGLE CHIP-MODULE*-OFF CHIP-MODULE* T)

(TOGGLE CHIP-MODULE*$DESTRUCTURE-OFF CHIP-MODULE*$DESTRUCTURE T)

(TOGGLE G*1*CHIP-MODULE*-OFF *1*CHIP-MODULE* T)

(DEFN CHIP-MODULE&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CHIP-MODULE NETLIST)
                  (CHIP-MODULE*))
           (REGFILE& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (FLAGS& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (WE-REG& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                    32)
           (FD1S& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (FD1SLP& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (WE-REG& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                    4)
           (REG& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                 40)
           (ID& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (B-BUF-PWR& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (B-BUF& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (B-NOT& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (EXTEND-IMMEDIATE& (DELETE-MODULE 'CHIP-MODULE NETLIST))
           (DEC-PASS& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                      32)
           (TV-IF& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                   (MAKE-TREE 32))
           (CORE-ALU& (DELETE-MODULE 'CHIP-MODULE NETLIST)
                      (MAKE-TREE 32))
           (NEXT-CNTL-STATE& (DELETE-MODULE 'CHIP-MODULE
                                            NETLIST))))

(TOGGLE CHIP-MODULE&-OFF CHIP-MODULE& T)

(DEFN CHIP-MODULE$NETLIST NIL
 (CONS
    (CHIP-MODULE*)
    (UNION (REGFILE$NETLIST)
           (UNION (UNION (UNION (UNION (FLAGS$NETLIST)
                                       (WE-REG$NETLIST 32))
                                (UNION (FD1S$NETLIST)
                                       (FD1SLP$NETLIST)))
                         (UNION (UNION (UNION (WE-REG$NETLIST 4)
                                              (REG$NETLIST 40))
                                       (UNION (ID$NETLIST)
                                              (EXTEND-IMMEDIATE$NETLIST)))
                                (UNION (UNION (DEC-PASS$NETLIST 32)
                                              (TV-IF$NETLIST (MAKE-TREE 32)))
                                       (UNION (CORE-ALU$NETLIST (MAKE-TREE 32))
                                              (NEXT-CNTL-STATE$NETLIST)))))
                  (UNION (B-BUF-PWR$NETLIST)
                         (UNION (B-BUF$NETLIST)
                                (B-NOT$NETLIST)))))))

(PROVE-LEMMA EQUAL-LENGTH-40-AS-COLLECTED-NTH+SUBRANGE NIL
             (IMPLIES (AND (EQUAL (LENGTH L) 40)
                           (PROPERP L))
                      (EQUAL L
                             (APPEND (LIST-AS-COLLECTED-NTH L 16 0)
                                     (SUBRANGE L 16 39))))
             ((ENABLE OPEN-NTH PROPERP-AS-NULL-NTHCDR OUR-CAR-CDR-ELIM
                      OPEN-SUBRANGE)
              (DISABLE CAR-CDR-ELIM)))

(PROVE-LEMMA LIST-AS-CNTL-STATE-CROCK NIL
 (IMPLIES
  (AND (PROPERP LIST)
       (EQUAL (LENGTH LIST) 40))
  (EQUAL LIST
   (CONS
    (RW- LIST)
    (CONS
     (STROBE- LIST)
     (CONS
      (HDACK- LIST)
      (CONS
       (WE-REGS LIST)
       (CONS
        (WE-A-REG LIST)
        (CONS
         (WE-B-REG LIST)
         (CONS
          (WE-I-REG LIST)
          (CONS
           (WE-DATA-OUT LIST)
           (CONS
            (WE-ADDR-OUT LIST)
            (CONS
             (WE-HOLD- LIST)
             (CONS
              (WE-PC-REG LIST)
              (CONS
               (DATA-IN-SELECT LIST)
               (CONS
                (DEC-ADDR-OUT LIST)
                (CONS
                 (SELECT-IMMEDIATE LIST)
                 (CONS
                  (ALU-C LIST)
                  (CONS
                   (ALU-ZERO LIST)
                   (APPEND
                    (STATE LIST)
                    (APPEND
                           (WE-FLAGS LIST)
                           (APPEND (REGS-ADDRESS LIST)
                                   (APPEND (ALU-OP LIST)
                                           (ALU-MPG LIST)))))))))))))))))))))))
 ((ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)
  (ENABLE OPEN-SUBRANGE)
  (USE (EQUAL-LENGTH-40-AS-COLLECTED-NTH+SUBRANGE (L LIST)))))

(PROVE-LEMMA REG-40$VALUE-AS-CNTL-STATE
 (REWRITE)
 (IMPLIES
  (AND (REG& NETLIST 40)
       (PROPERP STATE)
       (EQUAL (LENGTH STATE) 40))
  (EQUAL
   (DUAL-EVAL 0
              (INDEX 'REG 40)
              ARGS STATE NETLIST)
   (CONS
    (RW- (V-THREEFIX STATE))
    (CONS
     (STROBE- (V-THREEFIX STATE))
     (CONS
      (HDACK- (V-THREEFIX STATE))
      (CONS
       (WE-REGS (V-THREEFIX STATE))
       (CONS
        (WE-A-REG (V-THREEFIX STATE))
        (CONS
         (WE-B-REG (V-THREEFIX STATE))
         (CONS
          (WE-I-REG (V-THREEFIX STATE))
          (CONS
           (WE-DATA-OUT (V-THREEFIX STATE))
           (CONS
            (WE-ADDR-OUT (V-THREEFIX STATE))
            (CONS
             (WE-HOLD- (V-THREEFIX STATE))
             (CONS
              (WE-PC-REG (V-THREEFIX STATE))
              (CONS
               (DATA-IN-SELECT (V-THREEFIX STATE))
               (CONS
                (DEC-ADDR-OUT (V-THREEFIX STATE))
                (CONS
                 (SELECT-IMMEDIATE (V-THREEFIX STATE))
                 (CONS
                  (ALU-C (V-THREEFIX STATE))
                  (CONS
                   (ALU-ZERO (V-THREEFIX STATE))
                   (APPEND
                    (STATE (V-THREEFIX STATE))
                    (APPEND
                     (WE-FLAGS (V-THREEFIX STATE))
                     (APPEND
                      (REGS-ADDRESS (V-THREEFIX STATE))
                      (APPEND
                             (ALU-OP (V-THREEFIX STATE))
                             (ALU-MPG (V-THREEFIX STATE))))))))))))))))))))))))
 ((ENABLE REG$VALUE)
  (USE (LIST-AS-CNTL-STATE-CROCK (LIST (V-THREEFIX STATE))))))

(TOGGLE REG-40$VALUE-AS-CNTL-STATE-OFF REG-40$VALUE-AS-CNTL-STATE T)

(PROVE-LEMMA BV-AS-SUBRANGE
             (REWRITE)
             (IMPLIES (AND (IF (LESSP (LENGTH X) 3) F T)
                           (PROPERP X))
                      (EQUAL (BV X)
                             (SUBRANGE X 3 (SUB1 (LENGTH X)))))
             ((ENABLE BV SUBRANGE SUBRANGE-0)))

(TOGGLE BV-AS-SUBRANGE-OFF BV-AS-SUBRANGE T)

(DEFN MACHINE-STATE-INVARIANT
      (MACHINE-STATE)
      (AND (ALL-RAMP-MEM 4 (CAAR MACHINE-STATE))
           (MEMORY-PROPERP 4 32
                           (CAAR MACHINE-STATE))
           (PROPERP (CADDAR MACHINE-STATE))
           (EQUAL (LENGTH (CADDAR MACHINE-STATE))
                  32)
           (PROPERP (CADDDAR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDAR MACHINE-STATE))
                  4)
           (PROPERP (CADR MACHINE-STATE))
           (EQUAL (LENGTH (CADR MACHINE-STATE))
                  4)
           (PROPERP (CADDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDR MACHINE-STATE))
                  32)
           (PROPERP (CADDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDR MACHINE-STATE))
                  32)
           (PROPERP (CADDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDR MACHINE-STATE))
                  32)
           (PROPERP (CADDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDR MACHINE-STATE))
                  32)
           (PROPERP (CADDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDR MACHINE-STATE))
                  32)
           (PROPERP (CADDDDDDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDDDDDR MACHINE-STATE))
                  4)
           (PROPERP (CADDDDDDDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDDDDDDR MACHINE-STATE))
                  40)))

(PROVE-LEMMA CHIP-MODULE$STATE
 (REWRITE)
 (IMPLIES
  (AND (CHIP-MODULE& NETLIST)
       (MACHINE-STATE-INVARIANT (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                            REGS-ADDR)
                                      FLAGS A-REG B-REG I-REG DATA-OUT
                                      ADDR-OUT LAST-RESET- LAST-DTACK-
                                      LAST-HOLD- LAST-PC-REG CNTL-STATE))
       (EQUAL TE F)
       (EQUAL DISABLE-REGFILE- T)
       (EQUAL TEST-REGFILE- T)
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4)
       (PROPERP DATA-IN)
       (EQUAL (LENGTH DATA-IN) 32))
  (EQUAL
   (DUAL-EVAL 2 'CHIP-MODULE
    (CONS CLK
     (CONS TI
         (CONS TE
               (CONS DTACK-
                     (CONS RESET-
                           (CONS HOLD-
                                 (CONS DISABLE-REGFILE-
                                       (CONS TEST-REGFILE-
                                             (APPEND PC-REG-IN DATA-IN)))))))))
    (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
          FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET- LAST-DTACK-
          LAST-HOLD- LAST-PC-REG CNTL-STATE)
    NETLIST)
   (LIST
    (F$WRITE-REGS (WE-REGS (V-THREEFIX CNTL-STATE))
                  (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                  (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                  (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                  (V-THREEFIX A-REG)
                                  (V-THREEFIX B-REG)
                                  (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                  (ALU-MPG (V-THREEFIX CNTL-STATE))
                                  (ALU-OP (V-THREEFIX CNTL-STATE))
                                  (MAKE-TREE 32))))
    (F$UPDATE-FLAGS FLAGS
                    (WE-FLAGS (V-THREEFIX CNTL-STATE))
                    (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                (V-THREEFIX A-REG)
                                (V-THREEFIX B-REG)
                                (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                (ALU-MPG (V-THREEFIX CNTL-STATE))
                                (ALU-OP (V-THREEFIX CNTL-STATE))
                                (MAKE-TREE 32)))
    (FV-IF
     (WE-A-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        DATA-IN)
     A-REG)
    (FV-IF
     (WE-B-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        DATA-IN)
     B-REG)
    (FV-IF
     (WE-I-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        DATA-IN)
     I-REG)
    (FV-IF (WE-DATA-OUT (V-THREEFIX CNTL-STATE))
           (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                           (V-THREEFIX A-REG)
                           (V-THREEFIX B-REG)
                           (ALU-ZERO (V-THREEFIX CNTL-STATE))
                           (ALU-MPG (V-THREEFIX CNTL-STATE))
                           (ALU-OP (V-THREEFIX CNTL-STATE))
                           (MAKE-TREE 32)))
           DATA-OUT)
    (FV-IF
     (WE-ADDR-OUT (V-THREEFIX CNTL-STATE))
     (F$DEC-PASS
        (DEC-ADDR-OUT (V-THREEFIX CNTL-STATE))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR))))
     ADDR-OUT)
    (F-BUF RESET-)
    (F-OR (STROBE- (V-THREEFIX CNTL-STATE))
          DTACK-)
    (F-IF (WE-HOLD- (V-THREEFIX CNTL-STATE))
          HOLD- LAST-HOLD-)
    (FV-IF (WE-PC-REG (V-THREEFIX CNTL-STATE))
           PC-REG-IN LAST-PC-REG)
    (V-THREEFIX (F$NEXT-CNTL-STATE (F-BUF LAST-RESET-)
                                   (F-BUF LAST-DTACK-)
                                   (F-BUF LAST-HOLD-)
                                   (RW- (V-THREEFIX CNTL-STATE))
                                   (STATE (V-THREEFIX CNTL-STATE))
                                   (V-THREEFIX I-REG)
                                   (V-THREEFIX FLAGS)
                                   (V-THREEFIX LAST-PC-REG)
                                   (REGS-ADDRESS (V-THREEFIX CNTL-STATE)))))))
 ((ENABLE CHIP-MODULE& CHIP-MODULE*$DESTRUCTURE REGFILE$VALUE REGFILE$STATE
          FLAGS$VALUE FLAGS$STATE WE-REG$VALUE WE-REG$STATE FD1S$VALUE
          FD1S$STATE FD1SLP$VALUE FD1SLP$STATE REG$VALUE REG$STATE ID$VALUE
          B-BUF-PWR$VALUE B-BUF$VALUE B-NOT$VALUE DEC-PASS$VALUE TV-IF$VALUE
          CORE-ALU$VALUE NEXT-CNTL-STATE$VALUE EXTEND-IMMEDIATE$VALUE
          REG-40$VALUE-AS-CNTL-STATE B-OR$VALUE B-NAND$VALUE BV-AS-SUBRANGE
          A-IMMEDIATE F-BUF-DELETE-LEMMAS)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH OPEN-NTH *1*NTH MAKE-TREE
           *1*MAKE-TREE THREEFIX F-GATES=B-GATES OPEN-V-THREEFIX)
  (DISABLE-THEORY F-GATES B-GATES)
  (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)))

(PROVE-LEMMA CHIP-MODULE$VALUE
 (REWRITE)
 (IMPLIES
  (AND (CHIP-MODULE& NETLIST)
       (MACHINE-STATE-INVARIANT (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                            REGS-ADDR)
                                      FLAGS A-REG B-REG I-REG DATA-OUT
                                      ADDR-OUT LAST-RESET- LAST-DTACK-
                                      LAST-HOLD- LAST-PC-REG CNTL-STATE))
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4)
       (PROPERP DATA-IN)
       (EQUAL (LENGTH DATA-IN) 32))
  (EQUAL
   (DUAL-EVAL 0 'CHIP-MODULE
    (CONS CLK
     (CONS TI
         (CONS TE
               (CONS DTACK-
                     (CONS RESET-
                           (CONS HOLD-
                                 (CONS DISABLE-REGFILE-
                                       (CONS TEST-REGFILE-
                                             (APPEND PC-REG-IN DATA-IN)))))))))
    (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
          FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET- LAST-DTACK-
          LAST-HOLD- LAST-PC-REG CNTL-STATE)
    NETLIST)
   (CONS (NTH 3 (V-THREEFIX LAST-PC-REG))
         (CONS (NTH 2
                    (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                (V-THREEFIX A-REG)
                                (V-THREEFIX B-REG)
                                (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                (ALU-MPG (V-THREEFIX CNTL-STATE))
                                (ALU-OP (V-THREEFIX CNTL-STATE))
                                (MAKE-TREE 32)))
               (CONS (HDACK- (V-THREEFIX CNTL-STATE))
                     (CONS (F-NOT (HDACK- (V-THREEFIX CNTL-STATE)))
                           (CONS (F-BUF (RW- (V-THREEFIX CNTL-STATE)))
                                 (CONS (STROBE- (V-THREEFIX CNTL-STATE))
                                       (APPEND5 (V-THREEFIX ADDR-OUT)
                                                (V-THREEFIX DATA-OUT)
                                                (V-THREEFIX FLAGS)
                                                (STATE (V-THREEFIX CNTL-STATE))
                                                (SUBRANGE (V-THREEFIX I-REG)
                                                          28 31))))))))))
 ((ENABLE CHIP-MODULE& CHIP-MODULE*$DESTRUCTURE REGFILE$VALUE REGFILE$STATE
          FLAGS$VALUE FLAGS$STATE WE-REG$VALUE WE-REG$STATE FD1S$VALUE
          FD1S$STATE FD1SLP$VALUE FD1SLP$STATE REG$VALUE REG$STATE ID$VALUE
          B-BUF-PWR$VALUE B-BUF$VALUE B-NOT$VALUE DEC-PASS$VALUE TV-IF$VALUE
          CORE-ALU$VALUE NEXT-CNTL-STATE$VALUE EXTEND-IMMEDIATE$VALUE
          REG-40$VALUE-AS-CNTL-STATE B-OR$VALUE B-NAND$VALUE BV-AS-SUBRANGE
          A-IMMEDIATE F-BUF-DELETE-LEMMAS)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH OPEN-NTH *1*NTH MAKE-TREE
           *1*MAKE-TREE THREEFIX F-GATES=B-GATES OPEN-V-THREEFIX)
  (DISABLE-THEORY F-GATES B-GATES)
  (ENABLE-THEORY CONTROL-STATE-ACCESSOR-THEORY)))

(DEFN CHIP* NIL
 (CONS 'CHIP
  (CONS
   (CONS 'CLK
    (CONS 'TI
     (CONS 'TE
       (CONS 'DTACK-
             (CONS 'RESET-
                   (CONS 'HOLD-
                         (CONS 'DISABLE-REGFILE-
                               (CONS 'TEST-REGFILE-
                                     (APPEND (INDICES 'PC-REG-IN 0 4)
                                             (INDICES 'DATA-BUS 0 32))))))))))
   (CONS
    (CONS 'PO
     (CONS 'TO
      (CONS 'TIMING
       (CONS 'HDACK-
        (CONS 'RW-
         (CONS 'STROBE-
               (APPEND (INDICES 'ADDR-OUT 0 32)
                       (APPEND (INDICES 'DATA-BUS 0 32)
                               (APPEND (INDICES 'FLAGS 0 4)
                                       (APPEND (INDICES 'CNTL-STATE 0 5)
                                               (INDICES 'I-REG 28 4)))))))))))
    (CONS
     (LIST
      (LIST 'BODY
       (CONS 'I-TO
        (CONS 'I-TIMING
         (CONS 'I-HDACK-
          (CONS 'I-EN-ADDR-OUT-
           (CONS 'I-RW-
            (CONS 'I-STROBE-
             (APPEND (INDICES 'I-ADDR-OUT 0 32)
                     (APPEND (INDICES 'I-DATA-OUT 0 32)
                             (APPEND (INDICES 'I-FLAGS 0 4)
                                     (APPEND (INDICES 'I-CNTL-STATE 0 5)
                                             (INDICES 'I-I-REG 28 4)))))))))))
       'CHIP-MODULE
       (CONS 'I-CLK
        (CONS 'I-TI
         (CONS 'I-TE
          (CONS 'I-DTACK-
           (CONS 'I-RESET-
                 (CONS 'I-HOLD-
                       (CONS 'I-DISABLE-REGFILE-
                             (CONS 'I-TEST-REGFILE-
                                   (APPEND (INDICES 'I-PC-REG 0 4)
                                           (INDICES 'I-DATA-IN 0 32)))))))))))
      '(PLUS-5 (B-TRUE-P) VDD-PARAMETRIC NIL)
      '(CLOCK-PAD (I-CLK CLK-PO)
                  TTL-CLK-INPUT
                  (CLK B-TRUE-P))
      '(TI-PAD (I-TI TI-PO)
               TTL-INPUT
               (TI B-TRUE-P))
      '(TE-PAD (I-TE TE-PO)
               TTL-INPUT
               (TE TI-PO))
      '(DTACK-PAD (I-DTACK- DTACK-PO)
                  TTL-INPUT
                  (DTACK- TE-PO))
      '(RESET-PAD (I-RESET- RESET-PO)
                  TTL-INPUT
                  (RESET- DTACK-PO))
      '(HOLD-PAD (I-HOLD- HOLD-PO)
                 TTL-INPUT
                 (HOLD- RESET-PO))
      '(DISABLE-REGFILE-PAD (I-DISABLE-REGFILE- DISABLE-REGFILE-PO)
                            TTL-INPUT
                            (DISABLE-REGFILE- HOLD-PO))
      '(TEST-REGFILE-PAD (I-TEST-REGFILE- TEST-REGFILE-PO)
                         TTL-INPUT
                         (TEST-REGFILE- DISABLE-REGFILE-PO))
      (LIST 'DATA-BUS-PADS
            (CONS 'DATA-BUS-PO
                  (APPEND (INDICES 'DATA-BUS 0 32)
                          (INDICES 'I-DATA-IN 0 32)))
            (INDEX 'TTL-BIDIRECT-PADS 32)
            (CONS 'I-RW-
                  (CONS 'TEST-REGFILE-PO
                        (APPEND (INDICES 'DATA-BUS 0 32)
                                (INDICES 'I-DATA-OUT 0 32)))))
      (LIST 'PC-REG-PADS
            (CONS 'PC-REG-PO
                  (INDICES 'I-PC-REG 0 4))
            (INDEX 'TTL-INPUT-PADS 4)
            (CONS 'DATA-BUS-PO
                  (INDICES 'PC-REG-IN 0 4)))
      '(MONITOR (I-PO)
                PROCMON
                (PC-REG-PO CLK-PO B-TRUE-P B-TRUE-P))
      '(PO-PAD (PO)
               TTL-OUTPUT-PARAMETRIC
               (I-PO))
      '(TO-PAD (TO) TTL-OUTPUT (I-TO))
      '(TIMING-PAD (TIMING)
                   TTL-OUTPUT-FAST
                   (I-TIMING))
      '(HDACK-PAD (HDACK-)
                  TTL-OUTPUT-FAST
                  (I-HDACK-))
      '(RW-PAD (RW-)
               TTL-TRI-OUTPUT-FAST
               (I-RW- I-EN-ADDR-OUT-))
      '(STROBE-PAD (STROBE-)
                   TTL-TRI-OUTPUT-FAST
                   (I-STROBE- I-EN-ADDR-OUT-))
      (LIST 'ADDR-OUT-PADS
            (INDICES 'ADDR-OUT 0 32)
            (INDEX 'TTL-TRI-OUTPUT-PADS 32)
            (CONS 'I-EN-ADDR-OUT-
                  (INDICES 'I-ADDR-OUT 0 32)))
      (LIST 'FLAGS-PADS
            (INDICES 'FLAGS 0 4)
            (INDEX 'TTL-OUTPUT-PADS 4)
            (INDICES 'I-FLAGS 0 4))
      (LIST 'CNTL-STATE-PADS
            (INDICES 'CNTL-STATE 0 5)
            (INDEX 'TTL-OUTPUT-PADS 5)
            (INDICES 'I-CNTL-STATE 0 5))
      (LIST 'I-REG-PADS
            (INDICES 'I-REG 28 4)
            (INDEX 'TTL-OUTPUT-PADS 4)
            (INDICES 'I-I-REG 28 4)))
     '(BODY))))))

(PROVE-LEMMA CHIP*$DESTRUCTURE
 (REWRITE)
 (AND
  (EQUAL (CAR (CHIP*)) 'CHIP)
  (EQUAL
   (CADR (CHIP*))
   (CONS 'CLK
    (CONS 'TI
     (CONS 'TE
      (CONS 'DTACK-
            (CONS 'RESET-
                  (CONS 'HOLD-
                        (CONS 'DISABLE-REGFILE-
                              (CONS 'TEST-REGFILE-
                                    (APPEND (INDICES 'PC-REG-IN 0 4)
                                            (INDICES 'DATA-BUS 0 32)))))))))))
  (EQUAL
   (CADDR (CHIP*))
   (CONS 'PO
    (CONS 'TO
     (CONS 'TIMING
      (CONS 'HDACK-
       (CONS 'RW-
        (CONS 'STROBE-
              (APPEND (INDICES 'ADDR-OUT 0 32)
                      (APPEND (INDICES 'DATA-BUS 0 32)
                              (APPEND (INDICES 'FLAGS 0 4)
                                      (APPEND (INDICES 'CNTL-STATE 0 5)
                                              (INDICES 'I-REG 28 4))))))))))))
  (EQUAL
   (CADDDR (CHIP*))
   (LIST
    (LIST 'BODY
     (CONS 'I-TO
      (CONS 'I-TIMING
       (CONS 'I-HDACK-
        (CONS 'I-EN-ADDR-OUT-
         (CONS 'I-RW-
          (CONS 'I-STROBE-
             (APPEND (INDICES 'I-ADDR-OUT 0 32)
                     (APPEND (INDICES 'I-DATA-OUT 0 32)
                             (APPEND (INDICES 'I-FLAGS 0 4)
                                     (APPEND (INDICES 'I-CNTL-STATE 0 5)
                                             (INDICES 'I-I-REG 28 4)))))))))))
     'CHIP-MODULE
     (CONS 'I-CLK
      (CONS 'I-TI
       (CONS 'I-TE
        (CONS 'I-DTACK-
           (CONS 'I-RESET-
                 (CONS 'I-HOLD-
                       (CONS 'I-DISABLE-REGFILE-
                             (CONS 'I-TEST-REGFILE-
                                   (APPEND (INDICES 'I-PC-REG 0 4)
                                           (INDICES 'I-DATA-IN 0 32)))))))))))
    '(PLUS-5 (B-TRUE-P) VDD-PARAMETRIC NIL)
    '(CLOCK-PAD (I-CLK CLK-PO)
                TTL-CLK-INPUT
                (CLK B-TRUE-P))
    '(TI-PAD (I-TI TI-PO)
             TTL-INPUT
             (TI B-TRUE-P))
    '(TE-PAD (I-TE TE-PO)
             TTL-INPUT
             (TE TI-PO))
    '(DTACK-PAD (I-DTACK- DTACK-PO)
                TTL-INPUT
                (DTACK- TE-PO))
    '(RESET-PAD (I-RESET- RESET-PO)
                TTL-INPUT
                (RESET- DTACK-PO))
    '(HOLD-PAD (I-HOLD- HOLD-PO)
               TTL-INPUT
               (HOLD- RESET-PO))
    '(DISABLE-REGFILE-PAD (I-DISABLE-REGFILE- DISABLE-REGFILE-PO)
                          TTL-INPUT
                          (DISABLE-REGFILE- HOLD-PO))
    '(TEST-REGFILE-PAD (I-TEST-REGFILE- TEST-REGFILE-PO)
                       TTL-INPUT
                       (TEST-REGFILE- DISABLE-REGFILE-PO))
    (LIST 'DATA-BUS-PADS
          (CONS 'DATA-BUS-PO
                (APPEND (INDICES 'DATA-BUS 0 32)
                        (INDICES 'I-DATA-IN 0 32)))
          (INDEX 'TTL-BIDIRECT-PADS 32)
          (CONS 'I-RW-
                (CONS 'TEST-REGFILE-PO
                      (APPEND (INDICES 'DATA-BUS 0 32)
                              (INDICES 'I-DATA-OUT 0 32)))))
    (LIST 'PC-REG-PADS
          (CONS 'PC-REG-PO
                (INDICES 'I-PC-REG 0 4))
          (INDEX 'TTL-INPUT-PADS 4)
          (CONS 'DATA-BUS-PO
                (INDICES 'PC-REG-IN 0 4)))
    '(MONITOR (I-PO)
              PROCMON
              (PC-REG-PO CLK-PO B-TRUE-P B-TRUE-P))
    '(PO-PAD (PO)
             TTL-OUTPUT-PARAMETRIC
             (I-PO))
    '(TO-PAD (TO) TTL-OUTPUT (I-TO))
    '(TIMING-PAD (TIMING)
                 TTL-OUTPUT-FAST
                 (I-TIMING))
    '(HDACK-PAD (HDACK-)
                TTL-OUTPUT-FAST
                (I-HDACK-))
    '(RW-PAD (RW-)
             TTL-TRI-OUTPUT-FAST
             (I-RW- I-EN-ADDR-OUT-))
    '(STROBE-PAD (STROBE-)
                 TTL-TRI-OUTPUT-FAST
                 (I-STROBE- I-EN-ADDR-OUT-))
    (LIST 'ADDR-OUT-PADS
          (INDICES 'ADDR-OUT 0 32)
          (INDEX 'TTL-TRI-OUTPUT-PADS 32)
          (CONS 'I-EN-ADDR-OUT-
                (INDICES 'I-ADDR-OUT 0 32)))
    (LIST 'FLAGS-PADS
          (INDICES 'FLAGS 0 4)
          (INDEX 'TTL-OUTPUT-PADS 4)
          (INDICES 'I-FLAGS 0 4))
    (LIST 'CNTL-STATE-PADS
          (INDICES 'CNTL-STATE 0 5)
          (INDEX 'TTL-OUTPUT-PADS 5)
          (INDICES 'I-CNTL-STATE 0 5))
    (LIST 'I-REG-PADS
          (INDICES 'I-REG 28 4)
          (INDEX 'TTL-OUTPUT-PADS 4)
          (INDICES 'I-I-REG 28 4))))
  (EQUAL (CADDDDR (CHIP*)) 'BODY)))

(TOGGLE CHIP*-OFF CHIP* T)

(TOGGLE CHIP*$DESTRUCTURE-OFF CHIP*$DESTRUCTURE T)

(TOGGLE G*1*CHIP*-OFF *1*CHIP* T)

(DEFN CHIP&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CHIP NETLIST)
                  (CHIP*))
           (VDD-PARAMETRIC& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-CLK-INPUT& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-INPUT& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-INPUT-PADS& (DELETE-MODULE 'CHIP NETLIST)
                            4)
           (CHIP-MODULE& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-BIDIRECT-PADS& (DELETE-MODULE 'CHIP NETLIST)
                               32)
           (TTL-OUTPUT-PARAMETRIC& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-OUTPUT& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-OUTPUT-FAST& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-TRI-OUTPUT-FAST& (DELETE-MODULE 'CHIP NETLIST))
           (TTL-TRI-OUTPUT-PADS& (DELETE-MODULE 'CHIP NETLIST)
                                 32)
           (TTL-OUTPUT-PADS& (DELETE-MODULE 'CHIP NETLIST)
                             4)
           (TTL-OUTPUT-PADS& (DELETE-MODULE 'CHIP NETLIST)
                             5)
           (PROCMON& (DELETE-MODULE 'CHIP NETLIST))))

(TOGGLE CHIP&-OFF CHIP& T)

(DEFN CHIP$NETLIST NIL
      (CONS (CHIP*)
            (UNION (UNION (UNION (UNION (TTL-BIDIRECT-PADS$NETLIST 32)
                                        (CHIP-MODULE$NETLIST))
                                 (UNION (TTL-INPUT$NETLIST)
                                        (TTL-INPUT-PADS$NETLIST 4)))
                          (UNION (UNION (TTL-CLK-INPUT$NETLIST)
                                        (VDD-PARAMETRIC$NETLIST))
                                 (UNION (TTL-OUTPUT-PARAMETRIC$NETLIST)
                                        (TTL-OUTPUT$NETLIST))))
                   (UNION (UNION (UNION (TTL-OUTPUT-FAST$NETLIST)
                                        (TTL-TRI-OUTPUT-FAST$NETLIST))
                                 (UNION (TTL-TRI-OUTPUT-PADS$NETLIST 32)
                                        (TTL-OUTPUT-PADS$NETLIST 4)))
                          (UNION (TTL-OUTPUT-PADS$NETLIST 5)
                                 (PROCMON$NETLIST))))))

(PROVE-LEMMA CHIP$STATE
 (REWRITE)
 (IMPLIES
  (AND (CHIP& NETLIST)
       (MACHINE-STATE-INVARIANT (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                            REGS-ADDR)
                                      FLAGS A-REG B-REG I-REG DATA-OUT
                                      ADDR-OUT LAST-RESET- LAST-DTACK-
                                      LAST-HOLD- LAST-PC-REG CNTL-STATE))
       (EQUAL TE F)
       (EQUAL DISABLE-REGFILE- T)
       (EQUAL TEST-REGFILE- T)
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4)
       (PROPERP DATA-IN)
       (EQUAL (LENGTH DATA-IN) 32))
  (EQUAL
   (DUAL-EVAL 2 'CHIP
    (CONS CLK
     (CONS TI
         (CONS TE
               (CONS DTACK-
                     (CONS RESET-
                           (CONS HOLD-
                                 (CONS DISABLE-REGFILE-
                                       (CONS TEST-REGFILE-
                                             (APPEND PC-REG-IN DATA-IN)))))))))
    (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
          FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET- LAST-DTACK-
          LAST-HOLD- LAST-PC-REG CNTL-STATE)
    NETLIST)
   (LIST
    (F$WRITE-REGS (WE-REGS (V-THREEFIX CNTL-STATE))
                  (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                  (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                  (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                  (V-THREEFIX A-REG)
                                  (V-THREEFIX B-REG)
                                  (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                  (ALU-MPG (V-THREEFIX CNTL-STATE))
                                  (ALU-OP (V-THREEFIX CNTL-STATE))
                                  (MAKE-TREE 32))))
    (F$UPDATE-FLAGS FLAGS
                    (WE-FLAGS (V-THREEFIX CNTL-STATE))
                    (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                (V-THREEFIX A-REG)
                                (V-THREEFIX B-REG)
                                (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                (ALU-MPG (V-THREEFIX CNTL-STATE))
                                (ALU-OP (V-THREEFIX CNTL-STATE))
                                (MAKE-TREE 32)))
    (FV-IF
     (WE-A-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        (V-WIRE DATA-IN
                (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                         (V-THREEFIX DATA-OUT))))
     A-REG)
    (FV-IF
     (WE-B-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        (V-WIRE DATA-IN
                (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                         (V-THREEFIX DATA-OUT))))
     B-REG)
    (FV-IF
     (WE-I-REG (V-THREEFIX CNTL-STATE))
     (FV-IF
        (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
                (F-NOT LAST-DTACK-))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR)))
        (V-WIRE DATA-IN
                (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                         (V-THREEFIX DATA-OUT))))
     I-REG)
    (FV-IF (WE-DATA-OUT (V-THREEFIX CNTL-STATE))
           (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                           (V-THREEFIX A-REG)
                           (V-THREEFIX B-REG)
                           (ALU-ZERO (V-THREEFIX CNTL-STATE))
                           (ALU-MPG (V-THREEFIX CNTL-STATE))
                           (ALU-OP (V-THREEFIX CNTL-STATE))
                           (MAKE-TREE 32)))
           DATA-OUT)
    (FV-IF
     (WE-ADDR-OUT (V-THREEFIX CNTL-STATE))
     (F$DEC-PASS
        (DEC-ADDR-OUT (V-THREEFIX CNTL-STATE))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR))))
     ADDR-OUT)
    (F-BUF RESET-)
    (F-OR (STROBE- (V-THREEFIX CNTL-STATE))
          (F-BUF DTACK-))
    (F-IF (WE-HOLD- (V-THREEFIX CNTL-STATE))
          (F-BUF HOLD-)
          LAST-HOLD-)
    (FV-IF (WE-PC-REG (V-THREEFIX CNTL-STATE))
           PC-REG-IN LAST-PC-REG)
    (V-THREEFIX (F$NEXT-CNTL-STATE (F-BUF LAST-RESET-)
                                   (F-BUF LAST-DTACK-)
                                   (F-BUF LAST-HOLD-)
                                   (RW- (V-THREEFIX CNTL-STATE))
                                   (STATE (V-THREEFIX CNTL-STATE))
                                   (V-THREEFIX I-REG)
                                   (V-THREEFIX FLAGS)
                                   (V-THREEFIX LAST-PC-REG)
                                   (REGS-ADDRESS (V-THREEFIX CNTL-STATE)))))))
 ((ENABLE CHIP& CHIP*$DESTRUCTURE CHIP-MODULE$VALUE CHIP-MODULE$STATE
          VDD-PARAMETRIC$VALUE TTL-CLK-INPUT$VALUE TTL-INPUT$VALUE
          TTL-OUTPUT$VALUE TTL-TRI-OUTPUT$VALUE TTL-OUTPUT-FAST$VALUE
          TTL-TRI-OUTPUT-FAST$VALUE TTL-INPUT-PADS$VALUE TTL-OUTPUT-PADS$VALUE
          TTL-BIDIRECT-PADS$VALUE TTL-TRI-OUTPUT-PADS$VALUE
          F-BUF-DELETE-LEMMAS)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH OPEN-NTH *1*NTH MAKE-TREE
           *1*MAKE-TREE THREEFIX F-GATES=B-GATES OPEN-V-THREEFIX
           APPEND-V-THREEFIX)
  (DISABLE-THEORY F-GATES B-GATES)))

(PROVE-LEMMA CHIP$VALUE
 (REWRITE)
 (IMPLIES
  (AND (CHIP& NETLIST)
       (MACHINE-STATE-INVARIANT (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                            REGS-ADDR)
                                      FLAGS A-REG B-REG I-REG DATA-OUT
                                      ADDR-OUT LAST-RESET- LAST-DTACK-
                                      LAST-HOLD- LAST-PC-REG CNTL-STATE))
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4)
       (PROPERP DATA-IN)
       (EQUAL (LENGTH DATA-IN) 32))
  (EQUAL
   (CDR
    (DUAL-EVAL 0 'CHIP
     (CONS CLK
      (CONS TI
         (CONS TE
               (CONS DTACK-
                     (CONS RESET-
                           (CONS HOLD-
                                 (CONS DISABLE-REGFILE-
                                       (CONS TEST-REGFILE-
                                             (APPEND PC-REG-IN DATA-IN)))))))))
     (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
           FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET- LAST-DTACK-
           LAST-HOLD- LAST-PC-REG CNTL-STATE)
     NETLIST))
   (CONS
    (F-BUF (NTH 3 (V-THREEFIX LAST-PC-REG)))
    (CONS
     (F-BUF (NTH 2
                 (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                             (V-THREEFIX A-REG)
                             (V-THREEFIX B-REG)
                             (ALU-ZERO (V-THREEFIX CNTL-STATE))
                             (ALU-MPG (V-THREEFIX CNTL-STATE))
                             (ALU-OP (V-THREEFIX CNTL-STATE))
                             (MAKE-TREE 32))))
     (CONS
      (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
      (CONS
          (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                  (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
          (CONS (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                        (STROBE- (V-THREEFIX CNTL-STATE)))
                (APPEND5 (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                  (V-THREEFIX ADDR-OUT))
                         (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                                  (V-THREEFIX DATA-OUT))
                         (V-THREEFIX FLAGS)
                         (V-THREEFIX (STATE (V-THREEFIX CNTL-STATE)))
                         (V-THREEFIX (SUBRANGE (V-THREEFIX I-REG)
                                               28 31))))))))))
 ((ENABLE CHIP& CHIP*$DESTRUCTURE CHIP-MODULE$VALUE VDD-PARAMETRIC$VALUE
          TTL-CLK-INPUT$VALUE TTL-INPUT$VALUE TTL-OUTPUT$VALUE
          TTL-TRI-OUTPUT$VALUE TTL-OUTPUT-FAST$VALUE TTL-TRI-OUTPUT-FAST$VALUE
          TTL-INPUT-PADS$VALUE TTL-OUTPUT-PADS$VALUE TTL-BIDIRECT-PADS$VALUE
          TTL-TRI-OUTPUT-PADS$VALUE F-NOT-F-NOT=F-BUF STATE)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH OPEN-NTH *1*NTH MAKE-TREE
           *1*MAKE-TREE MAKE-LIST *1*MAKE-LIST THREEFIX F-GATES=B-GATES
           OPEN-V-THREEFIX APPEND-V-THREEFIX)
  (DISABLE-THEORY F-GATES B-GATES)))

(DEFN CHIP-SYSTEM* NIL
 (CONS 'CHIP-SYSTEM
  (CONS
   (CONS 'CLK
         (CONS 'TI
               (CONS 'TE
                     (CONS 'RESET-
                           (CONS 'HOLD-
                                 (CONS 'DISABLE-REGFILE-
                                       (CONS 'TEST-REGFILE-
                                             (INDICES 'PC-REG 0 4))))))))
   (CONS NIL
    (CONS
     (LIST
      (LIST 'FM9001
       (CONS 'PO
        (CONS 'TO
         (CONS 'TIMING
          (CONS 'HDACK-
           (CONS 'RW-
            (CONS 'STROBE-
               (APPEND (INDICES 'ADDR-OUT 0 32)
                       (APPEND (INDICES 'FM9001-DATA 0 32)
                               (APPEND (INDICES 'FLAGS 0 4)
                                       (APPEND (INDICES 'CNTL-STATE 0 5)
                                               (INDICES 'I-REG 28 4)))))))))))
       'CHIP
       (CONS 'CLK
        (CONS 'TI
         (CONS 'TE
          (CONS 'DTACK-
            (CONS 'RESET-
                  (CONS 'HOLD-
                        (CONS 'DISABLE-REGFILE-
                              (CONS 'TEST-REGFILE-
                                    (APPEND (INDICES 'PC-REG 0 4)
                                            (INDICES 'DATA-BUS 0 32)))))))))))
      '(PULLUP-RW- (RW-BUS) PULLUP (RW-))
      '(PULLUP-STROBE- (STROBE-BUS)
                       PULLUP
                       (STROBE-))
      (LIST 'ADDRESS
            (INDICES 'ADDR-BUS 0 32)
            (INDEX 'V-PULLUP 32)
            (INDICES 'ADDR-OUT 0 32))
      (LIST 'MEM
            (CONS 'DTACK-
                  (INDICES 'MEM-DATA 0 32))
            'MEM-32X32
            (CONS 'RW-BUS
                  (CONS 'STROBE-BUS
                        (APPEND (INDICES 'ADDR-BUS 0 32)
                                (INDICES 'DATA-BUS 0 32)))))
      (LIST 'DATA-WIRE
            (INDICES 'DATA-WIRE 0 32)
            (INDEX 'V-WIRE 32)
            (APPEND (INDICES 'FM9001-DATA 0 32)
                    (INDICES 'MEM-DATA 0 32)))
      (LIST 'DATA
            (INDICES 'DATA-BUS 0 32)
            (INDEX 'V-PULLUP 32)
            (INDICES 'DATA-WIRE 0 32)))
     '((FM9001 MEM)))))))

(PROVE-LEMMA CHIP-SYSTEM*$DESTRUCTURE
 (REWRITE)
 (AND
  (EQUAL (CAR (CHIP-SYSTEM*))
         'CHIP-SYSTEM)
  (EQUAL
       (CADR (CHIP-SYSTEM*))
       (CONS 'CLK
             (CONS 'TI
                   (CONS 'TE
                         (CONS 'RESET-
                               (CONS 'HOLD-
                                     (CONS 'DISABLE-REGFILE-
                                           (CONS 'TEST-REGFILE-
                                                 (INDICES 'PC-REG 0 4)))))))))
  (EQUAL (CADDR (CHIP-SYSTEM*)) NIL)
  (EQUAL
   (CADDDR (CHIP-SYSTEM*))
   (LIST
    (LIST 'FM9001
     (CONS 'PO
      (CONS 'TO
       (CONS 'TIMING
        (CONS 'HDACK-
         (CONS 'RW-
          (CONS 'STROBE-
               (APPEND (INDICES 'ADDR-OUT 0 32)
                       (APPEND (INDICES 'FM9001-DATA 0 32)
                               (APPEND (INDICES 'FLAGS 0 4)
                                       (APPEND (INDICES 'CNTL-STATE 0 5)
                                               (INDICES 'I-REG 28 4)))))))))))
     'CHIP
     (CONS 'CLK
      (CONS 'TI
       (CONS 'TE
        (CONS 'DTACK-
            (CONS 'RESET-
                  (CONS 'HOLD-
                        (CONS 'DISABLE-REGFILE-
                              (CONS 'TEST-REGFILE-
                                    (APPEND (INDICES 'PC-REG 0 4)
                                            (INDICES 'DATA-BUS 0 32)))))))))))
    '(PULLUP-RW- (RW-BUS) PULLUP (RW-))
    '(PULLUP-STROBE- (STROBE-BUS)
                     PULLUP
                     (STROBE-))
    (LIST 'ADDRESS
          (INDICES 'ADDR-BUS 0 32)
          (INDEX 'V-PULLUP 32)
          (INDICES 'ADDR-OUT 0 32))
    (LIST 'MEM
          (CONS 'DTACK-
                (INDICES 'MEM-DATA 0 32))
          'MEM-32X32
          (CONS 'RW-BUS
                (CONS 'STROBE-BUS
                      (APPEND (INDICES 'ADDR-BUS 0 32)
                              (INDICES 'DATA-BUS 0 32)))))
    (LIST 'DATA-WIRE
          (INDICES 'DATA-WIRE 0 32)
          (INDEX 'V-WIRE 32)
          (APPEND (INDICES 'FM9001-DATA 0 32)
                  (INDICES 'MEM-DATA 0 32)))
    (LIST 'DATA
          (INDICES 'DATA-BUS 0 32)
          (INDEX 'V-PULLUP 32)
          (INDICES 'DATA-WIRE 0 32))))
  (EQUAL (CADDDDR (CHIP-SYSTEM*))
         '(FM9001 MEM))))

(TOGGLE CHIP-SYSTEM*-OFF CHIP-SYSTEM* T)

(TOGGLE CHIP-SYSTEM*$DESTRUCTURE-OFF CHIP-SYSTEM*$DESTRUCTURE T)

(TOGGLE G*1*CHIP-SYSTEM*-OFF *1*CHIP-SYSTEM* T)

(DEFN CHIP-SYSTEM&
      (NETLIST)
      (AND (EQUAL (LOOKUP-MODULE 'CHIP-SYSTEM NETLIST)
                  (CHIP-SYSTEM*))
           (CHIP& (DELETE-MODULE 'CHIP-SYSTEM NETLIST))
           (PULLUP& (DELETE-MODULE 'CHIP-SYSTEM NETLIST))
           (V-PULLUP& (DELETE-MODULE 'CHIP-SYSTEM NETLIST)
                      32)
           (MEM-32X32& (DELETE-MODULE 'CHIP-SYSTEM NETLIST))
           (V-WIRE& (DELETE-MODULE 'CHIP-SYSTEM NETLIST)
                    32)))

(TOGGLE CHIP-SYSTEM&-OFF CHIP-SYSTEM& T)

(DEFN CHIP-SYSTEM$NETLIST NIL
      (CONS (CHIP-SYSTEM*)
            (UNION (PULLUP$NETLIST)
                   (UNION (V-PULLUP$NETLIST 32)
                          (UNION (MEM-32X32$NETLIST)
                                 (UNION (V-WIRE$NETLIST 32)
                                        (CHIP$NETLIST)))))))

(DEFN MEMORY-STATE-INVARIANT
      (MEM-STATE)
      (AND (MEMORY-PROPERP 32 32 (CAR MEM-STATE))
           (PROPERP (CADDDDDDR MEM-STATE))
           (PROPERP (CADDDDDDDR MEM-STATE))
           (EQUAL (LENGTH (CADDDDDDDR MEM-STATE))
                  32)))

(DEFN CHIP-SYSTEM-INVARIANT
      (STATE)
      (AND (MACHINE-STATE-INVARIANT (CAR STATE))
           (MEMORY-STATE-INVARIANT (CADR STATE))))

(PROVE-LEMMA EQUAL-MEMORY-VALUE-FOR-CHIP-SYSTEM$STATE
             (REWRITE)
             (EQUAL (MEMORY-VALUE STATE STROBE RW- ADDRESS
                                  (COLLECT-VALUE ARGS ALIST))
                    (MEMORY-VALUE STATE STROBE RW- ADDRESS
                                  (MAKE-LIST (LENGTH ARGS) (X)))))

(PROVE-LEMMA CHIP-SYSTEM$STATE-HELP
 (REWRITE)
 (IMPLIES
  (AND (CHIP-SYSTEM& NETLIST)
       (CHIP-SYSTEM-INVARIANT (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                                REGS-ADDR)
                                          FLAGS A-REG B-REG I-REG DATA-OUT
                                          ADDR-OUT LAST-RESET- LAST-DTACK-
                                          LAST-HOLD- LAST-PC-REG CNTL-STATE)
                                    MEM-STATE))
       (EQUAL TE F)
       (EQUAL DISABLE-REGFILE- T)
       (EQUAL TEST-REGFILE- T)
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4))
  (EQUAL
   (DUAL-EVAL 2 'CHIP-SYSTEM
       (CONS CLK
             (CONS TI
                   (CONS TE
                         (CONS RESET-
                               (CONS HOLD-
                                     (CONS DISABLE-REGFILE-
                                           (CONS TEST-REGFILE- PC-REG-IN)))))))
       (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                   FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET-
                   LAST-DTACK- LAST-HOLD- LAST-PC-REG CNTL-STATE)
             MEM-STATE)
       NETLIST)
   (LIST
    (LIST
     (F$WRITE-REGS (WE-REGS (V-THREEFIX CNTL-STATE))
                   (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                   (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                   (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                   (V-THREEFIX A-REG)
                                   (V-THREEFIX B-REG)
                                   (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                   (ALU-MPG (V-THREEFIX CNTL-STATE))
                                   (ALU-OP (V-THREEFIX CNTL-STATE))
                                   (MAKE-TREE 32))))
     (F$UPDATE-FLAGS FLAGS
                     (WE-FLAGS (V-THREEFIX CNTL-STATE))
                     (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                                 (V-THREEFIX A-REG)
                                 (V-THREEFIX B-REG)
                                 (ALU-ZERO (V-THREEFIX CNTL-STATE))
                                 (ALU-MPG (V-THREEFIX CNTL-STATE))
                                 (ALU-OP (V-THREEFIX CNTL-STATE))
                                 (MAKE-TREE 32)))
     (FV-IF
      (WE-A-REG (V-THREEFIX CNTL-STATE))
      (FV-IF
       (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                           (A-IMMEDIATE (V-THREEFIX I-REG))
                           (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                        (LIST REGS-REGS REGS-WE REGS-DATA
                                              REGS-ADDR)))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
           (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                    (V-THREEFIX DATA-OUT))
           (CDR
            (MEMORY-VALUE MEM-STATE
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (STROBE- (V-THREEFIX CNTL-STATE))))
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
                    (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                       (V-THREEFIX ADDR-OUT)))
                    (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                  (V-THREEFIX DATA-OUT)))))
      A-REG)
     (FV-IF
      (WE-B-REG (V-THREEFIX CNTL-STATE))
      (FV-IF
       (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                           (A-IMMEDIATE (V-THREEFIX I-REG))
                           (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                        (LIST REGS-REGS REGS-WE REGS-DATA
                                              REGS-ADDR)))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
           (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                    (V-THREEFIX DATA-OUT))
           (CDR
            (MEMORY-VALUE MEM-STATE
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (STROBE- (V-THREEFIX CNTL-STATE))))
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
                    (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                       (V-THREEFIX ADDR-OUT)))
                    (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                  (V-THREEFIX DATA-OUT)))))
      B-REG)
     (FV-IF
      (WE-I-REG (V-THREEFIX CNTL-STATE))
      (FV-IF
       (F-NAND (DATA-IN-SELECT (V-THREEFIX CNTL-STATE))
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                           (A-IMMEDIATE (V-THREEFIX I-REG))
                           (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                        (LIST REGS-REGS REGS-WE REGS-DATA
                                              REGS-ADDR)))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
           (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                    (V-THREEFIX DATA-OUT))
           (CDR
            (MEMORY-VALUE MEM-STATE
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (STROBE- (V-THREEFIX CNTL-STATE))))
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
                    (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                       (V-THREEFIX ADDR-OUT)))
                    (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                  (V-THREEFIX DATA-OUT)))))
      I-REG)
     (FV-IF (WE-DATA-OUT (V-THREEFIX CNTL-STATE))
            (BV (F$CORE-ALU (ALU-C (V-THREEFIX CNTL-STATE))
                            (V-THREEFIX A-REG)
                            (V-THREEFIX B-REG)
                            (ALU-ZERO (V-THREEFIX CNTL-STATE))
                            (ALU-MPG (V-THREEFIX CNTL-STATE))
                            (ALU-OP (V-THREEFIX CNTL-STATE))
                            (MAKE-TREE 32)))
            DATA-OUT)
     (FV-IF
      (WE-ADDR-OUT (V-THREEFIX CNTL-STATE))
      (F$DEC-PASS
        (DEC-ADDR-OUT (V-THREEFIX CNTL-STATE))
        (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE (V-THREEFIX CNTL-STATE))
                            (A-IMMEDIATE (V-THREEFIX I-REG))
                            (F$READ-REGS (REGS-ADDRESS (V-THREEFIX CNTL-STATE))
                                         (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDR))))
      ADDR-OUT)
     (F-BUF RESET-)
     (F-OR
      (STROBE- (V-THREEFIX CNTL-STATE))
      (F-BUF
       (CAR
        (MEMORY-VALUE MEM-STATE
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (STROBE- (V-THREEFIX CNTL-STATE))))
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
                    (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                       (V-THREEFIX ADDR-OUT)))
                    (MAKE-LIST 32 (X))))))
     (F-IF (WE-HOLD- (V-THREEFIX CNTL-STATE))
           (F-BUF HOLD-)
           LAST-HOLD-)
     (FV-IF (WE-PC-REG (V-THREEFIX CNTL-STATE))
            PC-REG-IN LAST-PC-REG)
     (V-THREEFIX (F$NEXT-CNTL-STATE (F-BUF LAST-RESET-)
                                    (F-BUF LAST-DTACK-)
                                    (F-BUF LAST-HOLD-)
                                    (RW- (V-THREEFIX CNTL-STATE))
                                    (STATE (V-THREEFIX CNTL-STATE))
                                    (V-THREEFIX I-REG)
                                    (V-THREEFIX FLAGS)
                                    (V-THREEFIX LAST-PC-REG)
                                    (REGS-ADDRESS (V-THREEFIX CNTL-STATE)))))
    (NEXT-MEMORY-STATE MEM-STATE
     (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                       (STROBE- (V-THREEFIX CNTL-STATE))))
     (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                       (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
     (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                        (V-THREEFIX ADDR-OUT)))
     (V-PULLUP
      (V-WIRE
       (VFT-BUF (F-NOT (F-BUF (RW- (V-THREEFIX CNTL-STATE))))
                (V-THREEFIX DATA-OUT))
       (CDR
        (MEMORY-VALUE MEM-STATE
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (STROBE- (V-THREEFIX CNTL-STATE))))
                    (F-PULLUP (FT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                      (F-BUF (RW- (V-THREEFIX CNTL-STATE)))))
                    (V-PULLUP (VFT-BUF (F-BUF (HDACK- (V-THREEFIX CNTL-STATE)))
                                       (V-THREEFIX ADDR-OUT)))
                    (MAKE-LIST 32 (X))))))))))
 ((ENABLE CHIP-SYSTEM& CHIP-SYSTEM*$DESTRUCTURE CHIP$VALUE CHIP$STATE
          MEM-32X32$STRUCTURED-VALUE MEM-32X32$STRUCTURED-STATE PULLUP$VALUE
          V-PULLUP$VALUE V-WIRE$VALUE)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH OPEN-NTH *1*NTH MAKE-TREE
           *1*MAKE-TREE THREEFIX F-GATES=B-GATES OPEN-V-THREEFIX
           APPEND-V-THREEFIX NEXT-MEMORY-STATE MEMORY-VALUE *1*MAKE-LIST)
  (DISABLE-THEORY F-GATES B-GATES)))

(TOGGLE CHIP-SYSTEM$STATE-HELP-OFF CHIP-SYSTEM$STATE-HELP T)

(PROVE-LEMMA CHIP-SYSTEM$STATE
 (REWRITE)
 (IMPLIES
  (AND (CHIP-SYSTEM& NETLIST)
       (CHIP-SYSTEM-INVARIANT (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                                REGS-ADDR)
                                          FLAGS A-REG B-REG I-REG DATA-OUT
                                          ADDR-OUT LAST-RESET- LAST-DTACK-
                                          LAST-HOLD- LAST-PC-REG CNTL-STATE)
                                    MEM-STATE))
       (EQUAL TE F)
       (EQUAL DISABLE-REGFILE- T)
       (EQUAL TEST-REGFILE- T)
       (PROPERP PC-REG-IN)
       (EQUAL (LENGTH PC-REG-IN) 4))
  (EQUAL
   (DUAL-EVAL 2 'CHIP-SYSTEM
       (CONS CLK
             (CONS TI
                   (CONS TE
                         (CONS RESET-
                               (CONS HOLD-
                                     (CONS DISABLE-REGFILE-
                                           (CONS TEST-REGFILE- PC-REG-IN)))))))
       (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                   FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT LAST-RESET-
                   LAST-DTACK- LAST-HOLD- LAST-PC-REG CNTL-STATE)
             MEM-STATE)
       NETLIST)
   (FM9001-NEXT-STATE (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA REGS-ADDR)
                                  FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                                  LAST-RESET- LAST-DTACK- LAST-HOLD-
                                  LAST-PC-REG CNTL-STATE)
                            MEM-STATE)
                      (CONS RESET-
                            (CONS HOLD- PC-REG-IN)))))
 ((ENABLE CHIP-SYSTEM$STATE-HELP FM9001-NEXT-STATE OPEN-NTH SUBRANGE-CONS)
  (DISABLE INDICES *1*INDICES OPEN-INDICES NTH *1*NTH MAKE-TREE *1*MAKE-TREE
           THREEFIX F-GATES=B-GATES OPEN-V-THREEFIX APPEND-V-THREEFIX
           NEXT-MEMORY-STATE MEMORY-VALUE *1*MAKE-LIST MACHINE-STATE-INVARIANT
           MEMORY-STATE-INVARIANT)
  (ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS
                 FM9001-EXTERNAL-INPUT-ACCESSORS)
  (DISABLE-THEORY F-GATES B-GATES)))

(TOGGLE CHIP-SYSTEM$STATE-OFF CHIP-SYSTEM$STATE T)

(PROVE-LEMMA NEXT-MEMORY-STATE-PRESERVES-MEMORY-INVARIANT
             (REWRITE)
             (IMPLIES (AND (MEMORY-STATE-INVARIANT MEM-STATE)
                           (PROPERP DATA)
                           (EQUAL (LENGTH DATA) 32)
                           (EQUAL (LENGTH ADDRESS) 32))
                      (MEMORY-STATE-INVARIANT (NEXT-MEMORY-STATE MEM-STATE
                                                                 STROBE- RW-
                                                                 ADDRESS
                                                                 DATA)))
             ((ENABLE NEXT-MEMORY-STATE)))

(PROVE-LEMMA MEMORY-PROPERP-DUAL-PORT-RAM-STATE-CROCK
 (REWRITE)
 (IMPLIES
  (AND (MEMORY-PROPERP 4 32 REGS)
       (EQUAL (LENGTH A-ADDRESS) 4)
       (EQUAL (LENGTH B-ADDRESS) 4)
       (PROPERP DATA)
       (EQUAL (LENGTH DATA) 32))
  (MEMORY-PROPERP 4 32
                (DUAL-PORT-RAM-STATE 32 4
                                     (APPEND A-ADDRESS
                                             (APPEND B-ADDRESS (CONS WE DATA)))
                                     REGS))))

(PROVE-LEMMA ALL-RAMP-MEM-DUAL-PORT-RAM-STATE-CROCK
 (REWRITE)
 (IMPLIES
  (AND (ALL-RAMP-MEM 4 REGS)
       (EQUAL (LENGTH A-ADDRESS) 4)
       (EQUAL (LENGTH B-ADDRESS) 4)
       (PROPERP DATA)
       (EQUAL (LENGTH DATA) 32))
  (ALL-RAMP-MEM 4
                (DUAL-PORT-RAM-STATE 32 4
                                     (APPEND A-ADDRESS
                                             (APPEND B-ADDRESS (CONS WE DATA)))
                                     REGS))))

(PROVE-LEMMA FM9001-PRESERVES-CHIP-SYSTEM-INVARIANT
             (REWRITE)
             (IMPLIES (AND (CHIP-SYSTEM-INVARIANT STATE)
                           (PROPERP (PC-REG-INPUT INPUTS))
                           (EQUAL (LENGTH (PC-REG-INPUT INPUTS))
                                  4))
                      (CHIP-SYSTEM-INVARIANT (FM9001-NEXT-STATE STATE INPUTS)))
             ((ENABLE FM9001-NEXT-STATE F$WRITE-REGS REGS-ADDRESS CNTL-STATE
                      OPEN-NTH)
              (DISABLE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX THREEFIX
                       DUAL-PORT-RAM-STATE)
              (ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
              (DISABLE-THEORY F-GATES)))

(DEFN CHIP-SYSTEM-INPUT-INVARIANT
      (INPUTS)
      (AND (EQUAL (CADDR INPUTS) F)
           (EQUAL (CADDDDDR INPUTS) T)
           (EQUAL (CADDDDDDR INPUTS) T)
           (PROPERP (CDDDDDDDR INPUTS))
           (EQUAL (LENGTH (CDDDDDDDR INPUTS))
                  4)))

(PROVE-LEMMA REWRITE-CHIP-SYSTEM-INPUT-INVARIANT NIL
 (EQUAL
  (CHIP-SYSTEM-INPUT-INVARIANT INPUTS)
  (AND
    (EQUAL INPUTS
           (CONS (CAR INPUTS)
                 (CONS (CADR INPUTS)
                       (CONS (CADDR INPUTS)
                             (CONS (CADDDR INPUTS)
                                   (CONS (CADDDDR INPUTS)
                                         (CONS (CADDDDDR INPUTS)
                                               (CONS (CADDDDDDR INPUTS)
                                                     (CDDDDDDDR INPUTS)))))))))
    (EQUAL (CADDR INPUTS) F)
    (EQUAL (CADDDDDR INPUTS) T)
    (EQUAL (CADDDDDDR INPUTS) T)
    (PROPERP (CDDDDDDDR INPUTS))
    (EQUAL (LENGTH (CDDDDDDDR INPUTS))
           4))))

(DEFN CHIP-SYSTEM-OPERATING-INPUTS-P
      (INPUTS N)
      (IF (ZEROP N)
          T
          (AND (CHIP-SYSTEM-INPUT-INVARIANT (CAR INPUTS))
               (CHIP-SYSTEM-OPERATING-INPUTS-P (CDR INPUTS)
                                               (SUB1 N)))))

(TOGGLE CHIP-SYSTEM-OPERATING-INPUTS-P-OFF CHIP-SYSTEM-OPERATING-INPUTS-P T)

(PROVE-LEMMA OPEN-CHIP-SYSTEM-OPERATING-INPUTS-P
        (REWRITE)
        (AND (IMPLIES (ZEROP N)
                      (EQUAL (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS N)
                             T))
             (IMPLIES (NOT (ZEROP N))
                      (EQUAL (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS N)
                             (AND (CHIP-SYSTEM-INPUT-INVARIANT (CAR INPUTS))
                                  (CHIP-SYSTEM-OPERATING-INPUTS-P (CDR INPUTS)
                                                                  (SUB1 N))))))
        ((ENABLE CHIP-SYSTEM-OPERATING-INPUTS-P)))

(DEFN MAP-UP-1-INPUT
      (INPUTS)
      (CONS (CADDDR INPUTS)
            (CONS (CADDDDR INPUTS)
                  (CDDDDDDDR INPUTS))))

(DEFN MAP-UP-INPUTS
      (INPUTS)
      (IF (NLISTP INPUTS)
          NIL
          (CONS (MAP-UP-1-INPUT (CAR INPUTS))
                (MAP-UP-INPUTS (CDR INPUTS)))))

(TOGGLE MAP-UP-INPUTS-OFF MAP-UP-INPUTS T)

(PROVE-LEMMA OPEN-MAP-UP-INPUTS
             (REWRITE)
             (AND (IMPLIES (NLISTP INPUTS)
                           (EQUAL (MAP-UP-INPUTS INPUTS) NIL))
                  (IMPLIES (LISTP INPUTS)
                           (EQUAL (MAP-UP-INPUTS INPUTS)
                                  (CONS (MAP-UP-1-INPUT (CAR INPUTS))
                                        (MAP-UP-INPUTS (CDR INPUTS))))))
             ((ENABLE MAP-UP-INPUTS)))

(PROVE-LEMMA CHIP-SYSTEM=FM9001$STEP
             (REWRITE)
             (IMPLIES (AND (CHIP-SYSTEM& NETLIST)
                           (FM9001-STATE-STRUCTURE STATE)
                           (CHIP-SYSTEM-INVARIANT STATE)
                           (CHIP-SYSTEM-INPUT-INVARIANT INPUTS))
                      (EQUAL (DUAL-EVAL 2 'CHIP-SYSTEM
                                        INPUTS STATE NETLIST)
                             (FM9001-NEXT-STATE STATE
                                                (MAP-UP-1-INPUT INPUTS))))
             ((DISABLE CHIP-SYSTEM-INVARIANT FM9001-STATE-STRUCTURE
                       CHIP-SYSTEM-INPUT-INVARIANT CAR-CDR-ELIM CONS-CAR-CDR)
              (USE (CHIP-SYSTEM$STATE (REGS-REGS (CAAAR STATE))
                                      (REGS-WE (CADAAR STATE))
                                      (REGS-DATA (CADDAAR STATE))
                                      (REGS-ADDR (CADDDAAR STATE))
                                      (FLAGS (CADAR STATE))
                                      (A-REG (CADDAR STATE))
                                      (B-REG (CADDDAR STATE))
                                      (I-REG (CADDDDAR STATE))
                                      (DATA-OUT (CADDDDDAR STATE))
                                      (ADDR-OUT (CADDDDDDAR STATE))
                                      (LAST-RESET- (CADDDDDDDAR STATE))
                                      (LAST-DTACK- (CADDDDDDDDAR STATE))
                                      (LAST-HOLD- (CADDDDDDDDDAR STATE))
                                      (LAST-PC-REG (CADDDDDDDDDDAR STATE))
                                      (CNTL-STATE (CADDDDDDDDDDDAR STATE))
                                      (MEM-STATE (LIST (CAADR STATE)
                                                       (CADADR STATE)
                                                       (CADDADR STATE)
                                                       (CADDDADR STATE)
                                                       (CADDDDADR STATE)
                                                       (CADDDDDADR STATE)
                                                       (CADDDDDDADR STATE)
                                                       (CADDDDDDDADR STATE)))
                                      (CLK (CAR INPUTS))
                                      (TI (CADR INPUTS))
                                      (TE (CADDR INPUTS))
                                      (RESET- (CADDDR INPUTS))
                                      (HOLD- (CADDDDR INPUTS))
                                      (DISABLE-REGFILE- (CADDDDDR INPUTS))
                                      (TEST-REGFILE- (CADDDDDDR INPUTS))
                                      (PC-REG-IN (CDDDDDDDR INPUTS)))
                   (FM9001-STATE-AS-A-LIST)
                   (REWRITE-CHIP-SYSTEM-INPUT-INVARIANT))))

(TOGGLE CHIP-SYSTEM=FM9001$STEP-OFF CHIP-SYSTEM=FM9001$STEP T)

(DEFN CHIP-SYSTEM=RUN-FM9001$INDUCTION
  (STATE INPUTS FM9001-INPUTS N)
  (IF (ZEROP N)
      T
      (CHIP-SYSTEM=RUN-FM9001$INDUCTION (FM9001-NEXT-STATE STATE
                                                           (CAR FM9001-INPUTS))
                                        (CDR INPUTS)
                                        (CDR FM9001-INPUTS)
                                        (SUB1 N))))

(PROVE-LEMMA CHIP-SYSTEM=RUN-FM9001
             (REWRITE)
             (IMPLIES (AND (CHIP-SYSTEM& NETLIST)
                           (FM9001-STATE-STRUCTURE STATE)
                           (CHIP-SYSTEM-INVARIANT STATE)
                           (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS N)
                           (EQUAL FM9001-INPUTS
                                  (MAP-UP-INPUTS INPUTS)))
                      (EQUAL (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                                                   INPUTS STATE NETLIST N)
                             (RUN-FM9001 STATE FM9001-INPUTS N)))
             ((INDUCT (CHIP-SYSTEM=RUN-FM9001$INDUCTION STATE INPUTS
                                                        FM9001-INPUTS N))
              (ENABLE CHIP-SYSTEM=FM9001$STEP PC-REG-INPUT OPEN-SUBRANGE
                      RUN-FM9001-STEP-CASE)
              (DISABLE FM9001-STATE-STRUCTURE CHIP-SYSTEM-INVARIANT
                       CHIP-SYSTEM-INPUT-INVARIANT MAP-UP-1-INPUT)))

(DEFN RUN-INPUTS-P
      (INPUTS N)
      (IF (ZEROP N)
          T
          (AND (EQUAL (RESET--INPUT (CAR INPUTS)) T)
               (PROPERP (PC-REG-INPUT (CAR INPUTS)))
               (EQUAL (LENGTH (PC-REG-INPUT (CAR INPUTS)))
                      4)
               (RUN-INPUTS-P (CDR INPUTS)
                             (SUB1 N)))))

(TOGGLE RUN-INPUTS-P-OFF RUN-INPUTS-P T)

(PROVE-LEMMA OPEN-RUN-INPUTS-P
          (REWRITE)
          (AND (IMPLIES (ZEROP N)
                        (EQUAL (RUN-INPUTS-P INPUTS N) T))
               (IMPLIES (NOT (ZEROP N))
                        (EQUAL (RUN-INPUTS-P INPUTS N)
                               (AND (EQUAL (RESET--INPUT (CAR INPUTS)) T)
                                    (PROPERP (PC-REG-INPUT (CAR INPUTS)))
                                    (EQUAL (LENGTH (PC-REG-INPUT (CAR INPUTS)))
                                           4)
                                    (RUN-INPUTS-P (CDR INPUTS)
                                                  (SUB1 N))))))
          ((ENABLE RUN-INPUTS-P)))

(PROVE-LEMMA RUN-INPUTS-P-PLUS
             (REWRITE)
             (EQUAL (RUN-INPUTS-P INPUTS (PLUS N M))
                    (AND (RUN-INPUTS-P INPUTS N)
                         (RUN-INPUTS-P (NTHCDR N INPUTS) M)))
             ((ENABLE RUN-INPUTS-P NTHCDR PLUS)))

(PROVE-LEMMA RUN-INPUTS-P-1
             (REWRITE)
             (IMPLIES (AND (RUN-INPUTS-P INPUTS N)
                           (NOT (ZEROP N)))
                      (RUN-INPUTS-P INPUTS 1))
             ((ENABLE RUN-INPUTS-P)))

(PROVE-LEMMA OPEN-RUN-INPUTS-P-ADD1
             (REWRITE)
             (EQUAL (RUN-INPUTS-P INPUTS (ADD1 N))
                    (AND (EQUAL (RESET--INPUT (CAR INPUTS)) T)
                         (PROPERP (PC-REG-INPUT (CAR INPUTS)))
                         (EQUAL (LENGTH (PC-REG-INPUT (CAR INPUTS)))
                                4)
                         (RUN-INPUTS-P (CDR INPUTS) N)))
             ((ENABLE RUN-INPUTS-P)))

(DEFN REGFILE-OKP
      (REGS)
      (AND (EQUAL (LENGTH REGS) 4)
           (MEMORY-OKP 4 32 (CAR REGS))
           (ALL-RAMP-MEM 4 (CAR REGS))
           (BOOLP (CADR REGS))
           (AND (BVP (CADDR REGS))
                (EQUAL (LENGTH (CADDR REGS)) 32))
           (BVP (CADDDR REGS))
           (EQUAL (LENGTH (CADDDR REGS)) 4)))

(PROVE-LEMMA REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
 (REWRITE)
 (IMPLIES
  (AND (BVP FLAGS)
       (BVP A-REG)
       (BVP B-REG)
       (BVP I-REG)
       (BVP DATA-OUT)
       (BVP ADDR-OUT)
       (BOOLP LAST-RESET-)
       (BOOLP LAST-DTACK-)
       (BOOLP LAST-HOLD-)
       (BVP LAST-PC-REG)
       (BVP CNTL-STATE))
  (EQUAL
   (FM9001-NEXT-STATE (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                  ADDR-OUT LAST-RESET- LAST-DTACK- LAST-HOLD-
                                  LAST-PC-REG CNTL-STATE)
                            MEM-STATE)
                      EXTERNAL-INPUTS)
   (LIST
    (LIST
     (F$WRITE-REGS (WE-REGS CNTL-STATE)
                   (REGS-ADDRESS CNTL-STATE)
                   REGS
                   (BV (F$CORE-ALU (ALU-C CNTL-STATE)
                                   A-REG B-REG
                                   (ALU-ZERO CNTL-STATE)
                                   (ALU-MPG CNTL-STATE)
                                   (ALU-OP CNTL-STATE)
                                   (MAKE-TREE 32))))
     (F$UPDATE-FLAGS FLAGS
                     (WE-FLAGS CNTL-STATE)
                     (F$CORE-ALU (ALU-C CNTL-STATE)
                                 A-REG B-REG
                                 (ALU-ZERO CNTL-STATE)
                                 (ALU-MPG CNTL-STATE)
                                 (ALU-OP CNTL-STATE)
                                 (MAKE-TREE 32)))
     (FV-IF
      (WE-A-REG CNTL-STATE)
      (FV-IF
       (F-NAND (DATA-IN-SELECT CNTL-STATE)
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE CNTL-STATE)
                           (A-IMMEDIATE I-REG)
                           (F$READ-REGS (REGS-ADDRESS CNTL-STATE)
                                        REGS))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
              (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                       DATA-OUT)
              (CDR (MEMORY-VALUE MEM-STATE
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (STROBE- CNTL-STATE)))
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (F-BUF (RW- CNTL-STATE))))
                                 (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                    ADDR-OUT))
                                 (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                  DATA-OUT))))
      A-REG)
     (FV-IF
      (WE-B-REG CNTL-STATE)
      (FV-IF
       (F-NAND (DATA-IN-SELECT CNTL-STATE)
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE CNTL-STATE)
                           (A-IMMEDIATE I-REG)
                           (F$READ-REGS (REGS-ADDRESS CNTL-STATE)
                                        REGS))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
              (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                       DATA-OUT)
              (CDR (MEMORY-VALUE MEM-STATE
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (STROBE- CNTL-STATE)))
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (F-BUF (RW- CNTL-STATE))))
                                 (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                    ADDR-OUT))
                                 (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                  DATA-OUT))))
      B-REG)
     (FV-IF
      (WE-I-REG CNTL-STATE)
      (FV-IF
       (F-NAND (DATA-IN-SELECT CNTL-STATE)
               (F-NOT LAST-DTACK-))
       (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE CNTL-STATE)
                           (A-IMMEDIATE I-REG)
                           (F$READ-REGS (REGS-ADDRESS CNTL-STATE)
                                        REGS))
       (V-THREEFIX
        (V-WIRE
         (V-PULLUP
          (V-WIRE
              (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                       DATA-OUT)
              (CDR (MEMORY-VALUE MEM-STATE
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (STROBE- CNTL-STATE)))
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (F-BUF (RW- CNTL-STATE))))
                                 (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                    ADDR-OUT))
                                 (MAKE-LIST 32 (X))))))
         (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                  DATA-OUT))))
      I-REG)
     (FV-IF (WE-DATA-OUT CNTL-STATE)
            (BV (F$CORE-ALU (ALU-C CNTL-STATE)
                            A-REG B-REG
                            (ALU-ZERO CNTL-STATE)
                            (ALU-MPG CNTL-STATE)
                            (ALU-OP CNTL-STATE)
                            (MAKE-TREE 32)))
            DATA-OUT)
     (FV-IF
         (WE-ADDR-OUT CNTL-STATE)
         (F$DEC-PASS (DEC-ADDR-OUT CNTL-STATE)
                     (F$EXTEND-IMMEDIATE (SELECT-IMMEDIATE CNTL-STATE)
                                         (A-IMMEDIATE I-REG)
                                         (F$READ-REGS (REGS-ADDRESS CNTL-STATE)
                                                      REGS)))
         ADDR-OUT)
     (F-BUF (RESET--INPUT EXTERNAL-INPUTS))
     (F-OR
       (STROBE- CNTL-STATE)
       (F-BUF (CAR (MEMORY-VALUE MEM-STATE
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (STROBE- CNTL-STATE)))
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (F-BUF (RW- CNTL-STATE))))
                                 (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                    ADDR-OUT))
                                 (MAKE-LIST 32 (X))))))
     (F-IF (WE-HOLD- CNTL-STATE)
           (F-BUF (HOLD--INPUT EXTERNAL-INPUTS))
           LAST-HOLD-)
     (FV-IF (WE-PC-REG CNTL-STATE)
            (PC-REG-INPUT EXTERNAL-INPUTS)
            LAST-PC-REG)
     (V-THREEFIX (F$NEXT-CNTL-STATE LAST-RESET- LAST-DTACK- LAST-HOLD-
                                    (RW- CNTL-STATE)
                                    (STATE CNTL-STATE)
                                    I-REG FLAGS LAST-PC-REG
                                    (REGS-ADDRESS CNTL-STATE))))
    (NEXT-MEMORY-STATE MEM-STATE
     (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                       (STROBE- CNTL-STATE)))
     (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                       (F-BUF (RW- CNTL-STATE))))
     (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                        ADDR-OUT))
     (V-PULLUP
      (V-WIRE (VFT-BUF (F-NOT (F-BUF (RW- CNTL-STATE)))
                       DATA-OUT)
              (CDR (MEMORY-VALUE MEM-STATE
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (STROBE- CNTL-STATE)))
                                 (F-PULLUP (FT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                   (F-BUF (RW- CNTL-STATE))))
                                 (V-PULLUP (VFT-BUF (F-BUF (HDACK- CNTL-STATE))
                                                    ADDR-OUT))
                                 (MAKE-LIST 32 (X))))))))))
 ((ENABLE FM9001-NEXT-STATE BOOLP-B-GATES OPEN-NTH)
  (ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE *1*MAKE-LIST)
  (DISABLE-THEORY F-GATES)))

(PROVE-LEMMA FETCH0$STEP0
 (REWRITE)
 (IMPLIES
      (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
           (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
           (MEMORY-OKP 32 32 MEM)
           (REGFILE-OKP REGS)
           (BVP A-REG)
           (EQUAL (LENGTH A-REG) 32)
           (BVP B-REG)
           (EQUAL (LENGTH B-REG) 32)
           (BVP ADDR-OUT)
           (EQUAL (LENGTH ADDR-OUT) 32)
           (BVP DATA-OUT)
           (EQUAL (LENGTH DATA-OUT) 32)
           (NOT (ZEROP N))
           (RUN-INPUTS-P INPUTS 1)
           (BOOLP DTACK-)
           (BOOLP HOLD-)
           (EQUAL RESET- T)
           NIL)
      (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                     ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                     (CV_FETCH0 T LAST-REGS-ADDRESS
                                                LAST-I-REG LAST-FLAGS
                                                LAST-PC-REG))
                               (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                     LAST-ADDRESS LAST-DATA))
                         INPUTS N)
             (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS LAST-PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS LAST-PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T LAST-PC-REG I-REG FLAGS
                                                PC-REG))
                               (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                     (V-THREEFIX LAST-DATA)))
                         (CDR INPUTS)
                         (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH0$STEP1
 (REWRITE)
 (IMPLIES
      (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
           (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
           (MEMORY-OKP 32 32 MEM)
           (REGFILE-OKP REGS)
           (BVP A-REG)
           (EQUAL (LENGTH A-REG) 32)
           (BVP B-REG)
           (EQUAL (LENGTH B-REG) 32)
           (BVP ADDR-OUT)
           (EQUAL (LENGTH ADDR-OUT) 32)
           (BVP DATA-OUT)
           (EQUAL (LENGTH DATA-OUT) 32)
           (NOT (ZEROP N))
           (RUN-INPUTS-P INPUTS 1)
           (BOOLP DTACK-)
           (BOOLP HOLD-)
           (EQUAL RESET- T)
           NIL)
      (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                     ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                     (CV_FETCH0 T LAST-REGS-ADDRESS
                                                LAST-I-REG LAST-FLAGS
                                                LAST-PC-REG))
                               (LIST MEM 1 CLOCK MEM-COUNT MEM-DTACK T
                                     LAST-ADDRESS LAST-DATA))
                         INPUTS N)
             (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS LAST-PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS LAST-PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T LAST-PC-REG I-REG FLAGS
                                                PC-REG))
                               (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                     (V-THREEFIX LAST-DATA)))
                         (CDR INPUTS)
                         (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH0$STEP2
 (REWRITE)
 (IMPLIES
      (AND (CV-HYPS F LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
           (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
           (MEMORY-OKP 32 32 MEM)
           (REGFILE-OKP REGS)
           (BVP A-REG)
           (EQUAL (LENGTH A-REG) 32)
           (BVP B-REG)
           (EQUAL (LENGTH B-REG) 32)
           (BVP ADDR-OUT)
           (EQUAL (LENGTH ADDR-OUT) 32)
           (BVP DATA-OUT)
           (EQUAL (LENGTH DATA-OUT) 32)
           (NOT (ZEROP N))
           (RUN-INPUTS-P INPUTS 1)
           (BOOLP DTACK-)
           (BOOLP HOLD-)
           (EQUAL RESET- T)
           (ZEROP MEM-COUNT))
      (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                     ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                     (CV_FETCH0 F LAST-REGS-ADDRESS
                                                LAST-I-REG LAST-FLAGS
                                                LAST-PC-REG))
                               (LIST MEM 2 CLOCK MEM-COUNT MEM-DTACK F
                                     ADDR-OUT DATA-OUT))
                         INPUTS N)
             (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS LAST-PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS LAST-PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T LAST-PC-REG I-REG FLAGS
                                                PC-REG))
                               (LIST (WRITE-MEM ADDR-OUT MEM DATA-OUT)
                                     0 CLOCK 0 T F ADDR-OUT DATA-OUT))
                         (CDR INPUTS)
                         (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH1$STEP
           (REWRITE)
           (IMPLIES (AND (CV-HYPS LAST-RW- LAST-REGS-ADDRESS LAST-I-REG
                                  LAST-FLAGS LAST-PC-REG)
                         (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (NOT (ZEROP N))
                         (RUN-INPUTS-P INPUTS 1)
                         (BOOLP DTACK-)
                         (BOOLP HOLD-)
                         (EQUAL RESET- T)
                         (BOOLP LAST-RW-))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT
                                                   RESET- DTACK- HOLD- PC-REG
                                                   (CV_FETCH1 LAST-RW-
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              LAST-PC-REG))
                                             (LIST MEM 0 CLOCK MEM-COUNT
                                                   MEM-DTACK LAST-RW-
                                                   LAST-ADDRESS LAST-DATA))
                                       INPUTS N)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG B-REG I-REG
                                                   DATA-OUT ADDR-OUT T T HOLD-
                                                   PC-REG
                                                   (IF* HOLD-
                                                        (CV_FETCH2 T
                                                                   LAST-PC-REG
                                                                   I-REG FLAGS
                                                                   PC-REG)
                                                        (CV_HOLD0 T
                                                                  LAST-PC-REG
                                                                  I-REG
                                                                  FLAGS
                                                                  PC-REG)))
                                             (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N))))
           ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
            (DISABLE-THEORY F-GATES)
            (ENABLE RUN-FM9001-STEP-CASE
                    REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                    NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH1$DESTRUCTURE
                    OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
            (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH2$STEP
         (REWRITE)
         (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                LAST-PC-REG)
                       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                       (MEMORY-OKP 32 32 MEM)
                       (REGFILE-OKP REGS)
                       (BVP A-REG)
                       (EQUAL (LENGTH A-REG) 32)
                       (BVP B-REG)
                       (EQUAL (LENGTH B-REG) 32)
                       (BVP ADDR-OUT)
                       (EQUAL (LENGTH ADDR-OUT) 32)
                       (BVP DATA-OUT)
                       (EQUAL (LENGTH DATA-OUT) 32)
                       (NOT (ZEROP N))
                       (RUN-INPUTS-P INPUTS 1)
                       (BOOLP DTACK-)
                       (BOOLP HOLD-)
                       (EQUAL RESET- T)
                       NIL)
                  (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                 DATA-OUT ADDR-OUT RESET-
                                                 DTACK- HOLD- PC-REG
                                                 (CV_FETCH2 T
                                                            LAST-REGS-ADDRESS
                                                            LAST-I-REG
                                                            LAST-FLAGS
                                                            LAST-PC-REG))
                                           (LIST MEM 0 CLOCK MEM-COUNT
                                                 MEM-DTACK T ADDR-OUT
                                                 LAST-DATA))
                                     INPUTS N)
                         (IF (ZEROP (CAR CLOCK))
                             (RUN-FM9001 (LIST (LIST (WRITE-REGS T LAST-PC-REG
                                                                 REGS
                                                                 (V-INC A-REG))
                                                     FLAGS A-REG B-REG I-REG
                                                     DATA-OUT ADDR-OUT T F
                                                     HOLD- PC-REG
                                                     (CV_FETCH3 T LAST-PC-REG
                                                                I-REG FLAGS
                                                                PC-REG))
                                               (LIST MEM 1
                                                     (CDR CLOCK)
                                                     0 T T ADDR-OUT
                                                     (V-THREEFIX LAST-DATA)))
                                         (CDR INPUTS)
                                         (SUB1 N))
                             (RUN-FM9001 (LIST (LIST (WRITE-REGS T LAST-PC-REG
                                                                 REGS
                                                                 (V-INC A-REG))
                                                     FLAGS A-REG B-REG I-REG
                                                     DATA-OUT ADDR-OUT T T
                                                     HOLD- PC-REG
                                                     (CV_FETCH3 T LAST-PC-REG
                                                                I-REG FLAGS
                                                                PC-REG))
                                               (LIST MEM 1
                                                     (CDR CLOCK)
                                                     (SUB1 (CAR CLOCK))
                                                     F T ADDR-OUT
                                                     (V-THREEFIX LAST-DATA)))
                                         (CDR INPUTS)
                                         (SUB1 N)))))
         ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
          (DISABLE-THEORY F-GATES)
          (ENABLE RUN-FM9001-STEP-CASE
                  REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                  NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH2$DESTRUCTURE
                  OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
          (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH3$STEP0
           (REWRITE)
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  LAST-PC-REG)
                         (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (NOT (ZEROP N))
                         (RUN-INPUTS-P INPUTS 1)
                         (BOOLP F)
                         (BOOLP HOLD-)
                         (EQUAL RESET- T)
                         (ZEROP MEM-COUNT))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT
                                                   RESET- F HOLD- PC-REG
                                                   (CV_FETCH3 T
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              LAST-PC-REG))
                                             (LIST MEM 1 CLOCK MEM-COUNT T T
                                                   ADDR-OUT LAST-DATA))
                                       INPUTS N)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG B-REG
                                                   (READ-MEM ADDR-OUT MEM)
                                                   DATA-OUT ADDR-OUT T F HOLD-
                                                   PC-REG
                                                   (CV_DECODE T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N))))
           ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
            (DISABLE-THEORY F-GATES)
            (ENABLE RUN-FM9001-STEP-CASE
                    REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                    NEXT-MEMORY-STATE MEMORY-VALUE CV_FETCH3$DESTRUCTURE
                    OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
            (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA FETCH3$STEP1
       (REWRITE)
       (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                              LAST-PC-REG)
                     (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                     (MEMORY-OKP 32 32 MEM)
                     (REGFILE-OKP REGS)
                     (BVP A-REG)
                     (EQUAL (LENGTH A-REG) 32)
                     (BVP B-REG)
                     (EQUAL (LENGTH B-REG) 32)
                     (BVP ADDR-OUT)
                     (EQUAL (LENGTH ADDR-OUT) 32)
                     (BVP DATA-OUT)
                     (EQUAL (LENGTH DATA-OUT) 32)
                     (NOT (ZEROP N))
                     (RUN-INPUTS-P INPUTS 1)
                     (BOOLP T)
                     (BOOLP HOLD-)
                     (EQUAL RESET- T)
                     NIL)
                (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT RESET- T
                                               HOLD- PC-REG
                                               (CV_FETCH3 T LAST-REGS-ADDRESS
                                                          LAST-I-REG
                                                          LAST-FLAGS
                                                          LAST-PC-REG))
                                         (LIST MEM 1 CLOCK MEM-COUNT F T
                                               ADDR-OUT LAST-DATA))
                                   INPUTS N)
                       (IF (ZEROP MEM-COUNT)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG B-REG
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   DATA-OUT ADDR-OUT T F HOLD-
                                                   PC-REG
                                                   (CV_FETCH3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N))
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG B-REG
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   DATA-OUT ADDR-OUT T T HOLD-
                                                   PC-REG
                                                   (CV_FETCH3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK
                                                   (SUB1 MEM-COUNT)
                                                   F T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N)))))
       ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
        (DISABLE-THEORY F-GATES)
        (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
                BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE
                CV_FETCH3$DESTRUCTURE OPEN-NTH BVP-LENGTH-STATE-VECTORS
                BVP-CV-VECTORS)
        (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA DECODE$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_DECODE T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 1 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS N)
   (RUN-FM9001
             (LIST (LIST (WRITE-REGS F 0 REGS 0)
                         FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD-
                         PC-REG
                         (IF* (OR* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                   (SET-SOME-FLAGS (SET-FLAGS I-REG)))
                              (IF* (OR* (A-IMMEDIATE-P I-REG)
                                        (REG-DIRECT-P (MODE-A I-REG)))
                                   (IF* (OR* (REG-DIRECT-P (MODE-B I-REG))
                                             (UNARY-OP-CODE-P (OP-CODE I-REG)))
                                        (CV_REGA T LAST-PC-REG I-REG FLAGS
                                                 PC-REG)
                                        (CV_READB0 T LAST-PC-REG I-REG FLAGS
                                                   PC-REG))
                                   (CV_READA0 T LAST-PC-REG I-REG FLAGS
                                              PC-REG))
                              (IF* (AND* (NOT* (A-IMMEDIATE-P I-REG))
                                         (OR* (PRE-DEC-P (MODE-A I-REG))
                                              (POST-INC-P (MODE-A I-REG))))
                                   (CV_SEFA0 T LAST-PC-REG I-REG FLAGS PC-REG)
                                   (IF* (OR* (PRE-DEC-P (MODE-B I-REG))
                                             (POST-INC-P (MODE-B I-REG)))
                                        (CV_SEFB0 T LAST-PC-REG I-REG FLAGS
                                                  PC-REG)
                                        (CV_FETCH0 T LAST-PC-REG I-REG
                                                   FLAGS PC-REG)))))
                   (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                         (V-THREEFIX LAST-DATA)))
             (CDR INPUTS)
             (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_DECODE$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA REGA$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
       (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                               RESET- DTACK- HOLD- PC-REG
                               (CV_REGA T LAST-REGS-ADDRESS LAST-I-REG
                                        LAST-FLAGS LAST-PC-REG))
                         (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                               LAST-DATA))
                   INPUTS N)
       (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                               FLAGS
                               (IF* (A-IMMEDIATE-P LAST-I-REG)
                                    (SIGN-EXTEND (A-IMMEDIATE I-REG) 32)
                                    (READ-REGS (RN-A LAST-I-REG) REGS))
                               B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
                               (IF* (REG-DIRECT-P (MODE-B I-REG))
                                    (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
                                         (CV_UPDATE T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG)
                                         (CV_REGB T
                                                  (RN-A LAST-I-REG)
                                                  I-REG FLAGS PC-REG))
                                    (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                         (CV_WRITE0 T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG)
                                         (CV_UPDATE T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG))))
                         (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                               (V-THREEFIX LAST-DATA)))
                   (CDR INPUTS)
                   (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_REGA$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA REGB$STEP
     (REWRITE)
     (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                            LAST-PC-REG)
                   (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                   (MEMORY-OKP 32 32 MEM)
                   (REGFILE-OKP REGS)
                   (BVP A-REG)
                   (EQUAL (LENGTH A-REG) 32)
                   (BVP B-REG)
                   (EQUAL (LENGTH B-REG) 32)
                   (BVP ADDR-OUT)
                   (EQUAL (LENGTH ADDR-OUT) 32)
                   (BVP DATA-OUT)
                   (EQUAL (LENGTH DATA-OUT) 32)
                   (NOT (ZEROP N))
                   (RUN-INPUTS-P INPUTS 1)
                   (BOOLP DTACK-)
                   (BOOLP HOLD-)
                   (EQUAL RESET- T)
                   NIL)
              (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                             DATA-OUT ADDR-OUT RESET- DTACK-
                                             HOLD- PC-REG
                                             (CV_REGB T LAST-REGS-ADDRESS
                                                      LAST-I-REG LAST-FLAGS
                                                      LAST-PC-REG))
                                       (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK
                                             T LAST-ADDRESS LAST-DATA))
                                 INPUTS N)
                     (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                             FLAGS A-REG
                                             (READ-REGS (RN-B LAST-I-REG) REGS)
                                             I-REG DATA-OUT ADDR-OUT T T HOLD-
                                             PC-REG
                                             (CV_UPDATE T
                                                        (RN-B LAST-I-REG)
                                                        I-REG FLAGS PC-REG))
                                       (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                             (V-THREEFIX LAST-DATA)))
                                 (CDR INPUTS)
                                 (SUB1 N))))
     ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
      (DISABLE-THEORY F-GATES)
      (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
              BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_REGB$DESTRUCTURE
              OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
      (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA UPDATE$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       (OR (EQUAL MEM-STATE 0)
           (EQUAL MEM-STATE 1)))
  (EQUAL
       (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                               RESET- DTACK- HOLD- PC-REG
                               (CV_UPDATE T LAST-REGS-ADDRESS LAST-I-REG
                                          LAST-FLAGS LAST-PC-REG))
                         (LIST MEM MEM-STATE CLOCK MEM-COUNT MEM-DTACK T
                               LAST-ADDRESS LAST-DATA))
                   INPUTS N)
       (RUN-FM9001 (LIST (LIST (WRITE-REGS (STORE-RESULTP (STORE-CC LAST-I-REG)
                                                          LAST-FLAGS)
                                           (RN-B LAST-I-REG)
                                           REGS
                                           (BV (V-ALU (C-FLAG LAST-FLAGS)
                                                      A-REG B-REG
                                                      (OP-CODE LAST-I-REG))))
                               (UPDATE-FLAGS FLAGS
                                             (SET-FLAGS LAST-I-REG)
                                             (V-ALU (C-FLAG LAST-FLAGS)
                                                    A-REG B-REG
                                                    (OP-CODE LAST-I-REG)))
                               A-REG
                               (READ-REGS (RN-B LAST-I-REG) REGS)
                               I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
                               (IF* (AND* (OR* (PRE-DEC-P (MODE-B I-REG))
                                               (POST-INC-P (MODE-B I-REG)))
                                          (UNARY-OP-CODE-P (OP-CODE I-REG)))
                                    (CV_SEFB1 T
                                              (RN-B LAST-I-REG)
                                              I-REG FLAGS PC-REG)
                                    (CV_FETCH0 T
                                               (RN-B LAST-I-REG)
                                               I-REG FLAGS PC-REG)))
                         (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                               (V-THREEFIX LAST-DATA)))
                   (CDR INPUTS)
                   (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_UPDATE$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READA0$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
        (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                                RESET- DTACK- HOLD- PC-REG
                                (CV_READA0 T LAST-REGS-ADDRESS LAST-I-REG
                                           LAST-FLAGS LAST-PC-REG))
                          (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                LAST-ADDRESS LAST-DATA))
                    INPUTS N)
        (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                FLAGS
                                (READ-REGS (RN-A LAST-I-REG) REGS)
                                B-REG I-REG DATA-OUT
                                (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                     (V-DEC (READ-REGS (RN-A LAST-I-REG) REGS))
                                     (READ-REGS (RN-A LAST-I-REG) REGS))
                                T T HOLD- PC-REG
                                (CV_READA1 T
                                           (RN-A LAST-I-REG)
                                           I-REG FLAGS PC-REG))
                          (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                (V-THREEFIX LAST-DATA)))
                    (CDR INPUTS)
                    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READA0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READA1$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_READA1 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS N)
   (RUN-FM9001
    (LIST
     (LIST
      (WRITE-REGS
               (AND* (NOT* (A-IMMEDIATE-P LAST-I-REG))
                     (OR* (PRE-DEC-P (MODE-A LAST-I-REG))
                          (POST-INC-P (MODE-A LAST-I-REG))))
               (RN-A LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
      (CV_READA2 T
                 (RN-A LAST-I-REG)
                 I-REG FLAGS PC-REG))
     (LIST MEM 0 CLOCK 0 T T ADDR-OUT
           (V-THREEFIX LAST-DATA)))
    (CDR INPUTS)
    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READA1$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READA2$STEP
 (REWRITE)
 (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
               (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
               (MEMORY-OKP 32 32 MEM)
               (REGFILE-OKP REGS)
               (BVP A-REG)
               (EQUAL (LENGTH A-REG) 32)
               (BVP B-REG)
               (EQUAL (LENGTH B-REG) 32)
               (BVP ADDR-OUT)
               (EQUAL (LENGTH ADDR-OUT) 32)
               (BVP DATA-OUT)
               (EQUAL (LENGTH DATA-OUT) 32)
               (NOT (ZEROP N))
               (RUN-INPUTS-P INPUTS 1)
               (BOOLP DTACK-)
               (BOOLP HOLD-)
               (EQUAL RESET- T)
               NIL)
          (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                         ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                         (CV_READA2 T LAST-REGS-ADDRESS
                                                    LAST-I-REG LAST-FLAGS
                                                    LAST-PC-REG))
                                   (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                         ADDR-OUT LAST-DATA))
                             INPUTS N)
                 (IF (ZEROP (CAR CLOCK))
                     (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                             FLAGS A-REG
                                             (READ-REGS (RN-B LAST-I-REG) REGS)
                                             I-REG DATA-OUT ADDR-OUT T F HOLD-
                                             PC-REG
                                             (CV_READA3 T
                                                        (RN-B LAST-I-REG)
                                                        I-REG FLAGS PC-REG))
                                       (LIST MEM 1
                                             (CDR CLOCK)
                                             0 T T ADDR-OUT
                                             (V-THREEFIX LAST-DATA)))
                                 (CDR INPUTS)
                                 (SUB1 N))
                     (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                             FLAGS A-REG
                                             (READ-REGS (RN-B LAST-I-REG) REGS)
                                             I-REG DATA-OUT ADDR-OUT T T HOLD-
                                             PC-REG
                                             (CV_READA3 T
                                                        (RN-B LAST-I-REG)
                                                        I-REG FLAGS PC-REG))
                                       (LIST MEM 1
                                             (CDR CLOCK)
                                             (SUB1 (CAR CLOCK))
                                             F T ADDR-OUT
                                             (V-THREEFIX LAST-DATA)))
                                 (CDR INPUTS)
                                 (SUB1 N)))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READA2$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READA3$STEP0
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP F)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       (ZEROP MEM-COUNT))
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- F HOLD- PC-REG
                           (CV_READA3 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 1 CLOCK MEM-COUNT T T ADDR-OUT LAST-DATA))
               INPUTS N)
   (RUN-FM9001
              (LIST (LIST (WRITE-REGS F 0 REGS 0)
                          FLAGS
                          (READ-MEM ADDR-OUT MEM)
                          B-REG I-REG DATA-OUT ADDR-OUT T F HOLD- PC-REG
                          (IF* (REG-DIRECT-P (MODE-B I-REG))
                               (CV_UPDATE T LAST-PC-REG I-REG FLAGS PC-REG)
                               (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
                                    (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                         (CV_WRITE0 T LAST-PC-REG I-REG FLAGS
                                                    PC-REG)
                                         (CV_UPDATE T LAST-PC-REG I-REG FLAGS
                                                    PC-REG))
                                    (CV_READB0 T LAST-PC-REG I-REG FLAGS
                                               PC-REG))))
                    (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                          (V-THREEFIX LAST-DATA)))
              (CDR INPUTS)
              (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READA3$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READA3$STEP1
       (REWRITE)
       (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                              LAST-PC-REG)
                     (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                     (MEMORY-OKP 32 32 MEM)
                     (REGFILE-OKP REGS)
                     (BVP A-REG)
                     (EQUAL (LENGTH A-REG) 32)
                     (BVP B-REG)
                     (EQUAL (LENGTH B-REG) 32)
                     (BVP ADDR-OUT)
                     (EQUAL (LENGTH ADDR-OUT) 32)
                     (BVP DATA-OUT)
                     (EQUAL (LENGTH DATA-OUT) 32)
                     (NOT (ZEROP N))
                     (RUN-INPUTS-P INPUTS 1)
                     (BOOLP T)
                     (BOOLP HOLD-)
                     (EQUAL RESET- T)
                     NIL)
                (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT RESET- T
                                               HOLD- PC-REG
                                               (CV_READA3 T LAST-REGS-ADDRESS
                                                          LAST-I-REG
                                                          LAST-FLAGS
                                                          LAST-PC-REG))
                                         (LIST MEM 1 CLOCK MEM-COUNT F T
                                               ADDR-OUT LAST-DATA))
                                   INPUTS N)
                       (IF (ZEROP MEM-COUNT)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   B-REG I-REG DATA-OUT
                                                   ADDR-OUT T F HOLD- PC-REG
                                                   (CV_READA3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N))
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   B-REG I-REG DATA-OUT
                                                   ADDR-OUT T T HOLD- PC-REG
                                                   (CV_READA3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK
                                                   (SUB1 MEM-COUNT)
                                                   F T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N)))))
       ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
        (DISABLE-THEORY F-GATES)
        (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
                BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE
                CV_READA3$DESTRUCTURE OPEN-NTH BVP-LENGTH-STATE-VECTORS
                BVP-CV-VECTORS)
        (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READB0$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       (OR (EQUAL MEM-STATE 0)
           (EQUAL MEM-STATE 1)))
  (EQUAL
        (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                                RESET- DTACK- HOLD- PC-REG
                                (CV_READB0 T LAST-REGS-ADDRESS LAST-I-REG
                                           LAST-FLAGS LAST-PC-REG))
                          (LIST MEM MEM-STATE CLOCK MEM-COUNT MEM-DTACK T
                                LAST-ADDRESS LAST-DATA))
                    INPUTS N)
        (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                FLAGS A-REG
                                (READ-REGS (RN-B LAST-I-REG) REGS)
                                I-REG DATA-OUT
                                (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                     (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
                                     (READ-REGS (RN-B LAST-I-REG) REGS))
                                T T HOLD- PC-REG
                                (CV_READB1 T
                                           (RN-B LAST-I-REG)
                                           I-REG FLAGS PC-REG))
                          (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                (V-THREEFIX LAST-DATA)))
                    (CDR INPUTS)
                    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READB0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READB1$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                 ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                 (CV_READB1 T LAST-REGS-ADDRESS LAST-I-REG
                                            LAST-FLAGS LAST-PC-REG))
                           (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                 LAST-ADDRESS LAST-DATA))
                     INPUTS N)
         (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                 FLAGS
                                 (IF* (OR* (A-IMMEDIATE-P LAST-I-REG)
                                           (REG-DIRECT-P (MODE-A LAST-I-REG)))
                                      (IF* (A-IMMEDIATE-P LAST-I-REG)
                                           (SIGN-EXTEND (A-IMMEDIATE I-REG) 32)
                                           (READ-REGS (RN-A LAST-I-REG) REGS))
                                      A-REG)
                                 B-REG I-REG DATA-OUT ADDR-OUT T T HOLD-
                                 PC-REG
                                 (CV_READB2 T
                                            (RN-A LAST-I-REG)
                                            I-REG FLAGS PC-REG))
                           (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                 (V-THREEFIX LAST-DATA)))
                     (CDR INPUTS)
                     (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READB1$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READB2$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_READB2 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T ADDR-OUT
                           LAST-DATA))
               INPUTS N)
   (IF
    (ZEROP (CAR CLOCK))
    (RUN-FM9001
     (LIST
      (LIST
       (WRITE-REGS
               (AND* (NOT* (STORE-RESULTP (STORE-CC LAST-I-REG)
                                          LAST-FLAGS))
                     (OR* (PRE-DEC-P (MODE-B LAST-I-REG))
                          (POST-INC-P (MODE-B LAST-I-REG))))
               (RN-B LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
       FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T F HOLD- PC-REG
       (CV_READB3 T
                  (RN-B LAST-I-REG)
                  I-REG FLAGS PC-REG))
      (LIST MEM 1
            (CDR CLOCK)
            0 T T ADDR-OUT
            (V-THREEFIX LAST-DATA)))
     (CDR INPUTS)
     (SUB1 N))
    (RUN-FM9001
     (LIST
      (LIST
       (WRITE-REGS
               (AND* (NOT* (STORE-RESULTP (STORE-CC LAST-I-REG)
                                          LAST-FLAGS))
                     (OR* (PRE-DEC-P (MODE-B LAST-I-REG))
                          (POST-INC-P (MODE-B LAST-I-REG))))
               (RN-B LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
       FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
       (CV_READB3 T
                  (RN-B LAST-I-REG)
                  I-REG FLAGS PC-REG))
      (LIST MEM 1
            (CDR CLOCK)
            (SUB1 (CAR CLOCK))
            F T ADDR-OUT
            (V-THREEFIX LAST-DATA)))
     (CDR INPUTS)
     (SUB1 N)))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READB2$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READB3$STEP0
 (REWRITE)
 (IMPLIES
     (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
          (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
          (MEMORY-OKP 32 32 MEM)
          (REGFILE-OKP REGS)
          (BVP A-REG)
          (EQUAL (LENGTH A-REG) 32)
          (BVP B-REG)
          (EQUAL (LENGTH B-REG) 32)
          (BVP ADDR-OUT)
          (EQUAL (LENGTH ADDR-OUT) 32)
          (BVP DATA-OUT)
          (EQUAL (LENGTH DATA-OUT) 32)
          (NOT (ZEROP N))
          (RUN-INPUTS-P INPUTS 1)
          (BOOLP F)
          (BOOLP HOLD-)
          (EQUAL RESET- T)
          (ZEROP MEM-COUNT))
     (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                    ADDR-OUT RESET- F HOLD- PC-REG
                                    (CV_READB3 T LAST-REGS-ADDRESS LAST-I-REG
                                               LAST-FLAGS LAST-PC-REG))
                              (LIST MEM 1 CLOCK MEM-COUNT T T ADDR-OUT
                                    LAST-DATA))
                        INPUTS N)
            (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                    FLAGS A-REG
                                    (READ-MEM ADDR-OUT MEM)
                                    I-REG DATA-OUT ADDR-OUT T F HOLD- PC-REG
                                    (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                         (CV_WRITE0 T LAST-PC-REG I-REG FLAGS
                                                    PC-REG)
                                         (CV_UPDATE T LAST-PC-REG I-REG
                                                    FLAGS PC-REG)))
                              (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                    (V-THREEFIX LAST-DATA)))
                        (CDR INPUTS)
                        (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_READB3$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA READB3$STEP1
       (REWRITE)
       (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                              LAST-PC-REG)
                     (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                     (MEMORY-OKP 32 32 MEM)
                     (REGFILE-OKP REGS)
                     (BVP A-REG)
                     (EQUAL (LENGTH A-REG) 32)
                     (BVP B-REG)
                     (EQUAL (LENGTH B-REG) 32)
                     (BVP ADDR-OUT)
                     (EQUAL (LENGTH ADDR-OUT) 32)
                     (BVP DATA-OUT)
                     (EQUAL (LENGTH DATA-OUT) 32)
                     (NOT (ZEROP N))
                     (RUN-INPUTS-P INPUTS 1)
                     (BOOLP T)
                     (BOOLP HOLD-)
                     (EQUAL RESET- T)
                     NIL)
                (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT RESET- T
                                               HOLD- PC-REG
                                               (CV_READB3 T LAST-REGS-ADDRESS
                                                          LAST-I-REG
                                                          LAST-FLAGS
                                                          LAST-PC-REG))
                                         (LIST MEM 1 CLOCK MEM-COUNT F T
                                               ADDR-OUT LAST-DATA))
                                   INPUTS N)
                       (IF (ZEROP MEM-COUNT)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   I-REG DATA-OUT ADDR-OUT T F
                                                   HOLD- PC-REG
                                                   (CV_READB3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N))
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG
                                                   (READ-REGS LAST-PC-REG REGS)
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_READB3 T LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK
                                                   (SUB1 MEM-COUNT)
                                                   F T ADDR-OUT
                                                   (V-THREEFIX LAST-DATA)))
                                       (CDR INPUTS)
                                       (SUB1 N)))))
       ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
        (DISABLE-THEORY F-GATES)
        (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
                BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE
                CV_READB3$DESTRUCTURE OPEN-NTH BVP-LENGTH-STATE-VECTORS
                BVP-CV-VECTORS)
        (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA WRITE0$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       (OR (EQUAL MEM-STATE 0)
           (EQUAL MEM-STATE 1)))
  (EQUAL
        (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                                RESET- DTACK- HOLD- PC-REG
                                (CV_WRITE0 T LAST-REGS-ADDRESS LAST-I-REG
                                           LAST-FLAGS LAST-PC-REG))
                          (LIST MEM MEM-STATE CLOCK MEM-COUNT MEM-DTACK T
                                LAST-ADDRESS LAST-DATA))
                    INPUTS N)
        (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                (UPDATE-FLAGS FLAGS
                                              (SET-FLAGS LAST-I-REG)
                                              (V-ALU (C-FLAG LAST-FLAGS)
                                                     A-REG B-REG
                                                     (OP-CODE LAST-I-REG)))
                                A-REG
                                (READ-REGS (RN-B LAST-I-REG) REGS)
                                I-REG
                                (BV (V-ALU (C-FLAG LAST-FLAGS)
                                           A-REG B-REG
                                           (OP-CODE LAST-I-REG)))
                                (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                     (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
                                     (READ-REGS (RN-B LAST-I-REG) REGS))
                                T T HOLD- PC-REG
                                (CV_WRITE1 T
                                           (RN-B LAST-I-REG)
                                           I-REG FLAGS PC-REG))
                          (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                (V-THREEFIX LAST-DATA)))
                    (CDR INPUTS)
                    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_WRITE0$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA WRITE1$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_WRITE1 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS N)
   (RUN-FM9001
    (LIST
     (LIST
      (WRITE-REGS
               (OR* (PRE-DEC-P (MODE-B LAST-I-REG))
                    (POST-INC-P (MODE-B LAST-I-REG)))
               (RN-B LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
      (CV_WRITE2 F
                 (RN-B LAST-I-REG)
                 I-REG FLAGS PC-REG))
     (LIST MEM 0 CLOCK 0 T F ADDR-OUT DATA-OUT))
    (CDR INPUTS)
    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_WRITE1$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA WRITE2$STEP
           (REWRITE)
           (IMPLIES (AND (CV-HYPS F LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  LAST-PC-REG)
                         (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (NOT (ZEROP N))
                         (RUN-INPUTS-P INPUTS 1)
                         (BOOLP DTACK-)
                         (BOOLP HOLD-)
                         (EQUAL RESET- T)
                         NIL)
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT
                                                   RESET- DTACK- HOLD- PC-REG
                                                   (CV_WRITE2 F
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              LAST-PC-REG))
                                             (LIST MEM 0 CLOCK MEM-COUNT
                                                   MEM-DTACK F ADDR-OUT
                                                   DATA-OUT))
                                       INPUTS N)
                           (IF (ZEROP (CAR CLOCK))
                               (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                       FLAGS A-REG B-REG I-REG
                                                       DATA-OUT ADDR-OUT T F
                                                       HOLD- PC-REG
                                                       (CV_WRITE3 F
                                                                  LAST-PC-REG
                                                                  I-REG FLAGS
                                                                  PC-REG))
                                                 (LIST MEM 2
                                                       (CDR CLOCK)
                                                       0 T F ADDR-OUT
                                                       DATA-OUT))
                                           (CDR INPUTS)
                                           (SUB1 N))
                               (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                       FLAGS A-REG B-REG I-REG
                                                       DATA-OUT ADDR-OUT T T
                                                       HOLD- PC-REG
                                                       (CV_WRITE3 F
                                                                  LAST-PC-REG
                                                                  I-REG FLAGS
                                                                  PC-REG))
                                                 (LIST MEM 2
                                                       (CDR CLOCK)
                                                       (SUB1 (CAR CLOCK))
                                                       F F ADDR-OUT DATA-OUT))
                                           (CDR INPUTS)
                                           (SUB1 N)))))
           ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
            (DISABLE-THEORY F-GATES)
            (ENABLE RUN-FM9001-STEP-CASE
                    REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                    NEXT-MEMORY-STATE MEMORY-VALUE CV_WRITE2$DESTRUCTURE
                    OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
            (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA WRITE3$STEP0
           (REWRITE)
           (IMPLIES (AND (CV-HYPS F LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  LAST-PC-REG)
                         (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (NOT (ZEROP N))
                         (RUN-INPUTS-P INPUTS 1)
                         (BOOLP F)
                         (BOOLP HOLD-)
                         (EQUAL RESET- T)
                         (ZEROP MEM-COUNT))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT
                                                   RESET- F HOLD- PC-REG
                                                   (CV_WRITE3 F
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              LAST-PC-REG))
                                             (LIST MEM 2 CLOCK MEM-COUNT T F
                                                   ADDR-OUT DATA-OUT))
                                       INPUTS N)
                           (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                   FLAGS A-REG B-REG I-REG
                                                   DATA-OUT ADDR-OUT T F HOLD-
                                                   PC-REG
                                                   (CV_FETCH0 F LAST-PC-REG
                                                              I-REG FLAGS
                                                              PC-REG))
                                             (LIST MEM 2 CLOCK 0 T F ADDR-OUT
                                                   DATA-OUT))
                                       (CDR INPUTS)
                                       (SUB1 N))))
           ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
            (DISABLE-THEORY F-GATES)
            (ENABLE RUN-FM9001-STEP-CASE
                    REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                    NEXT-MEMORY-STATE MEMORY-VALUE CV_WRITE3$DESTRUCTURE
                    OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
            (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA WRITE3$STEP1
           (REWRITE)
           (IMPLIES (AND (CV-HYPS F LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  LAST-PC-REG)
                         (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (NOT (ZEROP N))
                         (RUN-INPUTS-P INPUTS 1)
                         (BOOLP T)
                         (BOOLP HOLD-)
                         (EQUAL RESET- T)
                         NIL)
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT
                                                   RESET- T HOLD- PC-REG
                                                   (CV_WRITE3 F
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              LAST-PC-REG))
                                             (LIST MEM 2 CLOCK MEM-COUNT F F
                                                   ADDR-OUT DATA-OUT))
                                       INPUTS N)
                           (IF (ZEROP MEM-COUNT)
                               (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                       FLAGS A-REG B-REG I-REG
                                                       DATA-OUT ADDR-OUT T F
                                                       HOLD- PC-REG
                                                       (CV_WRITE3 F
                                                                  LAST-PC-REG
                                                                  I-REG FLAGS
                                                                  PC-REG))
                                                 (LIST MEM 2 CLOCK 0 T F
                                                       ADDR-OUT DATA-OUT))
                                           (CDR INPUTS)
                                           (SUB1 N))
                               (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                                       FLAGS A-REG B-REG I-REG
                                                       DATA-OUT ADDR-OUT T T
                                                       HOLD- PC-REG
                                                       (CV_WRITE3 F
                                                                  LAST-PC-REG
                                                                  I-REG FLAGS
                                                                  PC-REG))
                                                 (LIST MEM 2 CLOCK
                                                       (SUB1 MEM-COUNT)
                                                       F F ADDR-OUT DATA-OUT))
                                           (CDR INPUTS)
                                           (SUB1 N)))))
           ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
            (DISABLE-THEORY F-GATES)
            (ENABLE RUN-FM9001-STEP-CASE
                    REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS BOOLP-B-GATES
                    NEXT-MEMORY-STATE MEMORY-VALUE CV_WRITE3$DESTRUCTURE
                    OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
            (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA SEFA0$STEP
     (REWRITE)
     (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                            LAST-PC-REG)
                   (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                   (MEMORY-OKP 32 32 MEM)
                   (REGFILE-OKP REGS)
                   (BVP A-REG)
                   (EQUAL (LENGTH A-REG) 32)
                   (BVP B-REG)
                   (EQUAL (LENGTH B-REG) 32)
                   (BVP ADDR-OUT)
                   (EQUAL (LENGTH ADDR-OUT) 32)
                   (BVP DATA-OUT)
                   (EQUAL (LENGTH DATA-OUT) 32)
                   (NOT (ZEROP N))
                   (RUN-INPUTS-P INPUTS 1)
                   (BOOLP DTACK-)
                   (BOOLP HOLD-)
                   (EQUAL RESET- T)
                   NIL)
              (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                             DATA-OUT ADDR-OUT RESET- DTACK-
                                             HOLD- PC-REG
                                             (CV_SEFA0 T LAST-REGS-ADDRESS
                                                       LAST-I-REG LAST-FLAGS
                                                       LAST-PC-REG))
                                       (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK
                                             T LAST-ADDRESS LAST-DATA))
                                 INPUTS N)
                     (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                             FLAGS
                                             (READ-REGS (RN-A LAST-I-REG) REGS)
                                             B-REG I-REG DATA-OUT ADDR-OUT T T
                                             HOLD- PC-REG
                                             (CV_SEFA1 T
                                                       (RN-A LAST-I-REG)
                                                       I-REG FLAGS PC-REG))
                                       (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                             (V-THREEFIX LAST-DATA)))
                                 (CDR INPUTS)
                                 (SUB1 N))))
     ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
      (DISABLE-THEORY F-GATES)
      (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
              BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE
              CV_SEFA0$DESTRUCTURE OPEN-NTH BVP-LENGTH-STATE-VECTORS
              BVP-CV-VECTORS)
      (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA SEFA1$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_SEFA1 T LAST-REGS-ADDRESS LAST-I-REG
                                     LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS N)
   (RUN-FM9001
    (LIST
     (LIST
      (WRITE-REGS T
               (RN-A LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
      (IF* (OR* (PRE-DEC-P (MODE-B I-REG))
                (POST-INC-P (MODE-B I-REG)))
           (CV_SEFB0 T
                     (RN-A LAST-I-REG)
                     I-REG FLAGS PC-REG)
           (CV_FETCH0 T
                      (RN-A LAST-I-REG)
                      I-REG FLAGS PC-REG)))
     (LIST MEM 0 CLOCK 0 T T ADDR-OUT
           (V-THREEFIX LAST-DATA)))
    (CDR INPUTS)
    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_SEFA1$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA SEFB0$STEP
     (REWRITE)
     (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                            LAST-PC-REG)
                   (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                   (MEMORY-OKP 32 32 MEM)
                   (REGFILE-OKP REGS)
                   (BVP A-REG)
                   (EQUAL (LENGTH A-REG) 32)
                   (BVP B-REG)
                   (EQUAL (LENGTH B-REG) 32)
                   (BVP ADDR-OUT)
                   (EQUAL (LENGTH ADDR-OUT) 32)
                   (BVP DATA-OUT)
                   (EQUAL (LENGTH DATA-OUT) 32)
                   (NOT (ZEROP N))
                   (RUN-INPUTS-P INPUTS 1)
                   (BOOLP DTACK-)
                   (BOOLP HOLD-)
                   (EQUAL RESET- T)
                   NIL)
              (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                             DATA-OUT ADDR-OUT RESET- DTACK-
                                             HOLD- PC-REG
                                             (CV_SEFB0 T LAST-REGS-ADDRESS
                                                       LAST-I-REG LAST-FLAGS
                                                       LAST-PC-REG))
                                       (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK
                                             T LAST-ADDRESS LAST-DATA))
                                 INPUTS N)
                     (RUN-FM9001 (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                             FLAGS A-REG
                                             (READ-REGS (RN-B LAST-I-REG) REGS)
                                             I-REG DATA-OUT ADDR-OUT T T HOLD-
                                             PC-REG
                                             (CV_SEFB1 T
                                                       (RN-B LAST-I-REG)
                                                       I-REG FLAGS PC-REG))
                                       (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                             (V-THREEFIX LAST-DATA)))
                                 (CDR INPUTS)
                                 (SUB1 N))))
     ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
      (DISABLE-THEORY F-GATES)
      (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
              BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE
              CV_SEFB0$DESTRUCTURE OPEN-NTH BVP-LENGTH-STATE-VECTORS
              BVP-CV-VECTORS)
      (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(PROVE-LEMMA SEFB1$STEP
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (NOT (ZEROP N))
       (RUN-INPUTS-P INPUTS 1)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_SEFB1 T LAST-REGS-ADDRESS LAST-I-REG
                                     LAST-FLAGS LAST-PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS N)
   (RUN-FM9001
    (LIST
     (LIST
      (WRITE-REGS T
               (RN-B LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
      (CV_FETCH0 T
                 (RN-B LAST-I-REG)
                 I-REG FLAGS PC-REG))
     (LIST MEM 0 CLOCK 0 T T ADDR-OUT
           (V-THREEFIX LAST-DATA)))
    (CDR INPUTS)
    (SUB1 N))))
 ((ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY F-GATES)
  (ENABLE RUN-FM9001-STEP-CASE REWRITE-FM9001-NEXT-STATE-FOR-STEP-LEMMAS
          BOOLP-B-GATES NEXT-MEMORY-STATE MEMORY-VALUE CV_SEFB1$DESTRUCTURE
          OPEN-NTH BVP-LENGTH-STATE-VECTORS BVP-CV-VECTORS)
  (DISABLE MPG MAKE-TREE *1*MAKE-TREE *1*MAKE-LIST OPEN-V-THREEFIX)))

(DEFTHEORY FM9001-STEP-THEORY
           (SEFB1$STEP SEFB0$STEP SEFA1$STEP SEFA0$STEP WRITE3$STEP1
                       WRITE3$STEP0 WRITE2$STEP WRITE1$STEP WRITE0$STEP
                       READB3$STEP1 READB3$STEP0 READB2$STEP READB1$STEP
                       READB0$STEP READA3$STEP1 READA3$STEP0 READA2$STEP
                       READA1$STEP READA0$STEP UPDATE$STEP REGB$STEP REGA$STEP
                       DECODE$STEP FETCH3$STEP1 FETCH3$STEP0 FETCH2$STEP
                       FETCH1$STEP FETCH0$STEP2 FETCH0$STEP1 FETCH0$STEP0))

(DEFN READ-FN
      (REG0 REG1 N)
      (IF (ZEROP N)
          REG0
          (READ-FN REG1 REG1 (SUB1 N))))

(TOGGLE READ-FN-OFF READ-FN T)

(PROVE-LEMMA OPEN-READ-FN
             (REWRITE)
             (AND (IMPLIES (ZEROP N)
                           (EQUAL (READ-FN REG0 REG1 N) REG0))
                  (IMPLIES (NOT (ZEROP N))
                           (EQUAL (READ-FN REG0 REG1 N)
                                  (READ-FN REG1 REG1 (SUB1 N)))))
             ((ENABLE READ-FN)))

(PROVE-LEMMA LENGTH-READ-FN
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH REG0) 32)
                           (EQUAL (LENGTH REG1) 32))
                      (EQUAL (LENGTH (READ-FN REG0 REG1 N))
                             32))
             ((ENABLE READ-FN)))

(PROVE-LEMMA PROPERP-READ-FN
             (REWRITE)
             (IMPLIES (AND (PROPERP REG0) (PROPERP REG1))
                      (PROPERP (READ-FN REG0 REG1 N)))
             ((ENABLE READ-FN)))

(PROVE-LEMMA BVP-READ-FN
             (REWRITE)
             (IMPLIES (AND (BVP REG0) (BVP REG1))
                      (BVP (READ-FN REG0 REG1 N)))
             ((ENABLE READ-FN)))

(DEFN FETCH3$INDUCTION
      (N CLOCK COUNT INPUTS REGS A-REG B-REG RW- REGS-ADDRESS I-REG FLAGS
         PC-REG LAST-RW- LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-DATA)
      (IF (ZEROP N)
          T
          (FETCH3$INDUCTION (SUB1 N)
                            CLOCK
                            (SUB1 COUNT)
                            (CDR INPUTS)
                            (WRITE-REGS F 0 REGS 0)
                            A-REG B-REG T REGS-ADDRESS
                            (READ-REGS PC-REG REGS)
                            FLAGS PC-REG RW- PC-REG I-REG FLAGS
                            (V-THREEFIX LAST-DATA))))

(PROVE-LEMMA FETCH3$PROGRESS-HELP NIL
        (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                               PC-REG)
                      (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                      (MEMORY-OKP 32 32 MEM)
                      (REGFILE-OKP REGS)
                      (BVP A-REG)
                      (EQUAL (LENGTH A-REG) 32)
                      (BVP B-REG)
                      (EQUAL (LENGTH B-REG) 32)
                      (BVP ADDR-OUT)
                      (EQUAL (LENGTH ADDR-OUT) 32)
                      (BVP DATA-OUT)
                      (EQUAL (LENGTH DATA-OUT) 32)
                      (BOOLP HOLD-)
                      (RUN-INPUTS-P INPUTS (ADD1 N))
                      (IF (LESSP COUNT N) F T))
                 (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                DATA-OUT ADDR-OUT T T HOLD-
                                                PC-REG
                                                (CV_FETCH3 T
                                                           LAST-REGS-ADDRESS
                                                           LAST-I-REG
                                                           LAST-FLAGS PC-REG))
                                          (LIST MEM 1 CLOCK COUNT F T
                                                ADDR-OUT LAST-DATA))
                                    INPUTS
                                    (ADD1 N))
                        (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                    FLAGS A-REG B-REG
                                    (READ-FN I-REG
                                             (READ-REGS PC-REG REGS)
                                             (ADD1 N))
                                    DATA-OUT ADDR-OUT T
                                    (NOT (IF (LESSP N COUNT) F T))
                                    HOLD- PC-REG
                                    (CV_FETCH3 T PC-REG
                                               (READ-FN I-REG
                                                        (READ-REGS PC-REG REGS)
                                                        N)
                                               FLAGS PC-REG))
                              (LIST MEM 1 CLOCK
                                    (DIFFERENCE COUNT (ADD1 N))
                                    (IF (LESSP N COUNT) F T)
                                    T ADDR-OUT
                                    (V-THREEFIX LAST-DATA)))))
        ((INDUCT (FETCH3$INDUCTION N CLOCK COUNT INPUTS REGS A-REG B-REG RW-
                                   REGS-ADDRESS I-REG FLAGS PC-REG LAST-RW-
                                   LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                   LAST-DATA))
         (ENABLE PLUS NTHCDR DIFFERENCE OPEN-READ-FN WRITE-REGS-OK)))

(PROVE-LEMMA FETCH3$PROGRESS
        (REWRITE)
        (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                               PC-REG)
                      (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                      (MEMORY-OKP 32 32 MEM)
                      (REGFILE-OKP REGS)
                      (BVP A-REG)
                      (EQUAL (LENGTH A-REG) 32)
                      (BVP B-REG)
                      (EQUAL (LENGTH B-REG) 32)
                      (BVP ADDR-OUT)
                      (EQUAL (LENGTH ADDR-OUT) 32)
                      (BVP DATA-OUT)
                      (EQUAL (LENGTH DATA-OUT) 32)
                      (BOOLP HOLD-)
                      (RUN-INPUTS-P INPUTS COUNT)
                      (NOT (ZEROP COUNT)))
                 (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                DATA-OUT ADDR-OUT T T HOLD-
                                                PC-REG
                                                (CV_FETCH3 T
                                                           LAST-REGS-ADDRESS
                                                           LAST-I-REG
                                                           LAST-FLAGS PC-REG))
                                          (LIST MEM 1 CLOCK
                                                (SUB1 COUNT)
                                                F T ADDR-OUT LAST-DATA))
                                    INPUTS COUNT)
                        (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                    FLAGS A-REG B-REG
                                    (READ-FN I-REG
                                             (READ-REGS PC-REG REGS)
                                             COUNT)
                                    DATA-OUT ADDR-OUT T F HOLD- PC-REG
                                    (CV_FETCH3 T PC-REG
                                               (READ-FN I-REG
                                                        (READ-REGS PC-REG REGS)
                                                        (SUB1 COUNT))
                                               FLAGS PC-REG))
                              (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                    (V-THREEFIX LAST-DATA)))))
        ((USE (FETCH3$PROGRESS-HELP (COUNT (SUB1 COUNT))
                                    (N (SUB1 COUNT))))
         (DISABLE PLUS-ADD1 OPEN-RUN-INPUTS-P)
         (ENABLE OPEN-READ-FN)))

(DEFN READA3$INDUCTION
      (N CLOCK COUNT INPUTS REGS A-REG B-REG RW- REGS-ADDRESS I-REG FLAGS
         PC-REG LAST-RW- LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-DATA)
      (IF (ZEROP N)
          T
          (READA3$INDUCTION (SUB1 N)
                            CLOCK
                            (SUB1 COUNT)
                            (CDR INPUTS)
                            (WRITE-REGS F 0 REGS 0)
                            (READ-REGS PC-REG REGS)
                            B-REG T REGS-ADDRESS I-REG FLAGS PC-REG RW-
                            PC-REG I-REG FLAGS
                            (V-THREEFIX LAST-DATA))))

(PROVE-LEMMA READA3$PROGRESS-HELP NIL
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS (ADD1 N))
                         (IF (LESSP COUNT N) F T))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_READA3 T
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK COUNT F T
                                                   ADDR-OUT LAST-DATA))
                                       INPUTS
                                       (ADD1 N))
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS
                                       (READ-FN A-REG
                                                (READ-REGS PC-REG REGS)
                                                (ADD1 N))
                                       B-REG I-REG DATA-OUT ADDR-OUT T
                                       (NOT (IF (LESSP N COUNT) F T))
                                       HOLD- PC-REG
                                       (CV_READA3 T PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 1 CLOCK
                                       (DIFFERENCE COUNT (ADD1 N))
                                       (IF (LESSP N COUNT) F T)
                                       T ADDR-OUT
                                       (V-THREEFIX LAST-DATA)))))
           ((INDUCT (READA3$INDUCTION N CLOCK COUNT INPUTS REGS A-REG B-REG
                                      RW- REGS-ADDRESS I-REG FLAGS PC-REG
                                      LAST-RW- LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-DATA))
            (ENABLE PLUS NTHCDR DIFFERENCE OPEN-READ-FN RUN-INPUTS-P
                    WRITE-REGS-OK)
            (DISABLE OPEN-RUN-INPUTS-P)))

(PROVE-LEMMA READA3$PROGRESS
           (REWRITE)
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS COUNT)
                         (NOT (ZEROP COUNT)))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_READA3 T
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK
                                                   (SUB1 COUNT)
                                                   F T ADDR-OUT LAST-DATA))
                                       INPUTS COUNT)
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS
                                       (READ-FN A-REG
                                                (READ-REGS PC-REG REGS)
                                                COUNT)
                                       B-REG I-REG DATA-OUT ADDR-OUT T F HOLD-
                                       PC-REG
                                       (CV_READA3 T PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                       (V-THREEFIX LAST-DATA)))))
           ((USE (READA3$PROGRESS-HELP (COUNT (SUB1 COUNT))
                                       (N (SUB1 COUNT))))
            (DISABLE PLUS-ADD1 OPEN-RUN-INPUTS-P)
            (ENABLE OPEN-READ-FN)))

(DEFN READB3$INDUCTION
      (N CLOCK COUNT INPUTS REGS A-REG B-REG RW- REGS-ADDRESS I-REG FLAGS
         PC-REG LAST-RW- LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-DATA)
      (IF (ZEROP N)
          T
          (READB3$INDUCTION (SUB1 N)
                            CLOCK
                            (SUB1 COUNT)
                            (CDR INPUTS)
                            (WRITE-REGS F 0 REGS 0)
                            A-REG
                            (READ-REGS PC-REG REGS)
                            T REGS-ADDRESS I-REG FLAGS PC-REG RW- PC-REG
                            I-REG FLAGS
                            (V-THREEFIX LAST-DATA))))

(PROVE-LEMMA READB3$PROGRESS-HELP NIL
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS (ADD1 N))
                         (IF (LESSP COUNT N) F T))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_READB3 T
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK COUNT F T
                                                   ADDR-OUT LAST-DATA))
                                       INPUTS
                                       (ADD1 N))
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS A-REG
                                       (READ-FN B-REG
                                                (READ-REGS PC-REG REGS)
                                                (ADD1 N))
                                       I-REG DATA-OUT ADDR-OUT T
                                       (NOT (IF (LESSP N COUNT) F T))
                                       HOLD- PC-REG
                                       (CV_READB3 T PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 1 CLOCK
                                       (DIFFERENCE COUNT (ADD1 N))
                                       (IF (LESSP N COUNT) F T)
                                       T ADDR-OUT
                                       (V-THREEFIX LAST-DATA)))))
           ((INDUCT (READB3$INDUCTION N CLOCK COUNT INPUTS REGS A-REG B-REG
                                      RW- REGS-ADDRESS I-REG FLAGS PC-REG
                                      LAST-RW- LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-DATA))
            (ENABLE PLUS NTHCDR DIFFERENCE OPEN-READ-FN RUN-INPUTS-P
                    WRITE-REGS-OK)
            (DISABLE OPEN-RUN-INPUTS-P)))

(PROVE-LEMMA READB3$PROGRESS
           (REWRITE)
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS COUNT)
                         (NOT (ZEROP COUNT)))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_READB3 T
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 1 CLOCK
                                                   (SUB1 COUNT)
                                                   F T ADDR-OUT LAST-DATA))
                                       INPUTS COUNT)
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS A-REG
                                       (READ-FN B-REG
                                                (READ-REGS PC-REG REGS)
                                                COUNT)
                                       I-REG DATA-OUT ADDR-OUT T F HOLD-
                                       PC-REG
                                       (CV_READB3 T PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 1 CLOCK 0 T T ADDR-OUT
                                       (V-THREEFIX LAST-DATA)))))
           ((USE (READB3$PROGRESS-HELP (COUNT (SUB1 COUNT))
                                       (N (SUB1 COUNT))))
            (DISABLE PLUS-ADD1 OPEN-RUN-INPUTS-P)
            (ENABLE OPEN-READ-FN)))

(DEFN WRITE3$INDUCTION
      (N CLOCK COUNT INPUTS REGS A-REG B-REG RW- REGS-ADDRESS I-REG FLAGS
         PC-REG LAST-RW- LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS LAST-DATA)
      (IF (ZEROP N)
          T
          (WRITE3$INDUCTION (SUB1 N)
                            CLOCK
                            (SUB1 COUNT)
                            (CDR INPUTS)
                            (WRITE-REGS F 0 REGS 0)
                            A-REG B-REG F REGS-ADDRESS I-REG FLAGS PC-REG RW-
                            PC-REG I-REG FLAGS
                            (V-THREEFIX LAST-DATA))))

(PROVE-LEMMA WRITE3$PROGRESS-HELP NIL
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS (ADD1 N))
                         (IF (LESSP COUNT N) F T))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_WRITE3 F
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 2 CLOCK COUNT F F
                                                   ADDR-OUT DATA-OUT))
                                       INPUTS
                                       (ADD1 N))
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS A-REG B-REG I-REG DATA-OUT
                                       ADDR-OUT T
                                       (NOT (IF (LESSP N COUNT) F T))
                                       HOLD- PC-REG
                                       (CV_WRITE3 F PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 2 CLOCK
                                       (DIFFERENCE COUNT (ADD1 N))
                                       (IF (LESSP N COUNT) F T)
                                       F ADDR-OUT DATA-OUT))))
           ((INDUCT (WRITE3$INDUCTION N CLOCK COUNT INPUTS REGS A-REG B-REG
                                      RW- REGS-ADDRESS I-REG FLAGS PC-REG
                                      LAST-RW- LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS LAST-DATA))
            (ENABLE PLUS NTHCDR DIFFERENCE OPEN-READ-FN RUN-INPUTS-P
                    WRITE-REGS-OK)
            (DISABLE OPEN-RUN-INPUTS-P)))

(PROVE-LEMMA WRITE3$PROGRESS
           (REWRITE)
           (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                  PC-REG)
                         (CV-HYPS T LAST-REGS-ADDRESS I-REG FLAGS PC-REG)
                         (MEMORY-OKP 32 32 MEM)
                         (REGFILE-OKP REGS)
                         (BVP A-REG)
                         (EQUAL (LENGTH A-REG) 32)
                         (BVP B-REG)
                         (EQUAL (LENGTH B-REG) 32)
                         (BVP ADDR-OUT)
                         (EQUAL (LENGTH ADDR-OUT) 32)
                         (BVP DATA-OUT)
                         (EQUAL (LENGTH DATA-OUT) 32)
                         (BOOLP HOLD-)
                         (RUN-INPUTS-P INPUTS COUNT)
                         (NOT (ZEROP COUNT)))
                    (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG
                                                   I-REG DATA-OUT ADDR-OUT T T
                                                   HOLD- PC-REG
                                                   (CV_WRITE3 F
                                                              LAST-REGS-ADDRESS
                                                              LAST-I-REG
                                                              LAST-FLAGS
                                                              PC-REG))
                                             (LIST MEM 2 CLOCK
                                                   (SUB1 COUNT)
                                                   F F ADDR-OUT DATA-OUT))
                                       INPUTS COUNT)
                           (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                       FLAGS A-REG B-REG I-REG DATA-OUT
                                       ADDR-OUT T F HOLD- PC-REG
                                       (CV_WRITE3 F PC-REG I-REG FLAGS PC-REG))
                                 (LIST MEM 2 CLOCK 0 T F ADDR-OUT DATA-OUT))))
           ((USE (WRITE3$PROGRESS-HELP (COUNT (SUB1 COUNT))
                                       (N (SUB1 COUNT))))
            (DISABLE PLUS-ADD1 OPEN-RUN-INPUTS-P)))

(DEFN ZEROP-NOT-ZEROP-CASES
      (N)
      (COND ((ZEROP N) T)
            ((NOT (ZEROP N)) T)
            (T (ZEROP-NOT-ZEROP-CASES N)))
      ((LESSP (COUNT N))))

(PROVE-LEMMA FETCH0->FETCH0$SIM0
         (REWRITE)
         (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                PC-REG)
                       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                       (MEMORY-OKP 32 32 MEM)
                       (REGFILE-OKP REGS)
                       (BVP A-REG)
                       (EQUAL (LENGTH A-REG) 32)
                       (BVP B-REG)
                       (EQUAL (LENGTH B-REG) 32)
                       (BVP ADDR-OUT)
                       (EQUAL (LENGTH ADDR-OUT) 32)
                       (BVP DATA-OUT)
                       (EQUAL (LENGTH DATA-OUT) 32)
                       (BOOLP DTACK-)
                       (BOOLP HOLD-)
                       (RUN-INPUTS-P INPUTS 1)
                       (EQUAL RESET- T)
                       NIL)
                  (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                 DATA-OUT ADDR-OUT RESET-
                                                 DTACK- HOLD- PC-REG
                                                 (CV_FETCH0 T
                                                            LAST-REGS-ADDRESS
                                                            LAST-I-REG
                                                            LAST-FLAGS PC-REG))
                                           (LIST MEM 0 CLOCK MEM-COUNT
                                                 MEM-DTACK T LAST-ADDRESS
                                                 LAST-DATA))
                                     INPUTS 1)
                         (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T PC-REG I-REG FLAGS PC-REG))
                               (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                     (V-THREEFIX LAST-DATA)))))
         ((ENABLE REGFILE-OKP)
          (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA FETCH0->FETCH0$SIM1
         (REWRITE)
         (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                PC-REG)
                       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                       (MEMORY-OKP 32 32 MEM)
                       (REGFILE-OKP REGS)
                       (BVP A-REG)
                       (EQUAL (LENGTH A-REG) 32)
                       (BVP B-REG)
                       (EQUAL (LENGTH B-REG) 32)
                       (BVP ADDR-OUT)
                       (EQUAL (LENGTH ADDR-OUT) 32)
                       (BVP DATA-OUT)
                       (EQUAL (LENGTH DATA-OUT) 32)
                       (BOOLP DTACK-)
                       (BOOLP HOLD-)
                       (RUN-INPUTS-P INPUTS 1)
                       (EQUAL RESET- T)
                       NIL)
                  (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                 DATA-OUT ADDR-OUT RESET-
                                                 DTACK- HOLD- PC-REG
                                                 (CV_FETCH0 T
                                                            LAST-REGS-ADDRESS
                                                            LAST-I-REG
                                                            LAST-FLAGS PC-REG))
                                           (LIST MEM 1 CLOCK MEM-COUNT
                                                 MEM-DTACK T LAST-ADDRESS
                                                 LAST-DATA))
                                     INPUTS 1)
                         (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T PC-REG I-REG FLAGS PC-REG))
                               (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                                     (V-THREEFIX LAST-DATA)))))
         ((ENABLE REGFILE-OKP)
          (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA FETCH0->FETCH0$SIM2
         (REWRITE)
         (IMPLIES (AND (CV-HYPS F LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS
                                PC-REG)
                       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                       (MEMORY-OKP 32 32 MEM)
                       (REGFILE-OKP REGS)
                       (BVP A-REG)
                       (EQUAL (LENGTH A-REG) 32)
                       (BVP B-REG)
                       (EQUAL (LENGTH B-REG) 32)
                       (BVP ADDR-OUT)
                       (EQUAL (LENGTH ADDR-OUT) 32)
                       (BVP DATA-OUT)
                       (EQUAL (LENGTH DATA-OUT) 32)
                       (BOOLP DTACK-)
                       (BOOLP HOLD-)
                       (RUN-INPUTS-P INPUTS 1)
                       (EQUAL RESET- T)
                       (ZEROP MEM-COUNT))
                  (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                                 DATA-OUT ADDR-OUT RESET-
                                                 DTACK- HOLD- PC-REG
                                                 (CV_FETCH0 F
                                                            LAST-REGS-ADDRESS
                                                            LAST-I-REG
                                                            LAST-FLAGS PC-REG))
                                           (LIST MEM 2 CLOCK MEM-COUNT
                                                 MEM-DTACK F ADDR-OUT
                                                 DATA-OUT))
                                     INPUTS 1)
                         (LIST (LIST (WRITE-REGS F 0 REGS 0)
                                     FLAGS
                                     (READ-REGS PC-REG REGS)
                                     B-REG I-REG DATA-OUT
                                     (READ-REGS PC-REG REGS)
                                     T T
                                     (F-BUF (F-BUF (HOLD--INPUT (CAR INPUTS))))
                                     PC-REG
                                     (CV_FETCH1 T PC-REG I-REG FLAGS PC-REG))
                               (LIST (WRITE-MEM ADDR-OUT MEM DATA-OUT)
                                     0 CLOCK 0 T F ADDR-OUT DATA-OUT))))
         ((ENABLE REGFILE-OKP)
          (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA FETCH1->DECODE$SIM
 (REWRITE)
 (IMPLIES
  (AND (EQUAL DTACK-WAIT (CAR CLOCK))
       (CV-HYPS LAST-RW- LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS
                     (ADD1 (ADD1 (PLUS (CAR CLOCK) 2))))
       (EQUAL RESET- T)
       (EQUAL HOLD- T)
       (BOOLP LAST-RW-))
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_FETCH1 LAST-RW- LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK LAST-RW-
                           LAST-ADDRESS LAST-DATA))
               INPUTS
               (ADD1 (ADD1 (PLUS (CAR CLOCK) 2))))
   (LIST
    (LIST
       (WRITE-REGS F 0
                   (WRITE-REGS T PC-REG
                               (WRITE-REGS F 0 REGS 0)
                               (V-INC A-REG))
                   0)
       FLAGS A-REG B-REG
       (READ-MEM ADDR-OUT MEM)
       DATA-OUT ADDR-OUT T T T PC-REG
       (IF* (OR* (STORE-RESULTP (STORE-CC (READ-MEM ADDR-OUT MEM))
                                FLAGS)
                 (SET-SOME-FLAGS (SET-FLAGS (READ-MEM ADDR-OUT MEM))))
            (IF* (OR* (A-IMMEDIATE-P (READ-MEM ADDR-OUT MEM))
                      (REG-DIRECT-P (MODE-A (READ-MEM ADDR-OUT MEM))))
                 (IF* (OR* (REG-DIRECT-P (MODE-B (READ-MEM ADDR-OUT MEM)))
                           (UNARY-OP-CODE-P (OP-CODE (READ-MEM ADDR-OUT MEM))))
                      (CV_REGA T PC-REG
                               (READ-MEM ADDR-OUT MEM)
                               FLAGS PC-REG)
                      (CV_READB0 T PC-REG
                                 (READ-MEM ADDR-OUT MEM)
                                 FLAGS PC-REG))
                 (CV_READA0 T PC-REG
                            (READ-MEM ADDR-OUT MEM)
                            FLAGS PC-REG))
            (IF* (AND* (NOT* (A-IMMEDIATE-P (READ-MEM ADDR-OUT MEM)))
                       (OR* (PRE-DEC-P (MODE-A (READ-MEM ADDR-OUT MEM)))
                            (POST-INC-P (MODE-A (READ-MEM ADDR-OUT MEM)))))
                 (CV_SEFA0 T PC-REG
                           (READ-MEM ADDR-OUT MEM)
                           FLAGS PC-REG)
                 (IF* (OR* (PRE-DEC-P (MODE-B (READ-MEM ADDR-OUT MEM)))
                           (POST-INC-P (MODE-B (READ-MEM ADDR-OUT MEM))))
                      (CV_SEFB0 T PC-REG
                                (READ-MEM ADDR-OUT MEM)
                                FLAGS PC-REG)
                      (CV_FETCH0 T PC-REG
                                 (READ-MEM ADDR-OUT MEM)
                                 FLAGS PC-REG)))))
    (LIST MEM 0
          (CDR CLOCK)
          0 T T ADDR-OUT
          (V-THREEFIX LAST-DATA)))))
 ((INDUCT (ZEROP-NOT-ZEROP-CASES DTACK-WAIT))
  (ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF FETCH3$STEP1)))

(PROVE-LEMMA REGA->REGA$SIM
   (REWRITE)
   (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
                 (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                 (MEMORY-OKP 32 32 MEM)
                 (REGFILE-OKP REGS)
                 (BVP A-REG)
                 (EQUAL (LENGTH A-REG) 32)
                 (BVP B-REG)
                 (EQUAL (LENGTH B-REG) 32)
                 (BVP ADDR-OUT)
                 (EQUAL (LENGTH ADDR-OUT) 32)
                 (BVP DATA-OUT)
                 (EQUAL (LENGTH DATA-OUT) 32)
                 (BOOLP DTACK-)
                 (BOOLP HOLD-)
                 (RUN-INPUTS-P INPUTS 1)
                 (EQUAL RESET- T)
                 NIL)
            (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                           DATA-OUT ADDR-OUT RESET- DTACK-
                                           HOLD- PC-REG
                                           (CV_REGA T LAST-REGS-ADDRESS
                                                    LAST-I-REG LAST-FLAGS
                                                    PC-REG))
                                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                           LAST-ADDRESS LAST-DATA))
                               INPUTS 1)
                   (LIST (LIST (WRITE-REGS F 0 REGS 0)
                               FLAGS
                               (IF* (A-IMMEDIATE-P LAST-I-REG)
                                    (SIGN-EXTEND (A-IMMEDIATE I-REG) 32)
                                    (READ-REGS (RN-A LAST-I-REG) REGS))
                               B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
                               (IF* (REG-DIRECT-P (MODE-B I-REG))
                                    (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
                                         (CV_UPDATE T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG)
                                         (CV_REGB T
                                                  (RN-A LAST-I-REG)
                                                  I-REG FLAGS PC-REG))
                                    (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                         (CV_WRITE0 T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG)
                                         (CV_UPDATE T
                                                    (RN-A LAST-I-REG)
                                                    I-REG FLAGS PC-REG))))
                         (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                               (V-THREEFIX LAST-DATA)))))
   ((ENABLE REGFILE-OKP)
    (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA REGB->UPDATE$SIM
 (REWRITE)
 (IMPLIES
   (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
        (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
        (MEMORY-OKP 32 32 MEM)
        (REGFILE-OKP REGS)
        (BVP A-REG)
        (EQUAL (LENGTH A-REG) 32)
        (BVP B-REG)
        (EQUAL (LENGTH B-REG) 32)
        (BVP ADDR-OUT)
        (EQUAL (LENGTH ADDR-OUT) 32)
        (BVP DATA-OUT)
        (EQUAL (LENGTH DATA-OUT) 32)
        (BOOLP DTACK-)
        (BOOLP HOLD-)
        (RUN-INPUTS-P INPUTS 2)
        (EQUAL RESET- T)
        NIL)
   (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT
                                  ADDR-OUT RESET- DTACK- HOLD- PC-REG
                                  (CV_REGB T LAST-REGS-ADDRESS LAST-I-REG
                                           LAST-FLAGS PC-REG))
                            (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T
                                  LAST-ADDRESS LAST-DATA))
                      INPUTS 2)
          (LIST (LIST (WRITE-REGS (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                                  (RN-B I-REG)
                                  (WRITE-REGS F 0 REGS 0)
                                  (BV (V-ALU (C-FLAG FLAGS)
                                             A-REG
                                             (READ-REGS (RN-B LAST-I-REG) REGS)
                                             (OP-CODE I-REG))))
                      (UPDATE-FLAGS FLAGS
                                    (SET-FLAGS I-REG)
                                    (V-ALU (C-FLAG FLAGS)
                                           A-REG
                                           (READ-REGS (RN-B LAST-I-REG) REGS)
                                           (OP-CODE I-REG)))
                      A-REG
                      (READ-REGS (RN-B I-REG) REGS)
                      I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
                      (IF* (AND* (OR* (PRE-DEC-P (MODE-B I-REG))
                                      (POST-INC-P (MODE-B I-REG)))
                                 (UNARY-OP-CODE-P (OP-CODE I-REG)))
                           (CV_SEFB1 T
                                     (RN-B I-REG)
                                     I-REG FLAGS PC-REG)
                           (CV_FETCH0 T
                                      (RN-B I-REG)
                                      I-REG FLAGS PC-REG)))
                (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                      (V-THREEFIX LAST-DATA)))))
 ((ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA UPDATE->UPDATE$SIM
   (REWRITE)
   (IMPLIES (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
                 (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
                 (MEMORY-OKP 32 32 MEM)
                 (REGFILE-OKP REGS)
                 (BVP A-REG)
                 (EQUAL (LENGTH A-REG) 32)
                 (BVP B-REG)
                 (EQUAL (LENGTH B-REG) 32)
                 (BVP ADDR-OUT)
                 (EQUAL (LENGTH ADDR-OUT) 32)
                 (BVP DATA-OUT)
                 (EQUAL (LENGTH DATA-OUT) 32)
                 (BOOLP DTACK-)
                 (BOOLP HOLD-)
                 (RUN-INPUTS-P INPUTS 1)
                 (EQUAL RESET- T)
                 (OR (EQUAL MEM-STATE 0)
                     (EQUAL MEM-STATE 1)))
            (EQUAL (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG
                                           DATA-OUT ADDR-OUT RESET- DTACK-
                                           HOLD- PC-REG
                                           (CV_UPDATE T LAST-REGS-ADDRESS
                                                      LAST-I-REG LAST-FLAGS
                                                      PC-REG))
                                     (LIST MEM MEM-STATE CLOCK MEM-COUNT
                                           MEM-DTACK T LAST-ADDRESS LAST-DATA))
                               INPUTS 1)
                   (LIST (LIST (WRITE-REGS (STORE-RESULTP (STORE-CC LAST-I-REG)
                                                          LAST-FLAGS)
                                           (RN-B LAST-I-REG)
                                           REGS
                                           (BV (V-ALU (C-FLAG LAST-FLAGS)
                                                      A-REG B-REG
                                                      (OP-CODE LAST-I-REG))))
                               (UPDATE-FLAGS FLAGS
                                             (SET-FLAGS LAST-I-REG)
                                             (V-ALU (C-FLAG LAST-FLAGS)
                                                    A-REG B-REG
                                                    (OP-CODE LAST-I-REG)))
                               A-REG
                               (READ-REGS (RN-B LAST-I-REG) REGS)
                               I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
                               (IF* (AND* (OR* (PRE-DEC-P (MODE-B I-REG))
                                               (POST-INC-P (MODE-B I-REG)))
                                          (UNARY-OP-CODE-P (OP-CODE I-REG)))
                                    (CV_SEFB1 T
                                              (RN-B LAST-I-REG)
                                              I-REG FLAGS PC-REG)
                                    (CV_FETCH0 T
                                               (RN-B LAST-I-REG)
                                               I-REG FLAGS PC-REG)))
                         (LIST MEM 0 CLOCK 0 T T ADDR-OUT
                               (V-THREEFIX LAST-DATA)))))
   ((ENABLE REGFILE-OKP)
    (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA READA0->READA3$SIM
 (REWRITE)
 (IMPLIES
  (AND (EQUAL DTACK-WAIT (CAR CLOCK))
       (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS
                     (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_READA0 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS
               (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
   (LIST
    (LIST
     (WRITE-REGS F 0
      (WRITE-REGS
               (AND* (NOT* (A-IMMEDIATE-P I-REG))
                     (OR* (PRE-DEC-P (MODE-A I-REG))
                          (POST-INC-P (MODE-A I-REG))))
               (RN-A I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             (READ-REGS (RN-A LAST-I-REG) REGS)
                             B-REG F
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      0)
     FLAGS
     (READ-MEM (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
                    (V-DEC (READ-REGS (RN-A LAST-I-REG) REGS))
                    (READ-REGS (RN-A LAST-I-REG) REGS))
               MEM)
     (READ-REGS
      (RN-B I-REG)
      (WRITE-REGS
               (AND* (NOT* (A-IMMEDIATE-P I-REG))
                     (OR* (PRE-DEC-P (MODE-A I-REG))
                          (POST-INC-P (MODE-A I-REG))))
               (RN-A I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             (READ-REGS (RN-A LAST-I-REG) REGS)
                             B-REG F
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32)))))
     I-REG DATA-OUT
     (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
          (V-DEC (READ-REGS (RN-A LAST-I-REG) REGS))
          (READ-REGS (RN-A LAST-I-REG) REGS))
     T F HOLD- PC-REG
     (IF* (REG-DIRECT-P (MODE-B I-REG))
          (CV_UPDATE T PC-REG I-REG FLAGS PC-REG)
          (IF* (UNARY-OP-CODE-P (OP-CODE I-REG))
               (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                    (CV_WRITE0 T PC-REG I-REG FLAGS PC-REG)
                    (CV_UPDATE T PC-REG I-REG FLAGS PC-REG))
               (CV_READB0 T PC-REG I-REG FLAGS PC-REG))))
    (LIST MEM 1
          (CDR CLOCK)
          0 T T
          (IF* (PRE-DEC-P (MODE-A LAST-I-REG))
               (V-DEC (READ-REGS (RN-A LAST-I-REG) REGS))
               (READ-REGS (RN-A LAST-I-REG) REGS))
          (V-THREEFIX LAST-DATA)))))
 ((INDUCT (ZEROP-NOT-ZEROP-CASES DTACK-WAIT))
  (ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF READA3$STEP1)))

(PROVE-LEMMA READB0->READB3$SIM
 (REWRITE)
 (IMPLIES
  (AND (EQUAL DTACK-WAIT (CAR CLOCK))
       (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS
                     (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
       (EQUAL RESET- T)
       (OR (EQUAL MEM-STATE 0)
           (EQUAL MEM-STATE 1)))
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_READB0 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS PC-REG))
                     (LIST MEM MEM-STATE CLOCK MEM-COUNT MEM-DTACK T
                           LAST-ADDRESS LAST-DATA))
               INPUTS
               (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
   (LIST
    (LIST
     (WRITE-REGS F 0
      (WRITE-REGS
               (AND* (NOT* (STORE-RESULTP (STORE-CC I-REG)
                                          FLAGS))
                     (OR* (PRE-DEC-P (MODE-B I-REG))
                          (POST-INC-P (MODE-B I-REG))))
               (RN-B I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             (IF* (OR* (A-IMMEDIATE-P I-REG)
                                       (REG-DIRECT-P (MODE-A I-REG)))
                                  (IF* (A-IMMEDIATE-P I-REG)
                                       (SIGN-EXTEND (A-IMMEDIATE I-REG) 32)
                                       (READ-REGS (RN-A I-REG) REGS))
                                  A-REG)
                             (READ-REGS (RN-B LAST-I-REG) REGS)
                             F
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      0)
     FLAGS
     (IF* (OR* (A-IMMEDIATE-P I-REG)
               (REG-DIRECT-P (MODE-A I-REG)))
          (IF* (A-IMMEDIATE-P I-REG)
               (SIGN-EXTEND (A-IMMEDIATE I-REG) 32)
               (READ-REGS (RN-A I-REG) REGS))
          A-REG)
     (READ-MEM (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                    (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
                    (READ-REGS (RN-B LAST-I-REG) REGS))
               MEM)
     I-REG DATA-OUT
     (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
          (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
          (READ-REGS (RN-B LAST-I-REG) REGS))
     T F HOLD- PC-REG
     (IF* (STORE-RESULTP (STORE-CC I-REG) FLAGS)
          (CV_WRITE0 T PC-REG I-REG FLAGS PC-REG)
          (CV_UPDATE T PC-REG I-REG FLAGS PC-REG)))
    (LIST MEM 1
          (CDR CLOCK)
          0 T T
          (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
               (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
               (READ-REGS (RN-B LAST-I-REG) REGS))
          (V-THREEFIX LAST-DATA)))))
 ((INDUCT (ZEROP-NOT-ZEROP-CASES DTACK-WAIT))
  (ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF READB3$STEP1)))

(PROVE-LEMMA WRITE0->WRITE3$SIM
 (REWRITE)
 (IMPLIES
  (AND (EQUAL DTACK-WAIT (CAR CLOCK))
       (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS
                     (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
       (EQUAL RESET- T)
       (OR (EQUAL MEM-STATE 0)
           (EQUAL MEM-STATE 1)))
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_WRITE0 T LAST-REGS-ADDRESS LAST-I-REG
                                      LAST-FLAGS PC-REG))
                     (LIST MEM MEM-STATE CLOCK MEM-COUNT MEM-DTACK T
                           LAST-ADDRESS LAST-DATA))
               INPUTS
               (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1)))))
   (LIST
    (LIST
     (WRITE-REGS F 0
      (WRITE-REGS
               (OR* (PRE-DEC-P (MODE-B I-REG))
                    (POST-INC-P (MODE-B I-REG)))
               (RN-B I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG
                             (READ-REGS (RN-B LAST-I-REG) REGS)
                             F
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
      0)
     (UPDATE-FLAGS FLAGS
                   (SET-FLAGS LAST-I-REG)
                   (V-ALU (C-FLAG LAST-FLAGS)
                          A-REG B-REG
                          (OP-CODE LAST-I-REG)))
     A-REG
     (READ-REGS (RN-B LAST-I-REG) REGS)
     I-REG
     (BV (V-ALU (C-FLAG LAST-FLAGS)
                A-REG B-REG
                (OP-CODE LAST-I-REG)))
     (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
          (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
          (READ-REGS (RN-B LAST-I-REG) REGS))
     T F HOLD- PC-REG
     (CV_FETCH0 F PC-REG I-REG
                (UPDATE-FLAGS FLAGS
                              (SET-FLAGS LAST-I-REG)
                              (V-ALU (C-FLAG LAST-FLAGS)
                                     A-REG B-REG
                                     (OP-CODE LAST-I-REG)))
                PC-REG))
    (LIST MEM 2
          (CDR CLOCK)
          0 T F
          (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
               (V-DEC (READ-REGS (RN-B LAST-I-REG) REGS))
               (READ-REGS (RN-B LAST-I-REG) REGS))
          (BV (V-ALU (C-FLAG LAST-FLAGS)
                     A-REG B-REG
                     (OP-CODE LAST-I-REG)))))))
 ((INDUCT (ZEROP-NOT-ZEROP-CASES DTACK-WAIT))
  (ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF WRITE3$STEP1)))

(PROVE-LEMMA SEFA0->SEFA1$SIM
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS 2)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_SEFA0 T LAST-REGS-ADDRESS LAST-I-REG
                                     LAST-FLAGS PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS 2)
   (LIST
    (LIST
     (WRITE-REGS T
               (RN-A I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             (READ-REGS (RN-A LAST-I-REG) REGS)
                             B-REG F
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (MPG (CONS F (CONS F (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS F (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-A I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
     FLAGS
     (READ-REGS (RN-A LAST-I-REG) REGS)
     B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
     (IF* (OR* (PRE-DEC-P (MODE-B I-REG))
               (POST-INC-P (MODE-B I-REG)))
          (CV_SEFB0 T
                    (RN-A I-REG)
                    I-REG FLAGS PC-REG)
          (CV_FETCH0 T
                     (RN-A I-REG)
                     I-REG FLAGS PC-REG)))
    (LIST MEM 0 CLOCK 0 T T ADDR-OUT
          (V-THREEFIX LAST-DATA)))))
 ((ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA SEFB0->SEFB1$SIM
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS 2)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_SEFB0 T LAST-REGS-ADDRESS LAST-I-REG
                                     LAST-FLAGS PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS 2)
   (LIST
    (LIST
     (WRITE-REGS T
               (RN-B I-REG)
               (WRITE-REGS F 0 REGS 0)
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG
                             (READ-REGS (RN-B LAST-I-REG) REGS)
                             F
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
     FLAGS A-REG
     (READ-REGS (RN-B LAST-I-REG) REGS)
     I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
     (CV_FETCH0 T
                (RN-B I-REG)
                I-REG FLAGS PC-REG))
    (LIST MEM 0 CLOCK 0 T T ADDR-OUT
          (V-THREEFIX LAST-DATA)))))
 ((ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(PROVE-LEMMA SEFB1->SEFB1$SIM
 (REWRITE)
 (IMPLIES
  (AND (CV-HYPS T LAST-REGS-ADDRESS LAST-I-REG LAST-FLAGS PC-REG)
       (CV-HYPS T PC-REG I-REG FLAGS PC-REG)
       (MEMORY-OKP 32 32 MEM)
       (REGFILE-OKP REGS)
       (BVP A-REG)
       (EQUAL (LENGTH A-REG) 32)
       (BVP B-REG)
       (EQUAL (LENGTH B-REG) 32)
       (BVP ADDR-OUT)
       (EQUAL (LENGTH ADDR-OUT) 32)
       (BVP DATA-OUT)
       (EQUAL (LENGTH DATA-OUT) 32)
       (BOOLP DTACK-)
       (BOOLP HOLD-)
       (RUN-INPUTS-P INPUTS 1)
       (EQUAL RESET- T)
       NIL)
  (EQUAL
   (RUN-FM9001 (LIST (LIST REGS FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT
                           RESET- DTACK- HOLD- PC-REG
                           (CV_SEFB1 T LAST-REGS-ADDRESS LAST-I-REG
                                     LAST-FLAGS PC-REG))
                     (LIST MEM 0 CLOCK MEM-COUNT MEM-DTACK T LAST-ADDRESS
                           LAST-DATA))
               INPUTS 1)
   (LIST
    (LIST
     (WRITE-REGS T
               (RN-B LAST-I-REG)
               REGS
               (BV (CORE-ALU (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-DEC-OP))))
                                  (CARRY-IN-HELP (CONS (C-FLAG LAST-FLAGS)
                                                       (CONS F (ALU-INC-OP)))))
                             A-REG B-REG F
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (MPG (CONS F (CONS T (ALU-DEC-OP))))
                                  (MPG (CONS F (CONS T (ALU-INC-OP)))))
                             (IF* (PRE-DEC-P (MODE-B LAST-I-REG))
                                  (ALU-DEC-OP)
                                  (ALU-INC-OP))
                             (MAKE-TREE 32))))
     FLAGS A-REG B-REG I-REG DATA-OUT ADDR-OUT T T HOLD- PC-REG
     (CV_FETCH0 T
                (RN-B LAST-I-REG)
                I-REG FLAGS PC-REG))
    (LIST MEM 0 CLOCK 0 T T ADDR-OUT
          (V-THREEFIX LAST-DATA)))))
 ((ENABLE REGFILE-OKP)
  (DISABLE PLUS-ADD1 MAKE-TREE *1*MAKE-TREE V-INC V-DEC BV F-BUF)))

(DEFN T_FETCH0 (CLOCK I-REG FLAGS) 1)

(DEFN T_SEFB1
      (CLOCK I-REG FLAGS)
      (PLUS 1 (T_FETCH0 CLOCK I-REG FLAGS)))

(DEFN T_SEFB0
      (CLOCK I-REG FLAGS)
      (PLUS 2 (T_FETCH0 CLOCK I-REG FLAGS)))

(DEFN T_SEFA0
      (CLOCK I-REG FLAGS)
      (PLUS 2
            (IF (OR* (PRE-DEC-P (MODE-B I-REG))
                     (POST-INC-P (MODE-B I-REG)))
                (T_SEFB0 CLOCK I-REG FLAGS)
                (T_FETCH0 CLOCK I-REG FLAGS))))

(DEFN T_WRITE0
      (CLOCK I-REG FLAGS)
      (PLUS (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1))))
            (T_FETCH0 (CDR CLOCK) I-REG FLAGS)))

(DEFN T_UPDATE
      (CLOCK I-REG FLAGS)
      (PLUS 1
            (IF (B-AND (OR* (PRE-DEC-P (MODE-B I-REG))
                            (POST-INC-P (MODE-B I-REG)))
                       (UNARY-OP-CODE-P (OP-CODE I-REG)))
                (T_SEFB1 CLOCK I-REG FLAGS)
                (T_FETCH0 CLOCK I-REG FLAGS))))

(DEFN T_READB0
      (CLOCK I-REG FLAGS)
      (PLUS (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1))))
            (IF (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                (T_WRITE0 (CDR CLOCK) I-REG FLAGS)
                (T_UPDATE (CDR CLOCK) I-REG FLAGS))))

(DEFN T_READA0
      (CLOCK I-REG FLAGS)
      (PLUS (ADD1 (ADD1 (ADD1 (PLUS (CAR CLOCK) 1))))
            (COND ((REG-DIRECT-P (MODE-B I-REG))
                   (T_UPDATE (CDR CLOCK) I-REG FLAGS))
                  ((UNARY-OP-CODE-P (OP-CODE I-REG))
                   (IF (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                       (T_WRITE0 (CDR CLOCK) I-REG FLAGS)
                       (T_UPDATE (CDR CLOCK) I-REG FLAGS)))
                  (T (T_READB0 (CDR CLOCK) I-REG FLAGS)))))

(DEFN T_REGB
      (CLOCK I-REG FLAGS)
      (PLUS 2
            (IF (B-AND (OR* (PRE-DEC-P (MODE-B I-REG))
                            (POST-INC-P (MODE-B I-REG)))
                       (UNARY-OP-CODE-P (OP-CODE I-REG)))
                (T_SEFB1 CLOCK I-REG FLAGS)
                (T_FETCH0 CLOCK I-REG FLAGS))))

(DEFN T_REGA
      (CLOCK I-REG FLAGS)
      (PLUS 1
            (COND ((REG-DIRECT-P (MODE-B I-REG))
                   (IF (UNARY-OP-CODE-P (OP-CODE I-REG))
                       (T_UPDATE CLOCK I-REG FLAGS)
                       (T_REGB CLOCK I-REG FLAGS)))
                  ((STORE-RESULTP (STORE-CC I-REG) FLAGS)
                   (T_WRITE0 CLOCK I-REG FLAGS))
                  (T (T_UPDATE CLOCK I-REG FLAGS)))))

(DEFN T_FETCH1
      (CLOCK I-REG FLAGS)
      (PLUS (ADD1 (ADD1 (PLUS (CAR CLOCK) 2)))
            (COND ((B-OR (STORE-RESULTP (STORE-CC I-REG) FLAGS)
                         (SET-SOME-FLAGS (SET-FLAGS I-REG)))
                   (IF (OR* (A-IMMEDIATE-P I-REG)
                            (REG-DIRECT-P (MODE-A I-REG)))
                       (IF (B-OR (REG-DIRECT-P (MODE-B I-REG))
                                 (UNARY-OP-CODE-P (OP-CODE I-REG)))
                           (T_REGA (CDR CLOCK) I-REG FLAGS)
                           (T_READB0 (CDR CLOCK) I-REG FLAGS))
                       (T_READA0 (CDR CLOCK) I-REG FLAGS)))
                  ((AND* (NOT* (A-IMMEDIATE-P I-REG))
                         (OR* (PRE-DEC-P (MODE-A I-REG))
                              (POST-INC-P (MODE-A I-REG))))
                   (T_SEFA0 (CDR CLOCK) I-REG FLAGS))
                  ((OR* (PRE-DEC-P (MODE-B I-REG))
                        (POST-INC-P (MODE-B I-REG)))
                   (T_SEFB0 (CDR CLOCK) I-REG FLAGS))
                  (T (T_FETCH0 (CDR CLOCK) I-REG FLAGS)))))

(DEFN OPERATING-INPUTS-P
      (INPUTS N)
      (IF (ZEROP N)
          T
          (AND (EQUAL (RESET--INPUT (CAR INPUTS)) T)
               (EQUAL (HOLD--INPUT (CAR INPUTS)) T)
               (BVP (PC-REG-INPUT (CAR INPUTS)))
               (EQUAL (LENGTH (PC-REG-INPUT (CAR INPUTS)))
                      4)
               (OPERATING-INPUTS-P (CDR INPUTS)
                                   (SUB1 N)))))

(TOGGLE OPERATING-INPUTS-P-OFF OPERATING-INPUTS-P T)

(PROVE-LEMMA OPEN-OPERATING-INPUTS-P
          (REWRITE)
          (AND (IMPLIES (ZEROP N)
                        (EQUAL (OPERATING-INPUTS-P INPUTS N)
                               T))
               (IMPLIES (NOT (ZEROP N))
                        (EQUAL (OPERATING-INPUTS-P INPUTS N)
                               (AND (EQUAL (RESET--INPUT (CAR INPUTS)) T)
                                    (EQUAL (HOLD--INPUT (CAR INPUTS)) T)
                                    (BVP (PC-REG-INPUT (CAR INPUTS)))
                                    (EQUAL (LENGTH (PC-REG-INPUT (CAR INPUTS)))
                                           4)
                                    (OPERATING-INPUTS-P (CDR INPUTS)
                                                        (SUB1 N))))))
          ((ENABLE OPERATING-INPUTS-P)))

(PROVE-LEMMA OPERATING-INPUTS-P-IMPLIES-RUN-INPUTS-P
             (REWRITE)
             (IMPLIES (OPERATING-INPUTS-P INPUTS N)
                      (RUN-INPUTS-P INPUTS N))
             ((ENABLE RUN-INPUTS-P OPERATING-INPUTS-P)))

(PROVE-LEMMA OPERATING-INPUTS-P-PLUS
             (REWRITE)
             (EQUAL (OPERATING-INPUTS-P INPUTS (PLUS N M))
                    (AND (OPERATING-INPUTS-P INPUTS N)
                         (OPERATING-INPUTS-P (NTHCDR N INPUTS)
                                             M)))
             ((ENABLE OPERATING-INPUTS-P NTHCDR PLUS)))

(PROVE-LEMMA OPERATING-INPUTS-P-1
             (REWRITE)
             (IMPLIES (AND (OPERATING-INPUTS-P INPUTS N)
                           (NOT (ZEROP N)))
                      (OPERATING-INPUTS-P INPUTS 1))
             ((ENABLE OPERATING-INPUTS-P)))

(PROVE-LEMMA OPERATING-INPUTS-P-IMPLIES-HOLD--INPUT
             (REWRITE)
             (IMPLIES (AND (OPERATING-INPUTS-P INPUTS N)
                           (NOT (ZEROP N)))
                      (EQUAL (HOLD--INPUT (CAR INPUTS)) T))
             ((ENABLE OPERATING-INPUTS-P)))

(DEFN MICROCYCLES
      (STATE)
      (T_FETCH1 (CADDADR STATE)
                (READ-MEM (READ-MEM (CADDDDDDDDDDAR STATE)
                                    (CAAAR STATE))
                          (CAADR STATE))
                (CADAR STATE)))

(DEFN TOTAL-MICROCYCLES
      (STATE INPUTS N)
      (IF (ZEROP N)
          0
          (PLUS (MICROCYCLES STATE)
                (TOTAL-MICROCYCLES (RUN-FM9001 STATE INPUTS
                                               (MICROCYCLES STATE))
                                   (NTHCDR (MICROCYCLES STATE) INPUTS)
                                   (SUB1 N)))))

(TOGGLE TOTAL-MICROCYCLES-OFF TOTAL-MICROCYCLES T)

(PROVE-LEMMA OPEN-TOTAL-MICROCYCLES
 (REWRITE)
 (AND
   (IMPLIES (ZEROP N)
            (EQUAL (TOTAL-MICROCYCLES STATE INPUTS N)
                   0))
   (IMPLIES (NOT (ZEROP N))
            (EQUAL (TOTAL-MICROCYCLES STATE INPUTS N)
                   (PLUS (MICROCYCLES STATE)
                         (TOTAL-MICROCYCLES (RUN-FM9001 STATE INPUTS
                                                        (MICROCYCLES STATE))
                                            (NTHCDR (MICROCYCLES STATE) INPUTS)
                                            (SUB1 N))))))
 ((ENABLE TOTAL-MICROCYCLES)
  (DISABLE MICROCYCLES)))

(DEFN MACROCYCLE-INVARIANT
      (STATE PC)
      (AND (ALL-RAMP-MEM 4 (CAAAR STATE))
           (MEMORY-OKP 4 32 (CAAAR STATE))
           (EQUAL (CADAAR STATE) F)
           (BVP (CADDAAR STATE))
           (EQUAL (LENGTH (CADDAAR STATE)) 32)
           (BVP (CADDDAAR STATE))
           (EQUAL (LENGTH (CADDDAAR STATE)) 4)
           (BVP (CADAR STATE))
           (EQUAL (LENGTH (CADAR STATE)) 4)
           (EQUAL (CADDAR STATE)
                  (READ-REGS (CADDDDDDDDDDAR STATE)
                             (CAAR STATE)))
           (BVP (CADDDAR STATE))
           (EQUAL (LENGTH (CADDDAR STATE)) 32)
           (BVP (CADDDDAR STATE))
           (EQUAL (LENGTH (CADDDDAR STATE)) 32)
           (BVP (CADDDDDAR STATE))
           (EQUAL (LENGTH (CADDDDDAR STATE)) 32)
           (EQUAL (CADDDDDDAR STATE)
                  (READ-REGS (CADDDDDDDDDDAR STATE)
                             (CAAR STATE)))
           (EQUAL (CADDDDDDDAR STATE) T)
           (BOOLP (CADDDDDDDDAR STATE))
           (EQUAL (CADDDDDDDDDAR STATE) T)
           (BVP (CADDDDDDDDDDAR STATE))
           (EQUAL (LENGTH (CADDDDDDDDDDAR STATE))
                  4)
           (EQUAL (CADDDDDDDDDDAR STATE) PC)
           (EQUAL (CADDDDDDDDDDDAR STATE)
                  (CV_FETCH1 (CADDDDDADR STATE)
                             (CADDDDDDDDDDAR STATE)
                             (CADDDDAR STATE)
                             (CADAR STATE)
                             (CADDDDDDDDDDAR STATE)))
           (MEMORY-OKP 32 32 (CAADR STATE))
           (EQUAL (CADADR STATE) 0)
           (NUMBERP (CADDDADR STATE))
           (BOOLP (CADDDDDADR STATE))
           (BVP (CADDDDDDADR STATE))
           (EQUAL (LENGTH (CADDDDDDADR STATE))
                  32)
           (PROPERP (CADDDDDDDADR STATE))
           (EQUAL (LENGTH (CADDDDDDDADR STATE))
                  32)))

(PROVE-LEMMA MACROCYCLE-INVARIANT==>CHIP-SYSTEM-INVARIANT$HELP NIL
             (IMPLIES (MACROCYCLE-INVARIANT (LIST (LIST (LIST REGS-REGS
                                                              REGS-WE
                                                              REGS-DATA
                                                              REGS-ADDRESS)
                                                        FLAGS A-REG B-REG
                                                        I-REG DATA-OUT
                                                        ADDR-OUT LAST-RESET-
                                                        LAST-DTACK- LAST-HOLD-
                                                        PC-REG CNTL-STATE)
                                                  (LIST MEM CNTL CLOCK COUNT
                                                        DTACK LAST-RW-
                                                        LAST-ADDRESS
                                                        LAST-DATA))
                                            PC)
                      (CHIP-SYSTEM-INVARIANT (LIST (LIST (LIST REGS-REGS
                                                               REGS-WE
                                                               REGS-DATA
                                                               REGS-ADDRESS)
                                                         FLAGS A-REG B-REG
                                                         I-REG DATA-OUT
                                                         ADDR-OUT LAST-RESET-
                                                         LAST-DTACK-
                                                         LAST-HOLD- PC-REG
                                                         CNTL-STATE)
                                                   (LIST MEM CNTL CLOCK
                                                         COUNT DTACK
                                                         LAST-RW-
                                                         LAST-ADDRESS
                                                         LAST-DATA))))
             ((DISABLE CAR-CDR-ELIM)))

(PROVE-LEMMA MACROCYCLE-INVARIANT==>CHIP-SYSTEM-INVARIANT
 (REWRITE)
 (IMPLIES (AND (FM9001-STATE-STRUCTURE STATE)
               (MACROCYCLE-INVARIANT STATE PC))
          (CHIP-SYSTEM-INVARIANT STATE))
 ((DISABLE CHIP-SYSTEM-INVARIANT MACROCYCLE-INVARIANT FM9001-STATE-STRUCTURE)
  (USE
   (MACROCYCLE-INVARIANT==>CHIP-SYSTEM-INVARIANT$HELP
                                           (REGS-REGS (CAAAR STATE))
                                           (REGS-WE (CADAAR STATE))
                                           (REGS-DATA (CADDAAR STATE))
                                           (REGS-ADDRESS (CADDDAAR STATE))
                                           (FLAGS (CADAR STATE))
                                           (A-REG (CADDAR STATE))
                                           (B-REG (CADDDAR STATE))
                                           (I-REG (CADDDDAR STATE))
                                           (DATA-OUT (CADDDDDAR STATE))
                                           (ADDR-OUT (CADDDDDDAR STATE))
                                           (LAST-RESET- (CADDDDDDDAR STATE))
                                           (LAST-DTACK- (CADDDDDDDDAR STATE))
                                           (LAST-HOLD- (CADDDDDDDDDAR STATE))
                                           (PC-REG (CADDDDDDDDDDAR STATE))
                                           (CNTL-STATE (CADDDDDDDDDDDAR STATE))
                                           (MEM (CAADR STATE))
                                           (CNTL (CADADR STATE))
                                           (CLOCK (CADDADR STATE))
                                           (COUNT (CADDDADR STATE))
                                           (DTACK (CADDDDADR STATE))
                                           (LAST-RW- (CADDDDDADR STATE))
                                           (LAST-ADDRESS (CADDDDDDADR STATE))
                                           (LAST-DATA (CADDDDDDDADR STATE)))
   (FM9001-STATE-AS-A-LIST))))

(DEFN MACROCYCLE-INVARIANT*
      (STATE PC)
      (MACROCYCLE-INVARIANT STATE PC))

(TOGGLE MACROCYCLE-INVARIANT*-OFF MACROCYCLE-INVARIANT* T)

(PROVE-LEMMA MACROCYCLE-INVARIANT*=MACROCYCLE-INVARIANT
             (REWRITE)
             (EQUAL (MACROCYCLE-INVARIANT* (CONS X Y) PC)
                    (MACROCYCLE-INVARIANT (CONS X Y) PC))
             ((ENABLE MACROCYCLE-INVARIANT*)
              (DISABLE MACROCYCLE-INVARIANT)))

(PROVE-LEMMA MACROCYCLE-INVARIANT-IS-INVARIANT$HELP NIL
 (IMPLIES
  (AND (MACROCYCLE-INVARIANT (LIST (LIST (LIST REGS-REGS REGS-WE REGS-DATA
                                               REGS-ADDRESS)
                                         FLAGS A-REG B-REG I-REG DATA-OUT
                                         ADDR-OUT LAST-RESET- LAST-DTACK-
                                         LAST-HOLD- PC-REG CNTL-STATE)
                                   (LIST MEM CNTL CLOCK COUNT DTACK LAST-RW-
                                         LAST-ADDRESS LAST-DATA))
                             PC)
       (OPERATING-INPUTS-P INPUTS
                           (MICROCYCLES (LIST (LIST (LIST REGS-REGS REGS-WE
                                                          REGS-DATA
                                                          REGS-ADDRESS)
                                                    FLAGS A-REG B-REG I-REG
                                                    DATA-OUT ADDR-OUT
                                                    LAST-RESET- LAST-DTACK-
                                                    LAST-HOLD- PC-REG
                                                    CNTL-STATE)
                                              (LIST MEM CNTL CLOCK COUNT
                                                    DTACK LAST-RW-
                                                    LAST-ADDRESS LAST-DATA)))))
  (MACROCYCLE-INVARIANT*
                       (RUN-FM9001 (LIST (LIST (LIST REGS-REGS REGS-WE
                                                     REGS-DATA REGS-ADDRESS)
                                               FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT LAST-RESET-
                                               LAST-DTACK- LAST-HOLD- PC-REG
                                               CNTL-STATE)
                                         (LIST MEM CNTL CLOCK COUNT DTACK
                                               LAST-RW- LAST-ADDRESS
                                               LAST-DATA))
                                   INPUTS
                                   (MICROCYCLES (LIST (LIST (LIST REGS-REGS
                                                                  REGS-WE
                                                                  REGS-DATA
                                                                  REGS-ADDRESS)
                                                            FLAGS A-REG B-REG
                                                            I-REG DATA-OUT
                                                            ADDR-OUT
                                                            LAST-RESET-
                                                            LAST-DTACK-
                                                            LAST-HOLD- PC-REG
                                                            CNTL-STATE)
                                                      (LIST MEM CNTL CLOCK
                                                            COUNT DTACK
                                                            LAST-RW-
                                                            LAST-ADDRESS
                                                            LAST-DATA))))
                       PC))
 ((ENABLE EXPAND-*-CONNECTIVES OPEN-NTH T_FETCH1 WRITE-REGS REGFILE-OKP
          REG-DIRECT->NOT-REG-INDIRECT FM9001-STEP)
  (ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY FM9001-STEP-THEORY)
  (DISABLE PLUS *1*PLUS PLUS-ADD1 MAKE-TREE *1*MAKE-TREE OPEN-RUN-INPUTS-P
           OPEN-RUN-INPUTS-P-ADD1 OPEN-OPERATING-INPUTS-P)))

(PROVE-LEMMA MACROCYCLE-INVARIANT-IS-INVARIANT
 (REWRITE)
 (IMPLIES (AND (FM9001-STATE-STRUCTURE STATE)
               (MACROCYCLE-INVARIANT STATE PC)
               (OPERATING-INPUTS-P INPUTS
                                   (MICROCYCLES STATE)))
          (MACROCYCLE-INVARIANT (RUN-FM9001 STATE INPUTS
                                            (MICROCYCLES STATE))
                                PC))
 ((USE
   (MACROCYCLE-INVARIANT-IS-INVARIANT$HELP
                           (REGS-REGS (CAAAR STATE))
                           (REGS-WE (CADAAR STATE))
                           (REGS-DATA (CADDAAR STATE))
                           (REGS-ADDRESS (CADDDAAR STATE))
                           (FLAGS (CADAR STATE))
                           (A-REG (CADDAR STATE))
                           (B-REG (CADDDAR STATE))
                           (I-REG (CADDDDAR STATE))
                           (DATA-OUT (CADDDDDAR STATE))
                           (ADDR-OUT (CADDDDDDAR STATE))
                           (LAST-RESET- (CADDDDDDDAR STATE))
                           (LAST-DTACK- (CADDDDDDDDAR STATE))
                           (LAST-HOLD- (CADDDDDDDDDAR STATE))
                           (PC-REG (CADDDDDDDDDDAR STATE))
                           (CNTL-STATE (CADDDDDDDDDDDAR STATE))
                           (MEM (CAADR STATE))
                           (CNTL (CADADR STATE))
                           (CLOCK (CADDADR STATE))
                           (COUNT (CADDDADR STATE))
                           (DTACK (CADDDDADR STATE))
                           (LAST-RW- (CADDDDDADR STATE))
                           (LAST-ADDRESS (CADDDDDDADR STATE))
                           (LAST-DATA (CADDDDDDDADR STATE))
                           (INSTR (READ-MEM (READ-REGS (CADDDDDDDDDDAR STATE)
                                                       (LIST (CAAAR STATE)
                                                             (CADAAR STATE)
                                                             (CADDAAR STATE)
                                                             (CADDDAAR STATE)))
                                            (CAADR STATE)))
                           (MICROCYCLES (MICROCYCLES STATE)))
   (FM9001-STATE-AS-A-LIST))
  (ENABLE MACROCYCLE-INVARIANT*)
  (DISABLE FM9001-STATE-STRUCTURE MACROCYCLE-INVARIANT T_FETCH1)))

(DEFN P-MAP-UP
      (P-STATE)
      (LIST (CAR (REGS P-STATE))
            (FLAGS P-STATE)))

(DEFN MEM-MAP-UP
      (MEM-STATE)
      (CAR MEM-STATE))

(DEFN MAP-UP
      (STATE)
      (LIST (P-MAP-UP (CAR STATE))
            (MEM-MAP-UP (CADR STATE))))

(TOGGLE MAP-UP-OFF MAP-UP T)

(PROVE-LEMMA OPEN-MAP-UP
             (REWRITE)
             (EQUAL (MAP-UP (CONS X Y))
                    (LIST (LIST (CAR (REGS (CAR (CONS X Y))))
                                (FLAGS (CAR (CONS X Y))))
                          (CAADR (CONS X Y))))
             ((ENABLE MAP-UP)))

(DEFN FM9001-STEP*
      (STATE PC-REG)
      (FM9001-STEP STATE PC-REG))

(TOGGLE FM9001-STEP*-OFF FM9001-STEP* T)

(PROVE-LEMMA FM9001-STEP*-LEMMA
             (REWRITE)
             (EQUAL (EQUAL (CONS X Y)
                           (FM9001-STEP* STATE PC-REG))
                    (EQUAL (CONS X Y)
                           (FM9001-STEP STATE PC-REG)))
             ((ENABLE FM9001-STEP*)))

(PROVE-LEMMA MIDDLE=HIGH$HELP NIL
 (IMPLIES
        (AND (MACROCYCLE-INVARIANT (LIST (LIST (LIST REGS-REGS REGS-WE
                                                     REGS-DATA REGS-ADDRESS)
                                               FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT LAST-RESET-
                                               LAST-DTACK- LAST-HOLD- PC-REG
                                               CNTL-STATE)
                                         (LIST MEM CNTL CLOCK COUNT DTACK
                                               LAST-RW- LAST-ADDRESS
                                               LAST-DATA))
                                   PC-REG)
             (OPERATING-INPUTS-P INPUTS
                                 (MICROCYCLES (LIST (LIST (LIST REGS-REGS
                                                                REGS-WE
                                                                REGS-DATA
                                                                REGS-ADDRESS)
                                                          FLAGS A-REG B-REG
                                                          I-REG DATA-OUT
                                                          ADDR-OUT LAST-RESET-
                                                          LAST-DTACK-
                                                          LAST-HOLD- PC-REG
                                                          CNTL-STATE)
                                                    (LIST MEM CNTL CLOCK
                                                          COUNT DTACK
                                                          LAST-RW-
                                                          LAST-ADDRESS
                                                          LAST-DATA)))))
        (EQUAL (MAP-UP (RUN-FM9001 (LIST (LIST (LIST REGS-REGS REGS-WE
                                                     REGS-DATA REGS-ADDRESS)
                                               FLAGS A-REG B-REG I-REG
                                               DATA-OUT ADDR-OUT LAST-RESET-
                                               LAST-DTACK- LAST-HOLD- PC-REG
                                               CNTL-STATE)
                                         (LIST MEM CNTL CLOCK COUNT DTACK
                                               LAST-RW- LAST-ADDRESS
                                               LAST-DATA))
                                   INPUTS
                                   (MICROCYCLES (LIST (LIST (LIST REGS-REGS
                                                                  REGS-WE
                                                                  REGS-DATA
                                                                  REGS-ADDRESS)
                                                            FLAGS A-REG B-REG
                                                            I-REG DATA-OUT
                                                            ADDR-OUT
                                                            LAST-RESET-
                                                            LAST-DTACK-
                                                            LAST-HOLD- PC-REG
                                                            CNTL-STATE)
                                                      (LIST MEM CNTL CLOCK
                                                            COUNT DTACK
                                                            LAST-RW-
                                                            LAST-ADDRESS
                                                            LAST-DATA)))))
               (FM9001-STEP* (LIST (LIST REGS-REGS FLAGS) MEM)
                             PC-REG)))
 ((ENABLE EXPAND-*-CONNECTIVES OPEN-NTH T_FETCH1 WRITE-REGS REGFILE-OKP
          REG-DIRECT->NOT-REG-INDIRECT FM9001-STEP)
  (ENABLE-THEORY FM9001-HARDWARE-STATE-ACCESSORS)
  (DISABLE-THEORY FM9001-STEP-THEORY)
  (DISABLE PLUS *1*PLUS PLUS-ADD1 MAKE-TREE *1*MAKE-TREE OPEN-RUN-INPUTS-P
           OPEN-RUN-INPUTS-P-ADD1 OPEN-OPERATING-INPUTS-P)))

(PROVE-LEMMA MACROCYCLE-INVARIANT==>PC-REG NIL
             (IMPLIES (MACROCYCLE-INVARIANT STATE PC-REG)
                      (EQUAL (PC-REG (CAR STATE)) PC-REG))
             ((ENABLE PC-REG MACROCYCLE-INVARIANT OPEN-NTH)))

(PROVE-LEMMA MIDDLE=HIGH
   (REWRITE)
   (IMPLIES (AND (FM9001-STATE-STRUCTURE STATE)
                 (MACROCYCLE-INVARIANT STATE PC)
                 (OPERATING-INPUTS-P INPUTS
                                     (MICROCYCLES STATE)))
            (EQUAL (MAP-UP (RUN-FM9001 STATE INPUTS
                                       (MICROCYCLES STATE)))
                   (FM9001-STEP (MAP-UP STATE) PC)))
   ((USE (MACROCYCLE-INVARIANT==>PC-REG (PC-REG PC))
         (MIDDLE=HIGH$HELP (REGS-REGS (CAAAR STATE))
                           (REGS-WE (CADAAR STATE))
                           (REGS-DATA (CADDAAR STATE))
                           (REGS-ADDRESS (CADDDAAR STATE))
                           (FLAGS (CADAR STATE))
                           (A-REG (CADDAR STATE))
                           (B-REG (CADDDAR STATE))
                           (I-REG (CADDDDAR STATE))
                           (DATA-OUT (CADDDDDAR STATE))
                           (ADDR-OUT (CADDDDDDAR STATE))
                           (LAST-RESET- (CADDDDDDDAR STATE))
                           (LAST-DTACK- (CADDDDDDDDAR STATE))
                           (LAST-HOLD- (CADDDDDDDDDAR STATE))
                           (PC-REG (CADDDDDDDDDDAR STATE))
                           (CNTL-STATE (CADDDDDDDDDDDAR STATE))
                           (MEM (CAADR STATE))
                           (CNTL (CADADR STATE))
                           (CLOCK (CADDADR STATE))
                           (COUNT (CADDDADR STATE))
                           (DTACK (CADDDDADR STATE))
                           (LAST-RW- (CADDDDDADR STATE))
                           (LAST-ADDRESS (CADDDDDDADR STATE))
                           (LAST-DATA (CADDDDDDDADR STATE))
                           (INSTR (READ-MEM (READ-REGS (CADDDDDDDDDDAR STATE)
                                                       (LIST (CAAAR STATE)
                                                             (CADAAR STATE)
                                                             (CADDAAR STATE)
                                                             (CADDDAAR STATE)))
                                            (CAADR STATE)))
                           (MICROCYCLES (MICROCYCLES STATE)))
         (FM9001-STATE-AS-A-LIST))
    (DISABLE FM9001-STATE-STRUCTURE MACROCYCLE-INVARIANT T_FETCH1)
    (ENABLE MAP-UP REGS FLAGS PC-REG OPEN-NTH FM9001-STEP*)
    (EXPAND (MICROCYCLES STATE))))

(PROVE-LEMMA FM9001-INTERPRETER-CORRECT
         (REWRITE)
         (IMPLIES (AND (FM9001-STATE-STRUCTURE STATE)
                       (MACROCYCLE-INVARIANT STATE PC)
                       (OPERATING-INPUTS-P INPUTS
                                           (TOTAL-MICROCYCLES STATE INPUTS
                                                              INSTRUCTIONS)))
                  (EQUAL (MAP-UP (RUN-FM9001 STATE INPUTS
                                             (TOTAL-MICROCYCLES STATE INPUTS
                                                                INSTRUCTIONS)))
                         (FM9001-INTERPRETER (MAP-UP STATE)
                                             PC INSTRUCTIONS)))
         ((INDUCT (TOTAL-MICROCYCLES STATE INPUTS INSTRUCTIONS))
          (DISABLE FM9001-STATE-STRUCTURE MICROCYCLES MACROCYCLE-INVARIANT)))

(PROVE-LEMMA CHIP-SYSTEM=FM9001-INTERPRETER
 (REWRITE)
 (IMPLIES
  (AND
      (CHIP-SYSTEM& NETLIST)
      (FM9001-STATE-STRUCTURE STATE)
      (MACROCYCLE-INVARIANT STATE PC)
      (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
                                      (TOTAL-MICROCYCLES STATE
                                                         (MAP-UP-INPUTS INPUTS)
                                                         INSTRUCTIONS))
      (OPERATING-INPUTS-P (MAP-UP-INPUTS INPUTS)
                          (TOTAL-MICROCYCLES STATE
                                             (MAP-UP-INPUTS INPUTS)
                                             INSTRUCTIONS)))
  (EQUAL
        (MAP-UP (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                                      INPUTS STATE NETLIST
                                      (TOTAL-MICROCYCLES STATE
                                                         (MAP-UP-INPUTS INPUTS)
                                                         INSTRUCTIONS)))
        (FM9001-INTERPRETER (MAP-UP STATE)
                            PC INSTRUCTIONS)))
 ((DISABLE FM9001-STATE-STRUCTURE MACROCYCLE-INVARIANT MAP-UP
           CHIP-SYSTEM-INVARIANT)))

(PROVE-LEMMA FM9001=FM9001-INTERPRETER NIL
             (EQUAL (FM9001 STATE N)
                    (FM9001-INTERPRETER STATE
                                        (MAKE-LIST 4 T)
                                        N))
             ((ENABLE FM9001 FM9001-INTERPRETER)
              (DISABLE FM9001-STEP)))

(DEFN MAP-DOWN-RELATION
      (HIGH-LEVEL-STATE LOW-LEVEL-STATE)
      (AND (EQUAL (REGS (CAR HIGH-LEVEL-STATE))
                  (CAR (REGS (CAR LOW-LEVEL-STATE))))
           (EQUAL (FLAGS (CAR HIGH-LEVEL-STATE))
                  (FLAGS (CAR LOW-LEVEL-STATE)))
           (EQUAL (CADR HIGH-LEVEL-STATE)
                  (CAADR LOW-LEVEL-STATE))))

(TOGGLE MAP-DOWN-RELATION-OFF MAP-DOWN-RELATION T)

(DEFN HIGH-LEVEL-STATE-STRUCTURE
      (STATE)
      (AND (PROPERP STATE)
           (PROPERP (CAR STATE))
           (EQUAL (LENGTH (CAR STATE)) 2)
           (EQUAL (LENGTH STATE) 2)))

(TOGGLE HIGH-LEVEL-STATE-STRUCTURE-OFF HIGH-LEVEL-STATE-STRUCTURE T)

(PROVE-LEMMA MAP-DOWN-RELATION-LEMMA
             (REWRITE)
             (IMPLIES (AND (HIGH-LEVEL-STATE-STRUCTURE HIGH-LEVEL-STATE)
                           (MAP-DOWN-RELATION HIGH-LEVEL-STATE
                                              LOW-LEVEL-STATE))
                      (EQUAL (MAP-UP LOW-LEVEL-STATE)
                             HIGH-LEVEL-STATE))
             ((ENABLE MAP-DOWN-RELATION HIGH-LEVEL-STATE-STRUCTURE MAP-UP
                      REGS FLAGS OPEN-NTH)))

(PROVE-LEMMA FM9001-INTERPRETER-CORRECT$MAP-DOWN
         (REWRITE)
         (IMPLIES (AND (HIGH-LEVEL-STATE-STRUCTURE HIGH-LEVEL-STATE)
                       (MAP-DOWN-RELATION HIGH-LEVEL-STATE LOW-LEVEL-STATE)
                       (FM9001-STATE-STRUCTURE LOW-LEVEL-STATE)
                       (MACROCYCLE-INVARIANT LOW-LEVEL-STATE PC)
                       (OPERATING-INPUTS-P INPUTS
                                           (TOTAL-MICROCYCLES LOW-LEVEL-STATE
                                                              INPUTS N)))
                  (EQUAL (MAP-UP (RUN-FM9001 LOW-LEVEL-STATE INPUTS
                                             (TOTAL-MICROCYCLES LOW-LEVEL-STATE
                                                                INPUTS N)))
                         (FM9001-INTERPRETER HIGH-LEVEL-STATE PC N)))
         ((DISABLE-THEORY T)
          (ENABLE-THEORY GROUND-ZERO)
          (USE (MAP-DOWN-RELATION-LEMMA)
               (FM9001-INTERPRETER-CORRECT (STATE LOW-LEVEL-STATE)
                                           (INSTRUCTIONS N)))))

(DEFN FM9001-MACHINE-STATEP
      (P-STATE)
      (AND (PROPERP P-STATE)
           (EQUAL (LENGTH P-STATE) 2)
           (ALL-RAMP-MEM 4 (CAR P-STATE))
           (MEMORY-OKP 4 32 (CAR P-STATE))
           (BVP (CADR P-STATE))
           (EQUAL (LENGTH (CADR P-STATE)) 4)))

(DEFN FM9001-STATEP
      (STATE)
      (AND (PROPERP STATE)
           (EQUAL (LENGTH STATE) 2)
           (FM9001-MACHINE-STATEP (CAR STATE))
           (MEMORY-OKP 32 32 (CADR STATE))))

(DEFN P-MAP-DOWN
      (P-STATE)
      (LIST (LIST (CAR P-STATE)
                  F
                  (MAKE-LIST 32 F)
                  (MAKE-LIST 4 T))
            (CADR P-STATE)
            (READ-MEM (MAKE-LIST 4 T)
                      (CAR P-STATE))
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            (READ-MEM (MAKE-LIST 4 T)
                      (CAR P-STATE))
            T T T
            (MAKE-LIST 4 T)
            (CV_FETCH1 T
                       (LIST T T T T)
                       (MAKE-LIST 32 F)
                       (LIST T F F F)
                       (MAKE-LIST 4 T))))

(DEFN MEM-MAP-DOWN
      (MEMORY)
      (LIST MEMORY 0 0 0 T T
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 (X))))

(DEFN MAP-DOWN
      (STATE)
      (LIST (P-MAP-DOWN (CAR STATE))
            (MEM-MAP-DOWN (CADR STATE))))

(PROVE-LEMMA MAP-UP-INVERTS-MAP-DOWN
             (REWRITE)
             (IMPLIES (FM9001-STATEP STATE)
                      (EQUAL (MAP-UP (MAP-DOWN STATE))
                             STATE))
             ((ENABLE REGS FLAGS NTH)
              (DISABLE MAKE-LIST *1*MAKE-LIST CV_FETCH1 *1*CV_FETCH1
                       MEMORY-OKP *1*MEMORY-OKP ALL-RAMP-MEM)))

(PROVE-LEMMA FM9001-STATEP-IMPLIES-FM9001-STATE-STRUCTURE
             (REWRITE)
             (IMPLIES (FM9001-STATEP STATE)
                      (FM9001-STATE-STRUCTURE (MAP-DOWN STATE)))
             ((DISABLE MAKE-LIST *1*MAKE-LIST CV_FETCH1 *1*CV_FETCH1
                       MEMORY-OKP *1*MEMORY-OKP ALL-RAMP-MEM)))

(PROVE-LEMMA FM9001-STATEP-IMPLIES-MACROCYCLE-INVARIANT-LEMMA1
             (REWRITE)
             (EQUAL (EQUAL (CV_FETCH1 T
                                      (LIST T T T T)
                                      (MAKE-LIST 32 F)
                                      (LIST T F F F)
                                      (MAKE-LIST 4 T))
                           (CV_FETCH1 T
                                      (MAKE-LIST 4 T)
                                      (MAKE-LIST 32 F)
                                      Z
                                      (MAKE-LIST 4 T)))
                    T)
             ((ENABLE CV_FETCH1 CARRY-IN-HELP C-FLAG OP-CODE V_FETCH1 APPEND
                      MPG MAKE-LIST)))

(PROVE-LEMMA FM9001-STATEP-IMPLIES-MACROCYCLE-INVARIANT
             (REWRITE)
             (IMPLIES (FM9001-STATEP STATE)
                      (MACROCYCLE-INVARIANT (MAP-DOWN STATE)
                                            (MAKE-LIST 4 T)))
             ((ENABLE LENGTH-MAKE-LIST PROPERP-MAKE-LIST BVP-MAKE-LIST)
              (DISABLE MAKE-LIST *1*MAKE-LIST CARRY-IN-HELP CV_FETCH1
                       READ-MEM MEMORY-OKP *1*MEMORY-OKP ALL-RAMP-MEM)))

(PROVE-LEMMA FM9001=CHIP-SYSTEM-LEMMA1
             (REWRITE)
             (EQUAL (NTH 10 (CAR (MAP-DOWN STATE)))
                    (LIST T T T T))
             ((ENABLE NTH)))

(PROVE-LEMMA FM9001=CHIP-SYSTEM
 (REWRITE)
 (IMPLIES
  (AND
      (CHIP-SYSTEM& NETLIST)
      (FM9001-STATEP STATE)
      (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
                                      (TOTAL-MICROCYCLES (MAP-DOWN STATE)
                                                         (MAP-UP-INPUTS INPUTS)
                                                         N))
      (OPERATING-INPUTS-P (MAP-UP-INPUTS INPUTS)
                          (TOTAL-MICROCYCLES (MAP-DOWN STATE)
                                             (MAP-UP-INPUTS INPUTS)
                                             N)))
  (EQUAL
        (FM9001 STATE N)
        (MAP-UP (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                                      INPUTS
                                      (MAP-DOWN STATE)
                                      NETLIST
                                      (TOTAL-MICROCYCLES (MAP-DOWN STATE)
                                                         (MAP-UP-INPUTS INPUTS)
                                                         N)))))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE FM9001-STATEP-IMPLIES-FM9001-STATE-STRUCTURE
          FM9001-STATEP-IMPLIES-MACROCYCLE-INVARIANT MAP-UP-INVERTS-MAP-DOWN)
  (USE (FM9001=FM9001-INTERPRETER)
       (CHIP-SYSTEM=FM9001-INTERPRETER (STATE (MAP-DOWN STATE))
                                       (INSTRUCTIONS N)
                                       (PC (MAKE-LIST 4 T))))))

(DEFN NO-HOLDS-RESET-OR-TEST
      (I C)
      (AND (CHIP-SYSTEM-OPERATING-INPUTS-P I C)
           (OPERATING-INPUTS-P (MAP-UP-INPUTS I)
                               C)))

(PROVE-LEMMA FM9001=CHIP-SYSTEM-SUMMARY NIL
 (IMPLIES
      (AND (FM9001-STATEP S)
           (NO-HOLDS-RESET-OR-TEST I
                                   (TOTAL-MICROCYCLES (MAP-DOWN S)
                                                      (MAP-UP-INPUTS I)
                                                      N)))
      (EQUAL (FM9001 S N)
             (MAP-UP (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                                           I
                                           (MAP-DOWN S)
                                           (CHIP-SYSTEM$NETLIST)
                                           (TOTAL-MICROCYCLES (MAP-DOWN S)
                                                              (MAP-UP-INPUTS I)
                                                              N)))))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE NO-HOLDS-RESET-OR-TEST *1*CHIP-SYSTEM$NETLIST *1*CHIP-SYSTEM&)
  (USE (FM9001=CHIP-SYSTEM (STATE S)
                           (NETLIST (CHIP-SYSTEM$NETLIST))
                           (INPUTS I)
                           (N N)))))

(DEFN B-KNOWNP
      (X)
      (OR (EQUAL X T)
          (EQUAL X F)
          (EQUAL X (Z))))

(PROVE-LEMMA B-KNOWNP-COMPOUND-RECOGNIZER
             (REWRITE)
             (EQUAL (B-KNOWNP X)
                    (OR (TRUEP X) (FALSEP X) (ZP X))))

(TOGGLE B-KNOWNP-OFF B-KNOWNP T)

(TOGGLE G*1*B-KNOWNP-OFF *1*B-KNOWNP T)

(DEFN B-APPROX
      (A1 A2)
      (IF (B-KNOWNP A1) (EQUAL A1 A2) T))

(DEFN V-APPROX
      (V1 V2)
      (IF (LISTP V1)
          (AND (LISTP V2)
               (B-APPROX (CAR V1) (CAR V2))
               (V-APPROX (CDR V1) (CDR V2)))
          (EQUAL V1 V2)))

(DEFN V-KNOWNP
      (X)
      (IF (LISTP X)
          (AND (B-KNOWNP (CAR X))
               (V-KNOWNP (CDR X)))
          T))

(PROVE-LEMMA V-KNOWNP-IMPLIES-V-APPROX-IS-EQUAL
             (REWRITE)
             (IMPLIES (AND (NOT (EQUAL X Y)) (V-KNOWNP X))
                      (NOT (V-APPROX X Y))))

(TOGGLE PLUS-ADD1-OFF PLUS-ADD1 T)

(DEFN MEM-WIDTH NIL 32)

(DEFN S-APPROX
      (S1 S2)
      (COND ((OR (LISTP S1) (LISTP S2))
             (IF (LISTP S1)
                 (IF (LISTP S2)
                     (AND (S-APPROX (CAR S1) (CAR S2))
                          (S-APPROX (CDR S1) (CDR S2)))
                     F)
                 F))
            ((OR (EQUAL S1 NIL) (EQUAL S2 NIL))
             (EQUAL S1 S2))
            ((OR (RAMP S1) (RAMP S2))
             (IF (RAMP S1)
                 (IF (RAMP S2)
                     (V-APPROX (RAM-GUTS S1) (RAM-GUTS S2))
                     F)
                 F))
            ((OR (ROMP S1) (ROMP S2))
             (IF (ROMP S1)
                 (IF (ROMP S2)
                     (V-APPROX (ROM-GUTS S1) (ROM-GUTS S2))
                     F)
                 F))
            ((OR (STUBP S1) (STUBP S2))
             (IF (STUBP S1)
                 (IF (STUBP S2)
                     (V-APPROX (STUB-GUTS S1)
                               (STUB-GUTS S2))
                     F)
                 F))
            (T (B-APPROX S1 S2))))

(PROVE-LEMMA S-APPROX-X-X
             (REWRITE)
             (S-APPROX X X))

(DEFN GOOD-S
      (S)
      (COND ((LISTP S)
             (AND (GOOD-S (CAR S))
                  (GOOD-S (CDR S))))
            ((RAMP S)
             (AND (EQUAL (LENGTH (RAM-GUTS S))
                         (MEM-WIDTH))
                  (PROPERP (RAM-GUTS S))))
            ((ROMP S)
             (AND (EQUAL (LENGTH (ROM-GUTS S))
                         (MEM-WIDTH))
                  (PROPERP (ROM-GUTS S))))
            ((STUBP S)
             (AND (EQUAL (LENGTH (STUB-GUTS S))
                         (MEM-WIDTH))
                  (PROPERP (STUB-GUTS S))))
            (T T)))

(DEFN S-KNOWNP
      (S)
      (COND ((LISTP S)
             (AND (S-KNOWNP (CAR S))
                  (S-KNOWNP (CDR S))))
            ((EQUAL S NIL) T)
            ((RAMP S) (V-KNOWNP (RAM-GUTS S)))
            ((ROMP S) (V-KNOWNP (ROM-GUTS S)))
            ((STUBP S) (V-KNOWNP (STUB-GUTS S)))
            (T (B-KNOWNP S))))

(PROVE-LEMMA S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL
             (REWRITE)
             (IMPLIES (AND (S-KNOWNP X) (NOT (EQUAL X Y)))
                      (NOT (S-APPROX X Y))))

(TOGGLE PLUS-ADD1-ON PLUS-ADD1 NIL)

(DEFN V-APPROX-ALIST
      (ALIST1 ALIST2)
      (IF (LISTP ALIST1)
          (AND (LISTP ALIST2)
               (EQUAL (CAAR ALIST1) (CAAR ALIST2))
               (B-APPROX (CDAR ALIST1) (CDAR ALIST2))
               (V-APPROX-ALIST (CDR ALIST1)
                               (CDR ALIST2)))
          (NLISTP ALIST2)))

(DEFN S-APPROX-ALIST
      (ALIST1 ALIST2)
      (IF (LISTP ALIST1)
          (AND (LISTP ALIST2)
               (EQUAL (CAAR ALIST1) (CAAR ALIST2))
               (S-APPROX (CDAR ALIST1) (CDAR ALIST2))
               (S-APPROX-ALIST (CDR ALIST1)
                               (CDR ALIST2)))
          (NLISTP ALIST2)))

(DEFN MONOTONICITY-PROPERTY
      (FLAG FN NETLIST A1 A2 S1 S2)
      (CASE FLAG
            (0 (IMPLIES (AND (V-APPROX A1 A2)
                             (S-APPROX S1 S2))
                        (V-APPROX (DUAL-EVAL 0 FN A1 S1 NETLIST)
                                  (DUAL-EVAL 0 FN A2 S2 NETLIST))))
            (1 (IMPLIES (AND (V-APPROX-ALIST A1 A2)
                             (ALISTP A1)
                             (ALISTP A2)
                             (S-APPROX-ALIST S1 S2)
                             (ALISTP S1)
                             (ALISTP S2))
                        (V-APPROX-ALIST (DUAL-EVAL 1 FN A1 S1 NETLIST)
                                        (DUAL-EVAL 1 FN A2 S2 NETLIST))))
            (2 (IMPLIES (AND (V-APPROX A1 A2)
                             (S-APPROX S1 S2))
                        (S-APPROX (DUAL-EVAL 2 FN A1 S1 NETLIST)
                                  (DUAL-EVAL 2 FN A2 S2 NETLIST))))
            (3 (IMPLIES (AND (V-APPROX-ALIST A1 A2)
                             (ALISTP A1)
                             (ALISTP A2)
                             (S-APPROX-ALIST S1 S2)
                             (ALISTP S1)
                             (ALISTP S2))
                        (S-APPROX-ALIST (DUAL-EVAL 3 FN A1 S1 NETLIST)
                                        (DUAL-EVAL 3 FN A2 S2 NETLIST))))
            (OTHERWISE T)))

(TOGGLE MONOTONICITY-PROPERTY-OFF MONOTONICITY-PROPERTY T)

(PROVE-LEMMA MONOTONICITY-PROPERTY-CONSEQUENCE-0
             (REWRITE)
             (IMPLIES (AND (MONOTONICITY-PROPERTY 0 FN NETLIST A1 A2 S1 S2)
                           (V-APPROX A1 A2)
                           (S-APPROX S1 S2))
                      (V-APPROX (DUAL-EVAL 0 FN A1 S1 NETLIST)
                                (DUAL-EVAL 0 FN A2 S2 NETLIST)))
             ((USE (MONOTONICITY-PROPERTY (FLAG 0)))))

(PROVE-LEMMA MONOTONICITY-PROPERTY-CONSEQUENCE-1
             (REWRITE)
             (IMPLIES (AND (MONOTONICITY-PROPERTY 1 FN NETLIST A1 A2 S1 S2)
                           (V-APPROX-ALIST A1 A2)
                           (ALISTP A1)
                           (ALISTP A2)
                           (S-APPROX-ALIST S1 S2)
                           (ALISTP S1)
                           (ALISTP S2))
                      (V-APPROX-ALIST (DUAL-EVAL 1 FN A1 S1 NETLIST)
                                      (DUAL-EVAL 1 FN A2 S2 NETLIST)))
             ((USE (MONOTONICITY-PROPERTY (FLAG 1)))))

(PROVE-LEMMA MONOTONICITY-PROPERTY-CONSEQUENCE-2
             (REWRITE)
             (IMPLIES (AND (MONOTONICITY-PROPERTY 2 FN NETLIST A1 A2 S1 S2)
                           (V-APPROX A1 A2)
                           (S-APPROX S1 S2))
                      (S-APPROX (DUAL-EVAL 2 FN A1 S1 NETLIST)
                                (DUAL-EVAL 2 FN A2 S2 NETLIST)))
             ((USE (MONOTONICITY-PROPERTY (FLAG 2)))))

(PROVE-LEMMA MONOTONICITY-PROPERTY-CONSEQUENCE-3
             (REWRITE)
             (IMPLIES (AND (MONOTONICITY-PROPERTY 3 FN NETLIST A1 A2 S1 S2)
                           (V-APPROX-ALIST A1 A2)
                           (ALISTP A1)
                           (ALISTP A2)
                           (S-APPROX-ALIST S1 S2)
                           (ALISTP S1)
                           (ALISTP S2))
                      (S-APPROX-ALIST (DUAL-EVAL 3 FN A1 S1 NETLIST)
                                      (DUAL-EVAL 3 FN A2 S2 NETLIST)))
             ((USE (MONOTONICITY-PROPERTY (FLAG 3)))))

(PROVE-LEMMA MONOTONICITY-PROPERTY-OPENER-0
             (REWRITE)
             (IFF (MONOTONICITY-PROPERTY 0 FN NETLIST A1 A2 S1 S2)
                  (IMPLIES (AND (V-APPROX A1 A2)
                                (S-APPROX S1 S2))
                           (V-APPROX (DUAL-EVAL 0 FN A1 S1 NETLIST)
                                     (DUAL-EVAL 0 FN A2 S2 NETLIST))))
             ((ENABLE MONOTONICITY-PROPERTY)))

(PROVE-LEMMA MONOTONICITY-PROPERTY-OPENER-1
             (REWRITE)
             (IFF (MONOTONICITY-PROPERTY 1 FN NETLIST A1 A2 S1 S2)
                  (IMPLIES (AND (V-APPROX-ALIST A1 A2)
                                (ALISTP A1)
                                (ALISTP A2)
                                (S-APPROX-ALIST S1 S2)
                                (ALISTP S1)
                                (ALISTP S2))
                           (V-APPROX-ALIST (DUAL-EVAL 1 FN A1 S1 NETLIST)
                                           (DUAL-EVAL 1 FN A2 S2 NETLIST))))
             ((ENABLE MONOTONICITY-PROPERTY)))

(PROVE-LEMMA MONOTONICITY-PROPERTY-OPENER-2
             (REWRITE)
             (IFF (MONOTONICITY-PROPERTY 2 FN NETLIST A1 A2 S1 S2)
                  (IMPLIES (AND (V-APPROX A1 A2)
                                (S-APPROX S1 S2))
                           (S-APPROX (DUAL-EVAL 2 FN A1 S1 NETLIST)
                                     (DUAL-EVAL 2 FN A2 S2 NETLIST))))
             ((ENABLE MONOTONICITY-PROPERTY)))

(PROVE-LEMMA MONOTONICITY-PROPERTY-OPENER-3
             (REWRITE)
             (IFF (MONOTONICITY-PROPERTY 3 FN NETLIST A1 A2 S1 S2)
                  (IMPLIES (AND (V-APPROX-ALIST A1 A2)
                                (ALISTP A1)
                                (ALISTP A2)
                                (S-APPROX-ALIST S1 S2)
                                (ALISTP S1)
                                (ALISTP S2))
                           (S-APPROX-ALIST (DUAL-EVAL 3 FN A1 S1 NETLIST)
                                           (DUAL-EVAL 3 FN A2 S2 NETLIST))))
             ((ENABLE MONOTONICITY-PROPERTY)))

(TOGGLE MONOTONICITY-PROPERTY-OPENER-0-OFF MONOTONICITY-PROPERTY-OPENER-0 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-1-OFF MONOTONICITY-PROPERTY-OPENER-1 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-2-OFF MONOTONICITY-PROPERTY-OPENER-2 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-3-OFF MONOTONICITY-PROPERTY-OPENER-3 T)

(PROVE-LEMMA F-BUF-MONOTONE
             (REWRITE)
             (IMPLIES (B-APPROX A1 A2)
                      (B-APPROX (F-BUF A1) (F-BUF A2))))

(PROVE-LEMMA F-AND-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-AND A1 B1)
                                (F-AND A2 B2))))

(PROVE-LEMMA F-AND3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-AND3 A1 B1 C1)
                                (F-AND3 A2 B2 C2)))
             ((DISABLE F-AND B-APPROX)))

(PROVE-LEMMA F-AND4-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2))
                      (B-APPROX (F-AND4 A1 B1 C1 D1)
                                (F-AND4 A2 B2 C2 D2)))
             ((DISABLE F-AND B-APPROX)))

(PROVE-LEMMA F-NOT-MONOTONE
             (REWRITE)
             (IMPLIES (B-APPROX A1 A2)
                      (B-APPROX (F-NOT A1) (F-NOT A2)))
             ((ENABLE BOOLP)))

(PROVE-LEMMA F-NAND-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-NAND A1 B1)
                                (F-NAND A2 B2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-NAND3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-NAND3 A1 B1 C1)
                                (F-NAND3 A2 B2 C2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-NAND4-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2))
                      (B-APPROX (F-NAND4 A1 B1 C1 D1)
                                (F-NAND4 A2 B2 C2 D2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-NAND5-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2))
                      (B-APPROX (F-NAND5 A1 B1 C1 D1 E1)
                                (F-NAND5 A2 B2 C2 D2 E2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-NAND6-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2)
                           (B-APPROX G1 G2))
                      (B-APPROX (F-NAND6 A1 B1 C1 D1 E1 G1)
                                (F-NAND6 A2 B2 C2 D2 E2 G2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-NAND8-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2)
                           (B-APPROX G1 G2)
                           (B-APPROX H1 H2)
                           (B-APPROX I1 I2))
                      (B-APPROX (F-NAND8 A1 B1 C1 D1 E1 G1 H1 I1)
                                (F-NAND8 A2 B2 C2 D2 E2 G2 H2 I2)))
             ((DISABLE F-AND F-NOT B-APPROX)))

(PROVE-LEMMA F-OR-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-OR A1 B1) (F-OR A2 B2))))

(PROVE-LEMMA F-OR3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-OR3 A1 B1 C1)
                                (F-OR3 A2 B2 C2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-OR4-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2))
                      (B-APPROX (F-OR4 A1 B1 C1 D1)
                                (F-OR4 A2 B2 C2 D2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-NOR A1 B1)
                                (F-NOR A2 B2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-NOR3 A1 B1 C1)
                                (F-NOR3 A2 B2 C2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR4-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2))
                      (B-APPROX (F-NOR4 A1 B1 C1 D1)
                                (F-NOR4 A2 B2 C2 D2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR5-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2))
                      (B-APPROX (F-NOR5 A1 B1 C1 D1 E1)
                                (F-NOR5 A2 B2 C2 D2 E2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR6-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2)
                           (B-APPROX G1 G2))
                      (B-APPROX (F-NOR6 A1 B1 C1 D1 E1 G1)
                                (F-NOR6 A2 B2 C2 D2 E2 G2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-NOR8-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2)
                           (B-APPROX D1 D2)
                           (B-APPROX E1 E2)
                           (B-APPROX G1 G2)
                           (B-APPROX H1 H2)
                           (B-APPROX I1 I2))
                      (B-APPROX (F-NOR8 A1 B1 C1 D1 E1 G1 H1 I1)
                                (F-NOR8 A2 B2 C2 D2 E2 G2 H2 I2)))
             ((DISABLE F-OR F-NOT B-APPROX)))

(PROVE-LEMMA F-XOR-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-XOR A1 B1)
                                (F-XOR A2 B2)))
             ((ENABLE BOOLP)))

(PROVE-LEMMA F-EQUV-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-EQUV A1 B1)
                                (F-EQUV A2 B2)))
             ((ENABLE BOOLP)))

(PROVE-LEMMA F-XOR3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-XOR3 A1 B1 C1)
                                (F-XOR3 A2 B2 C2)))
             ((DISABLE F-XOR F-EQUV B-APPROX)))

(PROVE-LEMMA F-EQUV3-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2)
                           (B-APPROX C1 C2))
                      (B-APPROX (F-EQUV3 A1 B1 C1)
                                (F-EQUV3 A2 B2 C2)))
             ((DISABLE F-XOR F-EQUV B-APPROX)))

(PROVE-LEMMA F-IF-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX C1 C2)
                           (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (F-IF C1 A1 B1)
                                (F-IF C2 A2 B2))))

(PROVE-LEMMA FT-BUF-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX C1 C2)
                           (B-APPROX A1 A2))
                      (B-APPROX (FT-BUF C1 A1)
                                (FT-BUF C2 A2))))

(PROVE-LEMMA FT-WIRE-MONOTONE
             (REWRITE)
             (IMPLIES (AND (B-APPROX A1 A2)
                           (B-APPROX B1 B2))
                      (B-APPROX (FT-WIRE A1 B1)
                                (FT-WIRE A2 B2))))

(PROVE-LEMMA F-PULLUP-MONOTONE
             (REWRITE)
             (IMPLIES (B-APPROX A1 A2)
                      (B-APPROX (F-PULLUP A1)
                                (F-PULLUP A2))))

(TOGGLE F-BUF-OFF F-BUF T)

(TOGGLE F-AND-OFF F-AND T)

(TOGGLE F-AND3-OFF F-AND3 T)

(TOGGLE F-AND4-OFF F-AND4 T)

(TOGGLE F-NOT-OFF F-NOT T)

(TOGGLE F-NAND-OFF F-NAND T)

(TOGGLE F-NAND3-OFF F-NAND3 T)

(TOGGLE F-NAND4-OFF F-NAND4 T)

(TOGGLE F-NAND5-OFF F-NAND5 T)

(TOGGLE F-NAND6-OFF F-NAND6 T)

(TOGGLE F-NAND8-OFF F-NAND8 T)

(TOGGLE F-OR-OFF F-OR T)

(TOGGLE F-OR3-OFF F-OR3 T)

(TOGGLE F-OR4-OFF F-OR4 T)

(TOGGLE F-NOR-OFF F-NOR T)

(TOGGLE F-NOR3-OFF F-NOR3 T)

(TOGGLE F-NOR4-OFF F-NOR4 T)

(TOGGLE F-NOR5-OFF F-NOR5 T)

(TOGGLE F-NOR6-OFF F-NOR6 T)

(TOGGLE F-NOR8-OFF F-NOR8 T)

(TOGGLE F-XOR-OFF F-XOR T)

(TOGGLE F-XOR3-OFF F-XOR3 T)

(TOGGLE F-EQUV-OFF F-EQUV T)

(TOGGLE F-EQUV3-OFF F-EQUV3 T)

(TOGGLE F-IF-OFF F-IF T)

(TOGGLE FT-BUF-OFF FT-BUF T)

(TOGGLE FT-WIRE-OFF FT-WIRE T)

(TOGGLE F-PULLUP-OFF F-PULLUP T)

(DEFTHEORY MONOTONICITY-LEMMAS
           (F-BUF-MONOTONE F-AND-MONOTONE F-AND3-MONOTONE F-AND4-MONOTONE
                           F-NOT-MONOTONE F-NAND-MONOTONE F-NAND3-MONOTONE
                           F-NAND4-MONOTONE F-NAND5-MONOTONE F-NAND6-MONOTONE
                           F-NAND8-MONOTONE F-OR-MONOTONE F-OR3-MONOTONE
                           F-OR4-MONOTONE F-NOR-MONOTONE F-NOR3-MONOTONE
                           F-NOR4-MONOTONE F-NOR5-MONOTONE F-NOR6-MONOTONE
                           F-NOR8-MONOTONE F-XOR-MONOTONE F-XOR3-MONOTONE
                           F-EQUV-MONOTONE F-EQUV3-MONOTONE F-IF-MONOTONE
                           FT-BUF-MONOTONE FT-WIRE-MONOTONE F-PULLUP-MONOTONE))

(TOGGLE B-APPROX-OFF B-APPROX T)

(PROVE-LEMMA DUAL-EVAL-0-PRIMP
             (REWRITE)
             (IMPLIES (PRIMP NAME)
                      (EQUAL (DUAL-EVAL 0 NAME ARGS STATE NETLIST)
                             (DUAL-APPLY-VALUE NAME ARGS STATE)))
             ((ENABLE DUAL-EVAL)))

(PROVE-LEMMA DUAL-EVAL-2-PRIMP
             (REWRITE)
             (IMPLIES (PRIMP NAME)
                      (EQUAL (DUAL-EVAL 2 NAME ARGS STATE NETLIST)
                             (DUAL-APPLY-STATE NAME ARGS STATE)))
             ((ENABLE DUAL-EVAL)))

(PROVE-LEMMA S-APPROX-IMPLIES-B-APPROX
             (REWRITE)
             (IMPLIES (S-APPROX X Y)
                      (B-APPROX X Y))
             ((ENABLE B-APPROX)))

(PROVE-LEMMA F-BUF-TYPE-SET
             (REWRITE)
             (OR (TRUEP (F-BUF X))
                 (FALSEP (F-BUF X))
                 (XP (F-BUF X)))
             ((ENABLE F-BUF BOOLP)))

(PROVE-LEMMA FOURP-F-BUF
             (REWRITE)
             (FOURP (F-BUF X)))

(PROVE-LEMMA FOURP-F-IF
             (REWRITE)
             (FOURP (F-IF X Y Z))
             ((ENABLE F-IF)
              (DISABLE F-IF-REWRITE)))

(PROVE-LEMMA FOURP-IMPLIES-S-APPROX-IS-B-APPROX
             (REWRITE)
             (IMPLIES (AND (FOURP X)
                           (FOURP Y)
                           (B-APPROX X Y))
                      (EQUAL (S-APPROX X Y) T)))

(PROVE-LEMMA DUAL-EVAL-AO2-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'AO2 ARGS STATE NETLIST)
                    (LIST (F-NOR (F-AND (CAR ARGS) (CADR ARGS))
                                 (F-AND (CADDR ARGS) (CADDDR ARGS)))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-AO2-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'AO2 ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA AO2-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'AO2
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'AO2
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-AO2-VALUE
                      DUAL-EVAL-AO2-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-AO4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'AO4 ARGS STATE NETLIST)
                    (LIST (F-NAND (F-OR (CAR ARGS) (CADR ARGS))
                                  (F-OR (CADDR ARGS) (CADDDR ARGS)))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-AO4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'AO4 ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA AO4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'AO4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'AO4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-AO4-VALUE
                      DUAL-EVAL-AO4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-AO6-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'AO6 ARGS STATE NETLIST)
                    (LIST (F-NOR (F-AND (CAR ARGS) (CADR ARGS))
                                 (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-AO6-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'AO6 ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA AO6-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'AO6
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'AO6
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-AO6-VALUE
                      DUAL-EVAL-AO6-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-AO7-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'AO7 ARGS STATE NETLIST)
                    (LIST (F-NAND (F-OR (CAR ARGS) (CADR ARGS))
                                  (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-AO7-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'AO7 ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA AO7-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'AO7
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'AO7
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-AO7-VALUE
                      DUAL-EVAL-AO7-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-AND-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-AND
                               ARGS STATE NETLIST)
                    (LIST (F-AND (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-AND-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-AND
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-AND-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-AND
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-AND
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-AND-VALUE
                      DUAL-EVAL-B-AND-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-AND3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-AND3
                               ARGS STATE NETLIST)
                    (LIST (F-AND3 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-AND3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-AND3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-AND3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-AND3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-AND3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-AND3-VALUE
                      DUAL-EVAL-B-AND3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-AND4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-AND4
                               ARGS STATE NETLIST)
                    (LIST (F-AND4 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS)
                                  (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-AND4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-AND4
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-AND4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-AND4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-AND4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-AND4-VALUE
                      DUAL-EVAL-B-AND4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-EQUV-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-EQUV
                               ARGS STATE NETLIST)
                    (LIST (F-EQUV (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-EQUV-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-EQUV
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-EQUV-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-EQUV
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-EQUV
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-EQUV-VALUE
                      DUAL-EVAL-B-EQUV-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-EQUV3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-EQUV3
                               ARGS STATE NETLIST)
                    (LIST (F-EQUV3 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-EQUV3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-EQUV3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-EQUV3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-EQUV3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-EQUV3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-EQUV3-VALUE
                      DUAL-EVAL-B-EQUV3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-IF-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-IF
                               ARGS STATE NETLIST)
                    (LIST (F-IF (CAR ARGS)
                                (CADR ARGS)
                                (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-IF-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-IF
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-IF-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-IF
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-IF
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-IF-VALUE
                      DUAL-EVAL-B-IF-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND
                               ARGS STATE NETLIST)
                    (LIST (F-NAND (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND-VALUE
                      DUAL-EVAL-B-NAND-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND3
                               ARGS STATE NETLIST)
                    (LIST (F-NAND3 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND3-VALUE
                      DUAL-EVAL-B-NAND3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND4
                               ARGS STATE NETLIST)
                    (LIST (F-NAND4 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS)
                                   (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND4
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND4-VALUE
                      DUAL-EVAL-B-NAND4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND5-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND5
                               ARGS STATE NETLIST)
                    (LIST (F-NAND5 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS)
                                   (CADDDR ARGS)
                                   (CADDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND5-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND5
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND5-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND5
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND5
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND5-VALUE
                      DUAL-EVAL-B-NAND5-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND6-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND6
                               ARGS STATE NETLIST)
                    (LIST (F-NAND6 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS)
                                   (CADDDR ARGS)
                                   (CADDDDR ARGS)
                                   (CADDDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND6-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND6
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND6-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND6
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND6
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND6-VALUE
                      DUAL-EVAL-B-NAND6-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2))
                      (V-APPROX (CDDDDDR A1)
                                (CDDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NAND8-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NAND8
                               ARGS STATE NETLIST)
                    (LIST (F-NAND8 (CAR ARGS)
                                   (CADR ARGS)
                                   (CADDR ARGS)
                                   (CADDDR ARGS)
                                   (CADDDDR ARGS)
                                   (CADDDDDR ARGS)
                                   (CADDDDDDR ARGS)
                                   (CADDDDDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NAND8-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NAND8
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NAND8-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NAND8
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NAND8
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NAND8-VALUE
                      DUAL-EVAL-B-NAND8-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2))
                      (V-APPROX (CDDDDDR A1) (CDDDDDR A2))
                      (V-APPROX (CDDDDDDR A1) (CDDDDDDR A2))
                      (V-APPROX (CDDDDDDDR A1)
                                (CDDDDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NBUF-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NBUF
                               ARGS STATE NETLIST)
                    (LIST (F-NOT (CAR ARGS))
                          (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NBUF-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NBUF
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NBUF-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NBUF
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NBUF
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NBUF-VALUE
                      DUAL-EVAL-B-NBUF-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-B-NOR-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR
                               ARGS STATE NETLIST)
                    (LIST (F-NOR (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR-VALUE
                      DUAL-EVAL-B-NOR-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOR3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR3
                               ARGS STATE NETLIST)
                    (LIST (F-NOR3 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR3-VALUE
                      DUAL-EVAL-B-NOR3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOR4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR4
                               ARGS STATE NETLIST)
                    (LIST (F-NOR4 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS)
                                  (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR4
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR4-VALUE
                      DUAL-EVAL-B-NOR4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOR5-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR5
                               ARGS STATE NETLIST)
                    (LIST (F-NOR5 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS)
                                  (CADDDR ARGS)
                                  (CADDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR5-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR5
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR5-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR5
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR5
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR5-VALUE
                      DUAL-EVAL-B-NOR5-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOR6-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR6
                               ARGS STATE NETLIST)
                    (LIST (F-NOR6 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS)
                                  (CADDDR ARGS)
                                  (CADDDDR ARGS)
                                  (CADDDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR6-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR6
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR6-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR6
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR6
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR6-VALUE
                      DUAL-EVAL-B-NOR6-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2))
                      (V-APPROX (CDDDDDR A1)
                                (CDDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOR8-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOR8
                               ARGS STATE NETLIST)
                    (LIST (F-NOR8 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS)
                                  (CADDDR ARGS)
                                  (CADDDDR ARGS)
                                  (CADDDDDR ARGS)
                                  (CADDDDDDR ARGS)
                                  (CADDDDDDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOR8-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOR8
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOR8-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOR8
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOR8
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOR8-VALUE
                      DUAL-EVAL-B-NOR8-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2))
                      (V-APPROX (CDDDDDR A1) (CDDDDDR A2))
                      (V-APPROX (CDDDDDDR A1) (CDDDDDDR A2))
                      (V-APPROX (CDDDDDDDR A1)
                                (CDDDDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-NOT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOT
                               ARGS STATE NETLIST)
                    (LIST (F-NOT (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-NOT-VALUE
                      DUAL-EVAL-B-NOT-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-B-NOT-B4IP-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOT-B4IP
                               ARGS STATE NETLIST)
                    (LIST (F-NOT (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOT-B4IP-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOT-B4IP
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOT-B4IP-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOT-B4IP
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOT-B4IP
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-B-NOT-B4IP-VALUE DUAL-EVAL-B-NOT-B4IP-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-B-NOT-IVAP-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-NOT-IVAP
                               ARGS STATE NETLIST)
                    (LIST (F-NOT (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-NOT-IVAP-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-NOT-IVAP
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-NOT-IVAP-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-NOT-IVAP
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-NOT-IVAP
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-B-NOT-IVAP-VALUE DUAL-EVAL-B-NOT-IVAP-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-B-OR-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-OR
                               ARGS STATE NETLIST)
                    (LIST (F-OR (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-OR-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-OR
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-OR-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-OR
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-OR
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-OR-VALUE
                      DUAL-EVAL-B-OR-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-OR3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-OR3
                               ARGS STATE NETLIST)
                    (LIST (F-OR3 (CAR ARGS)
                                 (CADR ARGS)
                                 (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-OR3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-OR3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-OR3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-OR3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-OR3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-OR3-VALUE
                      DUAL-EVAL-B-OR3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-OR4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-OR4
                               ARGS STATE NETLIST)
                    (LIST (F-OR4 (CAR ARGS)
                                 (CADR ARGS)
                                 (CADDR ARGS)
                                 (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-OR4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-OR4
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-OR4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-OR4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-OR4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-OR4-VALUE
                      DUAL-EVAL-B-OR4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-XOR-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-XOR
                               ARGS STATE NETLIST)
                    (LIST (F-XOR (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-XOR-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-XOR
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-XOR-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-XOR
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-XOR
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-XOR-VALUE
                      DUAL-EVAL-B-XOR-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-B-XOR3-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'B-XOR3
                               ARGS STATE NETLIST)
                    (LIST (F-XOR3 (CAR ARGS)
                                  (CADR ARGS)
                                  (CADDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-B-XOR3-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'B-XOR3
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA B-XOR3-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'B-XOR3
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'B-XOR3
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-B-XOR3-VALUE
                      DUAL-EVAL-B-XOR3-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-DEL2-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'DEL2
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-DEL2-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'DEL2
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA DEL2-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'DEL2
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'DEL2
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-DEL2-VALUE
                      DUAL-EVAL-DEL2-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-DEL4-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'DEL4
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-DEL4-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'DEL4
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA DEL4-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'DEL4
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'DEL4
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-DEL4-VALUE
                      DUAL-EVAL-DEL4-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-DEL10-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'DEL10
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-DEL10-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'DEL10
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA DEL10-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'DEL10
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'DEL10
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-DEL10-VALUE
                      DUAL-EVAL-DEL10-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-PROCMON-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'PROCMON
                               ARGS STATE NETLIST)
                    (LIST (F-IF (CADDR ARGS)
                                (F-IF (CADR ARGS)
                                      (F-IF (CAR ARGS) F F)
                                      (CAR ARGS))
                                (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-PROCMON-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'PROCMON
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA PROCMON-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'PROCMON
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'PROCMON
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-PROCMON-VALUE
                      DUAL-EVAL-PROCMON-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-FD1-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'FD1 ARGS STATE NETLIST)
                    (LIST (F-BUF STATE) (F-NOT STATE)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-FD1-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'FD1 ARGS STATE NETLIST)
                    (F-BUF (CAR ARGS)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA FD1-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'FD1
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'FD1
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-FD1-VALUE
                      DUAL-EVAL-FD1-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-FD1S-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'FD1S
                               ARGS STATE NETLIST)
                    (LIST (F-BUF STATE) (F-NOT STATE)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-FD1S-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'FD1S
                               ARGS STATE NETLIST)
                    (F-IF (CADDDR ARGS)
                          (CADDR ARGS)
                          (CAR ARGS)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA FD1S-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'FD1S
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'FD1S
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-FD1S-VALUE
                      DUAL-EVAL-FD1S-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-FD1SP-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'FD1SP
                               ARGS STATE NETLIST)
                    (LIST (F-BUF STATE) (F-NOT STATE)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-FD1SP-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'FD1SP
                               ARGS STATE NETLIST)
                    (F-IF (CADDDR ARGS)
                          (CADDR ARGS)
                          (CAR ARGS)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA FD1SP-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'FD1SP
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'FD1SP
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-FD1SP-VALUE
                      DUAL-EVAL-FD1SP-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-FD1SLP-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'FD1SLP
                               ARGS STATE NETLIST)
                    (LIST (F-BUF STATE) (F-NOT STATE)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-FD1SLP-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'FD1SLP
                               ARGS STATE NETLIST)
                    (F-IF (CADDDDR ARGS)
                          (CADDDR ARGS)
                          (F-IF (CADDR ARGS) (CAR ARGS) STATE)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA FD1SLP-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'FD1SLP
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'FD1SLP
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-FD1SLP-VALUE
                      DUAL-EVAL-FD1SLP-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2))
                      (V-APPROX (CDDDDR A1) (CDDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-ID-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'ID ARGS STATE NETLIST)
                    (LIST (CAR ARGS)))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-ID-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'ID ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA ID-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'ID
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'ID
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-ID-VALUE
                      DUAL-EVAL-ID-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'RAM-ENABLE-CIRCUIT
                               ARGS STATE NETLIST)
                    (LIST (F-NAND (CADDR ARGS) (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'RAM-ENABLE-CIRCUIT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA RAM-ENABLE-CIRCUIT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'RAM-ENABLE-CIRCUIT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'RAM-ENABLE-CIRCUIT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE
                      DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-T-BUF-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'T-BUF
                               ARGS STATE NETLIST)
                    (LIST (FT-BUF (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-T-BUF-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'T-BUF
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA T-BUF-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'T-BUF
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'T-BUF
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-T-BUF-VALUE
                      DUAL-EVAL-T-BUF-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-T-WIRE-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'T-WIRE
                               ARGS STATE NETLIST)
                    (LIST (FT-WIRE (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-T-WIRE-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'T-WIRE
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA T-WIRE-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'T-WIRE
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'T-WIRE
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-T-WIRE-VALUE
                      DUAL-EVAL-T-WIRE-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-PULLUP-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'PULLUP
                               ARGS STATE NETLIST)
                    (LIST (F-PULLUP (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-PULLUP-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'PULLUP
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA PULLUP-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'PULLUP
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'PULLUP
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-PULLUP-VALUE
                      DUAL-EVAL-PULLUP-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-TTL-BIDIRECT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-BIDIRECT
                               ARGS STATE NETLIST)
                    (LIST (FT-BUF (F-NOT (CADDR ARGS))
                                  (CADR ARGS))
                          (F-BUF (FT-WIRE (CAR ARGS)
                                          (FT-BUF (F-NOT (CADDR ARGS))
                                                  (CADR ARGS))))
                          (F-NAND (FT-WIRE (CAR ARGS)
                                           (FT-BUF (F-NOT (CADDR ARGS))
                                                   (CADR ARGS)))
                                  (CADDDR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-BIDIRECT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-BIDIRECT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-BIDIRECT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-BIDIRECT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-BIDIRECT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-BIDIRECT-VALUE
                      DUAL-EVAL-TTL-BIDIRECT-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2))
                      (V-APPROX (CDDR A1) (CDDR A2))
                      (V-APPROX (CDDDR A1) (CDDDR A2)))))

(PROVE-LEMMA DUAL-EVAL-TTL-CLK-INPUT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-CLK-INPUT
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))
                          (F-NAND (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-CLK-INPUT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-CLK-INPUT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-CLK-INPUT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-CLK-INPUT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-CLK-INPUT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-CLK-INPUT-VALUE
                      DUAL-EVAL-TTL-CLK-INPUT-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-TTL-INPUT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-INPUT
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))
                          (F-NAND (CAR ARGS) (CADR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-INPUT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-INPUT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-INPUT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-INPUT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-INPUT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-TTL-INPUT-VALUE
                      DUAL-EVAL-TTL-INPUT-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-OUTPUT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-OUTPUT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-OUTPUT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-OUTPUT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-OUTPUT-VALUE DUAL-EVAL-TTL-OUTPUT-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT-PARAMETRIC
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-OUTPUT-PARAMETRIC
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-OUTPUT-PARAMETRIC-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-OUTPUT-PARAMETRIC
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-OUTPUT-PARAMETRIC
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE
                      DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-FAST-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-OUTPUT-FAST
                               ARGS STATE NETLIST)
                    (LIST (F-BUF (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-OUTPUT-FAST-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-OUTPUT-FAST
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-OUTPUT-FAST-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-OUTPUT-FAST
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-OUTPUT-FAST
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-OUTPUT-FAST-VALUE
                      DUAL-EVAL-TTL-OUTPUT-FAST-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2))))

(PROVE-LEMMA DUAL-EVAL-TTL-TRI-OUTPUT-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-TRI-OUTPUT
                               ARGS STATE NETLIST)
                    (LIST (FT-BUF (F-NOT (CADR ARGS))
                                  (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-TRI-OUTPUT-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-TRI-OUTPUT
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-TRI-OUTPUT-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-TRI-OUTPUT
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-TRI-OUTPUT
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-TRI-OUTPUT-VALUE
                      DUAL-EVAL-TTL-TRI-OUTPUT-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'TTL-TRI-OUTPUT-FAST
                               ARGS STATE NETLIST)
                    (LIST (FT-BUF (F-NOT (CADR ARGS))
                                  (CAR ARGS))))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'TTL-TRI-OUTPUT-FAST
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA TTL-TRI-OUTPUT-FAST-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'TTL-TRI-OUTPUT-FAST
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'TTL-TRI-OUTPUT-FAST
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE
                      DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE
                      S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND (V-APPROX A1 A2)
                      (V-APPROX (CDR A1) (CDR A2)))))

(PROVE-LEMMA DUAL-EVAL-VDD-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'VDD ARGS STATE NETLIST)
                    (LIST T))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-VDD-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'VDD ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA VDD-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'VDD
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'VDD
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-VDD-VALUE
                      DUAL-EVAL-VDD-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND)))

(PROVE-LEMMA DUAL-EVAL-VDD-PARAMETRIC-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'VDD-PARAMETRIC
                               ARGS STATE NETLIST)
                    (LIST T))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-VDD-PARAMETRIC-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'VDD-PARAMETRIC
                               ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA VDD-PARAMETRIC-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'VDD-PARAMETRIC
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'VDD-PARAMETRIC
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2
                      DUAL-EVAL-VDD-PARAMETRIC-VALUE
                      DUAL-EVAL-VDD-PARAMETRIC-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND)))

(PROVE-LEMMA DUAL-EVAL-VSS-VALUE
             (REWRITE)
             (EQUAL (DUAL-EVAL 0 'VSS ARGS STATE NETLIST)
                    (LIST F))
             ((ENABLE DUAL-EVAL DUAL-APPLY-VALUE)))

(PROVE-LEMMA DUAL-EVAL-VSS-STATE
             (REWRITE)
             (EQUAL (DUAL-EVAL 2 'VSS ARGS STATE NETLIST)
                    0)
             ((ENABLE DUAL-EVAL DUAL-APPLY-STATE)))

(PROVE-LEMMA VSS-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'VSS
                                         NETLIST A1 A2 S1 S2)
                  (MONOTONICITY-PROPERTY 2 'VSS
                                         NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO MONOTONICITY-LEMMAS)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      MONOTONICITY-PROPERTY-OPENER-0
                      MONOTONICITY-PROPERTY-OPENER-2 DUAL-EVAL-VSS-VALUE
                      DUAL-EVAL-VSS-STATE S-APPROX-IMPLIES-B-APPROX
                      FOURP-IMPLIES-S-APPROX-IS-B-APPROX FOURP-F-BUF
                      FOURP-F-IF)
              (EXPAND)))

(DEFTHEORY PRIMITIVES-MONOTONE
           (AO2-MONOTONE AO4-MONOTONE AO6-MONOTONE AO7-MONOTONE B-AND-MONOTONE
                         B-AND3-MONOTONE B-AND4-MONOTONE B-EQUV-MONOTONE
                         B-EQUV3-MONOTONE B-IF-MONOTONE B-NAND-MONOTONE
                         B-NAND3-MONOTONE B-NAND4-MONOTONE B-NAND5-MONOTONE
                         B-NAND6-MONOTONE B-NAND8-MONOTONE B-NBUF-MONOTONE
                         B-NOR-MONOTONE B-NOR3-MONOTONE B-NOR4-MONOTONE
                         B-NOR5-MONOTONE B-NOR6-MONOTONE B-NOR8-MONOTONE
                         B-NOT-MONOTONE B-NOT-B4IP-MONOTONE
                         B-NOT-IVAP-MONOTONE B-OR-MONOTONE B-OR3-MONOTONE
                         B-OR4-MONOTONE B-XOR-MONOTONE B-XOR3-MONOTONE
                         DEL2-MONOTONE DEL4-MONOTONE DEL10-MONOTONE
                         PROCMON-MONOTONE FD1-MONOTONE FD1S-MONOTONE
                         FD1SP-MONOTONE FD1SLP-MONOTONE ID-MONOTONE
                         RAM-ENABLE-CIRCUIT-MONOTONE T-BUF-MONOTONE
                         T-WIRE-MONOTONE PULLUP-MONOTONE TTL-BIDIRECT-MONOTONE
                         TTL-CLK-INPUT-MONOTONE TTL-INPUT-MONOTONE
                         TTL-OUTPUT-MONOTONE TTL-OUTPUT-PARAMETRIC-MONOTONE
                         TTL-OUTPUT-FAST-MONOTONE TTL-TRI-OUTPUT-MONOTONE
                         TTL-TRI-OUTPUT-FAST-MONOTONE VDD-MONOTONE
                         VDD-PARAMETRIC-MONOTONE VSS-MONOTONE))

(PROVE-LEMMA BVP-REV1
             (REWRITE)
             (IMPLIES (AND (BVP X) (BVP ACC))
                      (BVP (REV1 X ACC)))
             ((ENABLE BVP REV1)))

(PROVE-LEMMA BVP-REVERSE
             (REWRITE)
             (IMPLIES (BVP X) (BVP (REVERSE X)))
             ((ENABLE REVERSE)))

(PROVE-LEMMA V-APPROX-BVP
             (REWRITE)
             (IMPLIES (BVP X)
                      (EQUAL (V-APPROX X Y) (EQUAL X Y)))
             ((ENABLE B-KNOWNP B-APPROX)))

(DEFN READ-MEM1-MONOTONE-INDUCTION
      (V-ADDR MEM1 MEM2)
      (COND ((OR (STUBP MEM1)
                 (STUBP MEM2)
                 (NLISTP V-ADDR)
                 (NLISTP MEM1)
                 (NLISTP MEM2))
             T)
            ((CAR V-ADDR)
             (READ-MEM1-MONOTONE-INDUCTION (CDR V-ADDR)
                                           (CDR MEM1)
                                           (CDR MEM2)))
            (T (READ-MEM1-MONOTONE-INDUCTION (CDR V-ADDR)
                                             (CAR MEM1)
                                             (CAR MEM2)))))

(PROVE-LEMMA READ-MEM1-MONOTONE
             (REWRITE)
             (IMPLIES (AND (BVP V-ADDR)
                           (S-APPROX MEM1 MEM2))
                      (V-APPROX (READ-MEM1 V-ADDR MEM1)
                                (READ-MEM1 V-ADDR MEM2)))
             ((ENABLE READ-MEM1)
              (INDUCT (READ-MEM1-MONOTONE-INDUCTION V-ADDR MEM1 MEM2))))

(PROVE-LEMMA BVP-IMPLIES-V-KNOWNP
             (REWRITE)
             (IMPLIES (BVP X) (V-KNOWNP X))
             ((ENABLE BVP V-KNOWNP BOOLP)))

(PROVE-LEMMA V-APPROX-X-X
             (REWRITE)
             (V-APPROX X X)
             ((ENABLE B-APPROX)))

(PROVE-LEMMA V-APPROX-IMPLIES-B-APPROX-NTH
             (REWRITE)
             (IMPLIES (AND (EQUAL (NTH N X) C)
                           (NOT (EQUAL (NTH N Y) C))
                           (B-KNOWNP C))
                      (NOT (V-APPROX X Y)))
             ((ENABLE B-APPROX B-KNOWNP NTH)))

(TOGGLE G*1*B-KNOWNP-ON *1*B-KNOWNP NIL)

(PROVE-LEMMA V-APPROX-IMPLIES-SUBRANGES-EQUAL
             (REWRITE)
             (IMPLIES (AND (V-APPROX X Y)
                           (BVP (SUBRANGE X I J)))
                      (EQUAL (SUBRANGE X I J)
                             (SUBRANGE Y I J)))
             ((ENABLE SUBRANGE BVP BOOLP B-APPROX B-KNOWNP)))

(PROVE-LEMMA V-APPROX-BVP-SUBRANGE
             (REWRITE)
             (IMPLIES (AND (V-APPROX A1 A2)
                           (BVP (SUBRANGE A1 I J)))
                      (BVP (SUBRANGE A2 I J)))
             ((ENABLE SUBRANGE BVP BOOLP B-APPROX B-KNOWNP)))

(PROVE-LEMMA V-APPROX-MAKE-LIST-X
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH Y) BITS)
                           (PROPERP Y))
                      (V-APPROX (MAKE-LIST BITS (X)) Y))
             ((ENABLE MAKE-LIST B-APPROX B-KNOWNP)
              (INDUCT (NTH BITS Y))))

(PROVE-LEMMA READ-MEM-MONOTONE
             (REWRITE)
             (IMPLIES (AND (BVP V-ADDR)
                           (S-APPROX MEM1 MEM2))
                      (V-APPROX (READ-MEM V-ADDR MEM1)
                                (READ-MEM V-ADDR MEM2)))
             ((ENABLE READ-MEM)))

(PROVE-LEMMA EQUAL-LENGTH-READ-MEM1
             (REWRITE)
             (IMPLIES (S-APPROX S1 S2)
                      (EQUAL (EQUAL (LENGTH (READ-MEM1 A S2))
                                    (LENGTH (READ-MEM1 A S1)))
                             T))
             ((ENABLE READ-MEM1)))

(PROVE-LEMMA EQUAL-LENGTH-READ-MEM
             (REWRITE)
             (IMPLIES (S-APPROX S1 S2)
                      (EQUAL (EQUAL (LENGTH (READ-MEM A S2))
                                    (LENGTH (READ-MEM A S1)))
                             T))
             ((ENABLE READ-MEM)))

(PROVE-LEMMA S-APPROX-IMPLIES-PROPERP-READ-MEM1
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2)
                           (PROPERP (READ-MEM1 A S1)))
                      (PROPERP (READ-MEM1 A S2)))
             ((ENABLE READ-MEM1)))

(PROVE-LEMMA S-APPROX-IMPLIES-PROPERP-READ-MEM
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2)
                           (PROPERP (READ-MEM A S1)))
                      (PROPERP (READ-MEM A S2)))
             ((ENABLE READ-MEM)))

(PROVE-LEMMA DUAL-PORT-RAM-VALUE-MONOTONE
             (REWRITE)
             (IMPLIES (AND (NUMBERP ADDRESS-LINES)
                           (S-APPROX S1 S2)
                           (V-APPROX A1 A2))
                      (V-APPROX (DUAL-PORT-RAM-VALUE BITS ADDRESS-LINES A1 S1)
                                (DUAL-PORT-RAM-VALUE BITS ADDRESS-LINES A2
                                                     S2))))

(PROVE-LEMMA EVAL$-APPEND
             (REWRITE)
             (IMPLIES (AND (LITATOM X) (MEMBER X LST))
                      (EQUAL (EVAL$ T X
                                    (APPEND (PAIRLIST LST Y) Z))
                             (EVAL$ T X (PAIRLIST LST Y))))
             ((INDUCT (PAIRLIST LST Y))))

(PROVE-LEMMA EVAL$-PAIRLIST-CONS
             (REWRITE)
             (IMPLIES (LITATOM X)
                      (EQUAL (EVAL$ T X (PAIRLIST (CONS C LST) Y))
                             (IF (EQUAL X C)
                                 (CAR Y)
                                 (EVAL$ T X (PAIRLIST LST (CDR Y)))))))

(PROVE-LEMMA EVAL$-APPEND-2
             (REWRITE)
             (IMPLIES (AND (LITATOM X) (NOT (MEMBER X LST)))
                      (EQUAL (EVAL$ T X
                                    (APPEND (PAIRLIST LST Y) Z))
                             (EVAL$ T X Z)))
             ((INDUCT (PAIRLIST LST Y))))

(PROVE-LEMMA DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1
 (REWRITE)
 (EQUAL
  (DUAL-APPLY-VALUE 'DP-RAM-16X32 A S)
  (EVAL$ T
         (CDR (LOOKUP-MODULE 'RESULTS
                             (CDR (PRIMP 'DP-RAM-16X32))))
         (APPEND (PAIRLIST (CDR (LOOKUP-MODULE 'INPUTS
                                               (CDR (PRIMP 'DP-RAM-16X32))))
                           A)
                 (PAIRSTATES (CDR (LOOKUP-MODULE 'STATES
                                                 (CDR (PRIMP 'DP-RAM-16X32))))
                             S))))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE DUAL-APPLY-VALUE PRIMP2 PRIMP-LOOKUP)))

(PROVE-LEMMA DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2
  (REWRITE)
  (EQUAL (DUAL-APPLY-VALUE 'DP-RAM-16X32 A S)
         (DUAL-PORT-RAM-VALUE 32 4
                              (LIST (EVAL$ T 'READ-A0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WEN
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D4
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D5
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D6
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D7
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D8
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D9
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D10
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D11
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D12
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D13
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D14
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D15
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D16
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D17
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D18
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D19
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D20
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D21
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D22
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D23
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D24
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D25
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D26
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D27
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D28
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D29
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D30
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D31
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S))))
                              (EVAL$ T 'STATE
                                     (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                 READ-A2
                                                                 READ-A3
                                                                 WRITE-B0
                                                                 WRITE-B1
                                                                 WRITE-B2
                                                                 WRITE-B3 WEN
                                                                 D0 D1 D2 D3
                                                                 D4 D5 D6 D7
                                                                 D8 D9 D10 D11
                                                                 D12 D13 D14
                                                                 D15 D16 D17
                                                                 D18 D19 D20
                                                                 D21 D22 D23
                                                                 D24 D25 D26
                                                                 D27 D28 D29
                                                                 D30 D31)
                                                       A)
                                             (PAIRSTATES 'STATE S)))))
  ((DISABLE-THEORY T)
   (ENABLE *1*PRIMP *1*LOOKUP-MODULE *1*CDR *1*CAR *1*EVAL$
           DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1 EVAL$-APPEND REWRITE-EVAL$
           EVAL$-APPEND-2 EVAL$-QUOTE)))

(PROVE-LEMMA DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3
 (REWRITE)
 (EQUAL
    (DUAL-APPLY-VALUE 'DP-RAM-16X32 A S)
    (DUAL-PORT-RAM-VALUE 32 4
                         (LIST (CAR A)
                               (CADR A)
                               (CADDR A)
                               (CADDDR A)
                               (CADDDDR A)
                               (CADDDDDR A)
                               (CADDDDDDR A)
                               (CADDDDDDDR A)
                               (CADDDDDDDDR A)
                               (CADDDDDDDDDR A)
                               (CADDDDDDDDDDR A)
                               (CADDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A))
                         S))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE EVAL$-APPEND EVAL$-APPEND-2 EVAL$-PAIRLIST-CONS PAIRSTATES
          DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2)
  (DISABLE PAIRLIST APPEND)))

(DEFN DUAL-PORT-RAM-VALUE-BODY
      (BITS A-ADDRESS B-ADDRESS WEN STATE)
      (COND ((OR (NOT (BVP A-ADDRESS))
                 (AND (NOT (EQUAL WEN T))
                      (OR (NOT (BVP B-ADDRESS))
                          (EQUAL A-ADDRESS B-ADDRESS))))
             (MAKE-LIST BITS (X)))
            ((AND (PROPERP (READ-MEM A-ADDRESS STATE))
                  (EQUAL (LENGTH (READ-MEM A-ADDRESS STATE))
                         BITS))
             (READ-MEM A-ADDRESS STATE))
            (T (MAKE-LIST BITS (X)))))

(PROVE-LEMMA DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY
     (REWRITE)
     (EQUAL (DUAL-PORT-RAM-VALUE BITS ADDRESS-LINES ARGS STATE)
            (DUAL-PORT-RAM-VALUE-BODY BITS
                                      (SUBRANGE ARGS 0 (SUB1 ADDRESS-LINES))
                                      (SUBRANGE ARGS ADDRESS-LINES
                                                (SUB1 (TIMES 2 ADDRESS-LINES)))
                                      (NTH (TIMES 2 ADDRESS-LINES) ARGS)
                                      STATE))
     ((DISABLE-THEORY T)
      (ENABLE DUAL-PORT-RAM-VALUE DUAL-PORT-RAM-VALUE-BODY)))

(PROVE-LEMMA DUAL-APPLY-VALUE-DP-RAM-16X32
             (REWRITE)
             (EQUAL (DUAL-APPLY-VALUE 'DP-RAM-16X32 A S)
                    (DUAL-PORT-RAM-VALUE 32 4 A S))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3
                      DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY
                      OPEN-SUBRANGE OPEN-NTH)))

(PROVE-LEMMA DP-RAM-16X32-MONOTONE-VALUE
             (REWRITE)
             (MONOTONICITY-PROPERTY 0 'DP-RAM-16X32
                                    NETLIST A1 A2 S1 S2)
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*PRIMP MONOTONICITY-PROPERTY
                      MONOTONICITY-PROPERTY-OPENER-0 DUAL-EVAL-0-PRIMP
                      DUAL-PORT-RAM-VALUE-MONOTONE
                      DUAL-APPLY-VALUE-DP-RAM-16X32)))

(TOGGLE V-KNOWNP-OFF V-KNOWNP T)

(TOGGLE S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL-OFF
        S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL T)

(TOGGLE BVP-OFF1 BVP T)

(TOGGLE FOURP-IMPLIES-S-APPROX-IS-B-APPROX-OFF
        FOURP-IMPLIES-S-APPROX-IS-B-APPROX T)

(TOGGLE V-APPROX-OFF V-APPROX T)

(TOGGLE S-KNOWNP-OFF S-KNOWNP T)

(PROVE-LEMMA S-APPROX-OPENER
            (REWRITE)
            (AND (IMPLIES (OR (LISTP S1) (LISTP S2))
                          (EQUAL (S-APPROX S1 S2)
                                 (IF (LISTP S1)
                                     (IF (LISTP S2)
                                         (AND (S-APPROX (CAR S1) (CAR S2))
                                              (S-APPROX (CDR S1) (CDR S2)))
                                         F)
                                     F)))
                 (IMPLIES (OR (EQUAL S1 NIL) (EQUAL S2 NIL))
                          (EQUAL (S-APPROX S1 S2)
                                 (EQUAL S1 S2)))
                 (IMPLIES (OR (RAMP S1) (RAMP S2))
                          (EQUAL (S-APPROX S1 S2)
                                 (IF (RAMP S1)
                                     (IF (RAMP S2)
                                         (V-APPROX (RAM-GUTS S1) (RAM-GUTS S2))
                                         F)
                                     F)))
                 (IMPLIES (OR (ROMP S1) (ROMP S2))
                          (EQUAL (S-APPROX S1 S2)
                                 (IF (ROMP S1)
                                     (IF (ROMP S2)
                                         (V-APPROX (ROM-GUTS S1) (ROM-GUTS S2))
                                         F)
                                     F)))
                 (IMPLIES (OR (STUBP S1) (STUBP S2))
                          (EQUAL (S-APPROX S1 S2)
                                 (IF (STUBP S1)
                                     (IF (STUBP S2)
                                         (V-APPROX (STUB-GUTS S1)
                                                   (STUB-GUTS S2))
                                         F)
                                     F)))
                 (IMPLIES (NOT (OR (LISTP S1)
                                   (LISTP S2)
                                   (EQUAL S1 NIL)
                                   (EQUAL S2 NIL)
                                   (RAMP S1)
                                   (RAMP S2)
                                   (ROMP S1)
                                   (ROMP S2)
                                   (STUBP S1)
                                   (STUBP S2)))
                          (EQUAL (S-APPROX S1 S2)
                                 (B-APPROX S1 S2))))
            ((DISABLE-THEORY T)
             (ENABLE-THEORY GROUND-ZERO)
             (EXPAND (S-APPROX S1 S2)
                     (S-APPROX NIL S2)
                     (S-APPROX NIL NIL)
                     (S-APPROX S1 NIL))))

(TOGGLE S-APPROX-OFF S-APPROX T)

(TOGGLE G*1*MEM-WIDTH-OFF *1*MEM-WIDTH T)

(TOGGLE MEM-WIDTH-OFF MEM-WIDTH T)

(PROVE-LEMMA V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T
             (REWRITE)
             (IMPLIES (AND (NOT (NTH N A1)) (NTH N A2))
                      (NOT (V-APPROX A1 A2)))
             ((ENABLE NTH V-APPROX B-APPROX)))

(PROVE-LEMMA WRITE-MEM1-OPENER
             (REWRITE)
             (AND (IMPLIES (STUBP MEM)
                           (EQUAL (WRITE-MEM1 V-ADDR MEM VALUE)
                                  MEM))
                  (IMPLIES (NLISTP V-ADDR)
                           (EQUAL (WRITE-MEM1 V-ADDR MEM VALUE)
                                  (IF (RAMP MEM) (RAM VALUE) MEM)))
                  (IMPLIES (AND (LISTP V-ADDR) (NLISTP MEM))
                           (EQUAL (WRITE-MEM1 V-ADDR MEM VALUE)
                                  MEM))
                  (IMPLIES (AND (LISTP MEM)
                                (LISTP V-ADDR)
                                (CAR V-ADDR))
                           (EQUAL (WRITE-MEM1 V-ADDR MEM VALUE)
                                  (CONS (CAR MEM)
                                        (WRITE-MEM1 (CDR V-ADDR)
                                                    (CDR MEM)
                                                    VALUE))))
                  (IMPLIES (AND (LISTP MEM)
                                (LISTP V-ADDR)
                                (NOT (CAR V-ADDR)))
                           (EQUAL (WRITE-MEM1 V-ADDR MEM VALUE)
                                  (CONS (WRITE-MEM1 (CDR V-ADDR)
                                                    (CAR MEM)
                                                    VALUE)
                                        (CDR MEM)))))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (EXPAND (WRITE-MEM1 V-ADDR MEM VALUE))))

(DEFN WRITE-MEM1-MONOTONE-INDUCTION
      (V-ADDR MEM1 MEM2)
      (COND ((OR (STUBP MEM1) (STUBP MEM2)) T)
            ((NLISTP V-ADDR) T)
            ((OR (NLISTP MEM1) (NLISTP MEM2)) T)
            ((CAR V-ADDR)
             (WRITE-MEM1-MONOTONE-INDUCTION (CDR V-ADDR)
                                            (CDR MEM1)
                                            (CDR MEM2)))
            (T (WRITE-MEM1-MONOTONE-INDUCTION (CDR V-ADDR)
                                              (CAR MEM1)
                                              (CAR MEM2)))))

(PROVE-LEMMA WRITE-MEM1-MONOTONE
             (REWRITE)
             (IMPLIES (AND (S-APPROX MEM1 MEM2)
                           (V-APPROX DATA1 DATA2)
                           (PROPERP DATA1)
                           (PROPERP DATA2)
                           (EQUAL (LENGTH DATA1) (MEM-WIDTH))
                           (EQUAL (LENGTH DATA2) (MEM-WIDTH)))
                      (S-APPROX (WRITE-MEM1 V-ADDR MEM1 DATA1)
                                (WRITE-MEM1 V-ADDR MEM2 DATA2)))
             ((INDUCT (WRITE-MEM1-MONOTONE-INDUCTION V-ADDR MEM1 MEM2))
              (EXPAND (S-APPROX MEM1 MEM2))))

(PROVE-LEMMA WRITE-MEM-MONOTONE
             (REWRITE)
             (IMPLIES (AND (S-APPROX MEM1 MEM2)
                           (V-APPROX DATA1 DATA2)
                           (PROPERP DATA1)
                           (PROPERP DATA2)
                           (EQUAL (LENGTH DATA1) (MEM-WIDTH))
                           (EQUAL (LENGTH DATA2) (MEM-WIDTH)))
                      (S-APPROX (WRITE-MEM V-ADDR MEM1 DATA1)
                                (WRITE-MEM V-ADDR MEM2 DATA2)))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA V-APPROX-LENGTH
             (REWRITE)
             (IMPLIES (V-APPROX V1 V2)
                      (NOT (LESSP (LENGTH V1) (LENGTH V2))))
             ((ENABLE V-APPROX LENGTH B-APPROX)))

(DEFN WRITE-MEM1-DOUBLE-INDUCTION
      (V-ADDR MEM1 MEM2)
      (COND ((OR (STUBP MEM1) (STUBP MEM2)) T)
            ((NLISTP V-ADDR) T)
            ((OR (NLISTP MEM1) (NLISTP MEM2)) T)
            ((CAR V-ADDR)
             (WRITE-MEM1-DOUBLE-INDUCTION (CDR V-ADDR)
                                          (CDR MEM1)
                                          (CDR MEM2)))
            (T (WRITE-MEM1-DOUBLE-INDUCTION (CDR V-ADDR)
                                            (CAR MEM1)
                                            (CAR MEM2)))))

(PROVE-LEMMA S-APPROX-WRITE-MEM1-ID
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2) (GOOD-S S2))
                      (S-APPROX (WRITE-MEM1 V-ADDR S1
                                            (MAKE-LIST (MEM-WIDTH) (X)))
                                S2))
             ((INDUCT (WRITE-MEM1-DOUBLE-INDUCTION V-ADDR S1 S2))
              (EXPAND (S-APPROX S1 S2))))

(PROVE-LEMMA S-APPROX-WRITE-MEM-ID
             (REWRITE)
             (IMPLIES (AND (GOOD-S S2) (S-APPROX S1 S2))
                      (S-APPROX (WRITE-MEM V-ADDR S1
                                           (MAKE-LIST (MEM-WIDTH) (X)))
                                S2))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA S-APPROX-CONSTANT-RAM-X-ID
             (REWRITE)
             (IMPLIES (AND (GOOD-S S2) (S-APPROX S1 S2))
                      (S-APPROX (CONSTANT-RAM S1
                                              (MAKE-LIST (MEM-WIDTH) (X)))
                                S2))
             ((ENABLE CONSTANT-RAM)
              (INDUCT (S-APPROX S1 S2))))

(PROVE-LEMMA S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X
             (REWRITE)
             (IMPLIES (S-APPROX S1 S2)
                      (S-APPROX (CONSTANT-RAM S1
                                              (MAKE-LIST (MEM-WIDTH) (X)))
                                (CONSTANT-RAM S2
                                              (MAKE-LIST (MEM-WIDTH) (X)))))
             ((ENABLE CONSTANT-RAM)
              (INDUCT (S-APPROX S1 S2))))

(PROVE-LEMMA V-APPROX-PRESERVES-LENGTH
             (REWRITE)
             (IMPLIES (V-APPROX A1 A2)
                      (EQUAL (LENGTH A1) (LENGTH A2)))
             ((ENABLE V-APPROX LENGTH)))

(PROVE-LEMMA V-APPROX-SUBRANGE
             (REWRITE)
             (IMPLIES (V-APPROX A1 A2)
                      (V-APPROX (SUBRANGE A1 I J)
                                (SUBRANGE A2 I J)))
             ((ENABLE V-APPROX B-APPROX SUBRANGE)))

(PROVE-LEMMA MEM-WIDTH-NON-ZERO
             (REWRITE)
             (NOT (EQUAL (MEM-WIDTH) 0))
             ((ENABLE *1*MEM-WIDTH)))

(PROVE-LEMMA S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3
             (REWRITE)
             (IMPLIES (AND (NOT (STUBP S1))
                           (NOT (STUBP S2))
                           (LISTP V-ADDR)
                           (NOT (LISTP S1))
                           (S-APPROX S1 S2)
                           (PROPERP V)
                           (EQUAL (LENGTH V) (MEM-WIDTH))
                           (NOT (RAMP S1)))
                      (S-APPROX S1
                                (WRITE-MEM1 V-ADDR S2 V)))
             ((ENABLE WRITE-MEM1 S-APPROX)))

(PROVE-LEMMA S-APPROX-CONSTANT-RAM-X-WRITE-MEM1
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2)
                           (PROPERP V)
                           (EQUAL (LENGTH V) (MEM-WIDTH))
                           (GOOD-S S2))
                      (S-APPROX (CONSTANT-RAM S1
                                              (MAKE-LIST (MEM-WIDTH) (X)))
                                (WRITE-MEM1 V-ADDR S2 V)))
             ((ENABLE CONSTANT-RAM)
              (INDUCT (WRITE-MEM1-DOUBLE-INDUCTION V-ADDR S1 S2))))

(PROVE-LEMMA S-APPROX-CONSTANT-RAM-X-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2)
                           (PROPERP V)
                           (EQUAL (LENGTH V) (MEM-WIDTH))
                           (GOOD-S S2))
                      (S-APPROX (CONSTANT-RAM S1
                                              (MAKE-LIST (MEM-WIDTH) (X)))
                                (WRITE-MEM V-ADDR S2 V)))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA V-APPROX-PRESERVES-PROPERP
             (REWRITE)
             (IMPLIES (NOT (IFF (PROPERP V1) (PROPERP V2)))
                      (NOT (V-APPROX V1 V2)))
             ((ENABLE PROPERP V-APPROX)))

(PROVE-LEMMA MEM-WIDTH-LINEAR-FACTS
             (REWRITE)
             (AND (LESSP 31 (MEM-WIDTH))
                  (LESSP (MEM-WIDTH) 33))
             ((ENABLE *1*MEM-WIDTH)))

(PROVE-LEMMA DUAL-PORT-RAM-STATE-MONOTONE NIL
             (IMPLIES (AND (S-APPROX S1 S2)
                           (GOOD-S S2)
                           (V-APPROX A1 A2))
                      (S-APPROX (DUAL-PORT-RAM-STATE (MEM-WIDTH)
                                                     4 A1 S1)
                                (DUAL-PORT-RAM-STATE (MEM-WIDTH)
                                                     4 A2 S2))))

(PROVE-LEMMA DUAL-PORT-RAM-STATE-MONOTONE-REWRITE
             (REWRITE)
             (IMPLIES (AND (S-APPROX S1 S2)
                           (GOOD-S S2)
                           (V-APPROX A1 A2))
                      (S-APPROX (DUAL-PORT-RAM-STATE 32 4 A1 S1)
                                (DUAL-PORT-RAM-STATE 32 4 A2 S2)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*MEM-WIDTH)
              (USE (DUAL-PORT-RAM-STATE-MONOTONE))))

(PROVE-LEMMA DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1
 (REWRITE)
 (EQUAL
  (DUAL-APPLY-STATE 'DP-RAM-16X32 A S)
  (EVAL$ T
         (CDR (LOOKUP-MODULE 'NEW-STATES
                             (CDR (PRIMP 'DP-RAM-16X32))))
         (APPEND (PAIRLIST (CDR (LOOKUP-MODULE 'INPUTS
                                               (CDR (PRIMP 'DP-RAM-16X32))))
                           A)
                 (PAIRSTATES (CDR (LOOKUP-MODULE 'STATES
                                                 (CDR (PRIMP 'DP-RAM-16X32))))
                             S))))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE DUAL-APPLY-STATE PRIMP2 PRIMP-LOOKUP)))

(PROVE-LEMMA DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2
  (REWRITE)
  (EQUAL (DUAL-APPLY-STATE 'DP-RAM-16X32 A S)
         (DUAL-PORT-RAM-STATE 32 4
                              (LIST (EVAL$ T 'READ-A0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'READ-A3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WRITE-B3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'WEN
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D0
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D1
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D2
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D3
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D4
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D5
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D6
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D7
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D8
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D9
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D10
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D11
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D12
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D13
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D14
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D15
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D16
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D17
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D18
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D19
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D20
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D21
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D22
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D23
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D24
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D25
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D26
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D27
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D28
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D29
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D30
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S)))
                                    (EVAL$ T 'D31
                                           (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                       READ-A2
                                                                       READ-A3
                                                                       WRITE-B0
                                                                       WRITE-B1
                                                                       WRITE-B2
                                                                       WRITE-B3
                                                                       WEN D0
                                                                       D1 D2
                                                                       D3 D4
                                                                       D5 D6
                                                                       D7 D8
                                                                       D9 D10
                                                                       D11 D12
                                                                       D13 D14
                                                                       D15 D16
                                                                       D17 D18
                                                                       D19 D20
                                                                       D21 D22
                                                                       D23 D24
                                                                       D25 D26
                                                                       D27 D28
                                                                       D29 D30
                                                                       D31)
                                                             A)
                                                   (PAIRSTATES 'STATE S))))
                              (EVAL$ T 'STATE
                                     (APPEND (PAIRLIST '(READ-A0 READ-A1
                                                                 READ-A2
                                                                 READ-A3
                                                                 WRITE-B0
                                                                 WRITE-B1
                                                                 WRITE-B2
                                                                 WRITE-B3 WEN
                                                                 D0 D1 D2 D3
                                                                 D4 D5 D6 D7
                                                                 D8 D9 D10 D11
                                                                 D12 D13 D14
                                                                 D15 D16 D17
                                                                 D18 D19 D20
                                                                 D21 D22 D23
                                                                 D24 D25 D26
                                                                 D27 D28 D29
                                                                 D30 D31)
                                                       A)
                                             (PAIRSTATES 'STATE S)))))
  ((DISABLE-THEORY T)
   (ENABLE *1*PRIMP *1*LOOKUP-MODULE *1*CDR *1*CAR *1*EVAL$
           DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1 EVAL$-APPEND REWRITE-EVAL$
           EVAL$-APPEND-2 EVAL$-QUOTE)))

(PROVE-LEMMA DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3
 (REWRITE)
 (EQUAL
    (DUAL-APPLY-STATE 'DP-RAM-16X32 A S)
    (DUAL-PORT-RAM-STATE 32 4
                         (LIST (CAR A)
                               (CADR A)
                               (CADDR A)
                               (CADDDR A)
                               (CADDDDR A)
                               (CADDDDDR A)
                               (CADDDDDDR A)
                               (CADDDDDDDR A)
                               (CADDDDDDDDR A)
                               (CADDDDDDDDDR A)
                               (CADDDDDDDDDDR A)
                               (CADDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A)
                               (CADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDR A))
                         S))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE EVAL$-APPEND EVAL$-APPEND-2 EVAL$-PAIRLIST-CONS PAIRSTATES
          DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2)
  (DISABLE PAIRLIST APPEND)))

(DEFN DUAL-PORT-RAM-STATE-BODY
      (BITS B-ADDRESS WEN DATA STATE)
      (COND ((EQUAL WEN T) STATE)
            ((NOT (BVP B-ADDRESS))
             (CONSTANT-RAM STATE
                           (MAKE-LIST BITS (X))))
            ((EQUAL WEN F)
             (WRITE-MEM B-ADDRESS STATE DATA))
            (T (WRITE-MEM B-ADDRESS STATE
                          (MAKE-LIST BITS (X))))))

(PROVE-LEMMA DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY
 (REWRITE)
 (EQUAL
       (DUAL-PORT-RAM-STATE BITS ADDRESS-LINES ARGS STATE)
       (DUAL-PORT-RAM-STATE-BODY BITS
                                 (SUBRANGE ARGS ADDRESS-LINES
                                           (SUB1 (TIMES 2 ADDRESS-LINES)))
                                 (NTH (TIMES 2 ADDRESS-LINES) ARGS)
                                 (SUBRANGE ARGS
                                           (ADD1 (TIMES 2 ADDRESS-LINES))
                                           (PLUS (TIMES 2 ADDRESS-LINES) BITS))
                                 STATE))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE DUAL-PORT-RAM-STATE DUAL-PORT-RAM-STATE-BODY)))

(PROVE-LEMMA DUAL-APPLY-STATE-DP-RAM-16X32
             (REWRITE)
             (EQUAL (DUAL-APPLY-STATE 'DP-RAM-16X32 A S)
                    (DUAL-PORT-RAM-STATE 32 4 A S))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3
                      DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY
                      OPEN-SUBRANGE OPEN-NTH)))

(PROVE-LEMMA DP-RAM-16X32-MONOTONE-STATE
             (REWRITE)
             (IMPLIES (GOOD-S S2)
                      (MONOTONICITY-PROPERTY 2 'DP-RAM-16X32
                                             NETLIST A1 A2 S1 S2))
             ((DISABLE-THEORY T)
              (ENABLE DUAL-PORT-RAM-STATE-MONOTONE-REWRITE
                      DUAL-APPLY-STATE-DP-RAM-16X32 DUAL-EVAL-2-PRIMP
                      MONOTONICITY-PROPERTY-OPENER-2 AND IMPLIES *1*PRIMP)))

(PROVE-LEMMA DP-RAM-16X32-MONOTONE
             (REWRITE)
             (AND (MONOTONICITY-PROPERTY 0 'DP-RAM-16X32
                                         NETLIST A1 A2 S1 S2)
                  (IMPLIES (GOOD-S S2)
                           (MONOTONICITY-PROPERTY 2 'DP-RAM-16X32
                                                  NETLIST A1 A2 S1 S2))))

(TOGGLE BVP-REVERSE-OFF BVP-REVERSE T)

(TOGGLE V-APPROX-BVP-OFF V-APPROX-BVP T)

(TOGGLE READ-MEM1-MONOTONE-OFF READ-MEM1-MONOTONE T)

(TOGGLE BVP-IMPLIES-V-KNOWNP-OFF BVP-IMPLIES-V-KNOWNP T)

(TOGGLE V-APPROX-X-X-OFF V-APPROX-X-X T)

(TOGGLE V-APPROX-IMPLIES-B-APPROX-NTH-OFF V-APPROX-IMPLIES-B-APPROX-NTH T)

(TOGGLE G*1*B-KNOWNP-OFF1 *1*B-KNOWNP T)

(TOGGLE V-APPROX-IMPLIES-SUBRANGES-EQUAL-OFF V-APPROX-IMPLIES-SUBRANGES-EQUAL T)

(TOGGLE V-APPROX-BVP-SUBRANGE-OFF V-APPROX-BVP-SUBRANGE T)

(TOGGLE V-APPROX-MAKE-LIST-X-OFF V-APPROX-MAKE-LIST-X T)

(TOGGLE READ-MEM-MONOTONE-OFF READ-MEM-MONOTONE T)

(TOGGLE EQUAL-LENGTH-READ-MEM1-OFF EQUAL-LENGTH-READ-MEM1 T)

(TOGGLE EQUAL-LENGTH-READ-MEM-OFF EQUAL-LENGTH-READ-MEM T)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM1-OFF
        S-APPROX-IMPLIES-PROPERP-READ-MEM1 T)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM-OFF S-APPROX-IMPLIES-PROPERP-READ-MEM
        T)

(TOGGLE DUAL-PORT-RAM-VALUE-MONOTONE-OFF DUAL-PORT-RAM-VALUE-MONOTONE T)

(TOGGLE EVAL$-APPEND-OFF EVAL$-APPEND T)

(TOGGLE EVAL$-PAIRLIST-CONS-OFF EVAL$-PAIRLIST-CONS T)

(TOGGLE EVAL$-APPEND-2-OFF EVAL$-APPEND-2 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1-OFF
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2-OFF
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3-OFF
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3 T)

(TOGGLE DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY-OFF
        DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-OFF DUAL-APPLY-VALUE-DP-RAM-16X32 T)

(TOGGLE DP-RAM-16X32-MONOTONE-VALUE-OFF DP-RAM-16X32-MONOTONE-VALUE T)

(TOGGLE V-KNOWNP-ON V-KNOWNP NIL)

(TOGGLE S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL-ON
        S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL NIL)

(TOGGLE BVP-ON BVP NIL)

(TOGGLE FOURP-IMPLIES-S-APPROX-IS-B-APPROX-ON
        FOURP-IMPLIES-S-APPROX-IS-B-APPROX NIL)

(TOGGLE V-APPROX-ON V-APPROX NIL)

(TOGGLE S-KNOWNP-ON S-KNOWNP NIL)

(TOGGLE S-APPROX-OPENER-OFF S-APPROX-OPENER T)

(TOGGLE S-APPROX-ON S-APPROX NIL)

(TOGGLE G*1*MEM-WIDTH-ON *1*MEM-WIDTH NIL)

(TOGGLE MEM-WIDTH-ON MEM-WIDTH NIL)

(TOGGLE V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T-OFF
        V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T T)

(TOGGLE WRITE-MEM1-OPENER-OFF WRITE-MEM1-OPENER T)

(TOGGLE WRITE-MEM1-MONOTONE-OFF WRITE-MEM1-MONOTONE T)

(TOGGLE WRITE-MEM-MONOTONE-OFF WRITE-MEM-MONOTONE T)

(TOGGLE V-APPROX-LENGTH-OFF V-APPROX-LENGTH T)

(TOGGLE S-APPROX-WRITE-MEM1-ID-OFF S-APPROX-WRITE-MEM1-ID T)

(TOGGLE S-APPROX-WRITE-MEM-ID-OFF S-APPROX-WRITE-MEM-ID T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-ID-OFF S-APPROX-CONSTANT-RAM-X-ID T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X-OFF
        S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X T)

(TOGGLE V-APPROX-PRESERVES-LENGTH-OFF V-APPROX-PRESERVES-LENGTH T)

(TOGGLE V-APPROX-SUBRANGE-OFF V-APPROX-SUBRANGE T)

(TOGGLE MEM-WIDTH-NON-ZERO-OFF MEM-WIDTH-NON-ZERO T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3-OFF
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3 T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-OFF
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1 T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM-OFF S-APPROX-CONSTANT-RAM-X-WRITE-MEM
        T)

(TOGGLE V-APPROX-PRESERVES-PROPERP-OFF V-APPROX-PRESERVES-PROPERP T)

(TOGGLE MEM-WIDTH-LINEAR-FACTS-OFF MEM-WIDTH-LINEAR-FACTS T)

(TOGGLE DUAL-PORT-RAM-STATE-MONOTONE-REWRITE-OFF
        DUAL-PORT-RAM-STATE-MONOTONE-REWRITE T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1-OFF
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1 T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2-OFF
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2 T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3-OFF
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3 T)

(TOGGLE DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY-OFF
        DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-OFF DUAL-APPLY-STATE-DP-RAM-16X32 T)

(TOGGLE DP-RAM-16X32-MONOTONE-STATE-OFF DP-RAM-16X32-MONOTONE-STATE T)

(TOGGLE DP-RAM-16X32-MONOTONE-OFF DP-RAM-16X32-MONOTONE T)

(DEFN OK-NETLISTP
   (FLAG FN NETLIST EXCEPTIONS)
   (CASE FLAG
         (0 (COND ((PRIMP FN)
                   (NOT (MEMBER FN EXCEPTIONS)))
                  ((LISTP (LOOKUP-MODULE FN NETLIST))
                   (OK-NETLISTP 1
                                (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                                (DELETE-MODULE FN NETLIST)
                                EXCEPTIONS))
                  (T F)))
         (1 (IF (LISTP FN)
                (AND (OK-NETLISTP 0
                                  (OCC-FUNCTION (CAR FN))
                                  NETLIST EXCEPTIONS)
                     (OK-NETLISTP 1
                                  (CDR FN)
                                  NETLIST EXCEPTIONS))
                T))
         (2 (COND ((PRIMP FN)
                   (NOT (MEMBER FN EXCEPTIONS)))
                  ((LISTP (LOOKUP-MODULE FN NETLIST))
                   (OK-NETLISTP 3
                                (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                                (DELETE-MODULE FN NETLIST)
                                EXCEPTIONS))
                  (T F)))
         (3 (IF (LISTP FN)
                (AND (OK-NETLISTP 2
                                  (OCC-FUNCTION (CAR FN))
                                  NETLIST EXCEPTIONS)
                     (OK-NETLISTP 3
                                  (CDR FN)
                                  NETLIST EXCEPTIONS))
                T))
         (OTHERWISE F))
   ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                     (COUNT FN)))))

(PROVE-LEMMA PRIMP-MONOTONE
             (REWRITE)
             (IMPLIES (AND (PRIMP FN)
                           (OR (EQUAL FLAG 0)
                               (AND (EQUAL FLAG 2)
                                    (IMPLIES (EQUAL FN 'DP-RAM-16X32)
                                             (GOOD-S S2))))
                           (NOT (EQUAL FN 'MEM-32X32)))
                      (AND (MONOTONICITY-PROPERTY FLAG FN NETLIST A1 A2 S1 S2)
                           (MONOTONICITY-PROPERTY FLAG FN NETLIST A1 A2 S1
                                                  S2)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO PRIMITIVES-MONOTONE)
              (ENABLE PRIMP LOOKUP-MODULE *1*PRIMP-DATABASE
                      DP-RAM-16X32-MONOTONE)))

(DEFN DUAL-EVAL-MONOTONE-INDUCTION
 (FLAG FN NETLIST A1 A2 S1 S2)
 (CASE FLAG
  (0
   (COND
    ((PRIMP FN) T)
    ((LISTP (LOOKUP-MODULE FN NETLIST))
     (DUAL-EVAL-MONOTONE-INDUCTION 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (DELETE-MODULE FN NETLIST)
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A1)
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A2)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S1)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S2)))
    (T T)))
  (1
   (IF
    (LISTP FN)
    (AND
     (DUAL-EVAL-MONOTONE-INDUCTION 0
                                   (OCC-FUNCTION (CAR FN))
                                   NETLIST
                                   (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                  A1)
                                   (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                  A2)
                                   (VALUE (OCC-NAME (CAR FN)) S1)
                                   (VALUE (OCC-NAME (CAR FN)) S2))
     (DUAL-EVAL-MONOTONE-INDUCTION 1
              (CDR FN)
              NETLIST
              (APPEND (PAIRLIST (OCC-OUTPUTS (CAR FN))
                                (DUAL-EVAL 0
                                           (OCC-FUNCTION (CAR FN))
                                           (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                          A1)
                                           (VALUE (OCC-NAME (CAR FN)) S1)
                                           NETLIST))
                      A1)
              (APPEND (PAIRLIST (OCC-OUTPUTS (CAR FN))
                                (DUAL-EVAL 0
                                           (OCC-FUNCTION (CAR FN))
                                           (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                          A2)
                                           (VALUE (OCC-NAME (CAR FN)) S2)
                                           NETLIST))
                      A2)
              S1 S2))
    T))
  (2
   (COND
    ((PRIMP FN) T)
    ((LISTP (LOOKUP-MODULE FN NETLIST))
     (AND
      (DUAL-EVAL-MONOTONE-INDUCTION 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (DELETE-MODULE FN NETLIST)
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A1)
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A2)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S1)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S2))
      (DUAL-EVAL-MONOTONE-INDUCTION 3
          (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
          (DELETE-MODULE FN NETLIST)
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A1)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S1)
                     (DELETE-MODULE FN NETLIST))
          (DUAL-EVAL 1
                     (MODULE-OCCURRENCES (LOOKUP-MODULE FN NETLIST))
                     (PAIRLIST (MODULE-INPUTS (LOOKUP-MODULE FN NETLIST))
                               A2)
                     (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                                 S2)
                     (DELETE-MODULE FN NETLIST))
          (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                      S1)
          (PAIRSTATES (MODULE-STATENAMES (LOOKUP-MODULE FN NETLIST))
                      S2))))
    (T T)))
  (3
    (IF (LISTP FN)
        (AND (DUAL-EVAL-MONOTONE-INDUCTION 2
                                           (OCC-FUNCTION (CAR FN))
                                           NETLIST
                                           (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                          A1)
                                           (COLLECT-VALUE (OCC-INPUTS (CAR FN))
                                                          A2)
                                           (VALUE (OCC-NAME (CAR FN)) S1)
                                           (VALUE (OCC-NAME (CAR FN)) S2))
             (DUAL-EVAL-MONOTONE-INDUCTION 3
                                           (CDR FN)
                                           NETLIST A1 A2 S1 S2))
        T))
  (OTHERWISE T))
 ((ORD-LESSP (CONS (ADD1 (COUNT NETLIST))
                   (COUNT FN)))))

(TOGGLE V-APPROX-X-X-ON V-APPROX-X-X NIL)

(PROVE-LEMMA V-APPROX-ALIST-IMPLIES-B-APPROX-VALUE
             (REWRITE)
             (IMPLIES (AND (ALISTP ALIST1)
                           (ALISTP ALIST2)
                           (V-APPROX-ALIST ALIST1 ALIST2))
                      (B-APPROX (VALUE X ALIST1)
                                (VALUE X ALIST2)))
             ((ENABLE VALUE ALISTP)))

(PROVE-LEMMA ALISTP-PAIRLIST
             (REWRITE)
             (ALISTP (PAIRLIST X Y))
             ((ENABLE ALISTP PAIRLIST)))

(PROVE-LEMMA ALISTP-APPEND
             (REWRITE)
             (IMPLIES (ALISTP X)
                      (EQUAL (ALISTP (APPEND X Y))
                             (ALISTP Y)))
             ((ENABLE ALISTP)))

(PROVE-LEMMA ALISTP-DUAL-EVAL-1
             (REWRITE)
             (IMPLIES (AND (ALISTP BINDINGS) (EQUAL FLAG 1))
                      (ALISTP (DUAL-EVAL FLAG OCCURRENCES BINDINGS
                                         STATE-BINDINTS NETLIST)))
             ((INDUCT (DUAL-EVAL FLAG OCCURRENCES BINDINGS STATE-BINDINTS
                                 NETLIST))))

(PROVE-LEMMA V-APPROX-ALIST-IMPLIES-V-APPROX-COLLECT-VALUE
             (REWRITE)
             (IMPLIES (AND (ALISTP ALIST1)
                           (ALISTP ALIST2)
                           (V-APPROX-ALIST ALIST1 ALIST2))
                      (V-APPROX (COLLECT-VALUE X ALIST1)
                                (COLLECT-VALUE X ALIST2)))
             ((ENABLE COLLECT-VALUE)))

(DEFN S-APPROX-LIST
      (X Y)
      (IF (LISTP X)
          (AND (LISTP Y)
               (S-APPROX (CAR X) (CAR Y))
               (S-APPROX-LIST (CDR X) (CDR Y)))
          (NLISTP Y)))

(PROVE-LEMMA S-APPROX-LIST-IMPLIES-S-APPROX-ALIST
             (REWRITE)
             (IMPLIES (S-APPROX-LIST S1 S2)
                      (S-APPROX-ALIST (PAIRLIST X S1)
                                      (PAIRLIST X S2)))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA V-APPROX-IMPLIES-V-APPROX-ALIST
             (REWRITE)
             (IMPLIES (V-APPROX V1 V2)
                      (V-APPROX-ALIST (PAIRLIST X V1)
                                      (PAIRLIST X V2)))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA ALISTP-OPENER
             (REWRITE)
             (EQUAL (ALISTP (CONS A Z))
                    (AND (LISTP A) (ALISTP Z)))
             ((ENABLE ALISTP)))

(PROVE-LEMMA S-APPROX-ALIST-IMPLIES-S-APPROX-VALUE
             (REWRITE)
             (IMPLIES (AND (S-APPROX-ALIST S1 S2)
                           (ALISTP S1)
                           (ALISTP S2))
                      (S-APPROX (VALUE W S1) (VALUE W S2)))
             ((ENABLE VALUE ALISTP)))

(PROVE-LEMMA V-APPROX-ALIST-APPEND
             (REWRITE)
             (IMPLIES (AND (V-APPROX-ALIST A C)
                           (V-APPROX-ALIST B D))
                      (V-APPROX-ALIST (APPEND A B)
                                      (APPEND C D))))

(DEFN DOUBLE-CDR-INDUCTION
      (X Y)
      (IF (AND (LISTP X) (LISTP Y))
          (DOUBLE-CDR-INDUCTION (CDR X) (CDR Y))
          T))

(PROVE-LEMMA S-APPROX-ALIST-IMPLIES-S-APPROX-LIST-COLLECT-VALUE
             (REWRITE)
             (IMPLIES (AND (S-APPROX-ALIST X Y)
                           (ALISTP X)
                           (ALISTP Y))
                      (S-APPROX-LIST (COLLECT-VALUE A X)
                                     (COLLECT-VALUE A Y)))
             ((ENABLE COLLECT-VALUE VALUE)))

(PROVE-LEMMA ALISTP-DUAL-EVAL-3
             (REWRITE)
             (IMPLIES (AND (ALISTP STATE-BINDINGS)
                           (EQUAL FLAG 3))
                      (ALISTP (DUAL-EVAL FLAG OCCURRENCES BINDINGS
                                         STATE-BINDINGS NETLIST)))
             ((INDUCT (DUAL-EVAL FLAG OCCURRENCES BINDINGS STATE-BINDINGS
                                 NETLIST))))

(PROVE-LEMMA S-APPROX-IMPLIES-S-APPROX-ALIST
             (REWRITE)
             (IMPLIES (S-APPROX S1 S2)
                      (S-APPROX-ALIST (PAIRLIST X S1)
                                      (PAIRLIST X S2)))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA S-APPROX-ALIST-IMPLIES-S-APPROX-COLLECT-VALUE
             (REWRITE)
             (IMPLIES (AND (S-APPROX-ALIST X Y)
                           (ALISTP X)
                           (ALISTP Y))
                      (S-APPROX (COLLECT-VALUE A X)
                                (COLLECT-VALUE A Y)))
             ((ENABLE COLLECT-VALUE VALUE)))

(PROVE-LEMMA OK-NETLISTP-REDUCTION NIL
             (IMPLIES (OR (EQUAL FLAG 2) (EQUAL FLAG 3))
                      (EQUAL (OK-NETLISTP FLAG FN NETLIST EXCEPTIONS)
                             (IF (EQUAL FLAG 2)
                                 (OK-NETLISTP 0 FN NETLIST EXCEPTIONS)
                                 (OK-NETLISTP 1 FN NETLIST EXCEPTIONS)))))

(PROVE-LEMMA OK-NETLISTP-REDUCTION-REWRITE
             (REWRITE)
             (AND (EQUAL (OK-NETLISTP 2 FN NETLIST EXCEPTIONS)
                         (OK-NETLISTP 0 FN NETLIST EXCEPTIONS))
                  (EQUAL (OK-NETLISTP 3 FN NETLIST EXCEPTIONS)
                         (OK-NETLISTP 1 FN NETLIST EXCEPTIONS)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (USE (OK-NETLISTP-REDUCTION (FLAG 2))
                   (OK-NETLISTP-REDUCTION (FLAG 3)))))

(PROVE-LEMMA DUAL-EVAL-MONOTONE-NO-RAM
             (REWRITE)
             (IMPLIES (OK-NETLISTP FLAG FN NETLIST
                                   '(MEM-32X32 DP-RAM-16X32))
                      (MONOTONICITY-PROPERTY FLAG FN NETLIST A1 A2 S1 S2))
             ((INDUCT (DUAL-EVAL-MONOTONE-INDUCTION FLAG FN NETLIST A1 A2 S1
                                                    S2))
              (ENABLE MONOTONICITY-PROPERTY)
              (DISABLE MEMBER-NON-LIST DUAL-EVAL-0-PRIMP)))

(DEFN GOOD-S-ALIST
      (X)
      (IF (LISTP X)
          (AND (LISTP (CAR X))
               (GOOD-S (CDAR X))
               (GOOD-S-ALIST (CDR X)))
          (EQUAL X NIL)))

(PROVE-LEMMA GOOD-S-ALIST-PAIRLIST
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S-ALIST (PAIRLIST X S)))
             ((ENABLE PAIRLIST)))

(PROVE-LEMMA GOOD-S-VALUE
             (REWRITE)
             (IMPLIES (GOOD-S-ALIST X)
                      (GOOD-S (VALUE W X)))
             ((ENABLE VALUE)))

(PROVE-LEMMA DUAL-EVAL-MONOTONE
             (REWRITE)
             (IMPLIES (OK-NETLISTP FLAG FN NETLIST
                                   '(MEM-32X32))
                      (IMPLIES (IF (OR (EQUAL FLAG 0) (EQUAL FLAG 2))
                                   (GOOD-S S2)
                                   (GOOD-S-ALIST S2))
                               (MONOTONICITY-PROPERTY FLAG FN NETLIST A1 A2
                                                      S1 S2)))
             ((INDUCT (DUAL-EVAL-MONOTONE-INDUCTION FLAG FN NETLIST A1 A2 S1
                                                    S2))
              (ENABLE MONOTONICITY-PROPERTY)
              (DISABLE MEMBER-NON-LIST DUAL-EVAL-0-PRIMP)))

(PROVE-LEMMA GOOD-S-COLLECT-VALUE
             (REWRITE)
             (IMPLIES (GOOD-S-ALIST S)
                      (GOOD-S (COLLECT-VALUE KEYS S)))
             ((ENABLE COLLECT-VALUE VALUE)))

(PROVE-LEMMA F-BUF-PRESERVES-GOOD-S
             (REWRITE)
             (GOOD-S (F-BUF X))
             ((ENABLE F-BUF BOOLP)))

(PROVE-LEMMA F-IF-PRESERVES-GOOD-S
             (REWRITE)
             (GOOD-S (F-IF X Y Z))
             ((ENABLE F-IF BOOLP)))

(PROVE-LEMMA GOOD-S-0
             (REWRITE)
             (GOOD-S 0)
             ((ENABLE *1*GOOD-S)))

(PROVE-LEMMA AO2-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'AO2 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-AO2-VALUE
                      DUAL-EVAL-AO2-STATE)))

(PROVE-LEMMA AO4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'AO4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-AO4-VALUE
                      DUAL-EVAL-AO4-STATE)))

(PROVE-LEMMA AO6-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'AO6 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-AO6-VALUE
                      DUAL-EVAL-AO6-STATE)))

(PROVE-LEMMA AO7-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'AO7 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-AO7-VALUE
                      DUAL-EVAL-AO7-STATE)))

(PROVE-LEMMA B-AND-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-AND ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-AND-VALUE
                      DUAL-EVAL-B-AND-STATE)))

(PROVE-LEMMA B-AND3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-AND3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-AND3-VALUE
                      DUAL-EVAL-B-AND3-STATE)))

(PROVE-LEMMA B-AND4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-AND4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-AND4-VALUE
                      DUAL-EVAL-B-AND4-STATE)))

(PROVE-LEMMA B-EQUV-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-EQUV ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-EQUV-VALUE
                      DUAL-EVAL-B-EQUV-STATE)))

(PROVE-LEMMA B-EQUV3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-EQUV3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-EQUV3-VALUE
                      DUAL-EVAL-B-EQUV3-STATE)))

(PROVE-LEMMA B-IF-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-IF ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-IF-VALUE
                      DUAL-EVAL-B-IF-STATE)))

(PROVE-LEMMA B-NAND-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND-VALUE
                      DUAL-EVAL-B-NAND-STATE)))

(PROVE-LEMMA B-NAND3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND3-VALUE
                      DUAL-EVAL-B-NAND3-STATE)))

(PROVE-LEMMA B-NAND4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND4-VALUE
                      DUAL-EVAL-B-NAND4-STATE)))

(PROVE-LEMMA B-NAND5-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND5 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND5-VALUE
                      DUAL-EVAL-B-NAND5-STATE)))

(PROVE-LEMMA B-NAND6-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND6 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND6-VALUE
                      DUAL-EVAL-B-NAND6-STATE)))

(PROVE-LEMMA B-NAND8-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NAND8 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NAND8-VALUE
                      DUAL-EVAL-B-NAND8-STATE)))

(PROVE-LEMMA B-NBUF-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NBUF ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NBUF-VALUE
                      DUAL-EVAL-B-NBUF-STATE)))

(PROVE-LEMMA B-NOR-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR-VALUE
                      DUAL-EVAL-B-NOR-STATE)))

(PROVE-LEMMA B-NOR3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR3-VALUE
                      DUAL-EVAL-B-NOR3-STATE)))

(PROVE-LEMMA B-NOR4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR4-VALUE
                      DUAL-EVAL-B-NOR4-STATE)))

(PROVE-LEMMA B-NOR5-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR5 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR5-VALUE
                      DUAL-EVAL-B-NOR5-STATE)))

(PROVE-LEMMA B-NOR6-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR6 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR6-VALUE
                      DUAL-EVAL-B-NOR6-STATE)))

(PROVE-LEMMA B-NOR8-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOR8 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOR8-VALUE
                      DUAL-EVAL-B-NOR8-STATE)))

(PROVE-LEMMA B-NOT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOT ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-NOT-VALUE
                      DUAL-EVAL-B-NOT-STATE)))

(PROVE-LEMMA B-NOT-B4IP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOT-B4IP
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-B-NOT-B4IP-VALUE DUAL-EVAL-B-NOT-B4IP-STATE)))

(PROVE-LEMMA B-NOT-IVAP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-NOT-IVAP
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-B-NOT-IVAP-VALUE DUAL-EVAL-B-NOT-IVAP-STATE)))

(PROVE-LEMMA B-OR-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-OR ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-OR-VALUE
                      DUAL-EVAL-B-OR-STATE)))

(PROVE-LEMMA B-OR3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-OR3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-OR3-VALUE
                      DUAL-EVAL-B-OR3-STATE)))

(PROVE-LEMMA B-OR4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-OR4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-OR4-VALUE
                      DUAL-EVAL-B-OR4-STATE)))

(PROVE-LEMMA B-XOR-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-XOR ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-XOR-VALUE
                      DUAL-EVAL-B-XOR-STATE)))

(PROVE-LEMMA B-XOR3-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'B-XOR3 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-B-XOR3-VALUE
                      DUAL-EVAL-B-XOR3-STATE)))

(PROVE-LEMMA DEL2-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'DEL2 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-DEL2-VALUE
                      DUAL-EVAL-DEL2-STATE)))

(PROVE-LEMMA DEL4-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'DEL4 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-DEL4-VALUE
                      DUAL-EVAL-DEL4-STATE)))

(PROVE-LEMMA DEL10-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'DEL10 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-DEL10-VALUE
                      DUAL-EVAL-DEL10-STATE)))

(PROVE-LEMMA PROCMON-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'PROCMON ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-PROCMON-VALUE
                      DUAL-EVAL-PROCMON-STATE)))

(PROVE-LEMMA FD1-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'FD1 ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-FD1-VALUE
                      DUAL-EVAL-FD1-STATE)))

(PROVE-LEMMA FD1S-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'FD1S ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-FD1S-VALUE
                      DUAL-EVAL-FD1S-STATE)))

(PROVE-LEMMA FD1SP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'FD1SP ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-FD1SP-VALUE
                      DUAL-EVAL-FD1SP-STATE)))

(PROVE-LEMMA FD1SLP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'FD1SLP ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-FD1SLP-VALUE
                      DUAL-EVAL-FD1SLP-STATE)))

(PROVE-LEMMA ID-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'ID ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-ID-VALUE
                      DUAL-EVAL-ID-STATE)))

(PROVE-LEMMA RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'RAM-ENABLE-CIRCUIT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE
                      DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE)))

(PROVE-LEMMA T-BUF-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'T-BUF ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-T-BUF-VALUE
                      DUAL-EVAL-T-BUF-STATE)))

(PROVE-LEMMA T-WIRE-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'T-WIRE ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-T-WIRE-VALUE
                      DUAL-EVAL-T-WIRE-STATE)))

(PROVE-LEMMA PULLUP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'PULLUP ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-PULLUP-VALUE
                      DUAL-EVAL-PULLUP-STATE)))

(PROVE-LEMMA TTL-BIDIRECT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-BIDIRECT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-BIDIRECT-VALUE
                      DUAL-EVAL-TTL-BIDIRECT-STATE)))

(PROVE-LEMMA TTL-CLK-INPUT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-CLK-INPUT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-CLK-INPUT-VALUE
                      DUAL-EVAL-TTL-CLK-INPUT-STATE)))

(PROVE-LEMMA TTL-INPUT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-INPUT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-INPUT-VALUE DUAL-EVAL-TTL-INPUT-STATE)))

(PROVE-LEMMA TTL-OUTPUT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-OUTPUT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-OUTPUT-VALUE DUAL-EVAL-TTL-OUTPUT-STATE)))

(PROVE-LEMMA TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-OUTPUT-PARAMETRIC
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE
                      DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE)))

(PROVE-LEMMA TTL-OUTPUT-FAST-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-OUTPUT-FAST
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-OUTPUT-FAST-VALUE
                      DUAL-EVAL-TTL-OUTPUT-FAST-STATE)))

(PROVE-LEMMA TTL-TRI-OUTPUT-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-TRI-OUTPUT
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-TRI-OUTPUT-VALUE
                      DUAL-EVAL-TTL-TRI-OUTPUT-STATE)))

(PROVE-LEMMA TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'TTL-TRI-OUTPUT-FAST
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE
                      DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE)))

(PROVE-LEMMA VDD-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'VDD ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-VDD-VALUE
                      DUAL-EVAL-VDD-STATE)))

(PROVE-LEMMA VDD-PARAMETRIC-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'VDD-PARAMETRIC
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-EVAL-VDD-PARAMETRIC-VALUE
                      DUAL-EVAL-VDD-PARAMETRIC-STATE)))

(PROVE-LEMMA VSS-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'VSS ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0 DUAL-EVAL-VSS-VALUE
                      DUAL-EVAL-VSS-STATE)))

(PROVE-LEMMA GOOD-S-CONSTANT-RAM
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (CONSTANT-RAM S (MAKE-LIST 32 (X)))))
             ((ENABLE CONSTANT-RAM)))

(PROVE-LEMMA GOOD-S-WRITE-MEM-1
             (REWRITE)
             (IMPLIES (AND (GOOD-S S)
                           (PROPERP VALUE)
                           (EQUAL (LENGTH VALUE) 32))
                      (GOOD-S (WRITE-MEM1 V-ADDR S VALUE)))
             ((ENABLE WRITE-MEM1)))

(PROVE-LEMMA GOOD-S-WRITE-MEM
             (REWRITE)
             (IMPLIES (AND (GOOD-S S)
                           (PROPERP VALUE)
                           (EQUAL (LENGTH VALUE) 32))
                      (GOOD-S (WRITE-MEM V-ADDR S VALUE)))
             ((ENABLE WRITE-MEM)))

(PROVE-LEMMA DP-RAM-16X32-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (GOOD-S S)
                      (GOOD-S (DUAL-APPLY-STATE 'DP-RAM-16X32
                                                ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*B-APPROX *1*V-APPROX *1*S-APPROX V-APPROX
                      GOOD-S-CONSTANT-RAM GOOD-S-WRITE-MEM LENGTH-SUBRANGE
                      PROPERP-SUBRANGE PROPERP-MAKE-LIST LENGTH-MAKE-LIST
                      DUAL-APPLY-STATE *1*PRIMP2 F-BUF-PRESERVES-GOOD-S
                      F-IF-PRESERVES-GOOD-S GOOD-S-0
                      DUAL-APPLY-STATE-DP-RAM-16X32 DUAL-PORT-RAM-STATE)))

(DEFTHEORY GOOD-S-PRIMITIVES-THEORY
           (AO2-PRESERVES-GOOD-S AO4-PRESERVES-GOOD-S AO6-PRESERVES-GOOD-S
                                 AO7-PRESERVES-GOOD-S B-AND-PRESERVES-GOOD-S
                                 B-AND3-PRESERVES-GOOD-S
                                 B-AND4-PRESERVES-GOOD-S
                                 B-EQUV-PRESERVES-GOOD-S
                                 B-EQUV3-PRESERVES-GOOD-S
                                 B-IF-PRESERVES-GOOD-S B-NAND-PRESERVES-GOOD-S
                                 B-NAND3-PRESERVES-GOOD-S
                                 B-NAND4-PRESERVES-GOOD-S
                                 B-NAND5-PRESERVES-GOOD-S
                                 B-NAND6-PRESERVES-GOOD-S
                                 B-NAND8-PRESERVES-GOOD-S
                                 B-NBUF-PRESERVES-GOOD-S
                                 B-NOR-PRESERVES-GOOD-S
                                 B-NOR3-PRESERVES-GOOD-S
                                 B-NOR4-PRESERVES-GOOD-S
                                 B-NOR5-PRESERVES-GOOD-S
                                 B-NOR6-PRESERVES-GOOD-S
                                 B-NOR8-PRESERVES-GOOD-S
                                 B-NOT-PRESERVES-GOOD-S
                                 B-NOT-B4IP-PRESERVES-GOOD-S
                                 B-NOT-IVAP-PRESERVES-GOOD-S
                                 B-OR-PRESERVES-GOOD-S B-OR3-PRESERVES-GOOD-S
                                 B-OR4-PRESERVES-GOOD-S B-XOR-PRESERVES-GOOD-S
                                 B-XOR3-PRESERVES-GOOD-S DEL2-PRESERVES-GOOD-S
                                 DEL4-PRESERVES-GOOD-S DEL10-PRESERVES-GOOD-S
                                 PROCMON-PRESERVES-GOOD-S FD1-PRESERVES-GOOD-S
                                 FD1S-PRESERVES-GOOD-S FD1SP-PRESERVES-GOOD-S
                                 FD1SLP-PRESERVES-GOOD-S ID-PRESERVES-GOOD-S
                                 RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S
                                 T-BUF-PRESERVES-GOOD-S
                                 T-WIRE-PRESERVES-GOOD-S
                                 PULLUP-PRESERVES-GOOD-S
                                 TTL-BIDIRECT-PRESERVES-GOOD-S
                                 TTL-CLK-INPUT-PRESERVES-GOOD-S
                                 TTL-INPUT-PRESERVES-GOOD-S
                                 TTL-OUTPUT-PRESERVES-GOOD-S
                                 TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S
                                 TTL-OUTPUT-FAST-PRESERVES-GOOD-S
                                 TTL-TRI-OUTPUT-PRESERVES-GOOD-S
                                 TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S
                                 VDD-PRESERVES-GOOD-S
                                 VDD-PARAMETRIC-PRESERVES-GOOD-S
                                 VSS-PRESERVES-GOOD-S
                                 DP-RAM-16X32-PRESERVES-GOOD-S))

(PROVE-LEMMA PRIMP-PRESERVES-GOOD-S
             (REWRITE)
             (IMPLIES (AND (GOOD-S S)
                           (PRIMP FN)
                           (NOT (EQUAL FN 'MEM-32X32)))
                      (GOOD-S (DUAL-APPLY-STATE FN ARGS S)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO GOOD-S-PRIMITIVES-THEORY)
              (ENABLE PRIMP LOOKUP-MODULE *1*PRIMP-DATABASE)))

(PROVE-LEMMA GOOD-S-PRESERVED
       (REWRITE)
       (IMPLIES (OK-NETLISTP FLAG FN NETLIST
                             '(MEM-32X32))
                (AND (IMPLIES (AND (EQUAL FLAG 2) (GOOD-S S))
                              (GOOD-S (DUAL-EVAL FLAG FN A S NETLIST)))
                     (IMPLIES (AND (EQUAL FLAG 3) (GOOD-S-ALIST S))
                              (GOOD-S-ALIST (DUAL-EVAL FLAG FN A S NETLIST)))))
       ((EXPAND (DUAL-EVAL 2 FN A S NETLIST)
                (DUAL-EVAL 3 FN A S NETLIST))
        (INDUCT (DUAL-EVAL FLAG FN A S NETLIST))))

(DEFN V-APPROX-LIST
      (X Y)
      (IF (LISTP X)
          (AND (LISTP Y)
               (V-APPROX (CAR X) (CAR Y))
               (V-APPROX-LIST (CDR X) (CDR Y)))
          (NLISTP Y)))

(DEFN V-S-APPROX-LIST
      (X Y)
      (IF (LISTP X)
          (AND (LISTP Y)
               (V-APPROX (CAAR X) (CAAR Y))
               (S-APPROX (CADAR X) (CADAR Y))
               (V-S-APPROX-LIST (CDR X) (CDR Y)))
          T))

(DEFN NAT-LST-LST-INDUCTION
      (N X Y)
      (IF (OR (ZEROP N) (NLISTP X) (NLISTP Y))
          T
          (NAT-LST-LST-INDUCTION (SUB1 N)
                                 (CDR X)
                                 (CDR Y))))

(TOGGLE OPEN-NTH-ON OPEN-NTH NIL)

(PROVE-LEMMA V-APPROX-CAR-NTH
             (REWRITE)
             (IMPLIES (AND (V-S-APPROX-LIST FINAL-1 FINAL-2)
                           (LESSP N (LENGTH FINAL-1)))
                      (V-APPROX (CAR (NTH N FINAL-1))
                                (CAR (NTH N FINAL-2))))
             ((INDUCT (NAT-LST-LST-INDUCTION N FINAL-1 FINAL-2))))

(PROVE-LEMMA S-APPROX-CADR-NTH
             (REWRITE)
             (IMPLIES (AND (V-S-APPROX-LIST FINAL-1 FINAL-2)
                           (LESSP N (LENGTH FINAL-1)))
                      (S-APPROX (CADR (NTH N FINAL-1))
                                (CADR (NTH N FINAL-2))))
             ((INDUCT (NAT-LST-LST-INDUCTION N FINAL-1 FINAL-2))))

(DEFN SIMULATE-MONOTONE-INDUCTION
      (FN INPUTS-1 STATE-1 NETLIST INPUTS-2 STATE-2)
      (IF (LISTP INPUTS-1)
          (SIMULATE-MONOTONE-INDUCTION FN
                                       (CDR INPUTS-1)
                                       (DUAL-EVAL 2 FN
                                                  (CAR INPUTS-1)
                                                  STATE-1 NETLIST)
                                       NETLIST
                                       (CDR INPUTS-2)
                                       (DUAL-EVAL 2 FN
                                                  (CAR INPUTS-2)
                                                  STATE-2 NETLIST))
          T))

(PROVE-LEMMA SIMULATE-MONOTONE
             (REWRITE)
             (IMPLIES (AND (V-APPROX-LIST INPUTS-1 INPUTS-2)
                           (S-APPROX STATE-1 STATE-2)
                           (GOOD-S STATE-2)
                           (OK-NETLISTP 0 FN NETLIST
                                        '(MEM-32X32))
                           (OK-NETLISTP 2 FN NETLIST
                                        '(MEM-32X32)))
                      (V-S-APPROX-LIST (SIMULATE FN INPUTS-1 STATE-1 NETLIST)
                                       (SIMULATE FN INPUTS-2 STATE-2 NETLIST)))
             ((INDUCT (SIMULATE-MONOTONE-INDUCTION FN INPUTS-1 STATE-1
                                                   NETLIST INPUTS-2 STATE-2))
              (DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE SIMULATE S-APPROX V-S-APPROX-LIST GOOD-S-PRESERVED
                      MONOTONICITY-PROPERTY-CONSEQUENCE-0
                      MONOTONICITY-PROPERTY-CONSEQUENCE-2 DUAL-EVAL-MONOTONE
                      V-APPROX-LIST)))

(PROVE-LEMMA V-APPROX-LIST-X-X
             (REWRITE)
             (V-APPROX-LIST X X))

(DEFN DOUBLET-P
      (X)
      (EQUAL X (LIST (CAR X) (CADR X))))

(DEFN DOUBLET-N-SIMULATE-INDUCTION
      (FN INPUTS STATE NETLIST N)
      (IF (ZEROP N)
          T
          (DOUBLET-N-SIMULATE-INDUCTION FN
                                        (CDR INPUTS)
                                        (DUAL-EVAL 2 FN
                                                   (CAR INPUTS)
                                                   STATE NETLIST)
                                        NETLIST
                                        (SUB1 N))))

(PROVE-LEMMA DOUBLET-N-SIMULATE
             (REWRITE)
             (IMPLIES (LESSP N (LENGTH INPUTS))
                      (DOUBLET-P (NTH N
                                      (SIMULATE FN INPUTS STATE NETLIST))))
             ((INDUCT (DOUBLET-N-SIMULATE-INDUCTION FN INPUTS STATE NETLIST N))
              (EXPAND (SIMULATE FN INPUTS STATE NETLIST))))

(PROVE-LEMMA DOUBLET-P-EQUAL-APPROX NIL
             (IMPLIES (AND (DOUBLET-P X)
                           (DOUBLET-P Y)
                           (V-KNOWNP (CAR X))
                           (S-KNOWNP (CADR X))
                           (V-APPROX (CAR X) (CAR Y))
                           (S-APPROX (CADR X) (CADR Y)))
                      (EQUAL X Y)))

(TOGGLE DOUBLET-P-OFF DOUBLET-P T)

(PROVE-LEMMA LENGTH-SIMULATE
             (REWRITE)
             (EQUAL (LENGTH (SIMULATE FN INPUTS STATE NETLIST))
                    (LENGTH INPUTS)))

(PROVE-LEMMA XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE NIL
   (IMPLIES (AND (LESSP N (LENGTH INPUTS))
                 (S-APPROX STATE-1 STATE-2)
                 (V-KNOWNP (CAR (NTH N
                                     (SIMULATE FN INPUTS STATE-1 NETLIST))))
                 (S-KNOWNP (CADR (NTH N
                                      (SIMULATE FN INPUTS STATE-1 NETLIST))))
                 (GOOD-S STATE-2)
                 (OK-NETLISTP 0 FN NETLIST
                              '(MEM-32X32))
                 (OK-NETLISTP 2 FN NETLIST
                              '(MEM-32X32)))
            (EQUAL (NTH N
                        (SIMULATE FN INPUTS STATE-1 NETLIST))
                   (NTH N
                        (SIMULATE FN INPUTS STATE-2 NETLIST))))
   ((USE (DOUBLET-P-EQUAL-APPROX (X (NTH N
                                         (SIMULATE FN INPUTS STATE-1 NETLIST)))
                                 (Y (NTH N
                                         (SIMULATE FN INPUTS STATE-2
                                                   NETLIST)))))
    (DISABLE-THEORY T)
    (ENABLE-THEORY GROUND-ZERO)
    (ENABLE V-APPROX-CAR-NTH S-APPROX-CADR-NTH SIMULATE-MONOTONE
            V-APPROX-LIST-X-X DOUBLET-N-SIMULATE DOUBLET-P-EQUAL-APPROX
            LENGTH-SIMULATE)))

(PROVE-LEMMA XS-SUFFICE-FOR-RESET-LEMMA NIL
             (IMPLIES (AND (LESSP N (LENGTH INPUTS))
                           (S-APPROX STATE-1 STATE-2)
                           (V-KNOWNP (CAR (NTH N
                                               (SIMULATE FN INPUTS STATE-1
                                                         NETLIST))))
                           (S-KNOWNP (CADR (NTH N
                                                (SIMULATE FN INPUTS STATE-1
                                                          NETLIST))))
                           (GOOD-S STATE-2)
                           (OK-NETLISTP 0 FN NETLIST
                                        '(MEM-32X32)))
                      (EQUAL (NTH N
                                  (SIMULATE FN INPUTS STATE-1 NETLIST))
                             (NTH N
                                  (SIMULATE FN INPUTS STATE-2 NETLIST))))
             ((USE (XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE))))

(DEFN COMPILE-UNCOMPILED-DEFNS NIL T)

(TOGGLE COMPILE-UNCOMPILED-DEFNS-ON COMPILE-UNCOMPILED-DEFNS NIL)

(COMPILE-UNCOMPILED-DEFNS "tmp")

(DEFN UNKNOWN-REGFILE NIL
      (LIST (CONS (CONS (CONS (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X))))
                              (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X)))))
                        (CONS (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X))))
                              (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X))))))
                  (CONS (CONS (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X))))
                              (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X)))))
                        (CONS (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X))))
                              (CONS (RAM (MAKE-LIST 32 (X)))
                                    (RAM (MAKE-LIST 32 (X)))))))
            (X)
            (MAKE-LIST 32 (X))
            (MAKE-LIST 4 (X))))

(DEFN UNKNOWN-MACHINE-STATE NIL
      (LIST (UNKNOWN-REGFILE)
            (MAKE-LIST 4 (X))
            (MAKE-LIST 32 (X))
            (MAKE-LIST 32 (X))
            (MAKE-LIST 32 (X))
            (MAKE-LIST 32 (X))
            (MAKE-LIST 32 (X))
            (X)
            (X)
            (X)
            (MAKE-LIST 4 (X))
            (MAKE-LIST 40 (X))))

(DEFN UNKNOWN-MEMORY-STATE NIL
      (LIST (STUB (MAKE-LIST 32 F))
            0 0 0
            (X)
            (X)
            (MAKE-LIST 32 (X))
            (MAKE-LIST 32 (X))))

(DEFN UNKNOWN-STATE NIL
      (LIST (UNKNOWN-MACHINE-STATE)
            (UNKNOWN-MEMORY-STATE)))

(PROVE-LEMMA CHIP-SYSTEM-INVARIANT-UNKNOWN-STATE NIL
             (CHIP-SYSTEM-INVARIANT (UNKNOWN-STATE)))

(PROVE-LEMMA FM9001-STATE-STRUCTURE-UNKNOWN-STATE NIL
             (FM9001-STATE-STRUCTURE (UNKNOWN-STATE)))

(DEFN RESET-VECTOR NIL
      (CONS (X)
            (CONS (X)
                  (CONS F
                        (CONS F
                              (CONS T
                                    (CONS T
                                          (CONS T (MAKE-LIST 4 T)))))))))

(DEFN RUN-VECTOR NIL
      (CONS (X)
            (CONS (X)
                  (CONS F
                        (CONS T
                              (CONS T
                                    (CONS T
                                          (CONS T (MAKE-LIST 4 T)))))))))

(DEFN RESET-SEQUENCE NIL
      (CONS (RESET-VECTOR)
            (MAKE-LIST 19 (RUN-VECTOR))))

(PROVE-LEMMA CHIP-SYSTEM-OPERATING-INPUTS-P-RESET-SEQUENCE NIL
             (CHIP-SYSTEM-OPERATING-INPUTS-P (RESET-SEQUENCE)
                                             20))

(DEFN INITIALIZED-REGFILE NIL
      (LIST (CONS (CONS (CONS (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F)))
                              (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F))))
                        (CONS (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F)))
                              (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F)))))
                  (CONS (CONS (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F)))
                              (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F))))
                        (CONS (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F)))
                              (CONS (RAM (MAKE-LIST 32 F))
                                    (RAM (MAKE-LIST 32 F))))))
            F
            (MAKE-LIST 32 F)
            (MAKE-LIST 4 T)))

(DEFN INITIALIZED-MACHINE-STATE NIL
      (LIST (INITIALIZED-REGFILE)
            (LIST T F F F)
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 F)
            T T T
            (MAKE-LIST 4 T)
            (CV_FETCH1 T
                       (LIST T T T T)
                       (MAKE-LIST 32 F)
                       (LIST T F F F)
                       (MAKE-LIST 4 T))))

(DEFN INITIALIZED-MEMORY-STATE NIL
      (LIST (STUB (MAKE-LIST 32 F))
            0 0 0 T T
            (MAKE-LIST 32 F)
            (MAKE-LIST 32 (X))))

(DEFN FINAL-STATE NIL
      (LIST (INITIALIZED-MACHINE-STATE)
            (INITIALIZED-MEMORY-STATE)))

(PROVE-LEMMA RESET-WORKS NIL
             (EQUAL (RUN-FM9001 (UNKNOWN-STATE)
                                (MAP-UP-INPUTS (RESET-SEQUENCE))
                                (LENGTH (RESET-SEQUENCE)))
                    (FINAL-STATE))
             ((DISABLE RUN-FM9001 UNKNOWN-STATE MAP-UP-INPUTS RESET-SEQUENCE
                       LENGTH FINAL-STATE)))

(PROVE-LEMMA UNKNOWN-STATE-OKP NIL
             (AND (FM9001-STATE-STRUCTURE (UNKNOWN-STATE))
                  (CHIP-SYSTEM-INVARIANT (UNKNOWN-STATE))
                  (CHIP-SYSTEM-OPERATING-INPUTS-P (RESET-SEQUENCE)
                                                  20))
             ((DISABLE CHIP-SYSTEM-INVARIANT CHIP-SYSTEM-OPERATING-INPUTS-P
                       RESET-SEQUENCE UNKNOWN-STATE FM9001-STATE-STRUCTURE)))

(PROVE-LEMMA FINAL-STATE-OKP
             (REWRITE)
             (AND (CHIP-SYSTEM& (CHIP-SYSTEM$NETLIST))
                  (FM9001-STATE-STRUCTURE (FINAL-STATE))
                  (MACROCYCLE-INVARIANT (FINAL-STATE)
                                        (MAKE-LIST 4 T)))
             ((DISABLE CHIP-SYSTEM& CHIP-SYSTEM$NETLIST
                       FM9001-STATE-STRUCTURE FINAL-STATE
                       MACROCYCLE-INVARIANT)))

(PROVE-LEMMA INSTANCE-THEOREM NIL
 (IMPLIES
  (AND
      (CHIP-SYSTEM& (CHIP-SYSTEM$NETLIST))
      (FM9001-STATE-STRUCTURE (FINAL-STATE))
      (MACROCYCLE-INVARIANT (FINAL-STATE)
                            PC)
      (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
                                      (TOTAL-MICROCYCLES (FINAL-STATE)
                                                         (MAP-UP-INPUTS INPUTS)
                                                         N))
      (OPERATING-INPUTS-P (MAP-UP-INPUTS INPUTS)
                          (TOTAL-MICROCYCLES (FINAL-STATE)
                                             (MAP-UP-INPUTS INPUTS)
                                             N)))
  (EQUAL
        (MAP-UP (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                                      INPUTS
                                      (FINAL-STATE)
                                      (CHIP-SYSTEM$NETLIST)
                                      (TOTAL-MICROCYCLES (FINAL-STATE)
                                                         (MAP-UP-INPUTS INPUTS)
                                                         N)))
        (FM9001-INTERPRETER (MAP-UP (FINAL-STATE))
                            PC N)))
 ((DISABLE MAP-UP-INPUTS TOTAL-MICROCYCLES CHIP-SYSTEM$NETLIST FINAL-STATE
           *1*FINAL-STATE FM9001-STATE-STRUCTURE MACROCYCLE-INVARIANT
           CHIP-SYSTEM-OPERATING-INPUTS-P OPERATING-INPUTS-P MAP-UP
           SIMULATE-DUAL-EVAL-2 FM9001-INTERPRETER PC-REG)))

(PROVE-LEMMA FM9001-STATEP-MAP-UP-FINAL-STATE
             (REWRITE)
             (FM9001-STATEP (MAP-UP (FINAL-STATE)))
             ((DISABLE FM9001-STATEP MAP-UP FINAL-STATE)))

(DEFN RESET-VECTOR-CHIP NIL
 (CONS
  (X)
  (CONS
       (X)
       (CONS F
             (CONS (X)
                   (CONS F
                         (CONS T
                               (CONS T
                                     (CONS T
                                           (APPEND (MAKE-LIST 4 T)
                                                   (MAKE-LIST 32 (X))))))))))))

(DEFN RUN-VECTOR-CHIP-1 NIL
 (CONS T
   (CONS (X)
         (CONS F
               (CONS T
                     (CONS T
                           (CONS T
                                 (CONS T
                                       (CONS T
                                             (APPEND (MAKE-LIST 4 T)
                                                     (MAKE-LIST 32 T)))))))))))

(DEFN RUN-VECTOR-CHIP-2 NIL
 (CONS F
   (CONS (X)
         (CONS F
               (CONS T
                     (CONS T
                           (CONS T
                                 (CONS T
                                       (CONS T
                                             (APPEND (MAKE-LIST 4 T)
                                                     (MAKE-LIST 32 T)))))))))))

(DEFN RESET-SEQUENCE-CHIP-1 NIL
      (CONS (RESET-VECTOR-CHIP)
            (MAKE-LIST 19 (RUN-VECTOR-CHIP-1))))

(DEFN RESET-SEQUENCE-CHIP-2 NIL
      (CONS (RESET-VECTOR-CHIP)
            (MAKE-LIST 19 (RUN-VECTOR-CHIP-2))))

(PROVE-LEMMA RESET-SEQUENCE-CHIP-1-VS-2 NIL
             (EQUAL (SIMULATE 'CHIP
                              (RESET-SEQUENCE-CHIP-1)
                              (UNKNOWN-MACHINE-STATE)
                              (CHIP$NETLIST))
                    (SIMULATE 'CHIP
                              (RESET-SEQUENCE-CHIP-2)
                              (UNKNOWN-MACHINE-STATE)
                              (CHIP$NETLIST)))
             ((DISABLE RESET-SEQUENCE-CHIP-1 RESET-SEQUENCE-CHIP-2
                       UNKNOWN-MACHINE-STATE CHIP$NETLIST SIMULATE)))

(PROVE-LEMMA SIMULATE-RESET-CHIP-FINAL-STATE NIL
             (EQUAL (CADR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                               (SIMULATE 'CHIP
                                         (RESET-SEQUENCE-CHIP-1)
                                         (UNKNOWN-MACHINE-STATE)
                                         (CHIP$NETLIST))))
                    (CAR (FINAL-STATE)))
             ((DISABLE RESET-SEQUENCE-CHIP-1 UNKNOWN-MACHINE-STATE
                       CHIP$NETLIST SUB1 LENGTH NTH SIMULATE FINAL-STATE)))

(PROVE-LEMMA FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP
             (REWRITE)
             (AND (EQUAL (LESSP (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                (LENGTH (RESET-SEQUENCE-CHIP-1)))
                         T)
                  (V-KNOWNP (CAR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                      (SIMULATE 'CHIP
                                                (RESET-SEQUENCE-CHIP-1)
                                                (UNKNOWN-MACHINE-STATE)
                                                (CHIP$NETLIST)))))
                  (S-KNOWNP (CADR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                       (SIMULATE 'CHIP
                                                 (RESET-SEQUENCE-CHIP-1)
                                                 (UNKNOWN-MACHINE-STATE)
                                                 (CHIP$NETLIST)))))
                  (OK-NETLISTP 0 'CHIP
                               (CHIP$NETLIST)
                               '(MEM-32X32)))
             ((DISABLE RESET-SEQUENCE-CHIP-1 UNKNOWN-MACHINE-STATE
                       CHIP$NETLIST SUB1 LENGTH NTH SIMULATE V-KNOWNP
                       S-KNOWNP OK-NETLISTP)))

(TOGGLE FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP-OFF
        FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP T)

(PROVE-LEMMA XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE NIL
  (IMPLIES (AND (S-APPROX (UNKNOWN-MACHINE-STATE)
                          STATE-2)
                (GOOD-S STATE-2))
           (EQUAL (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                       (SIMULATE 'CHIP
                                 (RESET-SEQUENCE-CHIP-1)
                                 (UNKNOWN-MACHINE-STATE)
                                 (CHIP$NETLIST)))
                  (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                       (SIMULATE 'CHIP
                                 (RESET-SEQUENCE-CHIP-1)
                                 STATE-2
                                 (CHIP$NETLIST)))))
  ((DISABLE RESET-SEQUENCE-CHIP-1 *1*RESET-SEQUENCE-CHIP-1
            UNKNOWN-MACHINE-STATE *1*UNKNOWN-MACHINE-STATE CHIP$NETLIST
            *1*CHIP$NETLIST SUB1 *1*SUB1 LENGTH *1*LENGTH NTH *1*NTH SIMULATE
            *1*SIMULATE S-APPROX *1*S-APPROX V-KNOWNP *1*V-KNOWNP S-KNOWNP
            *1*S-KNOWNP OK-NETLISTP *1*OK-NETLISTP)
   (ENABLE FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP)
   (USE (XS-SUFFICE-FOR-RESET-LEMMA (N (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1))))
                                    (FN 'CHIP)
                                    (INPUTS (RESET-SEQUENCE-CHIP-1))
                                    (STATE-1 (UNKNOWN-MACHINE-STATE))
                                    (STATE-2 STATE-2)
                                    (NETLIST (CHIP$NETLIST))))))

(PROVE-LEMMA FM9001-MACHINE-STATEP-P-MAP-UP-INITIALIZED-MACHINE-STATE
             (REWRITE)
             (FM9001-MACHINE-STATEP (P-MAP-UP (INITIALIZED-MACHINE-STATE)))
             ((DISABLE FM9001-MACHINE-STATEP MAP-UP INITIALIZED-MACHINE-STATE)))

(DEFN V-FOURP
      (X)
      (IF (NLISTP X)
          (EQUAL X NIL)
          (AND (FOURP (CAR X))
               (V-FOURP (CDR X)))))

(DEFN ALL-XS
      (VEC)
      (IF (NLISTP VEC)
          (EQUAL VEC NIL)
          (AND (EQUAL (CAR VEC) (X))
               (ALL-XS (CDR VEC)))))

(TOGGLE B-KNOWNP-ON B-KNOWNP NIL)

(TOGGLE B-APPROX-ON B-APPROX NIL)

(PROVE-LEMMA ALL-XS-APPROXIMATES
             (REWRITE)
             (IMPLIES (AND (ALL-XS VEC1)
                           (EQUAL (LENGTH VEC1) (LENGTH VEC2))
                           (PROPERP VEC2))
                      (V-APPROX VEC1 VEC2))
             ((ENABLE V-APPROX)))

(PROVE-LEMMA ALL-XS-MAKE-LIST
             (REWRITE)
             (ALL-XS (MAKE-LIST N (X)))
             ((ENABLE MAKE-LIST)))

(DEFN MEMORY-V-FOURP
      (N WIDTH MEM)
      (COND ((STUBP MEM)
             (AND (V-FOURP (STUB-GUTS MEM))
                  (EQUAL (LENGTH (STUB-GUTS MEM))
                         WIDTH)))
            ((ZEROP N)
             (COND ((RAMP MEM)
                    (AND (V-FOURP (RAM-GUTS MEM))
                         (EQUAL (LENGTH (RAM-GUTS MEM))
                                WIDTH)))
                   ((ROMP MEM)
                    (AND (V-FOURP (ROM-GUTS MEM))
                         (EQUAL (LENGTH (ROM-GUTS MEM))
                                WIDTH)))
                   (T F)))
            (T (AND (LISTP MEM)
                    (MEMORY-V-FOURP (SUB1 N)
                                    WIDTH
                                    (CAR MEM))
                    (MEMORY-V-FOURP (SUB1 N)
                                    WIDTH
                                    (CDR MEM))))))

(DEFN NEW-MACHINE-STATE-INVARIANT
      (MACHINE-STATE)
      (AND (EQUAL (LENGTH MACHINE-STATE) 12)
           (PROPERP MACHINE-STATE)
           (EQUAL (LENGTH (CAR MACHINE-STATE)) 4)
           (PROPERP (CAR MACHINE-STATE))
           (ALL-RAMP-MEM 4 (CAAR MACHINE-STATE))
           (FOURP (CADAR MACHINE-STATE))
           (MEMORY-V-FOURP 4 32
                           (CAAR MACHINE-STATE))
           (V-FOURP (CADDAR MACHINE-STATE))
           (EQUAL (LENGTH (CADDAR MACHINE-STATE))
                  32)
           (V-FOURP (CADDDAR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDAR MACHINE-STATE))
                  4)
           (V-FOURP (CADR MACHINE-STATE))
           (EQUAL (LENGTH (CADR MACHINE-STATE))
                  4)
           (V-FOURP (CADDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDR MACHINE-STATE))
                  32)
           (V-FOURP (CADDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDR MACHINE-STATE))
                  32)
           (V-FOURP (CADDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDR MACHINE-STATE))
                  32)
           (V-FOURP (CADDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDR MACHINE-STATE))
                  32)
           (V-FOURP (CADDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDR MACHINE-STATE))
                  32)
           (FOURP (CADDDDDDDR MACHINE-STATE))
           (FOURP (CADDDDDDDDR MACHINE-STATE))
           (FOURP (CADDDDDDDDDR MACHINE-STATE))
           (V-FOURP (CADDDDDDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDDDDDR MACHINE-STATE))
                  4)
           (V-FOURP (CADDDDDDDDDDDR MACHINE-STATE))
           (EQUAL (LENGTH (CADDDDDDDDDDDR MACHINE-STATE))
                  40)))

(PROVE-LEMMA S-APPROX-MAKE-LIST
             (REWRITE)
             (IMPLIES (AND (EQUAL (LENGTH VEC1) (LENGTH VEC2))
                           (V-FOURP VEC2)
                           (ALL-XS VEC1))
                      (S-APPROX VEC1 VEC2))
             ((ENABLE S-APPROX)))

(PROVE-LEMMA V-FOURP-IMPLIES-PROPERP
             (REWRITE)
             (IMPLIES (V-FOURP X) (PROPERP X)))

(PROVE-LEMMA LISTP-IMPLIES-NOT-FOURP
             (REWRITE)
             (IMPLIES (LISTP X) (NOT (FOURP X))))

(PROVE-LEMMA RAMP-IMPLIES-NOT-FOURP
             (REWRITE)
             (IMPLIES (RAMP X) (NOT (FOURP X))))

(PROVE-LEMMA ROMP-IMPLIES-NOT-FOURP
             (REWRITE)
             (IMPLIES (ROMP X) (NOT (FOURP X))))

(PROVE-LEMMA STUBP-IMPLIES-NOT-FOURP
             (REWRITE)
             (IMPLIES (STUBP X) (NOT (FOURP X))))

(PROVE-LEMMA B-APPROX-X
             (REWRITE)
             (B-APPROX (X) Y))

(PROVE-LEMMA MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA NIL
             (IMPLIES (AND (NEW-MACHINE-STATE-INVARIANT STATE)
                           (EQUAL STATE
                                  (LIST (LIST S1-1 S1-2 S1-3 S1-4)
                                        S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12)))
                      (S-APPROX (UNKNOWN-MACHINE-STATE)
                                STATE))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE NEW-MACHINE-STATE-INVARIANT B-APPROX-X ALL-RAMP-MEM
                      LISTP-IMPLIES-NOT-FOURP RAMP-IMPLIES-NOT-FOURP
                      ROMP-IMPLIES-NOT-FOURP STUBP-IMPLIES-NOT-FOURP *1*FOURP
                      V-FOURP-IMPLIES-PROPERP ALL-XS-APPROXIMATES LENGTH
                      *1*LENGTH LENGTH-CONS ALL-XS ALL-XS-MAKE-LIST
                      S-APPROX-MAKE-LIST S-APPROX *1*UNKNOWN-MACHINE-STATE
                      RAM-GUTS-RAM ROM-GUTS-ROM MEMORY-V-FOURP STUB-GUTS-STUB)))

(PROVE-LEMMA MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2 NIL
             (IMPLIES (AND (EQUAL (LENGTH STATE) 12)
                           (PROPERP STATE)
                           (EQUAL (LENGTH (CAR STATE)) 4)
                           (PROPERP (CAR STATE)))
                      (EQUAL STATE
                             (LIST (LIST (CAAR STATE)
                                         (CADAR STATE)
                                         (CADDAR STATE)
                                         (CADDDAR STATE))
                                   (CADR STATE)
                                   (CADDR STATE)
                                   (CADDDR STATE)
                                   (CADDDDR STATE)
                                   (CADDDDDR STATE)
                                   (CADDDDDDR STATE)
                                   (CADDDDDDDR STATE)
                                   (CADDDDDDDDR STATE)
                                   (CADDDDDDDDDR STATE)
                                   (CADDDDDDDDDDR STATE)
                                   (CADDDDDDDDDDDR STATE))))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE LENGTH LENGTH-BOTTOM PROPERP)))

(PROVE-LEMMA MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3 NIL
             (IMPLIES (NEW-MACHINE-STATE-INVARIANT STATE)
                      (AND (EQUAL (LENGTH STATE) 12)
                           (PROPERP STATE)
                           (EQUAL (LENGTH (CAR STATE)) 4)
                           (PROPERP (CAR STATE))))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE NEW-MACHINE-STATE-INVARIANT)))

(PROVE-LEMMA MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX NIL
 (IMPLIES (NEW-MACHINE-STATE-INVARIANT STATE)
          (S-APPROX (UNKNOWN-MACHINE-STATE)
                    STATE))
 ((DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (USE
   (MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2)
   (MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3)
   (MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA
                                               (S1-1 (CAAR STATE))
                                               (S1-2 (CADAR STATE))
                                               (S1-3 (CADDAR STATE))
                                               (S1-4 (CADDDAR STATE))
                                               (S2 (CADR STATE))
                                               (S3 (CADDR STATE))
                                               (S4 (CADDDR STATE))
                                               (S5 (CADDDDR STATE))
                                               (S6 (CADDDDDR STATE))
                                               (S7 (CADDDDDDR STATE))
                                               (S8 (CADDDDDDDR STATE))
                                               (S9 (CADDDDDDDDR STATE))
                                               (S10 (CADDDDDDDDDR STATE))
                                               (S11 (CADDDDDDDDDDR STATE))
                                               (S12 (CADDDDDDDDDDDR STATE))))))

(PROVE-LEMMA GOOD-S-OPENER
             (REWRITE)
             (AND (IMPLIES (LISTP S)
                           (EQUAL (GOOD-S S)
                                  (AND (GOOD-S (CAR S))
                                       (GOOD-S (CDR S)))))
                  (IMPLIES (RAMP S)
                           (EQUAL (GOOD-S S)
                                  (AND (EQUAL (LENGTH (RAM-GUTS S))
                                              (MEM-WIDTH))
                                       (PROPERP (RAM-GUTS S)))))
                  (IMPLIES (ROMP S)
                           (EQUAL (GOOD-S S)
                                  (AND (EQUAL (LENGTH (ROM-GUTS S))
                                              (MEM-WIDTH))
                                       (PROPERP (ROM-GUTS S)))))
                  (IMPLIES (STUBP S)
                           (EQUAL (GOOD-S S)
                                  (AND (EQUAL (LENGTH (STUB-GUTS S))
                                              (MEM-WIDTH))
                                       (PROPERP (STUB-GUTS S)))))
                  (IMPLIES (FOURP S) (GOOD-S S)))
             ((ENABLE GOOD-S)))

(PROVE-LEMMA MEMORY-V-FOURP-IMPLIES-GOOD-S
             (REWRITE)
             (IMPLIES (MEMORY-V-FOURP N 32 V)
                      (GOOD-S V)))

(PROVE-LEMMA V-FOURP-IS-GOOD-S
             (REWRITE)
             (IMPLIES (V-FOURP V) (GOOD-S V))
             ((ENABLE GOOD-S)))

(PROVE-LEMMA NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S NIL
             (IMPLIES (NEW-MACHINE-STATE-INVARIANT STATE)
                      (GOOD-S STATE))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE GOOD-S-OPENER NEW-MACHINE-STATE-INVARIANT
                      V-FOURP-IS-GOOD-S LENGTH-CONS LENGTH-1 LENGTH-BOTTOM
                      PROPERP-CONS PROPERP-NLISTP *1*GOOD-S
                      MEMORY-V-FOURP-IMPLIES-GOOD-S)))

(PROVE-LEMMA XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE NIL
  (IMPLIES (NEW-MACHINE-STATE-INVARIANT STATE)
           (EQUAL (CADR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                             (SIMULATE 'CHIP
                                       (RESET-SEQUENCE-CHIP-1)
                                       (UNKNOWN-MACHINE-STATE)
                                       (CHIP$NETLIST))))
                  (CADR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                             (SIMULATE 'CHIP
                                       (RESET-SEQUENCE-CHIP-1)
                                       STATE
                                       (CHIP$NETLIST))))))
  ((DISABLE-THEORY T)
   (ENABLE-THEORY GROUND-ZERO)
   (ENABLE FINAL-STATE)
   (USE (XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE (FINAL-1 (CAR (FINAL-STATE)))
                                                  (STATE-2 STATE))
        (SIMULATE-RESET-CHIP-FINAL-STATE)
        (MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX)
        (NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S))))

(PROVE-LEMMA XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-BETTER
            (REWRITE)
            (IMPLIES (NEW-MACHINE-STATE-INVARIANT STATE)
                     (EQUAL (CADR (NTH (SUB1 (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                       (SIMULATE 'CHIP
                                                 (RESET-SEQUENCE-CHIP-1)
                                                 STATE
                                                 (CHIP$NETLIST))))
                            (INITIALIZED-MACHINE-STATE)))
            ((DISABLE-THEORY T)
             (ENABLE-THEORY GROUND-ZERO)
             (ENABLE FINAL-STATE)
             (USE (XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE)
                  (SIMULATE-RESET-CHIP-FINAL-STATE))))

(PROVE-LEMMA NEW-MACHINE-STATE-INVARIANT-IS-NON-TRIVIAL NIL
             (NEW-MACHINE-STATE-INVARIANT (UNKNOWN-MACHINE-STATE))
             ((DISABLE-THEORY T)
              (ENABLE *1*NEW-MACHINE-STATE-INVARIANT *1*UNKNOWN-MACHINE-STATE)))

(PROVE-LEMMA MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP
             (REWRITE)
             (IMPLIES (MEMORY-V-FOURP N WIDTH MEM)
                      (MEMORY-PROPERP N WIDTH MEM))
             ((ENABLE MEMORY-PROPERP)))

(PROVE-LEMMA NEW-MACHINE-STATE-INVARIANT-IMPLIES-MACHINE-STATE-INVARIANT
             (REWRITE)
             (IMPLIES (NEW-MACHINE-STATE-INVARIANT MACHINE-STATE)
                      (MACHINE-STATE-INVARIANT MACHINE-STATE))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE NEW-MACHINE-STATE-INVARIANT MACHINE-STATE-INVARIANT
                      V-FOURP-IMPLIES-PROPERP
                      MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP)))

(PROVE-LEMMA FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE NIL
           (IMPLIES (MEMORY-OKP 32 32
                                (CADR (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                    MACHINE-MEMORY))))
                    (FM9001-STATEP (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                 MACHINE-MEMORY))))
           ((ENABLE *1*INITIALIZED-MACHINE-STATE *1*FM9001-MACHINE-STATEP)))

(PROVE-LEMMA FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA
 (REWRITE)
 (IMPLIES
  (AND
   (CHIP-SYSTEM& NETLIST)
   (MEMORY-OKP 32 32
               (CADR (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                   MACHINE-MEMORY))))
   (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
         (TOTAL-MICROCYCLES (MAP-DOWN (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                    MACHINE-MEMORY)))
                            (MAP-UP-INPUTS INPUTS)
                            N))
   (OPERATING-INPUTS-P
         (MAP-UP-INPUTS INPUTS)
         (TOTAL-MICROCYCLES (MAP-DOWN (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                    MACHINE-MEMORY)))
                            (MAP-UP-INPUTS INPUTS)
                            N)))
  (EQUAL
   (FM9001 (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                         MACHINE-MEMORY))
           N)
   (MAP-UP
    (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
         INPUTS
         (MAP-DOWN (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                 MACHINE-MEMORY)))
         NETLIST
         (TOTAL-MICROCYCLES (MAP-DOWN (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                    MACHINE-MEMORY)))
                            (MAP-UP-INPUTS INPUTS)
                            N)))))
 ((USE (FM9001=CHIP-SYSTEM (STATE (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                MACHINE-MEMORY))))
       (FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE))
  (DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE FM9001-STATEP PROPERP LENGTH LENGTH-CONS LENGTH-BOTTOM PROPERP-CONS
          PROPERP-NLISTP)))

(PROVE-LEMMA MAP-DOWN-INVERTS-MAP-UP
         (REWRITE)
         (IMPLIES (MEMORY-OKP 32 32
                              (CADR (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                  (LIST MEMORY 0 0 0 T T
                                                        (MAKE-LIST 32 F)
                                                        (MAKE-LIST 32 (X)))))))
                  (EQUAL (MAP-DOWN (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                                 (LIST MEMORY 0 0 0 T T
                                                       (MAKE-LIST 32 F)
                                                       (MAKE-LIST 32 (X))))))
                         (LIST (INITIALIZED-MACHINE-STATE)
                               (LIST MEMORY 0 0 0 T T
                                     (MAKE-LIST 32 F)
                                     (MAKE-LIST 32 (X)))))))

(PROVE-LEMMA CADR-MAP-UP NIL
             (EQUAL (CADR (MAP-UP (LIST S MEM)))
                    (CAR MEM)))

(PROVE-LEMMA FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET
 (REWRITE)
 (IMPLIES
  (AND
   (CHIP-SYSTEM& NETLIST)
   (MEMORY-OKP 32 32 MEMORY)
   (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
                           (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                    (LIST MEMORY 0 0 0 T T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X))))
                                              (MAP-UP-INPUTS INPUTS)
                                              N))
   (OPERATING-INPUTS-P (MAP-UP-INPUTS INPUTS)
                       (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                (LIST MEMORY 0 0 0 T T
                                                      (MAKE-LIST 32 F)
                                                      (MAKE-LIST 32 (X))))
                                          (MAP-UP-INPUTS INPUTS)
                                          N)))
  (EQUAL
   (FM9001 (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                         (LIST MEMORY 0 0 0 T T
                               (MAKE-LIST 32 F)
                               (MAKE-LIST 32 (X)))))
           N)
   (MAP-UP
     (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                           INPUTS
                           (LIST (INITIALIZED-MACHINE-STATE)
                                 (LIST MEMORY 0 0 0 T T
                                       (MAKE-LIST 32 F)
                                       (MAKE-LIST 32 (X))))
                           NETLIST
                           (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                    (LIST MEMORY 0 0 0 T T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X))))
                                              (MAP-UP-INPUTS INPUTS)
                                              N)))))
 ((USE
   (FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA
                                    (MACHINE-MEMORY (LIST MEMORY 0 0 0 T T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X)))))
   (CADR-MAP-UP (S (INITIALIZED-MACHINE-STATE))
                (MEM (LIST MEMORY 0 0 0 T T
                           (MAKE-LIST 32 F)
                           (MAKE-LIST 32 (X))))))
  (DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE MAP-DOWN-INVERTS-MAP-UP CADR-MAP-UP)))

(TOGGLE MAP-DOWN-INVERTS-MAP-UP-OFF MAP-DOWN-INVERTS-MAP-UP T)

(TOGGLE B-KNOWNP-OFF1 B-KNOWNP T)

(TOGGLE B-APPROX-OFF1 B-APPROX T)

(PROVE-LEMMA SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 NIL
             (IMPLIES (AND (NOT (ZEROP N))
                           (IF (LESSP (LENGTH INPUTS) N) F T))
                      (EQUAL (CADR (NTH (SUB1 N)
                                        (SIMULATE FN INPUTS STATE NETLIST)))
                             (SIMULATE-DUAL-EVAL-2 FN INPUTS STATE NETLIST N)))
             ((INDUCT (SIMULATE-DUAL-EVAL-2 FN INPUTS STATE NETLIST N))
              (ENABLE SIMULATE SIMULATE-DUAL-EVAL-2)))

(PROVE-LEMMA LENGTH-RESET-SEQUENCE-CHIP-1
             (REWRITE)
             (EQUAL (LENGTH (RESET-SEQUENCE-CHIP-1))
                    20))

(PROVE-LEMMA RESET-CHIP NIL
 (EQUAL (SIMULATE-DUAL-EVAL-2 'CHIP
                              (RESET-SEQUENCE-CHIP-1)
                              (UNKNOWN-MACHINE-STATE)
                              (CHIP$NETLIST)
                              (LENGTH (RESET-SEQUENCE-CHIP-1)))
        (INITIALIZED-MACHINE-STATE))
 ((USE
   (SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 (N (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                           (INPUTS (RESET-SEQUENCE-CHIP-1))
                                           (FN 'CHIP)
                                           (STATE (UNKNOWN-MACHINE-STATE))
                                           (NETLIST (CHIP$NETLIST)))
   (SIMULATE-RESET-CHIP-FINAL-STATE))
  (DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE FINAL-STATE LENGTH-RESET-SEQUENCE-CHIP-1)))

(PROVE-LEMMA RESET-CHIP-FROM-ANY-STATE NIL
 (IMPLIES (AND (S-APPROX (UNKNOWN-MACHINE-STATE)
                         ANY-STATE)
               (GOOD-S ANY-STATE))
          (EQUAL (SIMULATE-DUAL-EVAL-2 'CHIP
                                       (RESET-SEQUENCE-CHIP-1)
                                       ANY-STATE
                                       (CHIP$NETLIST)
                                       (LENGTH (RESET-SEQUENCE-CHIP-1)))
                 (INITIALIZED-MACHINE-STATE)))
 ((USE
   (SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 (N (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                           (INPUTS (RESET-SEQUENCE-CHIP-1))
                                           (FN 'CHIP)
                                           (STATE (UNKNOWN-MACHINE-STATE))
                                           (NETLIST (CHIP$NETLIST)))
   (SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 (N (LENGTH (RESET-SEQUENCE-CHIP-1)))
                                           (INPUTS (RESET-SEQUENCE-CHIP-1))
                                           (FN 'CHIP)
                                           (STATE ANY-STATE)
                                           (NETLIST (CHIP$NETLIST)))
   (SIMULATE-RESET-CHIP-FINAL-STATE)
   (XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE (STATE-2 ANY-STATE)))
  (DISABLE-THEORY T)
  (ENABLE-THEORY GROUND-ZERO)
  (ENABLE FINAL-STATE LENGTH-RESET-SEQUENCE-CHIP-1)))

(PROVE-LEMMA CHIP-SYSTEM=FM9001-INTERPRETER$AFTER-RESET
 (REWRITE)
 (IMPLIES
  (AND
   (CHIP-SYSTEM& NETLIST)
   (MEMORY-OKP 32 32 MEMORY)
   (CHIP-SYSTEM-OPERATING-INPUTS-P INPUTS
                           (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                    (LIST MEMORY 0 CLOCK 0
                                                          (X)
                                                          T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X))))
                                              (MAP-UP-INPUTS INPUTS)
                                              INSTRUCTIONS))
   (OPERATING-INPUTS-P (MAP-UP-INPUTS INPUTS)
                       (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                (LIST MEMORY 0 CLOCK 0
                                                      (X)
                                                      T
                                                      (MAKE-LIST 32 F)
                                                      (MAKE-LIST 32 (X))))
                                          (MAP-UP-INPUTS INPUTS)
                                          INSTRUCTIONS)))
  (EQUAL
   (MAP-UP
     (SIMULATE-DUAL-EVAL-2 'CHIP-SYSTEM
                           INPUTS
                           (LIST (INITIALIZED-MACHINE-STATE)
                                 (LIST MEMORY 0 CLOCK 0
                                       (X)
                                       T
                                       (MAKE-LIST 32 F)
                                       (MAKE-LIST 32 (X))))
                           NETLIST
                           (TOTAL-MICROCYCLES (LIST (INITIALIZED-MACHINE-STATE)
                                                    (LIST MEMORY 0 CLOCK 0
                                                          (X)
                                                          T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X))))
                                              (MAP-UP-INPUTS INPUTS)
                                              INSTRUCTIONS)))
   (FM9001-INTERPRETER (MAP-UP (LIST (INITIALIZED-MACHINE-STATE)
                                     (LIST MEMORY 0 CLOCK 0
                                           (X)
                                           T
                                           (MAKE-LIST 32 F)
                                           (MAKE-LIST 32 (X)))))
                       (MAKE-LIST 4 T)
                       INSTRUCTIONS)))
 ((USE (CHIP-SYSTEM=FM9001-INTERPRETER (STATE (LIST (INITIALIZED-MACHINE-STATE)
                                                    (LIST MEMORY 0 CLOCK 0
                                                          (X)
                                                          T
                                                          (MAKE-LIST 32 F)
                                                          (MAKE-LIST 32 (X)))))
                                       (PC (MAKE-LIST 4 T))))
  (DISABLE CHIP-SYSTEM=FM9001-INTERPRETER)))

(TOGGLE COMPILE-UNCOMPILED-DEFNS-ON1 COMPILE-UNCOMPILED-DEFNS NIL)

(COMPILE-UNCOMPILED-DEFNS "tmp")

(PROVE-LEMMA CHIP-WELL-FORMED NIL
             (AND (EQUAL (TOP-LEVEL-PREDICATE (CHIP-MODULE$NETLIST))
                         T)
                  (EQUAL (TOP-LEVEL-PREDICATE (CHIP$NETLIST))
                         T))
             ((DISABLE TOP-LEVEL-PREDICATE CHIP-MODULE$NETLIST CHIP$NETLIST)))

(PROVE-LEMMA CHIP-WELL-FORMED-AFTER-INDEXED-NAMES-REMOVED NIL
         (AND (EQUAL (TOP-LEVEL-PREDICATE (LISP-NETLIST (CHIP-MODULE$NETLIST)))
                     T)
              (EQUAL (TOP-LEVEL-PREDICATE (LISP-NETLIST (CHIP$NETLIST)))
                     T))
         ((DISABLE TOP-LEVEL-PREDICATE LISP-NETLIST CHIP-MODULE$NETLIST
                   CHIP$NETLIST)))

(PROVE-LEMMA CHIP-WELL-FORMED-SIMPLE NIL
  (AND (EQUAL (TOP-LEVEL-PREDICATE-SIMPLE (CHIP-MODULE$NETLIST))
              T)
       (EQUAL (TOP-LEVEL-PREDICATE-SIMPLE (LISP-NETLIST (CHIP-MODULE$NETLIST)))
              T))
  ((DISABLE TOP-LEVEL-PREDICATE CHIP-MODULE$NETLIST)))

(TOGGLE CHIP-WELL-FORMED-SIMPLE-OFF CHIP-WELL-FORMED-SIMPLE T)

(TOGGLE CHIP-WELL-FORMED-AFTER-INDEXED-NAMES-REMOVED-OFF
        CHIP-WELL-FORMED-AFTER-INDEXED-NAMES-REMOVED T)

(TOGGLE CHIP-WELL-FORMED-OFF CHIP-WELL-FORMED T)

(TOGGLE CHIP-SYSTEM=FM9001-INTERPRETER$AFTER-RESET-OFF
        CHIP-SYSTEM=FM9001-INTERPRETER$AFTER-RESET T)

(TOGGLE RESET-CHIP-FROM-ANY-STATE-OFF RESET-CHIP-FROM-ANY-STATE T)

(TOGGLE RESET-CHIP-OFF RESET-CHIP T)

(TOGGLE LENGTH-RESET-SEQUENCE-CHIP-1-OFF LENGTH-RESET-SEQUENCE-CHIP-1 T)

(TOGGLE SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2-OFF
        SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 T)

(TOGGLE FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-OFF
        FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET T)

(TOGGLE CADR-MAP-UP-OFF CADR-MAP-UP T)

(TOGGLE FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA-OFF
        FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA T)

(TOGGLE FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE-OFF
        FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE T)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IMPLIES-MACHINE-STATE-INVARIANT-OFF
        NEW-MACHINE-STATE-INVARIANT-IMPLIES-MACHINE-STATE-INVARIANT T)

(TOGGLE MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP-OFF
        MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP T)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IS-NON-TRIVIAL-OFF
        NEW-MACHINE-STATE-INVARIANT-IS-NON-TRIVIAL T)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-BETTER-OFF
        XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-BETTER T)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-OFF
        XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE T)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S-OFF
        NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S T)

(TOGGLE V-FOURP-IS-GOOD-S-OFF V-FOURP-IS-GOOD-S T)

(TOGGLE MEMORY-V-FOURP-IMPLIES-GOOD-S-OFF MEMORY-V-FOURP-IMPLIES-GOOD-S T)

(TOGGLE GOOD-S-OPENER-OFF GOOD-S-OPENER T)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-OFF
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX T)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3-OFF
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3 T)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2-OFF
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2 T)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-OFF
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA T)

(TOGGLE B-APPROX-X-OFF B-APPROX-X T)

(TOGGLE STUBP-IMPLIES-NOT-FOURP-OFF STUBP-IMPLIES-NOT-FOURP T)

(TOGGLE ROMP-IMPLIES-NOT-FOURP-OFF ROMP-IMPLIES-NOT-FOURP T)

(TOGGLE RAMP-IMPLIES-NOT-FOURP-OFF RAMP-IMPLIES-NOT-FOURP T)

(TOGGLE LISTP-IMPLIES-NOT-FOURP-OFF LISTP-IMPLIES-NOT-FOURP T)

(TOGGLE V-FOURP-IMPLIES-PROPERP-OFF V-FOURP-IMPLIES-PROPERP T)

(TOGGLE S-APPROX-MAKE-LIST-OFF S-APPROX-MAKE-LIST T)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-OFF NEW-MACHINE-STATE-INVARIANT T)

(TOGGLE G*1*NEW-MACHINE-STATE-INVARIANT-OFF *1*NEW-MACHINE-STATE-INVARIANT T)

(TOGGLE MEMORY-V-FOURP-OFF MEMORY-V-FOURP T)

(TOGGLE G*1*MEMORY-V-FOURP-OFF *1*MEMORY-V-FOURP T)

(TOGGLE ALL-XS-MAKE-LIST-OFF ALL-XS-MAKE-LIST T)

(TOGGLE ALL-XS-APPROXIMATES-OFF ALL-XS-APPROXIMATES T)

(TOGGLE ALL-XS-OFF ALL-XS T)

(TOGGLE G*1*ALL-XS-OFF *1*ALL-XS T)

(TOGGLE V-FOURP-OFF V-FOURP T)

(TOGGLE G*1*V-FOURP-OFF *1*V-FOURP T)

(TOGGLE FM9001-MACHINE-STATEP-P-MAP-UP-INITIALIZED-MACHINE-STATE-OFF
        FM9001-MACHINE-STATEP-P-MAP-UP-INITIALIZED-MACHINE-STATE T)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE-OFF
        XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE T)

(TOGGLE SIMULATE-RESET-CHIP-FINAL-STATE-OFF SIMULATE-RESET-CHIP-FINAL-STATE T)

(TOGGLE RESET-SEQUENCE-CHIP-1-VS-2-OFF RESET-SEQUENCE-CHIP-1-VS-2 T)

(TOGGLE RESET-SEQUENCE-CHIP-2-OFF RESET-SEQUENCE-CHIP-2 T)

(TOGGLE G*1*RESET-SEQUENCE-CHIP-2-OFF *1*RESET-SEQUENCE-CHIP-2 T)

(TOGGLE RESET-SEQUENCE-CHIP-1-OFF RESET-SEQUENCE-CHIP-1 T)

(TOGGLE G*1*RESET-SEQUENCE-CHIP-1-OFF *1*RESET-SEQUENCE-CHIP-1 T)

(TOGGLE RUN-VECTOR-CHIP-2-OFF RUN-VECTOR-CHIP-2 T)

(TOGGLE G*1*RUN-VECTOR-CHIP-2-OFF *1*RUN-VECTOR-CHIP-2 T)

(TOGGLE RUN-VECTOR-CHIP-1-OFF RUN-VECTOR-CHIP-1 T)

(TOGGLE G*1*RUN-VECTOR-CHIP-1-OFF *1*RUN-VECTOR-CHIP-1 T)

(TOGGLE RESET-VECTOR-CHIP-OFF RESET-VECTOR-CHIP T)

(TOGGLE G*1*RESET-VECTOR-CHIP-OFF *1*RESET-VECTOR-CHIP T)

(TOGGLE FM9001-STATEP-MAP-UP-FINAL-STATE-OFF FM9001-STATEP-MAP-UP-FINAL-STATE T)

(TOGGLE INSTANCE-THEOREM-OFF INSTANCE-THEOREM T)

(TOGGLE FINAL-STATE-OKP-OFF FINAL-STATE-OKP T)

(TOGGLE UNKNOWN-STATE-OKP-OFF UNKNOWN-STATE-OKP T)

(TOGGLE RESET-WORKS-OFF RESET-WORKS T)

(TOGGLE FINAL-STATE-OFF FINAL-STATE T)

(TOGGLE G*1*FINAL-STATE-OFF *1*FINAL-STATE T)

(TOGGLE INITIALIZED-MEMORY-STATE-OFF INITIALIZED-MEMORY-STATE T)

(TOGGLE G*1*INITIALIZED-MEMORY-STATE-OFF *1*INITIALIZED-MEMORY-STATE T)

(TOGGLE INITIALIZED-MACHINE-STATE-OFF INITIALIZED-MACHINE-STATE T)

(TOGGLE G*1*INITIALIZED-MACHINE-STATE-OFF *1*INITIALIZED-MACHINE-STATE T)

(TOGGLE INITIALIZED-REGFILE-OFF INITIALIZED-REGFILE T)

(TOGGLE G*1*INITIALIZED-REGFILE-OFF *1*INITIALIZED-REGFILE T)

(TOGGLE CHIP-SYSTEM-OPERATING-INPUTS-P-RESET-SEQUENCE-OFF
        CHIP-SYSTEM-OPERATING-INPUTS-P-RESET-SEQUENCE T)

(TOGGLE RESET-SEQUENCE-OFF RESET-SEQUENCE T)

(TOGGLE G*1*RESET-SEQUENCE-OFF *1*RESET-SEQUENCE T)

(TOGGLE RUN-VECTOR-OFF RUN-VECTOR T)

(TOGGLE G*1*RUN-VECTOR-OFF *1*RUN-VECTOR T)

(TOGGLE RESET-VECTOR-OFF RESET-VECTOR T)

(TOGGLE G*1*RESET-VECTOR-OFF *1*RESET-VECTOR T)

(TOGGLE FM9001-STATE-STRUCTURE-UNKNOWN-STATE-OFF
        FM9001-STATE-STRUCTURE-UNKNOWN-STATE T)

(TOGGLE CHIP-SYSTEM-INVARIANT-UNKNOWN-STATE-OFF
        CHIP-SYSTEM-INVARIANT-UNKNOWN-STATE T)

(TOGGLE UNKNOWN-STATE-OFF UNKNOWN-STATE T)

(TOGGLE G*1*UNKNOWN-STATE-OFF *1*UNKNOWN-STATE T)

(TOGGLE UNKNOWN-MEMORY-STATE-OFF UNKNOWN-MEMORY-STATE T)

(TOGGLE G*1*UNKNOWN-MEMORY-STATE-OFF *1*UNKNOWN-MEMORY-STATE T)

(TOGGLE UNKNOWN-MACHINE-STATE-OFF UNKNOWN-MACHINE-STATE T)

(TOGGLE G*1*UNKNOWN-MACHINE-STATE-OFF *1*UNKNOWN-MACHINE-STATE T)

(TOGGLE UNKNOWN-REGFILE-OFF UNKNOWN-REGFILE T)

(TOGGLE G*1*UNKNOWN-REGFILE-OFF *1*UNKNOWN-REGFILE T)

(TOGGLE COMPILE-UNCOMPILED-DEFNS-OFF COMPILE-UNCOMPILED-DEFNS T)

(TOGGLE G*1*COMPILE-UNCOMPILED-DEFNS-OFF *1*COMPILE-UNCOMPILED-DEFNS T)

(TOGGLE XS-SUFFICE-FOR-RESET-LEMMA-OFF XS-SUFFICE-FOR-RESET-LEMMA T)

(TOGGLE XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE-OFF
        XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE T)

(TOGGLE LENGTH-SIMULATE-OFF LENGTH-SIMULATE T)

(TOGGLE DOUBLET-P-EQUAL-APPROX-OFF DOUBLET-P-EQUAL-APPROX T)

(TOGGLE DOUBLET-N-SIMULATE-OFF DOUBLET-N-SIMULATE T)

(TOGGLE DOUBLET-N-SIMULATE-INDUCTION-OFF DOUBLET-N-SIMULATE-INDUCTION T)

(TOGGLE G*1*DOUBLET-N-SIMULATE-INDUCTION-OFF *1*DOUBLET-N-SIMULATE-INDUCTION T)

(TOGGLE G*1*DOUBLET-P-OFF *1*DOUBLET-P T)

(TOGGLE V-APPROX-LIST-X-X-OFF V-APPROX-LIST-X-X T)

(TOGGLE SIMULATE-MONOTONE-OFF SIMULATE-MONOTONE T)

(TOGGLE SIMULATE-MONOTONE-INDUCTION-OFF SIMULATE-MONOTONE-INDUCTION T)

(TOGGLE G*1*SIMULATE-MONOTONE-INDUCTION-OFF *1*SIMULATE-MONOTONE-INDUCTION T)

(TOGGLE S-APPROX-CADR-NTH-OFF S-APPROX-CADR-NTH T)

(TOGGLE V-APPROX-CAR-NTH-OFF V-APPROX-CAR-NTH T)

(TOGGLE NAT-LST-LST-INDUCTION-OFF NAT-LST-LST-INDUCTION T)

(TOGGLE G*1*NAT-LST-LST-INDUCTION-OFF *1*NAT-LST-LST-INDUCTION T)

(TOGGLE V-S-APPROX-LIST-OFF V-S-APPROX-LIST T)

(TOGGLE G*1*V-S-APPROX-LIST-OFF *1*V-S-APPROX-LIST T)

(TOGGLE V-APPROX-LIST-OFF V-APPROX-LIST T)

(TOGGLE G*1*V-APPROX-LIST-OFF *1*V-APPROX-LIST T)

(TOGGLE GOOD-S-PRESERVED-OFF GOOD-S-PRESERVED T)

(TOGGLE PRIMP-PRESERVES-GOOD-S-OFF PRIMP-PRESERVES-GOOD-S T)

(TOGGLE DP-RAM-16X32-PRESERVES-GOOD-S-OFF DP-RAM-16X32-PRESERVES-GOOD-S T)

(TOGGLE GOOD-S-WRITE-MEM-OFF GOOD-S-WRITE-MEM T)

(TOGGLE GOOD-S-WRITE-MEM-1-OFF GOOD-S-WRITE-MEM-1 T)

(TOGGLE GOOD-S-CONSTANT-RAM-OFF GOOD-S-CONSTANT-RAM T)

(TOGGLE VSS-PRESERVES-GOOD-S-OFF VSS-PRESERVES-GOOD-S T)

(TOGGLE VDD-PARAMETRIC-PRESERVES-GOOD-S-OFF VDD-PARAMETRIC-PRESERVES-GOOD-S T)

(TOGGLE VDD-PRESERVES-GOOD-S-OFF VDD-PRESERVES-GOOD-S T)

(TOGGLE TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S-OFF
        TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S T)

(TOGGLE TTL-TRI-OUTPUT-PRESERVES-GOOD-S-OFF TTL-TRI-OUTPUT-PRESERVES-GOOD-S T)

(TOGGLE TTL-OUTPUT-FAST-PRESERVES-GOOD-S-OFF TTL-OUTPUT-FAST-PRESERVES-GOOD-S T)

(TOGGLE TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S-OFF
        TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S T)

(TOGGLE TTL-OUTPUT-PRESERVES-GOOD-S-OFF TTL-OUTPUT-PRESERVES-GOOD-S T)

(TOGGLE TTL-INPUT-PRESERVES-GOOD-S-OFF TTL-INPUT-PRESERVES-GOOD-S T)

(TOGGLE TTL-CLK-INPUT-PRESERVES-GOOD-S-OFF TTL-CLK-INPUT-PRESERVES-GOOD-S T)

(TOGGLE TTL-BIDIRECT-PRESERVES-GOOD-S-OFF TTL-BIDIRECT-PRESERVES-GOOD-S T)

(TOGGLE PULLUP-PRESERVES-GOOD-S-OFF PULLUP-PRESERVES-GOOD-S T)

(TOGGLE T-WIRE-PRESERVES-GOOD-S-OFF T-WIRE-PRESERVES-GOOD-S T)

(TOGGLE T-BUF-PRESERVES-GOOD-S-OFF T-BUF-PRESERVES-GOOD-S T)

(TOGGLE RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S-OFF
        RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S T)

(TOGGLE ID-PRESERVES-GOOD-S-OFF ID-PRESERVES-GOOD-S T)

(TOGGLE FD1SLP-PRESERVES-GOOD-S-OFF FD1SLP-PRESERVES-GOOD-S T)

(TOGGLE FD1SP-PRESERVES-GOOD-S-OFF FD1SP-PRESERVES-GOOD-S T)

(TOGGLE FD1S-PRESERVES-GOOD-S-OFF FD1S-PRESERVES-GOOD-S T)

(TOGGLE FD1-PRESERVES-GOOD-S-OFF FD1-PRESERVES-GOOD-S T)

(TOGGLE PROCMON-PRESERVES-GOOD-S-OFF PROCMON-PRESERVES-GOOD-S T)

(TOGGLE DEL10-PRESERVES-GOOD-S-OFF DEL10-PRESERVES-GOOD-S T)

(TOGGLE DEL4-PRESERVES-GOOD-S-OFF DEL4-PRESERVES-GOOD-S T)

(TOGGLE DEL2-PRESERVES-GOOD-S-OFF DEL2-PRESERVES-GOOD-S T)

(TOGGLE B-XOR3-PRESERVES-GOOD-S-OFF B-XOR3-PRESERVES-GOOD-S T)

(TOGGLE B-XOR-PRESERVES-GOOD-S-OFF B-XOR-PRESERVES-GOOD-S T)

(TOGGLE B-OR4-PRESERVES-GOOD-S-OFF B-OR4-PRESERVES-GOOD-S T)

(TOGGLE B-OR3-PRESERVES-GOOD-S-OFF B-OR3-PRESERVES-GOOD-S T)

(TOGGLE B-OR-PRESERVES-GOOD-S-OFF B-OR-PRESERVES-GOOD-S T)

(TOGGLE B-NOT-IVAP-PRESERVES-GOOD-S-OFF B-NOT-IVAP-PRESERVES-GOOD-S T)

(TOGGLE B-NOT-B4IP-PRESERVES-GOOD-S-OFF B-NOT-B4IP-PRESERVES-GOOD-S T)

(TOGGLE B-NOT-PRESERVES-GOOD-S-OFF B-NOT-PRESERVES-GOOD-S T)

(TOGGLE B-NOR8-PRESERVES-GOOD-S-OFF B-NOR8-PRESERVES-GOOD-S T)

(TOGGLE B-NOR6-PRESERVES-GOOD-S-OFF B-NOR6-PRESERVES-GOOD-S T)

(TOGGLE B-NOR5-PRESERVES-GOOD-S-OFF B-NOR5-PRESERVES-GOOD-S T)

(TOGGLE B-NOR4-PRESERVES-GOOD-S-OFF B-NOR4-PRESERVES-GOOD-S T)

(TOGGLE B-NOR3-PRESERVES-GOOD-S-OFF B-NOR3-PRESERVES-GOOD-S T)

(TOGGLE B-NOR-PRESERVES-GOOD-S-OFF B-NOR-PRESERVES-GOOD-S T)

(TOGGLE B-NBUF-PRESERVES-GOOD-S-OFF B-NBUF-PRESERVES-GOOD-S T)

(TOGGLE B-NAND8-PRESERVES-GOOD-S-OFF B-NAND8-PRESERVES-GOOD-S T)

(TOGGLE B-NAND6-PRESERVES-GOOD-S-OFF B-NAND6-PRESERVES-GOOD-S T)

(TOGGLE B-NAND5-PRESERVES-GOOD-S-OFF B-NAND5-PRESERVES-GOOD-S T)

(TOGGLE B-NAND4-PRESERVES-GOOD-S-OFF B-NAND4-PRESERVES-GOOD-S T)

(TOGGLE B-NAND3-PRESERVES-GOOD-S-OFF B-NAND3-PRESERVES-GOOD-S T)

(TOGGLE B-NAND-PRESERVES-GOOD-S-OFF B-NAND-PRESERVES-GOOD-S T)

(TOGGLE B-IF-PRESERVES-GOOD-S-OFF B-IF-PRESERVES-GOOD-S T)

(TOGGLE B-EQUV3-PRESERVES-GOOD-S-OFF B-EQUV3-PRESERVES-GOOD-S T)

(TOGGLE B-EQUV-PRESERVES-GOOD-S-OFF B-EQUV-PRESERVES-GOOD-S T)

(TOGGLE B-AND4-PRESERVES-GOOD-S-OFF B-AND4-PRESERVES-GOOD-S T)

(TOGGLE B-AND3-PRESERVES-GOOD-S-OFF B-AND3-PRESERVES-GOOD-S T)

(TOGGLE B-AND-PRESERVES-GOOD-S-OFF B-AND-PRESERVES-GOOD-S T)

(TOGGLE AO7-PRESERVES-GOOD-S-OFF AO7-PRESERVES-GOOD-S T)

(TOGGLE AO6-PRESERVES-GOOD-S-OFF AO6-PRESERVES-GOOD-S T)

(TOGGLE AO4-PRESERVES-GOOD-S-OFF AO4-PRESERVES-GOOD-S T)

(TOGGLE AO2-PRESERVES-GOOD-S-OFF AO2-PRESERVES-GOOD-S T)

(TOGGLE GOOD-S-0-OFF GOOD-S-0 T)

(TOGGLE F-IF-PRESERVES-GOOD-S-OFF F-IF-PRESERVES-GOOD-S T)

(TOGGLE F-BUF-PRESERVES-GOOD-S-OFF F-BUF-PRESERVES-GOOD-S T)

(TOGGLE GOOD-S-COLLECT-VALUE-OFF GOOD-S-COLLECT-VALUE T)

(TOGGLE DUAL-EVAL-MONOTONE-OFF DUAL-EVAL-MONOTONE T)

(TOGGLE GOOD-S-VALUE-OFF GOOD-S-VALUE T)

(TOGGLE GOOD-S-ALIST-PAIRLIST-OFF GOOD-S-ALIST-PAIRLIST T)

(TOGGLE GOOD-S-ALIST-OFF GOOD-S-ALIST T)

(TOGGLE G*1*GOOD-S-ALIST-OFF *1*GOOD-S-ALIST T)

(TOGGLE DUAL-EVAL-MONOTONE-NO-RAM-OFF DUAL-EVAL-MONOTONE-NO-RAM T)

(TOGGLE OK-NETLISTP-REDUCTION-REWRITE-OFF OK-NETLISTP-REDUCTION-REWRITE T)

(TOGGLE OK-NETLISTP-REDUCTION-OFF OK-NETLISTP-REDUCTION T)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-COLLECT-VALUE-OFF
        S-APPROX-ALIST-IMPLIES-S-APPROX-COLLECT-VALUE T)

(TOGGLE S-APPROX-IMPLIES-S-APPROX-ALIST-OFF S-APPROX-IMPLIES-S-APPROX-ALIST T)

(TOGGLE ALISTP-DUAL-EVAL-3-OFF ALISTP-DUAL-EVAL-3 T)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-LIST-COLLECT-VALUE-OFF
        S-APPROX-ALIST-IMPLIES-S-APPROX-LIST-COLLECT-VALUE T)

(TOGGLE DOUBLE-CDR-INDUCTION-OFF DOUBLE-CDR-INDUCTION T)

(TOGGLE G*1*DOUBLE-CDR-INDUCTION-OFF *1*DOUBLE-CDR-INDUCTION T)

(TOGGLE V-APPROX-ALIST-APPEND-OFF V-APPROX-ALIST-APPEND T)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-VALUE-OFF
        S-APPROX-ALIST-IMPLIES-S-APPROX-VALUE T)

(TOGGLE ALISTP-OPENER-OFF ALISTP-OPENER T)

(TOGGLE V-APPROX-IMPLIES-V-APPROX-ALIST-OFF V-APPROX-IMPLIES-V-APPROX-ALIST T)

(TOGGLE S-APPROX-LIST-IMPLIES-S-APPROX-ALIST-OFF
        S-APPROX-LIST-IMPLIES-S-APPROX-ALIST T)

(TOGGLE S-APPROX-LIST-OFF S-APPROX-LIST T)

(TOGGLE G*1*S-APPROX-LIST-OFF *1*S-APPROX-LIST T)

(TOGGLE V-APPROX-ALIST-IMPLIES-V-APPROX-COLLECT-VALUE-OFF
        V-APPROX-ALIST-IMPLIES-V-APPROX-COLLECT-VALUE T)

(TOGGLE ALISTP-DUAL-EVAL-1-OFF ALISTP-DUAL-EVAL-1 T)

(TOGGLE ALISTP-APPEND-OFF ALISTP-APPEND T)

(TOGGLE ALISTP-PAIRLIST-OFF ALISTP-PAIRLIST T)

(TOGGLE V-APPROX-ALIST-IMPLIES-B-APPROX-VALUE-OFF
        V-APPROX-ALIST-IMPLIES-B-APPROX-VALUE T)

(TOGGLE DUAL-EVAL-MONOTONE-INDUCTION-OFF DUAL-EVAL-MONOTONE-INDUCTION T)

(TOGGLE G*1*DUAL-EVAL-MONOTONE-INDUCTION-OFF *1*DUAL-EVAL-MONOTONE-INDUCTION T)

(TOGGLE PRIMP-MONOTONE-OFF PRIMP-MONOTONE T)

(TOGGLE OK-NETLISTP-OFF OK-NETLISTP T)

(TOGGLE G*1*OK-NETLISTP-OFF *1*OK-NETLISTP T)

(TOGGLE DUAL-PORT-RAM-STATE-BODY-OFF DUAL-PORT-RAM-STATE-BODY T)

(TOGGLE G*1*DUAL-PORT-RAM-STATE-BODY-OFF *1*DUAL-PORT-RAM-STATE-BODY T)

(TOGGLE DUAL-PORT-RAM-STATE-MONOTONE-OFF DUAL-PORT-RAM-STATE-MONOTONE T)

(TOGGLE WRITE-MEM1-DOUBLE-INDUCTION-OFF WRITE-MEM1-DOUBLE-INDUCTION T)

(TOGGLE G*1*WRITE-MEM1-DOUBLE-INDUCTION-OFF *1*WRITE-MEM1-DOUBLE-INDUCTION T)

(TOGGLE WRITE-MEM1-MONOTONE-INDUCTION-OFF WRITE-MEM1-MONOTONE-INDUCTION T)

(TOGGLE G*1*WRITE-MEM1-MONOTONE-INDUCTION-OFF *1*WRITE-MEM1-MONOTONE-INDUCTION
        T)

(TOGGLE DUAL-PORT-RAM-VALUE-BODY-OFF DUAL-PORT-RAM-VALUE-BODY T)

(TOGGLE G*1*DUAL-PORT-RAM-VALUE-BODY-OFF *1*DUAL-PORT-RAM-VALUE-BODY T)

(TOGGLE V-APPROX-X-X-OFF1 V-APPROX-X-X T)

(TOGGLE READ-MEM1-MONOTONE-INDUCTION-OFF READ-MEM1-MONOTONE-INDUCTION T)

(TOGGLE G*1*READ-MEM1-MONOTONE-INDUCTION-OFF *1*READ-MEM1-MONOTONE-INDUCTION T)

(TOGGLE BVP-REV1-OFF BVP-REV1 T)

(TOGGLE VSS-MONOTONE-OFF VSS-MONOTONE T)

(TOGGLE DUAL-EVAL-VSS-STATE-OFF DUAL-EVAL-VSS-STATE T)

(TOGGLE DUAL-EVAL-VSS-VALUE-OFF DUAL-EVAL-VSS-VALUE T)

(TOGGLE VDD-PARAMETRIC-MONOTONE-OFF VDD-PARAMETRIC-MONOTONE T)

(TOGGLE DUAL-EVAL-VDD-PARAMETRIC-STATE-OFF DUAL-EVAL-VDD-PARAMETRIC-STATE T)

(TOGGLE DUAL-EVAL-VDD-PARAMETRIC-VALUE-OFF DUAL-EVAL-VDD-PARAMETRIC-VALUE T)

(TOGGLE VDD-MONOTONE-OFF VDD-MONOTONE T)

(TOGGLE DUAL-EVAL-VDD-STATE-OFF DUAL-EVAL-VDD-STATE T)

(TOGGLE DUAL-EVAL-VDD-VALUE-OFF DUAL-EVAL-VDD-VALUE T)

(TOGGLE TTL-TRI-OUTPUT-FAST-MONOTONE-OFF TTL-TRI-OUTPUT-FAST-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE-OFF
        DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE T)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE-OFF
        DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE T)

(TOGGLE TTL-TRI-OUTPUT-MONOTONE-OFF TTL-TRI-OUTPUT-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-STATE-OFF DUAL-EVAL-TTL-TRI-OUTPUT-STATE T)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-VALUE-OFF DUAL-EVAL-TTL-TRI-OUTPUT-VALUE T)

(TOGGLE TTL-OUTPUT-FAST-MONOTONE-OFF TTL-OUTPUT-FAST-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-FAST-STATE-OFF DUAL-EVAL-TTL-OUTPUT-FAST-STATE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-FAST-VALUE-OFF DUAL-EVAL-TTL-OUTPUT-FAST-VALUE T)

(TOGGLE TTL-OUTPUT-PARAMETRIC-MONOTONE-OFF TTL-OUTPUT-PARAMETRIC-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE-OFF
        DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE-OFF
        DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE T)

(TOGGLE TTL-OUTPUT-MONOTONE-OFF TTL-OUTPUT-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-STATE-OFF DUAL-EVAL-TTL-OUTPUT-STATE T)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-VALUE-OFF DUAL-EVAL-TTL-OUTPUT-VALUE T)

(TOGGLE TTL-INPUT-MONOTONE-OFF TTL-INPUT-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-INPUT-STATE-OFF DUAL-EVAL-TTL-INPUT-STATE T)

(TOGGLE DUAL-EVAL-TTL-INPUT-VALUE-OFF DUAL-EVAL-TTL-INPUT-VALUE T)

(TOGGLE TTL-CLK-INPUT-MONOTONE-OFF TTL-CLK-INPUT-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-CLK-INPUT-STATE-OFF DUAL-EVAL-TTL-CLK-INPUT-STATE T)

(TOGGLE DUAL-EVAL-TTL-CLK-INPUT-VALUE-OFF DUAL-EVAL-TTL-CLK-INPUT-VALUE T)

(TOGGLE TTL-BIDIRECT-MONOTONE-OFF TTL-BIDIRECT-MONOTONE T)

(TOGGLE DUAL-EVAL-TTL-BIDIRECT-STATE-OFF DUAL-EVAL-TTL-BIDIRECT-STATE T)

(TOGGLE DUAL-EVAL-TTL-BIDIRECT-VALUE-OFF DUAL-EVAL-TTL-BIDIRECT-VALUE T)

(TOGGLE PULLUP-MONOTONE-OFF PULLUP-MONOTONE T)

(TOGGLE DUAL-EVAL-PULLUP-STATE-OFF DUAL-EVAL-PULLUP-STATE T)

(TOGGLE DUAL-EVAL-PULLUP-VALUE-OFF DUAL-EVAL-PULLUP-VALUE T)

(TOGGLE T-WIRE-MONOTONE-OFF T-WIRE-MONOTONE T)

(TOGGLE DUAL-EVAL-T-WIRE-STATE-OFF DUAL-EVAL-T-WIRE-STATE T)

(TOGGLE DUAL-EVAL-T-WIRE-VALUE-OFF DUAL-EVAL-T-WIRE-VALUE T)

(TOGGLE T-BUF-MONOTONE-OFF T-BUF-MONOTONE T)

(TOGGLE DUAL-EVAL-T-BUF-STATE-OFF DUAL-EVAL-T-BUF-STATE T)

(TOGGLE DUAL-EVAL-T-BUF-VALUE-OFF DUAL-EVAL-T-BUF-VALUE T)

(TOGGLE RAM-ENABLE-CIRCUIT-MONOTONE-OFF RAM-ENABLE-CIRCUIT-MONOTONE T)

(TOGGLE DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE-OFF
        DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE T)

(TOGGLE DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE-OFF
        DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE T)

(TOGGLE ID-MONOTONE-OFF ID-MONOTONE T)

(TOGGLE DUAL-EVAL-ID-STATE-OFF DUAL-EVAL-ID-STATE T)

(TOGGLE DUAL-EVAL-ID-VALUE-OFF DUAL-EVAL-ID-VALUE T)

(TOGGLE FD1SLP-MONOTONE-OFF FD1SLP-MONOTONE T)

(TOGGLE DUAL-EVAL-FD1SLP-STATE-OFF DUAL-EVAL-FD1SLP-STATE T)

(TOGGLE DUAL-EVAL-FD1SLP-VALUE-OFF DUAL-EVAL-FD1SLP-VALUE T)

(TOGGLE FD1SP-MONOTONE-OFF FD1SP-MONOTONE T)

(TOGGLE DUAL-EVAL-FD1SP-STATE-OFF DUAL-EVAL-FD1SP-STATE T)

(TOGGLE DUAL-EVAL-FD1SP-VALUE-OFF DUAL-EVAL-FD1SP-VALUE T)

(TOGGLE FD1S-MONOTONE-OFF FD1S-MONOTONE T)

(TOGGLE DUAL-EVAL-FD1S-STATE-OFF DUAL-EVAL-FD1S-STATE T)

(TOGGLE DUAL-EVAL-FD1S-VALUE-OFF DUAL-EVAL-FD1S-VALUE T)

(TOGGLE FD1-MONOTONE-OFF FD1-MONOTONE T)

(TOGGLE DUAL-EVAL-FD1-STATE-OFF DUAL-EVAL-FD1-STATE T)

(TOGGLE DUAL-EVAL-FD1-VALUE-OFF DUAL-EVAL-FD1-VALUE T)

(TOGGLE PROCMON-MONOTONE-OFF PROCMON-MONOTONE T)

(TOGGLE DUAL-EVAL-PROCMON-STATE-OFF DUAL-EVAL-PROCMON-STATE T)

(TOGGLE DUAL-EVAL-PROCMON-VALUE-OFF DUAL-EVAL-PROCMON-VALUE T)

(TOGGLE DEL10-MONOTONE-OFF DEL10-MONOTONE T)

(TOGGLE DUAL-EVAL-DEL10-STATE-OFF DUAL-EVAL-DEL10-STATE T)

(TOGGLE DUAL-EVAL-DEL10-VALUE-OFF DUAL-EVAL-DEL10-VALUE T)

(TOGGLE DEL4-MONOTONE-OFF DEL4-MONOTONE T)

(TOGGLE DUAL-EVAL-DEL4-STATE-OFF DUAL-EVAL-DEL4-STATE T)

(TOGGLE DUAL-EVAL-DEL4-VALUE-OFF DUAL-EVAL-DEL4-VALUE T)

(TOGGLE DEL2-MONOTONE-OFF DEL2-MONOTONE T)

(TOGGLE DUAL-EVAL-DEL2-STATE-OFF DUAL-EVAL-DEL2-STATE T)

(TOGGLE DUAL-EVAL-DEL2-VALUE-OFF DUAL-EVAL-DEL2-VALUE T)

(TOGGLE B-XOR3-MONOTONE-OFF B-XOR3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-XOR3-STATE-OFF DUAL-EVAL-B-XOR3-STATE T)

(TOGGLE DUAL-EVAL-B-XOR3-VALUE-OFF DUAL-EVAL-B-XOR3-VALUE T)

(TOGGLE B-XOR-MONOTONE-OFF B-XOR-MONOTONE T)

(TOGGLE DUAL-EVAL-B-XOR-STATE-OFF DUAL-EVAL-B-XOR-STATE T)

(TOGGLE DUAL-EVAL-B-XOR-VALUE-OFF DUAL-EVAL-B-XOR-VALUE T)

(TOGGLE B-OR4-MONOTONE-OFF B-OR4-MONOTONE T)

(TOGGLE DUAL-EVAL-B-OR4-STATE-OFF DUAL-EVAL-B-OR4-STATE T)

(TOGGLE DUAL-EVAL-B-OR4-VALUE-OFF DUAL-EVAL-B-OR4-VALUE T)

(TOGGLE B-OR3-MONOTONE-OFF B-OR3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-OR3-STATE-OFF DUAL-EVAL-B-OR3-STATE T)

(TOGGLE DUAL-EVAL-B-OR3-VALUE-OFF DUAL-EVAL-B-OR3-VALUE T)

(TOGGLE B-OR-MONOTONE-OFF B-OR-MONOTONE T)

(TOGGLE DUAL-EVAL-B-OR-STATE-OFF DUAL-EVAL-B-OR-STATE T)

(TOGGLE DUAL-EVAL-B-OR-VALUE-OFF DUAL-EVAL-B-OR-VALUE T)

(TOGGLE B-NOT-IVAP-MONOTONE-OFF B-NOT-IVAP-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOT-IVAP-STATE-OFF DUAL-EVAL-B-NOT-IVAP-STATE T)

(TOGGLE DUAL-EVAL-B-NOT-IVAP-VALUE-OFF DUAL-EVAL-B-NOT-IVAP-VALUE T)

(TOGGLE B-NOT-B4IP-MONOTONE-OFF B-NOT-B4IP-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOT-B4IP-STATE-OFF DUAL-EVAL-B-NOT-B4IP-STATE T)

(TOGGLE DUAL-EVAL-B-NOT-B4IP-VALUE-OFF DUAL-EVAL-B-NOT-B4IP-VALUE T)

(TOGGLE B-NOT-MONOTONE-OFF B-NOT-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOT-STATE-OFF DUAL-EVAL-B-NOT-STATE T)

(TOGGLE DUAL-EVAL-B-NOT-VALUE-OFF DUAL-EVAL-B-NOT-VALUE T)

(TOGGLE B-NOR8-MONOTONE-OFF B-NOR8-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR8-STATE-OFF DUAL-EVAL-B-NOR8-STATE T)

(TOGGLE DUAL-EVAL-B-NOR8-VALUE-OFF DUAL-EVAL-B-NOR8-VALUE T)

(TOGGLE B-NOR6-MONOTONE-OFF B-NOR6-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR6-STATE-OFF DUAL-EVAL-B-NOR6-STATE T)

(TOGGLE DUAL-EVAL-B-NOR6-VALUE-OFF DUAL-EVAL-B-NOR6-VALUE T)

(TOGGLE B-NOR5-MONOTONE-OFF B-NOR5-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR5-STATE-OFF DUAL-EVAL-B-NOR5-STATE T)

(TOGGLE DUAL-EVAL-B-NOR5-VALUE-OFF DUAL-EVAL-B-NOR5-VALUE T)

(TOGGLE B-NOR4-MONOTONE-OFF B-NOR4-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR4-STATE-OFF DUAL-EVAL-B-NOR4-STATE T)

(TOGGLE DUAL-EVAL-B-NOR4-VALUE-OFF DUAL-EVAL-B-NOR4-VALUE T)

(TOGGLE B-NOR3-MONOTONE-OFF B-NOR3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR3-STATE-OFF DUAL-EVAL-B-NOR3-STATE T)

(TOGGLE DUAL-EVAL-B-NOR3-VALUE-OFF DUAL-EVAL-B-NOR3-VALUE T)

(TOGGLE B-NOR-MONOTONE-OFF B-NOR-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NOR-STATE-OFF DUAL-EVAL-B-NOR-STATE T)

(TOGGLE DUAL-EVAL-B-NOR-VALUE-OFF DUAL-EVAL-B-NOR-VALUE T)

(TOGGLE B-NBUF-MONOTONE-OFF B-NBUF-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NBUF-STATE-OFF DUAL-EVAL-B-NBUF-STATE T)

(TOGGLE DUAL-EVAL-B-NBUF-VALUE-OFF DUAL-EVAL-B-NBUF-VALUE T)

(TOGGLE B-NAND8-MONOTONE-OFF B-NAND8-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND8-STATE-OFF DUAL-EVAL-B-NAND8-STATE T)

(TOGGLE DUAL-EVAL-B-NAND8-VALUE-OFF DUAL-EVAL-B-NAND8-VALUE T)

(TOGGLE B-NAND6-MONOTONE-OFF B-NAND6-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND6-STATE-OFF DUAL-EVAL-B-NAND6-STATE T)

(TOGGLE DUAL-EVAL-B-NAND6-VALUE-OFF DUAL-EVAL-B-NAND6-VALUE T)

(TOGGLE B-NAND5-MONOTONE-OFF B-NAND5-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND5-STATE-OFF DUAL-EVAL-B-NAND5-STATE T)

(TOGGLE DUAL-EVAL-B-NAND5-VALUE-OFF DUAL-EVAL-B-NAND5-VALUE T)

(TOGGLE B-NAND4-MONOTONE-OFF B-NAND4-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND4-STATE-OFF DUAL-EVAL-B-NAND4-STATE T)

(TOGGLE DUAL-EVAL-B-NAND4-VALUE-OFF DUAL-EVAL-B-NAND4-VALUE T)

(TOGGLE B-NAND3-MONOTONE-OFF B-NAND3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND3-STATE-OFF DUAL-EVAL-B-NAND3-STATE T)

(TOGGLE DUAL-EVAL-B-NAND3-VALUE-OFF DUAL-EVAL-B-NAND3-VALUE T)

(TOGGLE B-NAND-MONOTONE-OFF B-NAND-MONOTONE T)

(TOGGLE DUAL-EVAL-B-NAND-STATE-OFF DUAL-EVAL-B-NAND-STATE T)

(TOGGLE DUAL-EVAL-B-NAND-VALUE-OFF DUAL-EVAL-B-NAND-VALUE T)

(TOGGLE B-IF-MONOTONE-OFF B-IF-MONOTONE T)

(TOGGLE DUAL-EVAL-B-IF-STATE-OFF DUAL-EVAL-B-IF-STATE T)

(TOGGLE DUAL-EVAL-B-IF-VALUE-OFF DUAL-EVAL-B-IF-VALUE T)

(TOGGLE B-EQUV3-MONOTONE-OFF B-EQUV3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-EQUV3-STATE-OFF DUAL-EVAL-B-EQUV3-STATE T)

(TOGGLE DUAL-EVAL-B-EQUV3-VALUE-OFF DUAL-EVAL-B-EQUV3-VALUE T)

(TOGGLE B-EQUV-MONOTONE-OFF B-EQUV-MONOTONE T)

(TOGGLE DUAL-EVAL-B-EQUV-STATE-OFF DUAL-EVAL-B-EQUV-STATE T)

(TOGGLE DUAL-EVAL-B-EQUV-VALUE-OFF DUAL-EVAL-B-EQUV-VALUE T)

(TOGGLE B-AND4-MONOTONE-OFF B-AND4-MONOTONE T)

(TOGGLE DUAL-EVAL-B-AND4-STATE-OFF DUAL-EVAL-B-AND4-STATE T)

(TOGGLE DUAL-EVAL-B-AND4-VALUE-OFF DUAL-EVAL-B-AND4-VALUE T)

(TOGGLE B-AND3-MONOTONE-OFF B-AND3-MONOTONE T)

(TOGGLE DUAL-EVAL-B-AND3-STATE-OFF DUAL-EVAL-B-AND3-STATE T)

(TOGGLE DUAL-EVAL-B-AND3-VALUE-OFF DUAL-EVAL-B-AND3-VALUE T)

(TOGGLE B-AND-MONOTONE-OFF B-AND-MONOTONE T)

(TOGGLE DUAL-EVAL-B-AND-STATE-OFF DUAL-EVAL-B-AND-STATE T)

(TOGGLE DUAL-EVAL-B-AND-VALUE-OFF DUAL-EVAL-B-AND-VALUE T)

(TOGGLE AO7-MONOTONE-OFF AO7-MONOTONE T)

(TOGGLE DUAL-EVAL-AO7-STATE-OFF DUAL-EVAL-AO7-STATE T)

(TOGGLE DUAL-EVAL-AO7-VALUE-OFF DUAL-EVAL-AO7-VALUE T)

(TOGGLE AO6-MONOTONE-OFF AO6-MONOTONE T)

(TOGGLE DUAL-EVAL-AO6-STATE-OFF DUAL-EVAL-AO6-STATE T)

(TOGGLE DUAL-EVAL-AO6-VALUE-OFF DUAL-EVAL-AO6-VALUE T)

(TOGGLE AO4-MONOTONE-OFF AO4-MONOTONE T)

(TOGGLE DUAL-EVAL-AO4-STATE-OFF DUAL-EVAL-AO4-STATE T)

(TOGGLE DUAL-EVAL-AO4-VALUE-OFF DUAL-EVAL-AO4-VALUE T)

(TOGGLE AO2-MONOTONE-OFF AO2-MONOTONE T)

(TOGGLE DUAL-EVAL-AO2-STATE-OFF DUAL-EVAL-AO2-STATE T)

(TOGGLE DUAL-EVAL-AO2-VALUE-OFF DUAL-EVAL-AO2-VALUE T)

(TOGGLE FOURP-IMPLIES-S-APPROX-IS-B-APPROX-OFF1
        FOURP-IMPLIES-S-APPROX-IS-B-APPROX T)

(TOGGLE FOURP-F-IF-OFF FOURP-F-IF T)

(TOGGLE FOURP-F-BUF-OFF FOURP-F-BUF T)

(TOGGLE F-BUF-TYPE-SET-OFF F-BUF-TYPE-SET T)

(TOGGLE S-APPROX-IMPLIES-B-APPROX-OFF S-APPROX-IMPLIES-B-APPROX T)

(TOGGLE DUAL-EVAL-2-PRIMP-OFF DUAL-EVAL-2-PRIMP T)

(TOGGLE DUAL-EVAL-0-PRIMP-OFF DUAL-EVAL-0-PRIMP T)

(TOGGLE F-PULLUP-MONOTONE-OFF F-PULLUP-MONOTONE T)

(TOGGLE FT-WIRE-MONOTONE-OFF FT-WIRE-MONOTONE T)

(TOGGLE FT-BUF-MONOTONE-OFF FT-BUF-MONOTONE T)

(TOGGLE F-IF-MONOTONE-OFF F-IF-MONOTONE T)

(TOGGLE F-EQUV3-MONOTONE-OFF F-EQUV3-MONOTONE T)

(TOGGLE F-XOR3-MONOTONE-OFF F-XOR3-MONOTONE T)

(TOGGLE F-EQUV-MONOTONE-OFF F-EQUV-MONOTONE T)

(TOGGLE F-XOR-MONOTONE-OFF F-XOR-MONOTONE T)

(TOGGLE F-NOR8-MONOTONE-OFF F-NOR8-MONOTONE T)

(TOGGLE F-NOR6-MONOTONE-OFF F-NOR6-MONOTONE T)

(TOGGLE F-NOR5-MONOTONE-OFF F-NOR5-MONOTONE T)

(TOGGLE F-NOR4-MONOTONE-OFF F-NOR4-MONOTONE T)

(TOGGLE F-NOR3-MONOTONE-OFF F-NOR3-MONOTONE T)

(TOGGLE F-NOR-MONOTONE-OFF F-NOR-MONOTONE T)

(TOGGLE F-OR4-MONOTONE-OFF F-OR4-MONOTONE T)

(TOGGLE F-OR3-MONOTONE-OFF F-OR3-MONOTONE T)

(TOGGLE F-OR-MONOTONE-OFF F-OR-MONOTONE T)

(TOGGLE F-NAND8-MONOTONE-OFF F-NAND8-MONOTONE T)

(TOGGLE F-NAND6-MONOTONE-OFF F-NAND6-MONOTONE T)

(TOGGLE F-NAND5-MONOTONE-OFF F-NAND5-MONOTONE T)

(TOGGLE F-NAND4-MONOTONE-OFF F-NAND4-MONOTONE T)

(TOGGLE F-NAND3-MONOTONE-OFF F-NAND3-MONOTONE T)

(TOGGLE F-NAND-MONOTONE-OFF F-NAND-MONOTONE T)

(TOGGLE F-NOT-MONOTONE-OFF F-NOT-MONOTONE T)

(TOGGLE F-AND4-MONOTONE-OFF F-AND4-MONOTONE T)

(TOGGLE F-AND3-MONOTONE-OFF F-AND3-MONOTONE T)

(TOGGLE F-AND-MONOTONE-OFF F-AND-MONOTONE T)

(TOGGLE F-BUF-MONOTONE-OFF F-BUF-MONOTONE T)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-3-OFF
        MONOTONICITY-PROPERTY-CONSEQUENCE-3 T)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-2-OFF
        MONOTONICITY-PROPERTY-CONSEQUENCE-2 T)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-1-OFF
        MONOTONICITY-PROPERTY-CONSEQUENCE-1 T)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-0-OFF
        MONOTONICITY-PROPERTY-CONSEQUENCE-0 T)

(TOGGLE G*1*MONOTONICITY-PROPERTY-OFF *1*MONOTONICITY-PROPERTY T)

(TOGGLE S-APPROX-ALIST-OFF S-APPROX-ALIST T)

(TOGGLE G*1*S-APPROX-ALIST-OFF *1*S-APPROX-ALIST T)

(TOGGLE V-APPROX-ALIST-OFF V-APPROX-ALIST T)

(TOGGLE G*1*V-APPROX-ALIST-OFF *1*V-APPROX-ALIST T)

(TOGGLE S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL-OFF1
        S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL T)

(TOGGLE S-KNOWNP-OFF1 S-KNOWNP T)

(TOGGLE G*1*S-KNOWNP-OFF *1*S-KNOWNP T)

(TOGGLE GOOD-S-OFF GOOD-S T)

(TOGGLE G*1*GOOD-S-OFF *1*GOOD-S T)

(TOGGLE S-APPROX-X-X-OFF S-APPROX-X-X T)

(TOGGLE S-APPROX-OFF1 S-APPROX T)

(TOGGLE G*1*S-APPROX-OFF *1*S-APPROX T)

(TOGGLE MEM-WIDTH-OFF1 MEM-WIDTH T)

(TOGGLE G*1*MEM-WIDTH-OFF1 *1*MEM-WIDTH T)

(TOGGLE V-KNOWNP-IMPLIES-V-APPROX-IS-EQUAL-OFF
        V-KNOWNP-IMPLIES-V-APPROX-IS-EQUAL T)

(TOGGLE V-KNOWNP-OFF1 V-KNOWNP T)

(TOGGLE G*1*V-KNOWNP-OFF *1*V-KNOWNP T)

(TOGGLE V-APPROX-OFF1 V-APPROX T)

(TOGGLE G*1*V-APPROX-OFF *1*V-APPROX T)

(TOGGLE G*1*B-APPROX-OFF *1*B-APPROX T)

(TOGGLE B-KNOWNP-COMPOUND-RECOGNIZER-OFF B-KNOWNP-COMPOUND-RECOGNIZER T)

(TOGGLE MONOTONICITY-PROPERTY-ON MONOTONICITY-PROPERTY NIL)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-0-ON MONOTONICITY-PROPERTY-OPENER-0 NIL)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-1-ON MONOTONICITY-PROPERTY-OPENER-1 NIL)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-2-ON MONOTONICITY-PROPERTY-OPENER-2 NIL)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-3-ON MONOTONICITY-PROPERTY-OPENER-3 NIL)

(TOGGLE F-BUF-ON F-BUF NIL)

(TOGGLE F-AND-ON F-AND NIL)

(TOGGLE F-AND3-ON F-AND3 NIL)

(TOGGLE F-AND4-ON F-AND4 NIL)

(TOGGLE F-NOT-ON F-NOT NIL)

(TOGGLE F-NAND-ON F-NAND NIL)

(TOGGLE F-NAND3-ON F-NAND3 NIL)

(TOGGLE F-NAND4-ON F-NAND4 NIL)

(TOGGLE F-NAND5-ON F-NAND5 NIL)

(TOGGLE F-NAND6-ON F-NAND6 NIL)

(TOGGLE F-NAND8-ON F-NAND8 NIL)

(TOGGLE F-OR-ON F-OR NIL)

(TOGGLE F-OR3-ON F-OR3 NIL)

(TOGGLE F-OR4-ON F-OR4 NIL)

(TOGGLE F-NOR-ON F-NOR NIL)

(TOGGLE F-NOR3-ON F-NOR3 NIL)

(TOGGLE F-NOR4-ON F-NOR4 NIL)

(TOGGLE F-NOR5-ON F-NOR5 NIL)

(TOGGLE F-NOR6-ON F-NOR6 NIL)

(TOGGLE F-NOR8-ON F-NOR8 NIL)

(TOGGLE F-XOR-ON F-XOR NIL)

(TOGGLE F-XOR3-ON F-XOR3 NIL)

(TOGGLE F-EQUV-ON F-EQUV NIL)

(TOGGLE F-EQUV3-ON F-EQUV3 NIL)

(TOGGLE F-IF-ON F-IF NIL)

(TOGGLE FT-BUF-ON FT-BUF NIL)

(TOGGLE FT-WIRE-ON FT-WIRE NIL)

(TOGGLE F-PULLUP-ON F-PULLUP NIL)

(TOGGLE BVP-REVERSE-ON BVP-REVERSE NIL)

(TOGGLE V-APPROX-BVP-ON V-APPROX-BVP NIL)

(TOGGLE READ-MEM1-MONOTONE-ON READ-MEM1-MONOTONE NIL)

(TOGGLE BVP-IMPLIES-V-KNOWNP-ON BVP-IMPLIES-V-KNOWNP NIL)

(TOGGLE V-APPROX-IMPLIES-B-APPROX-NTH-ON V-APPROX-IMPLIES-B-APPROX-NTH NIL)

(TOGGLE G*1*B-KNOWNP-ON1 *1*B-KNOWNP NIL)

(TOGGLE V-APPROX-IMPLIES-SUBRANGES-EQUAL-ON V-APPROX-IMPLIES-SUBRANGES-EQUAL
        NIL)

(TOGGLE V-APPROX-BVP-SUBRANGE-ON V-APPROX-BVP-SUBRANGE NIL)

(TOGGLE V-APPROX-MAKE-LIST-X-ON V-APPROX-MAKE-LIST-X NIL)

(TOGGLE READ-MEM-MONOTONE-ON READ-MEM-MONOTONE NIL)

(TOGGLE EQUAL-LENGTH-READ-MEM1-ON EQUAL-LENGTH-READ-MEM1 NIL)

(TOGGLE EQUAL-LENGTH-READ-MEM-ON EQUAL-LENGTH-READ-MEM NIL)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM1-ON
        S-APPROX-IMPLIES-PROPERP-READ-MEM1 NIL)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM-ON S-APPROX-IMPLIES-PROPERP-READ-MEM
        NIL)

(TOGGLE DUAL-PORT-RAM-VALUE-MONOTONE-ON DUAL-PORT-RAM-VALUE-MONOTONE NIL)

(TOGGLE EVAL$-APPEND-ON EVAL$-APPEND NIL)

(TOGGLE EVAL$-PAIRLIST-CONS-ON EVAL$-PAIRLIST-CONS NIL)

(TOGGLE EVAL$-APPEND-2-ON EVAL$-APPEND-2 NIL)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1-ON
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1 NIL)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2-ON
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2 NIL)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3-ON
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3 NIL)

(TOGGLE DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY-ON
        DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY NIL)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-ON DUAL-APPLY-VALUE-DP-RAM-16X32 NIL)

(TOGGLE DP-RAM-16X32-MONOTONE-VALUE-ON DP-RAM-16X32-MONOTONE-VALUE NIL)

(TOGGLE BVP-OFF2 BVP T)

(TOGGLE S-APPROX-OPENER-ON S-APPROX-OPENER NIL)

(TOGGLE V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T-ON
        V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T NIL)

(TOGGLE WRITE-MEM1-OPENER-ON WRITE-MEM1-OPENER NIL)

(TOGGLE WRITE-MEM1-MONOTONE-ON WRITE-MEM1-MONOTONE NIL)

(TOGGLE WRITE-MEM-MONOTONE-ON WRITE-MEM-MONOTONE NIL)

(TOGGLE V-APPROX-LENGTH-ON V-APPROX-LENGTH NIL)

(TOGGLE S-APPROX-WRITE-MEM1-ID-ON S-APPROX-WRITE-MEM1-ID NIL)

(TOGGLE S-APPROX-WRITE-MEM-ID-ON S-APPROX-WRITE-MEM-ID NIL)

(TOGGLE S-APPROX-CONSTANT-RAM-X-ID-ON S-APPROX-CONSTANT-RAM-X-ID NIL)

(TOGGLE S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X-ON
        S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X NIL)

(TOGGLE V-APPROX-PRESERVES-LENGTH-ON V-APPROX-PRESERVES-LENGTH NIL)

(TOGGLE V-APPROX-SUBRANGE-ON V-APPROX-SUBRANGE NIL)

(TOGGLE MEM-WIDTH-NON-ZERO-ON MEM-WIDTH-NON-ZERO NIL)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3-ON
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3 NIL)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-ON
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1 NIL)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM-ON S-APPROX-CONSTANT-RAM-X-WRITE-MEM
        NIL)

(TOGGLE V-APPROX-PRESERVES-PROPERP-ON V-APPROX-PRESERVES-PROPERP NIL)

(TOGGLE MEM-WIDTH-LINEAR-FACTS-ON MEM-WIDTH-LINEAR-FACTS NIL)

(TOGGLE DUAL-PORT-RAM-STATE-MONOTONE-REWRITE-ON
        DUAL-PORT-RAM-STATE-MONOTONE-REWRITE NIL)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1-ON
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1 NIL)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2-ON
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2 NIL)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3-ON
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3 NIL)

(TOGGLE DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY-ON
        DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY NIL)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-ON DUAL-APPLY-STATE-DP-RAM-16X32 NIL)

(TOGGLE DP-RAM-16X32-MONOTONE-STATE-ON DP-RAM-16X32-MONOTONE-STATE NIL)

(TOGGLE DP-RAM-16X32-MONOTONE-ON DP-RAM-16X32-MONOTONE NIL)

(TOGGLE OPEN-NTH-OFF1 OPEN-NTH T)

(TOGGLE DOUBLET-P-ON DOUBLET-P NIL)

(TOGGLE FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP-ON
        FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP NIL)

(TOGGLE MAP-DOWN-INVERTS-MAP-UP-ON MAP-DOWN-INVERTS-MAP-UP NIL)

(TOGGLE B-KNOWNP-ON1 B-KNOWNP NIL)

(TOGGLE B-APPROX-ON1 B-APPROX NIL)

(TOGGLE CANCEL-CONSTANTS-ILESSP-ON CANCEL-CONSTANTS-ILESSP NIL)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-2-ON CANCEL-CONSTANTS-ILESSP-LEMMA-2 NIL)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-1-ON CANCEL-CONSTANTS-ILESSP-LEMMA-1 NIL)

(TOGGLE ILESSP-ADD1-IPLUS-ON ILESSP-ADD1-IPLUS NIL)

(TOGGLE ILESSP-ADD1-ON ILESSP-ADD1 NIL)

(TOGGLE CANCEL-CONSTANTS-EQUAL-ON CANCEL-CONSTANTS-EQUAL NIL)

(TOGGLE CANCEL-CONSTANTS-EQUAL-LEMMA-ON CANCEL-CONSTANTS-EQUAL-LEMMA NIL)

(TOGGLE IPLUS-CONSTANTS-ON IPLUS-CONSTANTS NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY-ON
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY NIL)

(TOGGLE
CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-ON
CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
NIL)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-ON
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED NIL)

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-ON CANCEL-INEG-TERMS-FROM-INEQUALITY
        NIL)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-ON
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY NIL)

(TOGGLE MAKE-CANCEL-INEG-TERMS-INEQUALITY-ON MAKE-CANCEL-INEG-TERMS-INEQUALITY
        NIL)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-INEQUALITY-ON
        *1*MAKE-CANCEL-INEG-TERMS-INEQUALITY NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY-ON
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY NIL)

(TOGGLE IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS-ON
        IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS NIL)

(TOGGLE EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS-ON EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS
        NIL)

(TOGGLE EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS-ON EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS
        NIL)

(TOGGLE
    CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-ON
    CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED
    NIL)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-ON
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED NIL)

(TOGGLE CANCEL-INEG-TERMS-FROM-EQUALITY-ON CANCEL-INEG-TERMS-FROM-EQUALITY NIL)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-ON
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY NIL)

(TOGGLE MAKE-CANCEL-INEG-TERMS-EQUALITY-ON MAKE-CANCEL-INEG-TERMS-EQUALITY NIL)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-EQUALITY-ON
        *1*MAKE-CANCEL-INEG-TERMS-EQUALITY NIL)

(TOGGLE G*1*IPLUS-OR-INEG-TERM-ON *1*IPLUS-OR-INEG-TERM NIL)

(TOGGLE G*1*REMOVE-INEGS-ON *1*REMOVE-INEGS NIL)

(TOGGLE SPLIT-OUT-INEG-TERMS-ON SPLIT-OUT-INEG-TERMS NIL)

(TOGGLE G*1*SPLIT-OUT-INEG-TERMS-ON *1*SPLIT-OUT-INEG-TERMS NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0-ON
        CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0 NIL)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR-ON
        CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR NIL)

(TOGGLE CANCEL-FACTORS-ILESSP-0-ON CANCEL-FACTORS-ILESSP-0 NIL)

(TOGGLE G*1*CANCEL-FACTORS-ILESSP-0-ON *1*CANCEL-FACTORS-ILESSP-0 NIL)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-ON CONJOIN-INEQUALITIES-WITH-0 NIL)

(TOGGLE G*1*CONJOIN-INEQUALITIES-WITH-0-ON *1*CONJOIN-INEQUALITIES-WITH-0 NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-0-ON CORRECTNESS-OF-CANCEL-FACTORS-0 NIL)

(TOGGLE SOME-EVAL$S-TO-0-ELIMINATOR-ON SOME-EVAL$S-TO-0-ELIMINATOR NIL)

(TOGGLE SOME-EVAL$S-TO-0-APPEND-ON SOME-EVAL$S-TO-0-APPEND NIL)

(TOGGLE EVAL$-DISJOIN-EQUALITIES-WITH-0-ON EVAL$-DISJOIN-EQUALITIES-WITH-0 NIL)

(TOGGLE SOME-EVAL$S-TO-0-ON SOME-EVAL$S-TO-0 NIL)

(TOGGLE G*1*SOME-EVAL$S-TO-0-ON *1*SOME-EVAL$S-TO-0 NIL)

(TOGGLE CANCEL-FACTORS-0-ON CANCEL-FACTORS-0 NIL)

(TOGGLE G*1*CANCEL-FACTORS-0-ON *1*CANCEL-FACTORS-0 NIL)

(TOGGLE DISJOIN-EQUALITIES-WITH-0-ON DISJOIN-EQUALITIES-WITH-0 NIL)

(TOGGLE G*1*DISJOIN-EQUALITIES-WITH-0-ON *1*DISJOIN-EQUALITIES-WITH-0 NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS-ON
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS NIL)

(TOGGLE EQUAL-FIX-INT-TO-ILESSP-ON EQUAL-FIX-INT-TO-ILESSP NIL)

(TOGGLE EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA-ON
        EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA NIL)

(TOGGLE EVAL$-LIST-BAGINT-0-FOR-ILESSP-ON EVAL$-LIST-BAGINT-0-FOR-ILESSP NIL)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2-ON
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2 NIL)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1-ON
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1 NIL)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ON MEMBER-0-ITIMES-FACTORS-YIELDS-0
        NIL)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2-ON
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2 NIL)

(TOGGLE ILESSP-ZERO-IMPLIES-NOT-EQUAL-ON ILESSP-ZERO-IMPLIES-NOT-EQUAL NIL)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1-ON
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1 NIL)

(TOGGLE ZERO-ILESSP-IMPLIES-NOT-EQUAL-ON ZERO-ILESSP-IMPLIES-NOT-EQUAL NIL)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-ON
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF NIL)

(TOGGLE BAGINT-SINGLETON-ON BAGINT-SINGLETON NIL)

(TOGGLE CANCEL-ITIMES-ILESSP-FACTORS-ON CANCEL-ITIMES-ILESSP-FACTORS NIL)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-FACTORS-ON *1*CANCEL-ITIMES-ILESSP-FACTORS NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-FACTORS-ON
        CORRECTNESS-OF-CANCEL-ITIMES-FACTORS NIL)

(TOGGLE MEMBER-0-EVAL$-LIST-ON MEMBER-0-EVAL$-LIST NIL)

(TOGGLE MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0-ON
        MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0 NIL)

(TOGGLE CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS-ON
        CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS NIL)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-EXPANDED-ON *1*CANCEL-ITIMES-FACTORS-EXPANDED
        NIL)

(TOGGLE CANCEL-ITIMES-FACTORS-ON CANCEL-ITIMES-FACTORS NIL)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-ON *1*CANCEL-ITIMES-FACTORS NIL)

(TOGGLE G*1*IPLUS-OR-ITIMES-TERM-ON *1*IPLUS-OR-ITIMES-TERM NIL)

(TOGGLE ITIMES-EVAL$-ITIMES-TREE-INEG-ON ITIMES-EVAL$-ITIMES-TREE-INEG NIL)

(TOGGLE IPLUS-EVAL$-ITIMES-TREE-INEG-ON IPLUS-EVAL$-ITIMES-TREE-INEG NIL)

(TOGGLE INEG-EVAL$-ITIMES-TREE-INEG-ON INEG-EVAL$-ITIMES-TREE-INEG NIL)

(TOGGLE EVAL$-ITIMES-TREE-INEG-ON EVAL$-ITIMES-TREE-INEG NIL)

(TOGGLE FIX-INT-EVAL$-ITIMES-TREE-REC-ON FIX-INT-EVAL$-ITIMES-TREE-REC NIL)

(TOGGLE ILESSP-INEG-INEG-ON ILESSP-INEG-INEG NIL)

(TOGGLE EQUAL-INEG-INEG-ON EQUAL-INEG-INEG NIL)

(TOGGLE ITIMES--1-ON ITIMES--1 NIL)

(TOGGLE ITIMES-FACTORS-ON ITIMES-FACTORS NIL)

(TOGGLE G*1*ITIMES-FACTORS-ON *1*ITIMES-FACTORS NIL)

(TOGGLE G*1*ITIMES-TREE-INEG-ON *1*ITIMES-TREE-INEG NIL)

(TOGGLE ILESSP-STRICT-ON ILESSP-STRICT NIL)

(TOGGLE ILESSP-ITIMES-RIGHT-NEGATIVE-ON ILESSP-ITIMES-RIGHT-NEGATIVE NIL)

(TOGGLE ILESSP-ITIMES-RIGHT-POSITIVE-ON ILESSP-ITIMES-RIGHT-POSITIVE NIL)

(TOGGLE CANCEL-ITIMES-ILESSP-ON CANCEL-ITIMES-ILESSP NIL)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-ON *1*CANCEL-ITIMES-ILESSP NIL)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-INEQUALITY-ON *1*MAKE-CANCEL-ITIMES-INEQUALITY
        NIL)

(TOGGLE G*1*ITIMES-TREE-NO-FIX-INT-ON *1*ITIMES-TREE-NO-FIX-INT NIL)

(TOGGLE SUBSETP-ON SUBSETP NIL)

(TOGGLE G*1*SUBSETP-ON *1*SUBSETP NIL)

(TOGGLE EQUAL-FIX-INT-ON EQUAL-FIX-INT NIL)

(TOGGLE MEMBER-APPEND-ON MEMBER-APPEND NIL)

(TOGGLE ITIMES-LIST-APPEND-ON ITIMES-LIST-APPEND NIL)

(TOGGLE CANCEL-ITIMES-ON CANCEL-ITIMES NIL)

(TOGGLE G*1*CANCEL-ITIMES-ON *1*CANCEL-ITIMES NIL)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-EQUALITY-ON *1*MAKE-CANCEL-ITIMES-EQUALITY NIL)

(TOGGLE INTEGERP-ITIMES-LIST-ON INTEGERP-ITIMES-LIST NIL)

(TOGGLE ITIMES-LIST-ON ITIMES-LIST NIL)

(TOGGLE G*1*ITIMES-LIST-ON *1*ITIMES-LIST NIL)

(TOGGLE G*1*ITIMES-TREE-ON *1*ITIMES-TREE NIL)

(TOGGLE ITIMES-TREE-REC-ON ITIMES-TREE-REC NIL)

(TOGGLE G*1*ITIMES-TREE-REC-ON *1*ITIMES-TREE-REC NIL)

(TOGGLE ITIMES-FRINGE-ON ITIMES-FRINGE NIL)

(TOGGLE G*1*ITIMES-FRINGE-ON *1*ITIMES-FRINGE NIL)

(TOGGLE FIX-INT-IREM-ON FIX-INT-IREM NIL)

(TOGGLE FIX-INT-IQUO-ON FIX-INT-IQUO NIL)

(TOGGLE FIX-INT-IMOD-ON FIX-INT-IMOD NIL)

(TOGGLE FIX-INT-IDIV-ON FIX-INT-IDIV NIL)

(TOGGLE FIX-INT-IREMAINDER-ON FIX-INT-IREMAINDER NIL)

(TOGGLE FIX-INT-IQUOTIENT-ON FIX-INT-IQUOTIENT NIL)

(TOGGLE IREM-FIX-INT2-ON IREM-FIX-INT2 NIL)

(TOGGLE IREM-FIX-INT1-ON IREM-FIX-INT1 NIL)

(TOGGLE IQUO-FIX-INT2-ON IQUO-FIX-INT2 NIL)

(TOGGLE IQUO-FIX-INT1-ON IQUO-FIX-INT1 NIL)

(TOGGLE IMOD-FIX-INT2-ON IMOD-FIX-INT2 NIL)

(TOGGLE IMOD-FIX-INT1-ON IMOD-FIX-INT1 NIL)

(TOGGLE IDIV-FIX-INT2-ON IDIV-FIX-INT2 NIL)

(TOGGLE IDIV-FIX-INT1-ON IDIV-FIX-INT1 NIL)

(TOGGLE IREMAINDER-FIX-INT2-ON IREMAINDER-FIX-INT2 NIL)

(TOGGLE IREMAINDER-FIX-INT1-ON IREMAINDER-FIX-INT1 NIL)

(TOGGLE IQUOTIENT-FIX-INT2-ON IQUOTIENT-FIX-INT2 NIL)

(TOGGLE IQUOTIENT-FIX-INT1-ON IQUOTIENT-FIX-INT1 NIL)

(TOGGLE INTEGERP-IREM-ON INTEGERP-IREM NIL)

(TOGGLE INTEGERP-IQUO-ON INTEGERP-IQUO NIL)

(TOGGLE INTEGERP-IMOD-ON INTEGERP-IMOD NIL)

(TOGGLE INTEGERP-IDIV-ON INTEGERP-IDIV NIL)

(TOGGLE INTEGERP-IREMAINDER-ON INTEGERP-IREMAINDER NIL)

(TOGGLE INTEGERP-IQUOTIENT-ON INTEGERP-IQUOTIENT NIL)

(TOGGLE ITIMES-CANCELLATION-3-ON ITIMES-CANCELLATION-3 NIL)

(TOGGLE ITIMES-CANCELLATION-2-ON ITIMES-CANCELLATION-2 NIL)

(TOGGLE ITIMES-CANCELLATION-1-ON ITIMES-CANCELLATION-1 NIL)

(TOGGLE ITIMES-INEG-2-ON ITIMES-INEG-2 NIL)

(TOGGLE ITIMES-INEG-1-ON ITIMES-INEG-1 NIL)

(TOGGLE IQUO-IREM-UNIQUENESS-ON IQUO-IREM-UNIQUENESS NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3 NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2 NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 NIL)

(TOGGLE IDIV-IMOD-UNIQUENESS-ON IDIV-IMOD-UNIQUENESS NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3 NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2 NIL)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1-ON
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1 NIL)

(TOGGLE IQUOTIENT-IREMAINDER-UNIQUENESS-ON IQUOTIENT-IREMAINDER-UNIQUENESS NIL)

(TOGGLE DIVISION-THEOREM-ON DIVISION-THEOREM NIL)

(TOGGLE DIVISION-THEOREM-PART3-ON DIVISION-THEOREM-PART3 NIL)

(TOGGLE DIVISION-THEOREM-PART2-ON DIVISION-THEOREM-PART2 NIL)

(TOGGLE DIVISION-THEOREM-PART1-ON DIVISION-THEOREM-PART1 NIL)

(TOGGLE QUOTIENT-REMAINDER-UNIQUENESS-ON QUOTIENT-REMAINDER-UNIQUENESS NIL)

(TOGGLE ITIMES-1-ARG1-ON ITIMES-1-ARG1 NIL)

(TOGGLE EQUAL-ITIMES-MINUS-1-ON EQUAL-ITIMES-MINUS-1 NIL)

(TOGGLE EQUAL-ITIMES-1-ON EQUAL-ITIMES-1 NIL)

(TOGGLE EQUAL-ITIMES-0-ON EQUAL-ITIMES-0 NIL)

(TOGGLE ASSOCIATIVITY-OF-ITIMES-ON ASSOCIATIVITY-OF-ITIMES NIL)

(TOGGLE COMMUTATIVITY2-OF-ITIMES-ON COMMUTATIVITY2-OF-ITIMES NIL)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-ON ITIMES-DISTRIBUTES-OVER-IPLUS NIL)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF-ON
        ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF NIL)

(TOGGLE COMMUTATIVITY-OF-ITIMES-ON COMMUTATIVITY-OF-ITIMES NIL)

(TOGGLE ITIMES-FIX-INT2-ON ITIMES-FIX-INT2 NIL)

(TOGGLE ITIMES-FIX-INT1-ON ITIMES-FIX-INT1 NIL)

(TOGGLE ITIMES-0-RIGHT-ON ITIMES-0-RIGHT NIL)

(TOGGLE ITIMES-0-LEFT-ON ITIMES-0-LEFT NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-ON
        CORRECTNESS-OF-CANCEL-IPLUS-ILESSP NIL)

(TOGGLE CANCEL-IPLUS-ILESSP-ON CANCEL-IPLUS-ILESSP NIL)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-ON *1*CANCEL-IPLUS-ILESSP NIL)

(TOGGLE G*1*IPLUS-TREE-NO-FIX-INT-ON *1*IPLUS-TREE-NO-FIX-INT NIL)

(TOGGLE IPLUS-CANCELLATION-2-FOR-ILESSP-ON IPLUS-CANCELLATION-2-FOR-ILESSP NIL)

(TOGGLE IPLUS-CANCELLATION-1-FOR-ILESSP-ON IPLUS-CANCELLATION-1-FOR-ILESSP NIL)

(TOGGLE CANCEL-IPLUS-ILESSP-1-ON CANCEL-IPLUS-ILESSP-1 NIL)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-1-ON *1*CANCEL-IPLUS-ILESSP-1 NIL)

(TOGGLE G*1*MAKE-CANCEL-IPLUS-INEQUALITY-1-ON *1*MAKE-CANCEL-IPLUS-INEQUALITY-1
        NIL)

(TOGGLE ILESSP-FIX-INT-2-ON ILESSP-FIX-INT-2 NIL)

(TOGGLE ILESSP-FIX-INT-1-ON ILESSP-FIX-INT-1 NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-ON CORRECTNESS-OF-CANCEL-IPLUS NIL)

(TOGGLE IPLUS-INEG7-ON IPLUS-INEG7 NIL)

(TOGGLE IPLUS-LIST-APPEND-ON IPLUS-LIST-APPEND NIL)

(TOGGLE EVAL$-IPLUS-LIST-DELETE-ON EVAL$-IPLUS-LIST-DELETE NIL)

(TOGGLE G*1*CANCEL-IPLUS-ON *1*CANCEL-IPLUS NIL)

(TOGGLE EVAL$-LIST-APPEND-ON EVAL$-LIST-APPEND NIL)

(TOGGLE INTEGERP-IPLUS-LIST-ON INTEGERP-IPLUS-LIST NIL)

(TOGGLE IPLUS-LIST-ON IPLUS-LIST NIL)

(TOGGLE G*1*IPLUS-LIST-ON *1*IPLUS-LIST NIL)

(TOGGLE G*1*IPLUS-TREE-ON *1*IPLUS-TREE NIL)

(TOGGLE IPLUS-TREE-REC-ON IPLUS-TREE-REC NIL)

(TOGGLE G*1*IPLUS-TREE-REC-ON *1*IPLUS-TREE-REC NIL)

(TOGGLE IPLUS-FRINGE-ON IPLUS-FRINGE NIL)

(TOGGLE G*1*IPLUS-FRINGE-ON *1*IPLUS-FRINGE NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-ON CORRECTNESS-OF-CANCEL-INEG NIL)

(TOGGLE IPLUS-X-Y-INEG-X-ON IPLUS-X-Y-INEG-X NIL)

(TOGGLE IPLUS-INEG4-ON IPLUS-INEG4 NIL)

(TOGGLE IPLUS-INEG3-ON IPLUS-INEG3 NIL)

(TOGGLE EVAL$-CANCEL-INEG-AUX-IS-ITS-FN-ON EVAL$-CANCEL-INEG-AUX-IS-ITS-FN NIL)

(TOGGLE EVAL$-CANCEL-INEG-AUX-FN-ON EVAL$-CANCEL-INEG-AUX-FN NIL)

(TOGGLE G*1*EVAL$-CANCEL-INEG-AUX-FN-ON *1*EVAL$-CANCEL-INEG-AUX-FN NIL)

(TOGGLE EVAL$-OTHER-ON EVAL$-OTHER NIL)

(TOGGLE EVAL$-LITATOM-ON EVAL$-LITATOM NIL)

(TOGGLE EVAL$-LIST-NLISTP-ON EVAL$-LIST-NLISTP NIL)

(TOGGLE EVAL$-LIST-CONS-ON EVAL$-LIST-CONS NIL)

(TOGGLE CANCEL-INEG-ON CANCEL-INEG NIL)

(TOGGLE G*1*CANCEL-INEG-ON *1*CANCEL-INEG NIL)

(TOGGLE CANCEL-INEG-AUX-ON CANCEL-INEG-AUX NIL)

(TOGGLE G*1*CANCEL-INEG-AUX-ON *1*CANCEL-INEG-AUX NIL)

(TOGGLE IDIFFERENCE-FIX-INT2-ON IDIFFERENCE-FIX-INT2 NIL)

(TOGGLE IDIFFERENCE-FIX-INT1-ON IDIFFERENCE-FIX-INT1 NIL)

(TOGGLE IPLUS-FIX-INT2-ON IPLUS-FIX-INT2 NIL)

(TOGGLE IPLUS-FIX-INT1-ON IPLUS-FIX-INT1 NIL)

(TOGGLE IPLUS-INEG2-ON IPLUS-INEG2 NIL)

(TOGGLE IPLUS-INEG1-ON IPLUS-INEG1 NIL)

(TOGGLE IPLUS-CANCELLATION-2-ON IPLUS-CANCELLATION-2 NIL)

(TOGGLE IPLUS-CANCELLATION-1-ON IPLUS-CANCELLATION-1 NIL)

(TOGGLE ASSOCIATIVITY-OF-IPLUS-ON ASSOCIATIVITY-OF-IPLUS NIL)

(TOGGLE COMMUTATIVITY-OF-IPLUS-ON COMMUTATIVITY-OF-IPLUS NIL)

(TOGGLE COMMUTATIVITY2-OF-IPLUS-ON COMMUTATIVITY2-OF-IPLUS NIL)

(TOGGLE IPLUS-0-RIGHT-ON IPLUS-0-RIGHT NIL)

(TOGGLE IPLUS-0-LEFT-ON IPLUS-0-LEFT NIL)

(TOGGLE INEG-0-ON INEG-0 NIL)

(TOGGLE INEG-FIX-INT-ON INEG-FIX-INT NIL)

(TOGGLE INEG-INEG-ON INEG-INEG NIL)

(TOGGLE INEG-IPLUS-ON INEG-IPLUS NIL)

(TOGGLE FIX-INT-ITIMES-ON FIX-INT-ITIMES NIL)

(TOGGLE FIX-INT-IABS-ON FIX-INT-IABS NIL)

(TOGGLE FIX-INT-INEG-ON FIX-INT-INEG NIL)

(TOGGLE FIX-INT-IDIFFERENCE-ON FIX-INT-IDIFFERENCE NIL)

(TOGGLE FIX-INT-IPLUS-ON FIX-INT-IPLUS NIL)

(TOGGLE FIX-INT-FIX-INT-ON FIX-INT-FIX-INT NIL)

(TOGGLE FIX-INT-REMOVER-ON FIX-INT-REMOVER NIL)

(TOGGLE INTEGERP-ITIMES-ON INTEGERP-ITIMES NIL)

(TOGGLE INTEGERP-IABS-ON INTEGERP-IABS NIL)

(TOGGLE INTEGERP-INEG-ON INTEGERP-INEG NIL)

(TOGGLE INTEGERP-IDIFFERENCE-ON INTEGERP-IDIFFERENCE NIL)

(TOGGLE INTEGERP-IPLUS-ON INTEGERP-IPLUS NIL)

(TOGGLE INTEGERP-FIX-INT-ON INTEGERP-FIX-INT NIL)

(TOGGLE G*1*IREM-ON *1*IREM NIL)

(TOGGLE G*1*IQUO-ON *1*IQUO NIL)

(TOGGLE G*1*IMOD-ON *1*IMOD NIL)

(TOGGLE G*1*IDIV-ON *1*IDIV NIL)

(TOGGLE G*1*IREMAINDER-ON *1*IREMAINDER NIL)

(TOGGLE G*1*IQUOTIENT-ON *1*IQUOTIENT NIL)

(TOGGLE G*1*ITIMES-ON *1*ITIMES NIL)

(TOGGLE G*1*IABS-ON *1*IABS NIL)

(TOGGLE IDIFFERENCE-ON IDIFFERENCE NIL)

(TOGGLE G*1*IDIFFERENCE-ON *1*IDIFFERENCE NIL)

(TOGGLE G*1*INEG-ON *1*INEG NIL)

(TOGGLE G*1*IPLUS-ON *1*IPLUS NIL)

(TOGGLE ILEQ-ON ILEQ NIL)

(TOGGLE G*1*ILEQ-ON *1*ILEQ NIL)

(TOGGLE G*1*ILESSP-ON *1*ILESSP NIL)

(TOGGLE IZEROP-ON IZEROP NIL)

(TOGGLE G*1*IZEROP-ON *1*IZEROP NIL)

(TOGGLE G*1*FIX-INT-ON *1*FIX-INT NIL)

(TOGGLE G*1*INTEGERP-ON *1*INTEGERP NIL)

(TOGGLE GCD-IDEMPOTENCE-ON GCD-IDEMPOTENCE NIL)

(TOGGLE GCD-X-X-ON GCD-X-X NIL)

(TOGGLE COMMUTATIVITY2-OF-GCD-ON COMMUTATIVITY2-OF-GCD NIL)

(TOGGLE COMMUTATIVITY2-OF-GCD-ZERO-CASE-ON COMMUTATIVITY2-OF-GCD-ZERO-CASE NIL)

(TOGGLE ASSOCIATIVITY-OF-GCD-ON ASSOCIATIVITY-OF-GCD NIL)

(TOGGLE ASSOCIATIVITY-OF-GCD-ZERO-CASE-ON ASSOCIATIVITY-OF-GCD-ZERO-CASE NIL)

(TOGGLE COMMON-DIVISOR-DIVIDES-GCD-ON COMMON-DIVISOR-DIVIDES-GCD NIL)

(TOGGLE GCD-IS-THE-GREATEST-ON GCD-IS-THE-GREATEST NIL)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-ON DISTRIBUTIVITY-OF-TIMES-OVER-GCD
        NIL)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF-ON
        DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF NIL)

(TOGGLE REMAINDER-GCD-ON REMAINDER-GCD NIL)

(TOGGLE GCD-PLUS-INSTANCE-ON GCD-PLUS-INSTANCE NIL)

(TOGGLE GCD-PLUS-ON GCD-PLUS NIL)

(TOGGLE GCD-PLUS-PROOF-ON GCD-PLUS-PROOF NIL)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-ON GCD-PLUS-INSTANCE-TEMP NIL)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-PROOF-ON GCD-PLUS-INSTANCE-TEMP-PROOF NIL)

(TOGGLE LESSP-GCD-ON LESSP-GCD NIL)

(TOGGLE EQUAL-GCD-0-ON EQUAL-GCD-0 NIL)

(TOGGLE GCD-1-ON GCD-1 NIL)

(TOGGLE GCD-0-ON GCD-0 NIL)

(TOGGLE SINGLE-NUMBER-INDUCTION-ON SINGLE-NUMBER-INDUCTION NIL)

(TOGGLE G*1*SINGLE-NUMBER-INDUCTION-ON *1*SINGLE-NUMBER-INDUCTION NIL)

(TOGGLE COMMUTATIVITY-OF-GCD-ON COMMUTATIVITY-OF-GCD NIL)

(TOGGLE LOG-EXP-ON LOG-EXP NIL)

(TOGGLE LOG-TIMES-EXP-ON LOG-TIMES-EXP NIL)

(TOGGLE LOG-TIMES-EXP-PROOF-ON LOG-TIMES-EXP-PROOF NIL)

(TOGGLE LOG-TIMES-ON LOG-TIMES NIL)

(TOGGLE LOG-TIMES-PROOF-ON LOG-TIMES-PROOF NIL)

(TOGGLE LOG-QUOTIENT-EXP-ON LOG-QUOTIENT-EXP NIL)

(TOGGLE LOG-QUOTIENT-TIMES-ON LOG-QUOTIENT-TIMES NIL)

(TOGGLE LOG-QUOTIENT-TIMES-PROOF-ON LOG-QUOTIENT-TIMES-PROOF NIL)

(TOGGLE LOG-QUOTIENT-ON LOG-QUOTIENT NIL)

(TOGGLE LEQ-LOG-LOG-ON LEQ-LOG-LOG NIL)

(TOGGLE DOUBLE-LOG-INDUCTION-ON DOUBLE-LOG-INDUCTION NIL)

(TOGGLE G*1*DOUBLE-LOG-INDUCTION-ON *1*DOUBLE-LOG-INDUCTION NIL)

(TOGGLE LOG-1-ON LOG-1 NIL)

(TOGGLE LOG-0-ON LOG-0 NIL)

(TOGGLE EQUAL-LOG-0-ON EQUAL-LOG-0 NIL)

(TOGGLE EXP-DIFFERENCE-ON EXP-DIFFERENCE NIL)

(TOGGLE EQUAL-EXP-1-ON EQUAL-EXP-1 NIL)

(TOGGLE EQUAL-EXP-0-ON EQUAL-EXP-0 NIL)

(TOGGLE EXP-EXP-ON EXP-EXP NIL)

(TOGGLE EXP-TIMES-ON EXP-TIMES NIL)

(TOGGLE EXP-0-ARG2-ON EXP-0-ARG2 NIL)

(TOGGLE EXP-1-ARG1-ON EXP-1-ARG1 NIL)

(TOGGLE EXP-0-ARG1-ON EXP-0-ARG1 NIL)

(TOGGLE EXP-PLUS-ON EXP-PLUS NIL)

(TOGGLE EXP-ADD1-ON EXP-ADD1 NIL)

(TOGGLE EXP-ZERO-ON EXP-ZERO NIL)

(TOGGLE QUOTIENT-EXP-ON QUOTIENT-EXP NIL)

(TOGGLE REMAINDER-EXP-EXP-ON REMAINDER-EXP-EXP NIL)

(TOGGLE DOUBLE-NUMBER-INDUCTION-ON DOUBLE-NUMBER-INDUCTION NIL)

(TOGGLE G*1*DOUBLE-NUMBER-INDUCTION-ON *1*DOUBLE-NUMBER-INDUCTION NIL)

(TOGGLE REMAINDER-EXP-ON REMAINDER-EXP NIL)

(TOGGLE GCD-ON GCD NIL)

(TOGGLE G*1*GCD-ON *1*GCD NIL)

(TOGGLE LOG-ON LOG NIL)

(TOGGLE G*1*LOG-ON *1*LOG NIL)

(TOGGLE EXP-ON EXP NIL)

(TOGGLE G*1*EXP-ON *1*EXP NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES-ON
        CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES NIL)

(TOGGLE CANCEL-QUOTIENT-TIMES-ON CANCEL-QUOTIENT-TIMES NIL)

(TOGGLE G*1*CANCEL-QUOTIENT-TIMES-ON *1*CANCEL-QUOTIENT-TIMES NIL)

(TOGGLE LESSP-QUOTIENT-ON LESSP-QUOTIENT NIL)

(TOGGLE QUOTIENT-X-X-ON QUOTIENT-X-X NIL)

(TOGGLE QUOTIENT-1-ARG1-ON QUOTIENT-1-ARG1 NIL)

(TOGGLE QUOTIENT-1-ARG1-CASESPLIT-ON QUOTIENT-1-ARG1-CASESPLIT NIL)

(TOGGLE QUOTIENT-1-ARG2-ON QUOTIENT-1-ARG2 NIL)

(TOGGLE LEQ-QUOTIENT-ON LEQ-QUOTIENT NIL)

(TOGGLE QUOTIENT-QUOTIENT-ON QUOTIENT-QUOTIENT NIL)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-INSTANCE-ON
        QUOTIENT-PLUS-TIMES-TIMES-INSTANCE NIL)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-ON QUOTIENT-PLUS-TIMES-TIMES NIL)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-PROOF-ON QUOTIENT-PLUS-TIMES-TIMES-PROOF NIL)

(TOGGLE QUOTIENT-PLUS-FACT-ON QUOTIENT-PLUS-FACT NIL)

(TOGGLE QUOTIENT-REMAINDER-INSTANCE-ON QUOTIENT-REMAINDER-INSTANCE NIL)

(TOGGLE QUOTIENT-REMAINDER-ON QUOTIENT-REMAINDER NIL)

(TOGGLE QUOTIENT-REMAINDER-TIMES-ON QUOTIENT-REMAINDER-TIMES NIL)

(TOGGLE QUOTIENT-DIFFERENCE3-ON QUOTIENT-DIFFERENCE3 NIL)

(TOGGLE QUOTIENT-DIFFERENCE2-ON QUOTIENT-DIFFERENCE2 NIL)

(TOGGLE QUOTIENT-LESSP-ARG1-ON QUOTIENT-LESSP-ARG1 NIL)

(TOGGLE QUOTIENT-DIFFERENCE1-ON QUOTIENT-DIFFERENCE1 NIL)

(TOGGLE QUOTIENT-TIMES-TIMES-PROOF-ON QUOTIENT-TIMES-TIMES-PROOF NIL)

(TOGGLE QUOTIENT-TIMES-INSTANCE-ON QUOTIENT-TIMES-INSTANCE NIL)

(TOGGLE QUOTIENT-TIMES-ON QUOTIENT-TIMES NIL)

(TOGGLE QUOTIENT-TIMES-PROOF-ON QUOTIENT-TIMES-PROOF NIL)

(TOGGLE QUOTIENT-TIMES-INSTANCE-TEMP-PROOF-ON
        QUOTIENT-TIMES-INSTANCE-TEMP-PROOF NIL)

(TOGGLE QUOTIENT-PLUS-ON QUOTIENT-PLUS NIL)

(TOGGLE QUOTIENT-PLUS-PROOF-ON QUOTIENT-PLUS-PROOF NIL)

(TOGGLE QUOTIENT-SUB1-ON QUOTIENT-SUB1 NIL)

(TOGGLE EQUAL-QUOTIENT-0-ON EQUAL-QUOTIENT-0 NIL)

(TOGGLE QUOTIENT-ADD1-ON QUOTIENT-ADD1 NIL)

(TOGGLE QUOTIENT-ZERO-ON QUOTIENT-ZERO NIL)

(TOGGLE QUOTIENT-OF-NON-NUMBER-ON QUOTIENT-OF-NON-NUMBER NIL)

(TOGGLE QUOTIENT-NOOP-ON QUOTIENT-NOOP NIL)

(TOGGLE TRANSITIVITY-OF-DIVIDES-ON TRANSITIVITY-OF-DIVIDES NIL)

(TOGGLE REMAINDER-X-X-ON REMAINDER-X-X NIL)

(TOGGLE REMAINDER-1-ARG2-ON REMAINDER-1-ARG2 NIL)

(TOGGLE REMAINDER-1-ARG1-ON REMAINDER-1-ARG1 NIL)

(TOGGLE REMAINDER-REMAINDER-ON REMAINDER-REMAINDER NIL)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-INSTANCE-ON
        REMAINDER-PLUS-TIMES-TIMES-INSTANCE NIL)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-ON REMAINDER-PLUS-TIMES-TIMES NIL)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-PROOF-ON REMAINDER-PLUS-TIMES-TIMES-PROOF
        NIL)

(TOGGLE REMAINDER-PLUS-FACT-ON REMAINDER-PLUS-FACT NIL)

(TOGGLE REMAINDER-DIFFERENCE2-ON REMAINDER-DIFFERENCE2 NIL)

(TOGGLE DOUBLE-REMAINDER-INDUCTION-ON DOUBLE-REMAINDER-INDUCTION NIL)

(TOGGLE G*1*DOUBLE-REMAINDER-INDUCTION-ON *1*DOUBLE-REMAINDER-INDUCTION NIL)

(TOGGLE REMAINDER-DIFFERENCE1-ON REMAINDER-DIFFERENCE1 NIL)

(TOGGLE REMAINDER-TIMES2-INSTANCE-ON REMAINDER-TIMES2-INSTANCE NIL)

(TOGGLE REMAINDER-TIMES2-ON REMAINDER-TIMES2 NIL)

(TOGGLE REMAINDER-TIMES2-PROOF-ON REMAINDER-TIMES2-PROOF NIL)

(TOGGLE REMAINDER-TIMES-TIMES-PROOF-ON REMAINDER-TIMES-TIMES-PROOF NIL)

(TOGGLE REMAINDER-TIMES1-INSTANCE-ON REMAINDER-TIMES1-INSTANCE NIL)

(TOGGLE REMAINDER-TIMES1-INSTANCE-PROOF-ON REMAINDER-TIMES1-INSTANCE-PROOF NIL)

(TOGGLE REMAINDER-TIMES1-ON REMAINDER-TIMES1 NIL)

(TOGGLE REMAINDER-TIMES1-PROOF-ON REMAINDER-TIMES1-PROOF NIL)

(TOGGLE EQUAL-REMAINDER-PLUS-REMAINDER-PROOF-ON
        EQUAL-REMAINDER-PLUS-REMAINDER-PROOF NIL)

(TOGGLE EQUAL-REMAINDER-PLUS-0-ON EQUAL-REMAINDER-PLUS-0 NIL)

(TOGGLE EQUAL-REMAINDER-PLUS-0-PROOF-ON EQUAL-REMAINDER-PLUS-0-PROOF NIL)

(TOGGLE REMAINDER-PLUS-ON REMAINDER-PLUS NIL)

(TOGGLE REMAINDER-PLUS-PROOF-ON REMAINDER-PLUS-PROOF NIL)

(TOGGLE REMAINDER-ADD1-ON REMAINDER-ADD1 NIL)

(TOGGLE REMAINDER-QUOTIENT-ELIM-ON REMAINDER-QUOTIENT-ELIM NIL)

(TOGGLE REMAINDER-ZERO-ON REMAINDER-ZERO NIL)

(TOGGLE REMAINDER-OF-NON-NUMBER-ON REMAINDER-OF-NON-NUMBER NIL)

(TOGGLE REMAINDER-NOOP-ON REMAINDER-NOOP NIL)

(TOGGLE LESSP-REMAINDER-ON LESSP-REMAINDER NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-TIMES-ON CORRECTNESS-OF-CANCEL-EQUAL-TIMES
        NIL)

(TOGGLE CANCEL-EQUAL-TIMES-ON CANCEL-EQUAL-TIMES NIL)

(TOGGLE G*1*CANCEL-EQUAL-TIMES-ON *1*CANCEL-EQUAL-TIMES NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-TIMES-ON CORRECTNESS-OF-CANCEL-LESSP-TIMES
        NIL)

(TOGGLE CANCEL-LESSP-TIMES-ON CANCEL-LESSP-TIMES NIL)

(TOGGLE G*1*CANCEL-LESSP-TIMES-ON *1*CANCEL-LESSP-TIMES NIL)

(TOGGLE INFER-EQUALITY-FROM-NOT-LESSP-ON INFER-EQUALITY-FROM-NOT-LESSP NIL)

(TOGGLE LESSP-TIMES-ARG1-ON LESSP-TIMES-ARG1 NIL)

(TOGGLE EVAL$-EQUAL-ON1 EVAL$-EQUAL NIL)

(TOGGLE AND-NOT-ZEROP-TREE-ON AND-NOT-ZEROP-TREE NIL)

(TOGGLE G*1*AND-NOT-ZEROP-TREE-ON *1*AND-NOT-ZEROP-TREE NIL)

(TOGGLE OR-ZEROP-TREE-ON OR-ZEROP-TREE NIL)

(TOGGLE G*1*OR-ZEROP-TREE-ON *1*OR-ZEROP-TREE NIL)

(TOGGLE TIMES-FRINGE-ON TIMES-FRINGE NIL)

(TOGGLE G*1*TIMES-FRINGE-ON *1*TIMES-FRINGE NIL)

(TOGGLE TIMES-TREE-ON TIMES-TREE NIL)

(TOGGLE G*1*TIMES-TREE-ON *1*TIMES-TREE NIL)

(TOGGLE LESSP-1-TIMES-ON LESSP-1-TIMES NIL)

(TOGGLE LESSP-PLUS-TIMES2-ON LESSP-PLUS-TIMES2 NIL)

(TOGGLE LESSP-PLUS-TIMES1-ON LESSP-PLUS-TIMES1 NIL)

(TOGGLE LESSP-PLUS-TIMES-PROOF-ON LESSP-PLUS-TIMES-PROOF NIL)

(TOGGLE LESSP-TIMES-CANCELLATION-PROOF-ON LESSP-TIMES-CANCELLATION-PROOF NIL)

(TOGGLE LESSP-TIMES3-ON LESSP-TIMES3 NIL)

(TOGGLE LESSP-TIMES3-PROOF2-ON LESSP-TIMES3-PROOF2 NIL)

(TOGGLE LESSP-TIMES3-PROOF1-ON LESSP-TIMES3-PROOF1 NIL)

(TOGGLE LESSP-TIMES2-ON LESSP-TIMES2 NIL)

(TOGGLE LESSP-TIMES2-PROOF-ON LESSP-TIMES2-PROOF NIL)

(TOGGLE LESSP-TIMES1-ON LESSP-TIMES1 NIL)

(TOGGLE LESSP-TIMES1-PROOF-ON LESSP-TIMES1-PROOF NIL)

(TOGGLE TIMES-1-ARG1-ON TIMES-1-ARG1 NIL)

(TOGGLE TIMES-QUOTIENT-ON TIMES-QUOTIENT NIL)

(TOGGLE TIMES-QUOTIENT-PROOF-ON TIMES-QUOTIENT-PROOF NIL)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-ON TIMES-DISTRIBUTES-OVER-DIFFERENCE
        NIL)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF-ON
        TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF NIL)

(TOGGLE ASSOCIATIVITY-OF-TIMES-ON ASSOCIATIVITY-OF-TIMES NIL)

(TOGGLE COMMUTATIVITY2-OF-TIMES-ON COMMUTATIVITY2-OF-TIMES NIL)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-ON TIMES-DISTRIBUTES-OVER-PLUS NIL)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-PROOF-ON TIMES-DISTRIBUTES-OVER-PLUS-PROOF
        NIL)

(TOGGLE COMMUTATIVITY-OF-TIMES-ON COMMUTATIVITY-OF-TIMES NIL)

(TOGGLE TIMES-ADD1-ON TIMES-ADD1 NIL)

(TOGGLE TIMES-ZERO-ON TIMES-ZERO NIL)

(TOGGLE EQUAL-SUB1-0-ON EQUAL-SUB1-0 NIL)

(TOGGLE EQUAL-TIMES-1-ON EQUAL-TIMES-1 NIL)

(TOGGLE EQUAL-TIMES-0-ON EQUAL-TIMES-0 NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-PLUS-ON CORRECTNESS-OF-CANCEL-LESSP-PLUS
        NIL)

(TOGGLE CANCEL-LESSP-PLUS-ON CANCEL-LESSP-PLUS NIL)

(TOGGLE G*1*CANCEL-LESSP-PLUS-ON *1*CANCEL-LESSP-PLUS NIL)

(TOGGLE DIFFERENCE-X-X-ON DIFFERENCE-X-X NIL)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG2-ON DIFFERENCE-DIFFERENCE-ARG2 NIL)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG1-ON DIFFERENCE-DIFFERENCE-ARG1 NIL)

(TOGGLE DIFFERENCE-SUB1-ARG2-ON DIFFERENCE-SUB1-ARG2 NIL)

(TOGGLE DIFFERENCE-ADD1-ARG2-ON DIFFERENCE-ADD1-ARG2 NIL)

(TOGGLE DIFFERENCE-LEQ-ARG1-ON DIFFERENCE-LEQ-ARG1 NIL)

(TOGGLE DIFFERENCE-ELIM-ON DIFFERENCE-ELIM NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS-ON
        CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS NIL)

(TOGGLE CANCEL-DIFFERENCE-PLUS-ON CANCEL-DIFFERENCE-PLUS NIL)

(TOGGLE G*1*CANCEL-DIFFERENCE-PLUS-ON *1*CANCEL-DIFFERENCE-PLUS NIL)

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-PLUS-ON CORRECTNESS-OF-CANCEL-EQUAL-PLUS
        NIL)

(TOGGLE CANCEL-EQUAL-PLUS-ON CANCEL-EQUAL-PLUS NIL)

(TOGGLE G*1*CANCEL-EQUAL-PLUS-ON *1*CANCEL-EQUAL-PLUS NIL)

(TOGGLE EVAL$-QUOTE-ON1 EVAL$-QUOTE NIL)

(TOGGLE PLUS-TREE-ON PLUS-TREE NIL)

(TOGGLE G*1*PLUS-TREE-ON *1*PLUS-TREE NIL)

(TOGGLE PLUS-FRINGE-ON PLUS-FRINGE NIL)

(TOGGLE G*1*PLUS-FRINGE-ON *1*PLUS-FRINGE NIL)

(TOGGLE DIFF-DIFF-ARG2-ON DIFF-DIFF-ARG2 NIL)

(TOGGLE DIFF-DIFF-ARG1-ON DIFF-DIFF-ARG1 NIL)

(TOGGLE DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF-ON
        DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF NIL)

(TOGGLE DIFFERENCE-PLUS-CANCELLATION-PROOF-ON
        DIFFERENCE-PLUS-CANCELLATION-PROOF NIL)

(TOGGLE PLUS-DIFFERENCE-ARG2-ON PLUS-DIFFERENCE-ARG2 NIL)

(TOGGLE PLUS-DIFFERENCE-ARG1-ON PLUS-DIFFERENCE-ARG1 NIL)

(TOGGLE ASSOCIATIVITY-OF-PLUS-ON ASSOCIATIVITY-OF-PLUS NIL)

(TOGGLE PLUS-ADD1-ARG2-ON PLUS-ADD1-ARG2 NIL)

(TOGGLE PLUS-ADD1-ARG1-ON PLUS-ADD1-ARG1 NIL)

(TOGGLE PLUS-ZERO-ARG2-ON PLUS-ZERO-ARG2 NIL)

(TOGGLE COMMUTATIVITY2-OF-PLUS-ON COMMUTATIVITY2-OF-PLUS NIL)

(TOGGLE COMMUTATIVITY-OF-PLUS-ON COMMUTATIVITY-OF-PLUS NIL)

(TOGGLE EQUAL-DIFFERENCE-0-ON EQUAL-DIFFERENCE-0 NIL)

(TOGGLE EQUAL-PLUS-0-ON EQUAL-PLUS-0 NIL)

(TOGGLE MEMBER-BAGINT-ON MEMBER-BAGINT NIL)

(TOGGLE OCCURRENCES-BAGDIFF-ON OCCURRENCES-BAGDIFF NIL)

(TOGGLE OCCURRENCES-BAGINT-ON OCCURRENCES-BAGINT NIL)

(TOGGLE SUBBAGP-BAGINT2-ON SUBBAGP-BAGINT2 NIL)

(TOGGLE SUBBAGP-BAGINT1-ON SUBBAGP-BAGINT1 NIL)

(TOGGLE SUBBAGP-CDR2-ON SUBBAGP-CDR2 NIL)

(TOGGLE SUBBAGP-CDR1-ON SUBBAGP-CDR1 NIL)

(TOGGLE SUBBAGP-DELETE-ON SUBBAGP-DELETE NIL)

(TOGGLE BAGDIFF-DELETE-ON BAGDIFF-DELETE NIL)

(TOGGLE MEMBER-BAGDIFF-ON MEMBER-BAGDIFF NIL)

(TOGGLE OCCURRENCES-DELETE-ON OCCURRENCES-DELETE NIL)

(TOGGLE MEMBER-DELETE-IMPLIES-MEMBERSHIP-ON MEMBER-DELETE-IMPLIES-MEMBERSHIP
        NIL)

(TOGGLE MEMBER-DELETE-ON MEMBER-DELETE NIL)

(TOGGLE MEMBER-NON-LIST-ON MEMBER-NON-LIST NIL)

(TOGGLE EQUAL-OCCURRENCES-ZERO-ON EQUAL-OCCURRENCES-ZERO NIL)

(TOGGLE DELETE-DELETE-ON DELETE-DELETE NIL)

(TOGGLE DELETE-NON-MEMBER-ON DELETE-NON-MEMBER NIL)

(TOGGLE SUBBAGP-ON SUBBAGP NIL)

(TOGGLE G*1*SUBBAGP-ON *1*SUBBAGP NIL)

(TOGGLE OCCURRENCES-ON OCCURRENCES NIL)

(TOGGLE G*1*OCCURRENCES-ON *1*OCCURRENCES NIL)

(TOGGLE BAGINT-ON BAGINT NIL)

(TOGGLE G*1*BAGINT-ON *1*BAGINT NIL)

(TOGGLE BAGDIFF-ON BAGDIFF NIL)

(TOGGLE G*1*BAGDIFF-ON *1*BAGDIFF NIL)

(TOGGLE DELETE-ON DELETE NIL)

(TOGGLE G*1*DELETE-ON *1*DELETE NIL)

(DEFN B-TO-NAT (C) (IF C 1 0))

(TOGGLE V-ADDER-OUTPUT=V-SUM-OFF V-ADDER-OUTPUT=V-SUM T)

(TOGGLE V-ADDER-CARRY-OUT=V-CARRY-OFF V-ADDER-CARRY-OUT=V-CARRY T)

(PROVE-LEMMA BVP-CDR
             (REWRITE)
             (IMPLIES (AND (BVP X) (LISTP X))
                      (BVP (CDR X))))

(DEFTHEORY INTEGER-METAS
 (CORRECTNESS-OF-CANCEL-INEG CORRECTNESS-OF-CANCEL-IPLUS
                             CORRECTNESS-OF-CANCEL-IPLUS-ILESSP
                             CORRECTNESS-OF-CANCEL-ITIMES
                             CORRECTNESS-OF-CANCEL-ITIMES-ILESSP
                             CORRECTNESS-OF-CANCEL-ITIMES-FACTORS
                             CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS
                             CORRECTNESS-OF-CANCEL-FACTORS-0
                             CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0
                             CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY
                             CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY))

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-OFF1 CORRECTNESS-OF-CANCEL-INEG T)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-OFF1 CORRECTNESS-OF-CANCEL-IPLUS T)

(TOGGLE CORRECTNESS-OF-CANCEL-IPLUS-ILESSP-OFF1
        CORRECTNESS-OF-CANCEL-IPLUS-ILESSP T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-OFF1 CORRECTNESS-OF-CANCEL-ITIMES T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-OFF1
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-FACTORS-OFF1
        CORRECTNESS-OF-CANCEL-ITIMES-FACTORS T)

(TOGGLE CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS-OFF1
        CORRECTNESS-OF-CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-0-OFF1 CORRECTNESS-OF-CANCEL-FACTORS-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0-OFF1
        CORRECTNESS-OF-CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY-OFF1
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF1
        CORRECTNESS-OF-CANCEL-INEG-TERMS-FROM-INEQUALITY T)

(DEFTHEORY NATURALS-METAS
       (CORRECTNESS-OF-CANCEL-EQUAL-PLUS CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS
                                         CORRECTNESS-OF-CANCEL-LESSP-PLUS
                                         CORRECTNESS-OF-CANCEL-LESSP-TIMES
                                         CORRECTNESS-OF-CANCEL-EQUAL-TIMES
                                         CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES))

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-PLUS-OFF1 CORRECTNESS-OF-CANCEL-EQUAL-PLUS
        T)

(TOGGLE CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS-OFF1
        CORRECTNESS-OF-CANCEL-DIFFERENCE-PLUS T)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-PLUS-OFF1 CORRECTNESS-OF-CANCEL-LESSP-PLUS
        T)

(TOGGLE CORRECTNESS-OF-CANCEL-LESSP-TIMES-OFF1
        CORRECTNESS-OF-CANCEL-LESSP-TIMES T)

(TOGGLE CORRECTNESS-OF-CANCEL-EQUAL-TIMES-OFF1
        CORRECTNESS-OF-CANCEL-EQUAL-TIMES T)

(TOGGLE CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES-OFF1
        CORRECTNESS-OF-CANCEL-QUOTIENT-TIMES T)

(DEFN V-ALU-NAT-INT-BUF
      (A)
      (CVZBV F F A))

(PROVE-LEMMA V-ALU-CORRECT-NAT-INT-BUF
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV F F (V-BUF A))
                             (V-ALU-NAT-INT-BUF A))))

(PROVE-LEMMA NTH-LENGTH-V
             (REWRITE)
             (IMPLIES (AND (BVP BV)
                           (EQUAL (LENGTH BV) (ADD1 N)))
                      (EQUAL (NTH N BV)
                             (NOT (LESSP (V-TO-NAT BV) (EXP 2 N)))))
             ((ENABLE V-TO-NAT NTH)
              (INDUCT (NTH N BV))))

(PROVE-LEMMA REMAINDER-PLUS-MULTIPLE NIL
             (IMPLIES (AND (LESSP Z1 Y1)
                           (EQUAL (REMAINDER A Y1) 0))
                      (EQUAL (REMAINDER (PLUS Z1 A) Y1)
                             (FIX Z1))))

(PROVE-LEMMA DIVIDES-PLUS-PLUS
             (REWRITE)
             (IMPLIES (EQUAL (REMAINDER X Y) 0)
                      (EQUAL (REMAINDER (PLUS X X) (PLUS Y Y))
                             0)))

(PROVE-LEMMA V-TO-NAT-FIRSTN-HACK1
            (REWRITE)
            (IMPLIES (LESSP Z Y)
                     (EQUAL (REMAINDER (PLUS Z Z (TIMES W Y) (TIMES W Y))
                                       (PLUS Y Y))
                            (PLUS Z Z)))
            ((USE (REMAINDER-PLUS-MULTIPLE (Y1 (PLUS Y Y))
                                           (Z1 (PLUS Z Z))
                                           (A (PLUS (TIMES W Y) (TIMES W Y)))))
             (DISABLE-THEORY T)
             (ENABLE-THEORY GROUND-ZERO NATURALS)
             (ENABLE DIVIDES-PLUS-PLUS)))

(PROVE-LEMMA REMAINDER-ADD1-PLUS-MULTIPLE NIL
             (IMPLIES (AND (LESSP (ADD1 Z1) Y1)
                           (EQUAL (REMAINDER A Y1) 0))
                      (EQUAL (REMAINDER (ADD1 (PLUS Z1 A)) Y1)
                             (ADD1 Z1)))
             ((USE (REMAINDER-PLUS-MULTIPLE (Z1 (ADD1 Z1))))))

(PROVE-LEMMA V-TO-NAT-FIRSTN-HACK2
       (REWRITE)
       (IMPLIES (LESSP Z Y)
                (EQUAL (REMAINDER (ADD1 (PLUS Z Z (TIMES D Y) (TIMES D Y)))
                                  (PLUS Y Y))
                       (ADD1 (PLUS Z Z))))
       ((USE (REMAINDER-ADD1-PLUS-MULTIPLE (Y1 (PLUS Y Y))
                                           (Z1 (PLUS Z Z))
                                           (A (PLUS (TIMES D Y) (TIMES D Y)))))
        (DISABLE-THEORY T)
        (ENABLE-THEORY GROUND-ZERO NATURALS)
        (ENABLE DIVIDES-PLUS-PLUS)))

(PROVE-LEMMA V-TO-NAT-FIRSTN
             (REWRITE)
             (EQUAL (V-TO-NAT (FIRSTN N V))
                    (REMAINDER (V-TO-NAT V) (EXP 2 N)))
             ((ENABLE V-TO-NAT FIRSTN)))

(TOGGLE V-TO-NAT-FIRSTN-HACK1-OFF V-TO-NAT-FIRSTN-HACK1 T)

(TOGGLE V-TO-NAT-FIRSTN-HACK2-OFF V-TO-NAT-FIRSTN-HACK2 T)

(PROVE-LEMMA V-TO-NAT-OF-NAT-TO-V-HACK
             (REWRITE)
             (IMPLIES (LESSP V (EXP 2 X))
                      (EQUAL (REMAINDER (ADD1 (PLUS V V
                                                    (TIMES W (EXP 2 X))
                                                    (TIMES W (EXP 2 X))))
                                        (PLUS (EXP 2 X) (EXP 2 X)))
                             (ADD1 (PLUS V V))))
             ((USE (REMAINDER-PLUS-MULTIPLE (Y1 (PLUS (EXP 2 X) (EXP 2 X)))
                                            (Z1 (ADD1 (PLUS V V)))
                                            (A (PLUS (TIMES W (EXP 2 X))
                                                     (TIMES W (EXP 2 X))))))
              (DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO NATURALS)
              (ENABLE DIVIDES-PLUS-PLUS)))

(PROVE-LEMMA V-TO-NAT-OF-NAT-TO-V
             (REWRITE)
             (EQUAL (V-TO-NAT (NAT-TO-V N LEN))
                    (REMAINDER N (EXP 2 LEN)))
             ((ENABLE V-TO-NAT NAT-TO-V)
              (INDUCT (NAT-TO-V N LEN))))

(PROVE-LEMMA REMAINDER-PLUS-X-X-2
             (REWRITE)
             (EQUAL (REMAINDER (PLUS X X) 2) 0)
             ((INDUCT (PLUS X Q))))

(PROVE-LEMMA QUOTIENT-PLUS-X-X-2
             (REWRITE)
             (EQUAL (QUOTIENT (PLUS X X) 2)
                    (FIX X))
             ((INDUCT (PLUS X Q))))

(PROVE-LEMMA NAT-TO-V-PLUS-X-X
             (REWRITE)
             (EQUAL (NAT-TO-V (PLUS X X) (ADD1 N))
                    (CONS F (NAT-TO-V X N)))
             ((ENABLE NAT-TO-V)))

(PROVE-LEMMA FIRSTN-ADD1-CONS
             (REWRITE)
             (EQUAL (FIRSTN (ADD1 N) (CONS A X))
                    (CONS A (FIRSTN N X)))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA FIRSTN-ZEROP
             (REWRITE)
             (IMPLIES (ZEROP N)
                      (EQUAL (FIRSTN N X) NIL))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA FIRSTN-NLISTP
             (REWRITE)
             (IMPLIES (NLISTP X)
                      (EQUAL (FIRSTN N X) NIL))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA NAT-TO-V-OF-V-TO-NAT-GENERAL
             (REWRITE)
             (IMPLIES (AND (BVP V)
                           (NOT (LESSP (LENGTH V) N)))
                      (EQUAL (NAT-TO-V (V-TO-NAT V) N)
                             (FIRSTN N V)))
             ((ENABLE V-TO-NAT NAT-TO-V)
              (INDUCT (FIRSTN N V))))

(PROVE-LEMMA FIRSTN-LENGTH
             (REWRITE)
             (IMPLIES (PROPERP X)
                      (EQUAL (FIRSTN (LENGTH X) X) X))
             ((ENABLE FIRSTN)))

(PROVE-LEMMA NAT-TO-V-OF-V-TO-NAT
             (REWRITE)
             (IMPLIES (BVP V)
                      (EQUAL (NAT-TO-V (V-TO-NAT V) (LENGTH V))
                             V)))

(PROVE-LEMMA NAT-TO-V-ZEROP
             (REWRITE)
             (IMPLIES (ZEROP LEN)
                      (EQUAL (NAT-TO-V N LEN) NIL))
             ((ENABLE NAT-TO-V)))

(PROVE-LEMMA EQUAL-NAT-TO-V-INVERTER-HACK1
             (REWRITE)
             (IMPLIES (AND (NUMBERP LEN)
                           (EQUAL V (NAT-TO-V N LEN)))
                      (EQUAL (EQUAL (V-TO-NAT V)
                                    (REMAINDER N (EXP 2 LEN)))
                             T)))

(PROVE-LEMMA EQUAL-NAT-TO-V-INVERTER-HACK2-LEMMA NIL
             (IMPLIES (AND (BVP V)
                           (EQUAL (V-TO-NAT V)
                                  (REMAINDER N (EXP 2 LEN))))
                      (EQUAL (EQUAL (NAT-TO-V (V-TO-NAT V) LEN)
                                    (NAT-TO-V (REMAINDER N (EXP 2 LEN))
                                              LEN))
                             T)))

(PROVE-LEMMA NAT-TO-V-REMAINDER
             (REWRITE)
             (EQUAL (NAT-TO-V (REMAINDER N (EXP 2 LEN))
                              LEN)
                    (NAT-TO-V N LEN))
             ((ENABLE NAT-TO-V)))

(PROVE-LEMMA EQUAL-NAT-TO-V-INVERTER-HACK2
             (REWRITE)
             (IMPLIES (AND (BVP V)
                           (EQUAL (V-TO-NAT V)
                                  (REMAINDER N (EXP 2 (LENGTH V)))))
                      (EQUAL (EQUAL V (NAT-TO-V N (LENGTH V)))
                             T))
             ((USE (EQUAL-NAT-TO-V-INVERTER-HACK2-LEMMA (LEN (LENGTH V))))))

(PROVE-LEMMA EQUAL-NAT-TO-V-INVERTER
             (REWRITE)
             (IFF (EQUAL V (NAT-TO-V N LEN))
                  (AND (BVP V)
                       (EQUAL (LENGTH V) (FIX LEN))
                       (EQUAL (V-TO-NAT V)
                              (REMAINDER N (EXP 2 LEN))))))

(TOGGLE EQUAL-NAT-TO-V-INVERTER-HACK1-OFF EQUAL-NAT-TO-V-INVERTER-HACK1 T)

(TOGGLE EQUAL-NAT-TO-V-INVERTER-HACK2-OFF EQUAL-NAT-TO-V-INVERTER-HACK2 T)

(PROVE-LEMMA V-TO-NAT-V-NOT-LEMMA NIL
             (IMPLIES (BVP A)
                      (EQUAL (PLUS (V-TO-NAT A)
                                   (V-TO-NAT (V-NOT A)))
                             (SUB1 (EXP 2 (LENGTH A)))))
             ((ENABLE V-TO-NAT V-NOT)))

(PROVE-LEMMA V-TO-NAT-V-NOT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (V-TO-NAT (V-NOT A))
                             (SUB1 (DIFFERENCE (EXP 2 (LENGTH A))
                                               (V-TO-NAT A)))))
             ((USE (V-TO-NAT-V-NOT-LEMMA))))

(PROVE-LEMMA LESSP-V-TO-NAT-EXP
             (REWRITE)
             (IMPLIES (BVP A)
                      (LESSP (V-TO-NAT A)
                             (EXP 2 (LENGTH A))))
             ((ENABLE V-TO-NAT LENGTH)))

(PROVE-LEMMA EQUAL-IFF
             (REWRITE)
             (IMPLIES (AND (BOOLP X) (BOOLP Y))
                      (EQUAL (EQUAL X Y) (IFF X Y)))
             ((ENABLE BOOLP)))

(TOGGLE EQUAL-IFF-OFF EQUAL-IFF T)

(PROVE-LEMMA V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT-LEMMA
             (REWRITE)
             (IMPLIES (AND (LESSP A-NAT BOUND)
                           (LESSP B-NAT BOUND))
                      (EQUAL (PLUS B-NAT
                                   (SUB1 (DIFFERENCE BOUND A-NAT)))
                             (SUB1 (DIFFERENCE (PLUS B-NAT BOUND)
                                               A-NAT)))))

(PROVE-LEMMA LESSP-V-TO-NAT-EXP-REWRITE
             (REWRITE)
             (IMPLIES (AND (BVP A) (EQUAL (LENGTH A) LEN))
                      (EQUAL (LESSP (V-TO-NAT A) (EXP 2 LEN))
                             T)))

(PROVE-LEMMA NOT-LESSP-QUOTIENT
             (REWRITE)
             (NOT (LESSP N (QUOTIENT N K))))

(PROVE-LEMMA V-TO-NAT-APPEND
             (REWRITE)
             (IMPLIES (AND (BVP A) (BVP B))
                      (EQUAL (V-TO-NAT (APPEND A B))
                             (PLUS (V-TO-NAT A)
                                   (TIMES (EXP 2 (LENGTH A))
                                          (V-TO-NAT B)))))
             ((ENABLE V-TO-NAT)))

(DEFN V-ALU-NAT-ADDER-OUTPUT
      (C A B)
      (NAT-TO-V (REMAINDER (PLUS (B-TO-NAT C)
                                 (V-TO-NAT A)
                                 (V-TO-NAT B))
                           (EXP 2 (LENGTH A)))
                (LENGTH A)))

(DEFN V-ALU-NAT-ADDER-CARRY-OUT
      (C A B)
      (NOT (LESSP (PLUS (B-TO-NAT C)
                        (V-TO-NAT A)
                        (V-TO-NAT B))
                  (EXP 2 (LENGTH A)))))

(DEFN V-ALU-NAT-ADDER
      (C A B)
      (CVZBV (V-ALU-NAT-ADDER-CARRY-OUT C A B)
             (V-ADDER-OVERFLOWP C A B)
             (V-ALU-NAT-ADDER-OUTPUT C A B)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-ADDER-CARRY-OUT
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-ADDER-CARRY-OUT C A B)
                             (V-ALU-NAT-ADDER-CARRY-OUT C A B))))

(PROVE-LEMMA V-ALU-CORRECT-NAT-ADDER-OUTPUT
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-ADDER-OUTPUT C A B)
                             (V-ALU-NAT-ADDER-OUTPUT C A B))))

(PROVE-LEMMA V-ALU-CORRECT-NAT-ADDER
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (CVZBV-V-ADDER C A B)
                             (V-ALU-NAT-ADDER C A B)))
             ((DISABLE V-ADDER-CARRY-OUT V-ADDER-OVERFLOWP V-ADDER-OUTPUT
                       V-ALU-NAT-ADDER-CARRY-OUT V-ALU-NAT-ADDER-OUTPUT)))

(DEFN V-ALU-NAT-INC
      (A)
      (V-ALU-NAT-ADDER T A
                       (NAT-TO-V 0 (LENGTH A))))

(PROVE-LEMMA V-ALU-CORRECT-NAT-INC
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV-INC A)
                             (V-ALU-NAT-INC A)))
             ((DISABLE V-ALU-NAT-ADDER CVZBV-V-ADDER)))

(DEFN V-ALU-NAT-SUBTRACTER-OUTPUT
      (C A B)
      (NAT-TO-V (REMAINDER (DIFFERENCE (PLUS (V-TO-NAT B) (EXP 2 (LENGTH A)))
                                       (PLUS (V-TO-NAT A) (B-TO-NAT C)))
                           (EXP 2 (LENGTH A)))
                (LENGTH A)))

(DEFN V-ALU-NAT-SUBTRACTER-CARRY-OUT
      (C A B)
      (LESSP (V-TO-NAT B)
             (PLUS (V-TO-NAT A) (B-TO-NAT C))))

(DEFN V-ALU-NAT-SUBTRACTER
      (C A B)
      (CVZBV (V-ALU-NAT-SUBTRACTER-CARRY-OUT C A B)
             (V-SUBTRACTER-OVERFLOWP C A B)
             (V-ALU-NAT-SUBTRACTER-OUTPUT C A B)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-SUBTRACTER-CARRY-OUT C A B)
                             (V-ALU-NAT-SUBTRACTER-CARRY-OUT C A B)))
             ((ENABLE EQUAL-IFF)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-SUBTRACTER-OUTPUT C A B)
                             (V-ALU-NAT-SUBTRACTER-OUTPUT C A B))))

(PROVE-LEMMA V-ALU-CORRECT-NAT-SUBTRACTER
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (CVZBV-V-SUBTRACTER C A B)
                             (V-ALU-NAT-SUBTRACTER C A B)))
             ((DISABLE V-SUBTRACTER-CARRY-OUT V-SUBTRACTER-OVERFLOWP
                       V-SUBTRACTER-OUTPUT V-ALU-NAT-SUBTRACTER-CARRY-OUT
                       V-ALU-NAT-SUBTRACTER-OUTPUT)))

(DEFN V-ALU-NAT-DEC
      (A)
      (V-ALU-NAT-SUBTRACTER T
                            (NAT-TO-V 0 (LENGTH A))
                            A))

(PROVE-LEMMA V-ALU-CORRECT-NAT-DEC
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV-DEC A)
                             (V-ALU-NAT-DEC A)))
             ((DISABLE V-ALU-NAT-SUBTRACTER CVZBV-V-SUBTRACTER)))

(DEFN V-ALU-NAT-LSR-OUTPUT
      (A)
      (NAT-TO-V (QUOTIENT (V-TO-NAT A) 2)
                (LENGTH A)))

(DEFN V-ALU-NAT-LSR-CARRY-OUT
      (A)
      (NOT (EQUAL (REMAINDER (V-TO-NAT A) 2) 0)))

(DEFN V-ALU-NAT-LSR
      (A)
      (CVZBV (V-ALU-NAT-LSR-CARRY-OUT A)
             F
             (V-ALU-NAT-LSR-OUTPUT A)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-LSR-CARRY-OUT
             (REWRITE)
             (IMPLIES (AND (BVP A) (LISTP A))
                      (EQUAL (NTH 0 A)
                             (V-ALU-NAT-LSR-CARRY-OUT A)))
             ((ENABLE NTH V-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-LSR-OUTPUT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (V-LSR A)
                             (V-ALU-NAT-LSR-OUTPUT A)))
             ((ENABLE V-SHIFT-RIGHT V-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-LSR
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV-V-LSR A)
                             (V-ALU-NAT-LSR A)))
             ((DISABLE V-ALU-NAT-LSR-CARRY-OUT V-ALU-NAT-LSR-OUTPUT V-LSR)))

(DEFN V-ALU-NAT-NOT-OUTPUT
      (A)
      (NAT-TO-V (SUB1 (DIFFERENCE (EXP 2 (LENGTH A))
                                  (V-TO-NAT A)))
                (LENGTH A)))

(DEFN V-ALU-NAT-NOT
      (A)
      (CVZBV F F (V-ALU-NAT-NOT-OUTPUT A)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-NOT-OUTPUT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (V-NOT A)
                             (V-ALU-NAT-NOT-OUTPUT A))))

(PROVE-LEMMA V-ALU-CORRECT-NAT-NOT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV-V-NOT A)
                             (V-ALU-NAT-NOT A))))

(DEFN V-ALU-NAT
      (C A B OP)
      (COND ((EQUAL OP (LIST F F F F))
             (V-ALU-NAT-INT-BUF A))
            ((EQUAL OP (LIST T F F F))
             (V-ALU-NAT-INC A))
            ((EQUAL OP (LIST F T F F))
             (V-ALU-NAT-ADDER C A B))
            ((EQUAL OP (LIST T T F F))
             (V-ALU-NAT-ADDER F A B))
            ((EQUAL OP (LIST T F T F))
             (V-ALU-NAT-DEC A))
            ((EQUAL OP (LIST F T T F))
             (V-ALU-NAT-SUBTRACTER C A B))
            ((EQUAL OP (LIST T T T F))
             (V-ALU-NAT-SUBTRACTER F A B))
            ((EQUAL OP (LIST F T F T))
             (V-ALU-NAT-LSR A))
            ((EQUAL OP (LIST F T T T))
             (V-ALU-NAT-NOT A))
            (T (V-ALU C A B OP))))

(PROVE-LEMMA V-ALU-CORRECT-NAT NIL
             (IMPLIES (BV2P A B)
                      (EQUAL (V-ALU C A B OP)
                             (V-ALU-NAT C A B OP)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE V-ALU V-ALU-NAT BV2P V-ALU-CORRECT-NAT-INT-BUF
                      V-ALU-CORRECT-NAT-ADDER V-ALU-CORRECT-NAT-INC
                      V-ALU-CORRECT-NAT-SUBTRACTER V-ALU-CORRECT-NAT-DEC
                      V-ALU-CORRECT-NAT-LSR V-ALU-CORRECT-NAT-NOT)
              (DISABLE V-ALU-NAT-INT-BUF V-ALU-NAT-INC V-ALU-NAT-ADDER
                       V-ALU-NAT-DEC V-ALU-NAT-SUBTRACTER V-ALU-NAT-LSR
                       V-ALU-NAT-NOT)))

(DEFN INT-TO-V
      (I L)
      (IF (ILESSP I 0)
          (NAT-TO-V (IPLUS I (EXP 2 L)) L)
          (NAT-TO-V I L)))

(DEFN V-TO-INT
      (V)
      (IF (LESSP (V-TO-NAT V)
                 (EXP 2 (SUB1 (LENGTH V))))
          (V-TO-NAT V)
          (IDIFFERENCE (V-TO-NAT V)
                       (EXP 2 (LENGTH V)))))

(DEFN INTEGER-IN-RANGEP
      (I L)
      (AND (ILEQ (INEG (EXP 2 (SUB1 L))) I)
           (ILESSP I (EXP 2 (SUB1 L)))))

(PROVE-LEMMA IPLUS-PLUS
             (REWRITE)
             (IMPLIES (AND (NUMBERP X) (NUMBERP Y))
                      (EQUAL (IPLUS X Y) (PLUS X Y)))
             ((ENABLE IPLUS)))

(PROVE-LEMMA ILESSP-LESSP
             (REWRITE)
             (IMPLIES (AND (NUMBERP X) (NUMBERP Y))
                      (EQUAL (ILESSP X Y) (LESSP X Y)))
             ((ENABLE ILESSP)))

(PROVE-LEMMA TIMES-2
             (REWRITE)
             (EQUAL (TIMES 2 X) (PLUS X X)))

(PROVE-LEMMA B-TO-NAT-LEQ
             (REWRITE)
             (NOT (LESSP 1 (B-TO-NAT X))))

(PROVE-LEMMA LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (EQUAL (LENGTH A) (LENGTH B))
                           (NOT (EQUAL (LENGTH B) 0)))
                      (LESSP (V-TO-NAT A)
                             (PLUS (EXP 2 (SUB1 (LENGTH B)))
                                   (EXP 2 (SUB1 (LENGTH B))))))
             ((USE (LESSP-V-TO-NAT-EXP))
              (DISABLE LESSP-V-TO-NAT-EXP-REWRITE)))

(PROVE-LEMMA FIX-INT-NUMBERP
             (REWRITE)
             (IMPLIES (NUMBERP X)
                      (EQUAL (FIX-INT X) X))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IPLUS3-PLUS-DIFFERENCE
             (REWRITE)
             (IMPLIES (AND (NUMBERP C0)
                           (NUMBERP A0)
                           (NUMBERP B0)
                           (NUMBERP D)
                           (NOT (LESSP (PLUS C0 A0 B0) D)))
                      (EQUAL (IPLUS C0
                                    (IPLUS A0 (IPLUS B0 (INEG D))))
                             (DIFFERENCE (PLUS C0 A0 B0) D)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA V-TO-INT-V-NOT
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-TO-INT (V-NOT A))
                             (IPLUS -1 (INEG (V-TO-INT A)))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(TOGGLE V-ALU-CORRECT-NAT-NOT-OUTPUT-OFF V-ALU-CORRECT-NAT-NOT-OUTPUT T)

(PROVE-LEMMA V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-LEMMA
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (IPLUS (B-TO-NAT (B-NOT C))
                                    (IPLUS (V-TO-INT (V-NOT A))
                                           (V-TO-INT B)))
                             (IDIFFERENCE (V-TO-INT B)
                                          (IPLUS (V-TO-INT A) (B-TO-NAT C)))))
             ((ENABLE-THEORY INTEGER-DEFNS)
              (DISABLE V-TO-INT)))

(PROVE-LEMMA IDIFFERENCE-DIFFERENCE
             (REWRITE)
             (IMPLIES (AND (NUMBERP X)
                           (NUMBERP Y)
                           (NOT (LESSP X Y)))
                      (AND (EQUAL (IPLUS X (INEG Y))
                                  (DIFFERENCE X Y))
                           (EQUAL (IPLUS (INEG Y) X)
                                  (DIFFERENCE X Y))))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IDIV-QUOTIENT
             (REWRITE)
             (IMPLIES (AND (NUMBERP X) (NUMBERP Y))
                      (EQUAL (IDIV X Y) (QUOTIENT X Y)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA IDIV-ILESSP-0
             (REWRITE)
             (IMPLIES (AND (NUMBERP Y) (NOT (EQUAL Y 0)))
                      (EQUAL (ILESSP (IDIV X Y) 0)
                             (ILESSP X 0)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(PROVE-LEMMA QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG
             (REWRITE)
             (EQUAL (QUOTIENT (PLUS X X Y) 2)
                    (PLUS X (QUOTIENT Y 2)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE PLUS-ADD1)))

(PROVE-LEMMA PLUS-QUOTIENT-2-LEMMA
             (REWRITE)
             (EQUAL (QUOTIENT (PLUS V (TIMES 2 Z)) 2)
                    (PLUS Z (QUOTIENT V 2))))

(PROVE-LEMMA PLUS-QUOTIENT-2
             (REWRITE)
             (IMPLIES (NOT (LESSP A0 EXP))
                      (EQUAL (PLUS EXP
                                   (QUOTIENT (DIFFERENCE A0 EXP) 2))
                             (QUOTIENT (PLUS A0 EXP) 2)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG LESSP-REMAINDER
                      REMAINDER-QUOTIENT-ELIM DIFFERENCE-ELIM
                      ASSOCIATIVITY-OF-PLUS PLUS-QUOTIENT-2-LEMMA
                      COMMUTATIVITY-OF-PLUS COMMUTATIVITY2-OF-PLUS)))

(PROVE-LEMMA IPLUS-DIV-HACK1
             (REWRITE)
             (IMPLIES (AND (NUMBERP A0) (NUMBERP EXP))
                      (EQUAL (IPLUS (IDIV (IPLUS A0 (INEG EXP)) 2)
                                    EXP)
                             (QUOTIENT (PLUS A0 EXP) 2)))
             ((ENABLE-THEORY INTEGER-DEFNS)))

(TOGGLE QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG-OFF
        QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG T)

(TOGGLE PLUS-QUOTIENT-2-LEMMA-OFF PLUS-QUOTIENT-2-LEMMA T)

(TOGGLE PLUS-QUOTIENT-2-OFF PLUS-QUOTIENT-2 T)

(PROVE-LEMMA LESSP-QUOTIENT-2
             (REWRITE)
             (IFF (LESSP (QUOTIENT X 2) Y)
                  (LESSP X (PLUS Y Y))))

(DEFN V-ALU-INT-ADDER-OUTPUT
      (C A B)
      (INT-TO-V (IPLUS (B-TO-NAT C)
                       (IPLUS (V-TO-INT A) (V-TO-INT B)))
                (LENGTH A)))

(DEFN V-ALU-INT-ADDER-OVERFLOWP
      (C A B)
      (NOT (INTEGER-IN-RANGEP (IPLUS (B-TO-NAT C)
                                     (IPLUS (V-TO-INT A) (V-TO-INT B)))
                              (LENGTH A))))

(DEFN V-ALU-INT-ADDER
      (C A B)
      (CVZBV (V-ADDER-CARRY-OUT C A B)
             (V-ALU-INT-ADDER-OVERFLOWP C A B)
             (V-ALU-INT-ADDER-OUTPUT C A B)))

(PROVE-LEMMA V-ALU-CORRECT-INT-ADDER-OVERFLOWP
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-ADDER-OVERFLOWP C A B)
                             (V-ALU-INT-ADDER-OVERFLOWP C A B)))
             ((ENABLE-THEORY INTEGER-METAS NATURALS-METAS)
              (DISABLE V-ADDER-OUTPUT B-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-INT-ADDER-OUTPUT
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-ADDER-OUTPUT C A B)
                             (V-ALU-INT-ADDER-OUTPUT C A B)))
             ((ENABLE-THEORY INTEGER-METAS NATURALS-METAS)
              (DISABLE V-ADDER-OUTPUT B-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-INT-ADDER
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-V-ADDER C A B)
                             (V-ALU-INT-ADDER C A B)))
             ((DISABLE V-ADDER-CARRY-OUT V-ADDER-OVERFLOWP V-ADDER-OUTPUT
                       V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT
                       V-ALU-CORRECT-NAT-ADDER)))

(DEFN V-ALU-INT-INC
      (A)
      (V-ALU-INT-ADDER T A
                       (INT-TO-V 0 (LENGTH A))))

(PROVE-LEMMA V-ALU-CORRECT-INT-INC
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-INC A)
                             (V-ALU-INT-INC A)))
             ((DISABLE V-ALU-CORRECT-NAT-INC V-ALU-INT-ADDER CVZBV-V-ADDER)))

(DEFN V-ALU-INT-SUBTRACTER-OUTPUT
      (C A B)
      (INT-TO-V (IDIFFERENCE (V-TO-INT B)
                             (IPLUS (V-TO-INT A) (B-TO-NAT C)))
                (LENGTH A)))

(DEFN V-ALU-INT-SUBTRACTER-OVERFLOWP
      (C A B)
      (NOT (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT B)
                                           (IPLUS (V-TO-INT A) (B-TO-NAT C)))
                              (LENGTH A))))

(DEFN V-ALU-INT-SUBTRACTER
      (C A B)
      (CVZBV (V-SUBTRACTER-CARRY-OUT C A B)
             (V-ALU-INT-SUBTRACTER-OVERFLOWP C A B)
             (V-ALU-INT-SUBTRACTER-OUTPUT C A B)))

(PROVE-LEMMA V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-SUBTRACTER-OVERFLOWP C A B)
                             (V-ALU-INT-SUBTRACTER-OVERFLOWP C A B)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE BV2P V-ALU-CORRECT-INT-ADDER-OVERFLOWP BVP-V-NOT
                      LENGTH-V-NOT V-ALU-INT-ADDER-OVERFLOWP
                      V-ALU-INT-SUBTRACTER-OVERFLOWP V-SUBTRACTER-OVERFLOWP
                      V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-LEMMA)))

(PROVE-LEMMA V-ALU-CORRECT-INT-SUBTRACTER-OUTPUT
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-SUBTRACTER-OUTPUT C A B)
                             (V-ALU-INT-SUBTRACTER-OUTPUT C A B)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE V-SUBTRACTER-OUTPUT V-ALU-CORRECT-INT-ADDER-OUTPUT
                      V-ALU-INT-SUBTRACTER-OUTPUT V-ALU-INT-ADDER-OUTPUT
                      V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-LEMMA
                      LENGTH-V-NOT BV2P BVP-V-NOT)))

(PROVE-LEMMA V-ALU-CORRECT-INT-SUBTRACTER
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-V-SUBTRACTER C A B)
                             (V-ALU-INT-SUBTRACTER C A B)))
             ((DISABLE V-SUBTRACTER-CARRY-OUT V-SUBTRACTER-OVERFLOWP
                       V-SUBTRACTER-OUTPUT V-ALU-INT-SUBTRACTER-OVERFLOWP
                       V-ALU-INT-SUBTRACTER-OUTPUT
                       V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT
                       V-ALU-CORRECT-NAT-SUBTRACTER)))

(DEFN V-ALU-INT-DEC
      (A)
      (V-ALU-INT-SUBTRACTER T
                            (INT-TO-V 0 (LENGTH A))
                            A))

(PROVE-LEMMA V-ALU-CORRECT-INT-DEC
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-DEC A)
                             (V-ALU-INT-DEC A)))
             ((DISABLE V-ALU-INT-SUBTRACTER CVZBV-V-SUBTRACTER
                       V-ALU-CORRECT-NAT-DEC V-ALU-CORRECT-NAT-SUBTRACTER)))

(DEFN V-ALU-INT-ASR-OUTPUT
      (A)
      (INT-TO-V (IDIV (V-TO-INT A) 2)
                (LENGTH A)))

(DEFN V-ALU-INT-ASR
      (A)
      (CVZBV (V-ALU-NAT-LSR-CARRY-OUT A)
             F
             (V-ALU-INT-ASR-OUTPUT A)))

(PROVE-LEMMA V-ALU-CORRECT-INT-ASR-OUTPUT
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-ASR A)
                             (V-ALU-INT-ASR-OUTPUT A)))
             ((ENABLE-THEORY INTEGER-METAS NATURALS-METAS)
              (ENABLE V-SHIFT-RIGHT V-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-INT-ASR
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (CVZBV-V-ASR A)
                             (V-ALU-INT-ASR A)))
             ((DISABLE V-ALU-NAT-LSR-CARRY-OUT V-ALU-NAT-LSR-OUTPUT V-LSR)))

(DEFN V-ALU-INT-NEG
      (A)
      (V-ALU-INT-SUBTRACTER F A
                            (INT-TO-V 0 (LENGTH A))))

(PROVE-LEMMA V-ALU-CORRECT-INT-NEG
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-NEG A)
                             (V-ALU-INT-NEG A)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE *1*ILESSP CVZBV-NEG V-ALU-INT-NEG INT-TO-V
                      V-ALU-CORRECT-INT-SUBTRACTER BV2P BVP-NAT-TO-V
                      LENGTH-NAT-TO-V)))

(DEFN V-ALU-INT-NOT-OUTPUT
      (A)
      (V-ALU-INT-SUBTRACTER-OUTPUT T A
                                   (INT-TO-V 0 (LENGTH A))))

(DEFN V-ALU-INT-NOT
      (A)
      (CVZBV F F (V-ALU-INT-NOT-OUTPUT A)))

(PROVE-LEMMA V-ALU-CORRECT-INT-NOT-OUTPUT
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-NOT A)
                             (V-ALU-INT-NOT-OUTPUT A)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO INTEGER-DEFNS NATURALS)
              (ENABLE LESSP-V-TO-NAT-EXP V-TO-NAT-OF-NAT-TO-V LENGTH-NAT-TO-V
                      V-ALU-CORRECT-NAT-NOT-OUTPUT V-ALU-NAT-NOT-OUTPUT
                      V-ALU-INT-NOT-OUTPUT V-ALU-INT-SUBTRACTER-OUTPUT
                      INT-TO-V V-TO-INT IDIFFERENCE ILEQ B-TO-NAT *1*B-TO-NAT)))

(PROVE-LEMMA V-ALU-CORRECT-INT-NOT
             (REWRITE)
             (IMPLIES (AND (BVP A)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (CVZBV-V-NOT A)
                             (V-ALU-INT-NOT A))))

(DEFN V-ALU-INT
      (C A B OP)
      (COND ((EQUAL OP (LIST F F F F))
             (V-ALU-NAT-INT-BUF A))
            ((EQUAL OP (LIST T F F F))
             (V-ALU-INT-INC A))
            ((EQUAL OP (LIST F T F F))
             (V-ALU-INT-ADDER C A B))
            ((EQUAL OP (LIST T T F F))
             (V-ALU-INT-ADDER F A B))
            ((EQUAL OP (LIST F F T F))
             (V-ALU-INT-NEG A))
            ((EQUAL OP (LIST T F T F))
             (V-ALU-INT-DEC A))
            ((EQUAL OP (LIST F T T F))
             (V-ALU-INT-SUBTRACTER C A B))
            ((EQUAL OP (LIST T T T F))
             (V-ALU-INT-SUBTRACTER F A B))
            ((EQUAL OP (LIST T F F T))
             (V-ALU-INT-ASR A))
            ((EQUAL OP (LIST F T T T))
             (V-ALU-INT-NOT A))
            (T (V-ALU C A B OP))))

(PROVE-LEMMA V-ALU-CORRECT-INT NIL
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-ALU C A B OP)
                             (V-ALU-INT C A B OP)))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE V-ALU V-ALU-INT BV2P V-ALU-CORRECT-NAT-INT-BUF
                      V-ALU-CORRECT-INT-ADDER V-ALU-CORRECT-INT-INC
                      V-ALU-CORRECT-INT-SUBTRACTER V-ALU-CORRECT-INT-DEC
                      V-ALU-CORRECT-INT-ASR V-ALU-CORRECT-INT-NEG
                      V-ALU-CORRECT-INT-NOT)
              (DISABLE V-ALU-NAT-INT-BUF V-ALU-INT-INC V-ALU-INT-ADDER
                       V-ALU-INT-DEC V-ALU-INT-SUBTRACTER V-ALU-INT-ASR
                       V-ALU-CORRECT-NAT)))

(TOGGLE V-ALU-CORRECT-NAT-INT-BUF-OFF V-ALU-CORRECT-NAT-INT-BUF T)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-CARRY-OUT-OFF V-ALU-CORRECT-NAT-ADDER-CARRY-OUT
        T)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-OUTPUT-OFF V-ALU-CORRECT-NAT-ADDER-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-OFF V-ALU-CORRECT-NAT-ADDER T)

(TOGGLE V-ALU-CORRECT-NAT-INC-OFF V-ALU-CORRECT-NAT-INC T)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT-OFF
        V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT T)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT-OFF
        V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-OFF V-ALU-CORRECT-NAT-SUBTRACTER T)

(TOGGLE V-ALU-CORRECT-NAT-DEC-OFF V-ALU-CORRECT-NAT-DEC T)

(TOGGLE V-ALU-CORRECT-NAT-LSR-CARRY-OUT-OFF V-ALU-CORRECT-NAT-LSR-CARRY-OUT T)

(TOGGLE V-ALU-CORRECT-NAT-LSR-OUTPUT-OFF V-ALU-CORRECT-NAT-LSR-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-LSR-OFF V-ALU-CORRECT-NAT-LSR T)

(TOGGLE V-ALU-CORRECT-NAT-NOT-OUTPUT-OFF1 V-ALU-CORRECT-NAT-NOT-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-NOT-OFF V-ALU-CORRECT-NAT-NOT T)

(TOGGLE V-ALU-CORRECT-INT-ADDER-OVERFLOWP-OFF V-ALU-CORRECT-INT-ADDER-OVERFLOWP
        T)

(TOGGLE V-ALU-CORRECT-INT-ADDER-OUTPUT-OFF V-ALU-CORRECT-INT-ADDER-OUTPUT T)

(TOGGLE V-ALU-CORRECT-INT-ADDER-OFF V-ALU-CORRECT-INT-ADDER T)

(TOGGLE V-ALU-CORRECT-INT-INC-OFF V-ALU-CORRECT-INT-INC T)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-OFF
        V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP T)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OUTPUT-OFF
        V-ALU-CORRECT-INT-SUBTRACTER-OUTPUT T)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OFF V-ALU-CORRECT-INT-SUBTRACTER T)

(TOGGLE V-ALU-CORRECT-INT-DEC-OFF V-ALU-CORRECT-INT-DEC T)

(TOGGLE V-ALU-CORRECT-INT-ASR-OUTPUT-OFF V-ALU-CORRECT-INT-ASR-OUTPUT T)

(TOGGLE V-ALU-CORRECT-INT-ASR-OFF V-ALU-CORRECT-INT-ASR T)

(TOGGLE V-ALU-CORRECT-INT-NEG-OFF V-ALU-CORRECT-INT-NEG T)

(TOGGLE V-ALU-CORRECT-INT-NOT-OFF V-ALU-CORRECT-INT-NOT T)

(TOGGLE V-ALU-CORRECT-INT-OFF V-ALU-CORRECT-INT T)

(TOGGLE V-ALU-INT-OFF V-ALU-INT T)

(TOGGLE G*1*V-ALU-INT-OFF *1*V-ALU-INT T)

(TOGGLE V-ALU-CORRECT-INT-NOT-OUTPUT-OFF V-ALU-CORRECT-INT-NOT-OUTPUT T)

(TOGGLE V-ALU-INT-NOT-OFF V-ALU-INT-NOT T)

(TOGGLE G*1*V-ALU-INT-NOT-OFF *1*V-ALU-INT-NOT T)

(TOGGLE V-ALU-INT-NOT-OUTPUT-OFF V-ALU-INT-NOT-OUTPUT T)

(TOGGLE G*1*V-ALU-INT-NOT-OUTPUT-OFF *1*V-ALU-INT-NOT-OUTPUT T)

(TOGGLE V-ALU-INT-NEG-OFF V-ALU-INT-NEG T)

(TOGGLE G*1*V-ALU-INT-NEG-OFF *1*V-ALU-INT-NEG T)

(TOGGLE V-ALU-INT-ASR-OFF V-ALU-INT-ASR T)

(TOGGLE G*1*V-ALU-INT-ASR-OFF *1*V-ALU-INT-ASR T)

(TOGGLE V-ALU-INT-ASR-OUTPUT-OFF V-ALU-INT-ASR-OUTPUT T)

(TOGGLE G*1*V-ALU-INT-ASR-OUTPUT-OFF *1*V-ALU-INT-ASR-OUTPUT T)

(TOGGLE V-ALU-INT-DEC-OFF V-ALU-INT-DEC T)

(TOGGLE G*1*V-ALU-INT-DEC-OFF *1*V-ALU-INT-DEC T)

(TOGGLE V-ALU-INT-SUBTRACTER-OFF V-ALU-INT-SUBTRACTER T)

(TOGGLE G*1*V-ALU-INT-SUBTRACTER-OFF *1*V-ALU-INT-SUBTRACTER T)

(TOGGLE V-ALU-INT-SUBTRACTER-OVERFLOWP-OFF V-ALU-INT-SUBTRACTER-OVERFLOWP T)

(TOGGLE G*1*V-ALU-INT-SUBTRACTER-OVERFLOWP-OFF
        *1*V-ALU-INT-SUBTRACTER-OVERFLOWP T)

(TOGGLE V-ALU-INT-SUBTRACTER-OUTPUT-OFF V-ALU-INT-SUBTRACTER-OUTPUT T)

(TOGGLE G*1*V-ALU-INT-SUBTRACTER-OUTPUT-OFF *1*V-ALU-INT-SUBTRACTER-OUTPUT T)

(TOGGLE V-ALU-INT-INC-OFF V-ALU-INT-INC T)

(TOGGLE G*1*V-ALU-INT-INC-OFF *1*V-ALU-INT-INC T)

(TOGGLE V-ALU-INT-ADDER-OFF V-ALU-INT-ADDER T)

(TOGGLE G*1*V-ALU-INT-ADDER-OFF *1*V-ALU-INT-ADDER T)

(TOGGLE V-ALU-INT-ADDER-OVERFLOWP-OFF V-ALU-INT-ADDER-OVERFLOWP T)

(TOGGLE G*1*V-ALU-INT-ADDER-OVERFLOWP-OFF *1*V-ALU-INT-ADDER-OVERFLOWP T)

(TOGGLE V-ALU-INT-ADDER-OUTPUT-OFF V-ALU-INT-ADDER-OUTPUT T)

(TOGGLE G*1*V-ALU-INT-ADDER-OUTPUT-OFF *1*V-ALU-INT-ADDER-OUTPUT T)

(TOGGLE LESSP-QUOTIENT-2-OFF LESSP-QUOTIENT-2 T)

(TOGGLE IPLUS-DIV-HACK1-OFF IPLUS-DIV-HACK1 T)

(TOGGLE IDIV-ILESSP-0-OFF IDIV-ILESSP-0 T)

(TOGGLE IDIV-QUOTIENT-OFF IDIV-QUOTIENT T)

(TOGGLE IDIFFERENCE-DIFFERENCE-OFF IDIFFERENCE-DIFFERENCE T)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-LEMMA-OFF
        V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-LEMMA T)

(TOGGLE V-TO-INT-V-NOT-OFF V-TO-INT-V-NOT T)

(TOGGLE IPLUS3-PLUS-DIFFERENCE-OFF IPLUS3-PLUS-DIFFERENCE T)

(TOGGLE FIX-INT-NUMBERP-OFF FIX-INT-NUMBERP T)

(TOGGLE LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED-OFF
        LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED T)

(TOGGLE B-TO-NAT-LEQ-OFF B-TO-NAT-LEQ T)

(TOGGLE TIMES-2-OFF TIMES-2 T)

(TOGGLE ILESSP-LESSP-OFF ILESSP-LESSP T)

(TOGGLE IPLUS-PLUS-OFF IPLUS-PLUS T)

(TOGGLE INTEGER-IN-RANGEP-OFF INTEGER-IN-RANGEP T)

(TOGGLE G*1*INTEGER-IN-RANGEP-OFF *1*INTEGER-IN-RANGEP T)

(TOGGLE V-TO-INT-OFF V-TO-INT T)

(TOGGLE G*1*V-TO-INT-OFF *1*V-TO-INT T)

(TOGGLE INT-TO-V-OFF INT-TO-V T)

(TOGGLE G*1*INT-TO-V-OFF *1*INT-TO-V T)

(TOGGLE V-ALU-CORRECT-NAT-OFF V-ALU-CORRECT-NAT T)

(TOGGLE V-ALU-NAT-OFF V-ALU-NAT T)

(TOGGLE G*1*V-ALU-NAT-OFF *1*V-ALU-NAT T)

(TOGGLE V-ALU-NAT-NOT-OFF V-ALU-NAT-NOT T)

(TOGGLE G*1*V-ALU-NAT-NOT-OFF *1*V-ALU-NAT-NOT T)

(TOGGLE V-ALU-NAT-NOT-OUTPUT-OFF V-ALU-NAT-NOT-OUTPUT T)

(TOGGLE G*1*V-ALU-NAT-NOT-OUTPUT-OFF *1*V-ALU-NAT-NOT-OUTPUT T)

(TOGGLE V-ALU-NAT-LSR-OFF V-ALU-NAT-LSR T)

(TOGGLE G*1*V-ALU-NAT-LSR-OFF *1*V-ALU-NAT-LSR T)

(TOGGLE V-ALU-NAT-LSR-CARRY-OUT-OFF V-ALU-NAT-LSR-CARRY-OUT T)

(TOGGLE G*1*V-ALU-NAT-LSR-CARRY-OUT-OFF *1*V-ALU-NAT-LSR-CARRY-OUT T)

(TOGGLE V-ALU-NAT-LSR-OUTPUT-OFF V-ALU-NAT-LSR-OUTPUT T)

(TOGGLE G*1*V-ALU-NAT-LSR-OUTPUT-OFF *1*V-ALU-NAT-LSR-OUTPUT T)

(TOGGLE V-ALU-NAT-DEC-OFF V-ALU-NAT-DEC T)

(TOGGLE G*1*V-ALU-NAT-DEC-OFF *1*V-ALU-NAT-DEC T)

(TOGGLE V-ALU-NAT-SUBTRACTER-OFF V-ALU-NAT-SUBTRACTER T)

(TOGGLE G*1*V-ALU-NAT-SUBTRACTER-OFF *1*V-ALU-NAT-SUBTRACTER T)

(TOGGLE V-ALU-NAT-SUBTRACTER-CARRY-OUT-OFF V-ALU-NAT-SUBTRACTER-CARRY-OUT T)

(TOGGLE G*1*V-ALU-NAT-SUBTRACTER-CARRY-OUT-OFF
        *1*V-ALU-NAT-SUBTRACTER-CARRY-OUT T)

(TOGGLE V-ALU-NAT-SUBTRACTER-OUTPUT-OFF V-ALU-NAT-SUBTRACTER-OUTPUT T)

(TOGGLE G*1*V-ALU-NAT-SUBTRACTER-OUTPUT-OFF *1*V-ALU-NAT-SUBTRACTER-OUTPUT T)

(TOGGLE V-ALU-NAT-INC-OFF V-ALU-NAT-INC T)

(TOGGLE G*1*V-ALU-NAT-INC-OFF *1*V-ALU-NAT-INC T)

(TOGGLE V-ALU-NAT-ADDER-OFF V-ALU-NAT-ADDER T)

(TOGGLE G*1*V-ALU-NAT-ADDER-OFF *1*V-ALU-NAT-ADDER T)

(TOGGLE V-ALU-NAT-ADDER-CARRY-OUT-OFF V-ALU-NAT-ADDER-CARRY-OUT T)

(TOGGLE G*1*V-ALU-NAT-ADDER-CARRY-OUT-OFF *1*V-ALU-NAT-ADDER-CARRY-OUT T)

(TOGGLE V-ALU-NAT-ADDER-OUTPUT-OFF V-ALU-NAT-ADDER-OUTPUT T)

(TOGGLE G*1*V-ALU-NAT-ADDER-OUTPUT-OFF *1*V-ALU-NAT-ADDER-OUTPUT T)

(TOGGLE V-TO-NAT-APPEND-OFF V-TO-NAT-APPEND T)

(TOGGLE NOT-LESSP-QUOTIENT-OFF NOT-LESSP-QUOTIENT T)

(TOGGLE LESSP-V-TO-NAT-EXP-REWRITE-OFF LESSP-V-TO-NAT-EXP-REWRITE T)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT-LEMMA-OFF
        V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT-LEMMA T)

(TOGGLE LESSP-V-TO-NAT-EXP-OFF LESSP-V-TO-NAT-EXP T)

(TOGGLE V-TO-NAT-V-NOT-OFF V-TO-NAT-V-NOT T)

(TOGGLE V-TO-NAT-V-NOT-LEMMA-OFF V-TO-NAT-V-NOT-LEMMA T)

(TOGGLE EQUAL-NAT-TO-V-INVERTER-OFF EQUAL-NAT-TO-V-INVERTER T)

(TOGGLE NAT-TO-V-REMAINDER-OFF NAT-TO-V-REMAINDER T)

(TOGGLE EQUAL-NAT-TO-V-INVERTER-HACK2-LEMMA-OFF
        EQUAL-NAT-TO-V-INVERTER-HACK2-LEMMA T)

(TOGGLE NAT-TO-V-ZEROP-OFF NAT-TO-V-ZEROP T)

(TOGGLE NAT-TO-V-OF-V-TO-NAT-OFF NAT-TO-V-OF-V-TO-NAT T)

(TOGGLE FIRSTN-LENGTH-OFF FIRSTN-LENGTH T)

(TOGGLE NAT-TO-V-OF-V-TO-NAT-GENERAL-OFF NAT-TO-V-OF-V-TO-NAT-GENERAL T)

(TOGGLE FIRSTN-NLISTP-OFF FIRSTN-NLISTP T)

(TOGGLE FIRSTN-ZEROP-OFF FIRSTN-ZEROP T)

(TOGGLE FIRSTN-ADD1-CONS-OFF FIRSTN-ADD1-CONS T)

(TOGGLE NAT-TO-V-PLUS-X-X-OFF NAT-TO-V-PLUS-X-X T)

(TOGGLE QUOTIENT-PLUS-X-X-2-OFF QUOTIENT-PLUS-X-X-2 T)

(TOGGLE REMAINDER-PLUS-X-X-2-OFF REMAINDER-PLUS-X-X-2 T)

(TOGGLE V-TO-NAT-OF-NAT-TO-V-OFF V-TO-NAT-OF-NAT-TO-V T)

(TOGGLE V-TO-NAT-OF-NAT-TO-V-HACK-OFF V-TO-NAT-OF-NAT-TO-V-HACK T)

(TOGGLE V-TO-NAT-FIRSTN-OFF V-TO-NAT-FIRSTN T)

(TOGGLE REMAINDER-ADD1-PLUS-MULTIPLE-OFF REMAINDER-ADD1-PLUS-MULTIPLE T)

(TOGGLE DIVIDES-PLUS-PLUS-OFF DIVIDES-PLUS-PLUS T)

(TOGGLE REMAINDER-PLUS-MULTIPLE-OFF REMAINDER-PLUS-MULTIPLE T)

(TOGGLE NTH-LENGTH-V-OFF NTH-LENGTH-V T)

(TOGGLE V-ALU-NAT-INT-BUF-OFF V-ALU-NAT-INT-BUF T)

(TOGGLE G*1*V-ALU-NAT-INT-BUF-OFF *1*V-ALU-NAT-INT-BUF T)

(TOGGLE BVP-CDR-OFF BVP-CDR T)

(TOGGLE B-TO-NAT-OFF B-TO-NAT T)

(TOGGLE G*1*B-TO-NAT-OFF *1*B-TO-NAT T)

(TOGGLE MAP-DOWN-INVERTS-MAP-UP-OFF1 MAP-DOWN-INVERTS-MAP-UP T)

(TOGGLE FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP-OFF1
        FOR-FINAL-1-OF-RESET-SEQUENCE-CHIP T)

(TOGGLE CHIP-WELL-FORMED-SIMPLE-ON CHIP-WELL-FORMED-SIMPLE NIL)

(TOGGLE CHIP-WELL-FORMED-AFTER-INDEXED-NAMES-REMOVED-ON
        CHIP-WELL-FORMED-AFTER-INDEXED-NAMES-REMOVED NIL)

(TOGGLE CHIP-WELL-FORMED-ON CHIP-WELL-FORMED NIL)

(TOGGLE CHIP-SYSTEM=FM9001-INTERPRETER$AFTER-RESET-ON
        CHIP-SYSTEM=FM9001-INTERPRETER$AFTER-RESET NIL)

(TOGGLE RESET-CHIP-FROM-ANY-STATE-ON RESET-CHIP-FROM-ANY-STATE NIL)

(TOGGLE RESET-CHIP-ON RESET-CHIP NIL)

(TOGGLE LENGTH-RESET-SEQUENCE-CHIP-1-ON LENGTH-RESET-SEQUENCE-CHIP-1 NIL)

(TOGGLE SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2-ON
        SIMULATE-CONTAINS-SIMULATE-DUAL-EVAL-2 NIL)

(TOGGLE FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-ON
        FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET NIL)

(TOGGLE CADR-MAP-UP-ON CADR-MAP-UP NIL)

(TOGGLE FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA-ON
        FM9001=CHIP-SYSTEM-TRUE-AFTER-RESET-LEMMA NIL)

(TOGGLE FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE-ON
        FM9001-STATEP-IMPLIES-MEMORY-OK-P-INSTANCE NIL)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IMPLIES-MACHINE-STATE-INVARIANT-ON
        NEW-MACHINE-STATE-INVARIANT-IMPLIES-MACHINE-STATE-INVARIANT NIL)

(TOGGLE MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP-ON
        MEMORY-V-FOURP-IMPLIES-MEMORY-PROPERP NIL)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IS-NON-TRIVIAL-ON
        NEW-MACHINE-STATE-INVARIANT-IS-NON-TRIVIAL NIL)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-BETTER-ON
        XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-BETTER NIL)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE-ON
        XS-SUFFICE-FOR-RESET-CHIP-FINAL-STATE-FOR-ANY-UNKNOWN-STATE NIL)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S-ON
        NEW-MACHINE-STATE-INVARIANT-IMPLIES-GOOD-S NIL)

(TOGGLE V-FOURP-IS-GOOD-S-ON V-FOURP-IS-GOOD-S NIL)

(TOGGLE MEMORY-V-FOURP-IMPLIES-GOOD-S-ON MEMORY-V-FOURP-IMPLIES-GOOD-S NIL)

(TOGGLE GOOD-S-OPENER-ON GOOD-S-OPENER NIL)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-ON
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX NIL)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3-ON
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-3 NIL)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2-ON
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-2 NIL)

(TOGGLE MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA-ON
        MACHINE-STATE-INVARIANT-IMPLIES-S-APPROX-LEMMA NIL)

(TOGGLE B-APPROX-X-ON B-APPROX-X NIL)

(TOGGLE STUBP-IMPLIES-NOT-FOURP-ON STUBP-IMPLIES-NOT-FOURP NIL)

(TOGGLE ROMP-IMPLIES-NOT-FOURP-ON ROMP-IMPLIES-NOT-FOURP NIL)

(TOGGLE RAMP-IMPLIES-NOT-FOURP-ON RAMP-IMPLIES-NOT-FOURP NIL)

(TOGGLE LISTP-IMPLIES-NOT-FOURP-ON LISTP-IMPLIES-NOT-FOURP NIL)

(TOGGLE V-FOURP-IMPLIES-PROPERP-ON V-FOURP-IMPLIES-PROPERP NIL)

(TOGGLE S-APPROX-MAKE-LIST-ON S-APPROX-MAKE-LIST NIL)

(TOGGLE NEW-MACHINE-STATE-INVARIANT-ON NEW-MACHINE-STATE-INVARIANT NIL)

(TOGGLE G*1*NEW-MACHINE-STATE-INVARIANT-ON *1*NEW-MACHINE-STATE-INVARIANT NIL)

(TOGGLE MEMORY-V-FOURP-ON MEMORY-V-FOURP NIL)

(TOGGLE G*1*MEMORY-V-FOURP-ON *1*MEMORY-V-FOURP NIL)

(TOGGLE ALL-XS-MAKE-LIST-ON ALL-XS-MAKE-LIST NIL)

(TOGGLE ALL-XS-APPROXIMATES-ON ALL-XS-APPROXIMATES NIL)

(TOGGLE ALL-XS-ON ALL-XS NIL)

(TOGGLE G*1*ALL-XS-ON *1*ALL-XS NIL)

(TOGGLE V-FOURP-ON V-FOURP NIL)

(TOGGLE G*1*V-FOURP-ON *1*V-FOURP NIL)

(TOGGLE FM9001-MACHINE-STATEP-P-MAP-UP-INITIALIZED-MACHINE-STATE-ON
        FM9001-MACHINE-STATEP-P-MAP-UP-INITIALIZED-MACHINE-STATE NIL)

(TOGGLE XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE-ON
        XS-SUFFICE-FOR-RESET-CHIP-LEMMA-INSTANCE NIL)

(TOGGLE SIMULATE-RESET-CHIP-FINAL-STATE-ON SIMULATE-RESET-CHIP-FINAL-STATE NIL)

(TOGGLE RESET-SEQUENCE-CHIP-1-VS-2-ON RESET-SEQUENCE-CHIP-1-VS-2 NIL)

(TOGGLE RESET-SEQUENCE-CHIP-2-ON RESET-SEQUENCE-CHIP-2 NIL)

(TOGGLE G*1*RESET-SEQUENCE-CHIP-2-ON *1*RESET-SEQUENCE-CHIP-2 NIL)

(TOGGLE RESET-SEQUENCE-CHIP-1-ON RESET-SEQUENCE-CHIP-1 NIL)

(TOGGLE G*1*RESET-SEQUENCE-CHIP-1-ON *1*RESET-SEQUENCE-CHIP-1 NIL)

(TOGGLE RUN-VECTOR-CHIP-2-ON RUN-VECTOR-CHIP-2 NIL)

(TOGGLE G*1*RUN-VECTOR-CHIP-2-ON *1*RUN-VECTOR-CHIP-2 NIL)

(TOGGLE RUN-VECTOR-CHIP-1-ON RUN-VECTOR-CHIP-1 NIL)

(TOGGLE G*1*RUN-VECTOR-CHIP-1-ON *1*RUN-VECTOR-CHIP-1 NIL)

(TOGGLE RESET-VECTOR-CHIP-ON RESET-VECTOR-CHIP NIL)

(TOGGLE G*1*RESET-VECTOR-CHIP-ON *1*RESET-VECTOR-CHIP NIL)

(TOGGLE FM9001-STATEP-MAP-UP-FINAL-STATE-ON FM9001-STATEP-MAP-UP-FINAL-STATE
        NIL)

(TOGGLE INSTANCE-THEOREM-ON INSTANCE-THEOREM NIL)

(TOGGLE FINAL-STATE-OKP-ON FINAL-STATE-OKP NIL)

(TOGGLE UNKNOWN-STATE-OKP-ON UNKNOWN-STATE-OKP NIL)

(TOGGLE RESET-WORKS-ON RESET-WORKS NIL)

(TOGGLE FINAL-STATE-ON FINAL-STATE NIL)

(TOGGLE G*1*FINAL-STATE-ON *1*FINAL-STATE NIL)

(TOGGLE INITIALIZED-MEMORY-STATE-ON INITIALIZED-MEMORY-STATE NIL)

(TOGGLE G*1*INITIALIZED-MEMORY-STATE-ON *1*INITIALIZED-MEMORY-STATE NIL)

(TOGGLE INITIALIZED-MACHINE-STATE-ON INITIALIZED-MACHINE-STATE NIL)

(TOGGLE G*1*INITIALIZED-MACHINE-STATE-ON *1*INITIALIZED-MACHINE-STATE NIL)

(TOGGLE INITIALIZED-REGFILE-ON INITIALIZED-REGFILE NIL)

(TOGGLE G*1*INITIALIZED-REGFILE-ON *1*INITIALIZED-REGFILE NIL)

(TOGGLE CHIP-SYSTEM-OPERATING-INPUTS-P-RESET-SEQUENCE-ON
        CHIP-SYSTEM-OPERATING-INPUTS-P-RESET-SEQUENCE NIL)

(TOGGLE RESET-SEQUENCE-ON RESET-SEQUENCE NIL)

(TOGGLE G*1*RESET-SEQUENCE-ON *1*RESET-SEQUENCE NIL)

(TOGGLE RUN-VECTOR-ON RUN-VECTOR NIL)

(TOGGLE G*1*RUN-VECTOR-ON *1*RUN-VECTOR NIL)

(TOGGLE RESET-VECTOR-ON RESET-VECTOR NIL)

(TOGGLE G*1*RESET-VECTOR-ON *1*RESET-VECTOR NIL)

(TOGGLE FM9001-STATE-STRUCTURE-UNKNOWN-STATE-ON
        FM9001-STATE-STRUCTURE-UNKNOWN-STATE NIL)

(TOGGLE CHIP-SYSTEM-INVARIANT-UNKNOWN-STATE-ON
        CHIP-SYSTEM-INVARIANT-UNKNOWN-STATE NIL)

(TOGGLE UNKNOWN-STATE-ON UNKNOWN-STATE NIL)

(TOGGLE G*1*UNKNOWN-STATE-ON *1*UNKNOWN-STATE NIL)

(TOGGLE UNKNOWN-MEMORY-STATE-ON UNKNOWN-MEMORY-STATE NIL)

(TOGGLE G*1*UNKNOWN-MEMORY-STATE-ON *1*UNKNOWN-MEMORY-STATE NIL)

(TOGGLE UNKNOWN-MACHINE-STATE-ON UNKNOWN-MACHINE-STATE NIL)

(TOGGLE G*1*UNKNOWN-MACHINE-STATE-ON *1*UNKNOWN-MACHINE-STATE NIL)

(TOGGLE UNKNOWN-REGFILE-ON UNKNOWN-REGFILE NIL)

(TOGGLE G*1*UNKNOWN-REGFILE-ON *1*UNKNOWN-REGFILE NIL)

(TOGGLE COMPILE-UNCOMPILED-DEFNS-ON2 COMPILE-UNCOMPILED-DEFNS NIL)

(COMPILE-UNCOMPILED-DEFNS "tmp")

(TOGGLE G*1*COMPILE-UNCOMPILED-DEFNS-ON *1*COMPILE-UNCOMPILED-DEFNS NIL)

(TOGGLE XS-SUFFICE-FOR-RESET-LEMMA-ON XS-SUFFICE-FOR-RESET-LEMMA NIL)

(TOGGLE XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE-ON
        XS-SUFFICE-FOR-RESET-LEMMA-VERBOSE NIL)

(TOGGLE LENGTH-SIMULATE-ON LENGTH-SIMULATE NIL)

(TOGGLE DOUBLET-P-EQUAL-APPROX-ON DOUBLET-P-EQUAL-APPROX NIL)

(TOGGLE DOUBLET-N-SIMULATE-ON DOUBLET-N-SIMULATE NIL)

(TOGGLE DOUBLET-N-SIMULATE-INDUCTION-ON DOUBLET-N-SIMULATE-INDUCTION NIL)

(TOGGLE G*1*DOUBLET-N-SIMULATE-INDUCTION-ON *1*DOUBLET-N-SIMULATE-INDUCTION NIL)

(TOGGLE G*1*DOUBLET-P-ON *1*DOUBLET-P NIL)

(TOGGLE V-APPROX-LIST-X-X-ON V-APPROX-LIST-X-X NIL)

(TOGGLE SIMULATE-MONOTONE-ON SIMULATE-MONOTONE NIL)

(TOGGLE SIMULATE-MONOTONE-INDUCTION-ON SIMULATE-MONOTONE-INDUCTION NIL)

(TOGGLE G*1*SIMULATE-MONOTONE-INDUCTION-ON *1*SIMULATE-MONOTONE-INDUCTION NIL)

(TOGGLE S-APPROX-CADR-NTH-ON S-APPROX-CADR-NTH NIL)

(TOGGLE V-APPROX-CAR-NTH-ON V-APPROX-CAR-NTH NIL)

(TOGGLE NAT-LST-LST-INDUCTION-ON NAT-LST-LST-INDUCTION NIL)

(TOGGLE G*1*NAT-LST-LST-INDUCTION-ON *1*NAT-LST-LST-INDUCTION NIL)

(TOGGLE V-S-APPROX-LIST-ON V-S-APPROX-LIST NIL)

(TOGGLE G*1*V-S-APPROX-LIST-ON *1*V-S-APPROX-LIST NIL)

(TOGGLE V-APPROX-LIST-ON V-APPROX-LIST NIL)

(TOGGLE G*1*V-APPROX-LIST-ON *1*V-APPROX-LIST NIL)

(TOGGLE GOOD-S-PRESERVED-ON GOOD-S-PRESERVED NIL)

(TOGGLE PRIMP-PRESERVES-GOOD-S-ON PRIMP-PRESERVES-GOOD-S NIL)

(TOGGLE DP-RAM-16X32-PRESERVES-GOOD-S-ON DP-RAM-16X32-PRESERVES-GOOD-S NIL)

(TOGGLE GOOD-S-WRITE-MEM-ON GOOD-S-WRITE-MEM NIL)

(TOGGLE GOOD-S-WRITE-MEM-1-ON GOOD-S-WRITE-MEM-1 NIL)

(TOGGLE GOOD-S-CONSTANT-RAM-ON GOOD-S-CONSTANT-RAM NIL)

(TOGGLE VSS-PRESERVES-GOOD-S-ON VSS-PRESERVES-GOOD-S NIL)

(TOGGLE VDD-PARAMETRIC-PRESERVES-GOOD-S-ON VDD-PARAMETRIC-PRESERVES-GOOD-S NIL)

(TOGGLE VDD-PRESERVES-GOOD-S-ON VDD-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S-ON
        TTL-TRI-OUTPUT-FAST-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-TRI-OUTPUT-PRESERVES-GOOD-S-ON TTL-TRI-OUTPUT-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-OUTPUT-FAST-PRESERVES-GOOD-S-ON TTL-OUTPUT-FAST-PRESERVES-GOOD-S
        NIL)

(TOGGLE TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S-ON
        TTL-OUTPUT-PARAMETRIC-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-OUTPUT-PRESERVES-GOOD-S-ON TTL-OUTPUT-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-INPUT-PRESERVES-GOOD-S-ON TTL-INPUT-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-CLK-INPUT-PRESERVES-GOOD-S-ON TTL-CLK-INPUT-PRESERVES-GOOD-S NIL)

(TOGGLE TTL-BIDIRECT-PRESERVES-GOOD-S-ON TTL-BIDIRECT-PRESERVES-GOOD-S NIL)

(TOGGLE PULLUP-PRESERVES-GOOD-S-ON PULLUP-PRESERVES-GOOD-S NIL)

(TOGGLE T-WIRE-PRESERVES-GOOD-S-ON T-WIRE-PRESERVES-GOOD-S NIL)

(TOGGLE T-BUF-PRESERVES-GOOD-S-ON T-BUF-PRESERVES-GOOD-S NIL)

(TOGGLE RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S-ON
        RAM-ENABLE-CIRCUIT-PRESERVES-GOOD-S NIL)

(TOGGLE ID-PRESERVES-GOOD-S-ON ID-PRESERVES-GOOD-S NIL)

(TOGGLE FD1SLP-PRESERVES-GOOD-S-ON FD1SLP-PRESERVES-GOOD-S NIL)

(TOGGLE FD1SP-PRESERVES-GOOD-S-ON FD1SP-PRESERVES-GOOD-S NIL)

(TOGGLE FD1S-PRESERVES-GOOD-S-ON FD1S-PRESERVES-GOOD-S NIL)

(TOGGLE FD1-PRESERVES-GOOD-S-ON FD1-PRESERVES-GOOD-S NIL)

(TOGGLE PROCMON-PRESERVES-GOOD-S-ON PROCMON-PRESERVES-GOOD-S NIL)

(TOGGLE DEL10-PRESERVES-GOOD-S-ON DEL10-PRESERVES-GOOD-S NIL)

(TOGGLE DEL4-PRESERVES-GOOD-S-ON DEL4-PRESERVES-GOOD-S NIL)

(TOGGLE DEL2-PRESERVES-GOOD-S-ON DEL2-PRESERVES-GOOD-S NIL)

(TOGGLE B-XOR3-PRESERVES-GOOD-S-ON B-XOR3-PRESERVES-GOOD-S NIL)

(TOGGLE B-XOR-PRESERVES-GOOD-S-ON B-XOR-PRESERVES-GOOD-S NIL)

(TOGGLE B-OR4-PRESERVES-GOOD-S-ON B-OR4-PRESERVES-GOOD-S NIL)

(TOGGLE B-OR3-PRESERVES-GOOD-S-ON B-OR3-PRESERVES-GOOD-S NIL)

(TOGGLE B-OR-PRESERVES-GOOD-S-ON B-OR-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOT-IVAP-PRESERVES-GOOD-S-ON B-NOT-IVAP-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOT-B4IP-PRESERVES-GOOD-S-ON B-NOT-B4IP-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOT-PRESERVES-GOOD-S-ON B-NOT-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR8-PRESERVES-GOOD-S-ON B-NOR8-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR6-PRESERVES-GOOD-S-ON B-NOR6-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR5-PRESERVES-GOOD-S-ON B-NOR5-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR4-PRESERVES-GOOD-S-ON B-NOR4-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR3-PRESERVES-GOOD-S-ON B-NOR3-PRESERVES-GOOD-S NIL)

(TOGGLE B-NOR-PRESERVES-GOOD-S-ON B-NOR-PRESERVES-GOOD-S NIL)

(TOGGLE B-NBUF-PRESERVES-GOOD-S-ON B-NBUF-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND8-PRESERVES-GOOD-S-ON B-NAND8-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND6-PRESERVES-GOOD-S-ON B-NAND6-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND5-PRESERVES-GOOD-S-ON B-NAND5-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND4-PRESERVES-GOOD-S-ON B-NAND4-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND3-PRESERVES-GOOD-S-ON B-NAND3-PRESERVES-GOOD-S NIL)

(TOGGLE B-NAND-PRESERVES-GOOD-S-ON B-NAND-PRESERVES-GOOD-S NIL)

(TOGGLE B-IF-PRESERVES-GOOD-S-ON B-IF-PRESERVES-GOOD-S NIL)

(TOGGLE B-EQUV3-PRESERVES-GOOD-S-ON B-EQUV3-PRESERVES-GOOD-S NIL)

(TOGGLE B-EQUV-PRESERVES-GOOD-S-ON B-EQUV-PRESERVES-GOOD-S NIL)

(TOGGLE B-AND4-PRESERVES-GOOD-S-ON B-AND4-PRESERVES-GOOD-S NIL)

(TOGGLE B-AND3-PRESERVES-GOOD-S-ON B-AND3-PRESERVES-GOOD-S NIL)

(TOGGLE B-AND-PRESERVES-GOOD-S-ON B-AND-PRESERVES-GOOD-S NIL)

(TOGGLE AO7-PRESERVES-GOOD-S-ON AO7-PRESERVES-GOOD-S NIL)

(TOGGLE AO6-PRESERVES-GOOD-S-ON AO6-PRESERVES-GOOD-S NIL)

(TOGGLE AO4-PRESERVES-GOOD-S-ON AO4-PRESERVES-GOOD-S NIL)

(TOGGLE AO2-PRESERVES-GOOD-S-ON AO2-PRESERVES-GOOD-S NIL)

(TOGGLE GOOD-S-0-ON GOOD-S-0 NIL)

(TOGGLE F-IF-PRESERVES-GOOD-S-ON F-IF-PRESERVES-GOOD-S NIL)

(TOGGLE F-BUF-PRESERVES-GOOD-S-ON F-BUF-PRESERVES-GOOD-S NIL)

(TOGGLE GOOD-S-COLLECT-VALUE-ON GOOD-S-COLLECT-VALUE NIL)

(TOGGLE DUAL-EVAL-MONOTONE-ON DUAL-EVAL-MONOTONE NIL)

(TOGGLE GOOD-S-VALUE-ON GOOD-S-VALUE NIL)

(TOGGLE GOOD-S-ALIST-PAIRLIST-ON GOOD-S-ALIST-PAIRLIST NIL)

(TOGGLE GOOD-S-ALIST-ON GOOD-S-ALIST NIL)

(TOGGLE G*1*GOOD-S-ALIST-ON *1*GOOD-S-ALIST NIL)

(TOGGLE DUAL-EVAL-MONOTONE-NO-RAM-ON DUAL-EVAL-MONOTONE-NO-RAM NIL)

(TOGGLE OK-NETLISTP-REDUCTION-REWRITE-ON OK-NETLISTP-REDUCTION-REWRITE NIL)

(TOGGLE OK-NETLISTP-REDUCTION-ON OK-NETLISTP-REDUCTION NIL)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-COLLECT-VALUE-ON
        S-APPROX-ALIST-IMPLIES-S-APPROX-COLLECT-VALUE NIL)

(TOGGLE S-APPROX-IMPLIES-S-APPROX-ALIST-ON S-APPROX-IMPLIES-S-APPROX-ALIST NIL)

(TOGGLE ALISTP-DUAL-EVAL-3-ON ALISTP-DUAL-EVAL-3 NIL)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-LIST-COLLECT-VALUE-ON
        S-APPROX-ALIST-IMPLIES-S-APPROX-LIST-COLLECT-VALUE NIL)

(TOGGLE DOUBLE-CDR-INDUCTION-ON DOUBLE-CDR-INDUCTION NIL)

(TOGGLE G*1*DOUBLE-CDR-INDUCTION-ON *1*DOUBLE-CDR-INDUCTION NIL)

(TOGGLE V-APPROX-ALIST-APPEND-ON V-APPROX-ALIST-APPEND NIL)

(TOGGLE S-APPROX-ALIST-IMPLIES-S-APPROX-VALUE-ON
        S-APPROX-ALIST-IMPLIES-S-APPROX-VALUE NIL)

(TOGGLE ALISTP-OPENER-ON ALISTP-OPENER NIL)

(TOGGLE V-APPROX-IMPLIES-V-APPROX-ALIST-ON V-APPROX-IMPLIES-V-APPROX-ALIST NIL)

(TOGGLE S-APPROX-LIST-IMPLIES-S-APPROX-ALIST-ON
        S-APPROX-LIST-IMPLIES-S-APPROX-ALIST NIL)

(TOGGLE S-APPROX-LIST-ON S-APPROX-LIST NIL)

(TOGGLE G*1*S-APPROX-LIST-ON *1*S-APPROX-LIST NIL)

(TOGGLE V-APPROX-ALIST-IMPLIES-V-APPROX-COLLECT-VALUE-ON
        V-APPROX-ALIST-IMPLIES-V-APPROX-COLLECT-VALUE NIL)

(TOGGLE ALISTP-DUAL-EVAL-1-ON ALISTP-DUAL-EVAL-1 NIL)

(TOGGLE ALISTP-APPEND-ON ALISTP-APPEND NIL)

(TOGGLE ALISTP-PAIRLIST-ON ALISTP-PAIRLIST NIL)

(TOGGLE V-APPROX-ALIST-IMPLIES-B-APPROX-VALUE-ON
        V-APPROX-ALIST-IMPLIES-B-APPROX-VALUE NIL)

(TOGGLE DUAL-EVAL-MONOTONE-INDUCTION-ON DUAL-EVAL-MONOTONE-INDUCTION NIL)

(TOGGLE G*1*DUAL-EVAL-MONOTONE-INDUCTION-ON *1*DUAL-EVAL-MONOTONE-INDUCTION NIL)

(TOGGLE PRIMP-MONOTONE-ON PRIMP-MONOTONE NIL)

(TOGGLE OK-NETLISTP-ON OK-NETLISTP NIL)

(TOGGLE G*1*OK-NETLISTP-ON *1*OK-NETLISTP NIL)

(TOGGLE DUAL-PORT-RAM-STATE-BODY-ON DUAL-PORT-RAM-STATE-BODY NIL)

(TOGGLE G*1*DUAL-PORT-RAM-STATE-BODY-ON *1*DUAL-PORT-RAM-STATE-BODY NIL)

(TOGGLE DUAL-PORT-RAM-STATE-MONOTONE-ON DUAL-PORT-RAM-STATE-MONOTONE NIL)

(TOGGLE WRITE-MEM1-DOUBLE-INDUCTION-ON WRITE-MEM1-DOUBLE-INDUCTION NIL)

(TOGGLE G*1*WRITE-MEM1-DOUBLE-INDUCTION-ON *1*WRITE-MEM1-DOUBLE-INDUCTION NIL)

(TOGGLE WRITE-MEM1-MONOTONE-INDUCTION-ON WRITE-MEM1-MONOTONE-INDUCTION NIL)

(TOGGLE G*1*WRITE-MEM1-MONOTONE-INDUCTION-ON *1*WRITE-MEM1-MONOTONE-INDUCTION
        NIL)

(TOGGLE DUAL-PORT-RAM-VALUE-BODY-ON DUAL-PORT-RAM-VALUE-BODY NIL)

(TOGGLE G*1*DUAL-PORT-RAM-VALUE-BODY-ON *1*DUAL-PORT-RAM-VALUE-BODY NIL)

(TOGGLE V-APPROX-X-X-ON1 V-APPROX-X-X NIL)

(TOGGLE READ-MEM1-MONOTONE-INDUCTION-ON READ-MEM1-MONOTONE-INDUCTION NIL)

(TOGGLE G*1*READ-MEM1-MONOTONE-INDUCTION-ON *1*READ-MEM1-MONOTONE-INDUCTION NIL)

(TOGGLE BVP-REV1-ON BVP-REV1 NIL)

(TOGGLE VSS-MONOTONE-ON VSS-MONOTONE NIL)

(TOGGLE DUAL-EVAL-VSS-STATE-ON DUAL-EVAL-VSS-STATE NIL)

(TOGGLE DUAL-EVAL-VSS-VALUE-ON DUAL-EVAL-VSS-VALUE NIL)

(TOGGLE VDD-PARAMETRIC-MONOTONE-ON VDD-PARAMETRIC-MONOTONE NIL)

(TOGGLE DUAL-EVAL-VDD-PARAMETRIC-STATE-ON DUAL-EVAL-VDD-PARAMETRIC-STATE NIL)

(TOGGLE DUAL-EVAL-VDD-PARAMETRIC-VALUE-ON DUAL-EVAL-VDD-PARAMETRIC-VALUE NIL)

(TOGGLE VDD-MONOTONE-ON VDD-MONOTONE NIL)

(TOGGLE DUAL-EVAL-VDD-STATE-ON DUAL-EVAL-VDD-STATE NIL)

(TOGGLE DUAL-EVAL-VDD-VALUE-ON DUAL-EVAL-VDD-VALUE NIL)

(TOGGLE TTL-TRI-OUTPUT-FAST-MONOTONE-ON TTL-TRI-OUTPUT-FAST-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE-ON
        DUAL-EVAL-TTL-TRI-OUTPUT-FAST-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE-ON
        DUAL-EVAL-TTL-TRI-OUTPUT-FAST-VALUE NIL)

(TOGGLE TTL-TRI-OUTPUT-MONOTONE-ON TTL-TRI-OUTPUT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-STATE-ON DUAL-EVAL-TTL-TRI-OUTPUT-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-TRI-OUTPUT-VALUE-ON DUAL-EVAL-TTL-TRI-OUTPUT-VALUE NIL)

(TOGGLE TTL-OUTPUT-FAST-MONOTONE-ON TTL-OUTPUT-FAST-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-FAST-STATE-ON DUAL-EVAL-TTL-OUTPUT-FAST-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-FAST-VALUE-ON DUAL-EVAL-TTL-OUTPUT-FAST-VALUE NIL)

(TOGGLE TTL-OUTPUT-PARAMETRIC-MONOTONE-ON TTL-OUTPUT-PARAMETRIC-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE-ON
        DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE-ON
        DUAL-EVAL-TTL-OUTPUT-PARAMETRIC-VALUE NIL)

(TOGGLE TTL-OUTPUT-MONOTONE-ON TTL-OUTPUT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-STATE-ON DUAL-EVAL-TTL-OUTPUT-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-OUTPUT-VALUE-ON DUAL-EVAL-TTL-OUTPUT-VALUE NIL)

(TOGGLE TTL-INPUT-MONOTONE-ON TTL-INPUT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-INPUT-STATE-ON DUAL-EVAL-TTL-INPUT-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-INPUT-VALUE-ON DUAL-EVAL-TTL-INPUT-VALUE NIL)

(TOGGLE TTL-CLK-INPUT-MONOTONE-ON TTL-CLK-INPUT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-CLK-INPUT-STATE-ON DUAL-EVAL-TTL-CLK-INPUT-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-CLK-INPUT-VALUE-ON DUAL-EVAL-TTL-CLK-INPUT-VALUE NIL)

(TOGGLE TTL-BIDIRECT-MONOTONE-ON TTL-BIDIRECT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-TTL-BIDIRECT-STATE-ON DUAL-EVAL-TTL-BIDIRECT-STATE NIL)

(TOGGLE DUAL-EVAL-TTL-BIDIRECT-VALUE-ON DUAL-EVAL-TTL-BIDIRECT-VALUE NIL)

(TOGGLE PULLUP-MONOTONE-ON PULLUP-MONOTONE NIL)

(TOGGLE DUAL-EVAL-PULLUP-STATE-ON DUAL-EVAL-PULLUP-STATE NIL)

(TOGGLE DUAL-EVAL-PULLUP-VALUE-ON DUAL-EVAL-PULLUP-VALUE NIL)

(TOGGLE T-WIRE-MONOTONE-ON T-WIRE-MONOTONE NIL)

(TOGGLE DUAL-EVAL-T-WIRE-STATE-ON DUAL-EVAL-T-WIRE-STATE NIL)

(TOGGLE DUAL-EVAL-T-WIRE-VALUE-ON DUAL-EVAL-T-WIRE-VALUE NIL)

(TOGGLE T-BUF-MONOTONE-ON T-BUF-MONOTONE NIL)

(TOGGLE DUAL-EVAL-T-BUF-STATE-ON DUAL-EVAL-T-BUF-STATE NIL)

(TOGGLE DUAL-EVAL-T-BUF-VALUE-ON DUAL-EVAL-T-BUF-VALUE NIL)

(TOGGLE RAM-ENABLE-CIRCUIT-MONOTONE-ON RAM-ENABLE-CIRCUIT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE-ON
        DUAL-EVAL-RAM-ENABLE-CIRCUIT-STATE NIL)

(TOGGLE DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE-ON
        DUAL-EVAL-RAM-ENABLE-CIRCUIT-VALUE NIL)

(TOGGLE ID-MONOTONE-ON ID-MONOTONE NIL)

(TOGGLE DUAL-EVAL-ID-STATE-ON DUAL-EVAL-ID-STATE NIL)

(TOGGLE DUAL-EVAL-ID-VALUE-ON DUAL-EVAL-ID-VALUE NIL)

(TOGGLE FD1SLP-MONOTONE-ON FD1SLP-MONOTONE NIL)

(TOGGLE DUAL-EVAL-FD1SLP-STATE-ON DUAL-EVAL-FD1SLP-STATE NIL)

(TOGGLE DUAL-EVAL-FD1SLP-VALUE-ON DUAL-EVAL-FD1SLP-VALUE NIL)

(TOGGLE FD1SP-MONOTONE-ON FD1SP-MONOTONE NIL)

(TOGGLE DUAL-EVAL-FD1SP-STATE-ON DUAL-EVAL-FD1SP-STATE NIL)

(TOGGLE DUAL-EVAL-FD1SP-VALUE-ON DUAL-EVAL-FD1SP-VALUE NIL)

(TOGGLE FD1S-MONOTONE-ON FD1S-MONOTONE NIL)

(TOGGLE DUAL-EVAL-FD1S-STATE-ON DUAL-EVAL-FD1S-STATE NIL)

(TOGGLE DUAL-EVAL-FD1S-VALUE-ON DUAL-EVAL-FD1S-VALUE NIL)

(TOGGLE FD1-MONOTONE-ON FD1-MONOTONE NIL)

(TOGGLE DUAL-EVAL-FD1-STATE-ON DUAL-EVAL-FD1-STATE NIL)

(TOGGLE DUAL-EVAL-FD1-VALUE-ON DUAL-EVAL-FD1-VALUE NIL)

(TOGGLE PROCMON-MONOTONE-ON PROCMON-MONOTONE NIL)

(TOGGLE DUAL-EVAL-PROCMON-STATE-ON DUAL-EVAL-PROCMON-STATE NIL)

(TOGGLE DUAL-EVAL-PROCMON-VALUE-ON DUAL-EVAL-PROCMON-VALUE NIL)

(TOGGLE DEL10-MONOTONE-ON DEL10-MONOTONE NIL)

(TOGGLE DUAL-EVAL-DEL10-STATE-ON DUAL-EVAL-DEL10-STATE NIL)

(TOGGLE DUAL-EVAL-DEL10-VALUE-ON DUAL-EVAL-DEL10-VALUE NIL)

(TOGGLE DEL4-MONOTONE-ON DEL4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-DEL4-STATE-ON DUAL-EVAL-DEL4-STATE NIL)

(TOGGLE DUAL-EVAL-DEL4-VALUE-ON DUAL-EVAL-DEL4-VALUE NIL)

(TOGGLE DEL2-MONOTONE-ON DEL2-MONOTONE NIL)

(TOGGLE DUAL-EVAL-DEL2-STATE-ON DUAL-EVAL-DEL2-STATE NIL)

(TOGGLE DUAL-EVAL-DEL2-VALUE-ON DUAL-EVAL-DEL2-VALUE NIL)

(TOGGLE B-XOR3-MONOTONE-ON B-XOR3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-XOR3-STATE-ON DUAL-EVAL-B-XOR3-STATE NIL)

(TOGGLE DUAL-EVAL-B-XOR3-VALUE-ON DUAL-EVAL-B-XOR3-VALUE NIL)

(TOGGLE B-XOR-MONOTONE-ON B-XOR-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-XOR-STATE-ON DUAL-EVAL-B-XOR-STATE NIL)

(TOGGLE DUAL-EVAL-B-XOR-VALUE-ON DUAL-EVAL-B-XOR-VALUE NIL)

(TOGGLE B-OR4-MONOTONE-ON B-OR4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-OR4-STATE-ON DUAL-EVAL-B-OR4-STATE NIL)

(TOGGLE DUAL-EVAL-B-OR4-VALUE-ON DUAL-EVAL-B-OR4-VALUE NIL)

(TOGGLE B-OR3-MONOTONE-ON B-OR3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-OR3-STATE-ON DUAL-EVAL-B-OR3-STATE NIL)

(TOGGLE DUAL-EVAL-B-OR3-VALUE-ON DUAL-EVAL-B-OR3-VALUE NIL)

(TOGGLE B-OR-MONOTONE-ON B-OR-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-OR-STATE-ON DUAL-EVAL-B-OR-STATE NIL)

(TOGGLE DUAL-EVAL-B-OR-VALUE-ON DUAL-EVAL-B-OR-VALUE NIL)

(TOGGLE B-NOT-IVAP-MONOTONE-ON B-NOT-IVAP-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOT-IVAP-STATE-ON DUAL-EVAL-B-NOT-IVAP-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOT-IVAP-VALUE-ON DUAL-EVAL-B-NOT-IVAP-VALUE NIL)

(TOGGLE B-NOT-B4IP-MONOTONE-ON B-NOT-B4IP-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOT-B4IP-STATE-ON DUAL-EVAL-B-NOT-B4IP-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOT-B4IP-VALUE-ON DUAL-EVAL-B-NOT-B4IP-VALUE NIL)

(TOGGLE B-NOT-MONOTONE-ON B-NOT-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOT-STATE-ON DUAL-EVAL-B-NOT-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOT-VALUE-ON DUAL-EVAL-B-NOT-VALUE NIL)

(TOGGLE B-NOR8-MONOTONE-ON B-NOR8-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR8-STATE-ON DUAL-EVAL-B-NOR8-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR8-VALUE-ON DUAL-EVAL-B-NOR8-VALUE NIL)

(TOGGLE B-NOR6-MONOTONE-ON B-NOR6-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR6-STATE-ON DUAL-EVAL-B-NOR6-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR6-VALUE-ON DUAL-EVAL-B-NOR6-VALUE NIL)

(TOGGLE B-NOR5-MONOTONE-ON B-NOR5-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR5-STATE-ON DUAL-EVAL-B-NOR5-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR5-VALUE-ON DUAL-EVAL-B-NOR5-VALUE NIL)

(TOGGLE B-NOR4-MONOTONE-ON B-NOR4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR4-STATE-ON DUAL-EVAL-B-NOR4-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR4-VALUE-ON DUAL-EVAL-B-NOR4-VALUE NIL)

(TOGGLE B-NOR3-MONOTONE-ON B-NOR3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR3-STATE-ON DUAL-EVAL-B-NOR3-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR3-VALUE-ON DUAL-EVAL-B-NOR3-VALUE NIL)

(TOGGLE B-NOR-MONOTONE-ON B-NOR-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NOR-STATE-ON DUAL-EVAL-B-NOR-STATE NIL)

(TOGGLE DUAL-EVAL-B-NOR-VALUE-ON DUAL-EVAL-B-NOR-VALUE NIL)

(TOGGLE B-NBUF-MONOTONE-ON B-NBUF-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NBUF-STATE-ON DUAL-EVAL-B-NBUF-STATE NIL)

(TOGGLE DUAL-EVAL-B-NBUF-VALUE-ON DUAL-EVAL-B-NBUF-VALUE NIL)

(TOGGLE B-NAND8-MONOTONE-ON B-NAND8-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND8-STATE-ON DUAL-EVAL-B-NAND8-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND8-VALUE-ON DUAL-EVAL-B-NAND8-VALUE NIL)

(TOGGLE B-NAND6-MONOTONE-ON B-NAND6-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND6-STATE-ON DUAL-EVAL-B-NAND6-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND6-VALUE-ON DUAL-EVAL-B-NAND6-VALUE NIL)

(TOGGLE B-NAND5-MONOTONE-ON B-NAND5-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND5-STATE-ON DUAL-EVAL-B-NAND5-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND5-VALUE-ON DUAL-EVAL-B-NAND5-VALUE NIL)

(TOGGLE B-NAND4-MONOTONE-ON B-NAND4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND4-STATE-ON DUAL-EVAL-B-NAND4-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND4-VALUE-ON DUAL-EVAL-B-NAND4-VALUE NIL)

(TOGGLE B-NAND3-MONOTONE-ON B-NAND3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND3-STATE-ON DUAL-EVAL-B-NAND3-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND3-VALUE-ON DUAL-EVAL-B-NAND3-VALUE NIL)

(TOGGLE B-NAND-MONOTONE-ON B-NAND-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-NAND-STATE-ON DUAL-EVAL-B-NAND-STATE NIL)

(TOGGLE DUAL-EVAL-B-NAND-VALUE-ON DUAL-EVAL-B-NAND-VALUE NIL)

(TOGGLE B-IF-MONOTONE-ON B-IF-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-IF-STATE-ON DUAL-EVAL-B-IF-STATE NIL)

(TOGGLE DUAL-EVAL-B-IF-VALUE-ON DUAL-EVAL-B-IF-VALUE NIL)

(TOGGLE B-EQUV3-MONOTONE-ON B-EQUV3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-EQUV3-STATE-ON DUAL-EVAL-B-EQUV3-STATE NIL)

(TOGGLE DUAL-EVAL-B-EQUV3-VALUE-ON DUAL-EVAL-B-EQUV3-VALUE NIL)

(TOGGLE B-EQUV-MONOTONE-ON B-EQUV-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-EQUV-STATE-ON DUAL-EVAL-B-EQUV-STATE NIL)

(TOGGLE DUAL-EVAL-B-EQUV-VALUE-ON DUAL-EVAL-B-EQUV-VALUE NIL)

(TOGGLE B-AND4-MONOTONE-ON B-AND4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-AND4-STATE-ON DUAL-EVAL-B-AND4-STATE NIL)

(TOGGLE DUAL-EVAL-B-AND4-VALUE-ON DUAL-EVAL-B-AND4-VALUE NIL)

(TOGGLE B-AND3-MONOTONE-ON B-AND3-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-AND3-STATE-ON DUAL-EVAL-B-AND3-STATE NIL)

(TOGGLE DUAL-EVAL-B-AND3-VALUE-ON DUAL-EVAL-B-AND3-VALUE NIL)

(TOGGLE B-AND-MONOTONE-ON B-AND-MONOTONE NIL)

(TOGGLE DUAL-EVAL-B-AND-STATE-ON DUAL-EVAL-B-AND-STATE NIL)

(TOGGLE DUAL-EVAL-B-AND-VALUE-ON DUAL-EVAL-B-AND-VALUE NIL)

(TOGGLE AO7-MONOTONE-ON AO7-MONOTONE NIL)

(TOGGLE DUAL-EVAL-AO7-STATE-ON DUAL-EVAL-AO7-STATE NIL)

(TOGGLE DUAL-EVAL-AO7-VALUE-ON DUAL-EVAL-AO7-VALUE NIL)

(TOGGLE AO6-MONOTONE-ON AO6-MONOTONE NIL)

(TOGGLE DUAL-EVAL-AO6-STATE-ON DUAL-EVAL-AO6-STATE NIL)

(TOGGLE DUAL-EVAL-AO6-VALUE-ON DUAL-EVAL-AO6-VALUE NIL)

(TOGGLE AO4-MONOTONE-ON AO4-MONOTONE NIL)

(TOGGLE DUAL-EVAL-AO4-STATE-ON DUAL-EVAL-AO4-STATE NIL)

(TOGGLE DUAL-EVAL-AO4-VALUE-ON DUAL-EVAL-AO4-VALUE NIL)

(TOGGLE AO2-MONOTONE-ON AO2-MONOTONE NIL)

(TOGGLE DUAL-EVAL-AO2-STATE-ON DUAL-EVAL-AO2-STATE NIL)

(TOGGLE DUAL-EVAL-AO2-VALUE-ON DUAL-EVAL-AO2-VALUE NIL)

(TOGGLE FOURP-IMPLIES-S-APPROX-IS-B-APPROX-ON1
        FOURP-IMPLIES-S-APPROX-IS-B-APPROX NIL)

(TOGGLE FOURP-F-IF-ON FOURP-F-IF NIL)

(TOGGLE FOURP-F-BUF-ON FOURP-F-BUF NIL)

(TOGGLE F-BUF-TYPE-SET-ON F-BUF-TYPE-SET NIL)

(TOGGLE S-APPROX-IMPLIES-B-APPROX-ON S-APPROX-IMPLIES-B-APPROX NIL)

(TOGGLE DUAL-EVAL-2-PRIMP-ON DUAL-EVAL-2-PRIMP NIL)

(TOGGLE DUAL-EVAL-0-PRIMP-ON DUAL-EVAL-0-PRIMP NIL)

(TOGGLE F-PULLUP-MONOTONE-ON F-PULLUP-MONOTONE NIL)

(TOGGLE FT-WIRE-MONOTONE-ON FT-WIRE-MONOTONE NIL)

(TOGGLE FT-BUF-MONOTONE-ON FT-BUF-MONOTONE NIL)

(TOGGLE F-IF-MONOTONE-ON F-IF-MONOTONE NIL)

(TOGGLE F-EQUV3-MONOTONE-ON F-EQUV3-MONOTONE NIL)

(TOGGLE F-XOR3-MONOTONE-ON F-XOR3-MONOTONE NIL)

(TOGGLE F-EQUV-MONOTONE-ON F-EQUV-MONOTONE NIL)

(TOGGLE F-XOR-MONOTONE-ON F-XOR-MONOTONE NIL)

(TOGGLE F-NOR8-MONOTONE-ON F-NOR8-MONOTONE NIL)

(TOGGLE F-NOR6-MONOTONE-ON F-NOR6-MONOTONE NIL)

(TOGGLE F-NOR5-MONOTONE-ON F-NOR5-MONOTONE NIL)

(TOGGLE F-NOR4-MONOTONE-ON F-NOR4-MONOTONE NIL)

(TOGGLE F-NOR3-MONOTONE-ON F-NOR3-MONOTONE NIL)

(TOGGLE F-NOR-MONOTONE-ON F-NOR-MONOTONE NIL)

(TOGGLE F-OR4-MONOTONE-ON F-OR4-MONOTONE NIL)

(TOGGLE F-OR3-MONOTONE-ON F-OR3-MONOTONE NIL)

(TOGGLE F-OR-MONOTONE-ON F-OR-MONOTONE NIL)

(TOGGLE F-NAND8-MONOTONE-ON F-NAND8-MONOTONE NIL)

(TOGGLE F-NAND6-MONOTONE-ON F-NAND6-MONOTONE NIL)

(TOGGLE F-NAND5-MONOTONE-ON F-NAND5-MONOTONE NIL)

(TOGGLE F-NAND4-MONOTONE-ON F-NAND4-MONOTONE NIL)

(TOGGLE F-NAND3-MONOTONE-ON F-NAND3-MONOTONE NIL)

(TOGGLE F-NAND-MONOTONE-ON F-NAND-MONOTONE NIL)

(TOGGLE F-NOT-MONOTONE-ON F-NOT-MONOTONE NIL)

(TOGGLE F-AND4-MONOTONE-ON F-AND4-MONOTONE NIL)

(TOGGLE F-AND3-MONOTONE-ON F-AND3-MONOTONE NIL)

(TOGGLE F-AND-MONOTONE-ON F-AND-MONOTONE NIL)

(TOGGLE F-BUF-MONOTONE-ON F-BUF-MONOTONE NIL)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-3-ON
        MONOTONICITY-PROPERTY-CONSEQUENCE-3 NIL)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-2-ON
        MONOTONICITY-PROPERTY-CONSEQUENCE-2 NIL)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-1-ON
        MONOTONICITY-PROPERTY-CONSEQUENCE-1 NIL)

(TOGGLE MONOTONICITY-PROPERTY-CONSEQUENCE-0-ON
        MONOTONICITY-PROPERTY-CONSEQUENCE-0 NIL)

(TOGGLE G*1*MONOTONICITY-PROPERTY-ON *1*MONOTONICITY-PROPERTY NIL)

(TOGGLE S-APPROX-ALIST-ON S-APPROX-ALIST NIL)

(TOGGLE G*1*S-APPROX-ALIST-ON *1*S-APPROX-ALIST NIL)

(TOGGLE V-APPROX-ALIST-ON V-APPROX-ALIST NIL)

(TOGGLE G*1*V-APPROX-ALIST-ON *1*V-APPROX-ALIST NIL)

(TOGGLE S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL-ON1
        S-KNOWNP-IMPLIES-S-APPROX-IS-EQUAL NIL)

(TOGGLE S-KNOWNP-ON1 S-KNOWNP NIL)

(TOGGLE G*1*S-KNOWNP-ON *1*S-KNOWNP NIL)

(TOGGLE GOOD-S-ON GOOD-S NIL)

(TOGGLE G*1*GOOD-S-ON *1*GOOD-S NIL)

(TOGGLE S-APPROX-X-X-ON S-APPROX-X-X NIL)

(TOGGLE S-APPROX-ON1 S-APPROX NIL)

(TOGGLE G*1*S-APPROX-ON *1*S-APPROX NIL)

(TOGGLE MEM-WIDTH-ON1 MEM-WIDTH NIL)

(TOGGLE G*1*MEM-WIDTH-ON1 *1*MEM-WIDTH NIL)

(TOGGLE V-KNOWNP-IMPLIES-V-APPROX-IS-EQUAL-ON
        V-KNOWNP-IMPLIES-V-APPROX-IS-EQUAL NIL)

(TOGGLE V-KNOWNP-ON1 V-KNOWNP NIL)

(TOGGLE G*1*V-KNOWNP-ON *1*V-KNOWNP NIL)

(TOGGLE V-APPROX-ON1 V-APPROX NIL)

(TOGGLE G*1*V-APPROX-ON *1*V-APPROX NIL)

(TOGGLE G*1*B-APPROX-ON *1*B-APPROX NIL)

(TOGGLE B-KNOWNP-COMPOUND-RECOGNIZER-ON B-KNOWNP-COMPOUND-RECOGNIZER NIL)

(TOGGLE MONOTONICITY-PROPERTY-OFF1 MONOTONICITY-PROPERTY T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-0-OFF1 MONOTONICITY-PROPERTY-OPENER-0 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-1-OFF1 MONOTONICITY-PROPERTY-OPENER-1 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-2-OFF1 MONOTONICITY-PROPERTY-OPENER-2 T)

(TOGGLE MONOTONICITY-PROPERTY-OPENER-3-OFF1 MONOTONICITY-PROPERTY-OPENER-3 T)

(TOGGLE F-BUF-OFF1 F-BUF T)

(TOGGLE F-AND-OFF1 F-AND T)

(TOGGLE F-AND3-OFF1 F-AND3 T)

(TOGGLE F-AND4-OFF1 F-AND4 T)

(TOGGLE F-NOT-OFF1 F-NOT T)

(TOGGLE F-NAND-OFF1 F-NAND T)

(TOGGLE F-NAND3-OFF1 F-NAND3 T)

(TOGGLE F-NAND4-OFF1 F-NAND4 T)

(TOGGLE F-NAND5-OFF1 F-NAND5 T)

(TOGGLE F-NAND6-OFF1 F-NAND6 T)

(TOGGLE F-NAND8-OFF1 F-NAND8 T)

(TOGGLE F-OR-OFF1 F-OR T)

(TOGGLE F-OR3-OFF1 F-OR3 T)

(TOGGLE F-OR4-OFF1 F-OR4 T)

(TOGGLE F-NOR-OFF1 F-NOR T)

(TOGGLE F-NOR3-OFF1 F-NOR3 T)

(TOGGLE F-NOR4-OFF1 F-NOR4 T)

(TOGGLE F-NOR5-OFF1 F-NOR5 T)

(TOGGLE F-NOR6-OFF1 F-NOR6 T)

(TOGGLE F-NOR8-OFF1 F-NOR8 T)

(TOGGLE F-XOR-OFF1 F-XOR T)

(TOGGLE F-XOR3-OFF1 F-XOR3 T)

(TOGGLE F-EQUV-OFF1 F-EQUV T)

(TOGGLE F-EQUV3-OFF1 F-EQUV3 T)

(TOGGLE F-IF-OFF1 F-IF T)

(TOGGLE FT-BUF-OFF1 FT-BUF T)

(TOGGLE FT-WIRE-OFF1 FT-WIRE T)

(TOGGLE F-PULLUP-OFF1 F-PULLUP T)

(TOGGLE BVP-REVERSE-OFF1 BVP-REVERSE T)

(TOGGLE V-APPROX-BVP-OFF1 V-APPROX-BVP T)

(TOGGLE READ-MEM1-MONOTONE-OFF1 READ-MEM1-MONOTONE T)

(TOGGLE BVP-IMPLIES-V-KNOWNP-OFF1 BVP-IMPLIES-V-KNOWNP T)

(TOGGLE V-APPROX-IMPLIES-B-APPROX-NTH-OFF1 V-APPROX-IMPLIES-B-APPROX-NTH T)

(TOGGLE G*1*B-KNOWNP-OFF2 *1*B-KNOWNP T)

(TOGGLE V-APPROX-IMPLIES-SUBRANGES-EQUAL-OFF1 V-APPROX-IMPLIES-SUBRANGES-EQUAL
        T)

(TOGGLE V-APPROX-BVP-SUBRANGE-OFF1 V-APPROX-BVP-SUBRANGE T)

(TOGGLE V-APPROX-MAKE-LIST-X-OFF1 V-APPROX-MAKE-LIST-X T)

(TOGGLE READ-MEM-MONOTONE-OFF1 READ-MEM-MONOTONE T)

(TOGGLE EQUAL-LENGTH-READ-MEM1-OFF1 EQUAL-LENGTH-READ-MEM1 T)

(TOGGLE EQUAL-LENGTH-READ-MEM-OFF1 EQUAL-LENGTH-READ-MEM T)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM1-OFF1
        S-APPROX-IMPLIES-PROPERP-READ-MEM1 T)

(TOGGLE S-APPROX-IMPLIES-PROPERP-READ-MEM-OFF1
        S-APPROX-IMPLIES-PROPERP-READ-MEM T)

(TOGGLE DUAL-PORT-RAM-VALUE-MONOTONE-OFF1 DUAL-PORT-RAM-VALUE-MONOTONE T)

(TOGGLE EVAL$-APPEND-OFF1 EVAL$-APPEND T)

(TOGGLE EVAL$-PAIRLIST-CONS-OFF1 EVAL$-PAIRLIST-CONS T)

(TOGGLE EVAL$-APPEND-2-OFF1 EVAL$-APPEND-2 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1-OFF1
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-1 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2-OFF1
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-2 T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3-OFF1
        DUAL-APPLY-VALUE-DP-RAM-16X32-LEMMA-3 T)

(TOGGLE DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY-OFF1
        DUAL-PORT-RAM-VALUE-IS-DUAL-PORT-RAM-VALUE-BODY T)

(TOGGLE DUAL-APPLY-VALUE-DP-RAM-16X32-OFF1 DUAL-APPLY-VALUE-DP-RAM-16X32 T)

(TOGGLE DP-RAM-16X32-MONOTONE-VALUE-OFF1 DP-RAM-16X32-MONOTONE-VALUE T)

(TOGGLE BVP-ON1 BVP NIL)

(TOGGLE S-APPROX-OPENER-OFF1 S-APPROX-OPENER T)

(TOGGLE V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T-OFF1
        V-APPROX-IMPLIES-NTH-DOES-NOT-GO-FROM-F-TO-T T)

(TOGGLE WRITE-MEM1-OPENER-OFF1 WRITE-MEM1-OPENER T)

(TOGGLE WRITE-MEM1-MONOTONE-OFF1 WRITE-MEM1-MONOTONE T)

(TOGGLE WRITE-MEM-MONOTONE-OFF1 WRITE-MEM-MONOTONE T)

(TOGGLE V-APPROX-LENGTH-OFF1 V-APPROX-LENGTH T)

(TOGGLE S-APPROX-WRITE-MEM1-ID-OFF1 S-APPROX-WRITE-MEM1-ID T)

(TOGGLE S-APPROX-WRITE-MEM-ID-OFF1 S-APPROX-WRITE-MEM-ID T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-ID-OFF1 S-APPROX-CONSTANT-RAM-X-ID T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X-OFF1
        S-APPROX-CONSTANT-RAM-X-CONSTANT-RAM-X T)

(TOGGLE V-APPROX-PRESERVES-LENGTH-OFF1 V-APPROX-PRESERVES-LENGTH T)

(TOGGLE V-APPROX-SUBRANGE-OFF1 V-APPROX-SUBRANGE T)

(TOGGLE MEM-WIDTH-NON-ZERO-OFF1 MEM-WIDTH-NON-ZERO T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3-OFF1
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-CASE-3 T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM1-OFF1
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM1 T)

(TOGGLE S-APPROX-CONSTANT-RAM-X-WRITE-MEM-OFF1
        S-APPROX-CONSTANT-RAM-X-WRITE-MEM T)

(TOGGLE V-APPROX-PRESERVES-PROPERP-OFF1 V-APPROX-PRESERVES-PROPERP T)

(TOGGLE MEM-WIDTH-LINEAR-FACTS-OFF1 MEM-WIDTH-LINEAR-FACTS T)

(TOGGLE DUAL-PORT-RAM-STATE-MONOTONE-REWRITE-OFF1
        DUAL-PORT-RAM-STATE-MONOTONE-REWRITE T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1-OFF1
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-1 T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2-OFF1
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-2 T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3-OFF1
        DUAL-APPLY-STATE-DP-RAM-16X32-LEMMA-3 T)

(TOGGLE DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY-OFF1
        DUAL-PORT-RAM-STATE-IS-DUAL-PORT-RAM-STATE-BODY T)

(TOGGLE DUAL-APPLY-STATE-DP-RAM-16X32-OFF1 DUAL-APPLY-STATE-DP-RAM-16X32 T)

(TOGGLE DP-RAM-16X32-MONOTONE-STATE-OFF1 DP-RAM-16X32-MONOTONE-STATE T)

(TOGGLE DP-RAM-16X32-MONOTONE-OFF1 DP-RAM-16X32-MONOTONE T)

(TOGGLE OPEN-NTH-ON1 OPEN-NTH NIL)

(TOGGLE DOUBLET-P-OFF1 DOUBLET-P T)

(TOGGLE B-KNOWNP-OFF2 B-KNOWNP T)

(TOGGLE B-APPROX-OFF2 B-APPROX T)

(TOGGLE CANCEL-CONSTANTS-ILESSP-OFF1 CANCEL-CONSTANTS-ILESSP T)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-2-OFF1 CANCEL-CONSTANTS-ILESSP-LEMMA-2 T)

(TOGGLE CANCEL-CONSTANTS-ILESSP-LEMMA-1-OFF1 CANCEL-CONSTANTS-ILESSP-LEMMA-1 T)

(TOGGLE ILESSP-ADD1-IPLUS-OFF1 ILESSP-ADD1-IPLUS T)

(TOGGLE ILESSP-ADD1-OFF1 ILESSP-ADD1 T)

(TOGGLE CANCEL-CONSTANTS-EQUAL-OFF1 CANCEL-CONSTANTS-EQUAL T)

(TOGGLE CANCEL-CONSTANTS-EQUAL-LEMMA-OFF1 CANCEL-CONSTANTS-EQUAL-LEMMA T)

(TOGGLE IPLUS-CONSTANTS-OFF1 IPLUS-CONSTANTS T)

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-OFF1
  CANCEL-INEG-TERMS-FROM-INEQUALITY-CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED
  T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED-OFF1
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY-EXPANDED T)

(TOGGLE CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF1
        CANCEL-INEG-TERMS-FROM-INEQUALITY T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-INEQUALITY-OFF1
        *1*CANCEL-INEG-TERMS-FROM-INEQUALITY T)

(TOGGLE MAKE-CANCEL-INEG-TERMS-INEQUALITY-OFF1
        MAKE-CANCEL-INEG-TERMS-INEQUALITY T)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-INEQUALITY-OFF1
        *1*MAKE-CANCEL-INEG-TERMS-INEQUALITY T)

(TOGGLE IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS-OFF1
        IPLUS-LIST-EVAL$-CAR-SPLIT-OUT-INEG-TERMS T)

(TOGGLE EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS-OFF1
        EVAL$-IPLUS-LIST-CDR-REMOVE-INEGS T)

(TOGGLE EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS-OFF1
        EVAL$-IPLUS-LIST-CAR-REMOVE-INEGS T)

(TOGGLE
  CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-OFF1
  CANCEL-INEG-TERMS-FROM-EQUALITY-CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED-OFF1
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY-EXPANDED T)

(TOGGLE CANCEL-INEG-TERMS-FROM-EQUALITY-OFF1 CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE G*1*CANCEL-INEG-TERMS-FROM-EQUALITY-OFF1
        *1*CANCEL-INEG-TERMS-FROM-EQUALITY T)

(TOGGLE MAKE-CANCEL-INEG-TERMS-EQUALITY-OFF1 MAKE-CANCEL-INEG-TERMS-EQUALITY T)

(TOGGLE G*1*MAKE-CANCEL-INEG-TERMS-EQUALITY-OFF1
        *1*MAKE-CANCEL-INEG-TERMS-EQUALITY T)

(TOGGLE G*1*IPLUS-OR-INEG-TERM-OFF1 *1*IPLUS-OR-INEG-TERM T)

(TOGGLE G*1*REMOVE-INEGS-OFF1 *1*REMOVE-INEGS T)

(TOGGLE SPLIT-OUT-INEG-TERMS-OFF1 SPLIT-OUT-INEG-TERMS T)

(TOGGLE G*1*SPLIT-OUT-INEG-TERMS-OFF1 *1*SPLIT-OUT-INEG-TERMS T)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR-OFF1
        CONJOIN-INEQUALITIES-WITH-0-ELIMINATOR T)

(TOGGLE CANCEL-FACTORS-ILESSP-0-OFF1 CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE G*1*CANCEL-FACTORS-ILESSP-0-OFF1 *1*CANCEL-FACTORS-ILESSP-0 T)

(TOGGLE CONJOIN-INEQUALITIES-WITH-0-OFF1 CONJOIN-INEQUALITIES-WITH-0 T)

(TOGGLE G*1*CONJOIN-INEQUALITIES-WITH-0-OFF1 *1*CONJOIN-INEQUALITIES-WITH-0 T)

(TOGGLE SOME-EVAL$S-TO-0-ELIMINATOR-OFF1 SOME-EVAL$S-TO-0-ELIMINATOR T)

(TOGGLE SOME-EVAL$S-TO-0-APPEND-OFF1 SOME-EVAL$S-TO-0-APPEND T)

(TOGGLE EVAL$-DISJOIN-EQUALITIES-WITH-0-OFF1 EVAL$-DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE SOME-EVAL$S-TO-0-OFF1 SOME-EVAL$S-TO-0 T)

(TOGGLE G*1*SOME-EVAL$S-TO-0-OFF1 *1*SOME-EVAL$S-TO-0 T)

(TOGGLE CANCEL-FACTORS-0-OFF1 CANCEL-FACTORS-0 T)

(TOGGLE G*1*CANCEL-FACTORS-0-OFF1 *1*CANCEL-FACTORS-0 T)

(TOGGLE DISJOIN-EQUALITIES-WITH-0-OFF1 DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE G*1*DISJOIN-EQUALITIES-WITH-0-OFF1 *1*DISJOIN-EQUALITIES-WITH-0 T)

(TOGGLE EQUAL-FIX-INT-TO-ILESSP-OFF1 EQUAL-FIX-INT-TO-ILESSP T)

(TOGGLE EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA-OFF1
        EVAL$-LIST-BAGINT-0-IMPLIES-EQUAL-FOR-ILESSP-LEMMA T)

(TOGGLE EVAL$-LIST-BAGINT-0-FOR-ILESSP-OFF1 EVAL$-LIST-BAGINT-0-FOR-ILESSP T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2-OFF1
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-2 T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1-OFF1
        MEMBER-0-ITIMES-FACTORS-YIELDS-0-ILESSP-CONSEQUENCE-1 T)

(TOGGLE MEMBER-0-ITIMES-FACTORS-YIELDS-0-OFF1 MEMBER-0-ITIMES-FACTORS-YIELDS-0
        T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2-OFF1
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-2 T)

(TOGGLE ILESSP-ZERO-IMPLIES-NOT-EQUAL-OFF1 ILESSP-ZERO-IMPLIES-NOT-EQUAL T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1-OFF1
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-COROLLARY-1 T)

(TOGGLE ZERO-ILESSP-IMPLIES-NOT-EQUAL-OFF1 ZERO-ILESSP-IMPLIES-NOT-EQUAL T)

(TOGGLE ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF-OFF1
        ILESSP-ITIMES-LIST-EVAL$-LIST-BAGDIFF T)

(TOGGLE BAGINT-SINGLETON-OFF1 BAGINT-SINGLETON T)

(TOGGLE CANCEL-ITIMES-ILESSP-FACTORS-OFF1 CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-FACTORS-OFF1 *1*CANCEL-ITIMES-ILESSP-FACTORS T)

(TOGGLE MEMBER-0-EVAL$-LIST-OFF1 MEMBER-0-EVAL$-LIST T)

(TOGGLE MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0-OFF1
        MEMBERSHIP-OF-0-IMPLIES-ITIMES-LIST-IS-0 T)

(TOGGLE CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS-OFF1
        CANCEL-ITIMES-FACTORS-EXPANDED-CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-EXPANDED-OFF1
        *1*CANCEL-ITIMES-FACTORS-EXPANDED T)

(TOGGLE CANCEL-ITIMES-FACTORS-OFF1 CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*CANCEL-ITIMES-FACTORS-OFF1 *1*CANCEL-ITIMES-FACTORS T)

(TOGGLE G*1*IPLUS-OR-ITIMES-TERM-OFF1 *1*IPLUS-OR-ITIMES-TERM T)

(TOGGLE ITIMES-EVAL$-ITIMES-TREE-INEG-OFF1 ITIMES-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE IPLUS-EVAL$-ITIMES-TREE-INEG-OFF1 IPLUS-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE INEG-EVAL$-ITIMES-TREE-INEG-OFF1 INEG-EVAL$-ITIMES-TREE-INEG T)

(TOGGLE EVAL$-ITIMES-TREE-INEG-OFF1 EVAL$-ITIMES-TREE-INEG T)

(TOGGLE FIX-INT-EVAL$-ITIMES-TREE-REC-OFF1 FIX-INT-EVAL$-ITIMES-TREE-REC T)

(TOGGLE ILESSP-INEG-INEG-OFF1 ILESSP-INEG-INEG T)

(TOGGLE EQUAL-INEG-INEG-OFF1 EQUAL-INEG-INEG T)

(TOGGLE ITIMES--1-OFF1 ITIMES--1 T)

(TOGGLE ITIMES-FACTORS-OFF1 ITIMES-FACTORS T)

(TOGGLE G*1*ITIMES-FACTORS-OFF1 *1*ITIMES-FACTORS T)

(TOGGLE G*1*ITIMES-TREE-INEG-OFF1 *1*ITIMES-TREE-INEG T)

(TOGGLE ILESSP-STRICT-OFF1 ILESSP-STRICT T)

(TOGGLE ILESSP-ITIMES-RIGHT-NEGATIVE-OFF1 ILESSP-ITIMES-RIGHT-NEGATIVE T)

(TOGGLE ILESSP-ITIMES-RIGHT-POSITIVE-OFF1 ILESSP-ITIMES-RIGHT-POSITIVE T)

(TOGGLE CANCEL-ITIMES-ILESSP-OFF1 CANCEL-ITIMES-ILESSP T)

(TOGGLE G*1*CANCEL-ITIMES-ILESSP-OFF1 *1*CANCEL-ITIMES-ILESSP T)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-INEQUALITY-OFF1 *1*MAKE-CANCEL-ITIMES-INEQUALITY
        T)

(TOGGLE G*1*ITIMES-TREE-NO-FIX-INT-OFF1 *1*ITIMES-TREE-NO-FIX-INT T)

(TOGGLE SUBSETP-OFF1 SUBSETP T)

(TOGGLE G*1*SUBSETP-OFF1 *1*SUBSETP T)

(TOGGLE EQUAL-FIX-INT-OFF1 EQUAL-FIX-INT T)

(TOGGLE MEMBER-APPEND-OFF1 MEMBER-APPEND T)

(TOGGLE ITIMES-LIST-APPEND-OFF1 ITIMES-LIST-APPEND T)

(TOGGLE CANCEL-ITIMES-OFF1 CANCEL-ITIMES T)

(TOGGLE G*1*CANCEL-ITIMES-OFF1 *1*CANCEL-ITIMES T)

(TOGGLE G*1*MAKE-CANCEL-ITIMES-EQUALITY-OFF1 *1*MAKE-CANCEL-ITIMES-EQUALITY T)

(TOGGLE INTEGERP-ITIMES-LIST-OFF1 INTEGERP-ITIMES-LIST T)

(TOGGLE ITIMES-LIST-OFF1 ITIMES-LIST T)

(TOGGLE G*1*ITIMES-LIST-OFF1 *1*ITIMES-LIST T)

(TOGGLE G*1*ITIMES-TREE-OFF1 *1*ITIMES-TREE T)

(TOGGLE ITIMES-TREE-REC-OFF1 ITIMES-TREE-REC T)

(TOGGLE G*1*ITIMES-TREE-REC-OFF1 *1*ITIMES-TREE-REC T)

(TOGGLE ITIMES-FRINGE-OFF1 ITIMES-FRINGE T)

(TOGGLE G*1*ITIMES-FRINGE-OFF1 *1*ITIMES-FRINGE T)

(TOGGLE FIX-INT-IREM-OFF1 FIX-INT-IREM T)

(TOGGLE FIX-INT-IQUO-OFF1 FIX-INT-IQUO T)

(TOGGLE FIX-INT-IMOD-OFF1 FIX-INT-IMOD T)

(TOGGLE FIX-INT-IDIV-OFF1 FIX-INT-IDIV T)

(TOGGLE FIX-INT-IREMAINDER-OFF1 FIX-INT-IREMAINDER T)

(TOGGLE FIX-INT-IQUOTIENT-OFF1 FIX-INT-IQUOTIENT T)

(TOGGLE IREM-FIX-INT2-OFF1 IREM-FIX-INT2 T)

(TOGGLE IREM-FIX-INT1-OFF1 IREM-FIX-INT1 T)

(TOGGLE IQUO-FIX-INT2-OFF1 IQUO-FIX-INT2 T)

(TOGGLE IQUO-FIX-INT1-OFF1 IQUO-FIX-INT1 T)

(TOGGLE IMOD-FIX-INT2-OFF1 IMOD-FIX-INT2 T)

(TOGGLE IMOD-FIX-INT1-OFF1 IMOD-FIX-INT1 T)

(TOGGLE IDIV-FIX-INT2-OFF1 IDIV-FIX-INT2 T)

(TOGGLE IDIV-FIX-INT1-OFF1 IDIV-FIX-INT1 T)

(TOGGLE IREMAINDER-FIX-INT2-OFF1 IREMAINDER-FIX-INT2 T)

(TOGGLE IREMAINDER-FIX-INT1-OFF1 IREMAINDER-FIX-INT1 T)

(TOGGLE IQUOTIENT-FIX-INT2-OFF1 IQUOTIENT-FIX-INT2 T)

(TOGGLE IQUOTIENT-FIX-INT1-OFF1 IQUOTIENT-FIX-INT1 T)

(TOGGLE INTEGERP-IREM-OFF1 INTEGERP-IREM T)

(TOGGLE INTEGERP-IQUO-OFF1 INTEGERP-IQUO T)

(TOGGLE INTEGERP-IMOD-OFF1 INTEGERP-IMOD T)

(TOGGLE INTEGERP-IDIV-OFF1 INTEGERP-IDIV T)

(TOGGLE INTEGERP-IREMAINDER-OFF1 INTEGERP-IREMAINDER T)

(TOGGLE INTEGERP-IQUOTIENT-OFF1 INTEGERP-IQUOTIENT T)

(TOGGLE ITIMES-CANCELLATION-3-OFF1 ITIMES-CANCELLATION-3 T)

(TOGGLE ITIMES-CANCELLATION-2-OFF1 ITIMES-CANCELLATION-2 T)

(TOGGLE ITIMES-CANCELLATION-1-OFF1 ITIMES-CANCELLATION-1 T)

(TOGGLE ITIMES-INEG-2-OFF1 ITIMES-INEG-2 T)

(TOGGLE ITIMES-INEG-1-OFF1 ITIMES-INEG-1 T)

(TOGGLE IQUO-IREM-UNIQUENESS-OFF1 IQUO-IREM-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART3 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART2 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-ZERO-PART1 T)

(TOGGLE IDIV-IMOD-UNIQUENESS-OFF1 IDIV-IMOD-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART3 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART2 T)

(TOGGLE DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1-OFF1
        DIVISION-THEOREM-FOR-TRUNCATE-TO-NEGINF-PART1 T)

(TOGGLE IQUOTIENT-IREMAINDER-UNIQUENESS-OFF1 IQUOTIENT-IREMAINDER-UNIQUENESS T)

(TOGGLE DIVISION-THEOREM-OFF1 DIVISION-THEOREM T)

(TOGGLE DIVISION-THEOREM-PART3-OFF1 DIVISION-THEOREM-PART3 T)

(TOGGLE DIVISION-THEOREM-PART2-OFF1 DIVISION-THEOREM-PART2 T)

(TOGGLE DIVISION-THEOREM-PART1-OFF1 DIVISION-THEOREM-PART1 T)

(TOGGLE QUOTIENT-REMAINDER-UNIQUENESS-OFF1 QUOTIENT-REMAINDER-UNIQUENESS T)

(TOGGLE ITIMES-1-ARG1-OFF1 ITIMES-1-ARG1 T)

(TOGGLE EQUAL-ITIMES-MINUS-1-OFF1 EQUAL-ITIMES-MINUS-1 T)

(TOGGLE EQUAL-ITIMES-1-OFF1 EQUAL-ITIMES-1 T)

(TOGGLE EQUAL-ITIMES-0-OFF1 EQUAL-ITIMES-0 T)

(TOGGLE ASSOCIATIVITY-OF-ITIMES-OFF1 ASSOCIATIVITY-OF-ITIMES T)

(TOGGLE COMMUTATIVITY2-OF-ITIMES-OFF1 COMMUTATIVITY2-OF-ITIMES T)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-OFF1 ITIMES-DISTRIBUTES-OVER-IPLUS T)

(TOGGLE ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF-OFF1
        ITIMES-DISTRIBUTES-OVER-IPLUS-PROOF T)

(TOGGLE COMMUTATIVITY-OF-ITIMES-OFF1 COMMUTATIVITY-OF-ITIMES T)

(TOGGLE ITIMES-FIX-INT2-OFF1 ITIMES-FIX-INT2 T)

(TOGGLE ITIMES-FIX-INT1-OFF1 ITIMES-FIX-INT1 T)

(TOGGLE ITIMES-0-RIGHT-OFF1 ITIMES-0-RIGHT T)

(TOGGLE ITIMES-0-LEFT-OFF1 ITIMES-0-LEFT T)

(TOGGLE CANCEL-IPLUS-ILESSP-OFF1 CANCEL-IPLUS-ILESSP T)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-OFF1 *1*CANCEL-IPLUS-ILESSP T)

(TOGGLE G*1*IPLUS-TREE-NO-FIX-INT-OFF1 *1*IPLUS-TREE-NO-FIX-INT T)

(TOGGLE IPLUS-CANCELLATION-2-FOR-ILESSP-OFF1 IPLUS-CANCELLATION-2-FOR-ILESSP T)

(TOGGLE IPLUS-CANCELLATION-1-FOR-ILESSP-OFF1 IPLUS-CANCELLATION-1-FOR-ILESSP T)

(TOGGLE CANCEL-IPLUS-ILESSP-1-OFF1 CANCEL-IPLUS-ILESSP-1 T)

(TOGGLE G*1*CANCEL-IPLUS-ILESSP-1-OFF1 *1*CANCEL-IPLUS-ILESSP-1 T)

(TOGGLE G*1*MAKE-CANCEL-IPLUS-INEQUALITY-1-OFF1
        *1*MAKE-CANCEL-IPLUS-INEQUALITY-1 T)

(TOGGLE ILESSP-FIX-INT-2-OFF1 ILESSP-FIX-INT-2 T)

(TOGGLE ILESSP-FIX-INT-1-OFF1 ILESSP-FIX-INT-1 T)

(TOGGLE IPLUS-INEG7-OFF1 IPLUS-INEG7 T)

(TOGGLE IPLUS-LIST-APPEND-OFF1 IPLUS-LIST-APPEND T)

(TOGGLE EVAL$-IPLUS-LIST-DELETE-OFF1 EVAL$-IPLUS-LIST-DELETE T)

(TOGGLE G*1*CANCEL-IPLUS-OFF1 *1*CANCEL-IPLUS T)

(TOGGLE EVAL$-LIST-APPEND-OFF1 EVAL$-LIST-APPEND T)

(TOGGLE INTEGERP-IPLUS-LIST-OFF1 INTEGERP-IPLUS-LIST T)

(TOGGLE IPLUS-LIST-OFF1 IPLUS-LIST T)

(TOGGLE G*1*IPLUS-LIST-OFF1 *1*IPLUS-LIST T)

(TOGGLE G*1*IPLUS-TREE-OFF1 *1*IPLUS-TREE T)

(TOGGLE IPLUS-TREE-REC-OFF1 IPLUS-TREE-REC T)

(TOGGLE G*1*IPLUS-TREE-REC-OFF1 *1*IPLUS-TREE-REC T)

(TOGGLE IPLUS-FRINGE-OFF1 IPLUS-FRINGE T)

(TOGGLE G*1*IPLUS-FRINGE-OFF1 *1*IPLUS-FRINGE T)

(TOGGLE IPLUS-X-Y-INEG-X-OFF1 IPLUS-X-Y-INEG-X T)

(TOGGLE IPLUS-INEG4-OFF1 IPLUS-INEG4 T)

(TOGGLE IPLUS-INEG3-OFF1 IPLUS-INEG3 T)

(TOGGLE EVAL$-CANCEL-INEG-AUX-IS-ITS-FN-OFF1 EVAL$-CANCEL-INEG-AUX-IS-ITS-FN T)

(TOGGLE EVAL$-CANCEL-INEG-AUX-FN-OFF1 EVAL$-CANCEL-INEG-AUX-FN T)

(TOGGLE G*1*EVAL$-CANCEL-INEG-AUX-FN-OFF1 *1*EVAL$-CANCEL-INEG-AUX-FN T)

(TOGGLE EVAL$-OTHER-OFF1 EVAL$-OTHER T)

(TOGGLE EVAL$-LITATOM-OFF1 EVAL$-LITATOM T)

(TOGGLE EVAL$-LIST-NLISTP-OFF1 EVAL$-LIST-NLISTP T)

(TOGGLE EVAL$-LIST-CONS-OFF1 EVAL$-LIST-CONS T)

(TOGGLE CANCEL-INEG-OFF1 CANCEL-INEG T)

(TOGGLE G*1*CANCEL-INEG-OFF1 *1*CANCEL-INEG T)

(TOGGLE CANCEL-INEG-AUX-OFF1 CANCEL-INEG-AUX T)

(TOGGLE G*1*CANCEL-INEG-AUX-OFF1 *1*CANCEL-INEG-AUX T)

(TOGGLE IDIFFERENCE-FIX-INT2-OFF1 IDIFFERENCE-FIX-INT2 T)

(TOGGLE IDIFFERENCE-FIX-INT1-OFF1 IDIFFERENCE-FIX-INT1 T)

(TOGGLE IPLUS-FIX-INT2-OFF1 IPLUS-FIX-INT2 T)

(TOGGLE IPLUS-FIX-INT1-OFF1 IPLUS-FIX-INT1 T)

(TOGGLE IPLUS-INEG2-OFF1 IPLUS-INEG2 T)

(TOGGLE IPLUS-INEG1-OFF1 IPLUS-INEG1 T)

(TOGGLE IPLUS-CANCELLATION-2-OFF1 IPLUS-CANCELLATION-2 T)

(TOGGLE IPLUS-CANCELLATION-1-OFF1 IPLUS-CANCELLATION-1 T)

(TOGGLE ASSOCIATIVITY-OF-IPLUS-OFF1 ASSOCIATIVITY-OF-IPLUS T)

(TOGGLE COMMUTATIVITY-OF-IPLUS-OFF1 COMMUTATIVITY-OF-IPLUS T)

(TOGGLE COMMUTATIVITY2-OF-IPLUS-OFF1 COMMUTATIVITY2-OF-IPLUS T)

(TOGGLE IPLUS-0-RIGHT-OFF1 IPLUS-0-RIGHT T)

(TOGGLE IPLUS-0-LEFT-OFF1 IPLUS-0-LEFT T)

(TOGGLE INEG-0-OFF1 INEG-0 T)

(TOGGLE INEG-FIX-INT-OFF1 INEG-FIX-INT T)

(TOGGLE INEG-INEG-OFF1 INEG-INEG T)

(TOGGLE INEG-IPLUS-OFF1 INEG-IPLUS T)

(TOGGLE FIX-INT-ITIMES-OFF1 FIX-INT-ITIMES T)

(TOGGLE FIX-INT-IABS-OFF1 FIX-INT-IABS T)

(TOGGLE FIX-INT-INEG-OFF1 FIX-INT-INEG T)

(TOGGLE FIX-INT-IDIFFERENCE-OFF1 FIX-INT-IDIFFERENCE T)

(TOGGLE FIX-INT-IPLUS-OFF1 FIX-INT-IPLUS T)

(TOGGLE FIX-INT-FIX-INT-OFF1 FIX-INT-FIX-INT T)

(TOGGLE FIX-INT-REMOVER-OFF1 FIX-INT-REMOVER T)

(TOGGLE INTEGERP-ITIMES-OFF1 INTEGERP-ITIMES T)

(TOGGLE INTEGERP-IABS-OFF1 INTEGERP-IABS T)

(TOGGLE INTEGERP-INEG-OFF1 INTEGERP-INEG T)

(TOGGLE INTEGERP-IDIFFERENCE-OFF1 INTEGERP-IDIFFERENCE T)

(TOGGLE INTEGERP-IPLUS-OFF1 INTEGERP-IPLUS T)

(TOGGLE INTEGERP-FIX-INT-OFF1 INTEGERP-FIX-INT T)

(TOGGLE G*1*IREM-OFF1 *1*IREM T)

(TOGGLE G*1*IQUO-OFF1 *1*IQUO T)

(TOGGLE G*1*IMOD-OFF1 *1*IMOD T)

(TOGGLE G*1*IDIV-OFF1 *1*IDIV T)

(TOGGLE G*1*IREMAINDER-OFF1 *1*IREMAINDER T)

(TOGGLE G*1*IQUOTIENT-OFF1 *1*IQUOTIENT T)

(TOGGLE G*1*ITIMES-OFF1 *1*ITIMES T)

(TOGGLE G*1*IABS-OFF1 *1*IABS T)

(TOGGLE IDIFFERENCE-OFF1 IDIFFERENCE T)

(TOGGLE G*1*IDIFFERENCE-OFF1 *1*IDIFFERENCE T)

(TOGGLE G*1*INEG-OFF1 *1*INEG T)

(TOGGLE G*1*IPLUS-OFF1 *1*IPLUS T)

(TOGGLE ILEQ-OFF1 ILEQ T)

(TOGGLE G*1*ILEQ-OFF1 *1*ILEQ T)

(TOGGLE G*1*ILESSP-OFF1 *1*ILESSP T)

(TOGGLE IZEROP-OFF1 IZEROP T)

(TOGGLE G*1*IZEROP-OFF1 *1*IZEROP T)

(TOGGLE G*1*FIX-INT-OFF1 *1*FIX-INT T)

(TOGGLE G*1*INTEGERP-OFF1 *1*INTEGERP T)

(TOGGLE GCD-IDEMPOTENCE-OFF1 GCD-IDEMPOTENCE T)

(TOGGLE GCD-X-X-OFF1 GCD-X-X T)

(TOGGLE COMMUTATIVITY2-OF-GCD-OFF1 COMMUTATIVITY2-OF-GCD T)

(TOGGLE COMMUTATIVITY2-OF-GCD-ZERO-CASE-OFF1 COMMUTATIVITY2-OF-GCD-ZERO-CASE T)

(TOGGLE ASSOCIATIVITY-OF-GCD-OFF1 ASSOCIATIVITY-OF-GCD T)

(TOGGLE ASSOCIATIVITY-OF-GCD-ZERO-CASE-OFF1 ASSOCIATIVITY-OF-GCD-ZERO-CASE T)

(TOGGLE COMMON-DIVISOR-DIVIDES-GCD-OFF1 COMMON-DIVISOR-DIVIDES-GCD T)

(TOGGLE GCD-IS-THE-GREATEST-OFF1 GCD-IS-THE-GREATEST T)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-OFF1 DISTRIBUTIVITY-OF-TIMES-OVER-GCD
        T)

(TOGGLE DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF-OFF1
        DISTRIBUTIVITY-OF-TIMES-OVER-GCD-PROOF T)

(TOGGLE REMAINDER-GCD-OFF1 REMAINDER-GCD T)

(TOGGLE GCD-PLUS-INSTANCE-OFF1 GCD-PLUS-INSTANCE T)

(TOGGLE GCD-PLUS-OFF1 GCD-PLUS T)

(TOGGLE GCD-PLUS-PROOF-OFF1 GCD-PLUS-PROOF T)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-OFF1 GCD-PLUS-INSTANCE-TEMP T)

(TOGGLE GCD-PLUS-INSTANCE-TEMP-PROOF-OFF1 GCD-PLUS-INSTANCE-TEMP-PROOF T)

(TOGGLE LESSP-GCD-OFF1 LESSP-GCD T)

(TOGGLE EQUAL-GCD-0-OFF1 EQUAL-GCD-0 T)

(TOGGLE GCD-1-OFF1 GCD-1 T)

(TOGGLE GCD-0-OFF1 GCD-0 T)

(TOGGLE SINGLE-NUMBER-INDUCTION-OFF1 SINGLE-NUMBER-INDUCTION T)

(TOGGLE G*1*SINGLE-NUMBER-INDUCTION-OFF1 *1*SINGLE-NUMBER-INDUCTION T)

(TOGGLE COMMUTATIVITY-OF-GCD-OFF1 COMMUTATIVITY-OF-GCD T)

(TOGGLE LOG-EXP-OFF1 LOG-EXP T)

(TOGGLE LOG-TIMES-EXP-OFF1 LOG-TIMES-EXP T)

(TOGGLE LOG-TIMES-EXP-PROOF-OFF1 LOG-TIMES-EXP-PROOF T)

(TOGGLE LOG-TIMES-OFF1 LOG-TIMES T)

(TOGGLE LOG-TIMES-PROOF-OFF1 LOG-TIMES-PROOF T)

(TOGGLE LOG-QUOTIENT-EXP-OFF1 LOG-QUOTIENT-EXP T)

(TOGGLE LOG-QUOTIENT-TIMES-OFF1 LOG-QUOTIENT-TIMES T)

(TOGGLE LOG-QUOTIENT-TIMES-PROOF-OFF1 LOG-QUOTIENT-TIMES-PROOF T)

(TOGGLE LOG-QUOTIENT-OFF1 LOG-QUOTIENT T)

(TOGGLE LEQ-LOG-LOG-OFF1 LEQ-LOG-LOG T)

(TOGGLE DOUBLE-LOG-INDUCTION-OFF1 DOUBLE-LOG-INDUCTION T)

(TOGGLE G*1*DOUBLE-LOG-INDUCTION-OFF1 *1*DOUBLE-LOG-INDUCTION T)

(TOGGLE LOG-1-OFF1 LOG-1 T)

(TOGGLE LOG-0-OFF1 LOG-0 T)

(TOGGLE EQUAL-LOG-0-OFF1 EQUAL-LOG-0 T)

(TOGGLE EXP-DIFFERENCE-OFF1 EXP-DIFFERENCE T)

(TOGGLE EQUAL-EXP-1-OFF1 EQUAL-EXP-1 T)

(TOGGLE EQUAL-EXP-0-OFF1 EQUAL-EXP-0 T)

(TOGGLE EXP-EXP-OFF1 EXP-EXP T)

(TOGGLE EXP-TIMES-OFF1 EXP-TIMES T)

(TOGGLE EXP-0-ARG2-OFF1 EXP-0-ARG2 T)

(TOGGLE EXP-1-ARG1-OFF1 EXP-1-ARG1 T)

(TOGGLE EXP-0-ARG1-OFF1 EXP-0-ARG1 T)

(TOGGLE EXP-PLUS-OFF1 EXP-PLUS T)

(TOGGLE EXP-ADD1-OFF1 EXP-ADD1 T)

(TOGGLE EXP-ZERO-OFF1 EXP-ZERO T)

(TOGGLE QUOTIENT-EXP-OFF1 QUOTIENT-EXP T)

(TOGGLE REMAINDER-EXP-EXP-OFF1 REMAINDER-EXP-EXP T)

(TOGGLE DOUBLE-NUMBER-INDUCTION-OFF1 DOUBLE-NUMBER-INDUCTION T)

(TOGGLE G*1*DOUBLE-NUMBER-INDUCTION-OFF1 *1*DOUBLE-NUMBER-INDUCTION T)

(TOGGLE REMAINDER-EXP-OFF1 REMAINDER-EXP T)

(TOGGLE GCD-OFF1 GCD T)

(TOGGLE G*1*GCD-OFF1 *1*GCD T)

(TOGGLE LOG-OFF1 LOG T)

(TOGGLE G*1*LOG-OFF1 *1*LOG T)

(TOGGLE EXP-OFF1 EXP T)

(TOGGLE G*1*EXP-OFF1 *1*EXP T)

(TOGGLE CANCEL-QUOTIENT-TIMES-OFF1 CANCEL-QUOTIENT-TIMES T)

(TOGGLE G*1*CANCEL-QUOTIENT-TIMES-OFF1 *1*CANCEL-QUOTIENT-TIMES T)

(TOGGLE LESSP-QUOTIENT-OFF1 LESSP-QUOTIENT T)

(TOGGLE QUOTIENT-X-X-OFF1 QUOTIENT-X-X T)

(TOGGLE QUOTIENT-1-ARG1-OFF1 QUOTIENT-1-ARG1 T)

(TOGGLE QUOTIENT-1-ARG1-CASESPLIT-OFF1 QUOTIENT-1-ARG1-CASESPLIT T)

(TOGGLE QUOTIENT-1-ARG2-OFF1 QUOTIENT-1-ARG2 T)

(TOGGLE LEQ-QUOTIENT-OFF1 LEQ-QUOTIENT T)

(TOGGLE QUOTIENT-QUOTIENT-OFF1 QUOTIENT-QUOTIENT T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-INSTANCE-OFF1
        QUOTIENT-PLUS-TIMES-TIMES-INSTANCE T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-OFF1 QUOTIENT-PLUS-TIMES-TIMES T)

(TOGGLE QUOTIENT-PLUS-TIMES-TIMES-PROOF-OFF1 QUOTIENT-PLUS-TIMES-TIMES-PROOF T)

(TOGGLE QUOTIENT-PLUS-FACT-OFF1 QUOTIENT-PLUS-FACT T)

(TOGGLE QUOTIENT-REMAINDER-INSTANCE-OFF1 QUOTIENT-REMAINDER-INSTANCE T)

(TOGGLE QUOTIENT-REMAINDER-OFF1 QUOTIENT-REMAINDER T)

(TOGGLE QUOTIENT-REMAINDER-TIMES-OFF1 QUOTIENT-REMAINDER-TIMES T)

(TOGGLE QUOTIENT-DIFFERENCE3-OFF1 QUOTIENT-DIFFERENCE3 T)

(TOGGLE QUOTIENT-DIFFERENCE2-OFF1 QUOTIENT-DIFFERENCE2 T)

(TOGGLE QUOTIENT-LESSP-ARG1-OFF1 QUOTIENT-LESSP-ARG1 T)

(TOGGLE QUOTIENT-DIFFERENCE1-OFF1 QUOTIENT-DIFFERENCE1 T)

(TOGGLE QUOTIENT-TIMES-TIMES-PROOF-OFF1 QUOTIENT-TIMES-TIMES-PROOF T)

(TOGGLE QUOTIENT-TIMES-INSTANCE-OFF1 QUOTIENT-TIMES-INSTANCE T)

(TOGGLE QUOTIENT-TIMES-OFF1 QUOTIENT-TIMES T)

(TOGGLE QUOTIENT-TIMES-PROOF-OFF1 QUOTIENT-TIMES-PROOF T)

(TOGGLE QUOTIENT-TIMES-INSTANCE-TEMP-PROOF-OFF1
        QUOTIENT-TIMES-INSTANCE-TEMP-PROOF T)

(TOGGLE QUOTIENT-PLUS-OFF1 QUOTIENT-PLUS T)

(TOGGLE QUOTIENT-PLUS-PROOF-OFF1 QUOTIENT-PLUS-PROOF T)

(TOGGLE QUOTIENT-SUB1-OFF1 QUOTIENT-SUB1 T)

(TOGGLE EQUAL-QUOTIENT-0-OFF1 EQUAL-QUOTIENT-0 T)

(TOGGLE QUOTIENT-ADD1-OFF1 QUOTIENT-ADD1 T)

(TOGGLE QUOTIENT-ZERO-OFF1 QUOTIENT-ZERO T)

(TOGGLE QUOTIENT-OF-NON-NUMBER-OFF1 QUOTIENT-OF-NON-NUMBER T)

(TOGGLE QUOTIENT-NOOP-OFF1 QUOTIENT-NOOP T)

(TOGGLE TRANSITIVITY-OF-DIVIDES-OFF1 TRANSITIVITY-OF-DIVIDES T)

(TOGGLE REMAINDER-X-X-OFF1 REMAINDER-X-X T)

(TOGGLE REMAINDER-1-ARG2-OFF1 REMAINDER-1-ARG2 T)

(TOGGLE REMAINDER-1-ARG1-OFF1 REMAINDER-1-ARG1 T)

(TOGGLE REMAINDER-REMAINDER-OFF1 REMAINDER-REMAINDER T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-INSTANCE-OFF1
        REMAINDER-PLUS-TIMES-TIMES-INSTANCE T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-OFF1 REMAINDER-PLUS-TIMES-TIMES T)

(TOGGLE REMAINDER-PLUS-TIMES-TIMES-PROOF-OFF1 REMAINDER-PLUS-TIMES-TIMES-PROOF
        T)

(TOGGLE REMAINDER-PLUS-FACT-OFF1 REMAINDER-PLUS-FACT T)

(TOGGLE REMAINDER-DIFFERENCE2-OFF1 REMAINDER-DIFFERENCE2 T)

(TOGGLE DOUBLE-REMAINDER-INDUCTION-OFF1 DOUBLE-REMAINDER-INDUCTION T)

(TOGGLE G*1*DOUBLE-REMAINDER-INDUCTION-OFF1 *1*DOUBLE-REMAINDER-INDUCTION T)

(TOGGLE REMAINDER-DIFFERENCE1-OFF1 REMAINDER-DIFFERENCE1 T)

(TOGGLE REMAINDER-TIMES2-INSTANCE-OFF1 REMAINDER-TIMES2-INSTANCE T)

(TOGGLE REMAINDER-TIMES2-OFF1 REMAINDER-TIMES2 T)

(TOGGLE REMAINDER-TIMES2-PROOF-OFF1 REMAINDER-TIMES2-PROOF T)

(TOGGLE REMAINDER-TIMES-TIMES-PROOF-OFF1 REMAINDER-TIMES-TIMES-PROOF T)

(TOGGLE REMAINDER-TIMES1-INSTANCE-OFF1 REMAINDER-TIMES1-INSTANCE T)

(TOGGLE REMAINDER-TIMES1-INSTANCE-PROOF-OFF1 REMAINDER-TIMES1-INSTANCE-PROOF T)

(TOGGLE REMAINDER-TIMES1-OFF1 REMAINDER-TIMES1 T)

(TOGGLE REMAINDER-TIMES1-PROOF-OFF1 REMAINDER-TIMES1-PROOF T)

(TOGGLE EQUAL-REMAINDER-PLUS-REMAINDER-PROOF-OFF1
        EQUAL-REMAINDER-PLUS-REMAINDER-PROOF T)

(TOGGLE EQUAL-REMAINDER-PLUS-0-OFF1 EQUAL-REMAINDER-PLUS-0 T)

(TOGGLE EQUAL-REMAINDER-PLUS-0-PROOF-OFF1 EQUAL-REMAINDER-PLUS-0-PROOF T)

(TOGGLE REMAINDER-PLUS-OFF1 REMAINDER-PLUS T)

(TOGGLE REMAINDER-PLUS-PROOF-OFF1 REMAINDER-PLUS-PROOF T)

(TOGGLE REMAINDER-ADD1-OFF1 REMAINDER-ADD1 T)

(TOGGLE REMAINDER-QUOTIENT-ELIM-OFF1 REMAINDER-QUOTIENT-ELIM T)

(TOGGLE REMAINDER-ZERO-OFF1 REMAINDER-ZERO T)

(TOGGLE REMAINDER-OF-NON-NUMBER-OFF1 REMAINDER-OF-NON-NUMBER T)

(TOGGLE REMAINDER-NOOP-OFF1 REMAINDER-NOOP T)

(TOGGLE LESSP-REMAINDER-OFF1 LESSP-REMAINDER T)

(TOGGLE CANCEL-EQUAL-TIMES-OFF1 CANCEL-EQUAL-TIMES T)

(TOGGLE G*1*CANCEL-EQUAL-TIMES-OFF1 *1*CANCEL-EQUAL-TIMES T)

(TOGGLE CANCEL-LESSP-TIMES-OFF1 CANCEL-LESSP-TIMES T)

(TOGGLE G*1*CANCEL-LESSP-TIMES-OFF1 *1*CANCEL-LESSP-TIMES T)

(TOGGLE INFER-EQUALITY-FROM-NOT-LESSP-OFF1 INFER-EQUALITY-FROM-NOT-LESSP T)

(TOGGLE LESSP-TIMES-ARG1-OFF1 LESSP-TIMES-ARG1 T)

(TOGGLE EVAL$-EQUAL-OFF2 EVAL$-EQUAL T)

(TOGGLE AND-NOT-ZEROP-TREE-OFF1 AND-NOT-ZEROP-TREE T)

(TOGGLE G*1*AND-NOT-ZEROP-TREE-OFF1 *1*AND-NOT-ZEROP-TREE T)

(TOGGLE OR-ZEROP-TREE-OFF1 OR-ZEROP-TREE T)

(TOGGLE G*1*OR-ZEROP-TREE-OFF1 *1*OR-ZEROP-TREE T)

(TOGGLE TIMES-FRINGE-OFF1 TIMES-FRINGE T)

(TOGGLE G*1*TIMES-FRINGE-OFF1 *1*TIMES-FRINGE T)

(TOGGLE TIMES-TREE-OFF1 TIMES-TREE T)

(TOGGLE G*1*TIMES-TREE-OFF1 *1*TIMES-TREE T)

(TOGGLE LESSP-1-TIMES-OFF1 LESSP-1-TIMES T)

(TOGGLE LESSP-PLUS-TIMES2-OFF1 LESSP-PLUS-TIMES2 T)

(TOGGLE LESSP-PLUS-TIMES1-OFF1 LESSP-PLUS-TIMES1 T)

(TOGGLE LESSP-PLUS-TIMES-PROOF-OFF1 LESSP-PLUS-TIMES-PROOF T)

(TOGGLE LESSP-TIMES-CANCELLATION-PROOF-OFF1 LESSP-TIMES-CANCELLATION-PROOF T)

(TOGGLE LESSP-TIMES3-OFF1 LESSP-TIMES3 T)

(TOGGLE LESSP-TIMES3-PROOF2-OFF1 LESSP-TIMES3-PROOF2 T)

(TOGGLE LESSP-TIMES3-PROOF1-OFF1 LESSP-TIMES3-PROOF1 T)

(TOGGLE LESSP-TIMES2-OFF1 LESSP-TIMES2 T)

(TOGGLE LESSP-TIMES2-PROOF-OFF1 LESSP-TIMES2-PROOF T)

(TOGGLE LESSP-TIMES1-OFF1 LESSP-TIMES1 T)

(TOGGLE LESSP-TIMES1-PROOF-OFF1 LESSP-TIMES1-PROOF T)

(TOGGLE TIMES-1-ARG1-OFF1 TIMES-1-ARG1 T)

(TOGGLE TIMES-QUOTIENT-OFF1 TIMES-QUOTIENT T)

(TOGGLE TIMES-QUOTIENT-PROOF-OFF1 TIMES-QUOTIENT-PROOF T)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-OFF1
        TIMES-DISTRIBUTES-OVER-DIFFERENCE T)

(TOGGLE TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF-OFF1
        TIMES-DISTRIBUTES-OVER-DIFFERENCE-PROOF T)

(TOGGLE ASSOCIATIVITY-OF-TIMES-OFF1 ASSOCIATIVITY-OF-TIMES T)

(TOGGLE COMMUTATIVITY2-OF-TIMES-OFF1 COMMUTATIVITY2-OF-TIMES T)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-OFF1 TIMES-DISTRIBUTES-OVER-PLUS T)

(TOGGLE TIMES-DISTRIBUTES-OVER-PLUS-PROOF-OFF1
        TIMES-DISTRIBUTES-OVER-PLUS-PROOF T)

(TOGGLE COMMUTATIVITY-OF-TIMES-OFF1 COMMUTATIVITY-OF-TIMES T)

(TOGGLE TIMES-ADD1-OFF1 TIMES-ADD1 T)

(TOGGLE TIMES-ZERO-OFF1 TIMES-ZERO T)

(TOGGLE EQUAL-SUB1-0-OFF1 EQUAL-SUB1-0 T)

(TOGGLE EQUAL-TIMES-1-OFF1 EQUAL-TIMES-1 T)

(TOGGLE EQUAL-TIMES-0-OFF1 EQUAL-TIMES-0 T)

(TOGGLE CANCEL-LESSP-PLUS-OFF1 CANCEL-LESSP-PLUS T)

(TOGGLE G*1*CANCEL-LESSP-PLUS-OFF1 *1*CANCEL-LESSP-PLUS T)

(TOGGLE DIFFERENCE-X-X-OFF1 DIFFERENCE-X-X T)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG2-OFF1 DIFFERENCE-DIFFERENCE-ARG2 T)

(TOGGLE DIFFERENCE-DIFFERENCE-ARG1-OFF1 DIFFERENCE-DIFFERENCE-ARG1 T)

(TOGGLE DIFFERENCE-SUB1-ARG2-OFF1 DIFFERENCE-SUB1-ARG2 T)

(TOGGLE DIFFERENCE-ADD1-ARG2-OFF1 DIFFERENCE-ADD1-ARG2 T)

(TOGGLE DIFFERENCE-LEQ-ARG1-OFF1 DIFFERENCE-LEQ-ARG1 T)

(TOGGLE DIFFERENCE-ELIM-OFF1 DIFFERENCE-ELIM T)

(TOGGLE CANCEL-DIFFERENCE-PLUS-OFF1 CANCEL-DIFFERENCE-PLUS T)

(TOGGLE G*1*CANCEL-DIFFERENCE-PLUS-OFF1 *1*CANCEL-DIFFERENCE-PLUS T)

(TOGGLE CANCEL-EQUAL-PLUS-OFF1 CANCEL-EQUAL-PLUS T)

(TOGGLE G*1*CANCEL-EQUAL-PLUS-OFF1 *1*CANCEL-EQUAL-PLUS T)

(TOGGLE EVAL$-QUOTE-OFF2 EVAL$-QUOTE T)

(TOGGLE PLUS-TREE-OFF1 PLUS-TREE T)

(TOGGLE G*1*PLUS-TREE-OFF1 *1*PLUS-TREE T)

(TOGGLE PLUS-FRINGE-OFF1 PLUS-FRINGE T)

(TOGGLE G*1*PLUS-FRINGE-OFF1 *1*PLUS-FRINGE T)

(TOGGLE DIFF-DIFF-ARG2-OFF1 DIFF-DIFF-ARG2 T)

(TOGGLE DIFF-DIFF-ARG1-OFF1 DIFF-DIFF-ARG1 T)

(TOGGLE DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF-OFF1
        DIFFERENCE-PLUS-PLUS-CANCELLATION-PROOF T)

(TOGGLE DIFFERENCE-PLUS-CANCELLATION-PROOF-OFF1
        DIFFERENCE-PLUS-CANCELLATION-PROOF T)

(TOGGLE PLUS-DIFFERENCE-ARG2-OFF1 PLUS-DIFFERENCE-ARG2 T)

(TOGGLE PLUS-DIFFERENCE-ARG1-OFF1 PLUS-DIFFERENCE-ARG1 T)

(TOGGLE ASSOCIATIVITY-OF-PLUS-OFF1 ASSOCIATIVITY-OF-PLUS T)

(TOGGLE PLUS-ADD1-ARG2-OFF1 PLUS-ADD1-ARG2 T)

(TOGGLE PLUS-ADD1-ARG1-OFF1 PLUS-ADD1-ARG1 T)

(TOGGLE PLUS-ZERO-ARG2-OFF1 PLUS-ZERO-ARG2 T)

(TOGGLE COMMUTATIVITY2-OF-PLUS-OFF1 COMMUTATIVITY2-OF-PLUS T)

(TOGGLE COMMUTATIVITY-OF-PLUS-OFF1 COMMUTATIVITY-OF-PLUS T)

(TOGGLE EQUAL-DIFFERENCE-0-OFF1 EQUAL-DIFFERENCE-0 T)

(TOGGLE EQUAL-PLUS-0-OFF1 EQUAL-PLUS-0 T)

(TOGGLE MEMBER-BAGINT-OFF1 MEMBER-BAGINT T)

(TOGGLE OCCURRENCES-BAGDIFF-OFF1 OCCURRENCES-BAGDIFF T)

(TOGGLE OCCURRENCES-BAGINT-OFF1 OCCURRENCES-BAGINT T)

(TOGGLE SUBBAGP-BAGINT2-OFF1 SUBBAGP-BAGINT2 T)

(TOGGLE SUBBAGP-BAGINT1-OFF1 SUBBAGP-BAGINT1 T)

(TOGGLE SUBBAGP-CDR2-OFF1 SUBBAGP-CDR2 T)

(TOGGLE SUBBAGP-CDR1-OFF1 SUBBAGP-CDR1 T)

(TOGGLE SUBBAGP-DELETE-OFF1 SUBBAGP-DELETE T)

(TOGGLE BAGDIFF-DELETE-OFF1 BAGDIFF-DELETE T)

(TOGGLE MEMBER-BAGDIFF-OFF1 MEMBER-BAGDIFF T)

(TOGGLE OCCURRENCES-DELETE-OFF1 OCCURRENCES-DELETE T)

(TOGGLE MEMBER-DELETE-IMPLIES-MEMBERSHIP-OFF1 MEMBER-DELETE-IMPLIES-MEMBERSHIP
        T)

(TOGGLE MEMBER-DELETE-OFF1 MEMBER-DELETE T)

(TOGGLE MEMBER-NON-LIST-OFF1 MEMBER-NON-LIST T)

(TOGGLE EQUAL-OCCURRENCES-ZERO-OFF1 EQUAL-OCCURRENCES-ZERO T)

(TOGGLE DELETE-DELETE-OFF1 DELETE-DELETE T)

(TOGGLE DELETE-NON-MEMBER-OFF1 DELETE-NON-MEMBER T)

(TOGGLE SUBBAGP-OFF1 SUBBAGP T)

(TOGGLE G*1*SUBBAGP-OFF1 *1*SUBBAGP T)

(TOGGLE OCCURRENCES-OFF1 OCCURRENCES T)

(TOGGLE G*1*OCCURRENCES-OFF1 *1*OCCURRENCES T)

(TOGGLE BAGINT-OFF1 BAGINT T)

(TOGGLE G*1*BAGINT-OFF1 *1*BAGINT T)

(TOGGLE BAGDIFF-OFF1 BAGDIFF T)

(TOGGLE G*1*BAGDIFF-OFF1 *1*BAGDIFF T)

(TOGGLE DELETE-OFF1 DELETE T)

(TOGGLE G*1*DELETE-OFF1 *1*DELETE T)

(TOGGLE V-ADDER-OUTPUT=V-SUM-ON V-ADDER-OUTPUT=V-SUM NIL)

(TOGGLE V-ADDER-CARRY-OUT=V-CARRY-ON V-ADDER-CARRY-OUT=V-CARRY NIL)

(TOGGLE V-TO-NAT-FIRSTN-HACK1-ON V-TO-NAT-FIRSTN-HACK1 NIL)

(TOGGLE V-TO-NAT-FIRSTN-HACK2-ON V-TO-NAT-FIRSTN-HACK2 NIL)

(TOGGLE EQUAL-NAT-TO-V-INVERTER-HACK1-ON EQUAL-NAT-TO-V-INVERTER-HACK1 NIL)

(TOGGLE EQUAL-NAT-TO-V-INVERTER-HACK2-ON EQUAL-NAT-TO-V-INVERTER-HACK2 NIL)

(TOGGLE EQUAL-IFF-ON EQUAL-IFF NIL)

(TOGGLE QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG-ON
        QUOTIENT-PLUS-X-X-2-WITH-EXTRA-ARG NIL)

(TOGGLE PLUS-QUOTIENT-2-LEMMA-ON PLUS-QUOTIENT-2-LEMMA NIL)

(TOGGLE PLUS-QUOTIENT-2-ON PLUS-QUOTIENT-2 NIL)

(TOGGLE V-ALU-CORRECT-NAT-INT-BUF-ON V-ALU-CORRECT-NAT-INT-BUF NIL)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-CARRY-OUT-ON V-ALU-CORRECT-NAT-ADDER-CARRY-OUT
        NIL)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-OUTPUT-ON V-ALU-CORRECT-NAT-ADDER-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-ON V-ALU-CORRECT-NAT-ADDER NIL)

(TOGGLE V-ALU-CORRECT-NAT-INC-ON V-ALU-CORRECT-NAT-INC NIL)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT-ON
        V-ALU-CORRECT-NAT-SUBTRACTER-CARRY-OUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT-ON
        V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-SUBTRACTER-ON V-ALU-CORRECT-NAT-SUBTRACTER NIL)

(TOGGLE V-ALU-CORRECT-NAT-DEC-ON V-ALU-CORRECT-NAT-DEC NIL)

(TOGGLE V-ALU-CORRECT-NAT-LSR-CARRY-OUT-ON V-ALU-CORRECT-NAT-LSR-CARRY-OUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-LSR-OUTPUT-ON V-ALU-CORRECT-NAT-LSR-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-LSR-ON V-ALU-CORRECT-NAT-LSR NIL)

(TOGGLE V-ALU-CORRECT-NAT-NOT-OUTPUT-ON V-ALU-CORRECT-NAT-NOT-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-NAT-NOT-ON V-ALU-CORRECT-NAT-NOT NIL)

(TOGGLE V-ALU-CORRECT-INT-ADDER-OVERFLOWP-ON V-ALU-CORRECT-INT-ADDER-OVERFLOWP
        NIL)

(TOGGLE V-ALU-CORRECT-INT-ADDER-OUTPUT-ON V-ALU-CORRECT-INT-ADDER-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-INT-ADDER-ON V-ALU-CORRECT-INT-ADDER NIL)

(TOGGLE V-ALU-CORRECT-INT-INC-ON V-ALU-CORRECT-INT-INC NIL)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP-ON
        V-ALU-CORRECT-INT-SUBTRACTER-OVERFLOWP NIL)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-OUTPUT-ON
        V-ALU-CORRECT-INT-SUBTRACTER-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-INT-SUBTRACTER-ON V-ALU-CORRECT-INT-SUBTRACTER NIL)

(TOGGLE V-ALU-CORRECT-INT-DEC-ON V-ALU-CORRECT-INT-DEC NIL)

(TOGGLE V-ALU-CORRECT-INT-ASR-OUTPUT-ON V-ALU-CORRECT-INT-ASR-OUTPUT NIL)

(TOGGLE V-ALU-CORRECT-INT-ASR-ON V-ALU-CORRECT-INT-ASR NIL)

(TOGGLE V-ALU-CORRECT-INT-NEG-ON V-ALU-CORRECT-INT-NEG NIL)

(TOGGLE V-ALU-CORRECT-INT-NOT-ON V-ALU-CORRECT-INT-NOT NIL)

(TOGGLE V-ALU-CORRECT-INT-NOT-OUTPUT-OFF1 V-ALU-CORRECT-INT-NOT-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-NOT-OUTPUT-OFF2 V-ALU-CORRECT-NAT-NOT-OUTPUT T)

(TOGGLE V-ALU-CORRECT-NAT-LSR-CARRY-OUT-OFF1 V-ALU-CORRECT-NAT-LSR-CARRY-OUT T)

(TOGGLE V-ADDER-OUTPUT=V-SUM-OFF1 V-ADDER-OUTPUT=V-SUM T)

(TOGGLE V-ALU-CORRECT-NAT-INC-OFF1 V-ALU-CORRECT-NAT-INC T)

(TOGGLE V-ALU-CORRECT-NAT-ADDER-OFF1 V-ALU-CORRECT-NAT-ADDER T)

(TOGGLE V-ALU-CORRECT-INT-ASR-OFF1 V-ALU-CORRECT-INT-ASR T)

(TOGGLE V-ALU-CORRECT-NAT-LSR-OFF1 V-ALU-CORRECT-NAT-LSR T)

(TOGGLE V-TO-NAT-OF-NAT-TO-V-ON V-TO-NAT-OF-NAT-TO-V NIL)

(TOGGLE IPLUS-0-LEFT-ON1 IPLUS-0-LEFT NIL)

(TOGGLE IPLUS-0-RIGHT-ON1 IPLUS-0-RIGHT NIL)

(TOGGLE COMMUTATIVITY-OF-IPLUS-ON1 COMMUTATIVITY-OF-IPLUS NIL)

(PROVE-LEMMA V-NEGP->V-NZEROP
             (REWRITE)
             (IMPLIES (V-NEGP V) (V-NZEROP V))
             ((ENABLE V-NEGP V-NZEROP)))

(PROVE-LEMMA V-ZEROP-IMPLIES-V-TO-NAT-0
             (REWRITE)
             (IMPLIES (V-ZEROP A)
                      (EQUAL (V-TO-NAT A) 0))
             ((ENABLE V-NZEROP V-TO-NAT)))

(PROVE-LEMMA BOOLP-FLAG-EXTRACTERS
             (REWRITE)
             (AND (BOOLP (C-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
                  (BOOLP (V-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
                  (BOOLP (N-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV)))
                  (BOOLP (Z-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS CVZBV))))
             ((ENABLE UPDATE-FLAGS)
              (ENABLE-THEORY FLAGS-THEORY)))

(PROVE-LEMMA V-TO-NAT-EQUAL
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (EQUAL (V-TO-NAT A) (V-TO-NAT B))
                             (EQUAL A B)))
             ((INDUCT (V-IFF A B))
              (ENABLE BVP V-TO-NAT)))

(PROVE-LEMMA V-NZEROP-NAT-TO-V-ZERO
             (REWRITE)
             (IMPLIES (ZEROP Z)
                      (NOT (V-NZEROP (NAT-TO-V Z L))))
             ((ENABLE V-NZEROP NAT-TO-V)))

(PROVE-LEMMA V-NOT-V-NOT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (V-NOT (V-NOT A)) A))
             ((ENABLE V-NOT BVP)))

(PROVE-LEMMA REWRITE-EQUAL-V-TO-NAT-0
             (REWRITE)
             (EQUAL (EQUAL (V-TO-NAT A) 0)
                    (V-ZEROP A))
             ((ENABLE V-TO-NAT V-ZEROP V-NZEROP)))

(TOGGLE REWRITE-EQUAL-V-TO-NAT-0-OFF REWRITE-EQUAL-V-TO-NAT-0 T)

(DEFN CC-CC NIL (LIST F F F F))

(DEFN CC-CS NIL (LIST T F F F))

(DEFN CC-VC NIL (LIST F T F F))

(DEFN CC-VS NIL (LIST T T F F))

(DEFN CC-PL NIL (LIST F F T F))

(DEFN CC-MI NIL (LIST T F T F))

(DEFN CC-NE NIL (LIST F T T F))

(DEFN CC-EQ NIL (LIST T T T F))

(DEFN CC-HI NIL (LIST F F F T))

(DEFN CC-LS NIL (LIST T F F T))

(DEFN CC-GE NIL (LIST F T F T))

(DEFN CC-LT NIL (LIST T T F T))

(DEFN CC-GT NIL (LIST F F T T))

(DEFN CC-LE NIL (LIST T F T T))

(DEFN CC-T NIL (LIST F T T T))

(DEFN CC-F NIL (LIST T T T T))

(DEFTHEORY CONDITION-CODE-THEORY
           (CC-CC CC-CS CC-VC CC-VS CC-PL CC-MI CC-NE CC-EQ CC-HI CC-LS CC-GE
                  CC-LT CC-GT CC-LE CC-T CC-F))

(DEFN OP-MOVE NIL (LIST F F F F))

(DEFN OP-INC NIL (LIST T F F F))

(DEFN OP-ADDC NIL (LIST F T F F))

(DEFN OP-ADD NIL (LIST T T F F))

(DEFN OP-NEG NIL (LIST F F T F))

(DEFN OP-DEC NIL (LIST T F T F))

(DEFN OP-SUBB NIL (LIST F T T F))

(DEFN OP-SUB NIL (LIST T T T F))

(DEFN OP-ROR NIL (LIST F F F T))

(DEFN OP-ASR NIL (LIST T F F T))

(DEFN OP-LSR NIL (LIST F T F T))

(DEFN OP-XOR NIL (LIST T T F T))

(DEFN OP-OR NIL (LIST F F T T))

(DEFN OP-AND NIL (LIST T F T T))

(DEFN OP-NOT NIL (LIST F T T T))

(DEFN OP-M15 NIL (LIST T T T T))

(DEFTHEORY OPCODE-THEORY
           (OP-MOVE OP-INC OP-ADDC OP-ADD OP-NEG OP-DEC OP-SUBB OP-SUB OP-ROR
                    OP-ASR OP-LSR OP-XOR OP-OR OP-AND OP-NOT OP-M15))

(PROVE-LEMMA ZB-V-ALU NIL
             (EQUAL (ZB (V-ALU C A B OP-CODE))
                    (V-ZEROP (BV (V-ALU C A B OP-CODE))))
             ((ENABLE ZB V-ALU BV)))

(PROVE-LEMMA N-V-ALU NIL
             (EQUAL (N (V-ALU C A B OP-CODE))
                    (V-NEGP (BV (V-ALU C A B OP-CODE))))
             ((ENABLE N V-ALU BV)))

(PROVE-LEMMA UNIVERSAL-FLAGS-INTERPRETATIONS NIL
 (IMPLIES
  (AND (BVP A)
       (BOOLP C)
       (NOT (ZEROP (LENGTH A))))
  (AND
      (IMPLIES (Z-SET SET-FLAGS)
               (AND (EQUAL (STORE-RESULTP (CC-NE)
                                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                                        (V-ALU C A B OP-CODE)))
                           (V-NZEROP (BV (V-ALU C A B OP-CODE))))
                    (EQUAL (STORE-RESULTP (CC-EQ)
                                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                                        (V-ALU C A B OP-CODE)))
                           (NOT (V-NZEROP (BV (V-ALU C A B OP-CODE)))))))
      (IMPLIES (N-SET SET-FLAGS)
               (AND (EQUAL (STORE-RESULTP (CC-PL)
                                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                                        (V-ALU C A B OP-CODE)))
                           (NOT (V-NEGP (BV (V-ALU C A B OP-CODE)))))
                    (EQUAL (STORE-RESULTP (CC-MI)
                                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                                        (V-ALU C A B OP-CODE)))
                           (V-NEGP (BV (V-ALU C A B OP-CODE))))))
      (EQUAL (STORE-RESULTP (CC-T)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU C A B OP-CODE)))
             T)
      (EQUAL (STORE-RESULTP (CC-F)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU C A B OP-CODE)))
             F)))
 ((USE (ZB-V-ALU) (N-V-ALU))
  (ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP BOOLP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA V-SUM-ON-NOT-A-A
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-NZEROP (V-SUM T A B))
                             (NOT (EQUAL (V-NOT A) B))))
             ((ENABLE V-NZEROP V-SUM V-NOT)
              (DISABLE V-ALU-CORRECT-NAT-NOT-OUTPUT)))

(PROVE-LEMMA IF-V-SUBTRACTER-OUTPUT=0-THEN-A=B
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-NZEROP (V-SUBTRACTER-OUTPUT F A B))
                             (NOT (EQUAL A B))))
             ((DISABLE V-ALU-CORRECT-NAT-NOT-OUTPUT)
              (ENABLE V-SUBTRACTER-OUTPUT V-ADDER-OUTPUT=V-SUM)))

(PROVE-LEMMA ZERO-FLAG-INTERPRETATION-FOR-SUB NIL
    (IMPLIES (AND (BV2P A B) (Z-SET SET-FLAGS))
             (EQUAL (Z-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
                    (EQUAL A B)))
    ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
             V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT V-ALU-NAT-DEC
             V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-CARRY-OUT
             V-ALU-NAT-SUBTRACTER-OUTPUT C V N CV BV *1*EXP *1*B-TO-NAT ZB)
     (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)
     (DISABLE V-SUBTRACTER-OUTPUT V-ALU-CORRECT-NAT-SUBTRACTER
              V-ALU-CORRECT-NAT-SUBTRACTER-OUTPUT)))

(PROVE-LEMMA FLAGS-INTERPRETATION-SUB NIL
 (IMPLIES
  (AND (BV2P A B) (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NOT (EQUAL A B)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (EQUAL A B))))
 ((USE (ZERO-FLAG-INTERPRETATION-FOR-SUB))
  (ENABLE SET-FLAGS STORE-RESULTP)
  (DISABLE V-ALU-CORRECT-NAT-INC V-ALU-CORRECT-NAT-ADDER)))

(PROVE-LEMMA V-NEGP-V-SHIFT-RIGHT
             (REWRITE)
             (IMPLIES (AND (NOT (EQUAL (LENGTH A) 0))
                           (BOOLP C))
                      (EQUAL (V-NEGP (V-SHIFT-RIGHT A C))
                             C))
             ((ENABLE V-NEGP V-SHIFT-RIGHT APPEND V-BUF)
              (INDUCT (LENGTH A))))

(PROVE-LEMMA FLAGS-INTERPRETATION-ROR NIL
 (IMPLIES
  (AND (BVP A)
       (BOOLP (C-FLAG FLAGS))
       (NOT (ZEROP (LENGTH A))))
  (AND
   (IMPLIES
    (C-SET SET-FLAGS)
    (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ROR))))
             (NOT (NTH 0 A)))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ROR))))
             (NTH 0 A))))
   (IMPLIES
    (N-SET SET-FLAGS)
    (AND
      (EQUAL (STORE-RESULTP (CC-PL)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ROR))))
             (NOT (C-FLAG FLAGS)))
      (EQUAL (STORE-RESULTP (CC-MI)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ROR))))
             (C-FLAG FLAGS))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C N BV)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-LSR NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (C-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (NOT (NTH 0 A)))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (NTH 0 A))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-XOR NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-XOR))))
             (NOT (EQUAL A B)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-XOR))))
             (EQUAL A B))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU ZB)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-MOVE NIL
 (IMPLIES
  (AND (BV2P A B) (Z-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-NE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NOT (EQUAL (V-TO-NAT A) 0)))
     (EQUAL (STORE-RESULTP (CC-EQ)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (EQUAL (V-TO-NAT A) 0))
     (EQUAL (STORE-RESULTP (CC-NE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NOT (EQUAL (V-TO-NAT A) 0)))
     (EQUAL (STORE-RESULTP (CC-EQ)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (EQUAL (V-TO-NAT A) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV *1*EXP
          *1*B-TO-NAT ZB REWRITE-EQUAL-V-TO-NAT-0)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-INC NIL
 (IMPLIES
  (AND (BV2P A B) (C-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (LESSP (ADD1 (V-TO-NAT A))
                    (EXP 2 (LENGTH A))))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (NOT (LESSP (ADD1 (V-TO-NAT A))
                         (EXP 2 (LENGTH A)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT C V N CV BV *1*EXP
          *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-ADDC NIL
 (IMPLIES
  (AND (BV2P A B) (C-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-CC)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (LESSP (PLUS (B-TO-NAT (C-FLAG FLAGS))
                         (V-TO-NAT A)
                         (V-TO-NAT B))
                   (EXP 2 (LENGTH A))))
     (EQUAL (STORE-RESULTP (CC-CS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (NOT (LESSP (PLUS (B-TO-NAT (C-FLAG FLAGS))
                              (V-TO-NAT A)
                              (V-TO-NAT B))
                        (EXP 2 (LENGTH A)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT C V N CV BV *1*EXP
          *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-ADD NIL
 (IMPLIES
  (AND (BV2P A B) (C-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (LESSP (PLUS (V-TO-NAT A) (V-TO-NAT B))
                    (EXP 2 (LENGTH A))))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (NOT (LESSP (PLUS (V-TO-NAT A) (V-TO-NAT B))
                         (EXP 2 (LENGTH A)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT C V N CV BV *1*EXP
          *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA WHEN-THE-MANTISSA-ISNT-0-THEN-NEITHER-IS-THE-EXPONENTIAL
             (REWRITE)
             (IMPLIES (NOT (ZEROP MANTISSA))
                      (NOT (EQUAL (EXP MANTISSA EXPONENT) 0)))
             ((ENABLE EXP)))

(DEFN DOUBLE-DIFFERENCE-INDUCTION
      (N M L)
      (COND ((ZEROP N) T)
            ((ZEROP M) T)
            ((ZEROP L) T)
            (T (DOUBLE-DIFFERENCE-INDUCTION (DIFFERENCE N L)
                                            (DIFFERENCE M L)
                                            L))))

(PROVE-LEMMA QUOTIENT-LESSP-DOUBLE-REMAINDER$HELP NIL
             (IMPLIES (AND (LESSP N M)
                           (NOT (ZEROP N))
                           (NOT (ZEROP M))
                           (NOT (ZEROP L))
                           (EQUAL (REMAINDER N L) 0)
                           (EQUAL (REMAINDER M L) 0))
                      (LESSP (QUOTIENT N L) (QUOTIENT M L)))
             ((INDUCT (DOUBLE-DIFFERENCE-INDUCTION N M L))))

(PROVE-LEMMA V-NZEROP-NAT-TO-V$HELP
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP L))
                           (NOT (ZEROP N))
                           (EQUAL (REMAINDER N 2) 0)
                           (LESSP N (EXP 2 L)))
                      (LESSP (QUOTIENT N 2)
                             (EXP 2 (SUB1 L))))
             ((ENABLE REMAINDER-EXP QUOTIENT-EXP)
              (USE (QUOTIENT-LESSP-DOUBLE-REMAINDER$HELP (N N)
                                                         (M (EXP 2 L))
                                                         (L 2)))))

(TOGGLE V-NZEROP-NAT-TO-V$HELP-OFF V-NZEROP-NAT-TO-V$HELP T)

(PROVE-LEMMA V-NZEROP-NAT-TO-V
             (REWRITE)
             (IMPLIES (LESSP N (EXP 2 L))
                      (EQUAL (V-NZEROP (NAT-TO-V N L))
                             (NOT (ZEROP N))))
             ((ENABLE V-NZEROP NAT-TO-V QUOTIENT EXP V-NZEROP-NAT-TO-V$HELP)
              (INDUCT (NAT-TO-V N L))))

(PROVE-LEMMA LESSP-SUB1-PLUS-A-B-B
             (REWRITE)
             (EQUAL (LESSP (SUB1 (PLUS A B)) B)
                    (AND (ZEROP A) (NOT (ZEROP B)))))

(PROVE-LEMMA LESSP-V-TO-NAT-EXP-2-LENGTH-A
             (REWRITE)
             (IMPLIES (EQUAL L (LENGTH A))
                      (EQUAL (LESSP (V-TO-NAT A) (EXP 2 L))
                             T))
             ((ENABLE V-TO-NAT EXP LENGTH)))

(PROVE-LEMMA LESSP-V-TO-NAT-EXP-2-LENGTH-A$LINEAR
             (REWRITE)
             (LESSP (V-TO-NAT A)
                    (EXP 2 (LENGTH A))))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-DEC NIL
 (IMPLIES
  (BV2P A B)
  (AND
   (IMPLIES
    (C-SET SET-FLAGS)
    (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NOT (EQUAL (V-TO-NAT A) 0)))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (EQUAL (V-TO-NAT A) 0))))
   (IMPLIES
    (AND (Z-SET SET-FLAGS)
         (NOT (EQUAL (LENGTH A) 0)))
    (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NOT (EQUAL (V-TO-NAT A) 1)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (EQUAL (V-TO-NAT A) 1))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-DEC V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-CARRY-OUT
          V-ALU-NAT-SUBTRACTER-OUTPUT C V N CV BV ZB *1*EXP *1*B-TO-NAT
          EQUAL-SUB1-0 EQUAL-EXP-1)
  (EXPAND (REMAINDER (SUB1 (PLUS (V-TO-NAT A)
                                 (EXP 2 (LENGTH A))))
                     (EXP 2 (LENGTH A))))
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA REMAINDER-THEOREM-FOR-SUBB
             (REWRITE)
             (IMPLIES (AND (LESSP A B) (LESSP B C))
                      (EQUAL (REMAINDER (DIFFERENCE (PLUS B C) A)
                                        C)
                             (DIFFERENCE B A)))
             ((EXPAND (REMAINDER (DIFFERENCE (PLUS B C) A)
                                 C))))

(PROVE-LEMMA DIFFERENCE-LINEAR
             (REWRITE)
             (IMPLIES (LESSP A B)
                      (EQUAL (LESSP (DIFFERENCE A C) B) T)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-SUBB-CARRY NIL
 (IMPLIES
  (AND (BV2P A B) (C-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-CC)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (NOT (LESSP (V-TO-NAT B)
                        (PLUS (V-TO-NAT A)
                              (B-TO-NAT (C-FLAG FLAGS))))))
     (EQUAL (STORE-RESULTP (CC-CS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (LESSP (V-TO-NAT B)
                   (PLUS (V-TO-NAT A)
                         (B-TO-NAT (C-FLAG FLAGS)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT V-ALU-NAT-DEC
          V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-CARRY-OUT C V N CV BV
          *1*EXP *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-SUBB-HIGHER NIL
 (IMPLIES
  (AND (BV2P A B)
       (C-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-HI)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (LESSP (PLUS (V-TO-NAT A)
                         (B-TO-NAT (C-FLAG FLAGS)))
                   (V-TO-NAT B)))
     (EQUAL (STORE-RESULTP (CC-LS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (NOT (LESSP (PLUS (V-TO-NAT A)
                              (B-TO-NAT (C-FLAG FLAGS)))
                        (V-TO-NAT B))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT V-ALU-NAT-DEC
          V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-CARRY-OUT
          V-ALU-NAT-SUBTRACTER-OUTPUT C V N CV BV ZB *1*EXP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA CARRY-FLAG-NAT-INTERPRETATION-FOR-SUB NIL
    (IMPLIES (AND (BV2P A B) (C-SET SET-FLAGS))
             (EQUAL (C-FLAG (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
                    (LESSP (V-TO-NAT B) (V-TO-NAT A))))
    ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
             V-ALU-NAT-ADDER V-ALU-NAT-ADDER-CARRY-OUT V-ALU-NAT-DEC
             V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-CARRY-OUT
             V-ALU-NAT-SUBTRACTER-OUTPUT C V N CV BV *1*EXP *1*B-TO-NAT ZB)
     (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-SUB NIL
 (IMPLIES
  (BV2P A B)
  (AND
   (IMPLIES
    (C-SET SET-FLAGS)
    (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NOT (LESSP (V-TO-NAT B) (V-TO-NAT A))))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (LESSP (V-TO-NAT B) (V-TO-NAT A)))))
   (IMPLIES
    (AND (C-SET SET-FLAGS)
         (Z-SET SET-FLAGS))
    (AND
      (EQUAL (STORE-RESULTP (CC-HI)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (LESSP (V-TO-NAT A) (V-TO-NAT B)))
      (EQUAL (STORE-RESULTP (CC-LS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NOT (LESSP (V-TO-NAT A)
                         (V-TO-NAT B))))))))
 ((USE (ZERO-FLAG-INTERPRETATION-FOR-SUB)
       (CARRY-FLAG-NAT-INTERPRETATION-FOR-SUB))
  (ENABLE C-SET Z-SET STORE-RESULTP)
  (DISABLE BOOLP)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-LSR-CARRY NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (C-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (EQUAL (REMAINDER (V-TO-NAT A) 2) 0))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (NOT (EQUAL (REMAINDER (V-TO-NAT A) 2)
                         0)))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-LSR V-ALU-NAT-LSR-CARRY-OUT
          V-ALU-CORRECT-NAT-LSR-CARRY-OUT C V N CV BV *1*EXP *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)
  (DISABLE V-NEGP-V-SHIFT-RIGHT OPEN-NTH)))

(PROVE-LEMMA FLAGS-INTERPRETATION-NAT-LSR-ZERO NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (NOT (EQUAL (QUOTIENT (V-TO-NAT A) 2) 0)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-LSR))))
             (EQUAL (QUOTIENT (V-TO-NAT A) 2) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU V-ALU-NAT-INC
          V-ALU-NAT-LSR-OUTPUT ZB C V N CV BV *1*EXP *1*B-TO-NAT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA IDIFFERENCE-0
             (REWRITE)
             (IMPLIES (AND (INTEGERP A) (INTEGERP B))
                      (EQUAL (EQUAL (IDIFFERENCE A B) 0)
                             (EQUAL A B)))
             ((ENABLE INTEGERP FIX-INT IDIFFERENCE IPLUS INEG)))

(PROVE-LEMMA V-TO-NAT-LESSP-EXP-2-LENGTH
             (REWRITE)
             (LESSP (V-TO-NAT A)
                    (EXP 2 (LENGTH A)))
             ((ENABLE V-TO-NAT EXP LENGTH)))

(PROVE-LEMMA INTEGERP-V-TO-INT
             (REWRITE)
             (INTEGERP (V-TO-INT A))
             ((ENABLE INTEGERP V-TO-INT IDIFFERENCE IPLUS)))

(PROVE-LEMMA V-NEGP-AS-BOUNDS
             (REWRITE)
             (IMPLIES (BVP X)
                      (EQUAL (V-NEGP X)
                             (NOT (LESSP (V-TO-NAT X)
                                         (EXP 2 (SUB1 (LENGTH X)))))))
             ((ENABLE V-TO-NAT V-NEGP EXP LENGTH BVP)))

(TOGGLE V-NEGP-AS-BOUNDS-OFF V-NEGP-AS-BOUNDS T)

(PROVE-LEMMA NEGATIVEP-IDIFFERENCE-ON-NUMBERPS
             (REWRITE)
             (IMPLIES (AND (NUMBERP A) (NUMBERP B))
                      (EQUAL (NEGATIVEP (IDIFFERENCE A B))
                             (LESSP A B)))
             ((ENABLE IDIFFERENCE IPLUS INEG)))

(PROVE-LEMMA V-NEGP->NEGATIVEP-V-TO-INT
             (REWRITE)
             (IMPLIES (BVP A)
                      (EQUAL (V-NEGP A)
                             (NEGATIVEP (V-TO-INT A))))
             ((ENABLE V-NEGP-AS-BOUNDS V-TO-INT)))

(TOGGLE V-NEGP->NEGATIVEP-V-TO-INT-OFF V-NEGP->NEGATIVEP-V-TO-INT T)

(PROVE-LEMMA REWRITE-EQUAL-V-TO-INT-0
             (REWRITE)
             (EQUAL (EQUAL (V-TO-INT A) 0)
                    (V-ZEROP A))
             ((ENABLE INTEGERP V-TO-INT V-ZEROP V-NZEROP
                      REWRITE-EQUAL-V-TO-NAT-0)))

(TOGGLE REWRITE-EQUAL-V-TO-INT-0-OFF REWRITE-EQUAL-V-TO-INT-0 T)

(PROVE-LEMMA INT-TO-V-V-TO-INT-0
             (REWRITE)
             (EQUAL (V-TO-INT (INT-TO-V 0 L)) 0)
             ((ENABLE V-TO-INT INT-TO-V ILESSP)))

(PROVE-LEMMA BVP-INT-TO-V
             (REWRITE)
             (BVP (INT-TO-V I L))
             ((ENABLE BVP INT-TO-V)))

(PROVE-LEMMA V-TO-INT-NAT-TO-V-0
             (REWRITE)
             (EQUAL (V-TO-INT (NAT-TO-V 0 L)) 0)
             ((ENABLE V-TO-INT NAT-TO-V)))

(PROVE-LEMMA INTEGER-IN-RANGEP-MINUS-0
             (REWRITE)
             (INTEGER-IN-RANGEP (MINUS 0) L)
             ((ENABLE INTEGER-IN-RANGEP *1*EXP ILEQ ILESSP INEG)))

(PROVE-LEMMA NOT-EQUAL-IPLUS-MINUS-0
             (REWRITE)
             (NOT (EQUAL (IPLUS A B) (MINUS 0)))
             ((ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA LESSP-1-PLUS-X-X
             (REWRITE)
             (EQUAL (LESSP 1 (PLUS X X))
                    (NOT (ZEROP X))))

(PROVE-LEMMA INTEGER-IN-RANGEP-1
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP L))
                           (NOT (EQUAL L 1)))
                      (INTEGER-IN-RANGEP 1 L))
             ((ENABLE INTEGER-IN-RANGEP ILEQ ILESSP IPLUS INEG)
              (EXPAND (EXP 2 (SUB1 L)))))

(PROVE-LEMMA LESSP-A-PLUS-A-A
             (REWRITE)
             (EQUAL (LESSP A (PLUS A A))
                    (NOT (ZEROP A))))

(PROVE-LEMMA EXP-LINEAR-BOUNDS
             (REWRITE)
             (IMPLIES (AND (IF (LESSP V (EXP 2 (SUB1 N))) F T)
                           (LESSP V (EXP 2 N)))
                      (NOT (LESSP (EXP 2 (SUB1 N))
                                  (DIFFERENCE (EXP 2 N) V))))
             ((EXPAND (EXP 2 N))))

(PROVE-LEMMA INTEGER-IN-RANGEP-V-TO-INT
             (REWRITE)
             (IMPLIES (EQUAL L (LENGTH A))
                      (INTEGER-IN-RANGEP (V-TO-INT A) L))
             ((ENABLE INTEGER-IN-RANGEP V-TO-INT)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)
              (DISABLE BVP)))

(PROVE-LEMMA ADDITION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS NIL
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (LESSP (IPLUS A B) (EXP 2 L)))
             ((ENABLE EXP INTEGER-IN-RANGEP ILESSP ILEQ INEG IPLUS INT-TO-V
                      V-NEGP-AS-BOUNDS)))

(PROVE-LEMMA SUBTRACTION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS NIL
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (LESSP (IPLUS B (INEG A)) (EXP 2 L)))
             ((ENABLE EXP INTEGER-IN-RANGEP ILESSP ILEQ INEG IPLUS INT-TO-V
                      FIX-INT V-NEGP-AS-BOUNDS)))

(PROVE-LEMMA EXP-2-L-1<=EXP-2-L NIL
             (IMPLIES (NOT (ZEROP L))
                      (LESSP (EXP 2 (SUB1 L)) (EXP 2 L)))
             ((ENABLE EXP)))

(PROVE-LEMMA LESSP-REMAINDER-THEOREM NIL
             (IMPLIES (LESSP N M)
                      (LESSP (REMAINDER N R) M)))

(PROVE-LEMMA INTEGER-IN-RANGEP-THE-OBVIOUS-WAY
             (REWRITE)
             (IMPLIES (AND (NOT (ZEROP L))
                           (INTEGERP I)
                           (INTEGER-IN-RANGEP I L))
                      (EQUAL (V-NEGP (INT-TO-V I L))
                             (NEGATIVEP I)))
             ((USE (LESSP-REMAINDER-THEOREM (N I)
                                            (M (EXP 2 (SUB1 L)))
                                            (R (PLUS (EXP 2 (SUB1 L))
                                                     (EXP 2 (SUB1 L))))))
              (ENABLE EXP INTEGER-IN-RANGEP V-NEGP-AS-BOUNDS INT-TO-V)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(TOGGLE INTEGER-IN-RANGEP-THE-OBVIOUS-WAY-OFF INTEGER-IN-RANGEP-THE-OBVIOUS-WAY
        T)

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS
             (REWRITE)
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (EQUAL (INTEGER-IN-RANGEP (IPLUS A B) L)
                             (EQUAL (V-NEGP (INT-TO-V (IPLUS A B) L))
                                    (NEGATIVEP (IPLUS A B)))))
             ((USE (ADDITION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS)
                   (EXP-2-L-1<=EXP-2-L))
              (ENABLE INTEGER-IN-RANGEP EXP V-NEGP-AS-BOUNDS INT-TO-V)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(TOGGLE INTEGER-IN-RANGEP-IPLUS-OFF INTEGER-IN-RANGEP-IPLUS T)

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS$COMMUTED NIL
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (EQUAL (NEGATIVEP (IPLUS A B))
                             (IFF (INTEGER-IN-RANGEP (IPLUS A B) L)
                                  (V-NEGP (INT-TO-V (IPLUS A B) L)))))
             ((USE (INTEGER-IN-RANGEP-IPLUS))))

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-CARRY
             (REWRITE)
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (EQUAL (INTEGER-IN-RANGEP (IPLUS 1 (IPLUS A B))
                                                L)
                             (EQUAL (V-NEGP (INT-TO-V (IPLUS 1 (IPLUS A B)) L))
                                    (NEGATIVEP (IPLUS 1 (IPLUS A B))))))
             ((USE (ADDITION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS)
                   (EXP-2-L-1<=EXP-2-L))
              (ENABLE EXP INTEGER-IN-RANGEP V-NEGP-AS-BOUNDS INT-TO-V)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(TOGGLE INTEGER-IN-RANGEP-IPLUS-CARRY-OFF INTEGER-IN-RANGEP-IPLUS-CARRY T)

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-CARRY$COMMUTED NIL
            (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                          (INTEGER-IN-RANGEP B L)
                          (NOT (ZEROP L)))
                     (EQUAL (NEGATIVEP (IPLUS 1 (IPLUS A B)))
                            (IFF (INTEGER-IN-RANGEP (IPLUS 1 (IPLUS A B))
                                                    L)
                                 (V-NEGP (INT-TO-V (IPLUS 1 (IPLUS A B)) L)))))
            ((USE (INTEGER-IN-RANGEP-IPLUS-CARRY))))

(PROVE-LEMMA NOT-INTEGERP-MINUS-ZERO
             (REWRITE)
             (EQUAL (INTEGERP (MINUS X))
                    (NOT (ZEROP X)))
             ((ENABLE INTEGERP)))

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-INEG
             (REWRITE)
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (EQUAL (INTEGER-IN-RANGEP (IPLUS B (INEG A))
                                                L)
                             (EQUAL (V-NEGP (INT-TO-V (IPLUS B (INEG A)) L))
                                    (NEGATIVEP (IPLUS B (INEG A))))))
             ((USE (SUBTRACTION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS)
                   (EXP-2-L-1<=EXP-2-L))
              (ENABLE EXP INTEGER-IN-RANGEP ILESSP ILEQ INEG IPLUS INT-TO-V
                      FIX-INT V-NEGP-AS-BOUNDS)))

(TOGGLE INTEGER-IN-RANGEP-IPLUS-INEG-OFF INTEGER-IN-RANGEP-IPLUS-INEG T)

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-INEG$COMMUTED NIL
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (INTEGER-IN-RANGEP B L)
                           (NOT (ZEROP L)))
                      (EQUAL (NEGATIVEP (IPLUS B (INEG A)))
                             (IFF (INTEGER-IN-RANGEP (IPLUS B (INEG A))
                                                     L)
                                  (V-NEGP (INT-TO-V (IPLUS B (INEG A)) L)))))
             ((USE (INTEGER-IN-RANGEP-IPLUS-INEG))))

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-INEG-CARRY
          (REWRITE)
          (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                        (INTEGER-IN-RANGEP B L)
                        (NOT (ZEROP L))
                        (NOT (EQUAL L 1)))
                   (EQUAL (INTEGER-IN-RANGEP (IPLUS B (INEG (IPLUS 1 A)))
                                             L)
                          (EQUAL (V-NEGP (INT-TO-V (IPLUS B (INEG (IPLUS 1 A)))
                                                   L))
                                 (NEGATIVEP (IPLUS B (INEG (IPLUS 1 A)))))))
          ((USE (SUBTRACTION-CASES-FOR-INTEGER-IN-RANGEP-LEMMAS)
                (EXP-2-L-1<=EXP-2-L))
           (EXPAND (REMAINDER B
                              (PLUS (EXP 2 (SUB1 L))
                                    (EXP 2 (SUB1 L)))))
           (ENABLE EXP INTEGER-IN-RANGEP ILESSP ILEQ INEG IPLUS INT-TO-V
                   IDIFFERENCE FIX-INT V-NEGP-AS-BOUNDS)))

(TOGGLE INTEGER-IN-RANGEP-IPLUS-INEG-CARRY-OFF
        INTEGER-IN-RANGEP-IPLUS-INEG-CARRY T)

(PROVE-LEMMA INTEGER-IN-RANGEP-IPLUS-INEG-CARRY$COMMUTED NIL
           (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                         (INTEGER-IN-RANGEP B L)
                         (NOT (ZEROP L))
                         (NOT (EQUAL L 1)))
                    (EQUAL (NEGATIVEP (IPLUS B (INEG (IPLUS 1 A))))
                           (IFF (V-NEGP (INT-TO-V (IPLUS B (INEG (IPLUS 1 A)))
                                                  L))
                                (INTEGER-IN-RANGEP (IPLUS B (INEG (IPLUS 1 A)))
                                                   L))))
           ((USE (INTEGER-IN-RANGEP-IPLUS-INEG-CARRY))))

(PROVE-LEMMA LESSP-1-EXP-2
             (REWRITE)
             (IMPLIES (NOT (ZEROP L))
                      (LESSP 1 (EXP 2 L)))
             ((ENABLE EXP)))

(PROVE-LEMMA V-NZEROP-INT-TO-V
             (REWRITE)
             (IMPLIES (AND (INTEGER-IN-RANGEP N L)
                           (NOT (ZEROP L)))
                      (EQUAL (V-NZEROP (INT-TO-V N L))
                             (NOT (IZEROP N))))
             ((ENABLE INT-TO-V INTEGER-IN-RANGEP EXP)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA IZEROP-INC-V-NZEROP
             (REWRITE)
             (IMPLIES (AND (INTEGER-IN-RANGEP A L)
                           (NOT (ZEROP L)))
                      (EQUAL (V-NZEROP (INT-TO-V (IPLUS 1 A) L))
                             (NOT (IZEROP (IPLUS 1 A)))))
             ((ENABLE-THEORY ALL-INTEGER-DEFNS)
              (ENABLE EXP INT-TO-V INTEGER-IN-RANGEP)))

(PROVE-LEMMA V-NZEROP-INT-TO-V-0
             (REWRITE)
             (IMPLIES (IZEROP Z)
                      (NOT (V-NZEROP (INT-TO-V Z L))))
             ((ENABLE INT-TO-V)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA INTEGER-IN-RANGEP-0
             (REWRITE)
             (IMPLIES (IZEROP A)
                      (INTEGER-IN-RANGEP A L))
             ((ENABLE-THEORY ALL-INTEGER-DEFNS)
              (ENABLE INTEGER-IN-RANGEP)))

(PROVE-LEMMA NOT-V-NEGP-NAT-TO-V-0
             (REWRITE)
             (IMPLIES (ZEROP A)
                      (NOT (V-NEGP (NAT-TO-V A L))))
             ((ENABLE V-NEGP NAT-TO-V)))

(PROVE-LEMMA LENGTH-INT-TO-V
             (REWRITE)
             (EQUAL (LENGTH (INT-TO-V I L))
                    (FIX L))
             ((ENABLE INT-TO-V)))

(PROVE-LEMMA INTEGER-IN-RANGEP--1
             (REWRITE)
             (IMPLIES (NOT (ZEROP L))
                      (INTEGER-IN-RANGEP -1 L))
             ((ENABLE INTEGER-IN-RANGEP)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-MOVE NIL
 (IMPLIES
  (BVP A)
  (AND
   (IMPLIES
    (V-SET SET-FLAGS)
    (AND
     (EQUAL (STORE-RESULTP (CC-VC)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (INTEGER-IN-RANGEP (V-TO-INT A)
                               (LENGTH A)))
     (EQUAL (STORE-RESULTP (CC-VC)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (INTEGER-IN-RANGEP (V-TO-INT A)
                               (LENGTH A)))
     (EQUAL (STORE-RESULTP (CC-VS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NOT (INTEGER-IN-RANGEP (V-TO-INT A)
                                    (LENGTH A))))
     (EQUAL (STORE-RESULTP (CC-VS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NOT (INTEGER-IN-RANGEP (V-TO-INT A)
                                    (LENGTH A))))))
   (IMPLIES
    (Z-SET SET-FLAGS)
    (AND
     (EQUAL (STORE-RESULTP (CC-NE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NOT (EQUAL (V-TO-INT A) 0)))
     (EQUAL (STORE-RESULTP (CC-EQ)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (EQUAL (V-TO-INT A) 0))
     (EQUAL (STORE-RESULTP (CC-NE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NOT (EQUAL (V-TO-INT A) 0)))
     (EQUAL (STORE-RESULTP (CC-EQ)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (IZEROP (V-TO-INT A)))))
   (IMPLIES
    (N-SET SET-FLAGS)
    (AND
     (EQUAL (STORE-RESULTP (CC-PL)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NOT (NEGATIVEP (V-TO-INT A))))
     (EQUAL (STORE-RESULTP (CC-MI)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NEGATIVEP (V-TO-INT A)))
     (EQUAL (STORE-RESULTP (CC-PL)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NOT (NEGATIVEP (V-TO-INT A))))
     (EQUAL (STORE-RESULTP (CC-MI)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NEGATIVEP (V-TO-INT A)))))
   (IMPLIES
    (AND (V-SET SET-FLAGS)
         (N-SET SET-FLAGS))
    (AND
     (EQUAL (STORE-RESULTP (CC-GE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NOT (NEGATIVEP (V-TO-INT A))))
     (EQUAL (STORE-RESULTP (CC-LT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (NEGATIVEP (V-TO-INT A)))
     (EQUAL (STORE-RESULTP (CC-GE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NOT (NEGATIVEP (V-TO-INT A))))
     (EQUAL (STORE-RESULTP (CC-LT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (NEGATIVEP (V-TO-INT A)))))
   (IMPLIES
    (AND (V-SET SET-FLAGS)
         (N-SET SET-FLAGS)
         (Z-SET SET-FLAGS))
    (AND
     (EQUAL (STORE-RESULTP (CC-GT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (ILESSP 0 (V-TO-INT A)))
     (EQUAL (STORE-RESULTP (CC-LE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-MOVE))))
            (ILEQ (V-TO-INT A) 0))
     (EQUAL (STORE-RESULTP (CC-GT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (ILESSP 0 (V-TO-INT A)))
     (EQUAL (STORE-RESULTP (CC-LE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-M15))))
            (ILEQ (V-TO-INT A) 0))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV *1*EXP
          *1*B-TO-NAT ZB IZEROP FIX-INT ILESSP ILEQ V-NEGP->NEGATIVEP-V-TO-INT
          REWRITE-EQUAL-V-TO-INT-0)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-INC-OVERFLOW NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (INTEGER-IN-RANGEP (IPLUS (V-TO-INT A) 1)
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (NOT (INTEGER-IN-RANGEP (IPLUS (V-TO-INT A) 1)
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-INC-ZERO NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (NOT (EQUAL (IPLUS (V-TO-INT A) 1) 0)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (EQUAL (IPLUS (V-TO-INT A) 1) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS IZEROP V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-INC-NEGATIVE NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 1))))
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (NEGATIVEP (IPLUS (V-TO-INT A) 1)))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-INC-GT-0 NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (ILESSP 0 (IPLUS 1 (V-TO-INT A))))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-INC))))
             (ILEQ (IPLUS 1 (V-TO-INT A)) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS IZEROP ILEQ)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADDC-OVERFLOW NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-VC)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (INTEGER-IN-RANGEP (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                                      (IPLUS (V-TO-INT A) (V-TO-INT B)))
                               (LENGTH A)))
     (EQUAL (STORE-RESULTP (CC-VS)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (NOT (INTEGER-IN-RANGEP (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                                           (IPLUS (V-TO-INT A) (V-TO-INT B)))
                                    (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADDC-NEGATIVE NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-LT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (NEGATIVEP (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                              (IPLUS (V-TO-INT A) (V-TO-INT B)))))
     (EQUAL (STORE-RESULTP (CC-GE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (NOT (NEGATIVEP (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                                   (IPLUS (V-TO-INT A)
                                          (V-TO-INT B))))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS INTEGER-IN-RANGEP-IPLUS-CARRY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADDC-GT-0 NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-GT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (ILESSP 0
                    (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                           (IPLUS (V-TO-INT A) (V-TO-INT B)))))
     (EQUAL (STORE-RESULTP (CC-LE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-ADDC))))
            (ILEQ (IPLUS (B-TO-NAT (C-FLAG FLAGS))
                         (IPLUS (V-TO-INT A) (V-TO-INT B)))
                  0))))
 ((USE (INTEGER-IN-RANGEP-IPLUS$COMMUTED (A (V-TO-INT A))
                                         (B (V-TO-INT B))
                                         (L (LENGTH A)))
       (INTEGER-IN-RANGEP-IPLUS-CARRY$COMMUTED (A (V-TO-INT A))
                                               (B (V-TO-INT B))
                                               (L (LENGTH A))))
  (ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT IZEROP ILEQ
          INTEGER-IN-RANGEP INEG)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADD-OVERFLOW NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (INTEGER-IN-RANGEP (IPLUS (V-TO-INT A) (V-TO-INT B))
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (NOT (INTEGER-IN-RANGEP (IPLUS (V-TO-INT A) (V-TO-INT B))
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADD-NEGATIVE NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (NEGATIVEP (IPLUS (V-TO-INT A) (V-TO-INT B))))
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (NOT (NEGATIVEP (IPLUS (V-TO-INT A) (V-TO-INT B)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ADD-GT-0 NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (ILESSP 0
                     (IPLUS (V-TO-INT A) (V-TO-INT B))))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ADD))))
             (ILEQ (IPLUS (V-TO-INT A) (V-TO-INT B))
                   0))))
 ((USE (INTEGER-IN-RANGEP-IPLUS$COMMUTED (A (V-TO-INT A))
                                         (B (V-TO-INT B))
                                         (L (LENGTH A))))
  (ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-INC V-ALU-INT-ADDER
          V-ALU-INT-ADDER-OVERFLOWP V-ALU-INT-ADDER-OUTPUT IZEROP ILEQ
          INTEGER-IN-RANGEP INEG)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA INT-NEG-RANGE-IMPLICATIONS
        (REWRITE)
        (AND (IMPLIES (AND (NEGATIVEP (V-TO-INT A))
                           (NOT (INTEGER-IN-RANGEP (NEGATIVE-GUTS (V-TO-INT A))
                                                   (LENGTH A))))
                      (V-NEGP (INT-TO-V (NEGATIVE-GUTS (V-TO-INT A))
                                        (LENGTH A))))
             (IMPLIES (AND (NOT (NEGATIVEP (V-TO-INT A)))
                           (NOT (INTEGER-IN-RANGEP (MINUS (V-TO-INT A))
                                                   (LENGTH A))))
                      (NOT (V-NEGP (INT-TO-V (MINUS (V-TO-INT A))
                                             (LENGTH A)))))
             (IMPLIES (AND (NOT (NEGATIVEP (V-TO-INT A)))
                           (NOT (INTEGER-IN-RANGEP (MINUS (V-TO-INT A))
                                                   (LENGTH A))))
                      (V-NZEROP (INT-TO-V (MINUS (V-TO-INT A))
                                          (LENGTH A)))))
        ((ENABLE INTEGER-IN-RANGEP EXP V-NEGP-AS-BOUNDS INT-TO-V REMAINDER
                 V-TO-INT)
         (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-NEG-OVERFLOW NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (INTEGER-IN-RANGEP (INEG (V-TO-INT A))
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (NOT (INTEGER-IN-RANGEP (INEG (V-TO-INT A))
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP V-ALU-INT-NEG
          V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-NEG-NEGATIVE NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (NEGATIVEP (INEG (V-TO-INT A))))
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (NOT (NEGATIVEP (INEG (V-TO-INT A)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP
          V-ALU-INT-NEG V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-NEG-ZERO NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (NOT (EQUAL (INEG (V-TO-INT A)) 0)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (EQUAL (INEG (V-TO-INT A)) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP
          V-ALU-INT-NEG V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-NEG-GT-0 NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (ILESSP 0 (INEG (V-TO-INT A))))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-NEG))))
             (ILEQ (INEG (V-TO-INT A)) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP ILEQ
          V-ALU-INT-NEG V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA INT-DEC-RANGEP-LEMMAS
 (REWRITE)
 (AND
  (IMPLIES (NOT (INTEGER-IN-RANGEP (SUB1 (V-TO-INT A))
                                   (LENGTH A)))
           (V-NZEROP (INT-TO-V (SUB1 (V-TO-INT A))
                               (LENGTH A))))
  (IMPLIES
       (AND (NOT (EQUAL (LENGTH A) 1))
            (NOT (INTEGER-IN-RANGEP (MINUS (ADD1 (NEGATIVE-GUTS (V-TO-INT A))))
                                    (LENGTH A))))
       (V-NZEROP (INT-TO-V (MINUS (ADD1 (NEGATIVE-GUTS (V-TO-INT A))))
                           (LENGTH A))))
  (IMPLIES (AND (NOT (NEGATIVEP (IPLUS -1 (V-TO-INT A))))
                (V-NZEROP (INT-TO-V (IPLUS -1 (V-TO-INT A))
                                    (LENGTH A))))
           (NOT (EQUAL (IPLUS -1 (V-TO-INT A)) 0)))
  (IMPLIES (AND (NOT (ZEROP (LENGTH A)))
                (NOT (NEGATIVEP (IPLUS -1 (V-TO-INT A))))
                (NOT (V-NZEROP (INT-TO-V (IPLUS -1 (V-TO-INT A))
                                         (LENGTH A)))))
           (EQUAL (IPLUS -1 (V-TO-INT A)) 0)))
 ((ENABLE INTEGER-IN-RANGEP EXP V-NEGP-AS-BOUNDS INT-TO-V REMAINDER V-TO-INT)
  (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-DEC-OVERFLOW NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT A) 1)
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NOT (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT A) 1)
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP
          V-ALU-INT-DEC V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-DEC-NEGATIVE NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NEGATIVEP (IDIFFERENCE (V-TO-INT A) 1)))
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NOT (NEGATIVEP (IDIFFERENCE (V-TO-INT A) 1))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP
          V-ALU-INT-DEC V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT INTEGER-IN-RANGEP-IPLUS)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-DEC-ZERO NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (NOT (EQUAL (IDIFFERENCE (V-TO-INT A) 1)
                         0)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (EQUAL (IDIFFERENCE (V-TO-INT A) 1)
                    0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP IPLUS
          V-ALU-INT-DEC V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-DEC-GT-0 NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (ILESSP 0
                     (IDIFFERENCE (V-TO-INT A) 1)))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-DEC))))
             (ILEQ (IDIFFERENCE (V-TO-INT A) 1)
                   0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS INEG IDIFFERENCE IZEROP INTEGERP ILEQ
          V-ALU-INT-DEC V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OVERFLOWP
          V-ALU-INT-SUBTRACTER-OUTPUT INTEGER-IN-RANGEP-IPLUS)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUBB-OVERFLOW NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
   (EQUAL (STORE-RESULTP (CC-VC)
                         (UPDATE-FLAGS FLAGS SET-FLAGS
                                       (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
          (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT B)
                                          (IPLUS (V-TO-INT A)
                                                 (B-TO-NAT (C-FLAG FLAGS))))
                             (LENGTH A)))
   (EQUAL
        (STORE-RESULTP (CC-VS)
                       (UPDATE-FLAGS FLAGS SET-FLAGS
                                     (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
        (NOT (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT B)
                                             (IPLUS (V-TO-INT A)
                                                    (B-TO-NAT (C-FLAG FLAGS))))
                                (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUBB-NEGATIVE NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
    (EQUAL (STORE-RESULTP (CC-LT)
                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                        (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
           (NEGATIVEP (IDIFFERENCE (V-TO-INT B)
                                   (IPLUS (V-TO-INT A)
                                          (B-TO-NAT (C-FLAG FLAGS))))))
    (EQUAL (STORE-RESULTP (CC-GE)
                          (UPDATE-FLAGS FLAGS SET-FLAGS
                                        (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
           (NOT (NEGATIVEP (IDIFFERENCE (V-TO-INT B)
                                        (IPLUS (V-TO-INT A)
                                               (B-TO-NAT (C-FLAG FLAGS)))))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS IDIFFERENCE V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP V-ALU-INT-SUBTRACTER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS-INEG INTEGER-IN-RANGEP-IPLUS-INEG-CARRY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUBB-GT-0 NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
     (EQUAL (STORE-RESULTP (CC-GT)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (ILESSP 0
                    (IDIFFERENCE (V-TO-INT B)
                                 (IPLUS (V-TO-INT A)
                                        (B-TO-NAT (C-FLAG FLAGS))))))
     (EQUAL (STORE-RESULTP (CC-LE)
                           (UPDATE-FLAGS FLAGS SET-FLAGS
                                         (V-ALU (C-FLAG FLAGS) A B (OP-SUBB))))
            (ILEQ (IDIFFERENCE (V-TO-INT B)
                               (IPLUS (V-TO-INT A)
                                      (B-TO-NAT (C-FLAG FLAGS))))
                  0))))
 ((USE
     (INTEGER-IN-RANGEP-IPLUS-INEG-CARRY$COMMUTED (A (V-TO-INT A))
                                                  (B (V-TO-INT B))
                                                  (C (B-TO-NAT (C-FLAG FLAGS)))
                                                  (L (LENGTH A)))
     (INTEGER-IN-RANGEP-IPLUS-INEG$COMMUTED (A (V-TO-INT A))
                                            (B (V-TO-INT B))
                                            (L (LENGTH A))))
  (ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP V-ALU-INT-SUBTRACTER-OUTPUT IZEROP
          ILEQ IDIFFERENCE INTEGER-IN-RANGEP INEG)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUB-OVERFLOW NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT B)
                                             (V-TO-INT A))
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NOT (INTEGER-IN-RANGEP (IDIFFERENCE (V-TO-INT B)
                                                  (V-TO-INT A))
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUB-NEGATIVE NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NEGATIVEP (IDIFFERENCE (V-TO-INT B)
                                     (V-TO-INT A))))
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (NOT (NEGATIVEP (IDIFFERENCE (V-TO-INT B)
                                          (V-TO-INT A)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS IDIFFERENCE V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP V-ALU-INT-SUBTRACTER-OUTPUT
          INTEGER-IN-RANGEP-IPLUS-INEG)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-SUB-GT-0 NIL
 (IMPLIES
  (AND (BV2P A B)
       (NOT (EQUAL (LENGTH A) 0))
       (NOT (EQUAL (LENGTH A) 1))
       (N-SET SET-FLAGS)
       (V-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (ILESSP 0
                     (IDIFFERENCE (V-TO-INT B)
                                  (V-TO-INT A))))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-SUB))))
             (ILEQ (IDIFFERENCE (V-TO-INT B)
                                (V-TO-INT A))
                   0))))
 ((USE (INTEGER-IN-RANGEP-IPLUS-INEG$COMMUTED (A (V-TO-INT A))
                                              (B (V-TO-INT B))
                                              (L (LENGTH A))))
  (ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-SUBTRACTER
          V-ALU-INT-SUBTRACTER-OVERFLOWP V-ALU-INT-SUBTRACTER-OUTPUT IZEROP
          ILEQ IDIFFERENCE INTEGER-IN-RANGEP INEG)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA EQUAL-IDIV-2-0
             (REWRITE)
             (EQUAL (EQUAL (IDIV I 2) 0)
                    (OR (IZEROP I) (EQUAL I 1)))
             ((ENABLE IDIV FIX-INT IZEROP INTEGERP)))

(PROVE-LEMMA INTEGER-IN-RANGEP-IDIV
             (REWRITE)
             (IMPLIES (INTEGER-IN-RANGEP I L)
                      (INTEGER-IN-RANGEP (IDIV I 2) L))
             ((ENABLE INTEGER-IN-RANGEP EXP V-NEGP-AS-BOUNDS INT-TO-V
                      REMAINDER V-TO-INT QUOTIENT EXP QUOTIENT-LESSP
                      QUOTIENT-STUFF NOT-LESSP-QUOTIENT)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ASR-ZERO NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-NE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NOT (EQUAL (IDIV (V-TO-INT A) 2) 0)))
      (EQUAL (STORE-RESULTP (CC-EQ)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (EQUAL (IDIV (V-TO-INT A) 2) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU INTEGERP-IDIV C V N CV BV
          B-TO-NAT ZB FIX-INT ILESSP INTEGERP-IPLUS IZEROP V-ALU-INT-ASR
          V-ALU-INT-ASR-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA EQUAL-SUB1-PLUS-X-X
             (REWRITE)
             (EQUAL (EQUAL (SUB1 (PLUS X X)) 0)
                    (ZEROP X)))

(PROVE-LEMMA REMAINDER-DIFFERENCE-PLUS-X-X-PLUS-Y-Y
             (REWRITE)
             (EQUAL (REMAINDER (DIFFERENCE (PLUS X X) (PLUS Y Y))
                               2)
                    0)
             ((ENABLE REMAINDER DIFFERENCE PLUS)
              (INDUCT (DIFFERENCE X Y))))

(PROVE-LEMMA REMAINDER-DIFFERENCE-PLUS-X-X-ADD1-PLUS-Y-Y
             (REWRITE)
             (IMPLIES (LESSP (ADD1 (PLUS Y Y)) (PLUS X X))
                      (EQUAL (REMAINDER (DIFFERENCE (PLUS X X)
                                                    (ADD1 (PLUS Y Y)))
                                        2)
                             1))
             ((ENABLE REMAINDER DIFFERENCE PLUS)
              (INDUCT (DIFFERENCE X Y))))

(PROVE-LEMMA QUOTIENT-DIFFERENCE-PLUS-X-X-PLUS-Y-Y-2
             (REWRITE)
             (EQUAL (QUOTIENT (DIFFERENCE (PLUS X X) (PLUS Y Y))
                              2)
                    (DIFFERENCE X Y))
             ((ENABLE QUOTIENT DIFFERENCE PLUS)
              (INDUCT (DIFFERENCE X Y))))

(PROVE-LEMMA QUOTIENT-DIFFERENCE-PLUS-X-X-ADD1-PLUS-Y-Y-2
             (REWRITE)
             (EQUAL (QUOTIENT (DIFFERENCE (PLUS X X)
                                          (ADD1 (PLUS Y Y)))
                              2)
                    (SUB1 (DIFFERENCE X Y)))
             ((ENABLE QUOTIENT DIFFERENCE PLUS)
              (INDUCT (DIFFERENCE X Y))))

(PROVE-LEMMA QUOTIENT-ADD1-PLUS-X-X-2
             (REWRITE)
             (EQUAL (QUOTIENT (ADD1 (PLUS X X)) 2)
                    (FIX X))
             ((ENABLE QUOTIENT PLUS)))

(PROVE-LEMMA IMOD-V-TO-INT-2
             (REWRITE)
             (IMPLIES (LISTP A)
                      (EQUAL (IMOD (V-TO-INT A) 2)
                             (B-TO-NAT (CAR A))))
             ((ENABLE IMOD V-TO-INT V-TO-NAT B-TO-NAT EXP QUOTIENT-PLUS-X-X-2)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)
              (EXPAND (V-TO-NAT A))))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ASR-CARRY NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (C-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-CC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (EQUAL (IMOD (V-TO-INT A) 2) 0))
      (EQUAL (STORE-RESULTP (CC-CS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NOT (EQUAL (IMOD (V-TO-INT A) 2) 0)))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS IZEROP V-ALU-INT-ASR
          V-ALU-INT-ASR-OUTPUT)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ASR-NEGATIVE NIL
 (IMPLIES
  (AND (BVP A) (NOT (ZEROP (LENGTH A))))
  (AND
   (IMPLIES
    (N-SET SET-FLAGS)
    (AND
      (EQUAL (STORE-RESULTP (CC-PL)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NOT (NEGATIVEP (IDIV (V-TO-INT A) 2))))
      (EQUAL (STORE-RESULTP (CC-MI)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NEGATIVEP (IDIV (V-TO-INT A) 2)))))
   (IMPLIES
    (AND (N-SET SET-FLAGS)
         (V-SET SET-FLAGS))
    (AND
      (EQUAL (STORE-RESULTP (CC-GE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NOT (NEGATIVEP (IDIV (V-TO-INT A) 2))))
      (EQUAL (STORE-RESULTP (CC-LT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NEGATIVEP (IDIV (V-TO-INT A) 2)))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-ASR V-ALU-INT-ASR-OUTPUT
          INTEGERP-IDIV INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ASR-GT-0 NIL
 (IMPLIES
  (AND (BVP A)
       (NOT (ZEROP (LENGTH A)))
       (V-SET SET-FLAGS)
       (N-SET SET-FLAGS)
       (Z-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-GT)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (ILESSP 0 (IDIV (V-TO-INT A) 2)))
      (EQUAL (STORE-RESULTP (CC-LE)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (ILEQ (IDIV (V-TO-INT A) 2) 0))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-ASR V-ALU-INT-ASR-OUTPUT
          INTEGERP-IDIV ILESSP ILEQ IZEROP INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(PROVE-LEMMA FLAGS-INTERPRETATION-INT-ASR-OVERFLOW NIL
 (IMPLIES
  (AND (BVP A) (V-SET SET-FLAGS))
  (AND
      (EQUAL (STORE-RESULTP (CC-VC)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (INTEGER-IN-RANGEP (IDIV (V-TO-INT A) 2)
                                (LENGTH A)))
      (EQUAL (STORE-RESULTP (CC-VS)
                            (UPDATE-FLAGS FLAGS SET-FLAGS
                                          (V-ALU (C-FLAG FLAGS) A B (OP-ASR))))
             (NOT (INTEGER-IN-RANGEP (IDIV (V-TO-INT A) 2)
                                     (LENGTH A))))))
 ((ENABLE SET-FLAGS UPDATE-FLAGS STORE-RESULTP V-ALU C V N CV BV B-TO-NAT ZB
          FIX-INT ILESSP INTEGERP-IPLUS V-ALU-INT-ASR V-ALU-INT-ASR-OUTPUT
          INTEGERP-IDIV ILESSP ILEQ IZEROP INTEGER-IN-RANGEP-THE-OBVIOUS-WAY)
  (ENABLE-THEORY SET-FLAGS-THEORY FLAGS-THEORY)))

(DEFN V-NEG
      (A)
      (V-SUBTRACTER-OUTPUT F A
                           (NAT-TO-V 0 (LENGTH A))))

(PROVE-LEMMA BV-CVZBV
             (REWRITE)
             (EQUAL (BV (CVZBV C V BV)) BV)
             ((ENABLE BV CVZBV)))

(PROVE-LEMMA C-CVZBV
             (REWRITE)
             (EQUAL (C (CVZBV C V BV)) C)
             ((ENABLE C CVZBV)))

(PROVE-LEMMA V-CVZBV
             (REWRITE)
             (EQUAL (V (CVZBV C V BV)) V)
             ((ENABLE V CVZBV)))

(PROVE-LEMMA ZB-CVZBV
             (REWRITE)
             (EQUAL (ZB (CVZBV C V BV))
                    (V-ZEROP BV))
             ((ENABLE ZB CVZBV)))

(PROVE-LEMMA BV-V-ALU NIL
             (EQUAL (BV (V-ALU C A B OP))
                    (COND ((EQUAL OP (LIST F F F F)) (V-BUF A))
                          ((EQUAL OP (LIST T F F F)) (V-INC A))
                          ((EQUAL OP (LIST F T F F))
                           (V-ADDER-OUTPUT C A B))
                          ((EQUAL OP (LIST T T F F))
                           (V-ADDER-OUTPUT F A B))
                          ((EQUAL OP (LIST F F T F)) (V-NEG A))
                          ((EQUAL OP (LIST T F T F)) (V-DEC A))
                          ((EQUAL OP (LIST F T T F))
                           (V-SUBTRACTER-OUTPUT C A B))
                          ((EQUAL OP (LIST T T T F))
                           (V-SUBTRACTER-OUTPUT F A B))
                          ((EQUAL OP (LIST F F F T))
                           (V-ROR A C))
                          ((EQUAL OP (LIST T F F T)) (V-ASR A))
                          ((EQUAL OP (LIST F T F T)) (V-LSR A))
                          ((EQUAL OP (LIST T T F T))
                           (V-XOR A B))
                          ((EQUAL OP (LIST F F T T)) (V-OR A B))
                          ((EQUAL OP (LIST T F T T))
                           (V-AND A B))
                          ((EQUAL OP (LIST F T T T)) (V-NOT A))
                          (T (V-BUF A))))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO)
              (ENABLE V-ALU BV-CVZBV CVZBV-INC CVZBV-V-ADDER CVZBV-NEG
                      CVZBV-DEC CVZBV-V-SUBTRACTER CVZBV-V-ROR CVZBV-V-ASR
                      CVZBV-V-LSR CVZBV-V-NOT V-INC V-DEC V-NEG)))

(PROVE-LEMMA C-V-ALU NIL
             (AND (IMPLIES (OR (EQUAL OP (OP-MOVE))
                               (EQUAL OP (OP-XOR))
                               (EQUAL OP (OP-OR))
                               (EQUAL OP (OP-AND))
                               (EQUAL OP (OP-NOT))
                               (EQUAL OP (OP-M15)))
                           (EQUAL (C (V-ALU C A B OP)) F))
                  (IMPLIES (AND (LISTP A)
                                (OR (EQUAL OP (OP-ROR))
                                    (EQUAL OP (OP-ASR))
                                    (EQUAL OP (OP-LSR))))
                           (EQUAL (C (V-ALU C A B OP))
                                  (NTH 0 A))))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO OPCODE-THEORY)
              (ENABLE V-ALU C-CVZBV CVZBV-INC CVZBV-V-ADDER CVZBV-NEG
                      CVZBV-DEC CVZBV-V-SUBTRACTER CVZBV-V-ROR CVZBV-V-ASR
                      CVZBV-V-LSR CVZBV-V-NOT V-INC V-DEC V-NEG)))

(PROVE-LEMMA V-V-ALU NIL
             (IMPLIES (OR (EQUAL OP (OP-MOVE))
                          (EQUAL OP (OP-ROR))
                          (EQUAL OP (OP-ASR))
                          (EQUAL OP (OP-ASR))
                          (EQUAL OP (OP-LSR))
                          (EQUAL OP (OP-XOR))
                          (EQUAL OP (OP-OR))
                          (EQUAL OP (OP-AND))
                          (EQUAL OP (OP-NOT))
                          (EQUAL OP (OP-M15)))
                      (EQUAL (V (V-ALU C A B OP)) F))
             ((DISABLE-THEORY T)
              (ENABLE-THEORY GROUND-ZERO OPCODE-THEORY)
              (ENABLE V-ALU V-CVZBV CVZBV-INC CVZBV-V-ADDER CVZBV-NEG
                      CVZBV-DEC CVZBV-V-SUBTRACTER CVZBV-V-ROR CVZBV-V-ASR
                      CVZBV-V-LSR CVZBV-V-NOT V-INC V-DEC V-NEG)))

(PROVE-LEMMA V-ALU-CORRECT-NAT-REWRITE
             (REWRITE)
             (IMPLIES (BV2P A B)
                      (EQUAL (V-ALU C A B OP)
                             (V-ALU-NAT C A B OP)))
             ((DISABLE V-ALU V-ALU-NAT)
              (USE (V-ALU-CORRECT-NAT))))

(TOGGLE V-ALU-CORRECT-NAT-REWRITE-OFF V-ALU-CORRECT-NAT-REWRITE T)

(PROVE-LEMMA V-ALU-CORRECT-INT-REWRITE
             (REWRITE)
             (IMPLIES (AND (BV2P A B)
                           (NOT (EQUAL (LENGTH A) 0)))
                      (EQUAL (V-ALU C A B OP)
                             (V-ALU-INT C A B OP)))
             ((DISABLE V-ALU V-ALU-INT)
              (USE (V-ALU-CORRECT-INT))))

(TOGGLE V-ALU-CORRECT-INT-REWRITE-OFF V-ALU-CORRECT-INT-REWRITE T)

(PROVE-LEMMA LESSP-QUOTIENT-TEST
             (REWRITE)
             (IMPLIES (LESSP N M)
                      (EQUAL (LESSP (QUOTIENT N K) M) T))
             ((ENABLE QUOTIENT LESSP)))

(TOGGLE LESSP-QUOTIENT-TEST-OFF LESSP-QUOTIENT-TEST T)

(PROVE-LEMMA NAT-TO-V-AS-REMAINDER
             (REWRITE)
             (EQUAL (NAT-TO-V (REMAINDER N (EXP 2 L)) L)
                    (NAT-TO-V N L))
             ((ENABLE NAT-TO-V QUOTIENT-REMAINDER REMAINDER-EXP QUOTIENT-EXP
                      REMAINDER-REMAINDER)
              (EXPAND (NAT-TO-V (REMAINDER N (EXP 2 L)) L))
              (INDUCT (NAT-TO-V N L))))

(PROVE-LEMMA NAT-TO-V-OF-V-TO-NAT*
             (REWRITE)
             (IMPLIES (AND (BVP V) (EQUAL L (LENGTH V)))
                      (EQUAL (NAT-TO-V (V-TO-NAT V) L) V)))

(TOGGLE NAT-TO-V-OF-V-TO-NAT*-OFF NAT-TO-V-OF-V-TO-NAT* T)

(PROVE-LEMMA BV-V-ALU-AS-NATURAL NIL
 (IMPLIES (AND (BV2P A B) (EQUAL (LENGTH A) 32))
          (EQUAL (BV (V-ALU C A B OP))
                 (COND ((EQUAL OP (OP-INC))
                        (NAT-TO-V (PLUS 1 (V-TO-NAT A)) 32))
                       ((EQUAL OP (OP-ADDC))
                        (NAT-TO-V (PLUS (B-TO-NAT C)
                                        (V-TO-NAT A)
                                        (V-TO-NAT B))
                                  32))
                       ((EQUAL OP (OP-ADD))
                        (NAT-TO-V (PLUS (V-TO-NAT A) (V-TO-NAT B))
                                  32))
                       ((EQUAL OP (OP-DEC))
                        (NAT-TO-V (DIFFERENCE (PLUS (V-TO-NAT A) (EXP 2 32))
                                              1)
                                  32))
                       ((EQUAL OP (OP-SUBB))
                        (NAT-TO-V (DIFFERENCE (PLUS (V-TO-NAT B) (EXP 2 32))
                                              (PLUS (V-TO-NAT A) (B-TO-NAT C)))
                                  32))
                       ((EQUAL OP (OP-SUB))
                        (NAT-TO-V (DIFFERENCE (PLUS (V-TO-NAT B) (EXP 2 32))
                                              (V-TO-NAT A))
                                  32))
                       ((EQUAL OP (OP-LSR))
                        (NAT-TO-V (QUOTIENT (V-TO-NAT A) 2)
                                  32))
                       (T (BV (V-ALU C A B OP))))))
 ((DISABLE CVZBV BV)
  (ENABLE BV-CVZBV NAT-TO-V-OF-V-TO-NAT* REMAINDER-REMAINDER REMAINDER-NOOP
          LESSP-QUOTIENT-TEST V-TO-NAT-OF-NAT-TO-V *1*B-TO-NAT
          V-ALU-CORRECT-NAT-REWRITE V-ALU-NAT V-ALU-NAT-INT-BUF V-ALU-NAT-INC
          V-ALU-NAT-DEC V-ALU-NAT-ADDER V-ALU-NAT-ADDER-OUTPUT
          V-ALU-NAT-SUBTRACTER V-ALU-NAT-SUBTRACTER-OUTPUT V-ALU-NAT-LSR
          V-ALU-NAT-LSR-OUTPUT)))

(PROVE-LEMMA FIX-INT-INT-TO-V
             (REWRITE)
             (EQUAL (FIX-INT (V-TO-INT V))
                    (V-TO-INT V))
             ((ENABLE FIX-INT V-TO-INT INTEGERP IDIFFERENCE IPLUS)))

(PROVE-LEMMA INT-TO-V-OF-V-TO-INT
             (REWRITE)
             (IMPLIES (AND (EQUAL L (LENGTH V)) (BVP V))
                      (EQUAL (INT-TO-V (V-TO-INT V) L) V))
             ((ENABLE INT-TO-V V-TO-INT)
              (ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA INEG-AS-IDIFFERENCE
             (REWRITE)
             (EQUAL (IDIFFERENCE 0 I) (INEG I))
             ((ENABLE-THEORY ALL-INTEGER-DEFNS)))

(PROVE-LEMMA BV-V-ALU-AS-INTEGER NIL
 (IMPLIES
        (AND (BV2P A B) (EQUAL (LENGTH A) 32))
        (EQUAL (BV (V-ALU C A B OP))
               (COND ((EQUAL OP (OP-INC))
                      (INT-TO-V (IPLUS 1 (V-TO-INT A)) 32))
                     ((EQUAL OP (OP-ADDC))
                      (INT-TO-V (IPLUS (B-TO-NAT C)
                                       (IPLUS (V-TO-INT A) (V-TO-INT B)))
                                32))
                     ((EQUAL OP (OP-ADD))
                      (INT-TO-V (IPLUS (V-TO-INT A) (V-TO-INT B))
                                32))
                     ((EQUAL OP (OP-NEG))
                      (INT-TO-V (INEG (V-TO-INT A)) 32))
                     ((EQUAL OP (OP-DEC))
                      (INT-TO-V (IDIFFERENCE (V-TO-INT A) 1)
                                32))
                     ((EQUAL OP (OP-SUBB))
                      (INT-TO-V (IDIFFERENCE (V-TO-INT B)
                                             (IPLUS (V-TO-INT A) (B-TO-NAT C)))
                                32))
                     ((EQUAL OP (OP-SUB))
                      (INT-TO-V (IDIFFERENCE (V-TO-INT B)
                                             (V-TO-INT A))
                                32))
                     ((EQUAL OP (OP-ASR))
                      (INT-TO-V (IDIV (V-TO-INT A) 2) 32))
                     (T (BV (V-ALU C A B OP))))))
 ((DISABLE CVZBV BV)
  (ENABLE BV-CVZBV REMAINDER-REMAINDER REMAINDER-NOOP LESSP-QUOTIENT-TEST
          *1*B-TO-NAT *1*V-TO-INT *1*FIX-INT FIX-INT-IPLUS FIX-INT-INEG
          FIX-INT-IDIFFERENCE FIX-INT-INT-TO-V V-ALU-CORRECT-INT-REWRITE
          V-ALU-INT V-ALU-INT-NEG V-ALU-NAT-INT-BUF V-ALU-INT-INC
          V-ALU-INT-DEC V-ALU-INT-ADDER V-ALU-INT-ADDER-OUTPUT
          V-ALU-INT-SUBTRACTER V-ALU-INT-SUBTRACTER-OUTPUT V-ALU-INT-ASR
          V-ALU-INT-ASR-OUTPUT)))


(MAKE-LIB "fm9001-replay" T) 