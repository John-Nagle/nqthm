#|
 Copyright (C) 1994 by Computational Logic, Inc.  All Rights Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Computational Logic, Inc.  All
 Rights Reserved."

 NO WARRANTY

 Computational Logic, Inc. PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT
 IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
 PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU
 ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 IN NO EVENT WILL Computational Logic, Inc. BE LIABLE TO YOU FOR ANY DAMAGES,
 ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL
 DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT
 NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
 SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF
 SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
|#

; FM9001 Piton 

; J Strother Moore
; October, 1991

; History 

; This file contains the complete script of the events establishing
; that Piton is correctly implemented on top of the FM9001.  The
; original correctness proof for Piton was done for the FM8502 and is
; reported accurately and completely in CLI Tech Report 22.  That
; report is still basically accurate.  FM9001 differs from FM8502
; primarily in that instructions are in a slightly different format
; and the instruction set is slightly different.  However, when Hunt
; and Brock developed FM9001 from FM8502 they explicitly considered
; Piton's use of the FM8502 instruction set.  For each FM8502
; instruction-instance used by the Piton compiler, they included an
; FM9001 instruction that could provide the same functionality.  Thus,
; to port the Piton implementation from FM8502 to FM9001 it was only
; necessary to change the code linkers, essentially from
; LINK-INSTR-WORD on down.

; However, porting the proof from FM8502 to FM9001 was harder than
; suggested by the instruction set changes alone.  FM9001 uses a
; different formal representation of memory -- a binary tree instead
; of a linear list -- and uses a different formalization of bit
; vectors -- lists of Booleans instead of the BITV shell.  But most
; dramatically, the FM8502 proof used an experimental version of NQTHM
; that was supposed to become the released version.  That experimental
; NQTHM, called XNQTHM, provided "books".  Indeed, it was the FM8502
; Piton effort that caused books to be invented in the first place.
; With books, the XNQTHM user could develop a large body of lemmas in
; one session and then, in the course of later sessions, extract
; selected results to build upon.  Thus, books were incremental as
; opposed to the monolithic "core dump" view of state saving provided
; by NQTHM's lib files.  The FM8502 Piton proofs used four different
; (major) books: one to handle the p->r diagram, one for r->i, one for
; i->m (where we also handled m=FM8502), and then one in which the
; main correctness result was derived by extracting the key theorems
; from the three preceding books.  In addition, the original
; development devoted a book each to the definitions of the various
; machines (p, r, i, and m) and to the implementation of the compiler
; and link-assembler so they could be loaded and run in isolation from
; the correctness proof.  (This was in fact necessary since, for
; example, both the p->r book and the r->i book both needed access to
; the definition of the r machine and the implementation.)  Finally, I
; redid the FM8502 correctness proof in book form so that Piton could
; build on the definition of FM8502 without the clutter of its
; correctness proof or gate-level implementation.

; In the summer of 1989, Boyer and I began the process of "blessing"
; XNQTHM in preparation for its release as the new NQTHM.  However,
; after several months of trying to combine macros and books, we
; decided to start afresh.  We thereby embarked on the NTHM Project,
; where books are central to the whole design.  That is another story.
; However, one impact of the decision not to release XNQTHM was the
; need to reproduce the Piton proofs in a publicly available NQTHM.  I
; decided to wait until FM9001 was done and then to do the new Piton
; in NQTHM (rather than XNQTHM).

; This has had a major detrimental effect on the readability of the
; proof script.  Books allowed a clean hierarchical decomposition of
; the various layers of the problem.  This was lost when I
; (essentially) just concatenated the event lists from all of the
; Piton books into one massive script.  Of course, I had to start this
; proof effort in the library file created for the FM9001 correctness
; proof, the only NQTHM file containing "the" correct definition of
; FM9001.  To achieve the effect of isolation provided by books, each
; major section is separated from the others by thousands of DISABLE
; events which effectively erase the rule base developed thus far.  In
; addition, some names had to be changed because of clashes which were
; allowed under the book mechanism.  In short, the "new" proof of
; Piton is, in many ways, a step backward from the original one.  This
; was particularly frustrating for me since NTHM's books (which are
; implemented and seem to work) provide even greater functionality
; than XNQTHM's books.  The ideal thing to have done would have been
; for everybody else to take ten years' vacation while Boyer and I
; perfected and released NTHM, and then to develop the new FM9001 stack
; in NTHM.

; I ported the first of Piton's 3 commutative diagrams to the FM9001
; in May, 1991.  At that time, the FM9001 correctness proof was not
; completed.  I "borrowed" a lib file from Bishop that contained the
; majority of the proof and did the bottom-most diagram in that lib.
; Actually, I introduced a fourth layer to Piton: the link from M to
; FM9001 (the corresponding level in the FM8502 proof was an equality)
; has become a full-fledged commutative diagram that handles the
; memory.  See M->FM9001, which is now the fourth application in LOAD,
; and ONE-WAY-CORRESPONDENCE-M-FM9001.  In one week in May, I
; successfully proved that the M machine was implemented on FM9001.  I
; then waited until my decks were clear (October, 1991) to port the
; rest of the proof.  It has taken roughly 2 weeks to do the rest.

; A major new proof burden was introduced by the new memory representation.
; See the events surrounding PLAUSIBLE-DATA-LINK-TABLEP.  The basic problem
; was that in order to display the FM9001 memory to recover the M memory (i.e.,
; to get the "up" arrow in the bottom-most diagram), it was necessary to know
; that no address exceeded the size the of FM9001 memory.  This in turn
; required showing that the size of the final memory was the same as that
; for the initial memory.  This in turn forced us to prove the analogous
; fact all the way up, i.e., for M, I, R, and P.  At the higher levels, of
; course, what we proved was that the machines preserved the "signatures"
; of the program and data segments.  While this work could have been
; rather naturally done at the time we were dealing with the respective
; machines in their component diagrams, we did not recognize the need for the
; theorems until we had redone all of the old diagrams and were trying to
; combine everything at the very end.  Thus, you will see at the end of this
; script some hideous lemmas about the r and p machines where we tediously
; enable things that were "naturally" enabled earlier in the script.

; The book structure of the original proof can be seen by searching
; for comments of the form "; Book:".

; November, 1991: After the first successful port to FM9001 a new
; patch was installed: The loader was changed to allow us to specify
; the location at which the Piton data segment was laid down in
; memory.  This was done so that part of the data segment could be
; memory mapped to allow us to do some output from Piton.  This was
; achieved by swapping the positions of the prog segment and the data
; segment (in the original Piton work, the prog segment was laid out
; first, followed by the data segment and then the system data).  Now
; the data segment is laid out first, then the program segment, and
; then the system data segment.  Furthermore, all of this is laid out
; starting at a given location, generally named the LOAD-ADDR, and the
; contents of memory below that point is specified by an oracle,
; generally named BOOT-LST.

; This change has had drastic effects rippling through the Piton
; proof.

; This takes roughly 8 hours on a Sparc 2 in AKCL and generates 30Mb
; of .proof output and a .lib file of about 20Mb.

(note-lib "fm9001-replay" t)

(set-status close-data-base-1 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

; Book:  Implementation.events

; We first define the implementation of Piton.  It is odd that we
; start there rather than with the semantics of the P machine.
; Logically and historically we started with the semantics.  But we
; are building the proof from the bottom up and in the beginning all
; we have is FM9001 and the implementation and we will build the m
; machine to explain the link part of the implementation, the i
; machine to build the code generator part, etc.

(DEFN INCR (C X)
  (IF (NLISTP X)
      NIL
      (CONS (XOR C (CAR X))
            (INCR (AND C (CAR X)) (CDR X)))))

(DEFN BITN (X N)
  (COND ((ZEROP N) F)
        ((EQUAL N 1) (CAR X))
        (T (BITN (CDR X) (SUB1 N)))))

(ADD-SHELL P-STATE NIL P-STATEP
           ((P-PC (NONE-OF) ZERO)
            (P-CTRL-STK (NONE-OF) ZERO)
            (P-TEMP-STK (NONE-OF) ZERO)
            (P-PROG-SEGMENT (NONE-OF) ZERO)
            (P-DATA-SEGMENT (NONE-OF) ZERO)
            (P-MAX-CTRL-STK-SIZE (NONE-OF) ZERO)
            (P-MAX-TEMP-STK-SIZE (NONE-OF) ZERO)
            (P-WORD-SIZE (NONE-OF) ZERO)
            (P-PSW (NONE-OF) ZERO)))

(DEFN ERRORP
      (PSW)
      (AND (NOT (EQUAL PSW 'RUN))
           (NOT (EQUAL PSW 'HALT))))

(DEFN DEFINITION
      (NAME ALIST)
      (ASSOC NAME ALIST))

(DEFN STRIP-CDRS
      (ALIST)
      (IF (NLISTP ALIST)
          NIL
          (CONS (CDAR ALIST)
                (STRIP-CDRS (CDR ALIST)))))

(DEFN NAME (D) (CAR D))

(DEFN FORMAL-VARS (D) (CADR D))

(DEFN TEMP-VAR-DCLS (D) (CADDR D))

(DEFN PROGRAM-BODY (D) (CDDDR D))

(DEFN LOCAL-VARS
      (D)
      (APPEND (FORMAL-VARS D)
              (STRIP-CARS (TEMP-VAR-DCLS D))))

(DEFN ADP-NAME (ADP) (CAR ADP))

(DEFN ADP-OFFSET (ADP) (CDR ADP))

(DEFN SUB-ADP
      (ADP N)
      (CONS (ADP-NAME ADP)
            (DIFFERENCE (ADP-OFFSET ADP) N)))

(DEFN GET
      (N LST)
      (IF (ZEROP N)
          (CAR LST)
          (GET (SUB1 N) (CDR LST))))

(DEFN TAG (TYPE OBJ) (LIST TYPE OBJ))

(DEFN TYPE (CONST) (CAR CONST))

(DEFN UNTAG (CONST) (CADR CONST))

(DEFN AREA-NAME
      (X)
      (ADP-NAME (UNTAG X)))

(DEFN SUB-ADDR
      (ADDR N)
      (TAG (TYPE ADDR)
           (SUB-ADP (UNTAG ADDR) N)))

(DEFN TOP (STK) (CAR STK))

(DEFN POP (STK) (CDR STK))

(DEFN DL
      (LAB COMMENT INS)
      (LIST 'DL LAB COMMENT INS))

(DEFN LABELLEDP
      (X)
      (EQUAL (CAR X) 'DL))

(DEFN UNLABEL
      (X)
      (IF (LABELLEDP X) (CADDDR X) X))

(DEFN FIND-LABEL
      (X LST)
      (COND ((NLISTP LST) 0)
            ((AND (LABELLEDP (CAR LST))
                  (EQUAL X (CADAR LST)))
             0)
            (T (ADD1 (FIND-LABEL X (CDR LST))))))

(DEFN PC
      (LAB PROGRAM)
      (TAG 'PC
           (CONS (NAME PROGRAM)
                 (FIND-LABEL LAB
                             (PROGRAM-BODY PROGRAM)))))

(DEFN BINDINGS (FRAME) (CAR FRAME))

(DEFN RET-PC (FRAME) (CADR FRAME))

(DEFN P-FRAME-SIZE
      (FRAME)
      (PLUS 2 (LENGTH (BINDINGS FRAME))))

(DEFN P-CTRL-STK-SIZE
      (CTRL-STK)
      (IF (NLISTP CTRL-STK)
          0
          (PLUS (P-FRAME-SIZE (TOP CTRL-STK))
                (P-CTRL-STK-SIZE (CDR CTRL-STK)))))

(DEFN ICODE-CALL
      (INS PCN PROGRAM)
      (LIST '(CPUSH_*)
            (TAG 'PC
                 (CONS (NAME PROGRAM) (ADD1 PCN)))
            '(JUMP_*)
            (TAG 'PC
                 (CONS (CADR INS) '(PRELUDE)))))

(DEFN GENERATE-PRELUDE1
      (TEMP-VAR-DCLS)
      (IF (NLISTP TEMP-VAR-DCLS)
          NIL
          (CONS '(CPUSH_*)
                (CONS (CADAR TEMP-VAR-DCLS)
                      (GENERATE-PRELUDE1 (CDR TEMP-VAR-DCLS))))))

(DEFN GENERATE-PRELUDE2
      (FORMAL-VARS)
      (IF (NLISTP FORMAL-VARS)
          NIL
          (CONS '(CPUSH_<TSP>+)
                (GENERATE-PRELUDE2 (CDR FORMAL-VARS)))))

(DEFN GENERATE-PRELUDE
      (PROGRAM)
      (APPEND (CONS (DL (CONS (NAME PROGRAM) '(PRELUDE))
                        '(PRELUDE)
                        '(CPUSH_CFP))
                    '((MOVE_CFP_CSP)))
              (APPEND (GENERATE-PRELUDE1 (REVERSE (TEMP-VAR-DCLS PROGRAM)))
                      (GENERATE-PRELUDE2 (FORMAL-VARS PROGRAM)))))

(DEFN FIND-POSITION-OF-VAR
      (VAR LST)
      (COND ((NLISTP LST) 0)
            ((EQUAL VAR (CAR LST)) 0)
            (T (ADD1 (FIND-POSITION-OF-VAR VAR
                                           (CDR LST))))))

(DEFN OFFSET-FROM-CSP
      (VAR PROGRAM)
      (FIND-POSITION-OF-VAR VAR
                            (LOCAL-VARS PROGRAM)))

(DEFN GENERATE-POSTLUDE
      (PROGRAM)
      (CONS (DL (CONS (NAME PROGRAM)
                      (LENGTH (PROGRAM-BODY PROGRAM)))
                '(POSTLUDE)
                '(MOVE_CSP_CFP))
            '((CPOP_CFP) (CPOP_PC))))

(DEFN ICODE-RET
      (INS PCN PROGRAM)
      (LIST '(JUMP_*)
            (TAG 'PC
                 (CONS (NAME PROGRAM)
                       (LENGTH (PROGRAM-BODY PROGRAM))))))

(DEFN ICODE-LOCN
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'NAT
                       (OFFSET-FROM-CSP (CADR INS) PROGRAM))
                  '((ADD_X{N}_CSP)
                    (MOVE_X_<X{S}>)
                    (ADD_X{N}_CSP)
                    (TPUSH_<X{S}>)))))

(DEFN ICODE-PUSH-CONSTANT
      (INS PCN PROGRAM)
      (LIST '(TPUSH_*)
            (COND ((EQUAL (CADR INS) 'PC)
                   (TAG 'PC
                        (CONS (NAME PROGRAM) (ADD1 PCN))))
                  ((NLISTP (CADR INS))
                   (PC (CADR INS) PROGRAM))
                  (T (CADR INS)))))

(DEFN ICODE-PUSH-LOCAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'NAT
                       (OFFSET-FROM-CSP (CADR INS) PROGRAM))
                  '((ADD_X{N}_CSP) (TPUSH_<X{S}>)))))

(DEFN ICODE-PUSH-GLOBAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'ADDR (CONS (CADR INS) 0))
                  '((TPUSH_<X{A}>)))))

(DEFN ICODE-PUSH-CTRL-STK-FREE-SIZE
      (INS PCN PROGRAM)
      '((MOVE_X_*)
        (SYS-ADDR (FULL-CTRL-STK-ADDR . 0))
        (MOVE_X_<X{S}>)
        (TPUSH_CSP)
        (SUB_<TSP>{S}_X{S})))

(DEFN ICODE-PUSH-TEMP-STK-FREE-SIZE
      (INS PCN PROGRAM)
      '((MOVE_X_*)
        (SYS-ADDR (FULL-TEMP-STK-ADDR . 0))
        (MOVE_X_<X{S}>)
        (TPUSH_TSP)
        (SUB_<TSP>{S}_X{S})))

(DEFN ICODE-PUSH-TEMP-STK-INDEX
 (INS PCN PROGRAM)
 (CONS
      '(MOVE_Y_TSP)
      (CONS '(MOVE_X_*)
            (CONS '(SYS-ADDR (EMPTY-TEMP-STK-ADDR . 0))
                  (CONS '(MOVE_X_<X{S}>)
                        (CONS '(SUB_<Z>_X{S}_Y{S})
                              (CONS '(TPUSH_X)
                                    (CONS '(MOVE_X_*)
                                          (CONS (TAG 'NAT (ADD1 (CADR INS)))
                                                '((SUB_<TSP>{N}_X{N})))))))))))

(DEFN ICODE-JUMP-IF-TEMP-STK-FULL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_TSP)
            (CONS '(MOVE_Y_*)
                  (CONS '(SYS-ADDR (FULL-TEMP-STK-ADDR . 0))
                        (CONS '(MOVE_Y_<Y{S}>)
                              (CONS '(SUB_<Z>_X{S}_Y{S})
                                    (CONS '(MOVE_X_*)
                                          (CONS (PC (CADR INS) PROGRAM)
                                                '((JUMP-Z_X))))))))))

(DEFN ICODE-JUMP-IF-TEMP-STK-EMPTY
      (INS PCN PROGRAM)
      (CONS '(MOVE_Y_TSP)
            (CONS '(MOVE_X_*)
                  (CONS '(SYS-ADDR (EMPTY-TEMP-STK-ADDR . 0))
                        (CONS '(MOVE_X_<X{S}>)
                              (CONS '(SUB_<Z>_X{S}_Y{S})
                                    (CONS '(MOVE_X_*)
                                          (CONS (PC (CADR INS) PROGRAM)
                                                '((JUMP-Z_X))))))))))

(DEFN ICODE-POP
      (INS PCN PROGRAM)
      '((TPOP_X)))

(DEFN ICODE-POP*
      (INS PCN PROGRAM)
      (LIST '(ADD_TSP_*{N})
            (TAG 'NAT (CADR INS))))

(DEFN ICODE-POPN
      (INS PCN PROGRAM)
      '((TPOP_X) (ADD_TSP_X{N})))

(DEFN ICODE-POP-LOCAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'NAT
                       (OFFSET-FROM-CSP (CADR INS) PROGRAM))
                  '((ADD_X{N}_CSP) (TPOP_<X{S}>)))))

(DEFN ICODE-POP-GLOBAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'ADDR (CONS (CADR INS) 0))
                  '((TPOP_<X{A}>)))))

(DEFN ICODE-POP-LOCN
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'NAT
                       (OFFSET-FROM-CSP (CADR INS) PROGRAM))
                  '((ADD_X{N}_CSP)
                    (MOVE_X_<X{S}>)
                    (ADD_X{N}_CSP)
                    (TPOP_<X{S}>)))))

(DEFN ICODE-POP-CALL
      (INS PCN PROGRAM)
      (CONS '(TPOP_X)
            (CONS '(CPUSH_*)
                  (CONS (TAG 'PC
                             (CONS (NAME PROGRAM) (ADD1 PCN)))
                        '((JUMP_X{SUBR}))))))

(DEFN ICODE-FETCH-TEMP-STK
      (INS PCN PROGRAM)
      '((TPOP_Y)
        (INCR_Y_Y{N})
        (MOVE_X_*)
        (SYS-ADDR (EMPTY-TEMP-STK-ADDR . 0))
        (MOVE_X_<X{S}>)
        (SUB_X{S}_Y{N})
        (TPUSH_<X{S}>)))

(DEFN ICODE-DEPOSIT-TEMP-STK
      (INS PCN PROGRAM)
      '((TPOP_Y)
        (INCR_Y_Y{N})
        (MOVE_X_*)
        (SYS-ADDR (EMPTY-TEMP-STK-ADDR . 0))
        (MOVE_X_<X{S}>)
        (SUB_X{S}_Y{N})
        (TPOP_<X{S}>)))

(DEFN ICODE-JUMP
      (INS PCN PROGRAM)
      (LIST '(JUMP_*)
            (PC (CADR INS) PROGRAM)))

(DEFN JUMP_*-LST
      (LST PROGRAM)
      (IF (NLISTP LST)
          NIL
          (CONS '(JUMP_*)
                (CONS (PC (CAR LST) PROGRAM)
                      (JUMP_*-LST (CDR LST) PROGRAM)))))

(DEFN ICODE-JUMP-CASE
      (INS PCN PROGRAM)
      (APPEND '((TPOP_X) (ADD_X_X{N}) (ADD_PC_X{N}))
              (JUMP_*-LST (CDR INS) PROGRAM)))

(DEFN ICODE-PUSHJ
      (INS PCN PROGRAM)
      (LIST '(TPUSH_*)
            (TAG 'PC
                 (CONS (NAME PROGRAM) (ADD1 PCN)))
            '(JUMP_*)
            (PC (CADR INS) PROGRAM)))

(DEFN ICODE-POPJ
      (INS PCN PROGRAM)
      '((TPOP_PC)))

(DEFN ICODE-SET-LOCAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'NAT
                       (OFFSET-FROM-CSP (CADR INS) PROGRAM))
                  '((ADD_X{N}_CSP)
                    (MOVE_<X{S}>_<TSP>)))))

(DEFN ICODE-SET-GLOBAL
      (INS PCN PROGRAM)
      (CONS '(MOVE_X_*)
            (CONS (TAG 'ADDR (CONS (CADR INS) 0))
                  '((MOVE_<X{A}>_<TSP>)))))

(DEFN ICODE-TEST-NAT-AND-JUMP
      (INS PCN PROGRAM)
      (IF (EQUAL (CADR INS) 'ZERO)
          (CONS '(TPOP{N}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-Z_X)))))
          (CONS '(TPOP{N}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-NZ_X)))))))

(DEFN ICODE-TEST-INT-AND-JUMP
      (INS PCN PROGRAM)
      (CASE (CAR (CDR INS))
            (ZERO (CONS '(TPOP{I}_<ZN>_Y)
                        (CONS '(MOVE_X_*)
                              (CONS (PC (CADDR INS) PROGRAM)
                                    '((JUMP-Z_X))))))
            (NOT-ZERO (CONS '(TPOP{I}_<ZN>_Y)
                            (CONS '(MOVE_X_*)
                                  (CONS (PC (CADDR INS) PROGRAM)
                                        '((JUMP-NZ_X))))))
            (NEG (CONS '(TPOP{I}_<ZN>_Y)
                       (CONS '(MOVE_X_*)
                             (CONS (PC (CADDR INS) PROGRAM)
                                   '((JUMP-N_X))))))
            (NOT-NEG (CONS '(TPOP{I}_<ZN>_Y)
                           (CONS '(MOVE_X_*)
                                 (CONS (PC (CADDR INS) PROGRAM)
                                       '((JUMP-NN_X))))))
            (POS (LIST '(TPOP{I}_<ZN>_Y)
                       '(MOVE_X_*)
                       (TAG 'PC
                            (CONS (NAME PROGRAM) (ADD1 PCN)))
                       '(JUMP-N_X)
                       '(JUMP-Z_X)
                       '(JUMP_*)
                       (PC (CADDR INS) PROGRAM)))
            (OTHERWISE (CONS '(TPOP{I}_<ZN>_Y)
                             (CONS '(MOVE_X_*)
                                   (CONS (PC (CADDR INS) PROGRAM)
                                         '((JUMP-N_X) (JUMP-Z_X))))))))

(DEFN ICODE-TEST-BOOL-AND-JUMP
      (INS PCN PROGRAM)
      (IF (EQUAL (CADR INS) 'T)
          (CONS '(TPOP{B}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-NZ_X)))))
          (CONS '(TPOP{B}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-Z_X)))))))

(DEFN ICODE-TEST-BITV-AND-JUMP
      (INS PCN PROGRAM)
      (IF (EQUAL (CADR INS) 'ALL-ZERO)
          (CONS '(TPOP{V}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-Z_X)))))
          (CONS '(TPOP{V}_<Z>_Y)
                (CONS '(MOVE_X_*)
                      (CONS (PC (CADDR INS) PROGRAM)
                            '((JUMP-NZ_X)))))))

(DEFN ICODE-NO-OP
      (INS PCN PROGRAM)
      '((MOVE_X_X)))

(DEFN ICODE-ADD-ADDR
      (INS PCN PROGRAM)
      '((TPOP_X) (ADD_<TSP>{A}_X{N})))

(DEFN ICODE-SUB-ADDR
      (INS PCN PROGRAM)
      '((TPOP_X) (SUB_<TSP>{A}_X{N})))

(DEFN ICODE-EQ
      (INS PCN PROGRAM)
      '((TPOP_X)
        (XOR_<Z>_<TSP>_X)
        (XOR_<TSP>_<TSP>)
        (MOVE-Z_<TSP>_*)
        (BOOL T)))

(DEFN ICODE-LT-ADDR
      (INS PCN PROGRAM)
      '((TPOP_X)
        (SUB_<C>_<TSP>{A}_X{A})
        (XOR_<TSP>_<TSP>)
        (MOVE-C_<TSP>_*)
        (BOOL T)))

(DEFN ICODE-FETCH
      (INS PCN PROGRAM)
      '((TPOP_X) (TPUSH_<X{A}>)))

(DEFN ICODE-DEPOSIT
      (INS PCN PROGRAM)
      '((TPOP_X) (TPOP_<X{A}>)))

(DEFN ICODE-ADD-INT
      (INS PCN PROGRAM)
      '((TPOP_X) (ADD_<TSP>{I}_X{I})))

(DEFN ICODE-ADD-INT-WITH-CARRY
      (INS PCN PROGRAM)
      '((TPOP_X)
        (TPOP_Y)
        (ASR_<C>_<TSP>_<TSP>{B})
        (ADDC_<V>_X{I}_Y{I})
        (MOVE-V_<TSP>_*)
        (BOOL T)
        (TPUSH_X)))

(DEFN ICODE-ADD1-INT
      (INS PCN PROGRAM)
      '((INCR_<TSP>_<TSP>{I})))

(DEFN ICODE-SUB-INT
      (INS PCN PROGRAM)
      '((TPOP_X) (SUB_<TSP>{I}_X{I})))

(DEFN ICODE-SUB-INT-WITH-CARRY
      (INS PCN PROGRAM)
      '((TPOP_Y)
        (TPOP_X)
        (ASR_<C>_<TSP>_<TSP>{B})
        (SUBB_<V>_X{I}_Y{I})
        (MOVE-V_<TSP>_*)
        (BOOL T)
        (TPUSH_X)))

(DEFN ICODE-SUB1-INT
      (INS PCN PROGRAM)
      '((DECR_<TSP>_<TSP>{I})))

(DEFN ICODE-NEG-INT
      (INS PCN PROGRAM)
      '((NEG_<TSP>_<TSP>{I})))

(DEFN ICODE-LT-INT
      (INS PCN PROGRAM)
      '((TPOP_X)
        (SUB_<NV>_<TSP>{I}_X{I})
        (MOVE_<TSP>_*)
        (BOOL F)
        (MOVE-V_<TSP>_*)
        (BOOL T)
        (MOVE_X_*)
        (BOOL F)
        (MOVE-N_X_*)
        (BOOL T)
        (XOR_<TSP>{B}_X{B})))

(DEFN ICODE-INT-TO-NAT
      (INS PCN PROGRAM)
      '((INT-TO-NAT)))

(DEFN ICODE-ADD-NAT
      (INS PCN PROGRAM)
      '((TPOP_X) (ADD_<TSP>{N}_X{N})))

(DEFN ICODE-ADD-NAT-WITH-CARRY
      (INS PCN PROGRAM)
      '((TPOP_X)
        (TPOP_Y)
        (ASR_<C>_<TSP>_<TSP>{B})
        (ADDC_<C>_X{N}_Y{N})
        (MOVE-C_<TSP>_*)
        (BOOL T)
        (TPUSH_X)))

(DEFN ICODE-ADD1-NAT
      (INS PCN PROGRAM)
      '((INCR_<TSP>_<TSP>{N})))

(DEFN ICODE-SUB-NAT
      (INS PCN PROGRAM)
      '((TPOP_X) (SUB_<TSP>{N}_X{N})))

(DEFN ICODE-SUB-NAT-WITH-CARRY
      (INS PCN PROGRAM)
      '((TPOP_Y)
        (TPOP_X)
        (ASR_<C>_<TSP>_<TSP>{B})
        (SUBB_<C>_X{N}_Y{N})
        (MOVE-C_<TSP>_*)
        (BOOL T)
        (TPUSH_X)))

(DEFN ICODE-SUB1-NAT
      (INS PCN PROGRAM)
      '((DECR_<TSP>_<TSP>{N})))

(DEFN ICODE-LT-NAT
      (INS PCN PROGRAM)
      '((TPOP_X)
        (SUB_<C>_<TSP>{N}_X{N})
        (XOR_<TSP>_<TSP>)
        (MOVE-C_<TSP>_*)
        (BOOL T)))

(DEFN ICODE-MULT2-NAT
      (INS PCN PROGRAM)
      '((ADD_<TSP>_<TSP>{N})))

(DEFN ICODE-MULT2-NAT-WITH-CARRY-OUT
      (INS PCN PROGRAM)
      '((TPOP_X)
        (ADD_<C>_X_X{N})
        (TPUSH_*)
        (BOOL F)
        (MOVE-C_<TSP>_*)
        (BOOL T)
        (TPUSH_X)))

(DEFN ICODE-DIV2-NAT
      (INS PCN PROGRAM)
      '((TPOP_<C>_X)
        (LSR_<C>_X_X{N})
        (TPUSH_X)
        (TPUSH_*)
        (NAT 0)
        (MOVE-C_<TSP>_*)
        (NAT 1)))

(DEFN ICODE-OR-BITV
      (INS PCN PROGRAM)
      '((TPOP_X) (OR_<TSP>{V}_X{V})))

(DEFN ICODE-AND-BITV
      (INS PCN PROGRAM)
      '((TPOP_X) (AND_<TSP>{V}_X{V})))

(DEFN ICODE-NOT-BITV
      (INS PCN PROGRAM)
      '((NOT_<TSP>_<TSP>{V})))

(DEFN ICODE-XOR-BITV
      (INS PCN PROGRAM)
      '((TPOP_X) (XOR_<TSP>{V}_X{V})))

(DEFN ICODE-RSH-BITV
      (INS PCN PROGRAM)
      '((LSR_<TSP>_<TSP>{V})))

(DEFN ICODE-LSH-BITV
      (INS PCN PROGRAM)
      '((ADD_<TSP>_<TSP>{V})))

(DEFN ICODE-OR-BOOL
      (INS PCN PROGRAM)
      '((TPOP_X) (OR_<TSP>{B}_X{B})))

(DEFN ICODE-AND-BOOL
      (INS PCN PROGRAM)
      '((TPOP_X) (AND_<TSP>{B}_X{B})))

(DEFN ICODE-NOT-BOOL
      (INS PCN PROGRAM)
      '((XOR_<TSP>{B}_*{B}) (BOOL T)))

(DEFN ICODE1
      (INS PCN PROG)
      (CASE (CAR INS)
            (CALL (ICODE-CALL INS PCN PROG))
            (RET (ICODE-RET INS PCN PROG))
            (LOCN (ICODE-LOCN INS PCN PROG))
            (PUSH-CONSTANT (ICODE-PUSH-CONSTANT INS PCN PROG))
            (PUSH-LOCAL (ICODE-PUSH-LOCAL INS PCN PROG))
            (PUSH-GLOBAL (ICODE-PUSH-GLOBAL INS PCN PROG))
            (PUSH-CTRL-STK-FREE-SIZE (ICODE-PUSH-CTRL-STK-FREE-SIZE INS PCN
                                                                    PROG))
            (PUSH-TEMP-STK-FREE-SIZE (ICODE-PUSH-TEMP-STK-FREE-SIZE INS PCN
                                                                    PROG))
            (PUSH-TEMP-STK-INDEX (ICODE-PUSH-TEMP-STK-INDEX INS PCN PROG))
            (JUMP-IF-TEMP-STK-FULL (ICODE-JUMP-IF-TEMP-STK-FULL INS PCN PROG))
            (JUMP-IF-TEMP-STK-EMPTY (ICODE-JUMP-IF-TEMP-STK-EMPTY INS PCN
                                                                  PROG))
            (POP (ICODE-POP INS PCN PROG))
            (POP* (ICODE-POP* INS PCN PROG))
            (POPN (ICODE-POPN INS PCN PROG))
            (POP-LOCAL (ICODE-POP-LOCAL INS PCN PROG))
            (POP-GLOBAL (ICODE-POP-GLOBAL INS PCN PROG))
            (POP-LOCN (ICODE-POP-LOCN INS PCN PROG))
            (POP-CALL (ICODE-POP-CALL INS PCN PROG))
            (FETCH-TEMP-STK (ICODE-FETCH-TEMP-STK INS PCN PROG))
            (DEPOSIT-TEMP-STK (ICODE-DEPOSIT-TEMP-STK INS PCN PROG))
            (JUMP (ICODE-JUMP INS PCN PROG))
            (JUMP-CASE (ICODE-JUMP-CASE INS PCN PROG))
            (PUSHJ (ICODE-PUSHJ INS PCN PROG))
            (POPJ (ICODE-POPJ INS PCN PROG))
            (SET-LOCAL (ICODE-SET-LOCAL INS PCN PROG))
            (SET-GLOBAL (ICODE-SET-GLOBAL INS PCN PROG))
            (TEST-NAT-AND-JUMP (ICODE-TEST-NAT-AND-JUMP INS PCN PROG))
            (TEST-INT-AND-JUMP (ICODE-TEST-INT-AND-JUMP INS PCN PROG))
            (TEST-BOOL-AND-JUMP (ICODE-TEST-BOOL-AND-JUMP INS PCN PROG))
            (TEST-BITV-AND-JUMP (ICODE-TEST-BITV-AND-JUMP INS PCN PROG))
            (NO-OP (ICODE-NO-OP INS PCN PROG))
            (ADD-ADDR (ICODE-ADD-ADDR INS PCN PROG))
            (SUB-ADDR (ICODE-SUB-ADDR INS PCN PROG))
            (EQ (ICODE-EQ INS PCN PROG))
            (LT-ADDR (ICODE-LT-ADDR INS PCN PROG))
            (FETCH (ICODE-FETCH INS PCN PROG))
            (DEPOSIT (ICODE-DEPOSIT INS PCN PROG))
            (ADD-INT (ICODE-ADD-INT INS PCN PROG))
            (ADD-INT-WITH-CARRY (ICODE-ADD-INT-WITH-CARRY INS PCN PROG))
            (ADD1-INT (ICODE-ADD1-INT INS PCN PROG))
            (SUB-INT (ICODE-SUB-INT INS PCN PROG))
            (SUB-INT-WITH-CARRY (ICODE-SUB-INT-WITH-CARRY INS PCN PROG))
            (SUB1-INT (ICODE-SUB1-INT INS PCN PROG))
            (NEG-INT (ICODE-NEG-INT INS PCN PROG))
            (LT-INT (ICODE-LT-INT INS PCN PROG))
            (INT-TO-NAT (ICODE-INT-TO-NAT INS PCN PROG))
            (ADD-NAT (ICODE-ADD-NAT INS PCN PROG))
            (ADD-NAT-WITH-CARRY (ICODE-ADD-NAT-WITH-CARRY INS PCN PROG))
            (ADD1-NAT (ICODE-ADD1-NAT INS PCN PROG))
            (SUB-NAT (ICODE-SUB-NAT INS PCN PROG))
            (SUB-NAT-WITH-CARRY (ICODE-SUB-NAT-WITH-CARRY INS PCN PROG))
            (SUB1-NAT (ICODE-SUB1-NAT INS PCN PROG))
            (LT-NAT (ICODE-LT-NAT INS PCN PROG))
            (MULT2-NAT (ICODE-MULT2-NAT INS PCN PROG))
            (MULT2-NAT-WITH-CARRY-OUT (ICODE-MULT2-NAT-WITH-CARRY-OUT INS PCN
                                                                      PROG))
            (DIV2-NAT (ICODE-DIV2-NAT INS PCN PROG))
            (OR-BITV (ICODE-OR-BITV INS PCN PROG))
            (AND-BITV (ICODE-AND-BITV INS PCN PROG))
            (NOT-BITV (ICODE-NOT-BITV INS PCN PROG))
            (XOR-BITV (ICODE-XOR-BITV INS PCN PROG))
            (RSH-BITV (ICODE-RSH-BITV INS PCN PROG))
            (LSH-BITV (ICODE-LSH-BITV INS PCN PROG))
            (OR-BOOL (ICODE-OR-BOOL INS PCN PROG))
            (AND-BOOL (ICODE-AND-BOOL INS PCN PROG))
            (NOT-BOOL (ICODE-NOT-BOOL INS PCN PROG))
            (OTHERWISE '((ERROR)))))

(DEFN DL-BLOCK
      (LAB COMMENT BLOCK)
      (CONS (DL LAB COMMENT (CAR BLOCK))
            (CDR BLOCK)))

(DEFN ICODE
      (INS PCN PROGRAM)
      (DL-BLOCK (CONS (NAME PROGRAM) PCN)
                INS
                (ICODE1 (UNLABEL INS) PCN PROGRAM)))

(DEFN ICOMPILE-PROGRAM-BODY
      (LST PCN PROGRAM)
      (IF (NLISTP LST)
          NIL
          (APPEND (ICODE (CAR LST) PCN PROGRAM)
                  (ICOMPILE-PROGRAM-BODY (CDR LST)
                                         (ADD1 PCN)
                                         PROGRAM))))

(DEFN ICOMPILE-PROGRAM
      (PROGRAM)
      (CONS (NAME PROGRAM)
            (APPEND (GENERATE-PRELUDE PROGRAM)
                    (APPEND (ICOMPILE-PROGRAM-BODY (PROGRAM-BODY PROGRAM)
                                                   0 PROGRAM)
                            (GENERATE-POSTLUDE PROGRAM)))))

(DEFN ICOMPILE
      (PROGRAMS)
      (IF (NLISTP PROGRAMS)
          NIL
          (CONS (ICOMPILE-PROGRAM (CAR PROGRAMS))
                (ICOMPILE (CDR PROGRAMS)))))

(DEFN SEGMENT-LENGTH
      (SEGMENT)
      (IF (NLISTP SEGMENT)
          0
          (PLUS (LENGTH (CDAR SEGMENT))
                (SEGMENT-LENGTH (CDR SEGMENT)))))

(DEFN TOTAL-P-SYSTEM-SIZE (P LOAD-ADDR)
      (PLUS LOAD-ADDR
            (SEGMENT-LENGTH (P-DATA-SEGMENT P))
            (SEGMENT-LENGTH (ICOMPILE (P-PROG-SEGMENT P)))
            (ADD1 (P-MAX-CTRL-STK-SIZE P))
            (ADD1 (P-MAX-TEMP-STK-SIZE P))
            3))

(DEFN P-LOADABLEP (P LOAD-ADDR)
      (LESSP (TOTAL-P-SYSTEM-SIZE P LOAD-ADDR)
             (EXP 2 (P-WORD-SIZE P))))

(ADD-SHELL R-STATE NIL R-STATEP
           ((R-PC (NONE-OF) ZERO)
            (R-CFP (NONE-OF) ZERO)
            (R-CSP (NONE-OF) ZERO)
            (R-TSP (NONE-OF) ZERO)
            (R-X (NONE-OF) ZERO)
            (R-Y (NONE-OF) ZERO)
            (R-C-FLG (NONE-OF) ZERO)
            (R-V-FLG (NONE-OF) ZERO)
            (R-N-FLG (NONE-OF) ZERO)
            (R-Z-FLG (NONE-OF) ZERO)
            (R-PROG-SEGMENT (NONE-OF) ZERO)
            (R-USR-DATA-SEGMENT (NONE-OF) ZERO)
            (R-SYS-DATA-SEGMENT (NONE-OF) ZERO)
            (R-WORD-SIZE (NONE-OF) ZERO)
            (R-PSW (NONE-OF) ZERO)))

(DEFN NAT-0S
      (N)
      (IF (ZEROP N)
          NIL
          (CONS (TAG 'NAT 0)
                (NAT-0S (SUB1 N)))))

(DEFN P->R_TEMP-STK
      (TEMP-STK MAX-TEMP-STK-SIZE)
      (CONS 'TSTK
            (APPEND (NAT-0S (DIFFERENCE MAX-TEMP-STK-SIZE
                                        (LENGTH TEMP-STK)))
                    (APPEND TEMP-STK
                            (LIST (TAG 'NAT 0))))))

(DEFN P->R_CSP
      (STK MAX)
      (TAG 'SYS-ADDR
           (CONS 'CSTK
                 (DIFFERENCE MAX
                             (P-CTRL-STK-SIZE STK)))))

(DEFN P->R_CFP
      (STK MAX)
      (SUB-ADDR (P->R_CSP (POP STK) MAX) 2))

(DEFN P->R_P-FRAME
      (PFRAME STK MAX)
      (APPEND (STRIP-CDRS (BINDINGS PFRAME))
              (LIST (P->R_CFP STK MAX)
                    (RET-PC PFRAME))))

(DEFN P->R_CTRL-STK1
      (STK MAX)
      (IF (NLISTP STK)
          NIL
          (APPEND (P->R_P-FRAME (TOP STK) (POP STK) MAX)
                  (P->R_CTRL-STK1 (POP STK) MAX))))

(DEFN P->R_CTRL-STK
      (STK MAX)
      (CONS 'CSTK
            (APPEND (NAT-0S (DIFFERENCE MAX
                                        (P-CTRL-STK-SIZE STK)))
                    (APPEND (P->R_CTRL-STK1 STK MAX)
                            (LIST (TAG 'NAT 0))))))

(DEFN P->R_SYS-DATA-SEGMENT
      (CTRL-STK MAX-CTRL-STK-SIZE TEMP-STK MAX-TEMP-STK-SIZE)
      (LIST (P->R_CTRL-STK CTRL-STK MAX-CTRL-STK-SIZE)
            (P->R_TEMP-STK TEMP-STK MAX-TEMP-STK-SIZE)
            (LIST 'FULL-CTRL-STK-ADDR
                  (TAG 'SYS-ADDR '(CSTK . 0)))
            (LIST 'FULL-TEMP-STK-ADDR
                  (TAG 'SYS-ADDR '(TSTK . 0)))
            (LIST 'EMPTY-TEMP-STK-ADDR
                  (TAG 'SYS-ADDR
                       (CONS 'TSTK MAX-TEMP-STK-SIZE)))))

(DEFN P->R_TSP
      (STK MAX)
      (TAG 'SYS-ADDR
           (CONS 'TSTK
                 (DIFFERENCE MAX (LENGTH STK)))))

(DEFN P->R
      (P)
      (R-STATE (P-PC P)
               (P->R_CFP (P-CTRL-STK P)
                         (P-MAX-CTRL-STK-SIZE P))
               (P->R_CSP (P-CTRL-STK P)
                         (P-MAX-CTRL-STK-SIZE P))
               (P->R_TSP (P-TEMP-STK P)
                         (P-MAX-TEMP-STK-SIZE P))
               '(NAT 0)
               '(NAT 0)
               '(BOOL F)
               '(BOOL F)
               '(BOOL F)
               '(BOOL F)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P->R_SYS-DATA-SEGMENT (P-CTRL-STK P)
                                      (P-MAX-CTRL-STK-SIZE P)
                                      (P-TEMP-STK P)
                                      (P-MAX-TEMP-STK-SIZE P))
               (P-WORD-SIZE P)
               (P-PSW P)))

(ADD-SHELL I-STATE NIL I-STATEP
           ((I-PC (NONE-OF) ZERO)
            (I-CFP (NONE-OF) ZERO)
            (I-CSP (NONE-OF) ZERO)
            (I-TSP (NONE-OF) ZERO)
            (I-X (NONE-OF) ZERO)
            (I-Y (NONE-OF) ZERO)
            (I-C-FLG (NONE-OF) ZERO)
            (I-V-FLG (NONE-OF) ZERO)
            (I-N-FLG (NONE-OF) ZERO)
            (I-Z-FLG (NONE-OF) ZERO)
            (I-PROG-SEGMENT (NONE-OF) ZERO)
            (I-USR-DATA-SEGMENT (NONE-OF) ZERO)
            (I-SYS-DATA-SEGMENT (NONE-OF) ZERO)
            (I-WORD-SIZE (NONE-OF) ZERO)
            (I-PSW (NONE-OF) ZERO)))

(DEFN R->I_PC
      (PC PROGRAMS)
      (TAG 'IPC
           (CONS (AREA-NAME PC)
                 (FIND-LABEL (UNTAG PC)
                             (CDR (ICOMPILE-PROGRAM (DEFINITION (AREA-NAME PC)
                                                                PROGRAMS)))))))

(DEFN R->I_PSW
      (PSW)
      (IF (EQUAL PSW 'HALT) 'RUN PSW))

(DEFN R->I
      (R)
      (I-STATE (R->I_PC (R-PC R) (R-PROG-SEGMENT R))
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (ICOMPILE (R-PROG-SEGMENT R))
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               (R->I_PSW (R-PSW R))))

(ADD-SHELL M-STATE NIL M-STATEP
           ((M-REGS (NONE-OF) ZERO)
            (M-C-FLG (NONE-OF) ZERO)
            (M-V-FLG (NONE-OF) ZERO)
            (M-N-FLG (NONE-OF) ZERO)
            (M-Z-FLG (NONE-OF) ZERO)
            (M-MEM (NONE-OF) ZERO)))

(DEFN LINK-TABLE-FOR-SEGMENT (SEGMENT ADDR0)
      (IF (NLISTP SEGMENT)
          NIL
          (CONS (CONS (CAAR SEGMENT) ADDR0)
                (LINK-TABLE-FOR-SEGMENT (CDR SEGMENT)
                                        (PLUS ADDR0
                                              (LENGTH (CDAR SEGMENT)))))))

(DEFN LINK-TABLE-FOR-LABELS
      (LST ADDR0)
      (COND ((NLISTP LST) NIL)
            ((LABELLEDP (CAR LST))
             (CONS (CONS (CADAR LST) ADDR0)
                   (LINK-TABLE-FOR-LABELS (CDR LST)
                                          (ADD1 ADDR0))))
            (T (LINK-TABLE-FOR-LABELS (CDR LST)
                                      (ADD1 ADDR0)))))

(DEFN LINK-TABLE-FOR-PROG-LABELS
      (SEGMENT ADDR0)
      (IF (NLISTP SEGMENT)
          NIL
          (CONS (CONS (CAAR SEGMENT)
                      (LINK-TABLE-FOR-LABELS (CDAR SEGMENT)
                                             ADDR0))
                (LINK-TABLE-FOR-PROG-LABELS (CDR SEGMENT)
                                            (PLUS ADDR0
                                                  (LENGTH (CDAR SEGMENT)))))))

(DEFN I-LINK-TABLES (I LOAD-ADDR)
  (LIST
   (LINK-TABLE-FOR-SEGMENT (I-PROG-SEGMENT I)
                           (PLUS LOAD-ADDR
                                 (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I))))
   (LINK-TABLE-FOR-PROG-LABELS (I-PROG-SEGMENT I)
                               (PLUS LOAD-ADDR
                                     (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I))))
   (LINK-TABLE-FOR-SEGMENT (I-USR-DATA-SEGMENT I)
                           LOAD-ADDR)
   (LINK-TABLE-FOR-SEGMENT (I-SYS-DATA-SEGMENT I)
                           (PLUS LOAD-ADDR
                                 (SEGMENT-LENGTH (I-PROG-SEGMENT I))
                                 (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I))))))

(DEFN PROG-LINKS
      (LINK-TABLES)
      (CAR LINK-TABLES))

(DEFN PROG-LABEL-TABLES
      (LINK-TABLES)
      (CADR LINK-TABLES))

(DEFN USR-DATA-LINKS
      (LINK-TABLES)
      (CADDR LINK-TABLES))

(DEFN SYS-DATA-LINKS
      (LINK-TABLES)
      (CADDDR LINK-TABLES))

(DEFN LABEL-LINKS
      (LABEL PROG-LABEL-TABLES)
      (CDR (ASSOC (ADP-NAME LABEL)
                  PROG-LABEL-TABLES)))

(DEFN BASE-ADDRESS
      (NAME LINK-TABLE)
      (CDR (ASSOC NAME LINK-TABLE)))

(DEFN FIND-CONTAINING-AREA-NAME
      (N LINK-TABLE)
      (COND ((NLISTP LINK-TABLE) 0)
            ((NLISTP (CDR LINK-TABLE))
             (CAAR LINK-TABLE))
            ((AND (NOT (LESSP N (CDAR LINK-TABLE)))
                  (LESSP N (CDADR LINK-TABLE)))
             (CAAR LINK-TABLE))
            (T (FIND-CONTAINING-AREA-NAME N
                                          (CDR LINK-TABLE)))))

(DEFN INVERT-BASE-ADDRESS
      (N LINK-TABLE)
      (FIND-CONTAINING-AREA-NAME N LINK-TABLE))

(DEFN LABEL-ADDRESS
      (LABEL PROG-LABEL-TABLES)
      (BASE-ADDRESS LABEL
                    (LABEL-LINKS LABEL PROG-LABEL-TABLES)))

(DEFN ASSOC-CDRP
      (N ALIST)
      (COND ((NLISTP ALIST) F)
            ((EQUAL N (CDAR ALIST)) T)
            (T (ASSOC-CDRP N (CDR ALIST)))))

(DEFN FIND-CONTAINING-LABEL-TABLE
      (N LABEL-TABLES)
      (COND ((NLISTP LABEL-TABLES) F)
            ((ASSOC-CDRP N (CDAR LABEL-TABLES))
             (CDAR LABEL-TABLES))
            (T (FIND-CONTAINING-LABEL-TABLE N
                                            (CDR LABEL-TABLES)))))

(DEFN INVERT-LABEL-ADDRESS
      (N PROG-LABEL-TABLES)
      (INVERT-BASE-ADDRESS N
                           (FIND-CONTAINING-LABEL-TABLE N PROG-LABEL-TABLES)))

(DEFN ABSOLUTE-ADDRESS
      (ADP LINK-TABLE)
      (PLUS (BASE-ADDRESS (ADP-NAME ADP)
                          LINK-TABLE)
            (ADP-OFFSET ADP)))

(DEFN INVERT-ABSOLUTE-ADDRESS
      (N LINK-TABLE)
      (CONS (FIND-CONTAINING-AREA-NAME N LINK-TABLE)
            (DIFFERENCE N
                        (BASE-ADDRESS (FIND-CONTAINING-AREA-NAME N LINK-TABLE)
                                      LINK-TABLE))))

(DEFN BITV-TO-V (LST WORD-SIZE)
  (IF (ZEROP WORD-SIZE)
      NIL
      (APPEND (BITV-TO-V (CDR LST)
                         (SUB1 WORD-SIZE))
              (LIST (IF (EQUAL (CAR LST) 0) F T)))))

(DEFN V-TO-BITV (V)
      (IF (NLISTP V)
          NIL
          (APPEND (V-TO-BITV (CDR V))
                  (LIST (IF (CAR V) 1 0)))))

(DEFN BOOL-TO-V
      (B WORD-SIZE)
      (IF (EQUAL B 'F)
          (NAT-TO-V 0 WORD-SIZE)
          (NAT-TO-V 1 WORD-SIZE)))

(DEFN V-TO-BOOL (V)
  (IF (CAR V) 'T 'F))

(DEFN ADDR-TO-V
      (ADP USR-DATA-LINKS WORD-SIZE)
      (NAT-TO-V (ABSOLUTE-ADDRESS ADP USR-DATA-LINKS)
                 WORD-SIZE))

(DEFN V-TO-ADDR
      (V USR-DATA-LINKS)
      (INVERT-ABSOLUTE-ADDRESS (V-TO-NAT V)
                               USR-DATA-LINKS))

(DEFN SUBR-TO-V
      (SUBR PROG-LINKS WORD-SIZE)
      (NAT-TO-V (BASE-ADDRESS SUBR PROG-LINKS)
                 WORD-SIZE))

(DEFN V-TO-SUBR
      (V PROG-LINKS)
      (INVERT-BASE-ADDRESS (V-TO-NAT V)
                           PROG-LINKS))

(DEFN SYS-ADDR-TO-V
      (ADP SYS-DATA-LINKS WORD-SIZE)
      (NAT-TO-V (ABSOLUTE-ADDRESS ADP SYS-DATA-LINKS)
                 WORD-SIZE))

(DEFN V-TO-SYS-ADDR
      (V SYS-DATA-LINKS)
      (INVERT-ABSOLUTE-ADDRESS (V-TO-NAT V)
                               SYS-DATA-LINKS))

(DEFN LABEL-TO-V
      (ILAB PROG-LABEL-TABLES WORD-SIZE)
      (NAT-TO-V (LABEL-ADDRESS ILAB PROG-LABEL-TABLES)
                 WORD-SIZE))

(DEFN V-TO-LABEL
      (V PROG-LABEL-TABLES)
      (INVERT-LABEL-ADDRESS (V-TO-NAT V)
                            PROG-LABEL-TABLES))

(DEFN IPC-TO-V
      (PCPP PROG-LINKS WORD-SIZE)
      (NAT-TO-V (ABSOLUTE-ADDRESS PCPP PROG-LINKS)
                 WORD-SIZE))

(DEFN LINK-DATA-WORD
      (X LINK-TABLES WORD-SIZE)
      (CASE (TYPE X)
            (NAT (NAT-TO-V (UNTAG X) WORD-SIZE))
            (INT (INT-TO-V (UNTAG X) WORD-SIZE))
            (BITV (BITV-TO-V (UNTAG X) WORD-SIZE))
            (BOOL (BOOL-TO-V (UNTAG X) WORD-SIZE))
            (ADDR (ADDR-TO-V (UNTAG X)
                              (USR-DATA-LINKS LINK-TABLES)
                              WORD-SIZE))
            (SUBR (SUBR-TO-V (UNTAG X)
                              (PROG-LINKS LINK-TABLES)
                              WORD-SIZE))
            (SYS-ADDR (SYS-ADDR-TO-V (UNTAG X)
                                      (SYS-DATA-LINKS LINK-TABLES)
                                      WORD-SIZE))
            (PC (LABEL-TO-V (UNTAG X)
                             (PROG-LABEL-TABLES LINK-TABLES)
                             WORD-SIZE))
            (IPC (IPC-TO-V (UNTAG X)
                            (PROG-LINKS LINK-TABLES)
                            WORD-SIZE))
            (OTHERWISE (NAT-TO-V 0 WORD-SIZE))))

(DEFN UNLINK-DATA-WORD
      (TYPE V LINK-TABLES)
      (CASE TYPE
            (NAT (TAG 'NAT (V-TO-NAT V)))
            (INT (TAG 'INT (V-TO-INT V)))
            (BITV (TAG 'BITV (V-TO-BITV V)))
            (BOOL (TAG 'BOOL (V-TO-BOOL V)))
            (ADDR (TAG 'ADDR
                       (V-TO-ADDR V
                                   (USR-DATA-LINKS LINK-TABLES))))
            (SUBR (TAG 'SUBR
                       (V-TO-SUBR V
                                   (PROG-LINKS LINK-TABLES))))
            (SYS-ADDR (TAG 'SYS-ADDR
                           (V-TO-SYS-ADDR V
                                           (SYS-DATA-LINKS LINK-TABLES))))
            (PC (TAG 'PC
                     (V-TO-LABEL V
                                  (PROG-LABEL-TABLES LINK-TABLES))))
            (OTHERWISE '(UNRECOGNIZED I-LEVEL TYPE))))

(DEFN LINK-INSTRUCTION-ALIST
      NIL
      '((ADD_<C>_X_X{N} (ADD (C) X X))
        (ADD_<TSP>_<TSP>{V} (ADD NIL (TSP) (TSP)))
        (ADD_<TSP>_<TSP>{N} (ADD NIL (TSP) (TSP)))
        (ADD_<TSP>{A}_X{N} (ADD NIL (TSP) X))
        (ADD_TSP_*{N} (ADD NIL TSP (PC 1)))
        (ADD_TSP_X{N} (ADD NIL TSP X))
        (ADD_<TSP>{I}_X{I} (ADD NIL (TSP) X))
        (ADD_<TSP>{N}_X{N} (ADD NIL (TSP) X))
        (ADD_PC_X{N} (ADD NIL PC X))
        (ADD_X_X{N} (ADD NIL X X))
        (ADD_X{N}_CSP (ADD NIL X CSP))
        (ADDC_<C>_X{N}_Y{N} (ADDC (C) X Y))
        (ADDC_<V>_X{I}_Y{I} (ADDC (V) X Y))
        (AND_<TSP>{V}_X{V} (AND NIL (TSP) X))
        (AND_<TSP>{B}_X{B} (AND NIL (TSP) X))
        (ASR_<C>_<TSP>_<TSP>{B} (ASR (C) (TSP) (TSP)))
        (CPOP_CFP (MOVE NIL CFP (CSP 1)))
        (CPOP_PC (MOVE NIL PC (CSP 1)))
        (CPUSH_* (MOVE NIL (-1 CSP) (PC 1)))
        (CPUSH_<TSP>+ (MOVE NIL (-1 CSP) (TSP 1)))
        (CPUSH_CFP (MOVE NIL (-1 CSP) CFP))
        (DECR_<TSP>_<TSP>{I} (DECR NIL (TSP) (TSP)))
        (DECR_<TSP>_<TSP>{N} (DECR NIL (TSP) (TSP)))
        (INCR_<TSP>_<TSP>{I} (INCR NIL (TSP) (TSP)))
        (INCR_<TSP>_<TSP>{N} (INCR NIL (TSP) (TSP)))
        (INCR_Y_Y{N} (INCR NIL Y Y))
        (INT-TO-NAT (MOVE NIL X X))
        (JUMP-N_X (MOVE-N NIL PC X))
        (JUMP-NN_X (MOVE-NN NIL PC X))
        (JUMP-NZ_X (MOVE-NZ NIL PC X))
        (JUMP-Z_X (MOVE-Z NIL PC X))
        (JUMP_* (MOVE NIL PC (PC)))
        (JUMP_X{SUBR} (MOVE NIL PC X))
        (LSR_<C>_X_X{N} (LSR (C) X X))
        (LSR_<TSP>_<TSP>{V} (LSR NIL (TSP) (TSP)))
        (MOVE-C_<TSP>_* (MOVE-C NIL (TSP) (PC 1)))
        (MOVE-V_<TSP>_* (MOVE-V NIL (TSP) (PC 1)))
        (MOVE-Z_<TSP>_* (MOVE-Z NIL (TSP) (PC 1)))
        (MOVE-N_X_* (MOVE-N NIL X (PC 1)))
        (MOVE_<TSP>_* (MOVE NIL (TSP) (PC 1)))
        (MOVE_<X{A}>_<TSP> (MOVE NIL (X) (TSP)))
        (MOVE_<X{S}>_<TSP> (MOVE NIL (X) (TSP)))
        (MOVE_CFP_CSP (MOVE NIL CFP CSP))
        (MOVE_CSP_CFP (MOVE NIL CSP CFP))
        (MOVE_X_* (MOVE NIL X (PC 1)))
        (MOVE_X_<X{S}> (MOVE NIL X (X)))
        (MOVE_X_TSP (MOVE NIL X TSP))
        (MOVE_X_X (MOVE NIL X X))
        (MOVE_Y_* (MOVE NIL Y (PC 1)))
        (MOVE_Y_<Y{S}> (MOVE NIL Y (Y)))
        (MOVE_Y_TSP (MOVE NIL Y TSP))
        (NEG_<TSP>_<TSP>{I} (NEG NIL (TSP) (TSP)))
        (NOT_<TSP>_<TSP>{V} (NOT NIL (TSP) (TSP)))
        (OR_<TSP>{V}_X{V} (OR NIL (TSP) X))
        (OR_<TSP>{B}_X{B} (OR NIL (TSP) X))
        (SUB_<C>_<TSP>{A}_X{A} (SUB (C) (TSP) X))
        (SUB_<C>_<TSP>{N}_X{N} (SUB (C) (TSP) X))
        (SUB_<NV>_<TSP>{I}_X{I} (SUB (N V) (TSP) X))
        (SUB_<TSP>{A}_X{N} (SUB NIL (TSP) X))
        (SUB_X{S}_Y{N} (SUB NIL X Y))
        (SUB_<TSP>{I}_X{I} (SUB NIL (TSP) X))
        (SUB_<TSP>{N}_X{N} (SUB NIL (TSP) X))
        (SUB_<TSP>{S}_X{S} (SUB NIL (TSP) X))
        (SUB_<Z>_X{S}_Y{S} (SUB (Z) X Y))
        (SUBB_<C>_X{N}_Y{N} (SUBB (C) X Y))
        (SUBB_<V>_X{I}_Y{I} (SUBB (V) X Y))
        (TPOP_<C>_X (MOVE (C) X (TSP 1)))
        (TPOP_<X{A}> (MOVE NIL (X) (TSP 1)))
        (TPOP_<X{S}> (MOVE NIL (X) (TSP 1)))
        (TPOP_PC (MOVE NIL PC (TSP 1)))
        (TPOP_X (MOVE NIL X (TSP 1)))
        (TPOP_Y (MOVE NIL Y (TSP 1)))
        (TPOP{V}_<Z>_Y (MOVE (Z) Y (TSP 1)))
        (TPOP{B}_<Z>_Y (MOVE (Z) Y (TSP 1)))
        (TPOP{I}_<ZN>_Y (MOVE (Z N) Y (TSP 1)))
        (TPOP{N}_<Z>_Y (MOVE (Z) Y (TSP 1)))
        (TPUSH_* (MOVE NIL (-1 TSP) (PC 1)))
        (TPUSH_<X{A}> (MOVE NIL (-1 TSP) (X)))
        (TPUSH_<X{S}> (MOVE NIL (-1 TSP) (X)))
        (TPUSH_CSP (MOVE NIL (-1 TSP) CSP))
        (TPUSH_TSP (MOVE NIL (-1 TSP) TSP))
        (TPUSH_X (MOVE NIL (-1 TSP) X))
        (XOR_<TSP>_<TSP> (XOR NIL (TSP) (TSP)))
        (XOR_<TSP>{V}_X{V} (XOR NIL (TSP) X))
        (XOR_<TSP>{B}_*{B} (XOR NIL (TSP) (PC 1)))
        (XOR_<TSP>{B}_X{B} (XOR NIL (TSP) X))
        (XOR_<Z>_<TSP>_X (XOR (Z) (TSP) X))))

(DEFN PACK-INSTRUCTION
      (OP MOVE-BITS CVNZ MODE-B REG-B MODE-A REG-A WORD-SIZE)
      (NAT-TO-V (PLUS (TIMES OP (EXP 2 24))
                      (TIMES MOVE-BITS (EXP 2 20))
                      (TIMES CVNZ (EXP 2 16))
                      (TIMES MODE-B (EXP 2 14))
                      (TIMES REG-B (EXP 2 10))
;                     (TIMES 0000 (EXP 2 6))
                      (TIMES MODE-A (EXP 2 4))
                      REG-A)
                 WORD-SIZE))

(DEFN EXTRACT-OP
      (OPCODE)
      (CADR (ASSOC OPCODE
                   '((INCR 1)
                     (ADDC 2)
                     (ADD 3)
                     (NEG 4)
                     (DECR 5)
                     (SUBB 6)
                     (SUB 7)
                     (ROR 8)
                     (ASR 9)
                     (LSR 10)
                     (XOR 11)
                     (OR 12)
                     (AND 13)
                     (NOT 14)
                     (MOVE 15)
                     (MOVE-NC 15)
                     (MOVE-C 15)
                     (MOVE-NV 15)
                     (MOVE-V 15)
                     (MOVE-NZ 15)
                     (MOVE-Z 15)
                     (MOVE-NN 15)
                     (MOVE-N 15)))))

(DEFN EXTRACT-MOVE-BITS (OPCODE)
  (CASE OPCODE
        (MOVE 14)
        (MOVE-NC 0)
        (MOVE-C 1)
        (MOVE-NV 2)
        (MOVE-V 3)
        (MOVE-NZ 6)
        (MOVE-Z 7)
        (MOVE-NN 4)
        (MOVE-N 5)
        (OTHERWISE 14)))

(DEFN EXTRACT-MODE
      (REG-SPEC)
      (COND ((LITATOM REG-SPEC) 0)
            ((EQUAL (CDR REG-SPEC) NIL) 1)
            ((EQUAL (CAR REG-SPEC) -1) 2)
            (T 3)))

(DEFN EXTRACT-CVNZ
      (FLG-NAMES)
      (PLUS (TIMES (IF (MEMBER 'C FLG-NAMES) 1 0)
                   (EXP 2 3))
            (TIMES (IF (MEMBER 'V FLG-NAMES) 1 0)
                   (EXP 2 2))
            (TIMES (IF (MEMBER 'N FLG-NAMES) 1 0)
                   (EXP 2 1))
            (TIMES (IF (MEMBER 'Z FLG-NAMES) 1 0)
                   (EXP 2 0))))

(DEFN EXTRACT-REG1
      (REG-SPEC)
      (COND ((LITATOM REG-SPEC) REG-SPEC)
            ((EQUAL (CDR REG-SPEC) NIL)
             (CAR REG-SPEC))
            ((EQUAL (CAR REG-SPEC) -1)
             (CADR REG-SPEC))
            (T (CAR REG-SPEC))))

(DEFN EXTRACT-REG
      (REG-SPEC)
      (CADR (ASSOC (EXTRACT-REG1 REG-SPEC)
                   '((PC 15)
                     (CFP 1)
                     (CSP 2)
                     (TSP 3)
                     (X 4)
                     (Y 5)))))

(DEFN MCI
      (INS WORD-SIZE)
      (PACK-INSTRUCTION (EXTRACT-OP (CAR INS))
                        (EXTRACT-MOVE-BITS (CAR INS))
                        (EXTRACT-CVNZ (CADR INS))
                        (EXTRACT-MODE (CADDR INS))
                        (EXTRACT-REG (CADDR INS))
                        (EXTRACT-MODE (CADDDR INS))
                        (EXTRACT-REG (CADDDR INS))
                        WORD-SIZE))

(DEFN ICODE-INSTRUCTIONP
      (INS)
      (EQUAL (CDR INS) NIL))

(DEFN LINK-INSTR-WORD
      (INS WORD-SIZE)
      (MCI (CADR (ASSOC (CAR INS)
                        (LINK-INSTRUCTION-ALIST)))
           WORD-SIZE))

(DEFN LINK-WORD
      (X LINK-TABLES WORD-SIZE)
      (IF (ICODE-INSTRUCTIONP X)
          (LINK-INSTR-WORD X WORD-SIZE)
          (LINK-DATA-WORD X LINK-TABLES WORD-SIZE)))

(DEFN LINK-AREA
      (LST LINK-TABLES WORD-SIZE)
      (IF (NLISTP LST)
          NIL
          (CONS (LINK-WORD (UNLABEL (CAR LST))
                           LINK-TABLES WORD-SIZE)
                (LINK-AREA (CDR LST)
                           LINK-TABLES WORD-SIZE))))

(DEFN LINK-SEGMENT
      (SEGMENT LINK-TABLES WORD-SIZE)
      (IF (NLISTP SEGMENT)
          NIL
          (APPEND (LINK-AREA (CDAR SEGMENT)
                             LINK-TABLES WORD-SIZE)
                  (LINK-SEGMENT (CDR SEGMENT)
                                LINK-TABLES WORD-SIZE))))

(defn boot-code (lst n word-size)
  (if (zerop n)
      nil
      (cons (nat-to-v (car lst) word-size)
            (boot-code (cdr lst) (sub1 n) word-size))))

(DEFN LINK-MEM (boot-lst LOAD-ADDR USR-DATA-SEGMENT PROG-SEGMENT SYS-DATA-SEGMENT
                         LINK-TABLES WORD-SIZE)
  (append
   (boot-code boot-lst load-addr word-size)
   (APPEND (LINK-SEGMENT USR-DATA-SEGMENT LINK-TABLES WORD-SIZE)
           (APPEND (LINK-SEGMENT PROG-SEGMENT LINK-TABLES WORD-SIZE)
                   (LINK-SEGMENT SYS-DATA-SEGMENT LINK-TABLES WORD-SIZE)))))

(DEFN BOOL-TO-LOGICAL
      (B)
      (IF (EQUAL B 'F) F T))

(DEFN I->M (I BOOT-LST LOAD-ADDR)
  (LET ((TABLES (I-LINK-TABLES I LOAD-ADDR))
        (W (I-WORD-SIZE I)))
  (M-STATE (LIST (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD (I-CFP I) TABLES W)
                 (LINK-WORD (I-CSP I) TABLES W)
                 (LINK-WORD (I-TSP I) TABLES W)
                 (LINK-WORD (I-X I) TABLES W)
                 (LINK-WORD (I-Y I) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD '(NAT 0) TABLES W)
                 (LINK-WORD (I-PC I) TABLES W))
           (BOOL-TO-LOGICAL (UNTAG (I-C-FLG I)))
           (BOOL-TO-LOGICAL (UNTAG (I-V-FLG I)))
           (BOOL-TO-LOGICAL (UNTAG (I-N-FLG I)))
           (BOOL-TO-LOGICAL (UNTAG (I-Z-FLG I)))
           (LINK-MEM BOOT-LST
                     LOAD-ADDR
                     (I-USR-DATA-SEGMENT I)
                     (I-PROG-SEGMENT I)
                     (I-SYS-DATA-SEGMENT I)
                     TABLES
                     W))))

(PROVE-LEMMA MY-LESSP-QUOTIENT (REWRITE)
             (IMPLIES (AND (NUMBERP SIZE)
                           (NOT (EQUAL SIZE 0)))
                      (LESSP (QUOTIENT SIZE 2) SIZE)))

(DEFN RAM-TREE (LST SIZE)
  (COND ((ZEROP SIZE) (STUB (NAT-TO-V 0 32)))   ; never happens
        ((NLISTP LST) (STUB (NAT-TO-V 0 32)))
        ((EQUAL SIZE 1) (RAM (CAR LST)))
        (T (CONS (RAM-TREE (FIRSTN (QUOTIENT SIZE 2) LST) (QUOTIENT SIZE 2))
                 (RAM-TREE (RESTN (QUOTIENT SIZE 2) LST)  (QUOTIENT SIZE 2)))))
  ((LESSP (COUNT SIZE))))

(DEFN FM-STATE (REGS C V N Z MEM)
  (LIST (LIST (RAM-TREE REGS 16)
              (LIST Z N V C))
        (RAM-TREE MEM (EXP 2 32))))

(DEFN M->FM9001 (M)
  (LIST (LIST (RAM-TREE (M-REGS M) 16)
              (LIST (M-Z-FLG M)
                    (M-N-FLG M)
                    (M-V-FLG M)
                    (M-C-FLG M)))
        (RAM-TREE (M-MEM M) (EXP 2 32))))

(DEFN LOAD (P boot-lst LOAD-ADDR) (M->FM9001 (I->M (R->I (P->R P)) boot-lst LOAD-ADDR)))

(DEFN LINK-TABLES (P LOAD-ADDR)
      (I-LINK-TABLES (R->I (P->R P)) LOAD-ADDR))

(DEFN TYPE-LST
      (LST)
      (IF (NLISTP LST)
          NIL
          (CONS (TYPE (CAR LST))
                (TYPE-LST (CDR LST)))))

(DEFN AREA-TYPE-SPECIFICATION
      (AREA)
      (CONS (CAR AREA)
            (TYPE-LST (CDR AREA))))

(DEFN TYPE-SPECIFICATION
      (SEGMENT)
      (IF (NLISTP SEGMENT)
          NIL
          (CONS (AREA-TYPE-SPECIFICATION (CAR SEGMENT))
                (TYPE-SPECIFICATION (CDR SEGMENT)))))

(DEFN DISPLAY-FM9001-ARRAY (TYPE-LST N FM-MEM LINK-TABLES)
  (IF (NLISTP TYPE-LST)
      NIL
      (CONS (UNLINK-DATA-WORD (CAR TYPE-LST)
                              (READ-MEM (NAT-TO-V N 32) FM-MEM)
                              LINK-TABLES)
            (DISPLAY-FM9001-ARRAY (CDR TYPE-LST)
                                  (ADD1 N)
                                  FM-MEM LINK-TABLES))))

(DEFN DISPLAY-FM9001-DATA-AREA (AREA-TYPE-SPEC FM-MEM LINK-TABLES)
  (CONS (CAR AREA-TYPE-SPEC)
        (DISPLAY-FM9001-ARRAY (CDR AREA-TYPE-SPEC)
                              (BASE-ADDRESS (CAR AREA-TYPE-SPEC)
                                            (USR-DATA-LINKS LINK-TABLES))
                              FM-MEM LINK-TABLES)))

(DEFN DISPLAY-FM9001-DATA-SEGMENT1 (TYPE-SPEC FM-MEM LINK-TABLES)
  (IF (NLISTP TYPE-SPEC)
      NIL
      (CONS (DISPLAY-FM9001-DATA-AREA (CAR TYPE-SPEC) FM-MEM LINK-TABLES)
            (DISPLAY-FM9001-DATA-SEGMENT1 (CDR TYPE-SPEC) FM-MEM LINK-TABLES))))

(DEFN DISPLAY-FM9001-DATA-SEGMENT (FM-STATE TYPE-SPEC LINK-TABLES)
      (DISPLAY-FM9001-DATA-SEGMENT1 TYPE-SPEC
                                    (CADR FM-STATE)
                                    LINK-TABLES))

; Book:  m.events.  Now we define the m machine.

(DEFN V-NTH1 (V-N LST)
  (IF (LESSP (V-TO-NAT V-N) (LENGTH LST))
      (NTH (V-TO-NAT V-N) LST)
      (NAT-TO-V 0 32)))

(DEFN CURRENT-INSTRUCTION (REGS MEM)
  (V-NTH1 (V-NTH1 (NAT-TO-V 15 4) REGS) MEM))

(DEFN M-STORE-RESULTP (STORE-CC C V N Z)
  (CASE STORE-CC
        ((*1*FALSE *1*FALSE *1*FALSE *1*FALSE)
         (NOT C))
        ((*1*TRUE *1*FALSE *1*FALSE *1*FALSE)
         C)
        ((*1*FALSE *1*TRUE *1*FALSE *1*FALSE)
         (NOT V))
        ((*1*TRUE *1*TRUE *1*FALSE *1*FALSE)
         V)
        ((*1*FALSE *1*FALSE *1*TRUE *1*FALSE)
         (NOT N))
        ((*1*TRUE *1*FALSE *1*TRUE *1*FALSE)
         N)
        ((*1*FALSE *1*TRUE *1*TRUE *1*FALSE)
         (NOT Z))
        ((*1*TRUE *1*TRUE *1*TRUE *1*FALSE)
         Z)
        ((*1*FALSE *1*FALSE *1*FALSE *1*TRUE)
         (AND (NOT C)
              (NOT Z)))
        ((*1*TRUE *1*FALSE *1*FALSE *1*TRUE)
         (OR C Z))
        ((*1*FALSE *1*TRUE *1*FALSE *1*TRUE)
         (OR (AND N V)
             (AND (NOT N)
                  (NOT V))))
        ((*1*TRUE *1*TRUE *1*FALSE *1*TRUE)
         (OR (AND N
                  (NOT V))
             (AND (NOT N)
                  V)))
        ((*1*FALSE *1*FALSE *1*TRUE *1*TRUE)
         (OR (AND N
                  V
                  (NOT Z))
             (AND (NOT N)
                  (NOT V)
                  (NOT Z))))
        ((*1*TRUE *1*FALSE *1*TRUE *1*TRUE)
         (OR Z
             (AND N
                  (NOT V))
             (AND (NOT N)
                  V)))
        ((*1*FALSE *1*TRUE *1*TRUE *1*TRUE) T)
        (OTHERWISE F)))

(PROVE-LEMMA M-STORE-RESULTP-IS-STORE-RESULTP (REWRITE)
  (EQUAL (M-STORE-RESULTP STORE-CC C V N Z)
         (STORE-RESULTP STORE-CC (LIST Z N V C))))

(DISABLE M-STORE-RESULTP)
(DISABLE STORE-RESULTP)

(DEFN M-ALU-OPERATION (REGS C V N Z MEM INS OPERAND-A OPERAND-B B-ADDRESS)
  (M-STATE (IF (AND (M-STORE-RESULTP (STORE-CC INS) C V N Z)
                      (REG-DIRECT-P (MODE-B INS)))
                (UPDATE-V-NTH (RN-B INS)
                              REGS
                              (BV (V-ALU C
                                         OPERAND-A OPERAND-B
                                         (OP-CODE INS))))
                REGS)
           (B-IF (C-SET (SET-FLAGS INS))
                 (C (V-ALU C
                           OPERAND-A OPERAND-B
                           (OP-CODE INS)))
                 C)
           (B-IF (V-SET (SET-FLAGS INS))
                 (V (V-ALU C
                           OPERAND-A OPERAND-B
                           (OP-CODE INS)))
                 V)
           (B-IF (N-SET (SET-FLAGS INS))
                 (N (V-ALU C
                           OPERAND-A OPERAND-B
                           (OP-CODE INS)))
                 N)
           (B-IF (Z-SET (SET-FLAGS INS))
                 (ZB (V-ALU C
                            OPERAND-A OPERAND-B
                            (OP-CODE INS)))
                 Z)
           (IF (AND (M-STORE-RESULTP (STORE-CC INS) C V N Z)
                      (NOT (REG-DIRECT-P (MODE-B INS))))
                (UPDATE-V-NTH B-ADDRESS MEM
                              (BV (V-ALU C
                                         OPERAND-A OPERAND-B
                                         (OP-CODE INS))))
                MEM)))

(DEFN READ-MEM1-RAM-TREE-HINT (RADDR LST)
  (COND ((NLISTP RADDR) T)
        ((CAR RADDR)
         (READ-MEM1-RAM-TREE-HINT (CDR RADDR)
                                  (RESTN (EXP 2 (LENGTH (CDR RADDR))) LST)))
        (T (READ-MEM1-RAM-TREE-HINT (CDR RADDR)
                                    (FIRSTN (EXP 2 (LENGTH (CDR RADDR))) LST)))))

(DEFN REV (X)
  (IF (NLISTP X)
      NIL
      (APPEND (REV (CDR X)) (LIST (CAR X)))))

(ENABLE APPEND)

(PROVE-LEMMA REV1-IS-REV (REWRITE)
  (EQUAL (REV1 X A) (APPEND (REV X) A)))

(PROVE-LEMMA APPEND-NIL (REWRITE)
  (IMPLIES (PROPERP X) (EQUAL (APPEND X NIL) X)))

(PROVE-LEMMA PROPERP-REV (REWRITE) (PROPERP (REV X)))

(PROVE-LEMMA READ-MEM1-REV-RAM-TREE-LEMMA1 (REWRITE)
  (IMPLIES (STUBP (RAM-TREE LST N))
           (EQUAL (STUB-GUTS (RAM-TREE LST N)) (NAT-TO-V 0 32))))

(ENABLE PLUS-0)
(ENABLE PLUS-ADD1-SUB1)
(ENABLE PLUS-ADD1)
(enable ASSOCIATIVITY-OF-PLUS)
(enable commutativity-of-plus)
(ENABLE TIMES-COMMUTES)
(ENABLE TIMES-ADD1-AGAIN)
(ENABLE TIMES-1)
(enable times-distributes-over-plus)
(enable ASSOCIATIVITY-OF-TIMES)


(PROVE-LEMMA MY-V-TO-NAT-APPEND (REWRITE)
  (EQUAL (V-TO-NAT (APPEND A B))
         (PLUS (V-TO-NAT A) (TIMES (EXP 2 (LENGTH A)) (V-TO-NAT B)))))

(ENABLE PLUS)

(ENABLE DIFFERENCE)

(PROVE-LEMMA DIFFERENCE-ADD1-ADD1-X-2 (REWRITE)
  (EQUAL (DIFFERENCE (ADD1 (ADD1 X)) 2) (FIX X)))

(enable QUOTIENT-PLUS-X-X-2)

(ENABLE LENGTH-FIRSTN)

(ENABLE LENGTH-RESTN)

(PROVE-LEMMA my-LESSP-V-TO-NAT-EXP (REWRITE)
  (IMPLIES (EQUAL N (LENGTH V))
           (LESSP (V-TO-NAT V) (EXP 2 N))))

(PROVE-LEMMA LENGTH-REV (REWRITE) (EQUAL (LENGTH (REV X)) (LENGTH X)))

(PROVE-LEMMA NTH-FIRSTN (REWRITE)
  (IMPLIES (LESSP I N)
           (EQUAL (NTH I (FIRSTN N LST)) (NTH I LST))))

(PROVE-LEMMA LESSP-DIFFERENCE (REWRITE)
  (EQUAL (LESSP V (DIFFERENCE L E))
         (IF (LESSP E L)
             (LESSP (PLUS E V) L)
             F)))

(PROVE-LEMMA NTH-RESTN-PLUS (REWRITE)
  (IMPLIES (LESSP I (LENGTH LST))
           (EQUAL (NTH N
                       (RESTN I LST))
                  (NTH (PLUS I N)
                       LST))))

(PROVE-LEMMA READ-MEM1-REV-RAM-TREE NIL
  (IMPLIES (NOT (LESSP (EXP 2 (LENGTH RADDR)) (LENGTH LST)))
           (EQUAL (V-NTH1 (REV RADDR) LST)
                  (READ-MEM1 RADDR (RAM-TREE LST (EXP 2 (LENGTH RADDR))))))
  ((INDUCT (READ-MEM1-RAM-TREE-HINT RADDR LST))))

(PROVE-LEMMA REV-APPEND (REWRITE)
  (EQUAL (REV (APPEND A B)) (APPEND (REV B) (REV A))))

(PROVE-LEMMA V-TO-NAT-REV-REV (REWRITE)
  (EQUAL (V-TO-NAT (REV (REV ADDR))) (V-TO-NAT ADDR)))

(PROVE-LEMMA READ-MEM-RAM-TREE (REWRITE)
  (IMPLIES (AND (EQUAL E (EXP 2 (LENGTH ADDR)))
                (NOT (LESSP E (LENGTH LST))))
           (EQUAL (V-NTH1 ADDR LST)
                  (READ-MEM ADDR (RAM-TREE LST E))))
  ((USE (READ-MEM1-REV-RAM-TREE (RADDR (REV ADDR))))))

(DISABLE V-NTH1)
(DISABLE READ-MEM)

(PROVE-LEMMA RESTN-UPDATE-NTH-PLUS (REWRITE)
  (EQUAL (RESTN E (UPDATE-NTH (PLUS V E) L VAL))
         (UPDATE-NTH V (RESTN E L) VAL)))

(PROVE-LEMMA FIRSTN-UPDATE-NTH-PLUS (REWRITE)
  (EQUAL (FIRSTN E (UPDATE-NTH (PLUS V E) L VAL))
         (FIRSTN E L)))

(PROVE-LEMMA RESTN-UPDATE-NTH (REWRITE)
  (IMPLIES (LESSP V E)
           (EQUAL (RESTN E (UPDATE-NTH V L VAL))
                  (RESTN E L))))

(PROVE-LEMMA FIRSTN-UPDATE-NTH (REWRITE)
  (IMPLIES (LESSP V E)
           (EQUAL (FIRSTN E (UPDATE-NTH V L VAL))
                  (UPDATE-NTH V (FIRSTN E L) VAL))))

(PROVE-LEMMA WRITE-MEM1-REV-RAM-TREE NIL
  (IMPLIES (NOT (LESSP (EXP 2 (LENGTH RADDR)) (LENGTH LST)))
           (EQUAL (RAM-TREE (UPDATE-V-NTH (REV RADDR) LST VAL)
                            (EXP 2 (LENGTH RADDR)))
                  (WRITE-MEM1 RADDR (RAM-TREE LST (EXP 2 (LENGTH RADDR))) VAL)))
  ((INDUCT (READ-MEM1-RAM-TREE-HINT RADDR LST))))

(PROVE-LEMMA WRITE-MEM-RAM-TREE (REWRITE)
  (IMPLIES (AND (EQUAL E (EXP 2 (LENGTH ADDR)))
                (NOT (LESSP E (LENGTH LST))))
           (EQUAL (RAM-TREE (UPDATE-V-NTH ADDR LST VAL) E)
                  (WRITE-MEM ADDR (RAM-TREE LST E) VAL)))
  ((USE (WRITE-MEM1-REV-RAM-TREE (RADDR (REV ADDR))))))

(DISABLE UPDATE-V-NTH)
(DISABLE WRITE-MEM)

(PROVE-LEMMA LENGTH-RN-B (REWRITE)
  (EQUAL (LENGTH (RN-B INS)) 4)
  ((ENABLE LENGTH-SUBRANGE)))

(PROVE-LEMMA M-ALU-OPERATION-IS-FM9001-ALU-OPERATION (REWRITE)
   (IMPLIES (AND (EQUAL (LENGTH B-ADDRESS) 32)
                 (EQUAL (LENGTH REGS) 16)
                 (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
            (EQUAL (M->FM9001
                    (M-ALU-OPERATION REGS C V N Z MEM
                                     INS OPERAND-A OPERAND-B B-ADDRESS))
                   (FM9001-ALU-OPERATION (RAM-TREE REGS 16)
                                         (LIST Z N V C)
                                         (RAM-TREE MEM (EXP 2 32))
                                         INS OPERAND-A OPERAND-B B-ADDRESS)))
   ((DISABLE REG-DIRECT-P STORE-CC MODE-B RN-B BV V-ALU OP-CODE C-SET
             V-SET N-SET Z-SET SET-FLAGS)))

(DEFN BVP-LISTP (LST)
  (IF (NLISTP LST)
      (EQUAL LST NIL)
      (AND (BVP (CAR LST))
           (EQUAL (LENGTH (CAR LST)) 32)
           (BVP-LISTP (CDR LST)))))

(DEFN PROPER-M-STATEP (M)
  (AND (M-STATEP M)
       (BVP-LISTP (M-REGS M))
       (BVP-LISTP (M-MEM M))
       (EQUAL (LENGTH (M-REGS M)) 16)
       (NOT (LESSP (EXP 2 32) (LENGTH (M-MEM M))))))

(PROVE-LEMMA LENGTH-NTH (REWRITE)
  (IMPLIES (AND (BVP-LISTP LST)
                (LESSP N (LENGTH LST)))
           (AND (BVP (NTH N LST))
                (EQUAL (LENGTH (NTH N LST)) 32))))

(PROVE-LEMMA LENGTH-V-NTH1 (REWRITE)
  (IMPLIES (BVP-LISTP LST)
           (AND (BVP (V-NTH1 ADDR LST))
                (EQUAL (LENGTH (V-NTH1 ADDR LST)) 32)))
  ((ENABLE V-NTH1)))

(PROVE-LEMMA LENGTH-READ-MEM (REWRITE)
  (IMPLIES (AND (BVP-LISTP LST)
                (EQUAL K (EXP 2 (LENGTH ADDR)))
                (NOT (LESSP K (LENGTH LST))))
           (AND (BVP (READ-MEM ADDR (RAM-TREE LST K)))
                (EQUAL (LENGTH (READ-MEM ADDR (RAM-TREE LST K))) 32)))
  ((ENABLE READ-MEM)
   (DISABLE READ-MEM-RAM-TREE)
   (USE (READ-MEM-RAM-TREE (E (EXP 2 (LENGTH ADDR)))))))

(PROVE-LEMMA BVP-LISTP-UPDATE-NTH (REWRITE)
  (IMPLIES (AND (BVP VAL)
                (EQUAL (LENGTH VAL) 32)
                (BVP-LISTP LST))
           (BVP-LISTP (UPDATE-NTH N LST VAL))))

(PROVE-LEMMA BVP-LISTP-UPDATE-V-NTH (REWRITE)
  (IMPLIES (AND (BVP VAL)
                (EQUAL (LENGTH VAL) 32)
                (BVP-LISTP LST))
           (BVP-LISTP (UPDATE-V-NTH ADDR LST VAL)))
  ((ENABLE UPDATE-V-NTH)))

(ENABLE BVP-BV-V-ALU)

(PROVE-LEMMA LENGTH-BV-V-ALU (REWRITE)
  (IMPLIES (AND (EQUAL (LENGTH A) (LENGTH B))
                (LISTP A))
           (EQUAL (LENGTH (BV (V-ALU C A B OP))) (LENGTH A)))
  ((DISABLE V-BUF V-NOT V-AND V-OR V-XOR V-LSR V-ASR V-ROR V-SUBTRACTER-OUTPUT
            V-ADDER-OUTPUT)
   (ENABLE LENGTH-V-BUF LENGTH-V-NOT LENGTH-V-AND LENGTH-V-OR LENGTH-V-XOR
           LENGTH-V-LSR LENGTH-V-ASR LENGTH-V-ROR LENGTH-OF-V-ADDER-OUTPUT
           LENGTH-OF-V-SUBTRACTER-OUTPUT LENGTH-NAT-TO-V)))

(PROVE-LEMMA LENGTH-UPDATE-NTH (REWRITE)
  (EQUAL (LENGTH (UPDATE-NTH I LST VAL)) (LENGTH LST)))

(PROVE-LEMMA LENGTH-UPDATE-V-NTH (REWRITE)
  (EQUAL (LENGTH (UPDATE-V-NTH V LST VAL)) (LENGTH LST))
  ((ENABLE UPDATE-V-NTH)))

(PROVE-LEMMA M-ALU-OPERATION-PRESERVES-HYPS (REWRITE)
  (IMPLIES
   (AND (BVP-LISTP MEM)
        (BVP-LISTP REGS)
        (BVP OPERAND-A)
        (EQUAL (LENGTH OPERAND-A) 32)
        (EQUAL (LENGTH OPERAND-B) 32)
        (LISTP OPERAND-A)
        (EQUAL (LENGTH B-ADDRESS) 32)
        (EQUAL (LENGTH REGS) 16)
        (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
   (PROPER-M-STATEP (M-ALU-OPERATION REGS C V N Z MEM
                                     INS OPERAND-A OPERAND-B B-ADDRESS)))
  ((DISABLE REG-DIRECT-P STORE-CC MODE-B RN-B BV V-ALU OP-CODE C-SET
            V-SET N-SET Z-SET SET-FLAGS)))

(DISABLE M-ALU-OPERATION)
(DISABLE FM9001-ALU-OPERATION)

(DEFN M-OPERAND-B (REGS C V N Z MEM INS OPERAND-A)
  (M-ALU-OPERATION (IF (PRE-DEC-P (MODE-B INS))
                       (UPDATE-V-NTH (RN-B INS)
                                     REGS
                                     (V-DEC (V-NTH1 (RN-B INS) REGS)))
                       (IF (POST-INC-P (MODE-B INS))
                           (UPDATE-V-NTH (RN-B INS)
                                         REGS
                                         (V-INC (V-NTH1 (RN-B INS) REGS)))
                           REGS))
                   C V N Z MEM INS OPERAND-A
                   (IF (REG-DIRECT-P (MODE-B INS))
                       (V-NTH1 (RN-B INS) REGS)
                       (V-NTH1 (IF (PRE-DEC-P (MODE-B INS))
                                   (V-DEC (V-NTH1 (RN-B INS) REGS))
                                   (V-NTH1 (RN-B INS) REGS))
                               MEM))
                   (IF (PRE-DEC-P (MODE-B INS))
                       (V-DEC (V-NTH1 (RN-B INS) REGS))
                       (V-NTH1 (RN-B INS) REGS))))

(ENABLE LENGTH-V-NOT)

(PROVE-LEMMA LENGTH-V-ADDER (REWRITE)
  (EQUAL (LENGTH (V-ADDER C A B)) (ADD1 (LENGTH A))))

(ENABLE LENGTH-NAT-TO-V)

(PROVE-LEMMA LENGTH-V-DEC (REWRITE)
             (EQUAL (LENGTH (V-DEC V)) (LENGTH V)))

(PROVE-LEMMA M-OPERAND-B-IS-FM9001-OPERAND-B (REWRITE)
  (IMPLIES (AND (BVP-LISTP REGS)
                (EQUAL (LENGTH REGS) 16)
                (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
           (EQUAL (M->FM9001 (M-OPERAND-B REGS C V N Z MEM INS OPERAND-A))
                  (FM9001-OPERAND-B (RAM-TREE REGS 16)
                                    (LIST Z N V C)
                                    (RAM-TREE MEM (EXP 2 32))
                                    INS OPERAND-A)))
  ((DISABLE M->FM9001 PRE-DEC-P MODE-B RN-B V-DEC POST-INC-P V-INC REG-DIRECT-P)))

(PROVE-LEMMA LENGTH-V-INC (REWRITE)
  (EQUAL (LENGTH (V-INC V)) (LENGTH V)))
  
(PROVE-LEMMA BVP-FIRSTN-V-ADDER (REWRITE)
  (IMPLIES (EQUAL N (LENGTH A))
           (BVP (FIRSTN N (V-ADDER C A B)))))

(PROVE-LEMMA BVP-V-DEC (REWRITE)
  (BVP (V-DEC V)))

(PROVE-LEMMA BVP-V-INC (REWRITE)
  (BVP (V-INC V)))

(PROVE-LEMMA BVP-LISTP-IF (REWRITE)
  (IMPLIES (AND (BVP-LISTP B)
                (BVP-LISTP C))
           (BVP-LISTP (IF A B C))))

(enable LENGTH-IF)

(PROVE-LEMMA LISTP-OPERAND-A NIL
  (IMPLIES (EQUAL (LENGTH OPERAND-A) 32)
           (LISTP OPERAND-A)))

(PROVE-LEMMA M-OPERAND-B-PRESERVES-HYPS (REWRITE)
  (IMPLIES
   (AND (BVP-LISTP REGS)
        (BVP-LISTP MEM)
        (BVP OPERAND-A)
        (EQUAL (LENGTH OPERAND-A) 32)
        (EQUAL (LENGTH REGS) 16)
        (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
   (PROPER-M-STATEP (M-OPERAND-B REGS C V N Z MEM INS OPERAND-A)))
  ((USE (LISTP-OPERAND-A))
   (DISABLE M->FM9001 PRE-DEC-P MODE-B RN-B V-DEC POST-INC-P V-INC REG-DIRECT-P)))

(DISABLE M-OPERAND-B)
(DISABLE FM9001-OPERAND-B)

(DEFN M-OPERAND-A (REGS C V N Z MEM INS)
  (M-OPERAND-B
   (IF (A-IMMEDIATE-P INS)
       REGS
       (IF (PRE-DEC-P (MODE-A INS))
           (UPDATE-V-NTH (RN-A INS)
                         REGS
                         (V-DEC (V-NTH1 (RN-A INS) REGS)))
           (IF (POST-INC-P (MODE-A INS))
               (UPDATE-V-NTH (RN-A INS)
                             REGS
                             (V-INC (V-NTH1 (RN-A INS) REGS)))
               REGS)))
   C V N Z MEM INS
   (IF (A-IMMEDIATE-P INS)
       (SIGN-EXTEND (A-IMMEDIATE INS) 32)
       (IF (REG-DIRECT-P (MODE-A INS))
           (V-NTH1 (RN-A INS) REGS)
           (IF (PRE-DEC-P (MODE-A INS))
               (V-NTH1 (V-DEC (V-NTH1 (RN-A INS) REGS))
                       MEM)
               (V-NTH1 (V-NTH1 (RN-A INS) REGS)
                       MEM))))))

(PROVE-LEMMA LENGTH-RN-A (REWRITE)
  (EQUAL (LENGTH (RN-A INS)) 4)
  ((ENABLE LENGTH-SUBRANGE)))

(PROVE-LEMMA M-OPERAND-A-IS-FM9001-OPERAND-A (REWRITE)
  (IMPLIES
   (AND (BVP-LISTP REGS)
        (EQUAL (LENGTH REGS) 16)
        (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
   (EQUAL (M->FM9001 (M-OPERAND-A REGS C V N Z MEM INS))
          (FM9001-OPERAND-A (RAM-TREE REGS 16)
                            (LIST Z N V C)
                            (RAM-TREE MEM (EXP 2 32))
                            INS)))
  ((DISABLE M->FM9001 A-IMMEDIATE-P PRE-DEC-P MODE-A RN-A RN-B
            V-DEC POST-INC-P V-INC SIGN-EXTEND A-IMMEDIATE REG-DIRECT-P)))

(PROVE-LEMMA M-OPERAND-A-PRESERVES-HYPS (REWRITE)
  (IMPLIES
   (AND (BVP-LISTP REGS)
        (BVP-LISTP MEM)
        (EQUAL (LENGTH REGS) 16)
        (NOT (LESSP (EXP 2 32) (LENGTH MEM))))
   (PROPER-M-STATEP (M-OPERAND-A REGS C V N Z MEM INS)))
  ((ENABLE BVP-SIGN-EXTEND LENGTH-SIGN-EXTEND)
   (DISABLE M->FM9001 A-IMMEDIATE-P PRE-DEC-P MODE-A RN-A RN-B
            V-DEC POST-INC-P V-INC SIGN-EXTEND A-IMMEDIATE REG-DIRECT-P)))


(DISABLE M-OPERAND-A)
(DISABLE FM9001-OPERAND-A)

(DEFN M-STEP1 (CURRENT-INSTRUCTION M)
  (M-OPERAND-A (UPDATE-V-NTH (NAT-TO-V 15 4) (M-REGS M)
                             (V-INC (V-NTH1 (NAT-TO-V 15 4) (M-REGS M))))
               (M-C-FLG M)
               (M-V-FLG M)
               (M-N-FLG M)
               (M-Z-FLG M)
               (M-MEM M)
               CURRENT-INSTRUCTION))

(DEFN M-STEP (M)
  (M-STEP1 (CURRENT-INSTRUCTION (M-REGS M)
                                (M-MEM M))
           M))

(PROVE-LEMMA M-STEP-IS-FM9001-STEP (REWRITE)
  (IMPLIES
   (AND
    (BVP-LISTP (M-REGS M))
    (EQUAL (LENGTH (M-REGS M)) 16)
    (NOT (LESSP (EXP 2 32) (LENGTH (M-MEM M)))))
   (EQUAL (M->FM9001 (M-STEP M))
          (FM9001-STEP (M->FM9001 M) (NAT-TO-V 15 4))))
((EXPAND (M->FM9001 M))
 (DISABLE M->FM9001 V-INC V-DEC  RN-A RN-B)))

(PROVE-LEMMA M-STEP-PRESERVES-HYPS (REWRITE)
  (IMPLIES
   (AND
    (BVP-LISTP (M-REGS M))
    (BVP-LISTP (M-MEM M))
    (EQUAL (LENGTH (M-REGS M)) 16)
    (NOT (LESSP (EXP 2 32) (LENGTH (M-MEM M)))))
   (PROPER-M-STATEP (M-STEP M))))

(DISABLE M-STEP)
(DISABLE M->FM9001)
(DISABLE FM9001-STEP)

(DEFN M (M N)
  (IF (ZEROP N)
      M
      (M (M-STEP M) (SUB1 N))))

(PROVE-LEMMA ONE-WAY-CORRESPONDENCE-M-FM9001 (REWRITE)
  (IMPLIES (PROPER-M-STATEP M)
           (EQUAL (M->FM9001 (M M N))
                  (FM9001 (M->FM9001 M) N)))
  ((INDUCT (M M N))
   (DISABLE NAT-TO-V *1*NAT-TO-V)))

; Book:  i.events.  Now we move up to the i machine.

(set-status close-data-base-2 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

(DEFN PUT-ASSOC
      (VAL NAME ALIST)
      (COND ((NLISTP ALIST) ALIST)
            ((EQUAL NAME (CAAR ALIST))
             (CONS (CONS NAME VAL) (CDR ALIST)))
            (T (CONS (CAR ALIST)
                     (PUT-ASSOC VAL NAME (CDR ALIST))))))

(DEFN DEFINEDP
      (NAME ALIST)
      (COND ((NLISTP ALIST) F)
            ((EQUAL NAME (CAAR ALIST)) T)
            (T (DEFINEDP NAME (CDR ALIST)))))

; DEFINIENS, below, used to be named VALUE but that name is now used
; in FM9001.

(DEFN DEFINIENS
      (NAME ALIST)
      (CDR (DEFINITION NAME ALIST)))

(DEFN PUT-VALUE
      (VAL NAME ALIST)
      (PUT-ASSOC VAL NAME ALIST))

(DEFN ADPP
      (X SEGMENT)
      (AND (LISTP X)
           (NUMBERP (ADP-OFFSET X))
           (DEFINEDP (ADP-NAME X) SEGMENT)
           (LESSP (ADP-OFFSET X)
                  (LENGTH (definiens (ADP-NAME X) SEGMENT)))))

(DEFN ADD-ADP
      (ADP N)
      (CONS (ADP-NAME ADP)
            (PLUS (ADP-OFFSET ADP) N)))

(DEFN ADD1-ADP (ADP) (ADD-ADP ADP 1))

(DEFN SUB1-ADP (ADP) (SUB-ADP ADP 1))

(DEFN PUT
      (VAL N LST)
      (IF (ZEROP N)
          (IF (LISTP LST)
              (CONS VAL (CDR LST))
              (LIST VAL))
          (CONS (CAR LST)
                (PUT VAL (SUB1 N) (CDR LST)))))

(DEFN FETCH-ADP
      (ADP SEGMENT)
      (GET (ADP-OFFSET ADP)
           (definiens (ADP-NAME ADP) SEGMENT)))

(DEFN DEPOSIT-ADP
      (VAL ADP SEGMENT)
      (PUT-VALUE (PUT VAL
                      (ADP-OFFSET ADP)
                      (definiens (ADP-NAME ADP) SEGMENT))
                 (ADP-NAME ADP)
                 SEGMENT))

(DEFN ADDRESSP
      (X SEGMENT)
      (ADPP (UNTAG X) SEGMENT))

(DEFN OFFSET
      (X)
      (ADP-OFFSET (UNTAG X)))

(DEFN ADD-ADDR
      (ADDR N)
      (TAG (TYPE ADDR)
           (ADD-ADP (UNTAG ADDR) N)))

(DEFN ADD1-ADDR
      (ADDR)
      (ADD-ADDR ADDR 1))

(DEFN SUB1-ADDR
      (ADDR)
      (SUB-ADDR ADDR 1))

(DEFN FETCH
      (ADDR SEGMENT)
      (FETCH-ADP (UNTAG ADDR) SEGMENT))

(DEFN DEPOSIT
      (VAL ADDR SEGMENT)
      (DEPOSIT-ADP VAL
                   (UNTAG ADDR)
                   SEGMENT))

(DEFN BOOLEANP
      (X)
      (OR (EQUAL X 'T) (EQUAL X 'F)))

(DEFN BOOL
      (X)
      (TAG 'BOOL (IF X 'T 'F)))

(DEFN OR-BOOL
      (X Y)
      (IF (EQUAL X 'F) Y 'T))

(DEFN AND-BOOL
      (X Y)
      (IF (EQUAL X 'F) 'F Y))

(DEFN XOR-BOOL
      (X Y)
      (COND ((EQUAL X 'F) Y)
            ((EQUAL Y 'F) 'T)
            (T 'F)))

(DEFN SMALL-NATURALP
      (I WORD-SIZE)
      (AND (NUMBERP I)
           (LESSP I (EXP 2 WORD-SIZE))))

(DEFN BOOL-TO-NAT
      (FLG)
      (IF (EQUAL FLG 'F) 0 1))

(DEFN FIX-SMALL-NATURAL
      (N WORD-SIZE)
      (REMAINDER N (EXP 2 WORD-SIZE)))

(DEFN SMALL-INTEGERP
      (I WORD-SIZE)
      (AND (INTEGERP I)
           (NOT (ILESSP I
                        (MINUS (EXP 2 (SUB1 WORD-SIZE)))))
           (ILESSP I (EXP 2 (SUB1 WORD-SIZE)))))

(DEFN INEGATE
      (I)
      (COND ((NEGATIVEP I) (NEGATIVE-GUTS I))
            ((ZEROP I) 0)
            (T (MINUS I))))

(DEFN FIX-SMALL-INTEGER
      (I WORD-SIZE)
      (COND ((SMALL-INTEGERP I WORD-SIZE) I)
            ((NEGATIVEP I)
             (IPLUS I (EXP 2 WORD-SIZE)))
            (T (IPLUS I (MINUS (EXP 2 WORD-SIZE))))))

(DEFN BITP
      (X)
      (OR (EQUAL X 0) (EQUAL X 1)))

(DEFN BIT-VECTORP
      (X N)
      (IF (NLISTP X)
          (AND (EQUAL X NIL) (ZEROP N))
          (AND (NOT (ZEROP N))
               (BITP (CAR X))
               (BIT-VECTORP (CDR X) (SUB1 N)))))

(DEFN OR-BIT
      (BIT1 BIT2)
      (IF (EQUAL BIT1 0)
          (IF (EQUAL BIT2 0) 0 1)
          1))

(DEFN NOT-BIT
      (BIT)
      (IF (EQUAL BIT 0) 1 0))

(DEFN AND-BIT
      (BIT1 BIT2)
      (COND ((EQUAL BIT1 0) 0)
            ((EQUAL BIT2 0) 0)
            (T 1)))

(DEFN XOR-BIT
      (BIT1 BIT2)
      (COND ((EQUAL BIT1 0)
             (IF (EQUAL BIT2 0) 0 1))
            ((EQUAL BIT2 0) 1)
            (T 0)))

(DEFN OR-BITV
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (OR-BIT (CAR A) (CAR B))
                (OR-BITV (CDR A) (CDR B)))))

(DEFN NOT-BITV
      (A)
      (IF (NLISTP A)
          NIL
          (CONS (NOT-BIT (CAR A))
                (NOT-BITV (CDR A)))))

(DEFN AND-BITV
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (AND-BIT (CAR A) (CAR B))
                (AND-BITV (CDR A) (CDR B)))))

(DEFN XOR-BITV
      (A B)
      (IF (NLISTP A)
          NIL
          (CONS (XOR-BIT (CAR A) (CAR B))
                (XOR-BITV (CDR A) (CDR B)))))

(DEFN ALL-BUT-LAST
      (A)
      (COND ((NLISTP A) NIL)
            ((NLISTP (CDR A)) NIL)
            (T (CONS (CAR A)
                     (ALL-BUT-LAST (CDR A))))))

(DEFN RSH-BITV
      (A)
      (CONS 0 (ALL-BUT-LAST A)))

(DEFN LSH-BITV
      (A)
      (APPEND (CDR A) '(0)))

(DEFN ALL-ZERO-BITVP
      (A)
      (IF (LISTP A)
          (AND (EQUAL (CAR A) 0)
               (ALL-ZERO-BITVP (CDR A)))
          T))

(DEFN FIND-LABELP
      (X LST)
      (COND ((NLISTP LST) F)
            ((AND (LABELLEDP (CAR LST))
                  (EQUAL X (CADAR LST)))
             T)
            (T (FIND-LABELP X (CDR LST)))))

(DEFN X-Y-ERROR-MSG
      (X Y)
      (PACK (APPEND (UNPACK 'ILLEGAL-)
                    (APPEND (UNPACK Y)
                            (CDR (UNPACK 'G-INSTRUCTION))))))

(DEFN CSTKP
      (X SEGMENT)
      (AND (EQUAL (TYPE X) 'SYS-ADDR)
           (ADDRESSP X SEGMENT)
           (EQUAL (AREA-NAME X) 'CSTK)
           (EQUAL (CDDR X) NIL)))

(DEFN TSTKP
      (X SEGMENT)
      (AND (EQUAL (TYPE X) 'SYS-ADDR)
           (ADDRESSP X SEGMENT)
           (EQUAL (AREA-NAME X) 'TSTK)
           (EQUAL (CDDR X) NIL)))

(DEFN PUSH-STK
      (SYS-ADDR)
      (SUB1-ADDR SYS-ADDR))

(DEFN POP-STK
      (SYS-ADDR)
      (ADD1-ADDR SYS-ADDR))

(DEFN STK-LENGTH
      (ADDR SEGMENT)
      (SUB1 (DIFFERENCE (LENGTH (definiens (AREA-NAME ADDR) SEGMENT))
                        (OFFSET ADDR))))

(DEFN EMPTY-STKP
      (ADDR SEGMENT)
      (ZEROP (STK-LENGTH ADDR SEGMENT)))

(DEFN FREE-STK-SIZE
      (ADDR)
      (OFFSET ADDR))

(DEFN ICODE-LABELP
      (LAB SEGMENT)
      (AND (DEFINEDP (ADP-NAME LAB) SEGMENT)
           (FIND-LABELP LAB
                        (definiens (ADP-NAME LAB) SEGMENT))))

(DEFN I-OBJECTP
      (X I)
      (AND (LISTP X)
           (EQUAL (CDDR X) NIL)
           (CASE (TYPE X)
                 (NAT (SMALL-NATURALP (UNTAG X)
                                      (I-WORD-SIZE I)))
                 (INT (SMALL-INTEGERP (UNTAG X)
                                      (I-WORD-SIZE I)))
                 (BITV (BIT-VECTORP (UNTAG X)
                                    (I-WORD-SIZE I)))
                 (BOOL (BOOLEANP (UNTAG X)))
                 (ADDR (ADPP (UNTAG X)
                             (I-USR-DATA-SEGMENT I)))
                 (PC (ICODE-LABELP (UNTAG X)
                                   (I-PROG-SEGMENT I)))
                 (SUBR (ADPP (CONS (UNTAG X) 0)
                             (I-PROG-SEGMENT I)))
                 (SYS-ADDR (ADPP (UNTAG X)
                                 (I-SYS-DATA-SEGMENT I)))
                 (IPC (ADPP (UNTAG X) (I-PROG-SEGMENT I)))
                 (OTHERWISE F))))

(DEFN I-OBJECTP-TYPE
      (TYPE X I)
      (AND (EQUAL TYPE (TYPE X))
           (I-OBJECTP X I)))

(DEFN I-USR-DATA-TYPEP
      (TYPE)
      (MEMBER TYPE
              '(NAT INT BITV BOOL ADDR SUBR PC)))

(DEFN I-USR-DATA-OBJECTP
      (X I)
      (AND (I-OBJECTP X I)
           (I-USR-DATA-TYPEP (TYPE X))))

(DEFN TOTAL-I-SYSTEM-SIZE
      (I load-addr)
      (PLUS load-addr
            (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I))
            (SEGMENT-LENGTH (I-PROG-SEGMENT I))
            (SEGMENT-LENGTH (I-SYS-DATA-SEGMENT I))))

(DEFN I-LOADABLEP
      (I load-addr)
      (LESSP (TOTAL-I-SYSTEM-SIZE I load-addr)
             (EXP 2 (I-WORD-SIZE I))))

(DEFN I-STATE-OKP
      (I load-addr)
      (AND (I-STATEP I)
           (I-OBJECTP-TYPE 'IPC (I-PC I) I)
           (CSTKP (I-CFP I)
                  (I-SYS-DATA-SEGMENT I))
           (CSTKP (I-CSP I)
                  (I-SYS-DATA-SEGMENT I))
           (TSTKP (I-TSP I)
                  (I-SYS-DATA-SEGMENT I))
           (I-OBJECTP-TYPE 'BOOL (I-C-FLG I) I)
           (I-OBJECTP-TYPE 'BOOL (I-V-FLG I) I)
           (I-OBJECTP-TYPE 'BOOL (I-N-FLG I) I)
           (I-OBJECTP-TYPE 'BOOL (I-Z-FLG I) I)
           (I-LOADABLEP I load-addr)))

(DEFN ALL-I-USR-DATA-OBJECTPS
      (LST I)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (I-USR-DATA-OBJECTP (CAR LST) I)
               (ALL-I-USR-DATA-OBJECTPS (CDR LST)
                                        I))))

(DEFN PROPER-I-USR-DATA-AREA
      (AREA I)
      (AND (LITATOM (CAR AREA))
           (LISTP (CDR AREA))
           (ALL-I-USR-DATA-OBJECTPS (CDR AREA)
                                    I)))

(DEFN PROPER-I-USR-DATA-SEGMENTP
      (DATA-SEGMENT I)
      (IF (NLISTP DATA-SEGMENT)
          (EQUAL DATA-SEGMENT NIL)
          (AND (PROPER-I-USR-DATA-AREA (CAR DATA-SEGMENT)
                                       I)
               (NOT (DEFINEDP (CAAR DATA-SEGMENT)
                              (CDR DATA-SEGMENT)))
               (PROPER-I-USR-DATA-SEGMENTP (CDR DATA-SEGMENT)
                                           I))))

(DEFN ADD1-I-PC
      (I)
      (ADD1-ADDR (I-PC I)))

(DEFN ADD1-I-PCP
      (I)
      (ADDRESSP (ADD1-I-PC I)
                (I-PROG-SEGMENT I)))

(DEFN ADD2-I-PC
      (I)
      (ADD1-ADDR (ADD1-ADDR (I-PC I))))

(DEFN ADD2-I-PCP
      (I)
      (ADDRESSP (ADD2-I-PC I)
                (I-PROG-SEGMENT I)))

(DEFN I-CURRENT-INSTRUCTION
      (I)
      (UNLABEL (FETCH (I-PC I) (I-PROG-SEGMENT I))))

(DEFN I-NEXTWORD
      (I)
      (UNLABEL (FETCH (ADD1-I-PC I)
                      (I-PROG-SEGMENT I))))

(DEFN IPC
      (LAB PROGRAM)
      (TAG 'IPC
           (CONS (NAME PROGRAM)
                 (FIND-LABEL LAB (CDR PROGRAM)))))

(DEFN I-HALT
      (I PSW)
      (I-STATE (I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               PSW))

(DEFN XOR-XXX (OBJ1 OBJ2 I LOAD-ADDR)
      (XOR-BITV (V-TO-BITV (LINK-DATA-WORD OBJ1
                                            (I-LINK-TABLES I LOAD-ADDR)
                                            (I-WORD-SIZE I)))
                (V-TO-BITV (LINK-DATA-WORD OBJ2
                                            (I-LINK-TABLES I LOAD-ADDR)
                                            (I-WORD-SIZE I)))))

(DEFN I-ADD_<C>_X_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)))

(DEFN I-ADD_<C>_X_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (TAG 'NAT
                    (FIX-SMALL-NATURAL (TIMES 2 (UNTAG (I-X I)))
                                       (I-WORD-SIZE I)))
               (I-Y I)
               (BOOL (NOT (SMALL-NATURALP (TIMES 2 (UNTAG (I-X I)))
                                          (I-WORD-SIZE I))))
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_<TSP>_<TSP>{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-ADD_<TSP>_<TSP>{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (LSH-BITV (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_<TSP>_<TSP>{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-NATURALP (TIMES 2
                                  (UNTAG (FETCH (I-TSP I)
                                                (I-SYS-DATA-SEGMENT I))))
                           (I-WORD-SIZE I))))

(DEFN I-ADD_<TSP>_<TSP>{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (TIMES 2
                                    (UNTAG (FETCH (I-TSP I)
                                                  (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_<TSP>{A}_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'ADDR
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (I-OBJECTP-TYPE 'ADDR
                           (ADD-ADDR (FETCH (I-TSP I)
                                            (I-SYS-DATA-SEGMENT I))
                                     (UNTAG (I-X I)))
                           I)))

(DEFN I-ADD_<TSP>{A}_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (ADD-ADDR (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I))
                                  (UNTAG (I-X I)))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_TSP_*{N}-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP-TYPE 'NAT
                           (I-NEXTWORD I)
                           I)
           (ADDRESSP (ADD-ADDR (I-TSP I)
                               (UNTAG (I-NEXTWORD I)))
                     (I-SYS-DATA-SEGMENT I))))

(DEFN I-ADD_TSP_*{N}-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (ADD-ADDR (I-TSP I)
                         (UNTAG (I-NEXTWORD I)))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_TSP_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (ADDRESSP (ADD-ADDR (I-TSP I) (UNTAG (I-X I)))
                     (I-SYS-DATA-SEGMENT I))))

(DEFN I-ADD_TSP_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (ADD-ADDR (I-TSP I) (UNTAG (I-X I)))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_<TSP>{I}_X{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT (I-X I) I)
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-INTEGERP (IPLUS (UNTAG (FETCH (I-TSP I)
                                                (I-SYS-DATA-SEGMENT I)))
                                  (UNTAG (I-X I)))
                           (I-WORD-SIZE I))))

(DEFN I-ADD_<TSP>{I}_X{I}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'INT
                             (IPLUS (UNTAG (FETCH (I-TSP I)
                                                  (I-SYS-DATA-SEGMENT I)))
                                    (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_<TSP>{N}_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-NATURALP (PLUS (UNTAG (FETCH (I-TSP I)
                                               (I-SYS-DATA-SEGMENT I)))
                                 (UNTAG (I-X I)))
                           (I-WORD-SIZE I))))

(DEFN I-ADD_<TSP>{N}_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (PLUS (UNTAG (FETCH (I-TSP I)
                                                 (I-SYS-DATA-SEGMENT I)))
                                   (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_PC_X{N}-OKP
      (I)
      (AND (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (ADDRESSP (ADD-ADDR (I-PC I)
                               (ADD1 (UNTAG (I-X I))))
                     (I-PROG-SEGMENT I))))

(DEFN I-ADD_PC_X{N}-STEP
      (I)
      (I-STATE (ADD-ADDR (I-PC I)
                         (ADD1 (UNTAG (I-X I))))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_X_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (SMALL-NATURALP (TIMES 2 (UNTAG (I-X I)))
                           (I-WORD-SIZE I))))

(DEFN I-ADD_X_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (TAG 'NAT (TIMES 2 (UNTAG (I-X I))))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADD_X{N}_CSP-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (ADDRESSP (ADD-ADDR (I-CSP I) (UNTAG (I-X I)))
                     (I-SYS-DATA-SEGMENT I))))

(DEFN I-ADD_X{N}_CSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (ADD-ADDR (I-CSP I) (UNTAG (I-X I)))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ADDC_<C>_X{N}_Y{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'NAT (I-Y I) I)))

(DEFN I-ADDC_<C>_X{N}_Y{N}-STEP
    (I)
    (I-STATE (ADD1-I-PC I)
             (I-CFP I)
             (I-CSP I)
             (I-TSP I)
             (TAG 'NAT
                  (FIX-SMALL-NATURAL (PLUS (BOOL-TO-NAT (UNTAG (I-C-FLG I)))
                                           (UNTAG (I-Y I))
                                           (UNTAG (I-X I)))
                                     (I-WORD-SIZE I)))
             (I-Y I)
             (BOOL (NOT (SMALL-NATURALP (PLUS (BOOL-TO-NAT (UNTAG (I-C-FLG I)))
                                              (UNTAG (I-Y I))
                                              (UNTAG (I-X I)))
                                        (I-WORD-SIZE I))))
             (I-V-FLG I)
             (I-N-FLG I)
             (I-Z-FLG I)
             (I-PROG-SEGMENT I)
             (I-USR-DATA-SEGMENT I)
             (I-SYS-DATA-SEGMENT I)
             (I-WORD-SIZE I)
             'RUN))

(DEFN I-ADDC_<V>_X{I}_Y{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'INT (I-X I) I)
           (I-OBJECTP-TYPE 'INT (I-Y I) I)))

(DEFN I-ADDC_<V>_X{I}_Y{I}-STEP
   (I)
   (I-STATE (ADD1-I-PC I)
            (I-CFP I)
            (I-CSP I)
            (I-TSP I)
            (TAG 'INT
                 (FIX-SMALL-INTEGER (IPLUS (BOOL-TO-NAT (UNTAG (I-C-FLG I)))
                                           (IPLUS (UNTAG (I-Y I))
                                                  (UNTAG (I-X I))))
                                    (I-WORD-SIZE I)))
            (I-Y I)
            (I-C-FLG I)
            (BOOL (NOT (SMALL-INTEGERP (IPLUS (BOOL-TO-NAT (UNTAG (I-C-FLG I)))
                                              (IPLUS (UNTAG (I-Y I))
                                                     (UNTAG (I-X I))))
                                       (I-WORD-SIZE I))))
            (I-N-FLG I)
            (I-Z-FLG I)
            (I-PROG-SEGMENT I)
            (I-USR-DATA-SEGMENT I)
            (I-SYS-DATA-SEGMENT I)
            (I-WORD-SIZE I)
            'RUN))

(DEFN I-AND_<TSP>{V}_X{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV (I-X I) I)
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-AND_<TSP>{V}_X{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (AND-BITV (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))
                                       (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-AND_<TSP>{B}_X{B}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL (I-X I) I)
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-AND_<TSP>{B}_X{B}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL
                             (AND-BOOL (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))
                                       (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-ASR_<C>_<TSP>_<TSP>{B}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-ASR_<C>_<TSP>_<TSP>{B}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL 'F)
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-CPOP_CFP-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-CSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (CSTKP (FETCH (I-CSP I)
                         (I-SYS-DATA-SEGMENT I))
                  (I-SYS-DATA-SEGMENT I))))

(DEFN I-CPOP_CFP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (FETCH (I-CSP I)
                      (I-SYS-DATA-SEGMENT I))
               (POP-STK (I-CSP I))
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-CPOP_PC-OKP
      (I)
      (AND (NOT (EMPTY-STKP (I-CSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'PC
                           (FETCH (I-CSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-CPOP_PC-STEP
      (I)
      (I-STATE (IPC (UNTAG (FETCH (I-CSP I)
                                  (I-SYS-DATA-SEGMENT I)))
                    (DEFINITION (AREA-NAME (FETCH (I-CSP I)
                                                  (I-SYS-DATA-SEGMENT I)))
                                (I-PROG-SEGMENT I)))
               (I-CFP I)
               (POP-STK (I-CSP I))
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-CPUSH_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (ZEROP (FREE-STK-SIZE (I-CSP I))))))

(DEFN I-CPUSH_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (PUSH-STK (I-CSP I))
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-NEXTWORD I)
                        (PUSH-STK (I-CSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-CPUSH_<TSP>+-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (NOT (ZEROP (FREE-STK-SIZE (I-CSP I))))))

(DEFN I-CPUSH_<TSP>+-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (PUSH-STK (I-CSP I))
               (POP-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (PUSH-STK (I-CSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-CPUSH_CFP-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-CSP I))))))

(DEFN I-CPUSH_CFP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (PUSH-STK (I-CSP I))
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-CFP I)
                        (PUSH-STK (I-CSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-DECR_<TSP>_<TSP>{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                      (I-SYS-DATA-SEGMENT I)))
                                        1)
                           (I-WORD-SIZE I))))

(DEFN I-DECR_<TSP>_<TSP>{I}-STEP
     (I)
     (I-STATE (ADD1-I-PC I)
              (I-CFP I)
              (I-CSP I)
              (I-TSP I)
              (I-X I)
              (I-Y I)
              (I-C-FLG I)
              (I-V-FLG I)
              (I-N-FLG I)
              (I-Z-FLG I)
              (I-PROG-SEGMENT I)
              (I-USR-DATA-SEGMENT I)
              (DEPOSIT (TAG 'INT
                            (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         1))
                       (I-TSP I)
                       (I-SYS-DATA-SEGMENT I))
              (I-WORD-SIZE I)
              'RUN))

(DEFN I-DECR_<TSP>_<TSP>{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (NOT (ZEROP (UNTAG (FETCH (I-TSP I)
                                     (I-SYS-DATA-SEGMENT I)))))))

(DEFN I-DECR_<TSP>_<TSP>{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (SUB1 (UNTAG (FETCH (I-TSP I)
                                                 (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-INCR_<TSP>_<TSP>{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-INTEGERP (IPLUS (UNTAG (FETCH (I-TSP I)
                                                (I-SYS-DATA-SEGMENT I)))
                                  1)
                           (I-WORD-SIZE I))))

(DEFN I-INCR_<TSP>_<TSP>{I}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'INT
                             (IPLUS (UNTAG (FETCH (I-TSP I)
                                                  (I-SYS-DATA-SEGMENT I)))
                                    1))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-INCR_<TSP>_<TSP>{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-NATURALP (ADD1 (UNTAG (FETCH (I-TSP I)
                                               (I-SYS-DATA-SEGMENT I))))
                           (I-WORD-SIZE I))))

(DEFN I-INCR_<TSP>_<TSP>{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (ADD1 (UNTAG (FETCH (I-TSP I)
                                                 (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-INCR_Y_Y{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-Y I) I)
           (SMALL-NATURALP (ADD1 (UNTAG (I-Y I)))
                           (I-WORD-SIZE I))))

(DEFN I-INCR_Y_Y{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (TAG 'NAT (ADD1 (UNTAG (I-Y I))))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-INT-TO-NAT-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (NOT (NEGATIVEP (UNTAG (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I)))))))

(DEFN I-INT-TO-NAT-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (UNTAG (FETCH (I-TSP I)
                                           (I-SYS-DATA-SEGMENT I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP-N_X-OKP
      (I)
      (IF (EQUAL (UNTAG (I-N-FLG I)) 'F)
          (ADD1-I-PCP I)
          (I-OBJECTP-TYPE 'PC (I-X I) I)))

(DEFN I-JUMP-N_X-STEP
      (I)
      (I-STATE (IF (EQUAL (UNTAG (I-N-FLG I)) 'F)
                   (ADD1-I-PC I)
                   (IPC (UNTAG (I-X I))
                        (DEFINITION (AREA-NAME (I-X I))
                                    (I-PROG-SEGMENT I))))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP-NN_X-OKP
      (I)
      (IF (EQUAL (UNTAG (I-N-FLG I)) 'F)
          (I-OBJECTP-TYPE 'PC (I-X I) I)
          (ADD1-I-PCP I)))

(DEFN I-JUMP-NN_X-STEP
      (I)
      (I-STATE (IF (EQUAL (UNTAG (I-N-FLG I)) 'F)
                   (IPC (UNTAG (I-X I))
                        (DEFINITION (AREA-NAME (I-X I))
                                    (I-PROG-SEGMENT I)))
                   (ADD1-I-PC I))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP-NZ_X-OKP
      (I)
      (IF (EQUAL (UNTAG (I-Z-FLG I)) 'F)
          (I-OBJECTP-TYPE 'PC (I-X I) I)
          (ADD1-I-PCP I)))

(DEFN I-JUMP-NZ_X-STEP
      (I)
      (I-STATE (IF (EQUAL (UNTAG (I-Z-FLG I)) 'F)
                   (IPC (UNTAG (I-X I))
                        (DEFINITION (AREA-NAME (I-X I))
                                    (I-PROG-SEGMENT I)))
                   (ADD1-I-PC I))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP-Z_X-OKP
      (I)
      (IF (EQUAL (UNTAG (I-Z-FLG I)) 'F)
          (ADD1-I-PCP I)
          (I-OBJECTP-TYPE 'PC (I-X I) I)))

(DEFN I-JUMP-Z_X-STEP
      (I)
      (I-STATE (IF (EQUAL (UNTAG (I-Z-FLG I)) 'F)
                   (ADD1-I-PC I)
                   (IPC (UNTAG (I-X I))
                        (DEFINITION (AREA-NAME (I-X I))
                                    (I-PROG-SEGMENT I))))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP_*-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'PC
                           (I-NEXTWORD I)
                           I)))

(DEFN I-JUMP_*-STEP
      (I)
      (I-STATE (IPC (UNTAG (I-NEXTWORD I))
                    (DEFINITION (AREA-NAME (I-NEXTWORD I))
                                (I-PROG-SEGMENT I)))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-JUMP_X{SUBR}-OKP
      (I)
      (I-OBJECTP-TYPE 'SUBR (I-X I) I))

(DEFN I-JUMP_X{SUBR}-STEP
      (I)
      (I-STATE (TAG 'IPC (CONS (UNTAG (I-X I)) 0))
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-LSR_<C>_X_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)))

(DEFN I-LSR_<C>_X_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (TAG 'NAT
                    (QUOTIENT (UNTAG (I-X I)) 2))
               (I-Y I)
               (BOOL (EQUAL (REMAINDER (UNTAG (I-X I)) 2)
                            1))
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-LSR_<TSP>_<TSP>{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-LSR_<TSP>_<TSP>{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (RSH-BITV (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE-C_<TSP>_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))))

(DEFN I-MOVE-C_<TSP>_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (IF (EQUAL (UNTAG (I-C-FLG I)) 'F)
                   (I-SYS-DATA-SEGMENT I)
                   (DEPOSIT (I-NEXTWORD I)
                            (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE-V_<TSP>_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))))

(DEFN I-MOVE-V_<TSP>_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (IF (EQUAL (UNTAG (I-V-FLG I)) 'F)
                   (I-SYS-DATA-SEGMENT I)
                   (DEPOSIT (I-NEXTWORD I)
                            (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE-Z_<TSP>_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))))

(DEFN I-MOVE-Z_<TSP>_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (IF (EQUAL (UNTAG (I-Z-FLG I)) 'F)
                   (I-SYS-DATA-SEGMENT I)
                   (DEPOSIT (I-NEXTWORD I)
                            (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE-N_X_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)))

(DEFN I-MOVE-N_X_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (IF (EQUAL (UNTAG (I-N-FLG I)) 'F)
                   (I-X I)
                   (I-NEXTWORD I))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_<TSP>_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))))

(DEFN I-MOVE_<TSP>_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-NEXTWORD I)
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_<X{A}>_<TSP>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'ADDR (I-X I) I)))

(DEFN I-MOVE_<X{A}>_<TSP>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (DEPOSIT (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (I-X I)
                        (I-USR-DATA-SEGMENT I))
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_<X{S}>_<TSP>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'SYS-ADDR
                           (I-X I)
                           I)))

(DEFN I-MOVE_<X{S}>_<TSP>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (I-X I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_CFP_CSP-OKP
      (I)
      (ADD1-I-PCP I))

(DEFN I-MOVE_CFP_CSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CSP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_CSP_CFP-OKP
      (I)
      (ADD1-I-PCP I))

(DEFN I-MOVE_CSP_CFP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CFP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_X_*-OKP
      (I)
      (ADD2-I-PCP I))

(DEFN I-MOVE_X_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-NEXTWORD I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_X_<X{S}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'SYS-ADDR (I-X I) I)
           (I-OBJECTP (FETCH (I-X I) (I-SYS-DATA-SEGMENT I))
                      I)))

(DEFN I-MOVE_X_<X{S}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (FETCH (I-X I) (I-SYS-DATA-SEGMENT I))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_X_TSP-OKP
      (I)
      (ADD1-I-PCP I))

(DEFN I-MOVE_X_TSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-TSP I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_X_X-OKP
      (I)
      (ADD1-I-PCP I))

(DEFN I-MOVE_X_X-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_Y_*-OKP
      (I)
      (ADD2-I-PCP I))

(DEFN I-MOVE_Y_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-NEXTWORD I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_Y_<Y{S}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'SYS-ADDR (I-Y I) I)
           (I-OBJECTP (FETCH (I-Y I) (I-SYS-DATA-SEGMENT I))
                      I)))

(DEFN I-MOVE_Y_<Y{S}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (FETCH (I-Y I) (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-MOVE_Y_TSP-OKP
      (I)
      (ADD1-I-PCP I))

(DEFN I-MOVE_Y_TSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-TSP I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-NEG_<TSP>_<TSP>{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-INTEGERP (INEGATE (UNTAG (FETCH (I-TSP I)
                                                  (I-SYS-DATA-SEGMENT I))))
                           (I-WORD-SIZE I))))

(DEFN I-NEG_<TSP>_<TSP>{I}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'INT
                             (INEGATE (UNTAG (FETCH (I-TSP I)
                                                    (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-NOT_<TSP>_<TSP>{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-NOT_<TSP>_<TSP>{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (NOT-BITV (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-OR_<TSP>{V}_X{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV (I-X I) I)
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-OR_<TSP>{V}_X{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (OR-BITV (UNTAG (FETCH (I-TSP I)
                                                    (I-SYS-DATA-SEGMENT I)))
                                      (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-OR_<TSP>{B}_X{B}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL (I-X I) I)
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-OR_<TSP>{B}_X{B}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL
                             (OR-BOOL (UNTAG (FETCH (I-TSP I)
                                                    (I-SYS-DATA-SEGMENT I)))
                                      (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-SUB_<C>_<TSP>{A}_X{A}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'ADDR (I-X I) I)
           (I-OBJECTP-TYPE 'ADDR
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (EQUAL (AREA-NAME (FETCH (I-TSP I)
                                    (I-SYS-DATA-SEGMENT I)))
                  (AREA-NAME (I-X I)))))

(DEFN I-SUB_<C>_<TSP>{A}_X{A}-STEP
 (I)
 (I-STATE
  (ADD1-I-PC I)
  (I-CFP I)
  (I-CSP I)
  (I-TSP I)
  (I-X I)
  (I-Y I)
  (BOOL (LESSP (OFFSET (FETCH (I-TSP I)
                              (I-SYS-DATA-SEGMENT I)))
               (OFFSET (I-X I))))
  (I-V-FLG I)
  (I-N-FLG I)
  (I-Z-FLG I)
  (I-PROG-SEGMENT I)
  (I-USR-DATA-SEGMENT I)
  (DEPOSIT
     (TAG 'NAT
          (IF (LESSP (OFFSET (FETCH (I-TSP I)
                                    (I-SYS-DATA-SEGMENT I)))
                     (OFFSET (I-X I)))
              (DIFFERENCE (EXP 2 (I-WORD-SIZE I))
                          (DIFFERENCE (OFFSET (I-X I))
                                      (OFFSET (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))))
              (DIFFERENCE (OFFSET (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I)))
                          (OFFSET (I-X I)))))
     (I-TSP I)
     (I-SYS-DATA-SEGMENT I))
  (I-WORD-SIZE I)
  'RUN))

(DEFN I-SUB_<C>_<TSP>{N}_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-SUB_<C>_<TSP>{N}_X{N}-STEP
 (I)
 (I-STATE
  (ADD1-I-PC I)
  (I-CFP I)
  (I-CSP I)
  (I-TSP I)
  (I-X I)
  (I-Y I)
  (BOOL (LESSP (UNTAG (FETCH (I-TSP I)
                             (I-SYS-DATA-SEGMENT I)))
               (UNTAG (I-X I))))
  (I-V-FLG I)
  (I-N-FLG I)
  (I-Z-FLG I)
  (I-PROG-SEGMENT I)
  (I-USR-DATA-SEGMENT I)
  (DEPOSIT
      (TAG 'NAT
           (IF (LESSP (UNTAG (FETCH (I-TSP I)
                                    (I-SYS-DATA-SEGMENT I)))
                      (UNTAG (I-X I)))
               (DIFFERENCE (EXP 2 (I-WORD-SIZE I))
                           (DIFFERENCE (UNTAG (I-X I))
                                       (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))))
               (DIFFERENCE (UNTAG (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I)))
                           (UNTAG (I-X I)))))
      (I-TSP I)
      (I-SYS-DATA-SEGMENT I))
  (I-WORD-SIZE I)
  'RUN))

(DEFN I-SUB_<NV>_<TSP>{I}_X{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (I-OBJECTP-TYPE 'INT (I-X I) I)))

(DEFN I-SUB_<NV>_<TSP>{I}_X{I}-STEP
 (I)
 (I-STATE
  (ADD1-I-PC I)
  (I-CFP I)
  (I-CSP I)
  (I-TSP I)
  (I-X I)
  (I-Y I)
  (I-C-FLG I)
  (BOOL
       (NOT (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         (UNTAG (I-X I)))
                            (I-WORD-SIZE I))))
  (BOOL
   (NEGATIVEP
         (FIX-SMALL-INTEGER (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         (UNTAG (I-X I)))
                            (I-WORD-SIZE I))))
  (I-Z-FLG I)
  (I-PROG-SEGMENT I)
  (I-USR-DATA-SEGMENT I)
  (DEPOSIT
    (TAG 'INT
         (FIX-SMALL-INTEGER (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         (UNTAG (I-X I)))
                            (I-WORD-SIZE I)))
    (I-TSP I)
    (I-SYS-DATA-SEGMENT I))
  (I-WORD-SIZE I)
  'RUN))

(DEFN I-SUB_<TSP>{A}_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'ADDR
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (NOT (LESSP (OFFSET (FETCH (I-TSP I)
                                      (I-SYS-DATA-SEGMENT I)))
                       (UNTAG (I-X I))))))

(DEFN I-SUB_<TSP>{A}_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (SUB-ADDR (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I))
                                  (UNTAG (I-X I)))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-SUB_X{S}_Y{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'SYS-ADDR (I-X I) I)
           (I-OBJECTP-TYPE 'NAT (I-Y I) I)
           (NOT (LESSP (OFFSET (I-X I))
                       (UNTAG (I-Y I))))))

(DEFN I-SUB_X{S}_Y{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (SUB-ADDR (I-X I) (UNTAG (I-Y I)))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-SUB_<TSP>{I}_X{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT (I-X I) I)
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                      (I-SYS-DATA-SEGMENT I)))
                                        (UNTAG (I-X I)))
                           (I-WORD-SIZE I))))

(DEFN I-SUB_<TSP>{I}_X{I}-STEP
     (I)
     (I-STATE (ADD1-I-PC I)
              (I-CFP I)
              (I-CSP I)
              (I-TSP I)
              (I-X I)
              (I-Y I)
              (I-C-FLG I)
              (I-V-FLG I)
              (I-N-FLG I)
              (I-Z-FLG I)
              (I-PROG-SEGMENT I)
              (I-USR-DATA-SEGMENT I)
              (DEPOSIT (TAG 'INT
                            (IDIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         (UNTAG (I-X I))))
                       (I-TSP I)
                       (I-SYS-DATA-SEGMENT I))
              (I-WORD-SIZE I)
              'RUN))

(DEFN I-SUB_<TSP>{N}_X{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (NOT (LESSP (UNTAG (FETCH (I-TSP I)
                                     (I-SYS-DATA-SEGMENT I)))
                       (UNTAG (I-X I))))))

(DEFN I-SUB_<TSP>{N}_X{N}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'NAT
                             (DIFFERENCE (UNTAG (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                         (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-SUB_<TSP>{S}_X{S}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'SYS-ADDR (I-X I) I)
           (I-OBJECTP-TYPE 'SYS-ADDR
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (EQUAL (AREA-NAME (FETCH (I-TSP I)
                                    (I-SYS-DATA-SEGMENT I)))
                  (AREA-NAME (I-X I)))
           (NOT (LESSP (OFFSET (FETCH (I-TSP I)
                                      (I-SYS-DATA-SEGMENT I)))
                       (OFFSET (I-X I))))))

(DEFN I-SUB_<TSP>{S}_X{S}-STEP
     (I)
     (I-STATE (ADD1-I-PC I)
              (I-CFP I)
              (I-CSP I)
              (I-TSP I)
              (I-X I)
              (I-Y I)
              (I-C-FLG I)
              (I-V-FLG I)
              (I-N-FLG I)
              (I-Z-FLG I)
              (I-PROG-SEGMENT I)
              (I-USR-DATA-SEGMENT I)
              (DEPOSIT (TAG 'NAT
                            (DIFFERENCE (OFFSET (FETCH (I-TSP I)
                                                       (I-SYS-DATA-SEGMENT I)))
                                        (OFFSET (I-X I))))
                       (I-TSP I)
                       (I-SYS-DATA-SEGMENT I))
              (I-WORD-SIZE I)
              'RUN))

(DEFN I-SUB_<Z>_X{S}_Y{S}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'SYS-ADDR (I-X I) I)
           (I-OBJECTP-TYPE 'SYS-ADDR (I-Y I) I)
           (EQUAL (AREA-NAME (I-Y I))
                  (AREA-NAME (I-X I)))
           (NOT (LESSP (OFFSET (I-X I))
                       (OFFSET (I-Y I))))))

(DEFN I-SUB_<Z>_X{S}_Y{S}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (TAG 'NAT
                    (DIFFERENCE (OFFSET (I-X I))
                                (OFFSET (I-Y I))))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (BOOL (EQUAL (OFFSET (I-X I))
                            (OFFSET (I-Y I))))
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-SUBB_<C>_X{N}_Y{N}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'NAT (I-X I) I)
           (I-OBJECTP-TYPE 'NAT (I-Y I) I)))

(DEFN I-SUBB_<C>_X{N}_Y{N}-STEP
 (I)
 (I-STATE
      (ADD1-I-PC I)
      (I-CFP I)
      (I-CSP I)
      (I-TSP I)
      (TAG 'NAT
           (IF (LESSP (UNTAG (I-X I))
                      (PLUS (UNTAG (I-Y I))
                            (BOOL-TO-NAT (UNTAG (I-C-FLG I)))))
               (DIFFERENCE (EXP 2 (I-WORD-SIZE I))
                           (DIFFERENCE (PLUS (UNTAG (I-Y I))
                                             (BOOL-TO-NAT (UNTAG (I-C-FLG I))))
                                       (UNTAG (I-X I))))
               (DIFFERENCE (UNTAG (I-X I))
                           (PLUS (UNTAG (I-Y I))
                                 (BOOL-TO-NAT (UNTAG (I-C-FLG I)))))))
      (I-Y I)
      (BOOL (LESSP (UNTAG (I-X I))
                   (PLUS (UNTAG (I-Y I))
                         (BOOL-TO-NAT (UNTAG (I-C-FLG I))))))
      (I-V-FLG I)
      (I-N-FLG I)
      (I-Z-FLG I)
      (I-PROG-SEGMENT I)
      (I-USR-DATA-SEGMENT I)
      (I-SYS-DATA-SEGMENT I)
      (I-WORD-SIZE I)
      'RUN))

(DEFN I-SUBB_<V>_X{I}_Y{I}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (I-OBJECTP-TYPE 'INT (I-X I) I)
           (I-OBJECTP-TYPE 'INT (I-Y I) I)))

(DEFN I-SUBB_<V>_X{I}_Y{I}-STEP
 (I)
 (I-STATE
  (ADD1-I-PC I)
  (I-CFP I)
  (I-CSP I)
  (I-TSP I)
  (TAG 'INT
     (FIX-SMALL-INTEGER (IDIFFERENCE (UNTAG (I-X I))
                                     (IPLUS (UNTAG (I-Y I))
                                            (BOOL-TO-NAT (UNTAG (I-C-FLG I)))))
                        (I-WORD-SIZE I)))
  (I-Y I)
  (I-C-FLG I)
  (BOOL
   (NOT (SMALL-INTEGERP (IDIFFERENCE (UNTAG (I-X I))
                                     (IPLUS (UNTAG (I-Y I))
                                            (BOOL-TO-NAT (UNTAG (I-C-FLG I)))))
                        (I-WORD-SIZE I))))
  (I-N-FLG I)
  (I-Z-FLG I)
  (I-PROG-SEGMENT I)
  (I-USR-DATA-SEGMENT I)
  (I-SYS-DATA-SEGMENT I)
  (I-WORD-SIZE I)
  'RUN))

(DEFN I-TPOP_<C>_X-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP (FETCH (I-TSP I)
                             (I-SYS-DATA-SEGMENT I))
                      I)))

(DEFN I-TPOP_<C>_X-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-Y I)
               (TAG 'BOOL 'F)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP_<X{A}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'ADDR (I-X I) I)))

(DEFN I-TPOP_<X{A}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (DEPOSIT (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (I-X I)
                        (I-USR-DATA-SEGMENT I))
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP_<X{S}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'SYS-ADDR
                           (I-X I)
                           I)))

(DEFN I-TPOP_<X{S}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (I-X I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP_PC-OKP
      (I)
      (AND (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'PC
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-TPOP_PC-STEP
      (I)
      (I-STATE (IPC (UNTAG (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I)))
                    (DEFINITION (AREA-NAME (FETCH (I-TSP I)
                                                  (I-SYS-DATA-SEGMENT I)))
                                (I-PROG-SEGMENT I)))
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP_X-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP (FETCH (I-TSP I)
                             (I-SYS-DATA-SEGMENT I))
                      I)))

(DEFN I-TPOP_X-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP_Y-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP (FETCH (I-TSP I)
                             (I-SYS-DATA-SEGMENT I))
                      I)))

(DEFN I-TPOP_Y-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP{V}_<Z>_Y-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-TPOP{V}_<Z>_Y-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (BOOL (ALL-ZERO-BITVP (UNTAG (FETCH (I-TSP I)
                                                   (I-SYS-DATA-SEGMENT I)))))
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP{B}_<Z>_Y-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-TPOP{B}_<Z>_Y-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (BOOL (EQUAL (UNTAG (FETCH (I-TSP I)
                                          (I-SYS-DATA-SEGMENT I)))
                            'F))
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP{I}_<ZN>_Y-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'INT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-TPOP{I}_<ZN>_Y-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (BOOL (NEGATIVEP (UNTAG (FETCH (I-TSP I)
                                              (I-SYS-DATA-SEGMENT I)))))
               (BOOL (EQUAL (UNTAG (FETCH (I-TSP I)
                                          (I-SYS-DATA-SEGMENT I)))
                            0))
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPOP{N}_<Z>_Y-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'NAT
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-TPOP{N}_<Z>_Y-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (POP-STK (I-TSP I))
               (I-X I)
               (FETCH (I-TSP I)
                      (I-SYS-DATA-SEGMENT I))
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (BOOL (EQUAL (UNTAG (FETCH (I-TSP I)
                                          (I-SYS-DATA-SEGMENT I)))
                            0))
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (I-SYS-DATA-SEGMENT I)
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_*-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (I-OBJECTP (I-NEXTWORD I) I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))))

(DEFN I-TPUSH_*-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-NEXTWORD I)
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_<X{A}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))
           (I-OBJECTP-TYPE 'ADDR (I-X I) I)
           (I-OBJECTP (FETCH (I-X I) (I-USR-DATA-SEGMENT I))
                      I)))

(DEFN I-TPUSH_<X{A}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (FETCH (I-X I) (I-USR-DATA-SEGMENT I))
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_<X{S}>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))
           (I-OBJECTP-TYPE 'SYS-ADDR
                           (I-X I)
                           I)))

(DEFN I-TPUSH_<X{S}>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (FETCH (I-X I) (I-SYS-DATA-SEGMENT I))
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_CSP-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))))

(DEFN I-TPUSH_CSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-CSP I)
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_TSP-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))))

(DEFN I-TPUSH_TSP-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-TSP I)
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-TPUSH_X-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (ZEROP (FREE-STK-SIZE (I-TSP I))))
           (I-OBJECTP (I-X I) I)))

(DEFN I-TPUSH_X-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (PUSH-STK (I-TSP I))
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (I-X I)
                        (PUSH-STK (I-TSP I))
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-XOR_<TSP>_<TSP>-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))))

(DEFN I-XOR_<TSP>_<TSP>-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL 'F)
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-XOR_<TSP>{V}_X{V}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BITV (I-X I) I)
           (I-OBJECTP-TYPE 'BITV
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)))

(DEFN I-XOR_<TSP>{V}_X{V}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BITV
                             (XOR-BITV (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))
                                       (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-XOR_<TSP>{B}_*{B}-OKP
      (I)
      (AND (ADD2-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (I-OBJECTP-TYPE 'BOOL
                           (I-NEXTWORD I)
                           I)))

(DEFN I-XOR_<TSP>{B}_*{B}-STEP
      (I)
      (I-STATE (ADD2-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL
                             (XOR-BOOL (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))
                                       (UNTAG (I-NEXTWORD I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-XOR_<TSP>{B}_X{B}-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-OBJECTP-TYPE 'BOOL
                           (FETCH (I-TSP I)
                                  (I-SYS-DATA-SEGMENT I))
                           I)
           (I-OBJECTP-TYPE 'BOOL (I-X I) I)))

(DEFN I-XOR_<TSP>{B}_X{B}-STEP
      (I)
      (I-STATE (ADD1-I-PC I)
               (I-CFP I)
               (I-CSP I)
               (I-TSP I)
               (I-X I)
               (I-Y I)
               (I-C-FLG I)
               (I-V-FLG I)
               (I-N-FLG I)
               (I-Z-FLG I)
               (I-PROG-SEGMENT I)
               (I-USR-DATA-SEGMENT I)
               (DEPOSIT (TAG 'BOOL
                             (XOR-BOOL (UNTAG (FETCH (I-TSP I)
                                                     (I-SYS-DATA-SEGMENT I)))
                                       (UNTAG (I-X I))))
                        (I-TSP I)
                        (I-SYS-DATA-SEGMENT I))
               (I-WORD-SIZE I)
               'RUN))

(DEFN I-XOR_<Z>_<TSP>_X-OKP
      (I)
      (AND (ADD1-I-PCP I)
           (NOT (EMPTY-STKP (I-TSP I)
                            (I-SYS-DATA-SEGMENT I)))
           (I-USR-DATA-OBJECTP (I-X I) I)
           (I-USR-DATA-OBJECTP (FETCH (I-TSP I)
                                      (I-SYS-DATA-SEGMENT I))
                               I)
           (EQUAL (TYPE (I-X I))
                  (TYPE (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))))))

; Note: This step function is different from all the others in that it
; takes a second argument!  The problem is that to xor any two
; addresses we must know where they are loaded to compute the
; resultant bit vector.  In the days before we added load-addr, the
; address 0 was built into this definition and this stepper was like
; all the others.  But now we have to supply it.  We could have made
; it part of the I state, but that would have required changing all
; the steppers to construct the new sized state and might have
; required other changes (e.g., in proving that it is unchanged?).  So
; we have just added it to this one stepper, which will be handled
; specially in by i-ins-step.  Of course, we have to add load-addr as
; an argument to the I machine itself.  Sigh.

(DEFN I-XOR_<Z>_<TSP>_X-STEP (I LOAD-ADDR)
  (I-STATE (ADD1-I-PC I)
           (I-CFP I)
           (I-CSP I)
           (I-TSP I)
           (I-X I)
           (I-Y I)
           (I-C-FLG I)
           (I-V-FLG I)
           (I-N-FLG I)
           (BOOL (EQUAL (FETCH (I-TSP I)
                               (I-SYS-DATA-SEGMENT I))
                        (I-X I)))
           (I-PROG-SEGMENT I)
           (I-USR-DATA-SEGMENT I)
           (DEPOSIT (TAG 'BITV
                         (XOR-XXX (FETCH (I-TSP I)
                                         (I-SYS-DATA-SEGMENT I))
                                  (I-X I)
                                  I
                                  LOAD-ADDR))
                    (I-TSP I)
                    (I-SYS-DATA-SEGMENT I))
           (I-WORD-SIZE I)
           'RUN))

(DEFN I-INS-OKP
      (INS I)
      (AND (EQUAL (CDR INS) NIL)
           (CASE (CAR INS)
                 (ADD_<C>_X_X{N} (I-ADD_<C>_X_X{N}-OKP I))
                 (ADD_<TSP>_<TSP>{V} (I-ADD_<TSP>_<TSP>{V}-OKP I))
                 (ADD_<TSP>_<TSP>{N} (I-ADD_<TSP>_<TSP>{N}-OKP I))
                 (ADD_<TSP>{A}_X{N} (I-ADD_<TSP>{A}_X{N}-OKP I))
                 (ADD_TSP_*{N} (I-ADD_TSP_*{N}-OKP I))
                 (ADD_TSP_X{N} (I-ADD_TSP_X{N}-OKP I))
                 (ADD_<TSP>{I}_X{I} (I-ADD_<TSP>{I}_X{I}-OKP I))
                 (ADD_<TSP>{N}_X{N} (I-ADD_<TSP>{N}_X{N}-OKP I))
                 (ADD_PC_X{N} (I-ADD_PC_X{N}-OKP I))
                 (ADD_X_X{N} (I-ADD_X_X{N}-OKP I))
                 (ADD_X{N}_CSP (I-ADD_X{N}_CSP-OKP I))
                 (ADDC_<C>_X{N}_Y{N} (I-ADDC_<C>_X{N}_Y{N}-OKP I))
                 (ADDC_<V>_X{I}_Y{I} (I-ADDC_<V>_X{I}_Y{I}-OKP I))
                 (AND_<TSP>{V}_X{V} (I-AND_<TSP>{V}_X{V}-OKP I))
                 (AND_<TSP>{B}_X{B} (I-AND_<TSP>{B}_X{B}-OKP I))
                 (ASR_<C>_<TSP>_<TSP>{B} (I-ASR_<C>_<TSP>_<TSP>{B}-OKP I))
                 (CPOP_CFP (I-CPOP_CFP-OKP I))
                 (CPOP_PC (I-CPOP_PC-OKP I))
                 (CPUSH_* (I-CPUSH_*-OKP I))
                 (CPUSH_<TSP>+ (I-CPUSH_<TSP>+-OKP I))
                 (CPUSH_CFP (I-CPUSH_CFP-OKP I))
                 (DECR_<TSP>_<TSP>{I} (I-DECR_<TSP>_<TSP>{I}-OKP I))
                 (DECR_<TSP>_<TSP>{N} (I-DECR_<TSP>_<TSP>{N}-OKP I))
                 (INCR_<TSP>_<TSP>{I} (I-INCR_<TSP>_<TSP>{I}-OKP I))
                 (INCR_<TSP>_<TSP>{N} (I-INCR_<TSP>_<TSP>{N}-OKP I))
                 (INCR_Y_Y{N} (I-INCR_Y_Y{N}-OKP I))
                 (INT-TO-NAT (I-INT-TO-NAT-OKP I))
                 (JUMP-N_X (I-JUMP-N_X-OKP I))
                 (JUMP-NN_X (I-JUMP-NN_X-OKP I))
                 (JUMP-NZ_X (I-JUMP-NZ_X-OKP I))
                 (JUMP-Z_X (I-JUMP-Z_X-OKP I))
                 (JUMP_* (I-JUMP_*-OKP I))
                 (JUMP_X{SUBR} (I-JUMP_X{SUBR}-OKP I))
                 (LSR_<C>_X_X{N} (I-LSR_<C>_X_X{N}-OKP I))
                 (LSR_<TSP>_<TSP>{V} (I-LSR_<TSP>_<TSP>{V}-OKP I))
                 (MOVE-C_<TSP>_* (I-MOVE-C_<TSP>_*-OKP I))
                 (MOVE-V_<TSP>_* (I-MOVE-V_<TSP>_*-OKP I))
                 (MOVE-Z_<TSP>_* (I-MOVE-Z_<TSP>_*-OKP I))
                 (MOVE-N_X_* (I-MOVE-N_X_*-OKP I))
                 (MOVE_<TSP>_* (I-MOVE_<TSP>_*-OKP I))
                 (MOVE_<X{A}>_<TSP> (I-MOVE_<X{A}>_<TSP>-OKP I))
                 (MOVE_<X{S}>_<TSP> (I-MOVE_<X{S}>_<TSP>-OKP I))
                 (MOVE_CFP_CSP (I-MOVE_CFP_CSP-OKP I))
                 (MOVE_CSP_CFP (I-MOVE_CSP_CFP-OKP I))
                 (MOVE_X_* (I-MOVE_X_*-OKP I))
                 (MOVE_X_<X{S}> (I-MOVE_X_<X{S}>-OKP I))
                 (MOVE_X_TSP (I-MOVE_X_TSP-OKP I))
                 (MOVE_X_X (I-MOVE_X_X-OKP I))
                 (MOVE_Y_* (I-MOVE_Y_*-OKP I))
                 (MOVE_Y_<Y{S}> (I-MOVE_Y_<Y{S}>-OKP I))
                 (MOVE_Y_TSP (I-MOVE_Y_TSP-OKP I))
                 (NEG_<TSP>_<TSP>{I} (I-NEG_<TSP>_<TSP>{I}-OKP I))
                 (NOT_<TSP>_<TSP>{V} (I-NOT_<TSP>_<TSP>{V}-OKP I))
                 (OR_<TSP>{V}_X{V} (I-OR_<TSP>{V}_X{V}-OKP I))
                 (OR_<TSP>{B}_X{B} (I-OR_<TSP>{B}_X{B}-OKP I))
                 (SUB_<C>_<TSP>{A}_X{A} (I-SUB_<C>_<TSP>{A}_X{A}-OKP I))
                 (SUB_<C>_<TSP>{N}_X{N} (I-SUB_<C>_<TSP>{N}_X{N}-OKP I))
                 (SUB_<NV>_<TSP>{I}_X{I} (I-SUB_<NV>_<TSP>{I}_X{I}-OKP I))
                 (SUB_<TSP>{A}_X{N} (I-SUB_<TSP>{A}_X{N}-OKP I))
                 (SUB_X{S}_Y{N} (I-SUB_X{S}_Y{N}-OKP I))
                 (SUB_<TSP>{I}_X{I} (I-SUB_<TSP>{I}_X{I}-OKP I))
                 (SUB_<TSP>{N}_X{N} (I-SUB_<TSP>{N}_X{N}-OKP I))
                 (SUB_<TSP>{S}_X{S} (I-SUB_<TSP>{S}_X{S}-OKP I))
                 (SUB_<Z>_X{S}_Y{S} (I-SUB_<Z>_X{S}_Y{S}-OKP I))
                 (SUBB_<C>_X{N}_Y{N} (I-SUBB_<C>_X{N}_Y{N}-OKP I))
                 (SUBB_<V>_X{I}_Y{I} (I-SUBB_<V>_X{I}_Y{I}-OKP I))
                 (TPOP_<C>_X (I-TPOP_<C>_X-OKP I))
                 (TPOP_<X{A}> (I-TPOP_<X{A}>-OKP I))
                 (TPOP_<X{S}> (I-TPOP_<X{S}>-OKP I))
                 (TPOP_PC (I-TPOP_PC-OKP I))
                 (TPOP_X (I-TPOP_X-OKP I))
                 (TPOP_Y (I-TPOP_Y-OKP I))
                 (TPOP{V}_<Z>_Y (I-TPOP{V}_<Z>_Y-OKP I))
                 (TPOP{B}_<Z>_Y (I-TPOP{B}_<Z>_Y-OKP I))
                 (TPOP{I}_<ZN>_Y (I-TPOP{I}_<ZN>_Y-OKP I))
                 (TPOP{N}_<Z>_Y (I-TPOP{N}_<Z>_Y-OKP I))
                 (TPUSH_* (I-TPUSH_*-OKP I))
                 (TPUSH_<X{A}> (I-TPUSH_<X{A}>-OKP I))
                 (TPUSH_<X{S}> (I-TPUSH_<X{S}>-OKP I))
                 (TPUSH_CSP (I-TPUSH_CSP-OKP I))
                 (TPUSH_TSP (I-TPUSH_TSP-OKP I))
                 (TPUSH_X (I-TPUSH_X-OKP I))
                 (XOR_<TSP>_<TSP> (I-XOR_<TSP>_<TSP>-OKP I))
                 (XOR_<TSP>{V}_X{V} (I-XOR_<TSP>{V}_X{V}-OKP I))
                 (XOR_<TSP>{B}_*{B} (I-XOR_<TSP>{B}_*{B}-OKP I))
                 (XOR_<TSP>{B}_X{B} (I-XOR_<TSP>{B}_X{B}-OKP I))
                 (XOR_<Z>_<TSP>_X (I-XOR_<Z>_<TSP>_X-OKP I))
                 (OTHERWISE F))))

(DEFN I-INS-STEP (INS I LOAD-ADDR)
      (CASE (CAR INS)
            (ADD_<C>_X_X{N} (I-ADD_<C>_X_X{N}-STEP I))
            (ADD_<TSP>_<TSP>{V} (I-ADD_<TSP>_<TSP>{V}-STEP I))
            (ADD_<TSP>_<TSP>{N} (I-ADD_<TSP>_<TSP>{N}-STEP I))
            (ADD_<TSP>{A}_X{N} (I-ADD_<TSP>{A}_X{N}-STEP I))
            (ADD_TSP_*{N} (I-ADD_TSP_*{N}-STEP I))
            (ADD_TSP_X{N} (I-ADD_TSP_X{N}-STEP I))
            (ADD_<TSP>{I}_X{I} (I-ADD_<TSP>{I}_X{I}-STEP I))
            (ADD_<TSP>{N}_X{N} (I-ADD_<TSP>{N}_X{N}-STEP I))
            (ADD_PC_X{N} (I-ADD_PC_X{N}-STEP I))
            (ADD_X_X{N} (I-ADD_X_X{N}-STEP I))
            (ADD_X{N}_CSP (I-ADD_X{N}_CSP-STEP I))
            (ADDC_<C>_X{N}_Y{N} (I-ADDC_<C>_X{N}_Y{N}-STEP I))
            (ADDC_<V>_X{I}_Y{I} (I-ADDC_<V>_X{I}_Y{I}-STEP I))
            (AND_<TSP>{V}_X{V} (I-AND_<TSP>{V}_X{V}-STEP I))
            (AND_<TSP>{B}_X{B} (I-AND_<TSP>{B}_X{B}-STEP I))
            (ASR_<C>_<TSP>_<TSP>{B} (I-ASR_<C>_<TSP>_<TSP>{B}-STEP I))
            (CPOP_CFP (I-CPOP_CFP-STEP I))
            (CPOP_PC (I-CPOP_PC-STEP I))
            (CPUSH_* (I-CPUSH_*-STEP I))
            (CPUSH_<TSP>+ (I-CPUSH_<TSP>+-STEP I))
            (CPUSH_CFP (I-CPUSH_CFP-STEP I))
            (DECR_<TSP>_<TSP>{I} (I-DECR_<TSP>_<TSP>{I}-STEP I))
            (DECR_<TSP>_<TSP>{N} (I-DECR_<TSP>_<TSP>{N}-STEP I))
            (INCR_<TSP>_<TSP>{I} (I-INCR_<TSP>_<TSP>{I}-STEP I))
            (INCR_<TSP>_<TSP>{N} (I-INCR_<TSP>_<TSP>{N}-STEP I))
            (INCR_Y_Y{N} (I-INCR_Y_Y{N}-STEP I))
            (INT-TO-NAT (I-INT-TO-NAT-STEP I))
            (JUMP-N_X (I-JUMP-N_X-STEP I))
            (JUMP-NN_X (I-JUMP-NN_X-STEP I))
            (JUMP-NZ_X (I-JUMP-NZ_X-STEP I))
            (JUMP-Z_X (I-JUMP-Z_X-STEP I))
            (JUMP_* (I-JUMP_*-STEP I))
            (JUMP_X{SUBR} (I-JUMP_X{SUBR}-STEP I))
            (LSR_<C>_X_X{N} (I-LSR_<C>_X_X{N}-STEP I))
            (LSR_<TSP>_<TSP>{V} (I-LSR_<TSP>_<TSP>{V}-STEP I))
            (MOVE-C_<TSP>_* (I-MOVE-C_<TSP>_*-STEP I))
            (MOVE-V_<TSP>_* (I-MOVE-V_<TSP>_*-STEP I))
            (MOVE-Z_<TSP>_* (I-MOVE-Z_<TSP>_*-STEP I))
            (MOVE-N_X_* (I-MOVE-N_X_*-STEP I))
            (MOVE_<TSP>_* (I-MOVE_<TSP>_*-STEP I))
            (MOVE_<X{A}>_<TSP> (I-MOVE_<X{A}>_<TSP>-STEP I))
            (MOVE_<X{S}>_<TSP> (I-MOVE_<X{S}>_<TSP>-STEP I))
            (MOVE_CFP_CSP (I-MOVE_CFP_CSP-STEP I))
            (MOVE_CSP_CFP (I-MOVE_CSP_CFP-STEP I))
            (MOVE_X_* (I-MOVE_X_*-STEP I))
            (MOVE_X_<X{S}> (I-MOVE_X_<X{S}>-STEP I))
            (MOVE_X_TSP (I-MOVE_X_TSP-STEP I))
            (MOVE_X_X (I-MOVE_X_X-STEP I))
            (MOVE_Y_* (I-MOVE_Y_*-STEP I))
            (MOVE_Y_<Y{S}> (I-MOVE_Y_<Y{S}>-STEP I))
            (MOVE_Y_TSP (I-MOVE_Y_TSP-STEP I))
            (NEG_<TSP>_<TSP>{I} (I-NEG_<TSP>_<TSP>{I}-STEP I))
            (NOT_<TSP>_<TSP>{V} (I-NOT_<TSP>_<TSP>{V}-STEP I))
            (OR_<TSP>{V}_X{V} (I-OR_<TSP>{V}_X{V}-STEP I))
            (OR_<TSP>{B}_X{B} (I-OR_<TSP>{B}_X{B}-STEP I))
            (SUB_<C>_<TSP>{A}_X{A} (I-SUB_<C>_<TSP>{A}_X{A}-STEP I))
            (SUB_<C>_<TSP>{N}_X{N} (I-SUB_<C>_<TSP>{N}_X{N}-STEP I))
            (SUB_<NV>_<TSP>{I}_X{I} (I-SUB_<NV>_<TSP>{I}_X{I}-STEP I))
            (SUB_<TSP>{A}_X{N} (I-SUB_<TSP>{A}_X{N}-STEP I))
            (SUB_X{S}_Y{N} (I-SUB_X{S}_Y{N}-STEP I))
            (SUB_<TSP>{I}_X{I} (I-SUB_<TSP>{I}_X{I}-STEP I))
            (SUB_<TSP>{N}_X{N} (I-SUB_<TSP>{N}_X{N}-STEP I))
            (SUB_<TSP>{S}_X{S} (I-SUB_<TSP>{S}_X{S}-STEP I))
            (SUB_<Z>_X{S}_Y{S} (I-SUB_<Z>_X{S}_Y{S}-STEP I))
            (SUBB_<C>_X{N}_Y{N} (I-SUBB_<C>_X{N}_Y{N}-STEP I))
            (SUBB_<V>_X{I}_Y{I} (I-SUBB_<V>_X{I}_Y{I}-STEP I))
            (TPOP_<C>_X (I-TPOP_<C>_X-STEP I))
            (TPOP_<X{A}> (I-TPOP_<X{A}>-STEP I))
            (TPOP_<X{S}> (I-TPOP_<X{S}>-STEP I))
            (TPOP_PC (I-TPOP_PC-STEP I))
            (TPOP_X (I-TPOP_X-STEP I))
            (TPOP_Y (I-TPOP_Y-STEP I))
            (TPOP{V}_<Z>_Y (I-TPOP{V}_<Z>_Y-STEP I))
            (TPOP{B}_<Z>_Y (I-TPOP{B}_<Z>_Y-STEP I))
            (TPOP{I}_<ZN>_Y (I-TPOP{I}_<ZN>_Y-STEP I))
            (TPOP{N}_<Z>_Y (I-TPOP{N}_<Z>_Y-STEP I))
            (TPUSH_* (I-TPUSH_*-STEP I))
            (TPUSH_<X{A}> (I-TPUSH_<X{A}>-STEP I))
            (TPUSH_<X{S}> (I-TPUSH_<X{S}>-STEP I))
            (TPUSH_CSP (I-TPUSH_CSP-STEP I))
            (TPUSH_TSP (I-TPUSH_TSP-STEP I))
            (TPUSH_X (I-TPUSH_X-STEP I))
            (XOR_<TSP>_<TSP> (I-XOR_<TSP>_<TSP>-STEP I))
            (XOR_<TSP>{V}_X{V} (I-XOR_<TSP>{V}_X{V}-STEP I))
            (XOR_<TSP>{B}_*{B} (I-XOR_<TSP>{B}_*{B}-STEP I))
            (XOR_<TSP>{B}_X{B} (I-XOR_<TSP>{B}_X{B}-STEP I))
            (XOR_<Z>_<TSP>_X (I-XOR_<Z>_<TSP>_X-STEP I LOAD-ADDR))
            (OTHERWISE (I-HALT I 'RUN))))

(DEFN I-STEP1
      (INS I load-addr)
      (IF (I-STATE-OKP I load-addr)
          (IF (I-INS-OKP INS I)
              (I-INS-STEP INS I load-addr)
              (I-HALT I
                      (X-Y-ERROR-MSG 'I (CAR INS))))
          (I-HALT I 'STATE-NOT-OKP)))

(DEFN I-STEP
      (I load-addr)
      (IF (EQUAL (I-PSW I) 'RUN)
          (I-STEP1 (I-CURRENT-INSTRUCTION I) I load-addr)
          I))

(DEFN I
      (I N load-addr)
      (IF (ZEROP N)
          I
          (I (I-STEP I load-addr) (SUB1 N) load-addr)))

(DEFN LIST-OF-NATS
      (LST)
      (IF (NLISTP LST)
          NIL
          (CONS (V-TO-NAT (CAR LST))
                (LIST-OF-NATS (CDR LST)))))

; Book: i-m.events.  We now develop the proof that the i machine is
; implemented on the m machine.

; I first develop the necessary rules about the FM9001 alu.

; Each of the alu theorems is about the bv-alu-cv function.
; That function returns a triple.  We are most interested in
; the bv and c components of the triple.  We are occasionally
; interested in the v component, but only for those instructions
; that we use that set the v flag.

; For each opcode op, each component, cmp, in {bv c v}
; and type, t, in {bitv nat tc} we have a theorem called
; alu-thm_t-cmp-op.  For example, we have alu-thm_BITV-BV-MOVE,
; which gives the BITV interpretation of the BV component of
; the alu on a MOVE opcode.  We omit some combinations because
; they do not make much sense.  Occasionally we have to prove
; conflicting rules -- rules that rewrite the same lhs.  This
; happens when the opcode has a natural interpretation for more
; than one type.  When it happens we note it.

(enable v-buf-works)

(prove-lemma alu-thm_bitv-bv-move-15 (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t t t)))
                  a)))

(prove-lemma alu-thm_bitv-c-move-15 (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t t t t)))
                  f)))

(prove-lemma alu-thm_bitv-bv-not (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t t t)))
                  (v-not a))))

(prove-lemma alu-thm_bitv-c-not (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f t t t)))
                  f)))

(prove-lemma alu-thm_bitv-bv-and (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f t t)))
                  (v-and a b))))

(prove-lemma alu-thm_bitv-c-and (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t f t t)))
                  f)))

(prove-lemma alu-thm_bitv-bv-or (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f f t t)))
                  (v-or a b))))

(prove-lemma alu-thm_bitv-c-or (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f f t t)))
                  f)))

(prove-lemma alu-thm_bitv-bv-xor (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t f t)))
                  (v-xor a b))))

(prove-lemma alu-thm_bitv-c-xor (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t t f t)))
                  f)))

; Conflict:  We will have both a BITV and a NAT interpretation of the
; BV and C produced by the LSR instruction.  Here is the BITV case:

(prove-lemma alu-thm_bitv-bv-lsr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t f t)))
                  (v-lsr a))))

; Note that we have an additional hypothesis below, (listp a).

(prove-lemma alu-thm_bitv-c-lsr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (listp a)
                (boolp c))
           (equal (c (v-alu c a b (list f t f t)))
                  (bitn a 1))))

; Conflict:  We will have both a BITV and a TC interpretation of the BV
; produced by the ASR instruction.  

(prove-lemma alu-thm_bitv-bv-asr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f f t)))
                  (v-asr a))))

; Note that we have an additional hypothesis below, (listp a).

(prove-lemma alu-thm_bitv-c-asr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (listp a)
                (boolp c))
           (equal (c (v-alu c a b (list t f f t)))
                  (bitn a 1))))


(prove-lemma alu-thm_bitv-bv-ror (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f f f t)))
                  (v-ror a c))))

; To prove the next one we need another piece of help.

(prove-lemma boolp-truep (rewrite)
  (implies (boolp c) (equal (truep c) c)))

(prove-lemma alu-thm_bitv-c-ror (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f f f t)))
                  (if (zerop (length a))
                      c
                      (bitn a 1)))))


; Here are the natural number interpretations of the bv and c flag of the
; alu.

; Our first step is to get the natural interpretation lemma as a rewrite
; rule and shut down v-alu:

(disable v-alu)

(prove-lemma v-alu-correct-nat-rewriter (rewrite)
  (implies (bv2p a b)
           (equal (v-alu c a b op)
                  (v-alu-nat c a b op)))
  ((disable v-alu-nat)
   (use (v-alu-correct-nat))))

; The original (FM8502) Piton proofs were based on alu interpretation
; lemmas proved for FM8502.  When FM9001 was done, Matt Kaufmann was given
; a free hand to formulate the alu interpretation lemmas for it.  His
; algebraic expressions were different than those used for FM8502, even
; though they were equivalent.  Rather than redesign the Piton proof to
; use Matt's formulation, we take the approach of proving the old-style
; algebraic formulations from Matt's.  That is what we do now.

; This gets exceptionally tedious for the twos-complement stuff.  I essentially
; just use brute force to wade through this stuff.  The general scheme was
; was to attack the top-level theorems with a fixed set of rules enabled,
; generating certain goals (all phrased in integer terms) and then attack
; each of those goals as a separate lemma with the integer stuff enabled.
; Those integer lemmas are killers, taking hundreds or thousands of seconds
; each.  But it was better than thinking...

(prove-lemma alu-thm_nat-bv-lsr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t f t)))
                  (nat-to-v (quotient (v-to-nat a) 2)
                             (length a)))))

(prove-lemma alu-thm_nat-c-lsr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f t f t)))
                  (not (zerop (remainder (v-to-nat a) 2))))))

(enable plus-0)

(prove-lemma pathological-difference (rewrite)
  (implies (not (lessp a b)) (equal (difference b a) 0)))

(prove-lemma difference-difference-plus (rewrite)
  (equal (difference (difference (plus b e) a) e)
         (difference b a)))

(enable LESSP-V-TO-NAT-EXP)

(prove-lemma remainder-difference-hack (rewrite)
  (implies (lessp b e)
           (equal (remainder (difference b a) e)
                  (difference b a)))
  ((induct (difference b a))))
           
(prove-lemma difference-difference-hack (rewrite)
  (implies (not (lessp a b))
           (equal (difference e (difference a b))
                  (difference (plus b e) a))))

; Conflict:  We will have both a NAT and a TC interpretation of the BV
; produced by the SUB instruction.

(prove-lemma alu-thm_nat-bv-sub (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t t f)))
                  (if (not (lessp (v-to-nat b) (v-to-nat a)))
                      (nat-to-v (difference (v-to-nat b)
                                             (v-to-nat a))
                                 (length a))
                      (nat-to-v
                        (difference (exp 2 (length a))
                                    (difference (v-to-nat a)
                                                (v-to-nat b)))
                        (length a)))))
  ((enable NAT-TO-V-REMAINDER)))

(prove-lemma alu-thm_nat-c-sub (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t t t f)))
                  (lessp (v-to-nat b) (v-to-nat a)))))

(defn carry (c)
  (if c 1 0))

; Conflict:  We will have both a NAT and a TC interpretation of the the
; BV produced by the SUBB instruction.

(prove-lemma alu-thm_nat-bv-subb (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t t f)))
                  (if (lessp (v-to-nat b)
                             (plus (v-to-nat a) (carry c)))
                      (nat-to-v (difference (exp 2 (length a))
                                  (difference (plus (v-to-nat a) (carry c))
                                              (v-to-nat b)))
                                 (length a))
                      (nat-to-v (difference (v-to-nat b)
                                  (plus (v-to-nat a) (carry c)))
                                 (length a)))))
  ((enable NAT-TO-V-REMAINDER)))

(prove-lemma alu-thm_nat-c-subb (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f t t f)))
                  (lessp (v-to-nat b)
                         (plus (v-to-nat a) (carry c))))))

(disable pathological-difference)
(disable difference-difference-plus)
(disable LESSP-V-TO-NAT-EXP)
(disable remainder-difference-hack)
(disable difference-difference-hack)

(enable length-nat-to-v)
(enable commutativity-of-plus)
(enable associativity-of-plus)
(enable plus-add1)
(enable plus-0)
(enable times-commutes)
(enable associativity-of-times)
(enable times-distributes-over-plus)
(enable times-add1-again)
(enable times-1)
(prove-lemma plus-commutes2 (rewrite)
  (equal (plus x (plus y z)) (plus y (plus x z))))
(prove-lemma times-commutes2 (rewrite)
  (equal (times x (times y z)) (times y (times x z))))
(prove-lemma remainder-lessp (rewrite generalize)
  (equal (lessp (remainder x y) y)
         (not (zerop y))))

(enable remainder-quotient-elim)
(prove-lemma remainder-quotient-rewrite (rewrite)
  (implies (and (numberp x)
                (not (zerop y)))
           (equal (plus (remainder x y) (times y (quotient x y))) x)))

(prove-lemma v-to-nat-nat-to-v (rewrite)
  (implies (lessp n (exp 2 len))
           (equal (v-to-nat (nat-to-v n len)) (fix n))))

(prove-lemma lessp-0-exp (rewrite)
  (implies (not (zerop i)) (lessp 0 (exp i j))))

(prove-lemma difference-plus (rewrite)
  (equal (difference (plus a b) b) (fix a)))

; The following lemma is a way to get linear arithmetic to address the
; question "is a less than b" when opening up (remainder a b).

(prove-lemma remainder-opener (rewrite)
  (implies (lessp a b) (equal (remainder a b) (fix a))))

(enable lessp-v-to-nat-exp)

(prove-lemma LESSP-V-TO-NAT-EXP-gen (REWRITE) 
  (LESSP (V-TO-NAT A) 
         (EXP 2 (LENGTH A))) 
  ((ENABLE V-TO-NAT LENGTH)))

(prove-lemma remainder-hack2 (rewrite)
 (equal (remainder (sub1 (v-to-nat v)) (exp 2 (length v)))
        (sub1 (v-to-nat v))))

(enable difference-x-1)

; Conflict:  We will have both a NAT and a TC interpretation of the the
; BV produced by the DECR instruction.

(prove-lemma alu-thm_nat-bv-decr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f t f)))
                  (if (zerop (v-to-nat a))
                      (nat-to-v (sub1 (exp 2 (length a)))
                                 (length a))
                      (nat-to-v (sub1 (v-to-nat a))
                                 (length a))))))

(prove-lemma alu-thm_nat-c-decr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t f t f)))
                  (zerop (v-to-nat a)))))

; Conflict:  We will have both a NAT and a TC interpretation of the the
; BV produced by the ADD instruction.

(prove-lemma alu-thm_nat-bv-add (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t f f)))
                  (if (lessp (plus (v-to-nat a) (v-to-nat b))
                             (exp 2 (length a)))
                      (nat-to-v (plus (v-to-nat a) (v-to-nat b))
                                 (length a))
                      (nat-to-v (remainder (plus (v-to-nat a) (v-to-nat b))
                                            (exp 2 (length a)))
                                 (length a))))))

(prove-lemma alu-thm_nat-c-add (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t t f f)))
                  (not (lessp (plus (v-to-nat a) (v-to-nat b))
                              (exp 2 (length a)))))))

; Conflict:  We will have both a NAT and a TC interpretation of the the
; BV produced by the ADDC instruction.

(prove-lemma alu-thm_nat-bv-addc (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t f f)))
                  (if (lessp (plus (v-to-nat a)
                                   (v-to-nat b)
                                   (carry c))
                             (exp 2 (length a)))
                      (nat-to-v (plus (v-to-nat a)
                                       (v-to-nat b)
                                       (carry c))
                                 (length a))
                      (nat-to-v (remainder (plus (v-to-nat a)
                                                  (v-to-nat b)
                                                  (carry c))
                                            (exp 2 (length a)))
                                 (length a))))))

(prove-lemma alu-thm_nat-c-addc (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list f t f f)))
                  (not (lessp (plus (v-to-nat a)
                                    (v-to-nat b)
                                    (carry c))
                              (exp 2 (length a)))))))


; Conflict:  We will have both a NAT and a TC interpretation of the the
; BV produced by the INCR instruction.

(prove-lemma alu-thm_nat-bv-incr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f f f)))
                  (if (lessp (add1 (v-to-nat a))
                             (exp 2 (length a)))
                      (nat-to-v (add1 (v-to-nat a)) (length a))
                      (nat-to-v 0 (length a)))))
  ((enable pathological-difference)))

(prove-lemma alu-thm_nat-c-incr (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (c (v-alu c a b (list t f f f)))
                  (not (lessp (add1 (v-to-nat a))
                              (exp 2 (length a))))))
  ((enable pathological-difference)))


; Conflict:  Each of the TC interpretations conflicts with some other rule.

; Warning: all of these tc guys had (hands-off if) hints!

(disable v-alu-correct-nat-rewriter)

(prove-lemma v-alu-correct-int-rewriter (rewrite)
  (implies (and (bv2p a b)
                (listp a))
           (equal (v-alu c a b op)
                  (v-alu-int c a b op)))
  ((expand (length a))
   (disable v-alu-int)
   (use (v-alu-correct-int))))

(defn mod2 (x)
  (if (negativep x)
      (minus (quotient (add1 (negative-guts x)) 2))
      (quotient x 2)))

(enable quotient-plus-x-x-2)

; A lemma quotient-add1-plus-x-x-2 exists in fm9001.events, but it did
; not originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-quotient-add1-plus-x-x-2 (rewrite)
  (equal (quotient (add1 (plus x x)) 2) (fix x)))

(prove-lemma idiv-is-mod2 (rewrite)
  (equal (idiv x 2) (if (integerp x) (mod2 x) 0)))

(disable idiv)

; A lemma integerp-v-to-int exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-integerp-v-to-int (rewrite)
  (integerp (v-to-int v)))

(prove-lemma alu-thm_tc-bv-asr (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f f t)))
                  (int-to-v (mod2 (v-to-int a))
                            (length a))))
  ((disable alu-thm_bitv-bv-asr integerp
            carry exp ineg iplus small-integerp v-to-int
            mod2 int-to-v nat-to-v boolp length)))

(defn tc-in-rangep (x n)
  (if (zerop n)
      f
      (if (negativep x)
          (not (lessp (exp 2 (sub1 n))
                      (negative-guts x)))
          (lessp x (exp 2 (sub1 n))))))

(defn tc-add (x y) (iplus x y))

(defn tc-minus (x) (ineg x))

(prove-lemma iplus-0 (rewrite)
  (equal (iplus x 0) (fix-int x)))

(prove-lemma equal-length-0 (rewrite)
  (equal (equal (length x) 0)
         (nlistp x)))

(prove-lemma negativep-ineg (rewrite)
  (implies (and (numberp x) (not (equal x 0))) (negativep (ineg x)))
  ((enable ineg)))

(prove-lemma not-equal-exp-0 (rewrite)
  (implies (not (zerop x)) (not (equal (exp x y) 0)))
  ((enable equal-times-0)))

(prove-lemma ineg-exp-2-x (rewrite)
  (equal (ineg (exp 2 x)) (minus (exp 2 x))))

(prove-lemma diff-diff (rewrite)
  (implies (and (numberp a)
                (numberp b))
           (equal (difference a (difference a b))
                  (if (lessp a b) a b)))
  ((enable pathological-difference)))

(prove-lemma alu-thm_tc-bv-sub-lemma (rewrite)
  (IMPLIES (AND (BVP A) 
                (LISTP A) 
                (BVP B) 
                (LISTP B) 
                (EQUAL (LENGTH A) (LENGTH B)) 
                (NOT (NEGATIVEP (IPLUS (V-TO-INT B) 
                                       (INEG (V-TO-INT A))))) 
                (not (LESSP (IPLUS (V-TO-INT B) 
                                   (INEG (V-TO-INT A))) 
                            (EXP 2 (SUB1 (LENGTH A))))))
           (EQUAL (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (IPLUS (MINUS (EXP 2 (LENGTH A))) 
                                          (INEG (V-TO-INT A)))) 
                            (LENGTH A)) 
                  (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (INEG (V-TO-INT A))) 
                            (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack)))

; Note: This was proved with the lower case a's replaced by b's, but I
; have now assumed it as shown below (except that the concluding
; equality was reversed).  Under that assumption, I can prove the
; tc-bv-sub lemma I need.  However, I now want to reverse the
; direction of the concluding equality so as not to take the chance
; that it loops.

(prove-lemma alu-thm_tc-bv-sub-lemma2 (rewrite)
  (IMPLIES (AND (BVP A) 
                (LISTP A) 
                (BVP B) 
                (LISTP B) 
                (EQUAL (LENGTH A) (LENGTH B)) 
                (NEGATIVEP (IPLUS (V-TO-INT B) 
                                  (INEG (V-TO-INT A)))) 
                (LESSP (EXP 2 (SUB1 (LENGTH a))) 
                       (NEGATIVE-GUTS (IPLUS (V-TO-INT B) 
                                             (INEG (V-TO-INT A)))))) 
           (EQUAL (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (IPLUS (EXP 2 (LENGTH a)) 
                                          (INEG (V-TO-INT A)))) 
                            (LENGTH a)) 
                  (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (INEG (V-TO-INT A))) 
                            (LENGTH a))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-difference-plus
           DIFFERENCE-PLUS-PLUS-CANCELLATION)))  

(prove-lemma alu-thm_tc-bv-sub (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t t f)))
                  (int-to-v
                   (cond ((tc-in-rangep (tc-add (v-to-int b)
                                              (tc-minus (v-to-int a)))
                                           (length a))
                           (tc-add (v-to-int b)
                                (tc-minus (v-to-int a))))
                          ((negativep (tc-add (v-to-int b)
                                           (tc-minus (v-to-int a))))
                           (tc-add (v-to-int b)
                                (tc-add (exp 2 (length a))
                                     (tc-minus (v-to-int a)))))
                          (t (tc-add (v-to-int b)
                                  (tc-add (minus (exp 2 (length a)))
                                       (tc-minus (v-to-int a))))))
                    (length a))))
  ((do-not-induct t)
   (enable integerp-iplus equal-length-0)
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OVERFLOWP iplus ineg
            integerp v-to-int int-to-v exp)))

(prove-lemma alu-thm_tc-v-sub (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (v (v-alu c a b (list t t t f)))
                  (not (tc-in-rangep (tc-add (v-to-int b)
                                          (tc-minus (v-to-int a)))
                                     (length a)))))
  ((do-not-induct t)
   (enable integerp-iplus equal-length-0)
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OUTPUT iplus ineg
            integerp v-to-int int-to-v exp)))

(prove-lemma diff-plus-cancellation-hack2 (rewrite)
  (equal (difference (plus a b c d) (plus b c)) (plus a d)))

(prove-lemma diff-plus-sub1-hack1 (rewrite)
  (implies (lessp a e)
           (equal (difference (plus b (sub1 e)) a)
                  (plus b (sub1 (difference e a))))))

(prove-lemma alu-thm_tc-bv-subb-lemma1 (rewrite)
  (IMPLIES (AND (BVP A) 
                (LISTP A) 
                (BVP B) 
                (LISTP B) 
                (EQUAL (LENGTH A) (LENGTH B)) 
                (NOT (NEGATIVEP (IPLUS (V-TO-INT B) 
                                       (INEG (IPLUS (V-TO-INT A) 1))))) 
                (NOT (LESSP (IPLUS (V-TO-INT B) 
                                   (INEG (IPLUS (V-TO-INT A) 1))) 
                            (EXP 2 (SUB1 (LENGTH A)))))) 
           (EQUAL (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (IPLUS (MINUS (EXP 2 (LENGTH A))) 
                                          (INEG (IPLUS (V-TO-INT A) 1)))) 
                            (LENGTH A)) 
                  (INT-TO-V (IPLUS (V-TO-INT B) 
                                   (INEG (IPLUS (V-TO-INT A) 1))) 
                            (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma diff-plus-sub1-hack2 (rewrite)
  (implies (and (not (zerop e))
                (lessp a e))
           (equal (DIFFERENCE (PLUS b (SUB1 (DIFFERENCE e a))) 
                              e)
                  (DIFFERENCE (PLUS b (SUB1 e)) 
                              (PLUS a e))))
  ((do-not-induct t)
   (enable EQUAL-PLUS-0 DIFFERENCE-ADD1-ARG2 DIFFERENCE-PLUS-PLUS-CANCELLATION 
    DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK DIFFERENCE-ELIM)))

(prove-lemma alu-thm_tc-bv-subb-lemma2-lemma1 (rewrite)
  (implies (and (bvp a)
                (not (equal (length a) 0)))
           (EQUAL 
            (NAT-TO-V 
             (DIFFERENCE 
              (PLUS (V-TO-NAT B) 
                    (SUB1 (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                            (EXP 2 (SUB1 (LENGTH A)))) 
                                      (V-TO-NAT A)))) 
              (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                    (EXP 2 (SUB1 (LENGTH A))))) 
             (LENGTH A)) 
            (NAT-TO-V 
             (DIFFERENCE (PLUS (V-TO-NAT B) 
                               (SUB1 (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                           (EXP 2 (SUB1 (LENGTH A)))))) 
                         (PLUS (V-TO-NAT A) 
                               (EXP 2 (SUB1 (LENGTH A))) 
                               (EXP 2 (SUB1 (LENGTH A))))) 
             (LENGTH A))))
  ((enable lessp-v-to-nat-exp-with-exp-opened)
   (disable nat-to-v v-to-nat difference plus lessp)))

(disable diff-plus-sub1-hack2)

(prove-lemma alu-thm_tc-bv-subb-lemma2 (rewrite)
  (IMPLIES 
   (AND (BVP A) 
        (LISTP A) 
        (BVP B) 
        (LISTP B) 
        (EQUAL (LENGTH A) (LENGTH B)) 
        (NEGATIVEP (IPLUS (V-TO-INT B) 
                          (INEG (IPLUS (V-TO-INT A) 1)))) 
        (LESSP (EXP 2 (SUB1 (LENGTH A))) 
               (NEGATIVE-GUTS (IPLUS (V-TO-INT B) 
                                     (INEG (IPLUS (V-TO-INT A) 1)))))) 
   (EQUAL (INT-TO-V (IPLUS (V-TO-INT B) 
                           (IPLUS (EXP 2 (LENGTH A)) 
                                  (INEG (IPLUS (V-TO-INT A) 1)))) 
                    (LENGTH A)) 
          (INT-TO-V (IPLUS (V-TO-INT B) 
                           (INEG (IPLUS (V-TO-INT A) 1))) 
                    (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-subb (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t t f)))
                  (int-to-v
                   (cond ((tc-in-rangep
                            (tc-add (v-to-int b)
                                  (tc-minus (tc-add (v-to-int a) (carry c))))
                             (length a))
                           (tc-add (v-to-int b)
                                (tc-minus (tc-add (v-to-int a) (carry c)))))
                          ((negativep (tc-add (v-to-int b)
                                           (tc-minus (tc-add (v-to-int a)
                                                          (carry c)))))
                           (tc-add (v-to-int b)
                                (tc-add (exp 2 (length a))
                                     (tc-minus (tc-add (v-to-int a) (carry c))))))
                          (t (tc-add (v-to-int b)
                                  (tc-add (minus (exp 2 (length a)))
                                       (tc-minus (tc-add (v-to-int a)
                                                      (carry c)))))))
                    (length a))))
  ((do-not-induct t)
   (enable integerp-iplus equal-length-0)
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OVERFLOWP iplus ineg
            integerp v-to-int int-to-v exp)))

(prove-lemma alu-thm_tc-v-subb (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (v (v-alu c a b (list f t t f)))
                  (not (tc-in-rangep
                        (tc-add (v-to-int b)
                             (tc-minus (tc-add (v-to-int a) (carry c))))
                        (length a)))))
  ((do-not-induct t)
   (enable integerp-iplus equal-length-0)
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OUTPUT iplus ineg
            integerp v-to-int int-to-v exp)))

(prove-lemma v-to-int-int-to-v-0 (rewrite)
  (equal (v-to-int (int-to-v 0 n)) 0))

; A lemma length-int-to-v exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-length-int-to-v (rewrite)
  (equal (length (int-to-v x n)) (fix n))
  ((enable length-nat-to-v)))

(prove-lemma alu-thm_tc-bv-decr-lemma1 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (IPLUS (V-TO-INT A) -1))) 
                      (NOT (LESSP (IPLUS (V-TO-INT A) -1) 
                                  (EXP 2 (SUB1 (LENGTH A)))))) 
                 (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) -1) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS -1 (MINUS (EXP 2 (LENGTH A))))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-decr-lemma2 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NEGATIVEP (IPLUS (V-TO-INT A) -1)) 
                      (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                             (NEGATIVE-GUTS (IPLUS (V-TO-INT A) -1)))) 
                 (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) -1) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS -1 (EXP 2 (LENGTH A)))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))
                                                             
(prove-lemma alu-thm_tc-bv-decr (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f t f)))
                  (int-to-v
                    (cond ((tc-in-rangep (tc-add (v-to-int a) -1)
                                         (length a))
                           (tc-add (v-to-int a) -1))
                          ((negativep (tc-add (v-to-int a) -1))
                           (tc-add (v-to-int a)
                                (tc-add -1 (exp 2 (length a)))))
                          (t (tc-add (v-to-int a)
                                  (tc-add -1 (minus (exp 2 (length a)))))))
                    (length a))))
  ((do-not-induct t)
   (enable integerp-iplus equal-length-0)
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OVERFLOWP iplus ineg
            integerp v-to-int int-to-v exp)))



(prove-lemma iplus-0-2 (rewrite) (equal (iplus 0 x) (fix-int x)))

(prove-lemma alu-thm_tc-bv-neg-lemma1 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (INEG (V-TO-INT A)))) 
                      (NOT (LESSP (INEG (V-TO-INT A)) 
                                  (EXP 2 (SUB1 (LENGTH A))))) 
                      (NOT (INTEGERP (INEG (V-TO-INT A))))) 
                 (EQUAL (INT-TO-V 0 (LENGTH A)) 
                        (INT-TO-V (IPLUS (MINUS (EXP 2 (LENGTH A))) 
                                         (INEG (V-TO-INT A))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg-lemma2 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (INEG (V-TO-INT A)))) 
                      (NOT (LESSP (INEG (V-TO-INT A)) 
                                  (EXP 2 (SUB1 (LENGTH A))))) 
                      (INTEGERP (INEG (V-TO-INT A)))) 
                 (EQUAL (INT-TO-V (INEG (V-TO-INT A)) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (MINUS (EXP 2 (LENGTH A))) 
                                         (INEG (V-TO-INT A))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg-lemma3 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NEGATIVEP (INEG (V-TO-INT A))) 
                      (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                             (NEGATIVE-GUTS (INEG (V-TO-INT A)))) 
                      (NOT (INTEGERP (INEG (V-TO-INT A))))) 
                 (EQUAL (INT-TO-V 0 (LENGTH A)) 
                        (INT-TO-V (IPLUS (EXP 2 (LENGTH A)) 
                                         (INEG (V-TO-INT A))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg-lemma4 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NEGATIVEP (INEG (V-TO-INT A))) 
                      (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                             (NEGATIVE-GUTS (INEG (V-TO-INT A)))) 
                      (INTEGERP (INEG (V-TO-INT A)))) 
                 (EQUAL (INT-TO-V (INEG (V-TO-INT A)) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (EXP 2 (LENGTH A)) 
                                         (INEG (V-TO-INT A))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg-lemma5 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (INEG (V-TO-INT A)))) 
                      (LESSP (INEG (V-TO-INT A)) 
                             (EXP 2 (SUB1 (LENGTH A)))) 
                      (NOT (INTEGERP (INEG (V-TO-INT A))))) 
                 (EQUAL (INT-TO-V 0 (LENGTH A)) 
                        (INT-TO-V (INEG (V-TO-INT A)) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg-lemma6 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NEGATIVEP (INEG (V-TO-INT A))) 
                      (NOT (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                                  (NEGATIVE-GUTS (INEG (V-TO-INT A))))) 
                      (NOT (INTEGERP (INEG (V-TO-INT A))))) 
                 (EQUAL (INT-TO-V 0 (LENGTH A)) 
                        (INT-TO-V (INEG (V-TO-INT A)) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-neg (rewrite) 
  (implies (and (bvp a) 
                (listp a) 
                (bvp b) 
                (listp b) 
                (equal (length a) (length b)) 
                (boolp c)) 
           (equal (bv (v-alu c a b (list f f t f))) 
                  (int-to-v 
                    (cond ((tc-in-rangep (tc-minus (v-to-int a)) 
                                         (length a)) 
                           (tc-minus (v-to-int a))) 
                          ((negativep (tc-minus (v-to-int a))) 
                           (tc-add (exp 2 (length a)) 
                                (tc-minus (v-to-int a)))) 
                          (t (tc-add (minus (exp 2 (length a))) 
                                  (tc-minus (v-to-int a))))) 
                    (length a)))) 
  ((do-not-induct t) 
   (enable integerp-iplus equal-length-0) 
   (disable V-ZEROP V-SUBTRACTER-CARRY-OUT V-ALU-INT-SUBTRACTER-OVERFLOWP iplus ineg 
            integerp v-to-int int-to-v exp)))

(prove-lemma diff-plus-plus-plus-cancellation (rewrite)
  (equal (difference (plus a (plus b e)) e) (plus a b)))

(prove-lemma alu-thm_tc-bv-add-lemma1 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (IPLUS (V-TO-INT A) (V-TO-INT B)))) 
                      (NOT (LESSP (IPLUS (V-TO-INT A) (V-TO-INT B)) 
                                  (EXP 2 (SUB1 (LENGTH A)))))) 
                 (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) (V-TO-INT B)) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS (V-TO-INT B) 
                                                (MINUS (EXP 2 (LENGTH A))))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2)))

(prove-lemma alu-thm_tc-bv-add-lemma2 (rewrite)
        (IMPLIES 
                (AND (BVP A) 
                     (LISTP A) 
                     (BVP B) 
                     (LISTP B) 
                     (EQUAL (LENGTH A) (LENGTH B)) 
                     (NEGATIVEP (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                     (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                            (NEGATIVE-GUTS (IPLUS (V-TO-INT A) (V-TO-INT B))))) 
                (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) (V-TO-INT B)) 
                                 (LENGTH A)) 
                       (INT-TO-V (IPLUS (V-TO-INT A) 
                                        (IPLUS (V-TO-INT B) 
                                               (EXP 2 (LENGTH A)))) 
                                 (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-add (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t t f f)))
                  (int-to-v
                    (cond ((tc-in-rangep (tc-add (v-to-int a) (v-to-int b))
                                         (length a))
                           (tc-add (v-to-int a) (v-to-int b)))
                          ((negativep (tc-add (v-to-int a) (v-to-int b)))
                           (tc-add (v-to-int a)
                                (tc-add (v-to-int b) (exp 2 (length a)))))
                          (t (tc-add (v-to-int a)
                                  (tc-add (v-to-int b)
                                       (minus (exp 2 (length a)))))))
                    (length a))))
  ((do-not-induct t) 
   (enable integerp-iplus equal-length-0) 
   (disable V-ZEROP V-ADDER-CARRY-OUT V-ALU-INT-ADDER-OVERFLOWP iplus ineg 
            integerp v-to-int int-to-v exp)))

(prove-lemma alu-thm_tc-bv-addc-lemma1 (rewrite)
        (IMPLIES 
          (AND (BVP A) 
               (LISTP A) 
               (BVP B) 
               (LISTP B) 
               (EQUAL (LENGTH A) (LENGTH B)) 
               (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                      (IPLUS (V-TO-INT B) 1)))) 
               (NOT (LESSP (IPLUS (V-TO-INT A) 
                                  (IPLUS (V-TO-INT B) 1)) 
                           (EXP 2 (SUB1 (LENGTH A)))))) 
          (EQUAL (INT-TO-V (IPLUS 1 
                                  (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                           (LENGTH A)) 
                 (INT-TO-V (IPLUS (V-TO-INT A) 
                                  (IPLUS (V-TO-INT B) 
                                         (IPLUS 1 (MINUS (EXP 2 (LENGTH A)))))) 
                           (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-addc-lemma2 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NEGATIVEP (IPLUS (V-TO-INT A) 
                                        (IPLUS (V-TO-INT B) 1))) 
                      (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                             (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                                   (IPLUS (V-TO-INT B) 1))))) 
                 (EQUAL (INT-TO-V (IPLUS 1 
                                         (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS (V-TO-INT B) 
                                                (IPLUS 1 (EXP 2 (LENGTH A))))) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

; The following three lemmas are killers as far as performance goes.
; I prove them, use them to get the lemmas I need, and then
; disable them.

(prove-lemma alu-thm_tc-bv-addc-lemma3-killer1 (rewrite)
  (implies (and (numberp a)
                (not (lessp a (difference (plus e e) b)))
                (not (lessp 1 (difference (plus e e) b)))
                (lessp b (plus e e)))
           (equal (add1 (difference (plus a b) (plus e e)))
                  a)))

(prove-lemma alu-thm_tc-bv-addc-lemma3-killer2 (rewrite)
  (implies (and (not (lessp 1 (difference (plus e e) b)))
                (lessp b (plus e e)))
           (equal (difference (plus e e) b) 1)))

(prove-lemma alu-thm_tc-bv-addc-lemma3-killer3 (rewrite)
  (implies (lessp (v-to-nat a) 1)
           (equal (v-to-nat a) 0)))

(prove-lemma alu-thm_tc-bv-addc-lemma3-lemma1 (rewrite)
  (IMPLIES (AND 
            (LESSP (V-TO-NAT B) 
                   (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                         (EXP 2 (SUB1 (LENGTH A))))) 
            (NOT (LESSP 1 
                        (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                          (EXP 2 (SUB1 (LENGTH A)))) 
                                    (V-TO-NAT B)))) 
            (NOT (LESSP (V-TO-NAT A) 
                        (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                          (EXP 2 (SUB1 (LENGTH A)))) 
                                    (V-TO-NAT B))))) 
           (equal (EQUAL (NAT-TO-V (ADD1 (DIFFERENCE (PLUS (V-TO-NAT A) (V-TO-NAT B)) 
                                                     (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                                           (EXP 2 (SUB1 (LENGTH A)))))) 
                                   (LENGTH A)) 
                         (NAT-TO-V (V-TO-NAT A) (LENGTH A)))
                  t)))

(prove-lemma alu-thm_tc-bv-addc-lemma3-lemma2 (rewrite)
          (IMPLIES 
           (AND 
            (NOT (LESSP 1 
                        (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                          (EXP 2 (SUB1 (LENGTH A)))) 
                                    (V-TO-NAT B)))) 
            (LESSP (V-TO-NAT B) 
                   (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                         (EXP 2 (SUB1 (LENGTH A))))) 
            (LESSP (V-TO-NAT A) 
                   (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                     (EXP 2 (SUB1 (LENGTH A)))) 
                               (V-TO-NAT B)))) 
           (equal
            (EQUAL (NAT-TO-V 0 (LENGTH A)) 
                   (NAT-TO-V (V-TO-NAT A) (LENGTH A)))
            t)))

(disable alu-thm_tc-bv-addc-lemma3-killer1)
(disable alu-thm_tc-bv-addc-lemma3-killer2) 
(disable alu-thm_tc-bv-addc-lemma3-killer3)

(prove-lemma alu-thm_tc-bv-addc-lemma3 (rewrite)
        (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                             (IPLUS (V-TO-INT B) 1)))) 
                      (LESSP (IPLUS (V-TO-INT A) 
                                    (IPLUS (V-TO-INT B) 1)) 
                             (EXP 2 (SUB1 (LENGTH A))))) 
                 (EQUAL (INT-TO-V (IPLUS 1 
                                         (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS (V-TO-INT B) 1)) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-addc-lemma4-lemma1 (rewrite)
 (IMPLIES (AND (LESSP (V-TO-NAT B) 
                      (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                            (EXP 2 (SUB1 (LENGTH A))))) 
               (LESSP (V-TO-NAT A) 
                      (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                            (EXP 2 (SUB1 (LENGTH A)))))
               (NOT 
                (LESSP (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                             (EXP 2 (SUB1 (LENGTH A)))) 
                       (DIFFERENCE (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                                     (EXP 2 (SUB1 (LENGTH A))) 
                                                     (EXP 2 (SUB1 (LENGTH A))) 
                                                     (EXP 2 (SUB1 (LENGTH A)))) 
                                               (V-TO-NAT A)) 
                                   (V-TO-NAT B))))) 
          (EQUAL 
           (DIFFERENCE 
             (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                   (EXP 2 (SUB1 (LENGTH A)))) 
             (PLUS (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                     (EXP 2 (SUB1 (LENGTH A)))) 
                               (V-TO-NAT A)) 
                   (SUB1 (DIFFERENCE (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                           (EXP 2 (SUB1 (LENGTH A)))) 
                                     (V-TO-NAT B))))) 
           (ADD1 (DIFFERENCE (PLUS (V-TO-NAT A) (V-TO-NAT B)) 
                                       (PLUS (EXP 2 (SUB1 (LENGTH A))) 
                                             (EXP 2 (SUB1 (LENGTH A)))))))))

(prove-lemma alu-thm_tc-bv-addc-lemma4 (rewrite)
        (IMPLIES 
             (AND (BVP A) 
                  (LISTP A) 
                  (BVP B) 
                  (LISTP B) 
                  (EQUAL (LENGTH A) (LENGTH B)) 
                  (NEGATIVEP (IPLUS (V-TO-INT A) 
                                    (IPLUS (V-TO-INT B) 1))) 
                  (NOT (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                              (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                                    (IPLUS (V-TO-INT B) 1)))))) 
             (EQUAL (INT-TO-V (IPLUS 1 
                                     (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                              (LENGTH A)) 
                    (INT-TO-V (IPLUS (V-TO-INT A) 
                                     (IPLUS (V-TO-INT B) 1)) 
                              (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-addc (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list f t f f)))
                  (int-to-v
                    (cond ((tc-in-rangep (tc-add (v-to-int a)
                                              (tc-add (v-to-int b) (carry c)))
                                         (length a))
                           (tc-add (v-to-int a)
                                (tc-add (v-to-int b) (carry c))))
                          ((negativep (tc-add (v-to-int a)
                                           (tc-add (v-to-int b) (carry c))))
                           (tc-add (v-to-int a)
                                (tc-add (v-to-int b)
                                     (tc-add (carry c) (exp 2 (length a))))))
                          (t (tc-add (v-to-int a)
                                  (tc-add (v-to-int b)
                                       (tc-add (carry c)
                                            (minus (exp 2 (length a))))))))
                    (length a))))
  ((do-not-induct t) 
   (enable integerp-iplus equal-length-0) 
   (disable V-ZEROP V-ADDER-CARRY-OUT V-ALU-INT-ADDER-OVERFLOWP iplus ineg 
            integerp v-to-int int-to-v exp)))

(prove-lemma alu-thm_tc-v-addc-lemma1 (rewrite)
        (IMPLIES 
              (AND (BVP A) 
                   (LISTP A) 
                   (BVP B) 
                   (LISTP B) 
                   (EQUAL (LENGTH A) (LENGTH B)) 
                   (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                          (IPLUS (V-TO-INT B) 1)))) 
                   (NOT (LESSP (IPLUS (V-TO-INT A) 
                                      (IPLUS (V-TO-INT B) 1)) 
                               (EXP 2 (SUB1 (LENGTH A))))) 
                   (NOT (NEGATIVEP (IPLUS 1 
                                          (IPLUS (V-TO-INT A) (V-TO-INT B)))))) 
              (equal (LESSP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                            (EXP 2 (SUB1 (LENGTH A))))
                     f))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma2 (rewrite)
         (IMPLIES 
            (AND (BVP A) 
                 (LISTP A) 
                 (BVP B) 
                 (LISTP B) 
                 (EQUAL (LENGTH A) (LENGTH B)) 
                 (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                        (IPLUS (V-TO-INT B) 1)))) 
                 (NOT (LESSP (IPLUS (V-TO-INT A) 
                                    (IPLUS (V-TO-INT B) 1)) 
                             (EXP 2 (SUB1 (LENGTH A))))) 
                 (NEGATIVEP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))))) 
            (equal (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                          (NEGATIVE-GUTS (IPLUS 1 
                                                (IPLUS (V-TO-INT A) (V-TO-INT B)))))
                   t))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma3 (rewrite)
         (IMPLIES 
              (AND (BVP A) 
                   (LISTP A) 
                   (BVP B) 
                   (LISTP B) 
                   (EQUAL (LENGTH A) (LENGTH B)) 
                   (NEGATIVEP (IPLUS (V-TO-INT A) 
                                     (IPLUS (V-TO-INT B) 1))) 
                   (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                          (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                                (IPLUS (V-TO-INT B) 1)))) 
                   (NOT (NEGATIVEP (IPLUS 1 
                                          (IPLUS (V-TO-INT A) (V-TO-INT B)))))) 
              (equal (LESSP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                            (EXP 2 (SUB1 (LENGTH A))))
                     f))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma4 (rewrite)
         (IMPLIES 
            (AND (BVP A) 
                 (LISTP A) 
                 (BVP B) 
                 (LISTP B) 
                 (EQUAL (LENGTH A) (LENGTH B)) 
                 (NEGATIVEP (IPLUS (V-TO-INT A) 
                                   (IPLUS (V-TO-INT B) 1))) 
                 (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                        (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                              (IPLUS (V-TO-INT B) 1)))) 
                 (NEGATIVEP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))))) 
            (equal (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                          (NEGATIVE-GUTS (IPLUS 1 
                                                (IPLUS (V-TO-INT A) (V-TO-INT B)))))
                   t))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))
                                                                                                    
(prove-lemma alu-thm_tc-v-addc-lemma5 (rewrite)
         (IMPLIES 
              (AND (BVP A) 
                   (LISTP A) 
                   (BVP B) 
                   (LISTP B) 
                   (EQUAL (LENGTH A) (LENGTH B)) 
                   (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                          (IPLUS (V-TO-INT B) 1)))) 
                   (LESSP (IPLUS (V-TO-INT A) 
                                 (IPLUS (V-TO-INT B) 1)) 
                          (EXP 2 (SUB1 (LENGTH A)))) 
                   (NOT (NEGATIVEP (IPLUS 1 
                                          (IPLUS (V-TO-INT A) (V-TO-INT B)))))) 
              (equal (LESSP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                            (EXP 2 (SUB1 (LENGTH A))))
                     t))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma6 (rewrite)
         (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (BVP B) 
                      (LISTP B) 
                      (EQUAL (LENGTH A) (LENGTH B)) 
                      (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 
                                             (IPLUS (V-TO-INT B) 1)))) 
                      (LESSP (IPLUS (V-TO-INT A) 
                                    (IPLUS (V-TO-INT B) 1)) 
                             (EXP 2 (SUB1 (LENGTH A)))) 
                      (NEGATIVEP (IPLUS 1 
                                        (IPLUS (V-TO-INT A) (V-TO-INT B))))) 
                 (equal (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                               (NEGATIVE-GUTS (IPLUS 1 
                                                     (IPLUS (V-TO-INT A) 
                                                            (V-TO-INT B)))))
                        f))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma7 (rewrite)
         (IMPLIES 
              (AND (BVP A) 
                   (LISTP A) 
                   (BVP B) 
                   (LISTP B) 
                   (EQUAL (LENGTH A) (LENGTH B)) 
                   (NEGATIVEP (IPLUS (V-TO-INT A) 
                                     (IPLUS (V-TO-INT B) 1))) 
                   (NOT (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                               (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                                     (IPLUS (V-TO-INT B) 1))))) 
                   (NOT (NEGATIVEP (IPLUS 1 
                                          (IPLUS (V-TO-INT A) (V-TO-INT B)))))) 
              (equal (LESSP (IPLUS 1 
                                   (IPLUS (V-TO-INT A) (V-TO-INT B))) 
                            (EXP 2 (SUB1 (LENGTH A))))
                     t))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc-lemma8 (rewrite)
         (IMPLIES 
              (AND (BVP A) 
                   (LISTP A) 
                   (BVP B) 
                   (LISTP B) 
                   (EQUAL (LENGTH A) (LENGTH B)) 
                   (NEGATIVEP (IPLUS (V-TO-INT A) 
                                     (IPLUS (V-TO-INT B) 1))) 
                   (NOT (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                               (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 
                                                     (IPLUS (V-TO-INT B) 1))))) 
                   (NEGATIVEP (IPLUS 1 
                                     (IPLUS (V-TO-INT A) (V-TO-INT B))))) 
              (equal (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                            (NEGATIVE-GUTS (IPLUS 1 
                                                  (IPLUS (V-TO-INT A) 
                                                         (V-TO-INT B)))))
                     f))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-v-addc (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (v (v-alu c a b (list f t f f)))
                  (not
                   (tc-in-rangep (tc-add (v-to-int a)
                                      (tc-add (v-to-int b) (carry c)))
                                 (length a)))))
  ((do-not-induct t) 
   (enable integerp-iplus equal-length-0) 
   (disable V-ZEROP V-ADDER-CARRY-OUT V-ALU-INT-ADDER-OUTPUT iplus ineg 
            integerp v-to-int int-to-v exp)))

(prove-lemma alu-thm_tc-bv-incr-lemma1 (rewrite)
         (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (NOT (NEGATIVEP (IPLUS (V-TO-INT A) 1))) 
                      (NOT (LESSP (IPLUS (V-TO-INT A) 1) 
                                  (EXP 2 (SUB1 (LENGTH A)))))) 
                 (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS 1 (MINUS (EXP 2 (LENGTH A))))) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS 1 (V-TO-INT A)) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-incr-lemma2 (rewrite)
         (IMPLIES (AND (BVP A) 
                      (LISTP A) 
                      (NEGATIVEP (IPLUS (V-TO-INT A) 1)) 
                      (LESSP (EXP 2 (SUB1 (LENGTH A))) 
                             (NEGATIVE-GUTS (IPLUS (V-TO-INT A) 1)))) 
                 (EQUAL (INT-TO-V (IPLUS (V-TO-INT A) 
                                         (IPLUS 1 (EXP 2 (LENGTH A)))) 
                                  (LENGTH A)) 
                        (INT-TO-V (IPLUS 1 (V-TO-INT A)) 
                                  (LENGTH A))))
  ((DO-NOT-INDUCT T)
   (enable LESSP-V-TO-NAT-EXP-WITH-EXP-OPENED MY-LESSP-V-TO-NAT-EXP ineg-iplus
           associativity-of-iplus ineg-ineg INTEGERP-INEG plus-difference-arg2
           difference-difference-hack difference-sub1-arg2 DIFFERENCE-PLUS-PLUS-CANCELLATION-HACK)))

(prove-lemma alu-thm_tc-bv-incr (rewrite)
  (implies (and (bvp a)
                (listp a)
                (bvp b)
                (listp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (bv (v-alu c a b (list t f f f)))
                  (int-to-v
                    (cond ((tc-in-rangep (tc-add (v-to-int a) 1)
                                         (length a))
                           (tc-add (v-to-int a) 1))
                          ((negativep (tc-add (v-to-int a) 1))
                           (tc-add (v-to-int a)
                                (tc-add 1 (exp 2 (length a)))))
                          (t (tc-add (v-to-int a)
                                  (tc-add 1 (minus (exp 2 (length a)))))))
                    (length a))))
  ((do-not-induct t) 
   (enable integerp-iplus equal-length-0 commutativity-of-iplus) 
   (disable V-ZEROP V-ADDER-CARRY-OUT V-ALU-INT-ADDER-OVERFLOWP iplus ineg 
            integerp v-to-int int-to-v exp)))

; That completes the alu interpretation lemmas.  Now we disable everything we did
; in this section other than the old-style interpretation lemmas (i.e., we make the
; data base behave as though we had done an add-axiom for each of the interpretation
; lemmas).  The reason for this is that the first time we rebuilt Piton on FM9001 we
; skipped the proofs of these boring facts so we could get on with the interesting
; part and now, having proved them, we have to make sure the lemmas we added don't
; mess up future proofs.

(DISABLE-THEORY
 (EQUAL-LENGTH-0 NEGATIVEP-INEG NOT-EQUAL-EXP-0 INEG-EXP-2-X DIFF-DIFF
  ALU-THM_TC-BV-SUB-LEMMA ALU-THM_TC-BV-SUB-LEMMA2 DIFF-PLUS-CANCELLATION-HACK2
  DIFF-PLUS-SUB1-HACK1 ALU-THM_TC-BV-SUBB-LEMMA1 DIFF-PLUS-SUB1-HACK2
  ALU-THM_TC-BV-SUBB-LEMMA2-LEMMA1 DIFF-PLUS-SUB1-HACK2-OFF
  ALU-THM_TC-BV-SUBB-LEMMA2 V-TO-INT-INT-TO-V-0 my-LENGTH-INT-TO-V
  ALU-THM_TC-BV-DECR-LEMMA1 ALU-THM_TC-BV-DECR-LEMMA2 IPLUS-0-2
  ALU-THM_TC-BV-NEG-LEMMA1 ALU-THM_TC-BV-NEG-LEMMA2 ALU-THM_TC-BV-NEG-LEMMA3
  ALU-THM_TC-BV-NEG-LEMMA4 ALU-THM_TC-BV-NEG-LEMMA5 ALU-THM_TC-BV-NEG-LEMMA6
  DIFF-PLUS-PLUS-PLUS-CANCELLATION ALU-THM_TC-BV-ADD-LEMMA1
  ALU-THM_TC-BV-ADD-LEMMA2 ALU-THM_TC-BV-ADDC-LEMMA1 ALU-THM_TC-BV-ADDC-LEMMA2
  ALU-THM_TC-BV-ADDC-LEMMA3-KILLER1 ALU-THM_TC-BV-ADDC-LEMMA3-KILLER2
  ALU-THM_TC-BV-ADDC-LEMMA3-KILLER3 ALU-THM_TC-BV-ADDC-LEMMA3-LEMMA1
  ALU-THM_TC-BV-ADDC-LEMMA3-LEMMA2 ALU-THM_TC-BV-ADDC-LEMMA3-KILLER1-OFF
  ALU-THM_TC-BV-ADDC-LEMMA3-KILLER2-OFF ALU-THM_TC-BV-ADDC-LEMMA3-KILLER3-OFF
  ALU-THM_TC-BV-ADDC-LEMMA3 ALU-THM_TC-BV-ADDC-LEMMA4-LEMMA1
  ALU-THM_TC-BV-ADDC-LEMMA4 ALU-THM_TC-V-ADDC-LEMMA1 ALU-THM_TC-V-ADDC-LEMMA2
  ALU-THM_TC-V-ADDC-LEMMA3 ALU-THM_TC-V-ADDC-LEMMA4 ALU-THM_TC-V-ADDC-LEMMA5
  ALU-THM_TC-V-ADDC-LEMMA6 ALU-THM_TC-V-ADDC-LEMMA7 ALU-THM_TC-V-ADDC-LEMMA8
  ALU-THM_TC-BV-INCR-LEMMA1 ALU-THM_TC-BV-INCR-LEMMA2 BV V C
  V-ALU-CORRECT-INT-REWRITER UNLABEL I-USR-DATA-TYPEP))

; This completes our rule base for the alu.  We should now be able
; to reduce any bv-alu-cv expression that arises.

; This completes the preliminary pass from m down to fm9001.


; I now prove a few useful equivalences between
; concepts at the m level and concepts at the i level.

(prove-lemma nth-is-get (rewrite)
  (equal (nth n l) (get n l)))

(prove-lemma update-nth-is-put (rewrite)
  (implies (lessp n (length l))
           (equal (update-nth n l v)
                  (put v n l))))

; Goal:  v-to-nat-inverts-nat-to-v

; Subgoal: remainder-quotient-elim

; First we build up the classic proof of remainder-quotient-elim, doing
; a lot of arithmetic along the way.

(enable difference-elim)

(prove-lemma difference-elim-rewrite (rewrite)
 (implies (and (numberp x)
               (not (lessp x y)))
          (equal (plus (difference x y) y) x)))

(prove-lemma v-to-nat-inverts-nat-to-v (rewrite)
  (implies (small-naturalp n word-size)
           (equal (v-to-nat (nat-to-v n word-size))
                  n)))

; QED:  v-to-nat-inverts-nat-to-v


; Next I will speed up the handling of i-objectp-type for
; the case where the type is a quoted constant.

(prove-lemma i-objectp-type-simplifier (rewrite)
  (and (equal (i-objectp-type 'nat x i)
              (and (equal (type x) 'nat)
                   (equal (cddr x) nil)
                   (small-naturalp (untag x)
                                   (i-word-size i))))
       (equal (i-objectp-type 'int x i)
              (and (equal (type x) 'int)
                   (equal (cddr x) nil)
                   (small-integerp (untag x)
                                   (i-word-size i))))
       (equal (i-objectp-type 'bitv x i)
              (and (equal (type x) 'bitv)
                   (equal (cddr x) nil)
                   (bit-vectorp (untag x)
                                (i-word-size i))))
       (equal (i-objectp-type 'bool x i)
              (and (equal (type x) 'bool)
                   (equal (cddr x) nil)
                   (booleanp (untag x))))
       (equal (i-objectp-type 'addr x i)
              (and (equal (type x) 'addr)
                   (equal (cddr x) nil)
                   (adpp (untag x)
                         (i-usr-data-segment i))))
       (equal (i-objectp-type 'pc x i)
              (and (equal (type x) 'pc)
                   (equal (cddr x) nil)
                   (icode-labelp (untag x)
                                 (i-prog-segment i))))
       (equal (i-objectp-type 'subr x i)
              (and (equal (type x) 'subr)
                   (equal (cddr x) nil)
                   (adpp (cons (untag x) 0)
                         (i-prog-segment i))))
       (equal (i-objectp-type 'sys-addr x i)
              (and (equal (type x) 'sys-addr)
                   (equal (cddr x) nil)
                   (adpp (untag x)
                         (i-sys-data-segment i))))
       (equal (i-objectp-type 'ipc x i)
              (and (equal (type x) 'ipc)
                   (equal (cddr x) nil)
                   (adpp (untag x) (i-prog-segment i))))))

(disable i-objectp-type)


; I will disable type, tag and untag for sanity's sake,
; but prove the obvious relationships first.

(prove-lemma type-tag (rewrite)
  (equal (type (tag x y)) x))

(prove-lemma untag-tag (rewrite)
  (equal (untag (tag x y)) y))

(disable type)
(disable tag)
(disable untag)

; And I will do a similar thing for the adp handlers

(prove-lemma adp-name-cons (rewrite)
 (equal (adp-name (cons name offset)) name))
(prove-lemma adp-offset-cons (rewrite)
 (equal (adp-offset (cons name offset)) offset))
(prove-lemma adp-name-add-adp (rewrite)
 (equal (adp-name (add-adp adp n))
        (adp-name adp)))
(prove-lemma adp-offset-add-adp (rewrite)
 (equal (adp-offset (add-adp adp n))
        (plus (adp-offset adp) n)))
(prove-lemma adp-name-sub-adp (rewrite)
 (equal (adp-name (sub-adp adp n))
        (adp-name adp)))
(prove-lemma adp-offset-sub-adp (rewrite)
 (equal (adp-offset (sub-adp adp n))
        (difference (adp-offset adp) n)))
(disable sub-adp)
(disable add-adp)
(disable adp-name)
(disable adp-offset)

; The function BOOLEANP is a killer because it
; causes everything to split.  I will disable it
; and prove what I need about it as necessary.

(disable booleanp)

(disable bool-to-logical)

; I am now going to partition the conjunctions of i-state-okp
; into two pots.  The first pot will put into the function
; defined below, i-state-types-okp, which will remain disabled.
; I will extract stuff from this hyp by back chaining when
; necessary.

(defn i-state-types-okp (i)
  (and 
    (i-statep i)
    (equal (type (i-pc i)) 'ipc)
    (equal (cddr (i-pc i)) nil)
    (listp (untag (i-pc i)))
    (definedp (adp-name (untag (i-pc i)))
              (i-prog-segment i))
    (equal (type (i-cfp i)) 'sys-addr)
    (listp (untag (i-cfp i)))
    (equal (adp-name (untag (i-cfp i)))
           'cstk)
    (equal (cddr (i-cfp i)) nil)
    (definedp 'cstk
              (i-sys-data-segment i))
    (equal (type (i-csp i)) 'sys-addr)
    (listp (untag (i-csp i)))
    (equal (adp-name (untag (i-csp i)))
           'cstk)
    (equal (cddr (i-csp i)) nil)
    (equal (type (i-tsp i)) 'sys-addr)
    (listp (untag (i-tsp i)))
    (equal (adp-name (untag (i-tsp i)))
           'tstk)
    (equal (cddr (i-tsp i)) nil)
    (definedp 'tstk
              (i-sys-data-segment i))
    (equal (type (i-c-flg i)) 'bool)
    (equal (cddr (i-c-flg i)) nil)
    (booleanp (untag (i-c-flg i)))
    (equal (type (i-v-flg i)) 'bool)
    (equal (cddr (i-v-flg i)) nil)
    (booleanp (untag (i-v-flg i)))
    (equal (type (i-n-flg i)) 'bool)
    (equal (cddr (i-n-flg i)) nil)
    (booleanp (untag (i-n-flg i)))
    (equal (type (i-z-flg i)) 'bool)
    (equal (cddr (i-z-flg i)) nil)
    (booleanp (untag (i-z-flg i)))))

; The second pot will be introduced explicitly into any clause
; containing i-state-okp.  These hyps will all be useful to
; linear and I don't want to hide them.

; Here is the lemma that does the restructuring.

(prove-lemma i-state-okp-restructuring (rewrite)
  (equal (i-state-okp i load-addr)
         (and (i-state-types-okp i)
              (numberp (adp-offset (untag (i-pc i))))
              (lessp (adp-offset (untag (i-pc i)))
                     (length (cdr (assoc (adp-name (untag (i-pc i)))
                                         (i-prog-segment i)))))
              (numberp (adp-offset (untag (i-cfp i))))
              (lessp (adp-offset (untag (i-cfp i)))
                     (length (cdr (assoc 'cstk
                                         (i-sys-data-segment i)))))
              (numberp (adp-offset (untag (i-csp i))))
              (lessp (adp-offset (untag (i-csp i)))
                     (length (cdr (assoc 'cstk
                                         (i-sys-data-segment i)))))
              (numberp (adp-offset (untag (i-tsp i))))
              (lessp (adp-offset (untag (i-tsp i)))
                     (length (cdr (assoc 'tstk
                                         (i-sys-data-segment i)))))
              (lessp (plus load-addr
                           (segment-length (i-prog-segment i))
                           (segment-length (i-usr-data-segment i))
                           (segment-length (i-sys-data-segment i)))
                     (exp 2 (i-word-size i))))))

(disable i-state-okp)

; And here is the lemma that lets me back chain into i-state-types-okp.

(prove-lemma i-state-types-okp-properties (rewrite)
  (implies (i-state-types-okp i)
           (and 
             (i-statep i)
             (equal (type (i-pc i)) 'ipc)
             (equal (cddr (i-pc i)) nil)
             (equal (listp (untag (i-pc i))) t)
             (definedp (adp-name (untag (i-pc i)))
                       (i-prog-segment i))
             (equal (type (i-cfp i)) 'sys-addr)
             (equal (listp (untag (i-cfp i))) t)
             (equal (adp-name (untag (i-cfp i)))
                    'cstk)
             (equal (cddr (i-cfp i)) nil)
             (definedp 'cstk
                       (i-sys-data-segment i))
             (equal (type (i-csp i)) 'sys-addr)
             (equal (listp (untag (i-csp i))) t)
             (equal (adp-name (untag (i-csp i)))
                    'cstk)
             (equal (cddr (i-csp i)) nil)
             (equal (type (i-tsp i)) 'sys-addr)
             (equal (listp (untag (i-tsp i))) t)
             (equal (adp-name (untag (i-tsp i)))
                    'tstk)
             (equal (cddr (i-tsp i)) nil)
             (definedp 'tstk
                       (i-sys-data-segment i))
             (equal (type (i-c-flg i)) 'bool)
             (equal (cddr (i-c-flg i)) nil)
             (booleanp (untag (i-c-flg i)))
             (equal (type (i-v-flg i)) 'bool)
             (equal (cddr (i-v-flg i)) nil)
             (booleanp (untag (i-v-flg i)))
             (equal (type (i-n-flg i)) 'bool)
             (equal (cddr (i-n-flg i)) nil)
             (booleanp (untag (i-n-flg i)))
             (equal (type (i-z-flg i)) 'bool)
             (equal (cddr (i-z-flg i)) nil)
             (booleanp (untag (i-z-flg i))))))

(disable i-state-types-okp)

; Some accellerators for psw handling...

(prove-lemma not-equal-x-y-error-msg-run (rewrite)
  (not (equal (x-y-error-msg x y) 'run)))

(disable x-y-error-msg)

(prove-lemma i-psw-i-halt (rewrite)
  (equal (i-psw (i-halt i psw)) psw))

(disable i-halt)


; Disabling some messy functions.

; I will disable a bunch of functions that cause large case
; splits.  These functions will have to be explicitly enabled
; to do proofs about their values.

(prove-lemma link-instr-word-expander (rewrite)
  (equal (link-instr-word (cons opcode nil) word-size)
         (mci (cadr (assoc opcode
                           (link-instruction-alist)))
              word-size)))

(disable link-instr-word)

(prove-lemma link-data-word-expander (rewrite)
  (implies (litatom (type x))
           (equal (link-data-word x link-tables word-size)
                  (case (type x)
                    (nat (nat-to-v (untag x) word-size))
                    (int (int-to-v (untag x) word-size))
                    (bitv (bitv-to-v (untag x) word-size))
                    (bool (BOOL-TO-V (untag x) word-size))
                    (addr (ADDR-TO-V (untag x)
                                      (usr-data-links link-tables)
                                      word-size))
                    (subr (subr-to-v (untag x)
                                      (prog-links link-tables)
                                      word-size))
                    (sys-addr (sys-addr-to-v (untag x)
                                              (sys-data-links link-tables)
                                              word-size))
                    (pc (label-to-v (untag x)
                                     (prog-label-tables link-tables)
                                     word-size))
                    (ipc (ipc-to-v (untag x)
                                    (prog-links link-tables)
                                    word-size))
                    (otherwise (nat-to-v 0 word-size))))))

(prove-lemma size-incr (rewrite)
  (equal (length (incr c a)) (length a)))

(prove-lemma size-compl (rewrite)
  (equal (length (v-not a)) (length a)))

(prove-lemma size-bitv-to-v (rewrite)
  (equal (length (bitv-to-v a word-size)) (fix word-size)))

(prove-lemma size-link-data-word (rewrite)
 (equal (length (link-data-word x link-tables word-size))
        (fix word-size)))

(disable link-data-word)

(disable *1*exp)

(prove-lemma size-link-instr-word (rewrite)
  (equal (length (link-instr-word ins word-size))
         (fix word-size))
  ((enable link-instr-word)
   (disable *1*link-instruction-alist link-instruction-alist
            extract-op extract-move-bits extract-cvnz extract-mode
            extract-reg)))

(prove-lemma size-link-word (rewrite)
  (equal (length (link-word x link-tables word-size))
         (fix word-size)))

(prove-lemma link-word-expander (rewrite)
  (and (implies (icode-instructionp x)
                (equal (link-word x link-tables word-size)
                       (link-instr-word x word-size)))
       (implies (not (icode-instructionp x))
                (equal (link-word x link-tables word-size)
                       (link-data-word x link-tables word-size)))))

(disable link-word)

; I am going to keep the i-link-tables function turned off and
; enable it as needed.  It expands into something I don't like
; reading.  Instead I'll prove the rewrite rules that let the
; four accessors work on it.

(prove-lemma prog-links-i-link-tables (rewrite)
  (equal (prog-links (i-link-tables i load-addr))
         (link-table-for-segment
          (i-prog-segment i)
          (plus load-addr
                (segment-length (i-usr-data-segment i))))))

(prove-lemma prog-label-tables-i-link-tables (rewrite)
  (equal (prog-label-tables (i-link-tables i load-addr))
         (link-table-for-prog-labels
          (i-prog-segment i)
          (plus load-addr
                (segment-length (i-usr-data-segment i))))))

(prove-lemma usr-data-links-i-link-tables (rewrite)
  (equal (usr-data-links (i-link-tables i load-addr))
         (link-table-for-segment (i-usr-data-segment i)
                                 load-addr)))

(prove-lemma sys-data-links-i-link-tables (rewrite)
  (equal (sys-data-links (i-link-tables i load-addr))
         (link-table-for-segment
          (i-sys-data-segment i)
          (plus load-addr
                (segment-length (i-prog-segment i))
                (segment-length (i-usr-data-segment i))))))

(disable i-link-tables)
(disable prog-links)
(disable prog-label-tables)
(disable usr-data-links)
(disable sys-data-links)

; Goal:  The fundamental theorems about Link Tables



(prove-lemma assoc-append (rewrite)
  (equal (assoc x (append alist1 alist2))
         (if (definedp x alist1)
             (assoc x alist1)
             (assoc x alist2))))

(prove-lemma get-append-1 (rewrite)
  (implies (lessp n (length a))
           (equal (get n (append a b))
                  (get n a))))

(prove-lemma get-append-2 (rewrite)
  (implies (equal n (length a))
           (equal (get (plus n k) (append a b))
                  (get k b))))

; Because we have swapped the positions of the data and prog
; segments we have to add the following version of get-append-2.
; Unknownst to me, the original proof exploited the fact that
; "i-prog-segment" comes lexicographically before "i-usr-data-segment"
; so that when the segment-lengths of those two are commuted into
; order the order agreed with that used by link-mem, namely,
; the prog-segment comes first.

(prove-lemma get-append-3 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2)))
           (equal (get (plus n2 n1 k)
                       (append a1 (append a2 b)))
                  (get k b)))
  ((disable get-append-2)
   (enable commutativity-of-plus commutativity2-of-plus)
   (use (get-append-2 (n n1)(a a1)(k (plus n2 k))(b (append a2 b)))
        (get-append-2 (n n2)(a a2)(k k)(b b)))))

(prove-lemma length-link-area-is-length (rewrite)
  (equal (length (link-area lst table word-size))
         (length lst)))

(enable associativity-of-append)

(prove-lemma get-link-area (rewrite)
  (implies (lessp n (length area))
           (equal (get n (link-area area table word-size))
                  (link-word (unlabel (get n area)) table word-size))))

(defn link-table-entry (name segment)
  (if (nlistp segment)
      0
      (if (equal name (caar segment))
          0
          (plus (length (cdar segment))
                (link-table-entry name (cdr segment))))))


(defn label-table-entry (lab segment)
  (find-label lab (cdr (assoc (car lab) segment))))


(prove-lemma assoc-link-table-for-segment (rewrite)
  (implies (and (definedp name segment)
                (numberp addr0))
           (equal (cdr (assoc name (link-table-for-segment segment addr0)))
                  (plus addr0 (link-table-entry name segment)))))

(prove-lemma lessp-absolute-address-segment-length-generalized nil
  (implies (and (definedp name segment)
                (lessp offset (length (cdr (assoc name segment)))))
           (lessp (plus (link-table-entry name segment) offset)
                  (segment-length segment))))

;  In anticipation of the various uses of this fact, we prove four
;  instances...

(prove-lemma lessp-absolute-address-segment-length-adp-name (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (lessp (adp-offset adp)
                       (length (cdr (assoc (adp-name adp) segment)))))
           (lessp (plus (link-table-entry (adp-name adp) segment)
                        (adp-offset adp))
                  (segment-length segment)))
  ((use (lessp-absolute-address-segment-length-generalized
          (name (adp-name adp))
          (offset (adp-offset adp))))))

(prove-lemma lessp-absolute-address-segment-length-cfp (rewrite)
  (implies (and (definedp 'cstk (i-sys-data-segment i))
                (lessp (adp-offset (untag (i-cfp i)))
                       (length (cdr (assoc 'cstk
                                           (i-sys-data-segment i))))))
           (lessp (plus (link-table-entry 'cstk
                                          (i-sys-data-segment i))
                        (adp-offset (untag (i-cfp i))))
                  (segment-length (i-sys-data-segment i))))
  ((use (lessp-absolute-address-segment-length-generalized
          (name 'cstk)
          (offset (adp-offset (untag (i-cfp i))))
          (segment (i-sys-data-segment i))))))

(prove-lemma lessp-absolute-address-segment-length-csp (rewrite)
  (implies (and (definedp 'cstk (i-sys-data-segment i))
                (lessp (adp-offset (untag (i-csp i)))
                       (length (cdr (assoc 'cstk
                                           (i-sys-data-segment i))))))
           (lessp (plus (link-table-entry 'cstk
                                          (i-sys-data-segment i))
                        (adp-offset (untag (i-csp i))))
                  (segment-length (i-sys-data-segment i))))
  ((use (lessp-absolute-address-segment-length-generalized
          (name 'cstk)
          (offset (adp-offset (untag (i-csp i))))
          (segment (i-sys-data-segment i))))))

(prove-lemma lessp-absolute-address-segment-length-tsp (rewrite)
  (implies (and (definedp 'tstk (i-sys-data-segment i))
                (lessp (adp-offset (untag (i-tsp i)))
                       (length (cdr (assoc 'tstk
                                           (i-sys-data-segment i))))))
           (lessp (plus (link-table-entry 'tstk
                                          (i-sys-data-segment i))
                        (adp-offset (untag (i-tsp i))))
                  (segment-length (i-sys-data-segment i))))
  ((use (lessp-absolute-address-segment-length-generalized
          (name 'tstk)
          (offset (adp-offset (untag (i-tsp i))))
          (segment (i-sys-data-segment i))))))

(enable length-append)

(prove-lemma length-link-segment-is-segment-length (rewrite)
             (equal (length (link-segment segment table word-size))
                    (segment-length segment)))

(disable commutativity-of-plus)

(prove-lemma get-link-table-entry-link-segment (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (lessp (adp-offset adp)
                       (length (cdr (assoc (adp-name adp) segment)))))
           (equal (get (plus (link-table-entry (adp-name adp) segment)
                             (adp-offset adp))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (adp-offset adp)
                           (cdr (assoc (adp-name adp) segment))))
                    table
                    word-size))))

; The above lemma states the fundamental relationship between
; linking and fetching.

; At this point we have enough machinery to reduce any legal
; current-instruction fetch at the m level to a link-word of the
; i level.

; We can speed things up in the subsequent proofs if we package
; this knowledge up.  We do it by proving a fact about
; current-instruction.  We still need the foregoing machinery for
; those occasions when the m machine fetches data from program memory.
; But after this we will disable current-instruction and at least
; short circuit all this for the top level fetch for each instruction.


; We first make it possible to get and put past the boot-code in
; linked memory.  By doing it this way (proving length-boot-code to introduce
; fix and this disabling it when we are done) we prevent all future
; splits on whether load-addr is numeric.

(prove-lemma length-boot-code (rewrite)
  (equal (length (boot-code lst n word-size)) (fix n)))

(prove-lemma get-past-boot-code (rewrite)
  (equal (get (plus load-addr n)
              (append (boot-code boot-lst load-addr word-size) a))
         (get n a)))

; When the address in question has been incremented or decremented,
; as happens when it is a stack pointer, we need:

(prove-lemma get-past-boot-code-add1 (rewrite)
  (equal (get (add1 (plus load-addr n))
              (append (boot-code boot-lst load-addr word-size) a))
         (get (add1 n) a))
  ((disable get-past-boot-code)
   (use (get-past-boot-code (n (add1 n))))))

(prove-lemma get-past-boot-code-sub1 (rewrite)
  (implies (not (zerop n))
           (equal (get (sub1 (plus load-addr n))
                       (append (boot-code boot-lst load-addr word-size) a))
                  (get (sub1 n) a)))
  ((disable get-past-boot-code)
   (use (get-past-boot-code (n (sub1 n))))))

(prove-lemma put-past-boot-code (rewrite)
  (equal (put val
              (plus load-addr n)
              (append (boot-code boot-lst load-addr word-size) a))
         (append (boot-code boot-lst load-addr word-size)
                 (put val n a))))

(prove-lemma put-past-boot-code-add1 (rewrite)
  (equal (put val
              (add1 (plus load-addr n))
              (append (boot-code boot-lst load-addr word-size) a))
         (append (boot-code boot-lst load-addr word-size)
                 (put val (add1 n) a)))
  ((disable put-past-boot-code)
   (use (put-past-boot-code (n (add1 n))))))

(prove-lemma put-past-boot-code-sub1 (rewrite)
  (implies (not (zerop n))
           (equal (put val
                       (sub1 (plus load-addr n))
                       (append (boot-code boot-lst load-addr word-size) a))
                  (append (boot-code boot-lst load-addr word-size)
                          (put val (sub1 n) a))))
  ((disable put-past-boot-code)
   (use (put-past-boot-code (n (sub1 n))))))

(prove-lemma length-boot-code-linear (rewrite)
  (and (not (lessp load-addr (length (boot-code boot-lst load-addr word-size))))
       (not (lessp (length (boot-code boot-lst load-addr word-size)) load-addr))))

(disable length-boot-code)

(prove-lemma current-instruction-i->m (rewrite)
  (implies
    (and (i-state-types-okp i)
         (numberp (adp-offset (untag (i-pc i))))
         (lessp (adp-offset (untag (i-pc i)))
                (length (cdr (assoc (adp-name (untag (i-pc i)))
                                    (i-prog-segment i)))))
         (lessp (plus load-addr
                      (segment-length (i-prog-segment i))
                      (segment-length (i-usr-data-segment i))
                      (segment-length (i-sys-data-segment i)))
                (exp 2 32))
         (equal (i-word-size i) 32))
    (equal
      (current-instruction
       (list r0 r1 r2 r3 r4 r5 r6 r7
             r8 r9 r10 r11 r12 r13 r14
             (nat-to-v
              (plus load-addr
                    (segment-length (i-usr-data-segment i))
                    (link-table-entry (adp-name (untag (i-pc i)))
                                      (i-prog-segment i))
                    (adp-offset (untag (i-pc i))))
              32))
       (append (boot-code boot-lst load-addr 32)
               (append (LINK-SEGMENT (I-USR-DATA-SEGMENT I) 
                                     (I-LINK-TABLES I LOAD-ADDR) 
                                     32)
                       (append
                        (link-segment
                         (i-prog-segment i)
                         (i-link-tables i load-addr)
                         32)
                        data-mem))))
      (link-word (unlabel
                   (fetch (i-pc i) (i-prog-segment i)))
                 (i-link-tables i load-addr)
                 32)))
  ((enable i-state-types-okp)))

(disable current-instruction)
                  
; The following section of this file documents about a half-day's
; work.

; I am headed for a simple theorem, namely that the i-psw of
; i-ins-step is 'run.  This follows immediately by opening up
; the -step fn for each i-level opcode and observing that the
; i-psw in each is 'run.  But there is much case analysis.
; To help out, I will disable -- in fact, hands-off -- every
; function used by any of the -step fns.  In addition, I provide
; the following accelerators:

(prove-lemma equal-i-psw-if-1 (rewrite)
  (equal (equal (i-psw (if t1 b1 b2)) 'run)
         (if t1
             (equal (i-psw b1) 'run)
             (equal (i-psw b2) 'run))))

(prove-lemma equal-i-psw-if-2 (rewrite)
  (equal (equal (i-psw (if t1 b1 (if t2 b2 b3))) 'run)
         (if t1
             (equal (i-psw b1) 'run)
             (if t2
                 (equal (i-psw b2) 'run)
                 (equal (i-psw b3) 'run)))))

(prove-lemma equal-i-psw-i-ins-step-run (rewrite)
  (equal (i-psw (i-ins-step ins i load-addr)) 'run)
  ((hands-off
    lsh-bitv times add-addr small-naturalp fix-small-natural and-bitv
    and-bool sub1 remainder quotient rsh-bitv inegate not-bitv or-bitv
    or-bool sub-addr offset exp difference plus lessp small-integerp
    not bool-to-nat iplus idifference fix-small-integer area-name
    definition ipc negativep pop-stk push-stk xor-bitv i-nextword untag
    xor-bool i-z-flg add2-i-pc i-word-size tag deposit
    i-usr-data-segment i-prog-segment i-sys-data-segment fetch xor-xxx
    all-zero-bitvp bool i-n-flg i-v-flg i-c-flg i-y i-x i-tsp i-csp
    i-cfp add1-i-pc i-state pack cons add1 zero)))

; Note: The hint above was mechanically generated; it is the list of
; all function symbols occurring in the body of any i-xxx-step fn, minus
; i-psw.  We clearly do not wish to keep hands off of (i-psw (i-state ...)).

; During the morning I have proved this theorem many times.  Here are
; some observations.  I don't remember what happens if you try it without
; any preparation, but either it explodes into many cases or it gets
; stack overflow.  I first included just a (hands-off i-state) under
; the mistaken belief that it would prevent all the (i-state ...)'s from
; being rewritten.  But it does not prevent the args to the i-state being
; rewritten so I disabled all the fns listed above.  However, that still
; permitted rewrite rules to be applied to them and so I did a hands-off
; on them instead.

; More interesting is the use of the two lemmas, equal-i-psw-if-1 and -2.
; The first I call the "single stripper" and the second the "double stripper."

; With just the single stripper around you get a stack overflow.  That is
; because rewrite recurses several times for every application of the
; lemma and there are so many opcodes.  My first attempt to solve this
; was to prove a backchaining version of the single stripper.  It said
; "if the psw of b and c are both 'run then the psw of (if a b c) is too."
; That causes fewer recursions in the rewriter and permitted the proof
; to go through, but cost 8538 seconds!  

; Then I hit upon the idea of the double stripper, which cuts in half the
; number of applications -- and this recursions -- necessary.  If the
; double stripper is available but the single stripper is not, the
; proof goes through but generates 30 cases and takes 354 seconds.

; Analysis of this showed that the problem is that some of our -step
; fns generate terms of the form (if & (i-state ...) (i-state ...)) and
; the double stripper could not be applied to these.  They get elevated
; to explicit cases.

; If both strippers are present, the proof goes through without any
; visible cases and takes 46 seconds.

; End of aside.

; In the one-way correspondence theorems I have the hypothesis
; that (i-step i load-addr) does not produce an error and then I make a
; statement about (i->m (i-step i load-addr) boot-lst load-addr).  The two occurrences of
; i-step bother me and the following theorem lets me replace the
; first with a conjunction of predicates.

(prove-lemma i-psw-i-step-run (rewrite)
  (equal (equal (i-psw (i-step i load-addr)) 'run)
         (and (equal (i-psw i) 'run)
              (i-state-okp i load-addr)
              (i-ins-okp (i-current-instruction i) i)))
  ((disable i-ins-okp i-ins-step i-current-instruction)))

(prove-lemma i-link-tables-i-state (rewrite)
  (implies (and (equal (link-table-for-segment
                         i-usr-data-segment
                         load-addr)
                       (link-table-for-segment
                         (i-usr-data-segment i)
                         load-addr))
                (equal (segment-length i-usr-data-segment)
                       (segment-length (i-usr-data-segment i)))
                (equal (link-table-for-segment
                         i-sys-data-segment
                         (plus load-addr
                               (segment-length (i-prog-segment i))
                               (segment-length (i-usr-data-segment i))))
                       (link-table-for-segment
                         (i-sys-data-segment i)
                         (plus load-addr
                               (segment-length (i-prog-segment i))
                               (segment-length (i-usr-data-segment i))))))
           (equal (i-link-tables (i-state pc cfp csp tsp
                                          x y c-flg v-flg n-flg z-flg
                                          (i-prog-segment i)
                                          i-usr-data-segment
                                          i-sys-data-segment
                                          word-size
                                          psw)
                                 load-addr)
                  (i-link-tables i load-addr)))
  ((enable i-link-tables)))


; Now I will embark on the proofs of each of one-way correspondence
; step theorems, starting with what I think is the simplest: the
; no-op case.

(enable plus-add1)

(prove-lemma get-add1-cons (rewrite)
  (equal (get (add1 n) (cons x y))
         (get n y)))

(prove-lemma get-0-cons (rewrite)
  (equal (get 0 (cons x y)) x))

(enable length-cons)

(prove-lemma length-reg-file (rewrite)
  (equal (length
           (list r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15))
         16))

(prove-lemma put-add1-cons (rewrite)
  (equal (put val (add1 n) (cons x y))
         (cons x (put val n y))))

(prove-lemma put-zero-cons (rewrite)
  (equal (put val 0 (cons x y))
         (cons val y)))

(prove-lemma boolp-bool-to-logical (rewrite)
  (boolp (bool-to-logical b)))

(prove-lemma i-state-types-okp-property2 (rewrite)
  (implies (i-state-types-okp i)
           (and (not (icode-instructionp (i-pc i)))
                (not (icode-instructionp (i-cfp i)))
                (not (icode-instructionp (i-csp i)))
                (not (icode-instructionp (i-tsp i)))
                (not (icode-instructionp (i-c-flg i)))
                (not (icode-instructionp (i-v-flg i)))
                (not (icode-instructionp (i-n-flg i)))
                (not (icode-instructionp (i-z-flg i)))))
  ((enable i-state-types-okp untag)))

(prove-lemma not-icode-instructionp-tag (rewrite)
  (not (icode-instructionp (tag type obj)))
  ((enable tag)))

(disable icode-instructionp)


(prove-lemma length-put (rewrite)
  (implies (lessp n (length lst))
           (equal (length (put v n lst))
                  (length lst))))

(prove-lemma nat-to-v-equivalence (rewrite)
  (implies (and (numberp n)
                (numberp m)
                (lessp n (exp 2 word-size))
                (lessp m (exp 2 word-size)))
           (equal (equal (nat-to-v n word-size)
                         (nat-to-v m word-size))
                  (equal n m))))



; --- Here I take time out in my development to define a few
; functions used to make slides for my Piton talk.

(defn list-of-bvs (lst)
 (if (nlistp lst)
     nil
     (cons (nat-to-v (car lst) 32)
           (list-of-bvs (cdr lst)))))

(defn n->m (n)
  (m-state (list-of-bvs (car n))
           (cadr n)
           (caddr n)
           (cadddr n)
           (caddddr n)
           (list-of-bvs (cadddddr n))))

(defn m->n (m)
  (list (list-of-nats (m-regs m))
        (m-c-flg m)
        (m-v-flg m)
        (m-n-flg m)
        (m-z-flg m)
        (list-of-nats (m-mem m))))

(defn n-step (n)
  (m->n (m-step (n->m n))))

; --- end of aside

; Recall



;(prove-lemma get-link-table-entry-link-segment (rewrite)
;  (implies (and (definedp (adp-name adp) segment)
;               (lessp (adp-offset adp)
;                      (length (cdr (assoc (adp-name adp) segment)))))
;          (equal (get (plus (link-table-entry (adp-name adp) segment)
;                            (adp-offset adp))
;                      (link-segment segment table word-size))
;                 (link-word
;                   (unlabel
;                     (get (adp-offset adp)
;                          (cdr (assoc (adp-name adp) segment))))
;                   table
;                   word-size))))
;

; from above.  Analogous lemmas for the data segment and the
; stack segment are needed.  In addition, we need to be able to handle
; the arithmetically equivalent cases that arise from opening plus
; or incrementing and decrementing addresses.  We'll do that first
; and then turn to the other segments and the add1/sub1 cases for them.

(prove-lemma plus-zerop (rewrite)
  (implies (not (numberp y))
           (equal (plus x y) (fix x))))

(prove-lemma get-link-table-entry-link-segment-add1 (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (lessp (add1 (adp-offset adp))
                       (length (cdr (assoc (adp-name adp) segment)))))
           (equal (get (add1 (plus (link-table-entry (adp-name adp) segment)
                                   (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (add1 (adp-offset adp))
                           (cdr (assoc (adp-name adp) segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment (adp (add1-adp adp))))
   (disable get-link-table-entry-link-segment)))

(prove-lemma plus-sub1 (rewrite)
  (implies (not (zerop y))
           (equal (plus x (sub1 y))
                  (sub1 (plus x y)))))

;  The above lemma causes infinite looping if plus opens and commutes.
;  So I'll disable it asap.

(prove-lemma get-link-table-entry-link-segment-sub1 (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (not (zerop (sub1 (adp-offset adp))))
                (lessp (adp-offset adp)
                       (length (cdr (assoc (adp-name adp) segment)))))
           (equal (get (sub1 (plus (link-table-entry (adp-name adp) segment)
                                   (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (sub1 (adp-offset adp))
                           (cdr (assoc (adp-name adp) segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment (adp (sub1-adp adp))))
   (disable get-link-table-entry-link-segment)))

(disable plus-sub1)

; Before we work on the two data segments we do some
; similar trivial arithmetic for the add1/sub1 cases of
; the previously proved:

;
;(prove-lemma lessp-absolute-address-segment-length-adp-name (rewrite)
;  (implies (and (definedp (adp-name adp) segment)
;               (lessp (adp-offset adp)
;                      (length (cdr (assoc (adp-name adp) segment)))))
;          (lessp (plus (link-table-entry (adp-name adp) segment)
;                       (adp-offset adp))
;                 (segment-length segment)))
;  ((use (lessp-absolute-address-segment-length-generalized
;         (name (adp-name adp))
;         (offset (adp-offset adp))))))
;


(prove-lemma lessp-absolute-address-segment-length-adp-name-add1 (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (lessp (adp-offset adp)
                       (sub1 (length (cdr (assoc (adp-name adp) segment))))))
           (lessp (add1
                    (plus (link-table-entry (adp-name adp) segment)
                          (adp-offset adp)))
                  (segment-length segment)))
  ((use (lessp-absolute-address-segment-length-generalized
          (name (adp-name adp))
          (offset (add1 (adp-offset adp)))))))


;  We will undoubtedly need related facts about 'cstk and 'tsk, similar
; to lessp-absolute-address-segment-length-cfp, etc., above.  But I
; don't know the exact form we'll need so I'll wait...  Here however
; are the related lemmas in their pure form



;(prove-lemma  (rewrite)
;  (implies (and (definedp 'cstk (i-sys-data-segment i))
;               (lessp (adp-offset (untag (i-cfp i)))
;                      (length (cdr (assoc 'cstk
;                                          (i-sys-data-segment i))))))
;          (lessp (plus (link-table-entry 'cstk
;                                         (i-sys-data-segment i))
;                       (adp-offset (untag (i-cfp i))))
;                 (segment-length (i-sys-data-segment i))))
;  ((use (lessp-absolute-address-segment-length-generalized
;         (name 'cstk)
;         (offset (adp-offset (untag (i-cfp i))))
;         (segment (i-sys-data-segment i))))))
;
;(prove-lemma lessp-absolute-address-segment-length-csp (rewrite)
;  (implies (and (definedp 'cstk (i-sys-data-segment i))
;               (lessp (adp-offset (untag (i-csp i)))
;                      (length (cdr (assoc 'cstk
;                                          (i-sys-data-segment i))))))
;          (lessp (plus (link-table-entry 'cstk
;                                         (i-sys-data-segment i))
;                       (adp-offset (untag (i-csp i))))
;                 (segment-length (i-sys-data-segment i))))
;  ((use (lessp-absolute-address-segment-length-generalized
;         (name 'cstk)
;         (offset (adp-offset (untag (i-csp i))))
;         (segment (i-sys-data-segment i))))))
;
;(prove-lemma lessp-absolute-address-segment-length-tsp (rewrite)
;  (implies (and (definedp 'tstk (i-sys-data-segment i))
;               (lessp (adp-offset (untag (i-tsp i)))
;                      (length (cdr (assoc 'tstk
;                                          (i-sys-data-segment i))))))
;          (lessp (plus (link-table-entry 'tstk
;                                         (i-sys-data-segment i))
;                       (adp-offset (untag (i-tsp i))))
;                 (segment-length (i-sys-data-segment i))))
;  ((use (lessp-absolute-address-segment-length-generalized
;         (name 'tstk)
;         (offset (adp-offset (untag (i-tsp i))))
;         (segment (i-sys-data-segment i))))))





; The previously proved:

;
;(prove-lemma get-append-2 (rewrite)
;  (implies (equal n (length a))
;          (equal (get (plus n k) (append a b))
;                 (get k b))))
;
; also needs to be expanded to the add1/sub1 cases:

(prove-lemma get-append-2-add1 (rewrite)
  (implies (equal n (length a))
           (equal (get (add1 (plus n k)) (append a b))
                  (get (add1 k) b)))
  ((use (get-append-2 (k (add1 k))))
   (disable get-append-2)))

(prove-lemma get-append-2-sub1 (rewrite)
  (implies (and (equal n (length a))
                (not (zerop k)))
           (equal (get (sub1 (plus n k)) (append a b))
                  (get (sub1 k) b)))
  ((use (get-append-2 (k (sub1 k))))
   (disable get-append-2)))

(prove-lemma get-append-3-add1 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2)))
           (equal (get (add1 (plus n2 n1 k))
                       (append a1 (append a2 b)))
                  (get (add1 k) b)))
  ((use (get-append-3 (k (add1 k))))
   (disable get-append-3)))

(prove-lemma get-append-3-sub1 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2))
                (not (zerop k)))
           (equal (get (sub1 (plus n2 n1 k))
                       (append a1 (append a2 b)))
                  (get (sub1 k) b)))
  ((use (get-append-3 (k (sub1 k))))
   (disable get-append-3)))

; Now it turns out we never increment or decrement addresses into the
; usr-data segment.  So we don't need lemmas for that.  But we do both
; operations on sys-data addresses when pushing and popping.  There
; is no difference between the usr-data and the sys-data accessing
; but it will turn out that we know that (adp-name (untag (i-csp i)))
; is 'cstk so we have to phrase the lemma explicitly for 'cstk and another
; one for tstk.

; Now for the sys-data segment, we just use the result above,
; but acknowledge that (adp-name adp) will be either 'cstk or 'tstk
; in all of our uses...

(prove-lemma get-link-table-entry-link-segment-cstk (rewrite)
  (implies (and (definedp 'cstk segment)
                (lessp (adp-offset adp)
                       (length (cdr (assoc 'cstk segment)))))
           (equal (get (plus (link-table-entry 'cstk segment)
                             (adp-offset adp))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (adp-offset adp)
                           (cdr (assoc 'cstk segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment
          (adp (cons 'cstk (adp-offset adp)))))
   (disable get-link-table-entry-link-segment)))

(prove-lemma get-link-table-entry-link-segment-tstk (rewrite)
  (implies (and (definedp 'tstk segment)
                (lessp (adp-offset adp)
                       (length (cdr (assoc 'tstk segment)))))
           (equal (get (plus (link-table-entry 'tstk segment)
                             (adp-offset adp))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (adp-offset adp)
                           (cdr (assoc 'tstk segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment
          (adp (cons 'tstk (adp-offset adp)))))
   (disable get-link-table-entry-link-segment)))

; and now, for both cstk and tstk, we get the pushed and popped
; versions.

(prove-lemma get-link-table-entry-link-segment-cstk-add1 (rewrite)
  (implies (and (definedp 'cstk segment)
                (lessp (adp-offset adp)
                       (sub1 (length (cdr (assoc 'cstk segment))))))
           (equal (get (add1
                         (plus (link-table-entry 'cstk segment)
                               (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel 
                      (get (add1 (adp-offset adp))
                           (cdr (assoc 'cstk segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment
          (adp (cons 'cstk (add1 (adp-offset adp))))))
   (disable get-link-table-entry-link-segment)))

(prove-lemma get-link-table-entry-link-segment-cstk-sub1 (rewrite)
  (implies (and (definedp 'cstk segment)
                (not (zerop (adp-offset adp)))
                (lessp (adp-offset adp)
                       (length (cdr (assoc 'cstk segment)))))
           (equal (get (sub1
                         (plus (link-table-entry 'cstk segment)
                               (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (sub1 (adp-offset adp))
                           (cdr (assoc 'cstk segment))))
                    table
                    word-size)))
  ((enable plus-sub1)
   (use (get-link-table-entry-link-segment
          (adp (cons 'cstk (sub1 (adp-offset adp))))))
   (disable get-link-table-entry-link-segment)))

(prove-lemma get-link-table-entry-link-segment-tstk-add1 (rewrite)
  (implies (and (definedp 'tstk segment)
                (lessp (adp-offset adp)
                       (sub1 (length (cdr (assoc 'tstk segment))))))
           (equal (get (add1
                         (plus (link-table-entry 'tstk segment)
                               (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (add1 (adp-offset adp))
                           (cdr (assoc 'tstk segment))))
                    table
                    word-size)))
  ((use (get-link-table-entry-link-segment
          (adp (cons 'tstk (add1 (adp-offset adp))))))
   (disable get-link-table-entry-link-segment)))

(prove-lemma get-link-table-entry-link-segment-tstk-sub1 (rewrite)
  (implies (and (definedp 'tstk segment)
                (not (zerop (adp-offset adp)))
                (lessp (adp-offset adp)
                       (length (cdr (assoc 'tstk segment)))))
           (equal (get (sub1
                         (plus (link-table-entry 'tstk segment)
                               (adp-offset adp)))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get (sub1 (adp-offset adp))
                           (cdr (assoc 'tstk segment))))
                    table
                    word-size)))
  ((enable plus-sub1)
   (use (get-link-table-entry-link-segment
          (adp (cons 'tstk (sub1 (adp-offset adp))))))
   (disable get-link-table-entry-link-segment)))

; We now need for put all of the stuff we have developed for get...

(prove-lemma put-append-1 (rewrite)
  (implies (lessp n (length a))
           (equal (put val n (append a b))
                  (append (put val n a) b))))

(prove-lemma put-append-2 (rewrite)
  (implies (equal n (length a))
           (equal (put val (plus n k) (append a b))
                  (append a (put val k b)))))

(prove-lemma put-append-3 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2)))
           (equal (put val
                       (plus n2 n1 k)
                       (append a1 (append a2 b)))
                  (append a1 (append a2 (put val k b)))))
  ((disable put-append-2)
   (enable commutativity-of-plus commutativity2-of-plus)
   (use (put-append-2 (n n1)(a a1)(k (plus n2 k))(b (append a2 b)))
        (put-append-2 (n n2)(a a2)(k k)(b b)))))

(prove-lemma put-append-2-add1 (rewrite)
  (implies (equal n (length a))
           (equal (put val (add1 (plus n k)) (append a b))
                  (append a (put val (add1 k) b))))
  ((use (put-append-2 (k (add1 k))))
   (disable put-append-2)))

(prove-lemma put-append-2-sub1 (rewrite)
  (implies (and (equal n (length a))
                (not (zerop k)))
           (equal (put val (sub1 (plus n k)) (append a b))
                  (append a (put val (sub1 k) b))))
  ((use (put-append-2 (k (sub1 k))))
   (disable put-append-2)
   (enable plus-sub1)))

(prove-lemma put-append-3-add1 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2)))
           (equal (put val
                       (add1 (plus n2 n1 k))
                       (append a1 (append a2 b)))
                  (append a1 (append a2 (put val (add1 k) b)))))
  ((disable put-append-3)
   (use (put-append-3 (k (add1 k))))))

(prove-lemma put-append-3-sub1 (rewrite)
  (implies (and (equal n1 (length a1))
                (equal n2 (length a2))
                (not (zerop k)))
           (equal (put val
                       (sub1 (plus n2 n1 k))
                       (append a1 (append a2 b)))
                  (append a1 (append a2 (put val (sub1 k) b)))))
  ((disable put-append-3)
   (use (put-append-3 (k (sub1 k))))))

(prove-lemma put-link-area (rewrite)
  (implies (lessp n (length lst))
           (equal (link-area (put val n lst)
                             tables
                             word-size)
                  (put (link-word (unlabel val) tables word-size)
                       n
                       (link-area lst tables word-size)))))

; Now we do for put and link-segment what we did for get and link-segment:

(prove-lemma put-link-segment (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (lessp (adp-offset adp)
                       (length (cdr (assoc (adp-name adp) segment)))))
           (equal (link-segment
                    (put-assoc
                     (put val
                          (adp-offset adp)
                          (cdr (assoc (adp-name adp) segment)))
                     (adp-name adp)
                     segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (plus (link-table-entry (adp-name adp) segment)
                             (adp-offset adp))
                       (link-segment segment tables word-size)))))

; And now we prove the cstk and tstk versions of the above, with
; the add1/sub1 variants.  These six lemmas, all just variations on
; the basic one above, should explain all of our deposits into the
; cstk and tstk areas.

(prove-lemma put-link-segment-cstk (rewrite)
  (implies (and (definedp 'cstk segment)
                (numberp stk-ptr)
                (lessp stk-ptr
                       (length (cdr (assoc 'cstk segment)))))
           (equal (link-segment
                    (put-assoc (put val stk-ptr
                                    (cdr (assoc 'cstk segment)))
                               'cstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (plus (link-table-entry 'cstk segment)
                             stk-ptr)
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'cstk stk-ptr))))
   (disable put-link-segment)))

(prove-lemma put-link-segment-tstk (rewrite)
  (implies (and (definedp 'tstk segment)
                (numberp stk-ptr)
                (lessp stk-ptr
                       (length (cdr (assoc 'tstk segment)))))
           (equal (link-segment
                    (put-assoc (put val stk-ptr (cdr (assoc 'tstk segment)))
                               'tstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (plus (link-table-entry 'tstk segment)
                             stk-ptr)
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'tstk stk-ptr))))
   (disable put-link-segment)))

(prove-lemma put-link-segment-cstk-add1 (rewrite)
  (implies (and (definedp 'cstk segment)
                (lessp (add1 stk-ptr)
                       (length (cdr (assoc 'cstk segment)))))
           (equal (link-segment
                    (put-assoc (put val (add1 stk-ptr)
                                    (cdr (assoc 'cstk segment)))
                               'cstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (add1
                         (plus (link-table-entry 'cstk segment)
                               stk-ptr))
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'cstk (add1 stk-ptr)))))
   (disable put-link-segment)))

(prove-lemma put-link-segment-cstk-sub1 (rewrite)
  (implies (and (definedp 'cstk segment)
                (not (zerop stk-ptr))
                (lessp stk-ptr
                       (length (cdr (assoc 'cstk segment)))))
           (equal (link-segment
                    (put-assoc (put val (sub1 stk-ptr)
                                    (cdr (assoc 'cstk segment)))
                               'cstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (sub1
                         (plus (link-table-entry 'cstk segment)
                               stk-ptr))
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'cstk (sub1 stk-ptr)))))
   (enable plus-sub1)
   (disable put-link-segment)))

(prove-lemma put-link-segment-tstk-add1 (rewrite)
  (implies (and (definedp 'tstk segment)
                (lessp (add1 stk-ptr)
                       (length (cdr (assoc 'tstk segment)))))
           (equal (link-segment
                    (put-assoc (put val (add1 stk-ptr)
                                    (cdr (assoc 'tstk segment)))
                               'tstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (add1
                         (plus (link-table-entry 'tstk segment)
                               stk-ptr))
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'tstk (add1 stk-ptr)))))
   (disable put-link-segment)))

(prove-lemma put-link-segment-tstk-sub1 (rewrite)
  (implies (and (definedp 'tstk segment)
                (not (zerop stk-ptr))
                (lessp stk-ptr
                       (length (cdr (assoc 'tstk segment)))))
           (equal (link-segment
                    (put-assoc (put val (sub1 stk-ptr)
                                    (cdr (assoc 'tstk segment)))
                               'tstk
                               segment)
                    tables
                    word-size)
                  (put (link-word (unlabel val) tables word-size)
                       (sub1
                         (plus (link-table-entry 'tstk segment)
                               stk-ptr))
                       (link-segment segment tables word-size))))
  ((use (put-link-segment (adp (cons 'tstk (sub1 stk-ptr)))))
   (enable plus-sub1)
   (disable put-link-segment)))

(prove-lemma definedp-put-assoc (rewrite)
  (equal (definedp name (put-assoc val name2 segment))
         (definedp name segment)))

(prove-lemma link-table-entry-put-assoc (rewrite)
  (implies (equal (length val)
                  (length (cdr (assoc name2 segment))))
           (equal (link-table-entry name (put-assoc val name2 segment))
                  (link-table-entry name segment))))

(prove-lemma link-table-for-segment-put-assoc (rewrite)
  (implies
    (equal (length val)
           (length (cdr (assoc name2 segment))))
    (equal (link-table-for-segment
             (put-assoc val name2 segment)
             addr)
           (link-table-for-segment segment addr))))

(prove-lemma equal-append (rewrite)
  (equal (equal (append a b)
                (append a c))
         (equal b c)))

; We also need...


(disable i-objectp)

(prove-lemma unlabel-i-objectp (rewrite)
  (implies (i-objectp x i) (equal (unlabel x) x))
  ((enable i-objectp unlabel type)))

(prove-lemma unlabel-tagged-object (rewrite)
  (implies (not (equal (type x) 'dl)) (equal (unlabel x) x))
  ((enable unlabel type)))

(prove-lemma link-area-put-unlabel (rewrite)
  (implies (i-objectp (unlabel val) i)
           (equal (link-area (put (unlabel val) n lst) tables word-size)
                  (link-area (put val n lst) tables word-size))))

(prove-lemma link-segment-put-unlabel (rewrite)
  (implies (i-objectp (unlabel val) i)
           (equal (link-segment
                    (put-assoc
                      (put (unlabel val)
                           offset
                           (cdr (assoc name segment)))
                      name
                      segment)
                    tables
                    word-size)
                  (link-segment
                    (put-assoc
                      (put val
                           offset
                           (cdr (assoc name segment)))
                      name
                      segment)
                    tables
                    word-size))))

(prove-lemma difference-1 (rewrite) (equal (difference x 1) (sub1 x)))

(disable int-to-v)

(prove-lemma tc-add-is-iplus (rewrite)
  (equal (tc-add x y) (iplus x y)))

(disable add)

(prove-lemma tc-in-rangep-is-small-integerp (rewrite)
  (implies (and (integerp x)
                (not (zerop word-size)))
           (equal (tc-in-rangep x word-size)
                  (small-integerp x word-size))))

(disable tc-in-rangep)

(enable integerp-iplus)

(prove-lemma small-integerp-implies-integerp (rewrite)
  (implies (small-integerp x word-size)
           (integerp x)))

(prove-lemma bitn-of-positive-is-f (rewrite)
  (implies (lessp i (exp 2 (sub1 word-size)))
           (equal (bitn (nat-to-v i word-size) word-size)
                  f)))

(prove-lemma lessp-exp-sub1-exp (rewrite)
  (implies (not (zerop word-size))
           (lessp (exp 2 (sub1 word-size))
                  (exp 2 word-size))))

(prove-lemma incr-f (rewrite)
  (implies (bvp b) (equal (incr f b) b)))

(prove-lemma compl-compl (rewrite)
  (implies (bvp b) (equal (v-not (v-not b)) b)))

(prove-lemma v-to-int-inverts-int-to-v-lemma1 (rewrite)
  (implies
         (and (numberp x)
              (not (equal x 0))
              (not (lessp (exp 2 (sub1 word-size)) x))
              (not (equal word-size 0))
              (numberp word-size))
         (equal
              (v-to-nat (incr t
                               (v-not (incr t
                                            (v-not (nat-to-v x word-size))))))
              x)))

(prove-lemma bitn-nat-to-v-0 (rewrite)
  (equal (bitn (nat-to-v 0 k) i)
         (if (zerop i)
             f
             (if (lessp k i) 0 f)))
  ((induct (lessp k i))))

; In fm8502 days we proved
; (prove-lemma not-zerop-size-implies-not-equal-bv-btm (rewrite)
;   (implies (not (zerop (length x)))
;            (not (equal x (btm)))))
; but I'm going with equal-length-0 now:

(enable equal-length-0)

(prove-lemma bitn-compl (rewrite)
  (implies (and (not (zerop n))
                (not (lessp (length b) n)))
           (equal (bitn (v-not b) n)
                  (not (bitn b n)))))

(prove-lemma times-non-numberp (rewrite)
  (implies (not (numberp x)) (equal (times y x) 0)))

(enable difference-plus-cancellation)

(prove-lemma remainder-times (rewrite)
  (equal (remainder (times x y) x) 0)
  ((induct (times y x))
   (expand (REMAINDER (PLUS X (TIMES X Z)) X))))

(prove-lemma remainder-exp-2-2 (rewrite)
  (equal (remainder (exp 2 x) 2)
         (if (zerop x) 1 0)))

(prove-lemma my-quotient-times (rewrite)
  (implies (not (zerop x))
           (equal (quotient (times x y) x)
                  (fix y)))
  ((induct (times y x))
   (expand (quotient (plus x (times x z)) x))))

(prove-lemma quotient-exp-2-2 (rewrite)
  (implies (not (zerop x))
           (equal (quotient (exp 2 x) 2)
                  (exp 2 (sub1 x)))))

(prove-lemma bitn-exp-2-sub1-word-size (rewrite)
  (implies (not (zerop word-size))
           (equal (bitn (nat-to-v (exp 2 (sub1 word-size))
                                   word-size)
                        word-size)
                  t))
  ((disable times)))

(prove-lemma bitn-of-negatives-is-t-lemma (rewrite)
  (implies (and (not (zerop word-size))
                (numberp x)
                (not (lessp (exp 2 (sub1 word-size))
                            x)))
           (equal (bitn (nat-to-v x word-size) word-size)
                  (equal x (exp 2 (sub1 word-size))))))

(prove-lemma bitn-of-negatives-is-t-lemma-hyp (rewrite)
  (implies (and (not (zerop word-size))
                (not (lessp (exp 2 word-size) i)))
           (not (lessp (exp 2 (sub1 word-size)) (quotient i 2)))))

(prove-lemma incr-f-is-noop (rewrite)
  (equal (bitn (incr f v) n)
         (if (lessp (length v) n)
             0
             (if (bitn v n) t f))))

(disable plus-commutes2)

(prove-lemma bitn-cons (rewrite)
  (equal (bitn (cons b v) i)
         (if (zerop i) f (if (equal i 1) b (bitn v (sub1 i))))))

(prove-lemma bitn-of-negatives-is-t (rewrite)
  (implies (and (not (zerop i))
                (not (zerop word-size))
                (not (lessp (exp 2 (sub1 word-size)) i)))
           (equal (bitn (incr t (v-not (nat-to-v i word-size)))
                        word-size)
                  t)))

(disable incr-f-is-noop)
(disable bitn-cons)
(disable bitn-of-negatives-is-t-lemma)
(disable bitn-of-negatives-is-t-lemma-hyp)

(prove-lemma v-to-int-inverts-int-to-v (rewrite)
  (implies (and (small-integerp i word-size)
                (not (zerop word-size)))
           (equal (v-to-int (int-to-v i word-size)) i))
  ((enable int-to-v)))

(prove-lemma v-to-int-inverts-link-word (rewrite)
  (implies (and (equal (type x) 'int)
                (equal (cddr x) nil)
                (small-integerp (untag x) word-size)
                (not (zerop word-size)))
           (equal (v-to-int (link-word x tables word-size))
                  (untag x)))
  ((disable v-to-int)
   (enable link-word icode-instructionp)))

(prove-lemma not-equal-link-word-btm (rewrite)
  (listp (link-word x tables 32))
  ((disable size-link-word)
   (use (size-link-word (link-tables tables) (word-size 32)))))

(enable commutativity-of-iplus)

; Initially, my owc step theorems were stated in terms of i-ins-okp
; and i-step.  But now I use the -okp and -step function specific to
; the given current-instruction.  Frequently the attempt to prove a
; owc step theorem exposes bugs in the -okp or -step function for
; the instruction.  If the previously proved owc step theorems are
; stated in terms of the i-ins-okp and i-step those previously proved
; theorems must be proved again when the -okp and -step functions for
; the current instruction are redefined.

; Here I have inserted a new theorem, m-step1-opener, that play the
; role that m-step1-expander did in fm8502.

(enable remainder-plus-x-x-2)

(prove-lemma remainder-add1-plus-x-x-2 (rewrite)
  (equal (remainder (add1 (plus x x)) 2) 1))

(prove-lemma nat-to-v-inverts-v-to-nat (rewrite)
  (implies (bvp v)
           (equal (nat-to-v (v-to-nat v) (length v)) v)))

(prove-lemma backchainer-trick (rewrite)
 (implies (and (bvp v)
               (not (lessp (length v) word-size))
               (equal (v-to-nat v) n))
          (equal (equal (firstn word-size v) (nat-to-v n word-size))
                 t)))

(prove-lemma v-adder-t-0-is-nat-to-v-add1 (rewrite)
  (implies (and (numberp pc)
                (not (zerop word-size))
                (lessp (add1 pc) (exp 2 word-size)))
           (equal (firstn word-size
                          (v-adder t
                                   (nat-to-v pc word-size)
                                   (nat-to-v 0 word-size)))
                  (nat-to-v (add1 pc) word-size)))
  ((enable bvp-nat-to-v v-adder-works BVP-V-ADDER length-v-adder)))

(prove-lemma v-adder-f-1-is-nat-to-v-sub1 (rewrite)
  (implies (and (numberp pc)
                (not (equal pc 0))
                (not (zerop word-size))
                (lessp pc (exp 2 word-size)))
           (equal (firstn word-size
                          (v-adder f
                                   (v-not (nat-to-v 0 word-size))
                                   (nat-to-v pc word-size)))
                  (nat-to-v (sub1 pc) word-size)))
  ((use (v-alu-correct-nat-subtracter-output
         (c t)
         (a (nat-to-v 0 word-size))
         (b (nat-to-v pc word-size))))
   (enable v-to-nat-v-not bvp-v-not bvp-nat-to-v v-adder-works BVP-V-ADDER length-v-adder)))

(disable backchainer-trick)
(disable nat-to-v-inverts-v-to-nat)
(disable remainder-add1-plus-x-x-2)
(disable remainder-plus-x-x-2)

(prove-lemma v-inc-nat-to-v (rewrite)
  (implies (and (numberp i)
                (not (zerop word-size))
                (lessp (add1 i) (exp 2 word-size)))
           (equal (v-inc (nat-to-v i word-size))
                  (nat-to-v (add1 i) word-size))))

(disable v-inc)

(enable bvp-nat-to-v)

(prove-lemma v-dec-nat-to-v (rewrite)
  (implies (and (lessp i (exp 2 word-size))
                (not (zerop word-size)))
           (equal (v-dec (nat-to-v i word-size))
                  (if (zerop i)
                      (nat-to-v (sub1 (exp 2 word-size)) word-size)
                      (nat-to-v (sub1 i) word-size))))
  ((disable alu-thm_nat-bv-subb)
   (enable v-alu bv)
   (use (alu-thm_nat-bv-subb (c t)
                             (a (nat-to-v 0 word-size))
                             (b (nat-to-v i word-size))))))

(disable v-dec)

(prove-lemma m-step1-opener (rewrite)
  (implies (and (numberp pc)
                (not (zerop word-size))
                (lessp (add1 pc) (exp 2 word-size)))
           (equal (m-step1 (cons ins0 ins1-31)
                           (m-state (list r0 r1 r2 r3 r4 r5 r6 r7
                                          r8 r9 r10 r11 r12 r13 r14
                                          (nat-to-v pc word-size))
                                    c v n z mem))
                  (m-operand-a (list r0 r1 r2 r3 r4 r5 r6 r7
                                     r8 r9 r10 r11 r12 r13 r14
                                     (nat-to-v (add1 pc) word-size))
                      c v n z mem (cons ins0 ins1-31))))
  ((disable m-operand-a)))

(disable m-step1)

(prove-lemma bvp-bitv-to-v (rewrite)
  (bvp (bitv-to-v bv word-size))
  ((enable bvp-append)))

; A lemma bvp-int-to-v exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-bvp-int-to-v (rewrite)
  (bvp (int-to-v i word-size))
  ((enable int-to-v)))

(prove-lemma bvp-link-word (rewrite)
  (bvp (link-word x link-tables word-size))
  ((disable *1*link-instruction-alist link-instruction-alist
            extract-op extract-move-bits extract-cvnz extract-mode
            extract-reg)
   (enable link-word link-data-word link-instr-word)))

(prove-lemma i-m-one-way-correspondence-step-move_x_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_x-okp i)
                (equal (i-current-instruction i) '(move_x_x)))
           (equal (i->m (i-move_x_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable nat-to-v link-table-entry)))

; This next segment has been added during the fm9001 port, to speed up
; the processing of the new fns introduced there.

; I had this around in the fm9001 effort before backing up and
; disabling v-inc and v-dec...

;(prove-lemma v-adder-t-0-is-nat-to-v-add1-32 (rewrite)
;  (implies (and (numberp pc)
;               (lessp (add1 pc) (exp 2 32)))
;          (equal (firstn 32
;                         (v-adder t
;                                  (nat-to-v pc 32)
;                                  (LIST F F F F F F F F F F F F F F F F
;                                        F F F F F F F F F F F F F F F F)))
;                 (nat-to-v (add1 pc) 32)))
;  ((disable v-adder-t-0-is-nat-to-v-add1)
;   (use (v-adder-t-0-is-nat-to-v-add1 (word-size 32)))))

; The following theorem delays the opening of m-operand-a until the
; reg file has been put into normal form.  Note that this means we
; list all 16 regs and the pc is (NAT-TO-V & 32). Use of the free var
; regs in the hyp is arranged to save the repeated rewriting of it in
; the rhs of the concl.  The conclusion is just what (ppsd
; 'm-operand-a) prints, except for the list-expr in the regs slot on
; the lhs.

(prove-lemma m-operand-a-opener (rewrite)
  (implies
   (equal regs (list r0 r1 r2 r3 r4 r5 r6 r7
                     r8 r9 r10 r11 r12 r13 r14 (nat-to-v pc 32)))
   (EQUAL (M-OPERAND-A (list r0 r1 r2 r3 r4 r5 r6 r7
                             r8 r9 r10 r11 r12 r13 r14 (nat-to-v pc 32))
                       C V N Z MEM INS)
          (COND
           ((A-IMMEDIATE-P INS)
            (M-OPERAND-B REGS C V N Z MEM INS
                         (SIGN-EXTEND (A-IMMEDIATE INS) 32)))
           ((PRE-DEC-P (MODE-A INS))
            (IF (REG-DIRECT-P (MODE-A INS))
                (M-OPERAND-B (UPDATE-V-NTH (RN-A INS)
                                           REGS
                                           (V-DEC (V-NTH1 (RN-A INS) REGS)))
                             C V N Z MEM INS
                             (V-NTH1 (RN-A INS) REGS))
                (M-OPERAND-B (UPDATE-V-NTH (RN-A INS)
                                           REGS
                                           (V-DEC (V-NTH1 (RN-A INS) REGS)))
                             C V N Z MEM INS
                             (V-NTH1 (V-DEC (V-NTH1 (RN-A INS) REGS))
                                     MEM))))
           ((POST-INC-P (MODE-A INS))
            (IF (REG-DIRECT-P (MODE-A INS))
                (M-OPERAND-B (UPDATE-V-NTH (RN-A INS)
                                           REGS
                                           (V-INC (V-NTH1 (RN-A INS) REGS)))
                             C V N Z MEM INS
                             (V-NTH1 (RN-A INS) REGS))
                (M-OPERAND-B (UPDATE-V-NTH (RN-A INS)
                                           REGS
                                           (V-INC (V-NTH1 (RN-A INS) REGS)))
                             C V N Z MEM INS
                             (V-NTH1 (V-NTH1 (RN-A INS) REGS)
                                     MEM))))
           ((REG-DIRECT-P (MODE-A INS))
            (M-OPERAND-B REGS C V N Z MEM INS
                         (V-NTH1 (RN-A INS) REGS)))
           (T (M-OPERAND-B REGS C V N Z MEM INS
                           (V-NTH1 (V-NTH1 (RN-A INS) REGS)
                                   MEM))))))
  ((disable A-IMMEDIATE-P M-OPERAND-B SIGN-EXTEND A-IMMEDIATE PRE-DEC-P
            MODE-A REG-DIRECT-P UPDATE-V-NTH RN-A V-DEC V-NTH1 POST-INC-P
            V-INC)))

(disable m-operand-a)

; Now we repeat the exercise for m-operand-b.

(prove-lemma m-operand-b-opener (rewrite)
  (implies
   (equal regs (list r0 r1 r2 r3 r4 r5 r6 r7
                     r8 r9 r10 r11 r12 r13 r14 (nat-to-v pc 32)))
   (EQUAL
    (M-OPERAND-B (list r0 r1 r2 r3 r4 r5 r6 r7
                       r8 r9 r10 r11 r12 r13 r14 (nat-to-v pc 32))
                 C V N Z MEM INS OPERAND-A)
    (COND ((PRE-DEC-P (MODE-B INS))
           (IF (REG-DIRECT-P (MODE-B INS))
               (M-ALU-OPERATION (UPDATE-V-NTH (RN-B INS)
                                              REGS
                                              (V-DEC (V-NTH1 (RN-B INS) REGS)))
                                C V N Z MEM INS OPERAND-A
                                (V-NTH1 (RN-B INS) REGS)
                                (V-DEC (V-NTH1 (RN-B INS) REGS)))
               (M-ALU-OPERATION (UPDATE-V-NTH (RN-B INS)
                                              REGS
                                              (V-DEC (V-NTH1 (RN-B INS) REGS)))
                                C V N Z MEM INS OPERAND-A
                                (V-NTH1 (V-DEC (V-NTH1 (RN-B INS) REGS))
                                        MEM)
                                (V-DEC (V-NTH1 (RN-B INS) REGS)))))
          ((POST-INC-P (MODE-B INS))
           (IF (REG-DIRECT-P (MODE-B INS))
               (M-ALU-OPERATION (UPDATE-V-NTH (RN-B INS)
                                              REGS
                                              (V-INC (V-NTH1 (RN-B INS) REGS)))
                                C V N Z MEM INS OPERAND-A
                                (V-NTH1 (RN-B INS) REGS)
                                (V-NTH1 (RN-B INS) REGS))
               (M-ALU-OPERATION (UPDATE-V-NTH (RN-B INS)
                                              REGS
                                              (V-INC (V-NTH1 (RN-B INS) REGS)))
                                C V N Z MEM INS OPERAND-A
                                (V-NTH1 (V-NTH1 (RN-B INS) REGS) MEM)
                                (V-NTH1 (RN-B INS) REGS))))
          ((REG-DIRECT-P (MODE-B INS))
           (M-ALU-OPERATION REGS C V N Z MEM INS OPERAND-A
                            (V-NTH1 (RN-B INS) REGS)
                            (V-NTH1 (RN-B INS) REGS)))
          (T (M-ALU-OPERATION REGS C V N Z MEM INS OPERAND-A
                              (V-NTH1 (V-NTH1 (RN-B INS) REGS) MEM)
                              (V-NTH1 (RN-B INS) REGS))))))
  ((disable PRE-DEC-P MODE-B REG-DIRECT-P M-ALU-OPERATION UPDATE-V-NTH
            RN-B V-DEC V-NTH1 POST-INC-P V-INC)))

(disable m-operand-b)

; In watching expansions we have found that the following fact comes up
; and causes a split, which we wish to avoid.  Note that we have
; generalized (I-SYS-DATA-SEGMENT I) to I-SYS-DATA-SEGMENT so we can
; induct here.

(prove-lemma non-zero-total-i-system-size (rewrite)
   (implies (LESSP (ADP-OFFSET (UNTAG (I-TSP I)))
                   (LENGTH (CDR (ASSOC 'TSTK I-SYS-DATA-SEGMENT))))  
            (not (EQUAL (PLUS load-addr
                              (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I))
                              (SEGMENT-LENGTH (I-PROG-SEGMENT I))
                              (SEGMENT-LENGTH I-SYS-DATA-SEGMENT))
                        0))))

; And again for m-alu-operation...except this time we also eliminate the
; B-IF's in m-alu-operation (in favor of plain IFs, which we hypothesize
; have boolp args).

(disable boolp)


; I am not sure if these two should be shut down or not.  But I will
; shut them down and we'll see...

(disable zb)
(disable n)

; To eliminate b-if without explosion, we have to be careful.

(prove-lemma b-if-is-if (rewrite)
  (implies (and (boolp a) (boolp b))
           (equal (b-if c a b) (if c a b)))
  ((enable boolp)))

(disable b-if)

(prove-lemma m-alu-operation-opener (rewrite)
  (implies
   (and
    (equal regs (list r0 r1 r2 r3 r4 r5 r6 r7
                      r8 r9 r10 r11 r12 r13 r14 pc))
    (boolp c)
    (boolp v)
    (boolp n)
    (boolp z)
    (bvp operand-a)
    (not (equal (length operand-a) 0)))
   (EQUAL
    (M-ALU-OPERATION (list r0 r1 r2 r3 r4 r5 r6 r7
                           r8 r9 r10 r11 r12 r13 r14 pc)
                     C V N Z MEM INS OPERAND-A OPERAND-B B-ADDRESS)
    (IF (M-STORE-RESULTP (STORE-CC INS)
                         C V N Z)
        (IF (REG-DIRECT-P (MODE-B INS))
            (M-STATE (UPDATE-V-NTH (RN-B INS)
                                   REGS
                                   (BV (V-ALU C OPERAND-A OPERAND-B
                                              (OP-CODE INS))))
                     (IF (C-SET (SET-FLAGS INS))
                         (C (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         C)
                     (IF (V-SET (SET-FLAGS INS))
                         (V (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         V)
                     (IF (N-SET (SET-FLAGS INS))
                         (N (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         N)
                     (IF (Z-SET (SET-FLAGS INS))
                         (ZB (V-ALU C OPERAND-A OPERAND-B
                                    (OP-CODE INS)))
                         Z)
                     MEM)
            (M-STATE REGS
                     (IF (C-SET (SET-FLAGS INS))
                         (C (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         C)
                     (IF (V-SET (SET-FLAGS INS))
                         (V (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         V)
                     (IF (N-SET (SET-FLAGS INS))
                         (N (V-ALU C OPERAND-A OPERAND-B
                                   (OP-CODE INS)))
                         N)
                     (IF (Z-SET (SET-FLAGS INS))
                         (ZB (V-ALU C OPERAND-A OPERAND-B
                                    (OP-CODE INS)))
                         Z)
                     (UPDATE-V-NTH B-ADDRESS MEM
                                   (BV (V-ALU C OPERAND-A OPERAND-B
                                              (OP-CODE INS))))))
        (M-STATE REGS
                 (IF (C-SET (SET-FLAGS INS))
                     (C (V-ALU C OPERAND-A OPERAND-B
                               (OP-CODE INS)))
                     C)
                 (IF (V-SET (SET-FLAGS INS))
                     (V (V-ALU C OPERAND-A OPERAND-B
                               (OP-CODE INS)))
                     V)
                 (IF (N-SET (SET-FLAGS INS))
                     (N (V-ALU C OPERAND-A OPERAND-B
                               (OP-CODE INS)))
                     N)
                 (IF (Z-SET (SET-FLAGS INS))
                     (ZB (V-ALU C OPERAND-A OPERAND-B
                                (OP-CODE INS)))
                     Z)
                 MEM))))
  ((hands-off if)
   (enable boolp-c-v-alu boolp-v-v-alu boolp-n boolp-zb-v-alu bvp-bv-v-alu)
   (disable M-STORE-RESULTP STORE-CC REG-DIRECT-P MODE-B UPDATE-V-NTH
            RN-B BV V-ALU OP-CODE C-SET SET-FLAGS V-SET N-SET Z-SET)))

(disable m-alu-operation)

(prove-lemma i-m-one-way-correspondence-step-cpush_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_*-okp i)
                (equal (i-current-instruction i) '(cpush_*)))
           (equal (i->m (i-cpush_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))


(prove-lemma i-m-one-way-correspondence-step-add_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{i}_x{i})))
           (equal (i->m (i-add_<tsp>{i}_x{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-add alu-thm_nat-c-add
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-cpush_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_cfp-okp i)
                (equal (i-current-instruction i) '(cpush_cfp)))
           (equal (i->m (i-cpush_cfp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_cfp_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_cfp_csp-okp i)
                (equal (i-current-instruction i) '(move_cfp_csp)))
           (equal (i->m (i-move_cfp_csp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-cpush_<tsp>+ (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_<tsp>+-okp i)
                (equal (i-current-instruction i) '(cpush_<tsp>+)))
           (equal (i->m (i-cpush_<tsp>+-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_csp_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_csp_cfp-okp i)
                (equal (i-current-instruction i) '(move_csp_cfp)))
           (equal (i->m (i-move_csp_cfp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_x_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_tsp-okp i)
                (equal (i-current-instruction i) '(move_x_tsp)))
           (equal (i->m (i-move_x_tsp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-cpop_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpop_cfp-okp i)
                (equal (i-current-instruction i) '(cpop_cfp)))
           (equal (i->m (i-cpop_cfp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_x_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_*-okp i)
                (equal (i-current-instruction i) '(move_x_*)))
           (equal (i->m (i-move_x_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_y_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_*-okp i)
                (equal (i-current-instruction i) '(move_y_*)))
           (equal (i->m (i-move_y_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma icode-instructionp-data-word (rewrite)
  (implies (equal (cddr x) nil)
           (equal (icode-instructionp x) f))
  ((enable icode-instructionp)))

(prove-lemma lessp-absolute-address-segment-length-rewrite (rewrite)
  (implies (and (definedp name segment)
                (lessp offset (length (cdr (assoc name segment)))))
           (lessp (plus (link-table-entry name segment) offset)
                  (segment-length segment)))
  ((use (lessp-absolute-address-segment-length-generalized))))

(prove-lemma i-m-one-way-correspondence-step-add_x{n}_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_x{n}_csp-okp i)
                (equal (i-current-instruction i) '(add_x{n}_csp)))
           (equal (i->m (i-add_x{n}_csp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the theorem below work, I had to change the -okp fn to
; check that the fetch of sys-addr i-x produced an i-objectp.

(prove-lemma i-m-one-way-correspondence-step-move_x_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(move_x_<x{s}>)))
           (equal (i->m (i-move_x_<x{s}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_y_<y{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_<y{s}>-okp i)
                (equal (i-current-instruction i)
                       '(move_y_<y{s}>)))
           (equal (i->m (i-move_y_<y{s}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_y_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_tsp-okp i)
                (equal (i-current-instruction i) '(move_y_tsp)))
           (equal (i->m (i-move_y_tsp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpush_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_csp-okp i)
                (equal (i-current-instruction i) '(tpush_csp)))
           (equal (i->m (i-tpush_csp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpush_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_tsp-okp i)
                (equal (i-current-instruction i) '(tpush_tsp)))
           (equal (i->m (i-tpush_tsp-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpush_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_x-okp i)
                (equal (i-current-instruction i) '(tpush_x)))
           (equal (i->m (i-tpush_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpush_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(tpush_<x{s}>)))
           (equal (i->m (i-tpush_<x{s}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpush_<x{a}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_<x{a}>-okp i)
                (equal (i-current-instruction i) '(tpush_<x{a}>)))
           (equal (i->m (i-tpush_<x{a}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))


; To make the theorem below work I had to change the -okp function
; to make sure that nextword was an i-objectp

(prove-lemma i-m-one-way-correspondence-step-tpush_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_*-okp i)
                (equal (i-current-instruction i) '(tpush_*)))
           (equal (i->m (i-tpush_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the theorem below work I had to change the -okp function
; to make sure that the top of tsp was an i-objectp.

(prove-lemma i-m-one-way-correspondence-step-tpop_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_x-okp i)
                (equal (i-current-instruction i) '(tpop_x)))
           (equal (i->m (i-tpop_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the theorem below work I had to change the -okp function
; to make sure that the top of tsp was an i-objectp.

(prove-lemma i-m-one-way-correspondence-step-tpop_y (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_y-okp i)
                (equal (i-current-instruction i) '(tpop_y)))
           (equal (i->m (i-tpop_y-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpop_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(tpop_<x{s}>)))
           (equal (i->m (i-tpop_<x{s}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma segment-length-put-assoc (rewrite)
  (implies (equal (length (cdr (assoc name segment)))
                       (length val))
           (equal (segment-length (put-assoc val name segment))
                  (segment-length segment))))


(prove-lemma i-m-one-way-correspondence-step-tpop_<x{a}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<x{a}>-okp i)
                (equal (i-current-instruction i)
                       '(tpop_<x{a}>)))
           (equal (i->m (i-tpop_<x{a}>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma car-assoc (rewrite)
  (implies (definedp name alist)
           (equal (car (assoc name alist)) name)))

(prove-lemma assoc-link-table-for-prog-labels (rewrite)
  (implies (and (numberp addr0)
                (definedp name segment))
           (equal
            (cdr
             (assoc name
                    (link-table-for-prog-labels segment addr0)))
            (link-table-for-labels
             (definiens name segment)
             (plus addr0
                   (link-table-entry name segment))))))

(prove-lemma assoc-link-table-for-labels (rewrite)
  (implies (and (numberp addr0)
                (find-labelp label lst))
           (equal (cdr (assoc label
                              (link-table-for-labels
                               lst
                               addr0)))
                  (plus addr0 (find-label label lst)))))

(prove-lemma i-m-one-way-correspondence-step-jump_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump_*-okp i)
                (equal (i-current-instruction i) '(jump_*)))
           (equal (i->m (i-jump_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-cpop_pc (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpop_pc-okp i)
                (equal (i-current-instruction i) '(cpop_pc)))
           (equal (i->m (i-cpop_pc-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_<x{s}>_<tsp>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<x{s}>_<tsp>-okp i)
                (equal (i-current-instruction i)
                       '(move_<x{s}>_<tsp>)))
           (equal (i->m (i-move_<x{s}>_<tsp>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_<x{a}>_<tsp>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<x{a}>_<tsp>-okp i)
                (equal (i-current-instruction i)
                       '(move_<x{a}>_<tsp>)))
           (equal (i->m (i-move_<x{a}>_<tsp>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-jump_x{subr} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump_x{subr}-okp i)
                (equal (i-current-instruction i) '(jump_x{subr})))
           (equal (i->m (i-jump_x{subr}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma bool-to-logical-non-f (rewrite)
  (implies (not (equal x 'F))
           (equal (bool-to-logical x) t))
  ((enable bool-to-logical)))

(prove-lemma i-m-one-way-correspondence-step-jump-n_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-n_x-okp i)
                (equal (i-current-instruction i) '(jump-n_x)))
           (equal (i->m (i-jump-n_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-jump-nn_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-nn_x-okp i)
                (equal (i-current-instruction i) '(jump-nn_x)))
           (equal (i->m (i-jump-nn_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-jump-z_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-z_x-okp i)
                (equal (i-current-instruction i) '(jump-z_x)))
           (equal (i->m (i-jump-z_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-jump-nz_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-nz_x-okp i)
                (equal (i-current-instruction i) '(jump-nz_x)))
           (equal (i->m (i-jump-nz_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpop_pc (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_pc-okp i)
                (equal (i-current-instruction i) '(tpop_pc)))
           (equal (i->m (i-tpop_pc-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the theorem below work I had to change the -okp fn to
; insure that the top of tsp was an i-objectp.

(prove-lemma i-m-one-way-correspondence-step-tpop_<c>_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<c>_x-okp i)
                (equal (i-current-instruction i) '(tpop_<c>_x)))
           (equal (i->m (i-tpop_<c>_x-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the thm below work I had to redefine the -step function
; because it did not include an untag in the computation of the flag.

; A lemma v-nzerop-nat-to-v exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-v-nzerop-nat-to-v (rewrite)
 (implies (lessp n (exp 2 word-size))
          (equal (v-nzerop (nat-to-v n word-size))
                 (not (zerop n)))))

(prove-lemma alu-thm_bitv-zb-move-15 (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (zb (v-alu c a b (list t t t t)))
                  (not (v-nzerop a))))
  ((enable zb v-alu)))

(prove-lemma i-m-one-way-correspondence-step-tpop{n}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{n}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{n}_<z>_y)))
           (equal (i->m (i-tpop{n}_<z>_y-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma size-int-to-v (rewrite)
  (equal (length (int-to-v i word-size)) (fix word-size))
  ((enable int-to-v)))

; These seem irrelevant and I'm going to skip them for the moment...
; They may have v-nzerop counterparts...

;(prove-lemma v-to-nat-incr-t (rewrite)
;  (equal (v-to-nat (incr t b))
;        (if (all-onesp b)
;            0
;            (add1 (v-to-nat b)))))

;(prove-lemma all-onesp-compl (rewrite)
;  (equal (all-onesp (v-not b))
;        (equal (v-to-nat b) 0)))

(prove-lemma zerop-v-to-nat-int-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (small-integerp i word-size))
           (equal (equal (v-to-nat (int-to-v i word-size)) 0)
                  (equal i 0)))
  ((enable int-to-v)))

; A lemma v-nzerop-int-to-v exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-v-nzerop-int-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (small-integerp i word-size))
           (equal (v-nzerop (int-to-v i word-size))
                  (not (equal i 0))))
  ((enable small-integerp int-to-v)))

(prove-lemma v-negp-nat-to-v (rewrite)
  (implies (and (not (zerop w))
                (lessp n (exp 2 w)))
           (equal (v-negp (nat-to-v n w))
                  (not (lessp n (exp 2 (sub1 w)))))))

(prove-lemma v-negp-int-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (small-integerp i word-size))
           (equal (v-negp (int-to-v i word-size))
                  (negativep i)))
  ((enable int-to-v)))

(disable v-negp-nat-to-v)

; I had to change the -step fn below because it failed to set y!

(prove-lemma i-m-one-way-correspondence-step-tpop{i}_<zn>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{i}_<zn>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{i}_<zn>_y)))
           (equal (i->m (i-tpop{i}_<zn>_y-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((enable n)
   (disable int-to-v v-to-int
            small-integerp
            integerp
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-tpop{b}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{b}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{b}_<z>_y)))
           (equal (i->m (i-tpop{b}_<z>_y-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma all-zero-bitvp-not-v-nzerop-bitv-to-v (rewrite)
  (equal (all-zero-bitvp b)
         (not (v-nzerop (bitv-to-v b (length b))))))

(prove-lemma length-bit-vectorp (rewrite)
  (implies (bit-vectorp b word-size)
           (equal (length b) (fix word-size))))

(prove-lemma i-m-one-way-correspondence-step-tpop{v}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{v}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{v}_<z>_y)))
           (equal (i->m (i-tpop{v}_<z>_y-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; For the next owc lemma it would be useful to have the
; commutativity of plus, but providing it messes up our
; rewrite rules.  We have implicitly assumed we had total
; knowledge of the shape of plus-nests.  The following rule,
; which is elegant in its own right, elevates the two
; plus expressions to the point where linear arithmetic
; can deal with them.

(prove-lemma put-equal (rewrite)
  (equal (equal (put val1 n lst)
                (put val2 n lst))
         (equal val1 val2)))

(prove-lemma i-m-one-way-correspondence-step-add_<tsp>{a}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{a}_x{n}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{a}_x{n})))
           (equal (i->m (i-add_<tsp>{a}_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-add_tsp_*{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_tsp_*{n}-okp i)
                (equal (i-current-instruction i) '(add_tsp_*{n})))
           (equal (i->m (i-add_tsp_*{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-add_tsp_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_tsp_x{n}-okp i)
                (equal (i-current-instruction i) '(add_tsp_x{n})))
           (equal (i->m (i-add_tsp_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-sub_<tsp>{a}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{a}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{a}_x{n})))
           (equal (i->m (i-sub_<tsp>{a}_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-sub_x{s}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_x{s}_y{n}-okp i)
                (equal (i-current-instruction i) '(sub_x{s}_y{n})))
           (equal (i->m (i-sub_x{s}_y{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma all-zero-bitvp-xor-bitv nil
  (implies (and (bit-vectorp a word-size)
                (bit-vectorp b word-size))
           (equal (all-zero-bitvp (xor-bitv a b))
                  (equal a b))))

(prove-lemma equal-append-generalized (rewrite)
  (implies (and (properp a)
                (properp b)
                (equal (length a) (length b)))
           (equal (equal (append a x)
                         (append b y))
                  (and (equal a b)
                       (equal x y))))
  ((induct (pairlist a b))))

(prove-lemma properp-v-to-bitv (rewrite)
  (properp (V-TO-BITV x)))

(prove-lemma length-v-to-bitv (rewrite)
  (equal (length (V-TO-BITV a))
         (length a)))

(prove-lemma equal-v-to-bitv nil
   (implies (and (bvp x)
                 (bvp y)
                 (equal (length x) (length y)))
            (equal (equal (V-TO-BITV x)
                          (V-TO-BITV y))
                   (equal x y)))
   ((induct (v-and x y))
    (enable boolp)))

(prove-lemma bit-vectorp-append-singleton (rewrite)
  (implies (and (bitp bit)
                (properp a))
           (equal (bit-vectorp (append a (list bit)) n)
                  (if (zerop n)
                      f
                      (bit-vectorp a (sub1 n)))))
  ((induct (bit-vectorp a n))
   (disable bitp)))
                  
(defn bit-vectorp-v-to-bitv-hint (a word-size)
  (if (or (zerop word-size)
          (not (bvp a))
          (nlistp a))
      t
      (bit-vectorp-v-to-bitv-hint (cdr a) (sub1 word-size))))

(prove-lemma bit-vectorp-v-to-bitv-lemma (rewrite)
  (bit-vectorp (v-to-bitv a) (length a)))

(prove-lemma bit-vectorp-v-to-bitv (rewrite)
  (equal (bit-vectorp (V-TO-BITV a) word-size)
         (equal (length a) (fix word-size)))
  ((disable length-bit-vectorp)
   (use (length-bit-vectorp (b (v-to-bitv a))))))

(prove-lemma bit-vectorp-v-to-bitv-link-data-word (rewrite)
  (bit-vectorp (V-TO-BITV (link-data-word x
                                           tables
                                           word-size))
               word-size)
  ((enable link-data-word int-to-v)))

(prove-lemma equal-int-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (small-integerp i word-size)
                (small-integerp j word-size))
           (equal (equal (int-to-v i word-size)
                         (int-to-v j word-size))
                  (equal i j)))
  ((disable v-to-int-inverts-int-to-v small-integerp)
   (use (v-to-int-inverts-int-to-v)
        (v-to-int-inverts-int-to-v (i j)))))

(prove-lemma v-to-bitv-inverts-bitv-to-v (rewrite)
  (implies (bit-vectorp x word-size)
           (equal (V-TO-BITV (bitv-to-v x word-size)) x)))

(prove-lemma equal-bitv-to-v (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (equal (equal (bitv-to-v x word-size)
                         (bitv-to-v y word-size))
                  (equal x y)))
  ((disable v-to-bitv-inverts-bitv-to-v)
   (use (V-TO-BITV-inverts-bitv-to-v)
        (V-TO-BITV-inverts-bitv-to-v (x y)))))

(prove-lemma v-to-bool-inverts-bool-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (booleanp x))
           (equal (V-TO-BOOL (BOOL-TO-V x word-size))
                  x))
  ((enable booleanp)
   (expand (nat-to-v 0 word-size)
           (nat-to-v 1 word-size))))

(prove-lemma equal-bool-to-v (rewrite)
  (implies (and (not (zerop word-size))
                (booleanp x)
                (booleanp y))
           (equal (equal (BOOL-TO-V x word-size)
                         (BOOL-TO-V y word-size))
                  (equal x y)))
  ((disable v-to-bool-inverts-bool-to-v)
   (use (V-TO-BOOL-inverts-bool-to-v)
        (V-TO-BOOL-inverts-bool-to-v (x y)))))

; We now turn to the harder cases of linking, those involving
; the link tables.

; Three of the linkers, namely addr-to-v, sys-addr-to-v, and
; ipc-to-v, use the primitive function absolute-address to
; compute their values.  We therefore first establish that
; absolute-address can be inverted on the link table actually used.

(prove-lemma cons-adp-name-adp-offset (rewrite)
  (implies (listp adp)
           (equal (cons (adp-name adp) (adp-offset adp)) adp))
  ((enable adp-name adp-offset)))

(prove-lemma listp-link-table-for-segment (rewrite)
  (equal (listp (link-table-for-segment segment addr0))
         (listp segment)))

(prove-lemma cdar-link-table-for-segment (rewrite)
  (implies (listp segment)
           (equal (cdar (link-table-for-segment segment addr0))
                  addr0)))

(prove-lemma find-containing-area-name-link-table-for-segment (rewrite)
  (implies (adpp adp segment)
           (equal (find-containing-area-name
                   (plus (cdr (assoc (adp-name adp)
                                     (link-table-for-segment
                                                segment addr0)))
                         (adp-offset adp))
                   (link-table-for-segment segment addr0))
                  (adp-name adp))))

(prove-lemma invert-absolute-address-inverts-absolute-address (rewrite)
  (implies (adpp adp segment)
           (equal (invert-absolute-address
                   (absolute-address adp
                                     (link-table-for-segment segment addr0))
                   (link-table-for-segment segment addr0))
                  adp)))

; Now I prove the invertibility results and the equality results for
; each of the three linkers that use absolute-address:  ipc-to-v,
; addr-to-v, and sys-addr-to-v.

; Each linker is used with its own link table.  In fact, if we could
; completely characterize the link table properties we could avoid
; having different theorems for these three linkers and just have a
; general one.  Rather than do that I just prove the appropriate
; result for the link table used by each linker.

; In fact we prove three lemmas for each linker.  The first establishes
; that the absolute address computed for a given link table is small
; enough.  The second is the invertibility result for the link table.
; The third is the equality result.

; Here is the series for prog-segment addresses.

; The following lemma would not be necessary if absolute-address could be
; enabled in the lemma below this.  But the invertibility of absolute-address
; above requires that the fn be disabled.

; The (PLUS LOAD-ADDR ...) term below is just (i-loadablep i load-addr).
; But it is open because it contains the free-var load-addr and will be
; the term we look for to bind that var.



(prove-lemma lessp-absolute-address-ipc (rewrite)
  (implies (and (adpp adp (i-prog-segment i))
                (LESSP (PLUS LOAD-ADDR 
                             (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-PROG-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-SYS-DATA-SEGMENT I))) 
                       (EXP 2 (I-WORD-SIZE I))))
           (lessp (absolute-address
                               adp
                               (link-table-for-segment
                                    (i-prog-segment i)
                                    (plus load-addr
                                          (segment-length (i-usr-data-segment i)))))
                  (exp 2 (i-word-size i)))))

; To prove the invertibility result for ipcs and keep it exactly
; symmetric with addrs and sys-addrs, it is necessary to define
; the inverter.  The inverter is not used in the main theorem.

(defn v-to-ipc (bv prog-links)
  (invert-absolute-address (v-to-nat bv)
                           prog-links))

(prove-lemma v-to-ipc-inverts-ipc-to-v (rewrite)
  (implies (and (adpp adp (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (v-to-ipc
                   (ipc-to-v adp
                             (link-table-for-segment
                              (i-prog-segment i)
                              (plus load-addr (segment-length (i-usr-data-segment i))))
                             (i-word-size i))
                   (link-table-for-segment
                    (i-prog-segment i)
                     (plus load-addr (segment-length (i-usr-data-segment i)))))
                  adp))
  ((disable absolute-address invert-absolute-address)))

(prove-lemma equal-ipc-to-v (rewrite)
  (implies (and (adpp adp1 (i-prog-segment i))
                (adpp adp2 (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (equal (IPC-TO-V adp1
                                   (link-table-for-segment
                                    (i-prog-segment i)
                                    (plus load-addr (segment-length (i-usr-data-segment i))))
                                   (i-word-size i))
                         (IPC-TO-V adp2
                                   (link-table-for-segment
                                    (i-prog-segment i)
                                    (plus load-addr (segment-length (i-usr-data-segment i))))
                                   (i-word-size i)))
                  (equal adp1 adp2)))
  ((disable v-to-ipc-inverts-ipc-to-v
            v-to-ipc ipc-to-v)
   (use (V-TO-IPC-inverts-ipc-to-v (adp adp1))
        (V-TO-IPC-inverts-ipc-to-v (adp adp2)))))

; So now we repeat the exercise for ADDRs.  That is, we use the usr-data
; segment and its link table...

(prove-lemma lessp-absolute-address-usr-data (rewrite)
  (implies (and (adpp adp (i-usr-data-segment i))
                (LESSP (PLUS LOAD-ADDR 
                             (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-PROG-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-SYS-DATA-SEGMENT I))) 
                       (EXP 2 (I-WORD-SIZE I)))
                (numberp load-addr))
           (lessp (absolute-address
                               adp
                               (link-table-for-segment
                                    (i-usr-data-segment i)
                                    load-addr))
                  (exp 2 (i-word-size i)))))

(prove-lemma v-to-addr-inverts-addr-to-v (rewrite)
  (implies (and (numberp load-addr)
                (adpp adp (i-usr-data-segment i))
                (i-loadablep i load-addr))
           (equal (V-TO-ADDR
                   (ADDR-TO-V adp
                               (link-table-for-segment
                                    (i-usr-data-segment i)
                                    load-addr)
                               (i-word-size i))
                   (link-table-for-segment
                        (i-usr-data-segment i)
                        load-addr))
                  adp))
  ((disable absolute-address invert-absolute-address)))

(prove-lemma equal-addr-to-v (rewrite)
  (implies (and (numberp load-addr)
                (adpp adp1 (i-usr-data-segment i))
                (adpp adp2 (i-usr-data-segment i))
                (i-loadablep i load-addr))
           (equal (equal (ADDR-TO-V adp1
                                     (link-table-for-segment
                                        (i-usr-data-segment i)
                                        load-addr)
                                     (i-word-size i))
                         (ADDR-TO-V adp2
                                     (link-table-for-segment
                                        (i-usr-data-segment i)
                                        load-addr)
                                     (i-word-size i)))
                  (equal adp1 adp2)))
  ((disable v-to-addr-inverts-addr-to-v
            v-to-addr addr-to-v)
   (use (V-TO-ADDR-inverts-addr-to-v (adp adp1))
        (V-TO-ADDR-inverts-addr-to-v (adp adp2)))))

; And finally we do the SYS-ADDR type...

(prove-lemma lessp-absolute-address-sys-data (rewrite)
  (implies (and (adpp adp (i-sys-data-segment i))
                (LESSP (PLUS LOAD-ADDR 
                             (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-PROG-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-SYS-DATA-SEGMENT I))) 
                       (EXP 2 (I-WORD-SIZE I))))
           (lessp (absolute-address
                               adp
                               (link-table-for-segment
                                    (i-sys-data-segment i)
                                    (plus
                                     load-addr
                                     (segment-length
                                      (i-usr-data-segment i))
                                     (segment-length
                                      (i-prog-segment i)))))
                  (exp 2 (i-word-size i)))))

(prove-lemma v-to-sys-addr-inverts-sys-addr-to-v (rewrite)
  (implies (and (adpp adp (i-sys-data-segment i))
                (i-loadablep i load-addr))
           (equal (V-TO-SYS-ADDR
                   (sys-addr-to-v adp
                                   (link-table-for-segment
                                    (i-sys-data-segment i)
                                    (plus
                                     load-addr
                                     (segment-length
                                      (i-usr-data-segment i))
                                     (segment-length
                                      (i-prog-segment i))))
                                   (i-word-size i))
                   (link-table-for-segment
                    (i-sys-data-segment i)
                    (plus
                     load-addr
                     (segment-length
                      (i-usr-data-segment i))
                     (segment-length
                      (i-prog-segment i)))))
                  adp))
  ((disable absolute-address invert-absolute-address)))

(prove-lemma equal-sys-addr-to-v (rewrite)
  (implies (and (adpp adp1 (i-sys-data-segment i))
                (adpp adp2 (i-sys-data-segment i))
                (i-loadablep i load-addr))
           (equal (equal (sys-addr-to-v adp1
                                     (link-table-for-segment
                                        (i-sys-data-segment i)
                                        (plus
                                         load-addr
                                         (segment-length
                                          (i-prog-segment i))
                                         (segment-length
                                          (i-usr-data-segment i))))
                                     (i-word-size i))
                         (sys-addr-to-v adp2
                                     (link-table-for-segment
                                        (i-sys-data-segment i)
                                        (plus
                                         load-addr
                                         (segment-length
                                          (i-prog-segment i))
                                         (segment-length
                                          (i-usr-data-segment i))))
                                     (i-word-size i)))
                  (equal adp1 adp2)))
  ((disable v-to-sys-addr-inverts-sys-addr-to-v
            v-to-sys-addr sys-addr-to-v)
   (enable commutativity-of-plus)
   (use (V-TO-SYS-ADDR-inverts-sys-addr-to-v (adp adp1))
        (V-TO-SYS-ADDR-inverts-sys-addr-to-v (adp adp2)))))

; Now I turn to the SUBR case.  It uses base-address instead of
; absolute-address.  The results we need could probably be
; obtained by creative instantiation of what we have.  But I
; prefer simply to prove them cold in perfect analogy with
; what we have done already.

(prove-lemma lessp-0-length (rewrite)
  (implies (listp a) (lessp 0 (length a))))

(prove-lemma invert-base-address-inverts-base-address-on-subrs (rewrite)
  (implies (adpp (cons name 0) segment)
           (equal (invert-base-address
                   (base-address name
                                 (link-table-for-segment segment addr0))
                   (link-table-for-segment segment addr0))
                  name)))

(prove-lemma lessp-base-address-link-table-for-segment (rewrite)
  (implies (and (adpp (cons name 0) (i-prog-segment i))
                (LESSP (PLUS LOAD-ADDR 
                             (SEGMENT-LENGTH (I-USR-DATA-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-PROG-SEGMENT I)) 
                             (SEGMENT-LENGTH (I-SYS-DATA-SEGMENT I))) 
                       (EXP 2 (I-WORD-SIZE I)))         )
           (lessp (base-address name
                                (link-table-for-segment
                                    (i-prog-segment i)
                                    (plus load-addr
                                          (segment-length (i-usr-data-segment i)))))
                  (exp 2 (i-word-size i))))
  ((use (lessp-absolute-address-segment-length-generalized
         (segment (i-prog-segment i))
         (offset 0)))))

(prove-lemma numberp-base-address-link-table-for-segment (rewrite)
  (implies (numberp addr0)
           (numberp (base-address name
                                  (link-table-for-segment
                                   segment
                                   addr0)))))

(prove-lemma v-to-subr-inverts-subr-to-v (rewrite)
  (implies (and (adpp (cons subr 0) (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (V-TO-SUBR
                   (subr-to-v subr
                               (link-table-for-segment
                                (i-prog-segment i)
                                (plus load-addr (segment-length (i-usr-data-segment i))))
                               (i-word-size i))
                   (link-table-for-segment
                        (i-prog-segment i)
                        (plus load-addr (segment-length (i-usr-data-segment i)))))
                  subr))
  ((disable base-address invert-base-address)))

(prove-lemma equal-subr-to-v (rewrite)
  (implies (and (adpp (cons subr1 0) (i-prog-segment i))
                (adpp (cons subr2 0) (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (equal (subr-to-v subr1
                                     (link-table-for-segment
                                        (i-prog-segment i)
                                        (plus load-addr (segment-length (i-usr-data-segment i))))
                                     (i-word-size i))
                         (subr-to-v subr2
                                     (link-table-for-segment
                                        (i-prog-segment i)
                                        (plus load-addr (segment-length (i-usr-data-segment i))))
                                     (i-word-size i)))
                  (equal subr1 subr2)))
  ((disable v-to-subr-inverts-subr-to-v
            v-to-subr subr-to-v)
   (use (V-TO-SUBR-inverts-subr-to-v (subr subr1))
        (V-TO-SUBR-inverts-subr-to-v (subr subr2)))))

(prove-lemma lessp-find-label-length (rewrite)
  (implies (find-labelp lab lst)
           (lessp (find-label lab lst) (length lst))))

(prove-lemma lessp-base-address-link-table-for-labels (rewrite)
  (implies (and (icode-labelp lab (i-prog-segment i))
                (i-loadablep i load-addr))
           (lessp (base-address lab
                                (link-table-for-labels
                                   (cdr (assoc (adp-name lab)
                                               (i-prog-segment i)))
                                   (plus load-addr
                                         (segment-length (i-usr-data-segment i))
                                         (link-table-entry
                                          (adp-name lab)
                                          (i-prog-segment i)))))
                  (exp 2 (i-word-size i))))
 ((use (lessp-absolute-address-segment-length-generalized
         (name (adp-name lab))
         (segment (i-prog-segment i))
         (offset (find-label lab
                             (cdr (assoc (adp-name lab)
                                         (i-prog-segment i)))))))))

(prove-lemma numberp-base-address-link-table-for-labels (rewrite)
  (implies (numberp addr0)
           (numberp (base-address name
                                  (link-table-for-labels lst addr0)))))

(prove-lemma assoc-cdrp-link-table-for-labels-t (rewrite)
  (implies (and (numberp addr0)
                (find-labelp lab lst))
           (assoc-cdrp (plus addr0 (find-label lab lst))
                       (link-table-for-labels lst addr0))))

(prove-lemma assoc-cdrp-link-table-for-labels-f (rewrite)
  (implies (not (lessp n (plus addr0 (length lst))))
           (not (assoc-cdrp n (link-table-for-labels lst addr0)))))

;The following lemma is a generalization of what we need.  We will
; instantiate it with addr0 = 0

(prove-lemma find-containing-label-table-base-address-generalized nil 
  (implies (and (numberp addr0)
                (definedp (adp-name lab) segment)
                (find-labelp lab
                             (cdr (assoc (adp-name lab) segment))))
           (equal
            (find-containing-label-table
             (base-address lab
                           (link-table-for-labels
                            (cdr (assoc (adp-name lab) segment))
                            (plus addr0
                                  (link-table-entry (adp-name lab)
                                                    segment))))
             (link-table-for-prog-labels segment addr0))
            (link-table-for-labels
             (cdr (assoc (adp-name lab) segment))
             (plus addr0
                   (link-table-entry (adp-name lab)
                                     segment))))))

(prove-lemma find-containing-label-table-base-address (rewrite)
  (implies (and (definedp (adp-name lab) segment)
                (find-labelp lab
                             (cdr (assoc (adp-name lab) segment))))
           (equal
            (find-containing-label-table
             (base-address lab
                           (link-table-for-labels
                            (cdr (assoc (adp-name lab) segment))
                            (plus load-addr
                                  (segment-length (i-usr-data-segment i))
                                  (link-table-entry (adp-name lab)
                                                    segment))))
             (link-table-for-prog-labels segment
                                         (plus load-addr (segment-length (i-usr-data-segment i)))))
            (link-table-for-labels
             (cdr (assoc (adp-name lab) segment))
             (plus load-addr
                   (segment-length (i-usr-data-segment i))
                   (link-table-entry (adp-name lab)
                                     segment)))))
  ((use (find-containing-label-table-base-address-generalized
         (addr0 (plus load-addr (segment-length (i-usr-data-segment i))))))))

(prove-lemma lessp-cdar-link-table-for-labels (rewrite)
  (implies (listp (link-table-for-labels lst addr0))
           (not (lessp (cdar (link-table-for-labels lst addr0))
                       addr0))))

(prove-lemma lessp-find-label-cdar-link-table-for-labels (rewrite)
  (implies (find-labelp lab lst)
           (not (lessp (plus addr0 (find-label lab lst))
                       (cdar (link-table-for-labels lst addr0))))))

(prove-lemma find-labelp-implies-listp-link-table-for-labels (rewrite)
  (implies (find-labelp lab lst)
           (listp (link-table-for-labels lst addr0))))

(prove-lemma invert-base-address-inverts-base-address-on-labels (rewrite)
  (implies (and (numberp addr0)
                (find-labelp lab lst))
           (equal (invert-base-address
                   (base-address lab
                                 (link-table-for-labels lst addr0))
                   (link-table-for-labels lst addr0))
                  lab)))

(prove-lemma v-to-label-inverts-label-to-v (rewrite)
  (implies (and (icode-labelp lab (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (V-TO-LABEL
                   (label-to-v lab
                                (link-table-for-prog-labels
                                 (i-prog-segment i)
                                 (plus load-addr (segment-length (i-usr-data-segment i))))
                                (i-word-size i))
                   (link-table-for-prog-labels
                    (i-prog-segment i)
                    (plus load-addr (segment-length (i-usr-data-segment i)))))
                  lab))
  ((disable base-address invert-base-address)))

(prove-lemma equal-label-to-v (rewrite)
  (implies (and (icode-labelp lab1 (i-prog-segment i))
                (icode-labelp lab2 (i-prog-segment i))
                (i-loadablep i load-addr))
           (equal (equal (label-to-v lab1
                                      (link-table-for-prog-labels
                                       (i-prog-segment i)
                                       (plus load-addr (segment-length (i-usr-data-segment i))))
                                      (i-word-size i))
                         (label-to-v lab2
                                      (link-table-for-prog-labels
                                       (i-prog-segment i)
                                       (plus load-addr (segment-length (i-usr-data-segment i))))
                                      (i-word-size i)))
                  (equal lab1 lab2)))
  ((disable v-to-label-inverts-label-to-v
            v-to-label label-to-v)
   (use (V-TO-LABEL-inverts-label-to-v (lab lab1))
        (V-TO-LABEL-inverts-label-to-v (lab lab2)))))

; The following little lemma would not be necessary if type and untag
; were opened to car and cadr and we were willing to suffer elims.

(prove-lemma equal-types-and-untags (rewrite)
  (implies (and (equal (type x) (type y))
                (equal (cddr x) nil)
                (equal (cddr y) nil)
                (not (equal x y)))
           (not (equal (untag x) (untag y))))
  ((enable type untag)))

(prove-lemma equal-link-data-word (rewrite)
  (implies (and (numberp load-addr)
                (not (zerop (i-word-size i)))
                (i-loadablep i load-addr)
                (i-objectp x i)
                (i-objectp-type (type x) y i))
           (equal (equal (link-data-word x
                                         (i-link-tables i load-addr)
                                         (i-word-size i))
                         (link-data-word y
                                         (i-link-tables i load-addr)
                                         (i-word-size i)))
                  (equal x y)))
  ((disable small-integerp bit-vectorp                 ;the top level fns of
            booleanp adpp icode-labelp                 ;i-objectp, except for
                                                       ;small-naturalp

            int-to-v bitv-to-v bool-to-v ipc-to-v   ;the top level fns of
            addr-to-v sys-addr-to-v subr-to-v       ;link-data-word
            label-to-v

            i-loadablep)
   (enable i-objectp link-data-word)))
                
; Note:  small-naturalp is not disabled above simply because I
; didn't provide what might be called equal-nat-to-v but rely
; instead on nat-to-v-equivalence, which has small-naturalp
; expanded in its hyps.

(prove-lemma bvp-link-data-word (rewrite)
  (bvp (link-data-word x table word-size))
  ((enable link-data-word)))

(prove-lemma xor-xxx-is-equal (rewrite)
  (implies (and (numberp load-addr)
                (not (zerop (i-word-size i)))
                (i-loadablep i load-addr)
                (i-objectp x i)
                (i-objectp-type (type x) y i))
           (equal (all-zero-bitvp (xor-xxx x y i load-addr))
                  (equal x y)))
 ((use (all-zero-bitvp-xor-bitv
        (a (V-TO-BITV (link-data-word x
                                       (i-link-tables i load-addr)
                                       (i-word-size i))))
        (b (V-TO-BITV (link-data-word y
                                       (i-link-tables i load-addr)
                                       (i-word-size i))))
        (word-size (i-word-size i)))
       (equal-v-to-bitv
        (x (link-data-word x
                           (i-link-tables i load-addr)
                           (i-word-size i)))
        (y (link-data-word y
                           (i-link-tables i load-addr)
                           (i-word-size i)))))))

(prove-lemma v-to-nat-v-xor-xx (rewrite)
  (equal (v-to-nat (v-xor x x)) 0))

(prove-lemma v-xor-is-equal (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b)))
           (equal (equal (v-to-nat (v-xor a b)) 0)
                  (equal a b)))
  ((enable boolp)))

(prove-lemma equal-link-word-lemma1 nil
  (implies (i-objectp x i) (not (icode-instructionp x)))
  ((enable i-objectp icode-instructionp)))

(prove-lemma equal-link-word-lemma2 nil
  (implies (i-objectp-type type x i) (not (icode-instructionp x)))
  ((enable i-objectp i-objectp-type icode-instructionp)))

(prove-lemma equal-link-word (rewrite)
  (implies (and (numberp load-addr)
                (equal word-size (i-word-size i))
                (not (zerop (i-word-size i)))
                (i-loadablep i load-addr)
                (i-objectp x i)
                (i-objectp-type (type x) y i))
           (equal (equal (link-word x (i-link-tables i load-addr) word-size)
                         (link-word y (i-link-tables i load-addr) word-size))
                  (equal x y)))
  ((use (equal-link-word-lemma1)
        (equal-link-word-lemma2 (x y) (type (type x))))
   (enable link-word)))

(prove-lemma v-xor-append (rewrite)
  (implies (and (bvp x)
                (bvp y)
                (equal (length a) (length b)))
           (equal (v-xor (append a x)
                         (append b y))
                  (append (v-xor a b) (v-xor x y)))))

(prove-lemma bitv-to-v-xor-bitv nil
  (implies (equal (length a) (length b))
           (equal (bitv-to-v (xor-bitv a b)
                              (length a))
                  (v-xor (bitv-to-v a (length a))
                         (bitv-to-v b (length a))))))

(prove-lemma bitv-to-v-inverts-v-to-bitv (rewrite)
  (implies (and (bvp a)
                (equal word-size (length a)))
           (equal (bitv-to-v (V-TO-BITV a) word-size)
                  a))
  ((disable v-to-bitv-inverts-bitv-to-v)
   (use (V-TO-BITV-inverts-bitv-to-v (x (V-TO-BITV a))
                                       (word-size (length a)))
        (equal-v-to-bitv (x (bitv-to-v (V-TO-BITV a) (length a)))
                          (y a)))))


(prove-lemma bitv-to-v-xor-xxx-is-v-xor-link-word (rewrite)
  (implies (and (numberp load-addr)
                (equal word-size (i-word-size i))
                (numberp (i-word-size i))
                (i-objectp x i)
                (i-objectp-type (type x) y i))
           (equal
            (equal (bitv-to-v (xor-xxx x y i load-addr) word-size)
                   (v-xor (link-word x (i-link-tables i load-addr) word-size)
                          (link-word y (i-link-tables i load-addr) word-size)))
            t))
  ((use (equal-link-word-lemma1)
        (equal-link-word-lemma2 (x y)(type (type x)))
        (bitv-to-v-xor-bitv
         (a (V-TO-BITV (link-data-word x
                                        (i-link-tables i load-addr)
                                        (i-word-size i))))
         (b (V-TO-BITV (link-data-word y
                                        (i-link-tables i load-addr)
                                        (i-word-size i))))))
   (enable link-word)))

; The complications are neverending!  Ok.  The next problem is
; that the two machines use xor in opposite orders.  That is,
; the xor done by one is the commuted version of the one done
; by the other.  So

(prove-lemma commutativity-of-xor-bitv (rewrite)
  (implies (equal (length x) (length y))
           (equal (xor-bitv x y) (xor-bitv y x))))

(prove-lemma commutativity-of-xor-xxx (rewrite)
  (equal (xor-xxx x y i load-addr)
         (xor-xxx y x i load-addr)))

(prove-lemma alu-thm_bitv-zb-xor (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (zb (v-alu c a b (list t t f t)))
                  (not (v-nzerop (v-xor a b)))))
  ((enable zb v-alu)))

; There is a certain amount of xor versus equal work above.  Unfortunately,
; I think it was all made irrelevant when FM9001 was introduced with its
; kind of bit vectors.

(prove-lemma v-nzerop-v-xor (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b)))
           (equal (v-nzerop (v-xor a b))
                  (not (equal a b))))
  ((enable boolp)))

(prove-lemma i-m-one-way-correspondence-step-xor_<z>_<tsp>_x
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<z>_<tsp>_x-okp i)
                (equal (i-current-instruction i)
                       '(xor_<z>_<tsp>_x)))
           (equal (i->m (i-xor_<z>_<tsp>_x-step i load-addr) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((enable i-objectp-type)
   (disable xor-xxx
            get nat-to-v link-table-entry)))

; The next owc uses xor to zero the top of stack.  I need

(prove-lemma v-xor-x-x-is-0 (rewrite)
  (equal (v-xor x x)
         (nat-to-v 0 (length x))))

; This rule will clash with others, like (v-to-nat (v-xor x x)) = 0,
; but I don't think I'll need the other rules anymore.  Famous last
; words.  This will return to haunt me.

(prove-lemma i-m-one-way-correspondence-step-xor_<tsp>_<tsp> (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>_<tsp>-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>_<tsp>)))
           (equal (i->m (i-xor_<tsp>_<tsp>-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; To make the next theorem work I had to change the -okp fn to
; insure that the nextword was an i-objectp

(prove-lemma i-m-one-way-correspondence-step-move-z_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-z_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-z_<tsp>_*)))
           (equal (i->m (i-move-z_<tsp>_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move-n_x_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-n_x_*-okp i)
                (equal (i-current-instruction i) '(move-n_x_*)))
           (equal (i->m (i-move-n_x_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move_<tsp>_*)))
           (equal (i->m (i-move_<tsp>_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma listp-nat-to-v (rewrite)
  (equal (listp (nat-to-v n word-size))
         (not (zerop word-size))))

(prove-lemma listp-int-to-v (rewrite)
  (equal (listp (int-to-v i word-size))
         (not (zerop word-size)))
  ((enable int-to-v)))

(prove-lemma i-m-one-way-correspondence-step-incr_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(incr_<tsp>_<tsp>{i})))
           (equal (i->m (i-incr_<tsp>_<tsp>{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-incr alu-thm_nat-c-incr
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-sub_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{i}_x{i})))
           (equal (i->m (i-sub_<tsp>{i}_x{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-sub alu-thm_nat-c-sub
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-decr_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-decr_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(decr_<tsp>_<tsp>{i})))
           (equal (i->m (i-decr_<tsp>_<tsp>{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-decr alu-thm_nat-c-decr
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-neg_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-neg_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(neg_<tsp>_<tsp>{i})))
           (equal (i->m (i-neg_<tsp>_<tsp>{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-asr_<c>_<tsp>_<tsp>{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-asr_<c>_<tsp>_<tsp>{b}-okp i)
                (equal (i-current-instruction i) '(asr_<c>_<tsp>_<tsp>{b})))
           (equal (i->m (i-asr_<c>_<tsp>_<tsp>{b}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma plus-1 (rewrite) (equal (plus 1 x) (add1 x)))

(prove-lemma not-zerop-exp-2-32 (rewrite) (lessp 0 (exp 2 32))
 ((enable *1*exp)))

(prove-lemma i-m-one-way-correspondence-step-addc_<c>_x{n}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-addc_<c>_x{n}_y{n}-okp i)
                (equal (i-current-instruction i) '(addc_<c>_x{n}_y{n})))
           (equal (i->m (i-addc_<c>_x{n}_y{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-addc get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-add_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{n}_x{n})))
           (equal (i->m (i-add_<tsp>{n}_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-incr_<tsp>_<tsp>{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i) '(incr_<tsp>_<tsp>{n})))
           (equal (i->m (i-incr_<tsp>_<tsp>{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-incr get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-incr_y_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_y_y{n}-okp i)
                (equal (i-current-instruction i) '(incr_y_y{n})))
           (equal (i->m (i-incr_y_y{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-incr get nat-to-v link-table-entry)))

; The following lemma, put-link-segment-no-op, states that it is a
; no-op to put into the link-segment of a segment a value that is
; the link-word of what is already at the corresponding position
; in the segment.  This lemma is what enables us to convert from
; one data type to another, e.g., from INT to NAT, by doing an
; explicit push in the i-level machine but a no-op in the m-level.
; To justify such an act all we need to know is that the link-word
; of what is being pushed is the link-word of what was already
; there.

(prove-lemma put-link-area-no-op (rewrite)
  (implies (and (numberp offset)
                (lessp offset (length v)))
           (equal (put (link-word (unlabel (get offset v))
                                  link-tables word-size)
                       offset
                       (link-area v link-tables word-size))
                  (link-area v link-tables word-size))))

(prove-lemma put-link-segment-no-op (rewrite)
  (implies (and (definedp name segment)
                (numberp offset)
                (lessp offset (length (cdr (assoc name segment))))
                (equal val
                       (link-word (unlabel
                                   (get offset (cdr (assoc name segment))))
                                  link-tables
                                  word-size)))
           (equal (equal (put val
                              (plus (link-table-entry name segment)
                                    offset)
                              (link-segment segment link-tables word-size))
                         (link-segment segment link-tables word-size))
                  t)))

; For the INT-TO-NAT case the justification is then:

(prove-lemma int-to-v-is-nat-to-v-on-nats (rewrite)
  (implies (numberp n)
           (equal (int-to-v n word-size)
                  (nat-to-v n word-size)))
  ((enable int-to-v)))

(prove-lemma i-m-one-way-correspondence-step-int-to-nat (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-int-to-nat-okp i)
                (equal (i-current-instruction i) '(int-to-nat)))
           (equal (i->m (i-int-to-nat-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(disable int-to-v-is-nat-to-v-on-nats)

(prove-lemma i-m-one-way-correspondence-step-decr_<tsp>_<tsp>{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-decr_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i) '(decr_<tsp>_<tsp>{n})))
           (equal (i->m (i-decr_<tsp>_<tsp>{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-decr get nat-to-v link-table-entry)))

(enable times-2)

(prove-lemma i-m-one-way-correspondence-step-add_<c>_x_x{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<c>_x_x{n}-okp i)
                (equal (i-current-instruction i)
                       '(add_<c>_x_x{n})))
           (equal (i->m (i-add_<c>_x_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-add_<tsp>_<tsp>{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i)
                       '(add_<tsp>_<tsp>{n})))
           (equal (i->m (i-add_<tsp>_<tsp>{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add get nat-to-v link-table-entry)))

(prove-lemma remainder-by-2 (rewrite)
  (implies (not (equal (remainder x 2) 0))
           (equal (remainder x 2) 1)))

(prove-lemma i-m-one-way-correspondence-step-lsr_<c>_x_x{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-lsr_<c>_x_x{n}-okp i)
                (equal (i-current-instruction i)
                       '(lsr_<c>_x_x{n})))
           (equal (i->m (i-lsr_<c>_x_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-subb_<c>_x{n}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-subb_<c>_x{n}_y{n}-okp i)
                (equal (i-current-instruction i) '(subb_<c>_x{n}_y{n})))
           (equal (i->m (i-subb_<c>_x{n}_y{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-subb get nat-to-v link-table-entry)))

; I redefined the -step fn below because it had the wrong parity on the
; c-flg!

(prove-lemma i-m-one-way-correspondence-step-sub_<c>_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<c>_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<c>_<tsp>{n}_x{n})))
           (equal (i->m (i-sub_<c>_<tsp>{n}_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-sub get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-sub_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{n}_x{n})))
           (equal (i->m (i-sub_<tsp>{n}_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-sub get nat-to-v link-table-entry)))

; The use hint below is necessary here because we have the hypothesis
; that both the top of tsp and x are addresses into the same usr-data
; area.  The rewriter replaces references to the adp-name of the top
; of tsp with references to the adp-name of x because it is simpler.
; But that prevents the firing of our rewrite rules for establishing
; that addresses link to small-naturalps.

(prove-lemma i-m-one-way-correspondence-step-sub_<c>_<tsp>{a}_x{a} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<c>_<tsp>{a}_x{a}-okp i)
                (equal (i-current-instruction i) '(sub_<c>_<tsp>{a}_x{a})))
           (equal (i->m (i-sub_<c>_<tsp>{a}_x{a}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-sub get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (get (adp-offset (untag (i-tsp i)))
                            (cdr (assoc 'tstk
                                        (i-sys-data-segment i)))))))
         (offset (adp-offset
                  (untag (get (adp-offset (untag (i-tsp i)))
                              (cdr (assoc 'tstk
                                          (i-sys-data-segment i)))))))
         (segment (i-usr-data-segment i))))))

(prove-lemma i-m-one-way-correspondence-step-sub_<tsp>{s}_x{s} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{s}_x{s}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{s}_x{s})))
           (equal (i->m (i-sub_<tsp>{s}_x{s}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-sub get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (get (adp-offset (untag (i-tsp i)))
                            (cdr (assoc 'tstk
                                        (i-sys-data-segment i)))))))
         (offset (adp-offset
                  (untag (get (adp-offset (untag (i-tsp i)))
                              (cdr (assoc 'tstk
                                          (i-sys-data-segment i)))))))
         (segment (i-sys-data-segment i))))))


(prove-lemma v-nzerop-nat-to-v-bridge (rewrite)
  (implies (and (equal firstn (nat-to-v n word-size))
                (lessp n (exp 2 word-size)))
           (equal (v-nzerop firstn) (not (zerop n)))))

(prove-lemma equal-difference-zero (rewrite)
  (equal (equal (difference x y) 0)
         (not (lessp y x))))

(prove-lemma equal-v-to-nat-v-to-nat (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b)))
           (equal (equal (v-to-nat a) (v-to-nat b))
                  (equal a b)))
  ((enable boolp)
   (induct (v-and a b))))

(enable my-lessp-v-to-nat-exp)

(prove-lemma alu-thm_bitv-zb-sub (rewrite)
  (implies (and (bvp a)
                (bvp b)
                (equal (length a) (length b))
                (boolp c))
           (equal (zb (v-alu c a b (list t t t f)))
                  (equal a b)))
  ((disable alu-thm_nat-bv-sub alu-thm_tc-bv-sub)
   (use (alu-thm_nat-bv-sub))
   (enable bv zb v-alu)))

(prove-lemma i-m-one-way-correspondence-step-sub_<z>_x{s}_y{s}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<z>_x{s}_y{s}-okp i)
                (equal (i-current-instruction i)
                       '(sub_<z>_x{s}_y{s})))
           (equal (i->m (i-sub_<z>_x{s}_y{s}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-sub get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (i-y i))))
         (offset (adp-offset
                  (untag (i-y i))))
         (segment (i-sys-data-segment i))))))

; To make the next thm work I changed the -okp fn to insure
; that nextword is an i-objectp.  I also changed the link instruction
; alist.

(prove-lemma i-m-one-way-correspondence-step-move-c_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-c_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-c_<tsp>_*)))
           (equal (i->m (i-move-c_<tsp>_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-move-v_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-v_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-v_<tsp>_*)))
           (equal (i->m (i-move-v_<tsp>_*-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma v-or-append (rewrite)
  (implies (and (equal (length a) (length b))
                (bvp x)
                (bvp y))
           (equal (v-or (append a x)
                        (append b y))
                  (append (v-or a b)
                            (v-or x y)))))

(prove-lemma v-or-bitv-to-v (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (equal (v-or (bitv-to-v x word-size)
                        (bitv-to-v y word-size))
                  (bitv-to-v (or-bitv x y) word-size))))

(prove-lemma commutativity-of-or-bitv (rewrite)
  (implies (equal (length x) (length y))
           (equal (or-bitv x y) (or-bitv y x))))

(prove-lemma i-m-one-way-correspondence-step-or_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-or_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(or_<tsp>{v}_x{v})))
           (equal (i->m (i-or_<tsp>{v}_x{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma v-and-append (rewrite)
  (implies (and (equal (length a) (length b))
                (bvp x)
                (bvp y))
           (equal (v-and (append a x)
                         (append b y))
                  (append (v-and a b)
                            (v-and x y)))))

(prove-lemma v-and-bitv-to-v (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (equal (v-and (bitv-to-v x word-size)
                         (bitv-to-v y word-size))
                  (bitv-to-v (and-bitv x y) word-size))))

(prove-lemma commutativity-of-and-bitv (rewrite)
  (implies (equal (length x) (length y))
           (equal (and-bitv x y) (and-bitv y x))))

(prove-lemma i-m-one-way-correspondence-step-and_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-and_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(and_<tsp>{v}_x{v})))
           (equal (i->m (i-and_<tsp>{v}_x{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma v-not-append (rewrite)
  (implies (bvp x)
           (equal (v-not (append a x))
                  (append (v-not a)
                            (v-not x)))))

(prove-lemma v-not-bitv-to-v (rewrite)
  (implies (bit-vectorp x word-size)
           (equal (v-not (bitv-to-v x word-size))
                  (bitv-to-v (not-bitv x) word-size))))

(prove-lemma i-m-one-way-correspondence-step-not_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-not_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(not_<tsp>_<tsp>{v})))
           (equal (i->m (i-not_<tsp>_<tsp>{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma v-xor-bitv-to-v (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (equal (v-xor (bitv-to-v x word-size)
                         (bitv-to-v y word-size))
                  (bitv-to-v (xor-bitv x y) word-size))))

(prove-lemma i-m-one-way-correspondence-step-xor_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{v}_x{v})))
           (equal (i->m (i-xor_<tsp>{v}_x{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma cdr-bitv-to-v (rewrite)
  (implies (and (listp x)
                (bit-vectorp x word-size))
           (equal (cdr (bitv-to-v x word-size))
                  (bitv-to-v (all-but-last x) (sub1 word-size)))))

(prove-lemma listp-append (rewrite)
  (equal (listp (append a b))
         (or (listp a) (listp b))))

(prove-lemma cdr-append (rewrite)
  (equal (cdr (append a b))
         (if (listp a) (append (cdr a) b) (cdr b))))

(prove-lemma v-buf-append (rewrite)
  (equal (v-buf (append a b)) (append (v-buf a) (v-buf b))))

(prove-lemma v-lsr-bitv-to-v (rewrite)
  (implies (bit-vectorp x word-size)
           (equal (v-lsr (bitv-to-v x word-size))
                  (bitv-to-v (rsh-bitv x) word-size)))
  ((enable v-buf-works)))

; The following two disables are motivated merely by the fact that the
; named lemmas were proved for the fm9001 effort and hence might get
; in the way.

(disable v-buf-append)
(disable cdr-append)

(prove-lemma i-m-one-way-correspondence-step-lsr_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-lsr_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(lsr_<tsp>_<tsp>{v})))
           (equal (i->m (i-lsr_<tsp>_<tsp>{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-lsr alu-thm_nat-c-lsr
            v-lsr
            get nat-to-v link-table-entry)))

(prove-lemma lsh-lemma-1 (rewrite)
  (implies (and (bit-vectorp x word-size)
                (not (zerop word-size)))
           (equal (bitv-to-v (append (cdr x) '(0)) word-size)
                  (cons f (bitv-to-v (cdr x) (sub1 word-size))))))

; Four of the next six lemmas use (plus x x y y) where (plus i i) could be
; used and then instantiated with (plus x y) and rearranged.  But
; they are, as stated, exactly what is needed and they go through
; without help.

(prove-lemma remainder-add1-xxyy-2 (rewrite)
  (equal (remainder (add1 (plus x x y y)) 2) 1))

(prove-lemma quotient-add1-xxyy-2 (rewrite)
  (equal (quotient (add1 (plus x x y y)) 2)
         (plus x y)))

(prove-lemma remainder-xx-2 (rewrite)
  (equal (remainder (plus x x) 2) 0))

(prove-lemma quotient-xx-2  (rewrite)
  (equal (quotient (plus x x) 2)
         (fix x)))

(prove-lemma remainder-xxyy-2 (rewrite)
  (equal (remainder (plus x x y y) 2) 0))

(prove-lemma quotient-xxyy-2  (rewrite)
  (equal (quotient (plus x x y y) 2)
         (plus x y)))

(prove-lemma lsh-lemma-2 (rewrite)
  (equal (nat-to-v (plus z (exp 2 word-size)) word-size)
         (nat-to-v z word-size)))

(prove-lemma lsh-lemma-3 (rewrite)
  (equal (nat-to-v (plus z (exp 2 word-size) u) word-size)
         (nat-to-v (plus z u) word-size))
  ((use (lsh-lemma-2 (z (plus z u)))
        (commutativity-of-plus (x (exp 2 word-size)) (y u)))))

(prove-lemma lsh-lemma-4 (rewrite)
  (equal (nat-to-v (plus z (times (exp 2 word-size) v)) word-size)
         (nat-to-v z word-size))
  ((induct (times v xxx))))

(disable times-commutes)

(prove-lemma lsh-lemma-5 (rewrite)
  (implies (numberp x)
           (equal (nat-to-v (remainder x (exp 2 word-size)) word-size)
                  (nat-to-v x word-size))))

(prove-lemma lsh-lemma-6 (rewrite)
  (implies (not (zerop word-size))
           (equal (nat-to-v (plus x x) word-size)
                  (cons f (nat-to-v x (sub1 word-size))))))

(prove-lemma remainder-add1-xx-2 (rewrite)
  (equal (remainder (add1 (plus x x)) 2) 1))

(prove-lemma quotient-add1-xx-2 (rewrite)
  (equal (quotient (add1 (plus x x)) 2) (fix x)))

(prove-lemma lsh-lemma-7 (rewrite)
  (implies (and (bvp x)
                (equal k (length x)))
           (equal (nat-to-v (v-to-nat (append x y)) k)
                  x))
  ((enable boolp)))

(enable bvp-append)

(prove-lemma i-m-one-way-correspondence-step-add_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>_<tsp>{v})))
           (equal (i->m (i-add_<tsp>_<tsp>{v}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add remainder-opener get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-or_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-or_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(or_<tsp>{b}_x{b})))
           (equal (i->m (i-or_<tsp>{b}_x{b}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-and_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-and_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(and_<tsp>{b}_x{b})))
           (equal (i->m (i-and_<tsp>{b}_x{b}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-xor_<tsp>{b}_*{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{b}_*{b}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{b}_*{b})))
           (equal (i->m (i-xor_<tsp>{b}_*{b}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-xor_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{b}_x{b})))
           (equal (i->m (i-xor_<tsp>{b}_x{b}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable get nat-to-v link-table-entry)))

; The following lemma is just enough arithmetic to get the add_pc_x{n}
; lemma.  As noted before, I've adopted the strategy of not automatically
; rewriting arithmetic expressions.  I could perhaps get the proof with
; associativity and commutativity available, but I don't want to even
; bother trying.

(prove-lemma commutativity-of-plus-hack (rewrite)
  (equal (plus load-addr
               (segment-length (i-usr-data-segment i))
               (link-table-entry (adp-name (untag (i-pc i)))
                                 (i-prog-segment i))
               (adp-offset (untag (i-pc i)))
               (untag (i-x i)))
         (plus (untag (i-x i))
               load-addr
               (segment-length (i-usr-data-segment i))
               (link-table-entry (adp-name (untag (i-pc i)))
                                 (i-prog-segment i))
               (adp-offset (untag (i-pc i))))))

(disable equal-length-0)
(disable remainder-opener)

(prove-lemma i-m-one-way-correspondence-step-add_pc_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_pc_x{n}-okp i)
                (equal (i-current-instruction i) '(add_pc_x{n})))
           (equal (i->m (i-add_pc_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add get nat-to-v link-table-entry)))

(prove-lemma i-m-one-way-correspondence-step-add_x_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_x_x{n}-okp i)
                (equal (i-current-instruction i) '(add_x_x{n})))
           (equal (i->m (i-add_x_x{n}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_tc-bv-add get nat-to-v link-table-entry)))

(enable associativity-of-iplus)

(enable commutativity2-of-iplus)

(prove-lemma i-m-one-way-correspondence-step-addc_<v>_x{i}_y{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-addc_<v>_x{i}_y{i}-okp i)
                (equal (i-current-instruction i) '(addc_<v>_x{i}_y{i})))
           (equal (i->m (i-addc_<v>_x{i}_y{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable alu-thm_nat-bv-addc alu-thm_nat-c-addc
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma tc-minus-is-inegate (rewrite)
  (equal (tc-minus x) (inegate x)))

(disable tc-minus)

(prove-lemma integerp-inegate (rewrite)
  (integerp (inegate x)))

(prove-lemma ineg-is-inegate (rewrite)
  (equal (ineg x) (inegate x)))

(disable ineg)

(prove-lemma i-m-one-way-correspondence-step-subb_<v>_x{i}_y{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-subb_<v>_x{i}_y{i}-okp i)
                (equal (i-current-instruction i) '(subb_<v>_x{i}_y{i})))
           (equal (i->m (i-subb_<v>_x{i}_y{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
    ((disable alu-thm_nat-bv-subb alu-thm_nat-c-subb
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            inegate
            get nat-to-v link-table-entry)))

; To relieve one of the hypotheses above we need the following lemma.
; Intuitively it says that (inegate x) is a small-integerp if x is.
; That's not true, because x might be the most negative integer, which
; has no small opposite.  But in the case in question we know that
; (inegate x) + y is negative, so things work out to tell us that  x isn't
; the most negative.

(prove-lemma small-integerp-inegate (rewrite)
  (implies (and (not (zerop word-size))
                (small-integerp x word-size)
                (negativep (iplus (inegate x) y))
                (small-integerp y word-size))
           (small-integerp (inegate x) word-size)))

(prove-lemma small-integerp-fix-small-integer-case-1 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (not (small-integerp (iplus (inegate x) y) word-size))
                (negativep (iplus (inegate x) y)))
           (small-integerp (iplus (exp 2 word-size) (iplus (inegate x) y))
                           word-size)))

(prove-lemma small-integerp-fix-small-integer-case-2 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (not (small-integerp (iplus (inegate x) y) word-size))
                (not (negativep (iplus (inegate x) y))))
           (small-integerp (iplus (minus (exp 2 word-size))
                                  (iplus (inegate x) y))
                           word-size)))

(prove-lemma i-m-one-way-correspondence-step-sub_<nv>_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<nv>_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(sub_<nv>_<tsp>{i}_x{i})))
           (equal (i->m (i-sub_<nv>_<tsp>{i}_x{i}-step i) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
    ((enable n)
     (disable alu-thm_nat-bv-subb alu-thm_nat-c-subb
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            inegate
            get nat-to-v link-table-entry)))

(prove-lemma i-current-instruction-packer-lemma nil
  (implies (and (equal (car ins) (pack opcode))
                (equal (cdr ins) nil))
           (equal ins
                  (list (pack opcode)))))

(prove-lemma i-current-instruction-packer (rewrite)
  (implies (and (equal (car (i-current-instruction i)) (pack opcode))
                (equal (cdr (i-current-instruction i)) nil))
           (equal (i-current-instruction i)
                  (list (pack opcode))))
  ((use (i-current-instruction-packer-lemma
         (ins (i-current-instruction i))))))

(prove-lemma i-m-one-way-correspondence-ins-okp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-ins-okp (i-current-instruction i) i))
           (equal (i->m (i-ins-step (i-current-instruction i) i load-addr) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
  ((disable
    i-state-okp i-state-okp-restructuring
    i-current-instruction
    i->m
    m-step
    i-add_<c>_x_x{n}-okp
    i-add_<c>_x_x{n}-step
    i-add_<tsp>_<tsp>{v}-okp
    i-add_<tsp>_<tsp>{v}-step
    i-add_<tsp>_<tsp>{n}-okp
    i-add_<tsp>_<tsp>{n}-step
    i-add_<tsp>{a}_x{n}-okp
    i-add_<tsp>{a}_x{n}-step
    i-add_tsp_*{n}-okp
    i-add_tsp_*{n}-step
    i-add_tsp_x{n}-okp
    i-add_tsp_x{n}-step
    i-add_<tsp>{i}_x{i}-okp
    i-add_<tsp>{i}_x{i}-step
    i-add_<tsp>{n}_x{n}-okp
    i-add_<tsp>{n}_x{n}-step
    i-add_pc_x{n}-okp
    i-add_pc_x{n}-step
    i-add_x_x{n}-okp
    i-add_x_x{n}-step
    i-add_x{n}_csp-okp
    i-add_x{n}_csp-step
    i-addc_<c>_x{n}_y{n}-okp
    i-addc_<c>_x{n}_y{n}-step
    i-addc_<v>_x{i}_y{i}-okp
    i-addc_<v>_x{i}_y{i}-step
    i-and_<tsp>{v}_x{v}-okp
    i-and_<tsp>{v}_x{v}-step
    i-and_<tsp>{b}_x{b}-okp
    i-and_<tsp>{b}_x{b}-step
    i-asr_<c>_<tsp>_<tsp>{b}-okp
    i-asr_<c>_<tsp>_<tsp>{b}-step
    i-cpop_cfp-okp
    i-cpop_cfp-step
    i-cpop_pc-okp
    i-cpop_pc-step
    i-cpush_*-okp
    i-cpush_*-step
    i-cpush_<tsp>+-okp
    i-cpush_<tsp>+-step
    i-cpush_cfp-okp
    i-cpush_cfp-step
    i-decr_<tsp>_<tsp>{i}-okp
    i-decr_<tsp>_<tsp>{i}-step
    i-decr_<tsp>_<tsp>{n}-okp
    i-decr_<tsp>_<tsp>{n}-step
    i-incr_<tsp>_<tsp>{i}-okp
    i-incr_<tsp>_<tsp>{i}-step
    i-incr_<tsp>_<tsp>{n}-okp
    i-incr_<tsp>_<tsp>{n}-step
    i-incr_y_y{n}-okp
    i-incr_y_y{n}-step
    i-int-to-nat-okp
    i-int-to-nat-step
    i-jump-n_x-okp
    i-jump-n_x-step
    i-jump-nn_x-okp
    i-jump-nn_x-step
    i-jump-nz_x-okp
    i-jump-nz_x-step
    i-jump-z_x-okp
    i-jump-z_x-step
    i-jump_*-okp
    i-jump_*-step
    i-jump_x{subr}-okp
    i-jump_x{subr}-step
    i-lsr_<c>_x_x{n}-okp
    i-lsr_<c>_x_x{n}-step
    i-lsr_<tsp>_<tsp>{v}-okp
    i-lsr_<tsp>_<tsp>{v}-step
    i-move-c_<tsp>_*-okp
    i-move-c_<tsp>_*-step
    i-move-v_<tsp>_*-okp
    i-move-v_<tsp>_*-step
    i-move-z_<tsp>_*-okp
    i-move-z_<tsp>_*-step
    i-move-n_x_*-okp
    i-move-n_x_*-step
    i-move_<tsp>_*-okp
    i-move_<tsp>_*-step
    i-move_<x{a}>_<tsp>-okp
    i-move_<x{a}>_<tsp>-step
    i-move_<x{s}>_<tsp>-okp
    i-move_<x{s}>_<tsp>-step
    i-move_cfp_csp-okp
    i-move_cfp_csp-step
    i-move_csp_cfp-okp
    i-move_csp_cfp-step
    i-move_x_*-okp
    i-move_x_*-step
    i-move_x_<x{s}>-okp
    i-move_x_<x{s}>-step
    i-move_x_tsp-okp
    i-move_x_tsp-step
    i-move_x_x-okp
    i-move_x_x-step
    i-move_y_*-okp
    i-move_y_*-step
    i-move_y_<y{s}>-okp
    i-move_y_<y{s}>-step
    i-move_y_tsp-okp
    i-move_y_tsp-step
    i-neg_<tsp>_<tsp>{i}-okp
    i-neg_<tsp>_<tsp>{i}-step
    i-not_<tsp>_<tsp>{v}-okp
    i-not_<tsp>_<tsp>{v}-step
    i-or_<tsp>{v}_x{v}-okp
    i-or_<tsp>{v}_x{v}-step
    i-or_<tsp>{b}_x{b}-okp
    i-or_<tsp>{b}_x{b}-step
    i-sub_<c>_<tsp>{a}_x{a}-okp
    i-sub_<c>_<tsp>{a}_x{a}-step
    i-sub_<c>_<tsp>{n}_x{n}-okp
    i-sub_<c>_<tsp>{n}_x{n}-step
    i-sub_<nv>_<tsp>{i}_x{i}-okp
    i-sub_<nv>_<tsp>{i}_x{i}-step
    i-sub_<tsp>{a}_x{n}-okp
    i-sub_<tsp>{a}_x{n}-step
    i-sub_x{s}_y{n}-okp
    i-sub_x{s}_y{n}-step
    i-sub_<tsp>{i}_x{i}-okp
    i-sub_<tsp>{i}_x{i}-step
    i-sub_<tsp>{n}_x{n}-okp
    i-sub_<tsp>{n}_x{n}-step
    i-sub_<tsp>{s}_x{s}-okp
    i-sub_<tsp>{s}_x{s}-step
    i-sub_<z>_x{s}_y{s}-okp
    i-sub_<z>_x{s}_y{s}-step
    i-subb_<c>_x{n}_y{n}-okp
    i-subb_<c>_x{n}_y{n}-step
    i-subb_<v>_x{i}_y{i}-okp
    i-subb_<v>_x{i}_y{i}-step
    i-tpop_<c>_x-okp
    i-tpop_<c>_x-step
    i-tpop_<x{a}>-okp
    i-tpop_<x{a}>-step
    i-tpop_<x{s}>-okp
    i-tpop_<x{s}>-step
    i-tpop_pc-okp
    i-tpop_pc-step
    i-tpop_x-okp
    i-tpop_x-step
    i-tpop_y-okp
    i-tpop_y-step
    i-tpop{v}_<z>_y-okp
    i-tpop{v}_<z>_y-step
    i-tpop{b}_<z>_y-okp
    i-tpop{b}_<z>_y-step
    i-tpop{i}_<zn>_y-okp
    i-tpop{i}_<zn>_y-step
    i-tpop{n}_<z>_y-okp
    i-tpop{n}_<z>_y-step
    i-tpush_*-okp
    i-tpush_*-step
    i-tpush_<x{a}>-okp
    i-tpush_<x{a}>-step
    i-tpush_<x{s}>-okp
    i-tpush_<x{s}>-step
    i-tpush_csp-okp
    i-tpush_csp-step
    i-tpush_tsp-okp
    i-tpush_tsp-step
    i-tpush_x-okp
    i-tpush_x-step
    i-xor_<tsp>_<tsp>-okp
    i-xor_<tsp>_<tsp>-step
    i-xor_<tsp>{v}_x{v}-okp
    i-xor_<tsp>{v}_x{v}-step
    i-xor_<tsp>{b}_*{b}-okp
    i-xor_<tsp>{b}_*{b}-step
    i-xor_<tsp>{b}_x{b}-okp
    i-xor_<tsp>{b}_x{b}-step
    i-xor_<z>_<tsp>_x-okp
    i-xor_<z>_<tsp>_x-step
    )))

(prove-lemma i-m-one-way-correspondence-step (rewrite)
  (implies (and (numberp load-addr)
                (equal (i-psw (i-step i load-addr)) 'run)
                (equal (i-word-size i) 32))
           (equal (i->m (i-step i load-addr) boot-lst load-addr)
                  (m-step (i->m i boot-lst load-addr))))
 ((disable i-state-okp i-state-okp-restructuring
           i-current-instruction
           i-ins-okp
           i-ins-step)))

(prove-lemma i-word-size-i-halt (rewrite)
  (equal (i-word-size (i-halt i psw)) (i-word-size i))
  ((enable i-halt)))

; The following two lemmas and then i-word-size-i-ins-step follow exactly
; the same strategy described above for i-psw-i-ins-step.

(prove-lemma equal-i-word-size-if-1 (rewrite)
  (equal (equal (i-word-size (if t1 b1 b2)) w)
         (if t1
             (equal (i-word-size b1) w)
             (equal (i-word-size b2) w))))

(prove-lemma equal-i-word-size-if-2 (rewrite)
  (equal (equal (i-word-size (if t1 b1 (if t2 b2 b3))) w)
         (if t1
             (equal (i-word-size b1) w)
             (if t2
                 (equal (i-word-size b2) w)
                 (equal (i-word-size b3) w)))))

(prove-lemma i-word-size-i-ins-step (rewrite)
  (equal (i-word-size (i-ins-step ins i load-addr)) (i-word-size i))
  ((hands-off
    lsh-bitv times add-addr small-naturalp fix-small-natural and-bitv
    and-bool sub1 remainder quotient rsh-bitv inegate not-bitv or-bitv
    or-bool sub-addr offset exp difference plus lessp small-integerp
    not bool-to-nat iplus idifference fix-small-integer area-name
    definition ipc negativep pop-stk push-stk xor-bitv i-nextword untag
    xor-bool i-z-flg add2-i-pc tag deposit i-psw
    i-usr-data-segment i-prog-segment i-sys-data-segment fetch xor-xxx
    all-zero-bitvp bool i-n-flg i-v-flg i-c-flg i-y i-x i-tsp i-csp
    i-cfp add1-i-pc i-state pack cons add1 zero)))

; The hint above is mechanically generated as in i-psw case mentioned
; above, except that it does not include i-word-size.

(prove-lemma i-word-size-i-step (rewrite)
  (equal (i-word-size (i-step i load-addr)) (i-word-size i))
  ((disable i-state-okp i-state-okp-restructuring
            i-current-instruction
            i-ins-okp
            i-ins-step)))

(prove-lemma i-psw-i-run (rewrite)
  (implies (equal (i-psw (i i n load-addr)) 'run)
           (equal (i-psw i) 'run))
  ((disable i-step)))

(prove-lemma i-m-one-way-correspondence (rewrite)
  (implies (and (numberp load-addr)
                (equal (i-psw (i i n load-addr)) 'run)
                (equal (i-word-size i) 32))
           (equal (i->m (i i n load-addr) boot-lst load-addr)
                  (m (i->m i boot-lst load-addr) n)))
  ((induct (i i n load-addr))
   (disable i-step m-step i->m i-state-okp i-state-okp-restructuring
            i-ins-okp i-ins-step)))

;  We now prove that i-state-okp is preserved by i-step.  We do
;  it in a very predictable way:  we prove it for each stepper.
;  First a few lemmas...

(prove-lemma assoc-put-assoc (rewrite)
  (implies (definedp name2 alist)
           (equal (assoc name1
                         (put-assoc val name2 alist))
                  (if (equal name1 name2)
                      (cons name1 val)
                      (assoc name1 alist))))
  nil)

(prove-lemma cddr-tag (rewrite)
  (equal (cddr (tag type obj))
         nil)
  ((enable tag)))

;  Now comes the litany of instructions.

;  After the first two, the hints for all of these preservation lemmas
;  are derived mechanically from the hint for the corresponding
;  one-way-correspondence lemma above by simply adding to the old hint
;  the disabling of the restructuring lemma and the enabling of
;  i-state-okp.

(prove-lemma i-state-okp-i-move_x_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_x_x-okp i))
           (i-state-okp (i-move_x_x-step i) load-addr))
  ((disable i-state-okp-restructuring)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-cpush_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-cpush_*-okp i))
           (i-state-okp (i-cpush_*-step i) load-addr))
  ((disable i-state-okp-restructuring)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<tsp>{i}_x{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<tsp>{i}_x{i}-okp i))
           (i-state-okp (i-add_<tsp>{i}_x{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-add
            alu-thm_nat-c-add int-to-v v-to-int small-integerp
            integerp iplus get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_cfp_csp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_cfp_csp-okp i))
           (i-state-okp (i-move_cfp_csp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-cpush_<tsp>+-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-cpush_<tsp>+-okp i))
           (i-state-okp (i-cpush_<tsp>+-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_csp_cfp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_csp_cfp-okp i))
           (i-state-okp (i-move_csp_cfp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_x_tsp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_x_tsp-okp i))
           (i-state-okp (i-move_x_tsp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-cpop_cfp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-cpop_cfp-okp i))
           (i-state-okp (i-cpop_cfp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_x_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_x_*-okp i))
           (i-state-okp (i-move_x_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_y_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_y_*-okp i))
           (i-state-okp (i-move_y_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_x{n}_csp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_x{n}_csp-okp i))
           (i-state-okp (i-add_x{n}_csp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_x_<x{s}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_x_<x{s}>-okp i))
           (i-state-okp (i-move_x_<x{s}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_y_<y{s}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_y_<y{s}>-okp i))
           (i-state-okp (i-move_y_<y{s}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_y_tsp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_y_tsp-okp i))
           (i-state-okp (i-move_y_tsp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_csp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_csp-okp i))
           (i-state-okp (i-tpush_csp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_tsp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_tsp-okp i))
           (i-state-okp (i-tpush_tsp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_x-okp i))
           (i-state-okp (i-tpush_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_<x{s}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_<x{s}>-okp i))
           (i-state-okp (i-tpush_<x{s}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_<x{a}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_<x{a}>-okp i))
           (i-state-okp (i-tpush_<x{a}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpush_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpush_*-okp i))
           (i-state-okp (i-tpush_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_x-okp i))
           (i-state-okp (i-tpop_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_y-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_y-okp i))
           (i-state-okp (i-tpop_y-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_<x{s}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_<x{s}>-okp i))
           (i-state-okp (i-tpop_<x{s}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_<x{a}>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_<x{a}>-okp i))
           (i-state-okp (i-tpop_<x{a}>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump_*-okp i))
           (i-state-okp (i-jump_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-cpop_pc-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-cpop_pc-okp i))
           (i-state-okp (i-cpop_pc-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_<x{s}>_<tsp>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_<x{s}>_<tsp>-okp i))
           (i-state-okp (i-move_<x{s}>_<tsp>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_<x{a}>_<tsp>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_<x{a}>_<tsp>-okp i))
           (i-state-okp (i-move_<x{a}>_<tsp>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump_x{subr}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump_x{subr}-okp i))
           (i-state-okp (i-jump_x{subr}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump-n_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump-n_x-okp i))
           (i-state-okp (i-jump-n_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump-nn_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump-nn_x-okp i))
           (i-state-okp (i-jump-nn_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump-z_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump-z_x-okp i))
           (i-state-okp (i-jump-z_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-jump-nz_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-jump-nz_x-okp i))
           (i-state-okp (i-jump-nz_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_pc-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_pc-okp i))
           (i-state-okp (i-tpop_pc-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop_<c>_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop_<c>_x-okp i))
           (i-state-okp (i-tpop_<c>_x-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop{n}_<z>_y-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop{n}_<z>_y-okp i))
           (i-state-okp (i-tpop{n}_<z>_y-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop{i}_<zn>_y-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop{i}_<zn>_y-okp i))
           (i-state-okp (i-tpop{i}_<zn>_y-step i) load-addr))
  ((disable i-state-okp-restructuring int-to-v v-to-int
            small-integerp integerp get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop{b}_<z>_y-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop{b}_<z>_y-okp i))
           (i-state-okp (i-tpop{b}_<z>_y-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-tpop{v}_<z>_y-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-tpop{v}_<z>_y-okp i))
           (i-state-okp (i-tpop{v}_<z>_y-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<tsp>{a}_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<tsp>{a}_x{n}-okp i))
           (i-state-okp (i-add_<tsp>{a}_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_tsp_*{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_tsp_*{n}-okp i))
           (i-state-okp (i-add_tsp_*{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_tsp_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_tsp_x{n}-okp i))
           (i-state-okp (i-add_tsp_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<tsp>{a}_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<tsp>{a}_x{n}-okp i))
           (i-state-okp (i-sub_<tsp>{a}_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_x{s}_y{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_x{s}_y{n}-okp i))
           (i-state-okp (i-sub_x{s}_y{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-xor_<tsp>_<tsp>-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-xor_<tsp>_<tsp>-okp i))
           (i-state-okp (i-xor_<tsp>_<tsp>-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move-z_<tsp>_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move-z_<tsp>_*-okp i))
           (i-state-okp (i-move-z_<tsp>_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move-n_x_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move-n_x_*-okp i))
           (i-state-okp (i-move-n_x_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move_<tsp>_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move_<tsp>_*-okp i))
           (i-state-okp (i-move_<tsp>_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-incr_<tsp>_<tsp>{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-incr_<tsp>_<tsp>{i}-okp i))
           (i-state-okp (i-incr_<tsp>_<tsp>{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-incr
            alu-thm_nat-c-incr int-to-v v-to-int small-integerp
            integerp iplus get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-xor_<z>_<tsp>_x-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-xor_<z>_<tsp>_x-okp i))
           (i-state-okp (i-xor_<z>_<tsp>_x-step i load-addr) load-addr))
  ((disable i-state-okp-restructuring xor-xxx get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<tsp>{i}_x{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<tsp>{i}_x{i}-okp i))
           (i-state-okp (i-sub_<tsp>{i}_x{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-sub
            alu-thm_nat-c-sub int-to-v v-to-int small-integerp
            integerp iplus get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-decr_<tsp>_<tsp>{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-decr_<tsp>_<tsp>{i}-okp i))
           (i-state-okp (i-decr_<tsp>_<tsp>{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-decr
            alu-thm_nat-c-decr int-to-v v-to-int small-integerp
            integerp iplus get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-neg_<tsp>_<tsp>{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-neg_<tsp>_<tsp>{i}-okp i))
           (i-state-okp (i-neg_<tsp>_<tsp>{i}-step i) load-addr))
  ((disable i-state-okp-restructuring int-to-v v-to-int
            small-integerp integerp iplus get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-asr_<c>_<tsp>_<tsp>{b}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-asr_<c>_<tsp>_<tsp>{b}-okp i))
           (i-state-okp (i-asr_<c>_<tsp>_<tsp>{b}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-addc_<c>_x{n}_y{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-addc_<c>_x{n}_y{n}-okp i))
           (i-state-okp (i-addc_<c>_x{n}_y{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<tsp>{n}_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<tsp>{n}_x{n}-okp i))
           (i-state-okp (i-add_<tsp>{n}_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-incr_<tsp>_<tsp>{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-incr_<tsp>_<tsp>{n}-okp i))
           (i-state-okp (i-incr_<tsp>_<tsp>{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-incr_y_y{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-incr_y_y{n}-okp i))
           (i-state-okp (i-incr_y_y{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-int-to-nat-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-int-to-nat-okp i))
           (i-state-okp (i-int-to-nat-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-decr_<tsp>_<tsp>{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-decr_<tsp>_<tsp>{n}-okp i))
           (i-state-okp (i-decr_<tsp>_<tsp>{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<c>_x_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<c>_x_x{n}-okp i))
           (i-state-okp (i-add_<c>_x_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<tsp>_<tsp>{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<tsp>_<tsp>{n}-okp i))
           (i-state-okp (i-add_<tsp>_<tsp>{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-lsr_<c>_x_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-lsr_<c>_x_x{n}-okp i))
           (i-state-okp (i-lsr_<c>_x_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-subb_<c>_x{n}_y{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-subb_<c>_x{n}_y{n}-okp i))
           (i-state-okp (i-subb_<c>_x{n}_y{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<c>_<tsp>{n}_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<c>_<tsp>{n}_x{n}-okp i))
           (i-state-okp (i-sub_<c>_<tsp>{n}_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

; I got to here, but ran out of CONS space and can't save my lib.


(prove-lemma i-state-okp-i-sub_<nv>_<tsp>{i}_x{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<nv>_<tsp>{i}_x{i}-okp i))
           (i-state-okp (i-sub_<nv>_<tsp>{i}_x{i}-step i) load-addr))
  ((disable alu-thm_nat-bv-subb alu-thm_nat-c-subb
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            inegate
            i-state-okp-restructuring
            get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<tsp>{n}_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<tsp>{n}_x{n}-okp i))
           (i-state-okp (i-sub_<tsp>{n}_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<c>_<tsp>{a}_x{a}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<c>_<tsp>{a}_x{a}-okp i))
           (i-state-okp (i-sub_<c>_<tsp>{a}_x{a}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v link-table-entry)
   (use
    (lessp-absolute-address-segment-length-generalized
     (name (adp-name (untag (get (adp-offset (untag (i-tsp i)))
                                 (cdr (assoc 'tstk
                                             (i-sys-data-segment i)))))))
     (offset (adp-offset (untag (get (adp-offset (untag (i-tsp i)))
                                     (cdr (assoc 'tstk
                                                 (i-sys-data-segment i)))))))
     (segment (i-usr-data-segment i))))
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<tsp>{s}_x{s}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<tsp>{s}_x{s}-okp i))
           (i-state-okp (i-sub_<tsp>{s}_x{s}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v link-table-entry)
   (use
    (lessp-absolute-address-segment-length-generalized
     (name (adp-name (untag (get (adp-offset (untag (i-tsp i)))
                                 (cdr (assoc 'tstk
                                             (i-sys-data-segment i)))))))
     (offset (adp-offset (untag (get (adp-offset (untag (i-tsp i)))
                                     (cdr (assoc 'tstk
                                                 (i-sys-data-segment i)))))))
     (segment (i-sys-data-segment i))))
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move-c_<tsp>_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move-c_<tsp>_*-okp i))
           (i-state-okp (i-move-c_<tsp>_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-move-v_<tsp>_*-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-move-v_<tsp>_*-okp i))
           (i-state-okp (i-move-v_<tsp>_*-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-or_<tsp>{v}_x{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-or_<tsp>{v}_x{v}-okp i))
           (i-state-okp (i-or_<tsp>{v}_x{v}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-and_<tsp>{v}_x{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-and_<tsp>{v}_x{v}-okp i))
           (i-state-okp (i-and_<tsp>{v}_x{v}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-not_<tsp>_<tsp>{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-not_<tsp>_<tsp>{v}-okp i))
           (i-state-okp (i-not_<tsp>_<tsp>{v}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-xor_<tsp>{v}_x{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-xor_<tsp>{v}_x{v}-okp i))
           (i-state-okp (i-xor_<tsp>{v}_x{v}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-lsr_<tsp>_<tsp>{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-lsr_<tsp>_<tsp>{v}-okp i))
           (i-state-okp (i-lsr_<tsp>_<tsp>{v}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-lsr
            alu-thm_nat-c-lsr v-lsr get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_<tsp>_<tsp>{v}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_<tsp>_<tsp>{v}-okp i))
           (i-state-okp (i-add_<tsp>_<tsp>{v}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-or_<tsp>{b}_x{b}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-or_<tsp>{b}_x{b}-okp i))
           (i-state-okp (i-or_<tsp>{b}_x{b}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-and_<tsp>{b}_x{b}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-and_<tsp>{b}_x{b}-okp i))
           (i-state-okp (i-and_<tsp>{b}_x{b}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-xor_<tsp>{b}_*{b}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-xor_<tsp>{b}_*{b}-okp i))
           (i-state-okp (i-xor_<tsp>{b}_*{b}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-xor_<tsp>{b}_x{b}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-xor_<tsp>{b}_x{b}-okp i))
           (i-state-okp (i-xor_<tsp>{b}_x{b}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_pc_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_pc_x{n}-okp i))
           (i-state-okp (i-add_pc_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-add_x_x{n}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-add_x_x{n}-okp i))
           (i-state-okp (i-add_x_x{n}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-addc_<v>_x{i}_y{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-addc_<v>_x{i}_y{i}-okp i))
           (i-state-okp (i-addc_<v>_x{i}_y{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-addc
            alu-thm_nat-c-addc int-to-v v-to-int small-integerp
            integerp iplus get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-subb_<v>_x{i}_y{i}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-subb_<v>_x{i}_y{i}-okp i))
           (i-state-okp (i-subb_<v>_x{i}_y{i}-step i) load-addr))
  ((disable i-state-okp-restructuring alu-thm_nat-bv-subb
            alu-thm_nat-c-subb int-to-v v-to-int small-integerp
            integerp iplus inegate get nat-to-v link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-cpush_cfp-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-cpush_cfp-okp i))
           (i-state-okp (i-cpush_cfp-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v
            link-table-entry)
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-sub_<z>_x{s}_y{s}-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-sub_<z>_x{s}_y{s}-okp i))
           (i-state-okp (i-sub_<z>_x{s}_y{s}-step i) load-addr))
  ((disable i-state-okp-restructuring get nat-to-v link-table-entry)
   (use
    (lessp-absolute-address-segment-length-generalized
     (name (adp-name (untag (i-y i))))
     (offset (adp-offset (untag (i-y i))))
     (segment (i-sys-data-segment i))))
   (enable i-state-okp)))

(prove-lemma i-state-okp-i-ins-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (i-ins-okp ins i))
           (i-state-okp (i-ins-step ins i load-addr) load-addr))
  ((disable i-state-okp i-state-okp-restructuring
            i-add_<c>_x_x{n}-okp i-add_<c>_x_x{n}-step
            i-add_<tsp>_<tsp>{v}-okp i-add_<tsp>_<tsp>{v}-step
            i-add_<tsp>_<tsp>{n}-okp i-add_<tsp>_<tsp>{n}-step
            i-add_<tsp>{a}_x{n}-okp i-add_<tsp>{a}_x{n}-step
            i-add_tsp_*{n}-okp i-add_tsp_*{n}-step
            i-add_tsp_x{n}-okp i-add_tsp_x{n}-step
            i-add_<tsp>{i}_x{i}-okp i-add_<tsp>{i}_x{i}-step
            i-add_<tsp>{n}_x{n}-okp i-add_<tsp>{n}_x{n}-step
            i-add_pc_x{n}-okp i-add_pc_x{n}-step
            i-add_x_x{n}-okp i-add_x_x{n}-step
            i-add_x{n}_csp-okp i-add_x{n}_csp-step
            i-addc_<c>_x{n}_y{n}-okp i-addc_<c>_x{n}_y{n}-step
            i-addc_<v>_x{i}_y{i}-okp i-addc_<v>_x{i}_y{i}-step
            i-and_<tsp>{v}_x{v}-okp i-and_<tsp>{v}_x{v}-step
            i-and_<tsp>{b}_x{b}-okp i-and_<tsp>{b}_x{b}-step
            i-asr_<c>_<tsp>_<tsp>{b}-okp
            i-asr_<c>_<tsp>_<tsp>{b}-step i-cpop_cfp-okp
            i-cpop_cfp-step i-cpop_pc-okp i-cpop_pc-step
            i-cpush_*-okp i-cpush_*-step i-cpush_<tsp>+-okp
            i-cpush_<tsp>+-step i-cpush_cfp-okp i-cpush_cfp-step
            i-decr_<tsp>_<tsp>{i}-okp i-decr_<tsp>_<tsp>{i}-step
            i-decr_<tsp>_<tsp>{n}-okp i-decr_<tsp>_<tsp>{n}-step
            i-incr_<tsp>_<tsp>{i}-okp i-incr_<tsp>_<tsp>{i}-step
            i-incr_<tsp>_<tsp>{n}-okp i-incr_<tsp>_<tsp>{n}-step
            i-incr_y_y{n}-okp
            i-incr_y_y{n}-step
            i-int-to-nat-okp
            i-int-to-nat-step
            i-jump-n_x-okp i-jump-n_x-step i-jump-nn_x-okp
            i-jump-nn_x-step i-jump-nz_x-okp i-jump-nz_x-step
            i-jump-z_x-okp i-jump-z_x-step i-jump_*-okp
            i-jump_*-step i-jump_x{subr}-okp i-jump_x{subr}-step
            i-lsr_<c>_x_x{n}-okp i-lsr_<c>_x_x{n}-step
            i-lsr_<tsp>_<tsp>{v}-okp i-lsr_<tsp>_<tsp>{v}-step
            i-move-c_<tsp>_*-okp i-move-c_<tsp>_*-step
            i-move-v_<tsp>_*-okp i-move-v_<tsp>_*-step
            i-move-z_<tsp>_*-okp i-move-z_<tsp>_*-step
            i-move-n_x_*-okp i-move-n_x_*-step
            i-move_<tsp>_*-okp i-move_<tsp>_*-step
            i-move_<x{a}>_<tsp>-okp i-move_<x{a}>_<tsp>-step
            i-move_<x{s}>_<tsp>-okp i-move_<x{s}>_<tsp>-step
            i-move_cfp_csp-okp i-move_cfp_csp-step
            i-move_csp_cfp-okp i-move_csp_cfp-step
            i-move_x_*-okp i-move_x_*-step i-move_x_<x{s}>-okp
            i-move_x_<x{s}>-step i-move_x_tsp-okp
            i-move_x_tsp-step i-move_x_x-okp i-move_x_x-step
            i-move_y_*-okp i-move_y_*-step i-move_y_<y{s}>-okp
            i-move_y_<y{s}>-step i-move_y_tsp-okp i-move_y_tsp-step
            i-neg_<tsp>_<tsp>{i}-okp
            i-neg_<tsp>_<tsp>{i}-step i-not_<tsp>_<tsp>{v}-okp
            i-not_<tsp>_<tsp>{v}-step i-or_<tsp>{v}_x{v}-okp
            i-or_<tsp>{v}_x{v}-step i-or_<tsp>{b}_x{b}-okp
            i-or_<tsp>{b}_x{b}-step i-sub_<c>_<tsp>{a}_x{a}-okp
            i-sub_<c>_<tsp>{a}_x{a}-step
            i-sub_<c>_<tsp>{n}_x{n}-okp
            i-sub_<c>_<tsp>{n}_x{n}-step
            i-sub_<nv>_<tsp>{i}_x{i}-okp
            i-sub_<nv>_<tsp>{i}_x{i}-step
            i-sub_<tsp>{a}_x{n}-okp i-sub_<tsp>{a}_x{n}-step
            i-sub_x{s}_y{n}-okp i-sub_x{s}_y{n}-step
            i-sub_<tsp>{i}_x{i}-okp
            i-sub_<tsp>{i}_x{i}-step i-sub_<tsp>{n}_x{n}-okp
            i-sub_<tsp>{n}_x{n}-step i-sub_<tsp>{s}_x{s}-okp
            i-sub_<tsp>{s}_x{s}-step i-sub_<z>_x{s}_y{s}-okp
            i-sub_<z>_x{s}_y{s}-step i-subb_<c>_x{n}_y{n}-okp
            i-subb_<c>_x{n}_y{n}-step i-subb_<v>_x{i}_y{i}-okp
            i-subb_<v>_x{i}_y{i}-step i-tpop_<c>_x-okp
            i-tpop_<c>_x-step i-tpop_<x{a}>-okp
            i-tpop_<x{a}>-step i-tpop_<x{s}>-okp
            i-tpop_<x{s}>-step i-tpop_pc-okp i-tpop_pc-step
            i-tpop_x-okp i-tpop_x-step i-tpop_y-okp
            i-tpop_y-step i-tpop{v}_<z>_y-okp
            i-tpop{v}_<z>_y-step i-tpop{b}_<z>_y-okp
            i-tpop{b}_<z>_y-step i-tpop{i}_<zn>_y-okp
            i-tpop{i}_<zn>_y-step i-tpop{n}_<z>_y-okp
            i-tpop{n}_<z>_y-step i-tpush_*-okp i-tpush_*-step
            i-tpush_<x{a}>-okp i-tpush_<x{a}>-step
            i-tpush_<x{s}>-okp i-tpush_<x{s}>-step
            i-tpush_csp-okp i-tpush_csp-step i-tpush_tsp-okp
            i-tpush_tsp-step i-tpush_x-okp i-tpush_x-step
            i-xor_<tsp>_<tsp>-okp i-xor_<tsp>_<tsp>-step
            i-xor_<tsp>{v}_x{v}-okp i-xor_<tsp>{v}_x{v}-step
            i-xor_<tsp>{b}_*{b}-okp i-xor_<tsp>{b}_*{b}-step
            i-xor_<tsp>{b}_x{b}-okp i-xor_<tsp>{b}_x{b}-step
            i-xor_<z>_<tsp>_x-okp i-xor_<z>_<tsp>_x-step)))

(prove-lemma i-state-okp-i-halt (rewrite)
  (equal (i-state-okp (i-halt i psw) load-addr)
         (i-state-okp i load-addr))
  ((disable i-state-okp-restructuring)
   (enable i-state-okp i-halt)))

(prove-lemma i-state-okp-i-step (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr))
           (i-state-okp (i-step i load-addr) load-addr))
  ((disable i-ins-okp i-ins-step i-state-okp
            i-state-okp-restructuring)))

; The link tables in display-data-segment play two roles.  One is
; to let us get at that section of memory containing a certain
; area.  The other is to map the objects in that section up.
; I wish to distinguish these two roles because I need to do some
; inductions in which one of the tables is fixed and the other
; varies.  In addition, I need to separate the process of fetching
; the objects from the process of mapping them up.  So I will define
; the functions that do these separate jobs and prove their equivalence
; to display-data-segment.

(defn get-array (n m-addr m-mem)
   (if (zerop n)
       nil
       (cons (get m-addr m-mem)
             (get-array (sub1 n) (add1 m-addr) m-mem))))

(defn unlink-data-word-array (type-lst obj-lst link-tables)
  (if (nlistp type-lst)
      nil
      (cons (unlink-data-word (car type-lst)
                              (car obj-lst)
                              link-tables)
            (unlink-data-word-array (cdr type-lst)
                                    (cdr obj-lst)
                                    link-tables))))

(defn get-areas (type-spec usr-data-links m-mem)
  (if (nlistp type-spec)
      nil
      (cons (cons (caar type-spec)
                  (get-array (length (cdar type-spec))
                             (base-address (caar type-spec)
                                           usr-data-links)
                             m-mem))
            (get-areas (cdr type-spec) usr-data-links m-mem))))

(defn unlink-areas (type-spec segment link-tables)
  (if (nlistp type-spec)
      nil
      (cons (cons (caar type-spec)
                  (unlink-data-word-array (cdar type-spec)
                                          (cdar segment)
                                          link-tables))
            (unlink-areas (cdr type-spec) (cdr segment) link-tables))))

(DEFN DISPLAY-ARRAY (TYPE-LST N M-MEM LINK-TABLES)
  (IF (NLISTP TYPE-LST)
      NIL
      (CONS (UNLINK-DATA-WORD (CAR TYPE-LST)
                              (GET N M-MEM)
                              LINK-TABLES)
            (DISPLAY-ARRAY (CDR TYPE-LST)
                                  (ADD1 N)
                                  M-MEM LINK-TABLES))))

(DEFN DISPLAY-DATA-AREA (AREA-TYPE-SPEC M-MEM LINK-TABLES)
  (CONS (CAR AREA-TYPE-SPEC)
        (DISPLAY-ARRAY (CDR AREA-TYPE-SPEC)
                       (BASE-ADDRESS (CAR AREA-TYPE-SPEC)
                                     (USR-DATA-LINKS LINK-TABLES))
                       M-MEM LINK-TABLES)))

(DEFN DISPLAY-DATA-SEGMENT (TYPE-SPEC M-MEM LINK-TABLES)
  (IF (NLISTP TYPE-SPEC)
      NIL
      (CONS (DISPLAY-DATA-AREA (CAR TYPE-SPEC) M-MEM LINK-TABLES)
            (DISPLAY-DATA-SEGMENT (CDR TYPE-SPEC) M-MEM LINK-TABLES))))

(DEFN DISPLAY-M-DATA-SEGMENT (M TYPE-SPEC LINK-TABLES)
      (DISPLAY-DATA-SEGMENT TYPE-SPEC
                            (M-MEM M)
                            LINK-TABLES))

(prove-lemma display-array-decomposition (rewrite)
  (equal (display-array type-lst m-addr m-mem link-tables)
         (unlink-data-word-array type-lst
                                 (get-array (length type-lst) m-addr m-mem)
                                 link-tables)))

(prove-lemma display-data-segment-decomposition (rewrite)
  (equal (display-data-segment type-spec m-mem (i-link-tables i load-addr))
         (unlink-areas type-spec
                       (get-areas type-spec
                                  (link-table-for-segment
                                   (i-usr-data-segment i)
                                   load-addr)
                                  m-mem)
                       (i-link-tables i load-addr))))

; The key steps to proving that display-data-segment inverts is to
; show that (a) get-areas retrieves the linked areas and (b)
; unlink-areas inverts link-areas.  We begin with the get-segment
; part.

; Link-areas, mentioned above, is like link-segment, only it
; preserves the areas instead of flattening them.

(defn link-areas (segment link-tables word-size)
      (if (nlistp segment)
          nil
          (cons (cons (caar segment)
                      (link-area (cdar segment)
                                 link-tables word-size))
                (link-areas (cdr segment)
                              link-tables word-size))))


; To show that get-areas on a linked memory gives link-areas, it is
; necessary to know that get-array gets a link-area.

(defn cdr-n (n lst)
  (if (zerop n) lst (cdr-n (sub1 n) (cdr lst))))

(enable equal-length-0)

(prove-lemma lessp-link-table-entry (rewrite)
  (implies (and (definedp name segment)
                (listp (cdr (assoc name segment))))
           (lessp (link-table-entry name segment)
                  (segment-length segment)))
  ((use (lessp-absolute-address-segment-length-generalized (offset 0)))))

(prove-lemma get-link-table-entry-link-segment-generalized (rewrite)
  (implies (and (definedp name segment)
                (lessp i
                       (length (cdr (assoc name segment)))))
           (equal (get (plus i
                             (link-table-entry name segment))
                       (link-segment segment table word-size))
                  (link-word
                    (unlabel
                      (get i
                           (cdr (assoc name segment))))
                    table
                    word-size)))
  ((use (commutativity-of-plus (x i) (y (link-table-entry name segment)))
        (get-link-table-entry-link-segment (adp (cons name i))))
   (disable get-link-table-entry-link-segment)))


(prove-lemma plus-equal-0 (rewrite)
  (equal (equal (plus x y) 0)
         (and (zerop x) (zerop y))))

(prove-lemma car-cdr-n-is-get (rewrite)
  (equal (car (cdr-n n lst)) (get n lst)))

(prove-lemma cdr-cdr-n (rewrite)
  (equal (cdr (cdr-n n lst)) (cdr-n n (cdr lst))))

; This lemma was excrutiatingly hard for me to get.
; The reason, I think, is that I've just come back to
; the im level proofs after 3 months of working elsewhere
; and I no longer have the required mastery of the rules.

; This theorem was hard to invent too.  The main reason is
; that I had to get a sufficiently general version to permit
; inductive proof.  The trick was the introduction of i.

(defn first-n (n x)
  (if (zerop n)
      nil
      (cons (car x) (first-n (sub1 n) (cdr x)))))

(prove-lemma get-array-link-mem nil
   (implies
         (and (definedp name usr-data-segment)
              (not (lessp (length (cdr (assoc name usr-data-segment)))
                          (plus i n)))
              (numberp i)
              (numberp n))
         (equal (get-array n
                           (plus load-addr
                                 (plus i
                                       (link-table-entry name
                                                   usr-data-segment)))
                           (append (boot-code boot-lst load-addr word-size)
                                   (append (link-segment usr-data-segment
                                                         tables word-size)
                                           rest)))
                (link-area
                 (first-n n
                          (cdr-n i
                                 (cdr (assoc name usr-data-segment))))
                 tables word-size)))
   ((induct (get-array n i mem))
    (use (lessp-absolute-address-segment-length-generalized
          (segment usr-data-segment)
          (offset i)))))

; Now I instantiate the above theorem to get the rule I need.

; The following lemma has a link-area around a familiar identity
; just so I can avoid bringing up a properp hypothesis.

(prove-lemma first-n-length-embedded (rewrite)
  (equal (link-area (first-n (length lst) lst) tables word-size)
         (link-area lst tables word-size)))

(prove-lemma get-array-link-mem-instance (rewrite)
   (implies
         (and (definedp name usr-data-segment)
              (equal n (length (cdr (assoc name usr-data-segment)))))
         (equal (get-array n
                           (plus load-addr
                                 (link-table-entry name
                                                   usr-data-segment))
                           (append (boot-code boot-lst load-addr word-size)
                                   (append (link-segment usr-data-segment
                                                         tables word-size)
                                           rest)))
                (link-area
                 (cdr (assoc name usr-data-segment))
                 tables word-size)))
   ((use (get-array-link-mem
          (n (length (cdr (assoc name usr-data-segment))))
          (i 0)))))

; To formulate a suitably general version of the get-areas
; theorem I need the concept that one segment is an extension
; of another.  By that I mean that everything that occurs in
; the one is identically defined in the other.
; Notice that this concept is not reflexive
; unless we know the segment contains no duplicate area names.
; This whole concept is fairly subtle in its interaction with
; the proof of the get-areas lemma.  The first three lemmas
; below are the crucial properties of subsegmentp for that
; proof.  Reflexivity is needed only for the final use of
; the get-areas theorem.

(defn subsegmentp
      (segment1 segment2)
      (if (nlistp segment1)
          t
          (and (definedp (caar segment1) segment2)
               (equal (assoc (caar segment1) segment2)
                      (car segment1))
               (subsegmentp (cdr segment1)
                            segment2))))

(prove-lemma subsegmentp-cdr (rewrite)
  (implies (and (listp x)
                (subsegmentp x y))
           (subsegmentp (cdr x) y)))

(prove-lemma subsegmentp-implies-definedp (rewrite)
  (implies (and (listp segment)
                (subsegmentp segment usr-data-segment))
           (definedp (caar segment) usr-data-segment)))

(prove-lemma subsegmentp-implies-equal-assoc (rewrite)
  (implies (and (listp segment)
                (subsegmentp segment usr-data-segment))
           (equal (assoc (caar segment) usr-data-segment)
                  (car segment))))

(prove-lemma subsegmentp-reflexive-lemma (rewrite)
  (implies (and (subsegmentp x (cdr y))
                (not (definedp (caar y) x)))
           (subsegmentp x y)))

(prove-lemma subsegmentp-reflexive (rewrite)
  (implies (proper-i-usr-data-segmentp segment i)
           (subsegmentp segment segment)))

(prove-lemma length-type-lst (rewrite)
  (equal (length (type-lst area)) (length area)))


; The following theorem is key step (a) above, when the theorem is
; instantiated with segment replaced by usr-data-segment.

(prove-lemma get-areas-link-mem (rewrite)
  (implies (and (numberp load-addr)
                (subsegmentp segment usr-data-segment))
           (equal (get-areas (type-specification segment)
                             (link-table-for-segment
                              usr-data-segment
                              load-addr)
                             (append (boot-code boot-lst load-addr word-size)
                                     (append (link-segment usr-data-segment
                                                           tables
                                                           word-size)
                                             rest)))
                  (link-areas segment tables word-size)))
  ((enable length-boot-code)
   (induct (type-specification segment))))

(prove-lemma not-icode-instructionp (rewrite)
  (implies (i-objectp x i)
           (not (icode-instructionp x)))
  ((enable i-objectp)))


; We now have to prove that if i-state-okp holds then i-word-size is
; non-0.  This is necessary because otherwise booleans don't invert!

(prove-lemma cstk-implies-not-zerop-segment-length nil
  (implies (lessp n (length (cdr (assoc 'cstk segment))))
           (not (zerop (segment-length segment)))))

(prove-lemma i-loadablep-and-cstk-implies-not-zerop-i-word-size nil
  (implies (and (i-loadablep i load-addr)
                (lessp (adp-offset (untag (i-cfp i)))
                       (length (cdr (assoc 'cstk
                                           (i-sys-data-segment i))))))
           (and (numberp (i-word-size i))
                (lessp 0 (i-word-size i))))
  ((enable i-loadablep)
   (use (cstk-implies-not-zerop-segment-length
         (segment (i-sys-data-segment i))
         (n (adp-offset (untag (i-cfp i))))))))

(prove-lemma car-cdr-elim-accelerator (rewrite)
  (implies (and (listp x)
                (equal (cddr x) nil)
                (equal type (car x)))
           (equal (list type (cadr x)) x)))


; Here is the key invertibility lemma.

; The list of disabled functions, after icode-instructionp, in the
; hint below was mechanically generated.  It contains all the
; functions used to link and unlink individual data types.  The list
; could be shortened.

(prove-lemma unlink-data-word-link-data-word (rewrite)
  (implies (and (numberp load-addr)
                (i-usr-data-objectp x i)
                (i-state-okp i load-addr))
           (equal (unlink-data-word (type x)
                                    (link-data-word x
                                                    (i-link-tables i load-addr)
                                                    (i-word-size i))
                                    (i-link-tables i load-addr))
                  x))
  ((use (i-loadablep-and-cstk-implies-not-zerop-i-word-size))
   (enable i-objectp tag type untag)
   (disable icode-instructionp
            nat-to-v int-to-v bitv-to-v bool-to-v addr-to-v subr-to-v
            sys-addr-to-v label-to-v v-to-nat v-to-int v-to-bitv
            v-to-bool v-to-addr v-to-subr v-to-sys-addr v-to-label)))

(prove-lemma unlink-data-word-array-link-area (rewrite)
   (implies (and (numberp load-addr)
                 (all-i-usr-data-objectps array i)
                 (i-state-okp i load-addr))
            (equal (unlink-data-word-array (type-lst array)
                                           (link-area array
                                                      (i-link-tables i
                                                                     load-addr)
                                                      (i-word-size i))
                                           (i-link-tables i load-addr))
                   array))
   ((disable unlink-data-word)))

(prove-lemma unlink-areas-link-areas (rewrite)
  (implies (and (numberp load-addr)
                (proper-i-usr-data-segmentp segment
                                            i)
                (i-state-okp i load-addr))
           (equal (unlink-areas (type-specification segment)
                                (link-areas segment
                                            (i-link-tables i load-addr)
                                            (i-word-size i))
                                (i-link-tables i load-addr))
                  segment)))

(prove-lemma display-m-data-segment-inverts-i->m (rewrite)
 (implies
  (and (numberp load-addr)
       (proper-i-usr-data-segmentp (i-usr-data-segment i) i)
       (i-state-okp i load-addr))
  (equal
      (display-m-data-segment (i->m i boot-lst load-addr)
                              (type-specification (i-usr-data-segment i))
                              (i-link-tables i load-addr))
      (i-usr-data-segment i))))
 
(prove-lemma i-link-tables-step-move_x_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_x-okp i)
                (equal (i-current-instruction i) '(move_x_x)))
           (equal (i-link-tables (i-move_x_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-cpush_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_*-okp i)
                (equal (i-current-instruction i) '(cpush_*)))
           (equal (i-link-tables (i-cpush_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{i}_x{i})))
           (equal (i-link-tables (i-add_<tsp>{i}_x{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-add alu-thm_nat-c-add
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-cpush_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_cfp-okp i)
                (equal (i-current-instruction i) '(cpush_cfp)))
           (equal (i-link-tables (i-cpush_cfp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_cfp_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_cfp_csp-okp i)
                (equal (i-current-instruction i) '(move_cfp_csp)))
           (equal (i-link-tables (i-move_cfp_csp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-cpush_<tsp>+ (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpush_<tsp>+-okp i)
                (equal (i-current-instruction i) '(cpush_<tsp>+)))
           (equal (i-link-tables (i-cpush_<tsp>+-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_csp_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_csp_cfp-okp i)
                (equal (i-current-instruction i) '(move_csp_cfp)))
           (equal (i-link-tables (i-move_csp_cfp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_x_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_tsp-okp i)
                (equal (i-current-instruction i) '(move_x_tsp)))
           (equal (i-link-tables (i-move_x_tsp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-cpop_cfp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpop_cfp-okp i)
                (equal (i-current-instruction i) '(cpop_cfp)))
           (equal (i-link-tables (i-cpop_cfp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_x_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_*-okp i)
                (equal (i-current-instruction i) '(move_x_*)))
           (equal (i-link-tables (i-move_x_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_y_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_*-okp i)
                (equal (i-current-instruction i) '(move_y_*)))
           (equal (i-link-tables (i-move_y_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_x{n}_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_x{n}_csp-okp i)
                (equal (i-current-instruction i) '(add_x{n}_csp)))
           (equal (i-link-tables (i-add_x{n}_csp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_x_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_x_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(move_x_<x{s}>)))
           (equal (i-link-tables (i-move_x_<x{s}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_y_<y{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_<y{s}>-okp i)
                (equal (i-current-instruction i)
                       '(move_y_<y{s}>)))
           (equal (i-link-tables (i-move_y_<y{s}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_y_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_y_tsp-okp i)
                (equal (i-current-instruction i) '(move_y_tsp)))
           (equal (i-link-tables (i-move_y_tsp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_csp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_csp-okp i)
                (equal (i-current-instruction i) '(tpush_csp)))
           (equal (i-link-tables (i-tpush_csp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_tsp (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_tsp-okp i)
                (equal (i-current-instruction i) '(tpush_tsp)))
           (equal (i-link-tables (i-tpush_tsp-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_x-okp i)
                (equal (i-current-instruction i) '(tpush_x)))
           (equal (i-link-tables (i-tpush_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(tpush_<x{s}>)))
           (equal (i-link-tables (i-tpush_<x{s}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_<x{a}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_<x{a}>-okp i)
                (equal (i-current-instruction i) '(tpush_<x{a}>)))
           (equal (i-link-tables (i-tpush_<x{a}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpush_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpush_*-okp i)
                (equal (i-current-instruction i) '(tpush_*)))
           (equal (i-link-tables (i-tpush_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_x-okp i)
                (equal (i-current-instruction i) '(tpop_x)))
           (equal (i-link-tables (i-tpop_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_y (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_y-okp i)
                (equal (i-current-instruction i) '(tpop_y)))
           (equal (i-link-tables (i-tpop_y-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_<x{s}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<x{s}>-okp i)
                (equal (i-current-instruction i)
                       '(tpop_<x{s}>)))
           (equal (i-link-tables (i-tpop_<x{s}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_<x{a}>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<x{a}>-okp i)
                (equal (i-current-instruction i)
                       '(tpop_<x{a}>)))
           (equal (i-link-tables (i-tpop_<x{a}>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump_*-okp i)
                (equal (i-current-instruction i) '(jump_*)))
           (equal (i-link-tables (i-jump_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-cpop_pc (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-cpop_pc-okp i)
                (equal (i-current-instruction i) '(cpop_pc)))
           (equal (i-link-tables (i-cpop_pc-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_<x{s}>_<tsp>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<x{s}>_<tsp>-okp i)
                (equal (i-current-instruction i)
                       '(move_<x{s}>_<tsp>)))
           (equal (i-link-tables (i-move_<x{s}>_<tsp>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_<x{a}>_<tsp>
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<x{a}>_<tsp>-okp i)
                (equal (i-current-instruction i)
                       '(move_<x{a}>_<tsp>)))
           (equal (i-link-tables (i-move_<x{a}>_<tsp>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump_x{subr} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump_x{subr}-okp i)
                (equal (i-current-instruction i) '(jump_x{subr})))
           (equal (i-link-tables (i-jump_x{subr}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump-n_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-n_x-okp i)
                (equal (i-current-instruction i) '(jump-n_x)))
           (equal (i-link-tables (i-jump-n_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump-nn_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-nn_x-okp i)
                (equal (i-current-instruction i) '(jump-nn_x)))
           (equal (i-link-tables (i-jump-nn_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump-z_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-z_x-okp i)
                (equal (i-current-instruction i) '(jump-z_x)))
           (equal (i-link-tables (i-jump-z_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-jump-nz_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-jump-nz_x-okp i)
                (equal (i-current-instruction i) '(jump-nz_x)))
           (equal (i-link-tables (i-jump-nz_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_pc (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_pc-okp i)
                (equal (i-current-instruction i) '(tpop_pc)))
           (equal (i-link-tables (i-tpop_pc-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop_<c>_x (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop_<c>_x-okp i)
                (equal (i-current-instruction i) '(tpop_<c>_x)))
           (equal (i-link-tables (i-tpop_<c>_x-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop{n}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{n}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{n}_<z>_y)))
           (equal (i-link-tables (i-tpop{n}_<z>_y-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop{i}_<zn>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{i}_<zn>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{i}_<zn>_y)))
           (equal (i-link-tables (i-tpop{i}_<zn>_y-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable int-to-v v-to-int
            small-integerp
            integerp
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop{b}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{b}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{b}_<z>_y)))
           (equal (i-link-tables (i-tpop{b}_<z>_y-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-tpop{v}_<z>_y
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-tpop{v}_<z>_y-okp i)
                (equal (i-current-instruction i)
                       '(tpop{v}_<z>_y)))
           (equal (i-link-tables (i-tpop{v}_<z>_y-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<tsp>{a}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{a}_x{n}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{a}_x{n})))
           (equal (i-link-tables (i-add_<tsp>{a}_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_tsp_*{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_tsp_*{n}-okp i)
                (equal (i-current-instruction i) '(add_tsp_*{n})))
           (equal (i-link-tables (i-add_tsp_*{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_tsp_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_tsp_x{n}-okp i)
                (equal (i-current-instruction i) '(add_tsp_x{n})))
           (equal (i-link-tables (i-add_tsp_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<tsp>{a}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{a}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{a}_x{n})))
           (equal (i-link-tables (i-sub_<tsp>{a}_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_x{s}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_x{s}_y{n}-okp i)
                (equal (i-current-instruction i) '(sub_x{s}_y{n})))
           (equal (i-link-tables (i-sub_x{s}_y{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-xor_<z>_<tsp>_x
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<z>_<tsp>_x-okp i)
                (equal (i-current-instruction i)
                       '(xor_<z>_<tsp>_x)))
           (equal (i-link-tables (i-xor_<z>_<tsp>_x-step i load-addr) load-addr)
                  (i-link-tables i load-addr)))
  ((enable i-objectp-type)
   (disable xor-xxx
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-xor_<tsp>_<tsp> (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>_<tsp>-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>_<tsp>)))
           (equal (i-link-tables (i-xor_<tsp>_<tsp>-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move-z_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-z_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-z_<tsp>_*)))
           (equal (i-link-tables (i-move-z_<tsp>_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move-n_x_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-n_x_*-okp i)
                (equal (i-current-instruction i) '(move-n_x_*)))
           (equal (i-link-tables (i-move-n_x_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move_<tsp>_*)))
           (equal (i-link-tables (i-move_<tsp>_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-incr_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(incr_<tsp>_<tsp>{i})))
           (equal (i-link-tables (i-incr_<tsp>_<tsp>{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-incr alu-thm_nat-c-incr
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{i}_x{i})))
           (equal (i-link-tables (i-sub_<tsp>{i}_x{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-sub alu-thm_nat-c-sub
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-decr_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-decr_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(decr_<tsp>_<tsp>{i})))
           (equal (i-link-tables (i-decr_<tsp>_<tsp>{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-decr alu-thm_nat-c-decr
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-neg_<tsp>_<tsp>{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-neg_<tsp>_<tsp>{i}-okp i)
                (equal (i-current-instruction i) '(neg_<tsp>_<tsp>{i})))
           (equal (i-link-tables (i-neg_<tsp>_<tsp>{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-asr_<c>_<tsp>_<tsp>{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-asr_<c>_<tsp>_<tsp>{b}-okp i)
                (equal (i-current-instruction i) '(asr_<c>_<tsp>_<tsp>{b})))
           (equal (i-link-tables (i-asr_<c>_<tsp>_<tsp>{b}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-addc_<c>_x{n}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-addc_<c>_x{n}_y{n}-okp i)
                (equal (i-current-instruction i) '(addc_<c>_x{n}_y{n})))
           (equal (i-link-tables (i-addc_<c>_x{n}_y{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>{n}_x{n})))
           (equal (i-link-tables (i-add_<tsp>{n}_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-incr_<tsp>_<tsp>{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i) '(incr_<tsp>_<tsp>{n})))
           (equal (i-link-tables (i-incr_<tsp>_<tsp>{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-incr_y_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-incr_y_y{n}-okp i)
                (equal (i-current-instruction i) '(incr_y_y{n})))
           (equal (i-link-tables (i-incr_y_y{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-int-to-nat (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-int-to-nat-okp i)
                (equal (i-current-instruction i) '(int-to-nat)))
           (equal (i-link-tables (i-int-to-nat-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-decr_<tsp>_<tsp>{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-decr_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i) '(decr_<tsp>_<tsp>{n})))
           (equal (i-link-tables (i-decr_<tsp>_<tsp>{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<c>_x_x{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<c>_x_x{n}-okp i)
                (equal (i-current-instruction i)
                       '(add_<c>_x_x{n})))
           (equal (i-link-tables (i-add_<c>_x_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<tsp>_<tsp>{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>_<tsp>{n}-okp i)
                (equal (i-current-instruction i)
                       '(add_<tsp>_<tsp>{n})))
           (equal (i-link-tables (i-add_<tsp>_<tsp>{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-lsr_<c>_x_x{n}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-lsr_<c>_x_x{n}-okp i)
                (equal (i-current-instruction i)
                       '(lsr_<c>_x_x{n})))
           (equal (i-link-tables (i-lsr_<c>_x_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-subb_<c>_x{n}_y{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-subb_<c>_x{n}_y{n}-okp i)
                (equal (i-current-instruction i) '(subb_<c>_x{n}_y{n})))
           (equal (i-link-tables (i-subb_<c>_x{n}_y{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<c>_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<c>_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<c>_<tsp>{n}_x{n})))
           (equal (i-link-tables (i-sub_<c>_<tsp>{n}_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<nv>_<tsp>{i}_x{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<nv>_<tsp>{i}_x{i}-okp i)
                (equal (i-current-instruction i) '(sub_<nv>_<tsp>{i}_x{i})))
           (equal (i-link-tables (i-sub_<nv>_<tsp>{i}_x{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-sub alu-thm_nat-c-sub
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            inegate
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<tsp>{n}_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{n}_x{n}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{n}_x{n})))
           (equal (i-link-tables (i-sub_<tsp>{n}_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-sub_<c>_<tsp>{a}_x{a} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<c>_<tsp>{a}_x{a}-okp i)
                (equal (i-current-instruction i) '(sub_<c>_<tsp>{a}_x{a})))
           (equal (i-link-tables (i-sub_<c>_<tsp>{a}_x{a}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (get (adp-offset (untag (i-tsp i)))
                            (cdr (assoc 'tstk
                                        (i-sys-data-segment i)))))))
         (offset (adp-offset
                  (untag (get (adp-offset (untag (i-tsp i)))
                              (cdr (assoc 'tstk
                                          (i-sys-data-segment i)))))))
         (segment (i-usr-data-segment i))))))

(prove-lemma i-link-tables-step-sub_<tsp>{s}_x{s} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<tsp>{s}_x{s}-okp i)
                (equal (i-current-instruction i) '(sub_<tsp>{s}_x{s})))
           (equal (i-link-tables (i-sub_<tsp>{s}_x{s}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (get (adp-offset (untag (i-tsp i)))
                            (cdr (assoc 'tstk
                                        (i-sys-data-segment i)))))))
         (offset (adp-offset
                  (untag (get (adp-offset (untag (i-tsp i)))
                              (cdr (assoc 'tstk
                                          (i-sys-data-segment i)))))))
         (segment (i-sys-data-segment i))))))

(prove-lemma i-link-tables-step-sub_<z>_x{s}_y{s}
             (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-sub_<z>_x{s}_y{s}-okp i)
                (equal (i-current-instruction i)
                       '(sub_<z>_x{s}_y{s})))
           (equal (i-link-tables (i-sub_<z>_x{s}_y{s}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)
   (use (lessp-absolute-address-segment-length-generalized
         (name (adp-name
                (untag (i-y i))))
         (offset (adp-offset
                  (untag (i-y i))))
         (segment (i-sys-data-segment i))))))

(prove-lemma i-link-tables-step-move-c_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-c_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-c_<tsp>_*)))
           (equal (i-link-tables (i-move-c_<tsp>_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-move-v_<tsp>_* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-move-v_<tsp>_*-okp i)
                (equal (i-current-instruction i) '(move-v_<tsp>_*)))
           (equal (i-link-tables (i-move-v_<tsp>_*-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-or_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-or_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(or_<tsp>{v}_x{v})))
           (equal (i-link-tables (i-or_<tsp>{v}_x{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-and_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-and_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(and_<tsp>{v}_x{v})))
           (equal (i-link-tables (i-and_<tsp>{v}_x{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-not_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-not_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(not_<tsp>_<tsp>{v})))
           (equal (i-link-tables (i-not_<tsp>_<tsp>{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-xor_<tsp>{v}_x{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{v}_x{v}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{v}_x{v})))
           (equal (i-link-tables (i-xor_<tsp>{v}_x{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-lsr_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-lsr_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(lsr_<tsp>_<tsp>{v})))
           (equal (i-link-tables (i-lsr_<tsp>_<tsp>{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-lsr alu-thm_nat-c-lsr
            v-lsr
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_<tsp>_<tsp>{v} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_<tsp>_<tsp>{v}-okp i)
                (equal (i-current-instruction i) '(add_<tsp>_<tsp>{v})))
           (equal (i-link-tables (i-add_<tsp>_<tsp>{v}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-or_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-or_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(or_<tsp>{b}_x{b})))
           (equal (i-link-tables (i-or_<tsp>{b}_x{b}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-and_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-and_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(and_<tsp>{b}_x{b})))
           (equal (i-link-tables (i-and_<tsp>{b}_x{b}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-xor_<tsp>{b}_*{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{b}_*{b}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{b}_*{b})))
           (equal (i-link-tables (i-xor_<tsp>{b}_*{b}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-xor_<tsp>{b}_x{b} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-xor_<tsp>{b}_x{b}-okp i)
                (equal (i-current-instruction i) '(xor_<tsp>{b}_x{b})))
           (equal (i-link-tables (i-xor_<tsp>{b}_x{b}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_pc_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_pc_x{n}-okp i)
                (equal (i-current-instruction i) '(add_pc_x{n})))
           (equal (i-link-tables (i-add_pc_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-add_x_x{n} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-add_x_x{n}-okp i)
                (equal (i-current-instruction i) '(add_x_x{n})))
           (equal (i-link-tables (i-add_x_x{n}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-addc_<v>_x{i}_y{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-addc_<v>_x{i}_y{i}-okp i)
                (equal (i-current-instruction i) '(addc_<v>_x{i}_y{i})))
           (equal (i-link-tables (i-addc_<v>_x{i}_y{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
  ((disable alu-thm_nat-bv-addc alu-thm_nat-c-addc
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-step-subb_<v>_x{i}_y{i} (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr)
                (equal (i-psw i) 'run)
                (equal (i-word-size i) 32)
                (i-subb_<v>_x{i}_y{i}-okp i)
                (equal (i-current-instruction i) '(subb_<v>_x{i}_y{i})))
           (equal (i-link-tables (i-subb_<v>_x{i}_y{i}-step i) load-addr)
                  (i-link-tables i load-addr)))
    ((disable alu-thm_nat-bv-subb alu-thm_nat-c-subb
            int-to-v v-to-int
            small-integerp
            integerp
            iplus
            inegate
            get nat-to-v link-table-entry)))

(prove-lemma i-link-tables-ins-okp-step (rewrite)
             (implies (and (numberp load-addr)
                           (i-state-okp i load-addr)
                           (equal (i-psw i) 'run)
                           (equal (i-word-size i) 32)
                           (i-ins-okp (i-current-instruction i) i))
                      (equal (i-link-tables (i-ins-step (i-current-instruction i) i load-addr) load-addr)
                             (i-link-tables i load-addr)))
             ((disable
               i-state-okp i-state-okp-restructuring
               i-current-instruction
               i->m
               m-step
               i-add_<c>_x_x{n}-okp
               i-add_<c>_x_x{n}-step
               i-add_<tsp>_<tsp>{v}-okp
               i-add_<tsp>_<tsp>{v}-step
               i-add_<tsp>_<tsp>{n}-okp
               i-add_<tsp>_<tsp>{n}-step
               i-add_<tsp>{a}_x{n}-okp
               i-add_<tsp>{a}_x{n}-step
               i-add_tsp_*{n}-okp
               i-add_tsp_*{n}-step
               i-add_tsp_x{n}-okp
               i-add_tsp_x{n}-step
               i-add_<tsp>{i}_x{i}-okp
               i-add_<tsp>{i}_x{i}-step
               i-add_<tsp>{n}_x{n}-okp
               i-add_<tsp>{n}_x{n}-step
               i-add_pc_x{n}-okp
               i-add_pc_x{n}-step
               i-add_x_x{n}-okp
               i-add_x_x{n}-step
               i-add_x{n}_csp-okp
               i-add_x{n}_csp-step
               i-addc_<c>_x{n}_y{n}-okp
               i-addc_<c>_x{n}_y{n}-step
               i-addc_<v>_x{i}_y{i}-okp
               i-addc_<v>_x{i}_y{i}-step
               i-and_<tsp>{v}_x{v}-okp
               i-and_<tsp>{v}_x{v}-step
               i-and_<tsp>{b}_x{b}-okp
               i-and_<tsp>{b}_x{b}-step
               i-asr_<c>_<tsp>_<tsp>{b}-okp
               i-asr_<c>_<tsp>_<tsp>{b}-step
               i-cpop_cfp-okp
               i-cpop_cfp-step
               i-cpop_pc-okp
               i-cpop_pc-step
               i-cpush_*-okp
               i-cpush_*-step
               i-cpush_<tsp>+-okp
               i-cpush_<tsp>+-step
               i-cpush_cfp-okp
               i-cpush_cfp-step
               i-decr_<tsp>_<tsp>{i}-okp
               i-decr_<tsp>_<tsp>{i}-step
               i-decr_<tsp>_<tsp>{n}-okp
               i-decr_<tsp>_<tsp>{n}-step
               i-incr_<tsp>_<tsp>{i}-okp
               i-incr_<tsp>_<tsp>{i}-step
               i-incr_<tsp>_<tsp>{n}-okp
               i-incr_<tsp>_<tsp>{n}-step
               i-incr_y_y{n}-okp
               i-incr_y_y{n}-step
               i-int-to-nat-okp
               i-int-to-nat-step
               i-jump-n_x-okp
               i-jump-n_x-step
               i-jump-nn_x-okp
               i-jump-nn_x-step
               i-jump-nz_x-okp
               i-jump-nz_x-step
               i-jump-z_x-okp
               i-jump-z_x-step
               i-jump_*-okp
               i-jump_*-step
               i-jump_x{subr}-okp
               i-jump_x{subr}-step
               i-lsr_<c>_x_x{n}-okp
               i-lsr_<c>_x_x{n}-step
               i-lsr_<tsp>_<tsp>{v}-okp
               i-lsr_<tsp>_<tsp>{v}-step
               i-move-c_<tsp>_*-okp
               i-move-c_<tsp>_*-step
               i-move-v_<tsp>_*-okp
               i-move-v_<tsp>_*-step
               i-move-z_<tsp>_*-okp
               i-move-z_<tsp>_*-step
               i-move-n_x_*-okp
               i-move-n_x_*-step
               i-move_<tsp>_*-okp
               i-move_<tsp>_*-step
               i-move_<x{a}>_<tsp>-okp
               i-move_<x{a}>_<tsp>-step
               i-move_<x{s}>_<tsp>-okp
               i-move_<x{s}>_<tsp>-step
               i-move_cfp_csp-okp
               i-move_cfp_csp-step
               i-move_csp_cfp-okp
               i-move_csp_cfp-step
               i-move_x_*-okp
               i-move_x_*-step
               i-move_x_<x{s}>-okp
               i-move_x_<x{s}>-step
               i-move_x_tsp-okp
               i-move_x_tsp-step
               i-move_x_x-okp
               i-move_x_x-step
               i-move_y_*-okp
               i-move_y_*-step
               i-move_y_<y{s}>-okp
               i-move_y_<y{s}>-step
               i-move_y_tsp-okp
               i-move_y_tsp-step
               i-neg_<tsp>_<tsp>{i}-okp
               i-neg_<tsp>_<tsp>{i}-step
               i-not_<tsp>_<tsp>{v}-okp
               i-not_<tsp>_<tsp>{v}-step
               i-or_<tsp>{v}_x{v}-okp
               i-or_<tsp>{v}_x{v}-step
               i-or_<tsp>{b}_x{b}-okp
               i-or_<tsp>{b}_x{b}-step
               i-sub_<c>_<tsp>{a}_x{a}-okp
               i-sub_<c>_<tsp>{a}_x{a}-step
               i-sub_<c>_<tsp>{n}_x{n}-okp
               i-sub_<c>_<tsp>{n}_x{n}-step
               i-sub_<nv>_<tsp>{i}_x{i}-okp
               i-sub_<nv>_<tsp>{i}_x{i}-step
               i-sub_<tsp>{a}_x{n}-okp
               i-sub_<tsp>{a}_x{n}-step
               i-sub_x{s}_y{n}-okp
               i-sub_x{s}_y{n}-step
               i-sub_<tsp>{i}_x{i}-okp
               i-sub_<tsp>{i}_x{i}-step
               i-sub_<tsp>{n}_x{n}-okp
               i-sub_<tsp>{n}_x{n}-step
               i-sub_<tsp>{s}_x{s}-okp
               i-sub_<tsp>{s}_x{s}-step
               i-sub_<z>_x{s}_y{s}-okp
               i-sub_<z>_x{s}_y{s}-step
               i-subb_<c>_x{n}_y{n}-okp
               i-subb_<c>_x{n}_y{n}-step
               i-subb_<v>_x{i}_y{i}-okp
               i-subb_<v>_x{i}_y{i}-step
               i-tpop_<c>_x-okp
               i-tpop_<c>_x-step
               i-tpop_<x{a}>-okp
               i-tpop_<x{a}>-step
               i-tpop_<x{s}>-okp
               i-tpop_<x{s}>-step
               i-tpop_pc-okp
               i-tpop_pc-step
               i-tpop_x-okp
               i-tpop_x-step
               i-tpop_y-okp
               i-tpop_y-step
               i-tpop{v}_<z>_y-okp
               i-tpop{v}_<z>_y-step
               i-tpop{b}_<z>_y-okp
               i-tpop{b}_<z>_y-step
               i-tpop{i}_<zn>_y-okp
               i-tpop{i}_<zn>_y-step
               i-tpop{n}_<z>_y-okp
               i-tpop{n}_<z>_y-step
               i-tpush_*-okp
               i-tpush_*-step
               i-tpush_<x{a}>-okp
               i-tpush_<x{a}>-step
               i-tpush_<x{s}>-okp
               i-tpush_<x{s}>-step
               i-tpush_csp-okp
               i-tpush_csp-step
               i-tpush_tsp-okp
               i-tpush_tsp-step
               i-tpush_x-okp
               i-tpush_x-step
               i-xor_<tsp>_<tsp>-okp
               i-xor_<tsp>_<tsp>-step
               i-xor_<tsp>{v}_x{v}-okp
               i-xor_<tsp>{v}_x{v}-step
               i-xor_<tsp>{b}_*{b}-okp
               i-xor_<tsp>{b}_*{b}-step
               i-xor_<tsp>{b}_x{b}-okp
               i-xor_<tsp>{b}_x{b}-step
               i-xor_<z>_<tsp>_x-okp
               i-xor_<z>_<tsp>_x-step
               )))

(prove-lemma i-link-tables-step (rewrite)
  (implies (and (numberp load-addr)
                (equal (i-psw (i-step i load-addr)) 'run)
                (equal (i-word-size i) 32))
           (equal (i-link-tables (i-step i load-addr) load-addr)
                  (i-link-tables i load-addr)))
 ((disable i-state-okp i-state-okp-restructuring
           i-current-instruction
           i-ins-okp
           i-ins-step)))

(prove-lemma i-link-tables-i (rewrite)
  (implies (and (numberp load-addr)
                (equal (i-psw (i i n load-addr)) 'run)
                (equal (i-word-size i) 32))
           (equal (i-link-tables (i i n load-addr) load-addr)
                  (i-link-tables i load-addr)))
  ((induct (i i n load-addr))
   (disable i-step m-step i->m i-state-okp i-state-okp-restructuring
            i-ins-okp i-ins-step)))

(prove-lemma read-mem-ram-tree-is-get
             (rewrite)
             (implies (and (not (lessp (exp 2 word-size) (length lst)))
                           (lessp n (length lst)))
                      (equal (read-mem (nat-to-v n word-size)
                                       (ram-tree lst (exp 2 word-size)))
                             (get n lst)))
  ((enable nth-is-get)
   (use (read-mem-ram-tree (addr (nat-to-v n word-size))
                           (lst lst)
                           (e (exp 2 word-size))))
   (disable read-mem)))

(prove-lemma one-way-correspondence-display-array (rewrite)
  (IMPLIES (AND (BVP-LISTP mem)
                (NOT (LESSP (exp 2 32) (LENGTH mem)))
                (not (lessp (length mem) (plus n (length type-lst)))))
           (EQUAL
            (display-fm9001-array type-lst n
                                  (ram-tree mem (exp 2 32))
                                  link-tables)
            (display-array type-lst n mem link-tables)))
  ((induct (display-array type-lst n mem link-tables))
   (disable unlink-data-word read-mem)))

(defn plausible-data-link-tablep (type-spec n usr-data-link-table)
  (if (nlistp type-spec)
      t
      (and (not (lessp n
                       (plus (cdr (assoc (caar type-spec) usr-data-link-table))
                             (length (cdar type-spec)))))
           (plausible-data-link-tablep (cdr type-spec) n usr-data-link-table))))

(prove-lemma one-way-correspondence-display-fm9001-data-segment1 (rewrite)
  (implies (and (bvp-listp mem)
                (not (lessp (exp 2 32) (length mem)))
                (plausible-data-link-tablep
                 type-spec
                 (length mem)
                 (usr-data-links link-tables)))
           (equal (display-fm9001-data-segment1 type-spec (ram-tree mem (exp 2 32)) link-tables)
                  (display-data-segment type-spec mem link-tables)))
  ((disable display-array-decomposition)))

(prove-lemma display-fm9001-data-segment-m->fm9001 (rewrite)
  (implies (and (proper-m-statep m)
                (plausible-data-link-tablep
                 type-spec
                 (length (m-mem m))
                 (usr-data-links link-tables)))
           (equal (display-fm9001-data-segment (m->fm9001 m)
                                               type-spec
                                               link-tables)
                  (display-m-data-segment m type-spec link-tables))))

; We will have to return to the question of a plausible data link table once we have
; finished the other levels.  The problem is that we have to show that the
; actual data link table generated is plausible and we will do that with
; arguments about the various levels preserving the signatures of the
; the various segments.  But these concepts are not available yet and so
; we complete our work at the m v. fm9001 level by just leaving plausibility
; for later.

; Book:  r.events.  Now we introduce the r machine.

(set-status close-data-base-3 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

; We now build r-i.events from its subbooks.

(DEFN STRIP-CADRS
      (ALIST)
      (IF (NLISTP ALIST)
          NIL
          (CONS (CADAR ALIST)
                (STRIP-CADRS (CDR ALIST)))))

(DEFN PCPP
      (X SEGMENT)
      (AND (LISTP X)
           (NUMBERP (ADP-OFFSET X))
           (DEFINEDP (ADP-NAME X) SEGMENT)
           (LESSP (ADP-OFFSET X)
                  (LENGTH (PROGRAM-BODY (DEFINITION (ADP-NAME X) SEGMENT))))))

(DEFN NOT-BOOL
      (X)
      (IF (EQUAL X 'F) 'T 'F))

(DEFN P-TEST-NATP
      (FLG X)
      (IF (EQUAL FLG 'ZERO)
          (EQUAL X 0)
          (NOT (EQUAL X 0))))

(DEFN P-TEST-INTP
      (FLG X)
      (CASE FLG
            (ZERO (EQUAL X 0))
            (NOT-ZERO (NOT (EQUAL X 0)))
            (NEG (NEGATIVEP X))
            (NOT-NEG (NOT (NEGATIVEP X)))
            (POS (AND (NUMBERP X) (NOT (EQUAL X 0))))
            (OTHERWISE (OR (EQUAL X 0) (NEGATIVEP X)))))

(DEFN P-TEST-BOOLP
      (FLG X)
      (IF (EQUAL FLG 'T)
          (EQUAL X 'T)
          (EQUAL X 'F)))

(DEFN P-TEST-BITVP
      (FLG X)
      (IF (EQUAL FLG 'ALL-ZERO)
          (ALL-ZERO-BITVP X)
          (NOT (ALL-ZERO-BITVP X))))

(DEFN PITON-OPCODES NIL
      '(CALL RET LOCN PUSH-CONSTANT PUSH-LOCAL PUSH-GLOBAL
             PUSH-CTRL-STK-FREE-SIZE PUSH-TEMP-STK-FREE-SIZE
             PUSH-TEMP-STK-INDEX JUMP-IF-TEMP-STK-FULL JUMP-IF-TEMP-STK-EMPTY
             POP POP* POPN POP-LOCAL POP-GLOBAL POP-LOCN POP-CALL
             FETCH-TEMP-STK DEPOSIT-TEMP-STK JUMP JUMP-CASE PUSHJ POPJ
             SET-LOCAL SET-GLOBAL TEST-NAT-AND-JUMP TEST-INT-AND-JUMP
             TEST-BOOL-AND-JUMP TEST-BITV-AND-JUMP NO-OP ADD-ADDR SUB-ADDR EQ
             LT-ADDR FETCH DEPOSIT ADD-INT ADD-INT-WITH-CARRY ADD1-INT SUB-INT
             SUB-INT-WITH-CARRY SUB1-INT NEG-INT LT-INT INT-TO-NAT ADD-NAT
             ADD-NAT-WITH-CARRY ADD1-NAT SUB-NAT SUB-NAT-WITH-CARRY SUB1-NAT
             LT-NAT MULT2-NAT MULT2-NAT-WITH-CARRY-OUT DIV2-NAT OR-BITV
             AND-BITV NOT-BITV XOR-BITV RSH-BITV LSH-BITV OR-BOOL AND-BOOL
             NOT-BOOL))

(DEFN LEGAL-LABELP
      (INS)
      (IMPLIES (LABELLEDP INS)
               (LITATOM (CADR INS))))

(DEFN R-OBJECTP
      (X R)
      (AND (LISTP X)
           (EQUAL (CDDR X) NIL)
           (CASE (TYPE X)
                 (NAT (SMALL-NATURALP (UNTAG X)
                                      (R-WORD-SIZE R)))
                 (INT (SMALL-INTEGERP (UNTAG X)
                                      (R-WORD-SIZE R)))
                 (BITV (BIT-VECTORP (UNTAG X)
                                    (R-WORD-SIZE R)))
                 (BOOL (BOOLEANP (UNTAG X)))
                 (ADDR (ADPP (UNTAG X)
                             (R-USR-DATA-SEGMENT R)))
                 (PC (PCPP (UNTAG X) (R-PROG-SEGMENT R)))
                 (SUBR (DEFINEDP (UNTAG X)
                                 (R-PROG-SEGMENT R)))
                 (SYS-ADDR (ADPP (UNTAG X)
                                 (R-SYS-DATA-SEGMENT R)))
                 (OTHERWISE F))))

(DEFN R-OBJECTP-TYPE
      (TYPE X R)
      (AND (EQUAL (TYPE X) TYPE)
           (R-OBJECTP X R)))

(DEFN ALL-R-OBJECTPS
      (LST R)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (R-OBJECTP (CAR LST) R)
               (ALL-R-OBJECTPS (CDR LST) R))))

(DEFN R-USR-DATA-TYPEP
      (TYPE)
      (MEMBER TYPE
              '(NAT INT BITV BOOL ADDR SUBR PC)))

(DEFN R-USR-DATA-OBJECTP
      (X R)
      (AND (R-OBJECTP X R)
           (R-USR-DATA-TYPEP (TYPE X))))

(DEFN PUSH-STK-N
      (N SYS-ADDR)
      (SUB-ADDR SYS-ADDR N))

(DEFN POP-STK-N
      (N SYS-ADDR)
      (ADD-ADDR SYS-ADDR N))

(DEFN FETCH-N
      (N ADDR SEGMENT)
      (IF (ZEROP N)
          NIL
          (CONS (FETCH ADDR SEGMENT)
                (FETCH-N (SUB1 N)
                         (POP-STK ADDR)
                         SEGMENT))))

(DEFN DEPOSIT-LST
      (LST ADDR SEGMENT)
      (IF (NLISTP LST)
          SEGMENT
          (DEPOSIT-LST (CDR LST)
                       (PUSH-STK ADDR)
                       (DEPOSIT (CAR LST) ADDR SEGMENT))))

(DEFN TOTAL-R-SYSTEM-SIZE (R load-addr)
      (PLUS load-addr
            (SEGMENT-LENGTH (R-USR-DATA-SEGMENT R))
            (SEGMENT-LENGTH (ICOMPILE (R-PROG-SEGMENT R)))
            (SEGMENT-LENGTH (R-SYS-DATA-SEGMENT R))))

(DEFN R-LOADABLEP (R load-addr)
      (LESSP (TOTAL-R-SYSTEM-SIZE R load-addr)
             (EXP 2 (R-WORD-SIZE R))))

(DEFN R-INSTRUCTIONP
      (INS)
      (AND (MEMBER (CAR INS) (PITON-OPCODES))
           (IMPLIES (EQUAL (CAR INS) 'PUSH-CONSTANT)
                    (NOT (LABELLEDP (CADR INS))))))

(DEFN R-PROGRAM-BODYP
      (LST)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (LEGAL-LABELP (CAR LST))
               (R-INSTRUCTIONP (UNLABEL (CAR LST)))
               (R-PROGRAM-BODYP (CDR LST)))))

(DEFN R-TEMP-VAR-DCLSP
      (TEMP-VAR-DCLS)
      (IF (LISTP TEMP-VAR-DCLS)
          (AND (NOT (LABELLEDP (CADAR TEMP-VAR-DCLS)))
               (R-TEMP-VAR-DCLSP (CDR TEMP-VAR-DCLS)))
          T))

(DEFN R-PROGRAMP
      (PROG)
      (AND (LITATOM (NAME PROG))
           (R-TEMP-VAR-DCLSP (TEMP-VAR-DCLS PROG))
           (LISTP (PROGRAM-BODY PROG))
           (R-PROGRAM-BODYP (PROGRAM-BODY PROG))))

(DEFN R-PROG-SEGMENTP
      (SEGMENT)
      (IF (NLISTP SEGMENT)
          (EQUAL SEGMENT NIL)
          (AND (R-PROGRAMP (CAR SEGMENT))
               (R-PROG-SEGMENTP (CDR SEGMENT)))))

(DEFN ALL-R-USR-DATA-OBJECTPS
      (LST R)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (R-USR-DATA-OBJECTP (CAR LST) R)
               (ALL-R-USR-DATA-OBJECTPS (CDR LST)
                                        R))))

(DEFN PROPER-R-USR-DATA-AREA
      (AREA R)
      (AND (LITATOM (CAR AREA))
           (LISTP (CDR AREA))
           (ALL-R-USR-DATA-OBJECTPS (CDR AREA)
                                    R)))

(DEFN PROPER-R-USR-DATA-SEGMENTP
      (DATA-SEGMENT R)
      (IF (NLISTP DATA-SEGMENT)
          (EQUAL DATA-SEGMENT NIL)
          (AND (PROPER-R-USR-DATA-AREA (CAR DATA-SEGMENT)
                                       R)
               (NOT (DEFINEDP (CAAR DATA-SEGMENT)
                              (CDR DATA-SEGMENT)))
               (PROPER-R-USR-DATA-SEGMENTP (CDR DATA-SEGMENT)
                                           R))))

(DEFN PROPER-R-STATEP (R LOAD-ADDR)
 (AND
     (R-STATEP R)
     (R-OBJECTP-TYPE 'PC (R-PC R) R)
     (CSTKP (R-CFP R)
            (R-SYS-DATA-SEGMENT R))
     (CSTKP (R-CSP R)
            (R-SYS-DATA-SEGMENT R))
     (TSTKP (R-TSP R)
            (R-SYS-DATA-SEGMENT R))
     (EQUAL (DEFINITION 'FULL-CTRL-STK-ADDR
                        (R-SYS-DATA-SEGMENT R))
            (LIST 'FULL-CTRL-STK-ADDR
                  (TAG 'SYS-ADDR '(CSTK . 0))))
     (EQUAL (DEFINITION 'FULL-TEMP-STK-ADDR
                        (R-SYS-DATA-SEGMENT R))
            (LIST 'FULL-TEMP-STK-ADDR
                  (TAG 'SYS-ADDR '(TSTK . 0))))
     (EQUAL (DEFINITION 'EMPTY-TEMP-STK-ADDR
                        (R-SYS-DATA-SEGMENT R))
            (LIST 'EMPTY-TEMP-STK-ADDR
                  (TAG 'SYS-ADDR
                       (CONS 'TSTK
                             (SUB1 (LENGTH (DEFINIENS 'TSTK
                                                  (R-SYS-DATA-SEGMENT R))))))))
     (R-OBJECTP-TYPE 'BOOL (R-C-FLG R) R)
     (R-OBJECTP-TYPE 'BOOL (R-V-FLG R) R)
     (R-OBJECTP-TYPE 'BOOL (R-N-FLG R) R)
     (R-OBJECTP-TYPE 'BOOL (R-Z-FLG R) R)
     (R-PROG-SEGMENTP (R-PROG-SEGMENT R))
     (PROPER-R-USR-DATA-SEGMENTP (R-USR-DATA-SEGMENT R)
                                 R)
     (R-LOADABLEP R load-addr)))

(enable PATHOLOGICAL-DIFFERENCE)

(DEFN STK-EQUAL
      (SP SEGMENT1 SEGMENT2)
      (IF (EMPTY-STKP SP SEGMENT1)
          T
          (AND (EQUAL (FETCH SP SEGMENT1)
                      (FETCH SP SEGMENT2))
               (STK-EQUAL (POP-STK SP)
                          SEGMENT1 SEGMENT2)))
      ((LESSP (STK-LENGTH SP SEGMENT1))))

(DEFN SIGNATURE
      (AREA)
      (CONS (CAR AREA) (LENGTH AREA)))

(DEFN SAME-SIGNATURE
      (SEGMENT1 SEGMENT2)
      (IF (LISTP SEGMENT1)
          (AND (LISTP SEGMENT2)
               (EQUAL (SIGNATURE (CAR SEGMENT1))
                      (SIGNATURE (CAR SEGMENT2)))
               (SAME-SIGNATURE (CDR SEGMENT1)
                               (CDR SEGMENT2)))
          (NLISTP SEGMENT2)))

(DEFN R-EQUAL
      (R1 R2)
      (AND (R-STATEP R1)
           (R-STATEP R2)
           (EQUAL (R-PC R1) (R-PC R2))
           (EQUAL (R-CFP R1) (R-CFP R2))
           (EQUAL (R-CSP R1) (R-CSP R2))
           (EQUAL (R-TSP R1) (R-TSP R2))
           (EQUAL (R-PROG-SEGMENT R1)
                  (R-PROG-SEGMENT R2))
           (EQUAL (R-USR-DATA-SEGMENT R1)
                  (R-USR-DATA-SEGMENT R2))
           (STK-EQUAL (R-CSP R1)
                      (R-SYS-DATA-SEGMENT R1)
                      (R-SYS-DATA-SEGMENT R2))
           (STK-EQUAL (R-TSP R1)
                      (R-SYS-DATA-SEGMENT R1)
                      (R-SYS-DATA-SEGMENT R2))
           (SAME-SIGNATURE (R-SYS-DATA-SEGMENT R1)
                           (R-SYS-DATA-SEGMENT R2))
           (EQUAL (R-WORD-SIZE R1)
                  (R-WORD-SIZE R2))
           (EQUAL (R-PSW R1) (R-PSW R2))))

(DEFN ADD1-R-PC
      (R)
      (ADD1-ADDR (R-PC R)))

(DEFN ADD1-R-PCP
      (R)
      (PCPP (UNTAG (ADD1-ADDR (R-PC R)))
            (R-PROG-SEGMENT R)))

(DEFN R-CURRENT-PROGRAM
      (R)
      (DEFINITION (AREA-NAME (R-PC R))
                  (R-PROG-SEGMENT R)))

(DEFN R-CURRENT-INSTRUCTION
      (R)
      (UNLABEL (GET (OFFSET (R-PC R))
                    (PROGRAM-BODY (R-CURRENT-PROGRAM R)))))

(DEFN R-HALT
      (R PSW)
      (R-STATE (R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               PSW))

(DEFN R-CALL-OKP
 (INS R)
 (AND
  (DEFINEDP (CADR INS)
            (R-PROG-SEGMENT R))
  (NOT
   (LESSP (FREE-STK-SIZE (R-CSP R))
          (ADD1 (ADD1 (LENGTH (LOCAL-VARS (DEFINITION (CADR INS)
                                                      (R-PROG-SEGMENT R))))))))
  (NOT (LESSP (STK-LENGTH (R-TSP R)
                          (R-SYS-DATA-SEGMENT R))
              (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                               (R-PROG-SEGMENT R))))))
  (ADD1-R-PCP R)
  (ALL-R-OBJECTPS (STRIP-CADRS (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                                          (R-PROG-SEGMENT R))))
                  R)))

(DEFN R-CALL-STEP
 (INS R)
 (R-STATE
  (TAG 'PC (CONS (CADR INS) 0))
  (PUSH-STK-N 2 (R-CSP R))
  (PUSH-STK-N (PLUS 2
                    (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                                     (R-PROG-SEGMENT R))))
                    (LENGTH (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                                       (R-PROG-SEGMENT R)))))
              (R-CSP R))
  (POP-STK-N (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                              (R-PROG-SEGMENT R))))
             (R-TSP R))
  (R-X R)
  (R-Y R)
  (R-C-FLG R)
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT-LST
   (APPEND
    (LIST (ADD1-ADDR (R-PC R)) (R-CFP R))
    (APPEND
        (REV (STRIP-CADRS (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                                         (R-PROG-SEGMENT R)))))
        (FETCH-N (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                                  (R-PROG-SEGMENT R))))
                 (R-TSP R)
                 (R-SYS-DATA-SEGMENT R))))
   (PUSH-STK (R-CSP R))
   (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-CALL-STEP-CLOCK
      (INS R)
      (PLUS 2 2
            (LENGTH (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                               (R-PROG-SEGMENT R))))
            (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                             (R-PROG-SEGMENT R))))))

(DEFN R-RET-OKP
      (INS R)
      (AND (NOT (EMPTY-STKP (R-CFP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-CFP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'PC
                           (FETCH (POP-STK (R-CFP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (EQUAL (AREA-NAME (R-CFP R)) 'CSTK)
           (EQUAL (AREA-NAME (R-CSP R)) 'CSTK)
           (NOT (LESSP (OFFSET (R-CFP R))
                       (OFFSET (R-CSP R))))
           (CSTKP (FETCH (R-CFP R)
                         (R-SYS-DATA-SEGMENT R))
                  (R-SYS-DATA-SEGMENT R))))

(DEFN R-RET-STEP
      (INS R)
      (IF (EMPTY-STKP (POP-STK (POP-STK (R-CFP R)))
                      (R-SYS-DATA-SEGMENT R))
          (R-HALT R 'HALT)
          (R-STATE (FETCH (POP-STK (R-CFP R))
                          (R-SYS-DATA-SEGMENT R))
                   (FETCH (R-CFP R)
                          (R-SYS-DATA-SEGMENT R))
                   (POP-STK (POP-STK (R-CFP R)))
                   (R-TSP R)
                   (R-X R)
                   (R-Y R)
                   (R-C-FLG R)
                   (R-V-FLG R)
                   (R-N-FLG R)
                   (R-Z-FLG R)
                   (R-PROG-SEGMENT R)
                   (R-USR-DATA-SEGMENT R)
                   (R-SYS-DATA-SEGMENT R)
                   (R-WORD-SIZE R)
                   'RUN)))

(DEFN R-RET-STEP-CLOCK
      (INS R)
      (IF (EMPTY-STKP (POP-STK (POP-STK (R-CFP R)))
                      (R-SYS-DATA-SEGMENT R))
          0
          (PLUS 1 3)))

(DEFN R-LOCN-OKP
 (INS R)
 (AND
  (ADD1-R-PCP R)
  (R-OBJECTP-TYPE 'SYS-ADDR
                  (ADD-ADDR (R-CSP R)
                            (OFFSET-FROM-CSP (CADR INS)
                                             (R-CURRENT-PROGRAM R)))
                  R)
  (R-OBJECTP-TYPE 'NAT
                  (FETCH (ADD-ADDR (R-CSP R)
                                   (OFFSET-FROM-CSP (CADR INS)
                                                    (R-CURRENT-PROGRAM R)))
                         (R-SYS-DATA-SEGMENT R))
                  R)
  (R-OBJECTP-TYPE 'SYS-ADDR
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     R)
  (NOT (EMPTY-STKP (ADD-ADDR (R-CSP R)
                             (OFFSET-FROM-CSP (CADR INS)
                                              (R-CURRENT-PROGRAM R)))
                   (R-SYS-DATA-SEGMENT R)))
  (NOT
   (EMPTY-STKP
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     (R-SYS-DATA-SEGMENT R)))
  (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-LOCN-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (PUSH-STK (R-TSP R))
  (ADD-ADDR (R-CSP R)
            (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                    (OFFSET-FROM-CSP (CADR INS)
                                                     (R-CURRENT-PROGRAM R)))
                          (R-SYS-DATA-SEGMENT R))))
  (R-Y R)
  (R-C-FLG R)
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (FETCH
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     (R-SYS-DATA-SEGMENT R))
   (PUSH-STK (R-TSP R))
   (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-LOCN-STEP-CLOCK (INS R) 5)

(DEFN R-PUSH-CONSTANT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (OR (R-OBJECTP (CADR INS) R)
               (EQUAL (CADR INS) 'PC)
               (AND (NLISTP (CADR INS))
                    (FIND-LABELP (CADR INS)
                                 (PROGRAM-BODY (R-CURRENT-PROGRAM R)))))
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSH-CONSTANT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (PUSH-STK (R-TSP R))
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (COND ((EQUAL (CADR INS) 'PC)
                               (ADD1-R-PC R))
                              ((NLISTP (CADR INS))
                               (PC (CADR INS) (R-CURRENT-PROGRAM R)))
                              (T (CADR INS)))
                        (PUSH-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-PUSH-CONSTANT-STEP-CLOCK
      (INS R)
      1)

(DEFN R-PUSH-LOCAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (R-OBJECTP-TYPE 'SYS-ADDR
                           (ADD-ADDR (R-CSP R)
                                     (OFFSET-FROM-CSP (CADR INS)
                                                      (R-CURRENT-PROGRAM R)))
                           R)
           (NOT (EMPTY-STKP (ADD-ADDR (R-CSP R)
                                      (OFFSET-FROM-CSP (CADR INS)
                                                       (R-CURRENT-PROGRAM R)))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSH-LOCAL-STEP
    (INS R)
    (R-STATE (ADD1-R-PC R)
             (R-CFP R)
             (R-CSP R)
             (PUSH-STK (R-TSP R))
             (ADD-ADDR (R-CSP R)
                       (OFFSET-FROM-CSP (CADR INS)
                                        (R-CURRENT-PROGRAM R)))
             (R-Y R)
             (R-C-FLG R)
             (R-V-FLG R)
             (R-N-FLG R)
             (R-Z-FLG R)
             (R-PROG-SEGMENT R)
             (R-USR-DATA-SEGMENT R)
             (DEPOSIT (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))
                      (PUSH-STK (R-TSP R))
                      (R-SYS-DATA-SEGMENT R))
             (R-WORD-SIZE R)
             'RUN))

(DEFN R-PUSH-LOCAL-STEP-CLOCK
      (INS R)
      3)

(DEFN R-PUSH-GLOBAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (DEFINEDP (CADR INS)
                     (R-USR-DATA-SEGMENT R))
           (LISTP (DEFINIENS (CADR INS)
                         (R-USR-DATA-SEGMENT R)))
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSH-GLOBAL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (PUSH-STK (R-TSP R))
               (TAG 'ADDR (CONS (CADR INS) 0))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (FETCH (TAG 'ADDR (CONS (CADR INS) 0))
                               (R-USR-DATA-SEGMENT R))
                        (PUSH-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-PUSH-GLOBAL-STEP-CLOCK
      (INS R)
      2)

(DEFN R-PUSH-CTRL-STK-FREE-SIZE-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSH-CTRL-STK-FREE-SIZE-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (PUSH-STK (R-TSP R))
               (FETCH '(SYS-ADDR (FULL-CTRL-STK-ADDR . 0))
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT (FREE-STK-SIZE (R-CSP R)))
                        (PUSH-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-PUSH-CTRL-STK-FREE-SIZE-STEP-CLOCK
      (INS R)
      4)

(DEFN R-PUSH-TEMP-STK-FREE-SIZE-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSH-TEMP-STK-FREE-SIZE-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (PUSH-STK (R-TSP R))
               (FETCH '(SYS-ADDR (FULL-TEMP-STK-ADDR . 0))
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT (FREE-STK-SIZE (R-TSP R)))
                        (PUSH-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-PUSH-TEMP-STK-FREE-SIZE-STEP-CLOCK
      (INS R)
      4)

(DEFN R-PUSH-TEMP-STK-INDEX-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))
           (NUMBERP (CADR INS))
           (LESSP (CADR INS)
                  (STK-LENGTH (R-TSP R)
                              (R-SYS-DATA-SEGMENT R)))))

(DEFN
  R-PUSH-TEMP-STK-INDEX-STEP
  (INS R)
  (R-STATE (ADD1-R-PC R)
           (R-CFP R)
           (R-CSP R)
           (PUSH-STK (R-TSP R))
           (TAG 'NAT (ADD1 (CADR INS)))
           (R-TSP R)
           (R-C-FLG R)
           (R-V-FLG R)
           (R-N-FLG R)
           '(BOOL F)
           (R-PROG-SEGMENT R)
           (R-USR-DATA-SEGMENT R)
           (DEPOSIT (TAG 'NAT
                         (DIFFERENCE (SUB1 (STK-LENGTH (R-TSP R)
                                                       (R-SYS-DATA-SEGMENT R)))
                                     (CADR INS)))
                    (PUSH-STK (R-TSP R))
                    (R-SYS-DATA-SEGMENT R))
           (R-WORD-SIZE R)
           'RUN))

(DEFN R-PUSH-TEMP-STK-INDEX-STEP-CLOCK
      (INS R)
      7)

(DEFN R-JUMP-IF-TEMP-STK-FULL-OKP
      (INS R)
      (IF (ZEROP (FREE-STK-SIZE (R-TSP R)))
          (FIND-LABELP (CADR INS)
                       (PROGRAM-BODY (R-CURRENT-PROGRAM R)))
          (ADD1-R-PCP R)))

(DEFN R-JUMP-IF-TEMP-STK-FULL-STEP
      (INS R)
      (R-STATE (IF (ZEROP (FREE-STK-SIZE (R-TSP R)))
                   (PC (CADR INS) (R-CURRENT-PROGRAM R))
                   (ADD1-R-PC R))
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (PC (CADR INS) (R-CURRENT-PROGRAM R))
               '(SYS-ADDR (TSTK . 0))
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (BOOL (ZEROP (FREE-STK-SIZE (R-TSP R))))
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-JUMP-IF-TEMP-STK-FULL-STEP-CLOCK
      (INS R)
      6)

(DEFN R-JUMP-IF-TEMP-STK-EMPTY-OKP
      (INS R)
      (IF (EMPTY-STKP (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
          (FIND-LABELP (CADR INS)
                       (PROGRAM-BODY (R-CURRENT-PROGRAM R)))
          (ADD1-R-PCP R)))

(DEFN R-JUMP-IF-TEMP-STK-EMPTY-STEP
      (INS R)
      (R-STATE (IF (EMPTY-STKP (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                   (PC (CADR INS) (R-CURRENT-PROGRAM R))
                   (ADD1-R-PC R))
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (PC (CADR INS) (R-CURRENT-PROGRAM R))
               (R-TSP R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (BOOL (EMPTY-STKP (R-TSP R)
                                 (R-SYS-DATA-SEGMENT R)))
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-JUMP-IF-TEMP-STK-EMPTY-STEP-CLOCK
      (INS R)
      6)

(DEFN R-POP-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (R-OBJECTP (FETCH (R-TSP R)
                             (R-SYS-DATA-SEGMENT R))
                      R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))))

(DEFN R-POP-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POP-STEP-CLOCK (INS R) 1)

(DEFN R-POP*-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NUMBERP (CADR INS))
           (R-OBJECTP-TYPE 'SYS-ADDR
                           (POP-STK-N (CADR INS) (R-TSP R))
                           R)))

(DEFN R-POP*-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK-N (CADR INS) (R-TSP R))
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POP*-STEP-CLOCK (INS R) 1)

(DEFN R-POPN-OKP
  (INS R)
  (AND (ADD1-R-PCP R)
       (NOT (EMPTY-STKP (R-TSP R)
                        (R-SYS-DATA-SEGMENT R)))
       (R-OBJECTP-TYPE 'NAT
                       (FETCH (R-TSP R)
                              (R-SYS-DATA-SEGMENT R))
                       R)
       (R-OBJECTP-TYPE 'SYS-ADDR
                       (POP-STK-N (ADD1 (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                                  (R-TSP R))
                       R)))

(DEFN R-POPN-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK-N (ADD1 (UNTAG (FETCH (R-TSP R)
                                              (R-SYS-DATA-SEGMENT R))))
                          (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POPN-STEP-CLOCK (INS R) 2)

(DEFN R-POP-LOCAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (R-OBJECTP-TYPE 'SYS-ADDR
                           (ADD-ADDR (R-CSP R)
                                     (OFFSET-FROM-CSP (CADR INS)
                                                      (R-CURRENT-PROGRAM R)))
                           R)
           (NOT (EMPTY-STKP (ADD-ADDR (R-CSP R)
                                      (OFFSET-FROM-CSP (CADR INS)
                                                       (R-CURRENT-PROGRAM R)))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))))

(DEFN R-POP-LOCAL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (ADD-ADDR (R-CSP R)
                         (OFFSET-FROM-CSP (CADR INS)
                                          (R-CURRENT-PROGRAM R)))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (ADD-ADDR (R-CSP R)
                                  (OFFSET-FROM-CSP (CADR INS)
                                                   (R-CURRENT-PROGRAM R)))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POP-LOCAL-STEP-CLOCK
      (INS R)
      3)

(DEFN R-POP-GLOBAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (DEFINEDP (CADR INS)
                     (R-USR-DATA-SEGMENT R))
           (LISTP (DEFINIENS (CADR INS)
                         (R-USR-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-USR-DATA-OBJECTP (FETCH (R-TSP R)
                                      (R-SYS-DATA-SEGMENT R))
                               R)))

(DEFN R-POP-GLOBAL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (TAG 'ADDR (CONS (CADR INS) 0))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (DEPOSIT (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (TAG 'ADDR (CONS (CADR INS) 0))
                        (R-USR-DATA-SEGMENT R))
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POP-GLOBAL-STEP-CLOCK
      (INS R)
      2)

(DEFN R-POP-LOCN-OKP
 (INS R)
 (AND
  (ADD1-R-PCP R)
  (R-OBJECTP-TYPE 'SYS-ADDR
                  (ADD-ADDR (R-CSP R)
                            (OFFSET-FROM-CSP (CADR INS)
                                             (R-CURRENT-PROGRAM R)))
                  R)
  (R-OBJECTP-TYPE 'NAT
                  (FETCH (ADD-ADDR (R-CSP R)
                                   (OFFSET-FROM-CSP (CADR INS)
                                                    (R-CURRENT-PROGRAM R)))
                         (R-SYS-DATA-SEGMENT R))
                  R)
  (R-OBJECTP-TYPE 'SYS-ADDR
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     R)
  (NOT (EMPTY-STKP (ADD-ADDR (R-CSP R)
                             (OFFSET-FROM-CSP (CADR INS)
                                              (R-CURRENT-PROGRAM R)))
                   (R-SYS-DATA-SEGMENT R)))
  (NOT
   (EMPTY-STKP
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     (R-SYS-DATA-SEGMENT R)))
  (NOT (EMPTY-STKP (R-TSP R)
                   (R-SYS-DATA-SEGMENT R)))))

(DEFN R-POP-LOCN-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (ADD-ADDR (R-CSP R)
            (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                    (OFFSET-FROM-CSP (CADR INS)
                                                     (R-CURRENT-PROGRAM R)))
                          (R-SYS-DATA-SEGMENT R))))
  (R-Y R)
  (R-C-FLG R)
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
     (FETCH (R-TSP R)
            (R-SYS-DATA-SEGMENT R))
     (ADD-ADDR (R-CSP R)
               (UNTAG (FETCH (ADD-ADDR (R-CSP R)
                                       (OFFSET-FROM-CSP (CADR INS)
                                                        (R-CURRENT-PROGRAM R)))
                             (R-SYS-DATA-SEGMENT R))))
     (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-POP-LOCN-STEP-CLOCK (INS R) 5)

(DEFN R-POP-CALL-OKP
      (INS R)
      (AND (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'SUBR
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-CALL-OKP (LIST 'CALL
                             (UNTAG (FETCH (R-TSP R)
                                           (R-SYS-DATA-SEGMENT R))))
                       (R-STATE (R-PC R)
                                (R-CFP R)
                                (R-CSP R)
                                (POP-STK (R-TSP R))
                                (FETCH (R-TSP R)
                                       (R-SYS-DATA-SEGMENT R))
                                (R-Y R)
                                (R-C-FLG R)
                                (R-V-FLG R)
                                (R-N-FLG R)
                                (R-Z-FLG R)
                                (R-PROG-SEGMENT R)
                                (R-USR-DATA-SEGMENT R)
                                (R-SYS-DATA-SEGMENT R)
                                (R-WORD-SIZE R)
                                'RUN))))

(DEFN R-POP-CALL-STEP
      (INS R)
      (R-CALL-STEP (LIST 'CALL
                         (UNTAG (FETCH (R-TSP R)
                                       (R-SYS-DATA-SEGMENT R))))
                   (R-STATE (R-PC R)
                            (R-CFP R)
                            (R-CSP R)
                            (POP-STK (R-TSP R))
                            (FETCH (R-TSP R)
                                   (R-SYS-DATA-SEGMENT R))
                            (R-Y R)
                            (R-C-FLG R)
                            (R-V-FLG R)
                            (R-N-FLG R)
                            (R-Z-FLG R)
                            (R-PROG-SEGMENT R)
                            (R-USR-DATA-SEGMENT R)
                            (R-SYS-DATA-SEGMENT R)
                            (R-WORD-SIZE R)
                            'RUN)))

(DEFN R-POP-CALL-STEP-CLOCK
 (INS R)
 (PLUS 3 2
      (LENGTH (TEMP-VAR-DCLS (DEFINITION (UNTAG (FETCH (R-TSP R)
                                                       (R-SYS-DATA-SEGMENT R)))
                                         (R-PROG-SEGMENT R))))
      (LENGTH (FORMAL-VARS (DEFINITION (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (R-PROG-SEGMENT R))))))

(DEFN R-FETCH-TEMP-STK-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (LESSP (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))
                  (STK-LENGTH (R-TSP R)
                              (R-SYS-DATA-SEGMENT R)))))

(DEFN
 R-FETCH-TEMP-STK-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (R-TSP R)
  (SUB-ADDR (TAG 'SYS-ADDR
                 (CONS 'TSTK
                       (SUB1 (LENGTH (DEFINIENS 'TSTK
                                            (R-SYS-DATA-SEGMENT R))))))
            (ADD1 (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))))
  (TAG 'NAT
       (ADD1 (UNTAG (FETCH (R-TSP R)
                           (R-SYS-DATA-SEGMENT R)))))
  (R-C-FLG R)
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (FETCH (SUB-ADDR (TAG 'SYS-ADDR
                         (CONS 'TSTK
                               (SUB1 (LENGTH (DEFINIENS 'TSTK
                                                    (R-SYS-DATA-SEGMENT R))))))
                    (ADD1 (UNTAG (FETCH (R-TSP R)
                                        (R-SYS-DATA-SEGMENT R)))))
          (R-SYS-DATA-SEGMENT R))
   (R-TSP R)
   (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-FETCH-TEMP-STK-STEP-CLOCK
      (INS R)
      6)

(DEFN R-DEPOSIT-TEMP-STK-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (LESSP (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))
                  (STK-LENGTH (POP-STK (POP-STK (R-TSP R)))
                              (R-SYS-DATA-SEGMENT R)))
           (R-USR-DATA-OBJECTP (FETCH (POP-STK (R-TSP R))
                                      (R-SYS-DATA-SEGMENT R))
                               R)))

(DEFN R-DEPOSIT-TEMP-STK-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (POP-STK (R-TSP R)))
  (SUB-ADDR (TAG 'SYS-ADDR
                 (CONS 'TSTK
                       (SUB1 (LENGTH (DEFINIENS 'TSTK
                                            (R-SYS-DATA-SEGMENT R))))))
            (ADD1 (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))))
  (TAG 'NAT
       (ADD1 (UNTAG (FETCH (R-TSP R)
                           (R-SYS-DATA-SEGMENT R)))))
  (R-C-FLG R)
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
          (FETCH (POP-STK (R-TSP R))
                 (R-SYS-DATA-SEGMENT R))
          (SUB-ADDR (TAG 'SYS-ADDR
                         (CONS 'TSTK
                               (SUB1 (LENGTH (DEFINIENS 'TSTK
                                                    (R-SYS-DATA-SEGMENT R))))))
                    (ADD1 (UNTAG (FETCH (R-TSP R)
                                        (R-SYS-DATA-SEGMENT R)))))
          (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-DEPOSIT-TEMP-STK-STEP-CLOCK
      (INS R)
      6)

(DEFN R-JUMP-OKP
      (INS R)
      (FIND-LABELP (CADR INS)
                   (PROGRAM-BODY (R-CURRENT-PROGRAM R))))

(DEFN R-JUMP-STEP
      (INS R)
      (R-STATE (PC (CADR INS) (R-CURRENT-PROGRAM R))
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-JUMP-STEP-CLOCK (INS R) 1)

(DEFN R-JUMP-CASE-OKP
      (INS R)
      (AND (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (LESSP (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))
                  (LENGTH (CDR INS)))
           (FIND-LABELP (GET (UNTAG (FETCH (R-TSP R)
                                           (R-SYS-DATA-SEGMENT R)))
                             (CDR INS))
                        (PROGRAM-BODY (R-CURRENT-PROGRAM R)))))

(DEFN R-JUMP-CASE-STEP
      (INS R)
      (R-STATE (PC (GET (UNTAG (FETCH (R-TSP R)
                                      (R-SYS-DATA-SEGMENT R)))
                        (CDR INS))
                   (R-CURRENT-PROGRAM R))
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (TAG 'NAT
                    (TIMES 2
                           (UNTAG (FETCH (R-TSP R)
                                         (R-SYS-DATA-SEGMENT R)))))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-JUMP-CASE-STEP-CLOCK
      (INS R)
      4)

(DEFN R-PUSHJ-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (FIND-LABELP (CADR INS)
                        (PROGRAM-BODY (R-CURRENT-PROGRAM R)))
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-PUSHJ-STEP
      (INS R)
      (R-STATE (PC (CADR INS) (R-CURRENT-PROGRAM R))
               (R-CFP R)
               (R-CSP R)
               (PUSH-STK (R-TSP R))
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (ADD1-R-PC R)
                        (PUSH-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-PUSHJ-STEP-CLOCK (INS R) 2)

(DEFN R-POPJ-OKP
      (INS R)
      (AND (R-OBJECTP-TYPE 'PC
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))))

(DEFN R-POPJ-STEP
      (INS R)
      (R-STATE (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-POPJ-STEP-CLOCK (INS R) 1)

(DEFN R-SET-LOCAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (R-OBJECTP-TYPE 'SYS-ADDR
                           (ADD-ADDR (R-CSP R)
                                     (OFFSET-FROM-CSP (CADR INS)
                                                      (R-CURRENT-PROGRAM R)))
                           R)
           (NOT (EMPTY-STKP (ADD-ADDR (R-CSP R)
                                      (OFFSET-FROM-CSP (CADR INS)
                                                       (R-CURRENT-PROGRAM R)))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))))

(DEFN R-SET-LOCAL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (ADD-ADDR (R-CSP R)
                         (OFFSET-FROM-CSP (CADR INS)
                                          (R-CURRENT-PROGRAM R)))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (ADD-ADDR (R-CSP R)
                                  (OFFSET-FROM-CSP (CADR INS)
                                                   (R-CURRENT-PROGRAM R)))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-SET-LOCAL-STEP-CLOCK
      (INS R)
      3)

(DEFN R-SET-GLOBAL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (DEFINEDP (CADR INS)
                     (R-USR-DATA-SEGMENT R))
           (LISTP (DEFINIENS (CADR INS)
                         (R-USR-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-USR-DATA-OBJECTP (FETCH (R-TSP R)
                                      (R-SYS-DATA-SEGMENT R))
                               R)))

(DEFN R-SET-GLOBAL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (TAG 'ADDR (CONS (CADR INS) 0))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (DEPOSIT (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (TAG 'ADDR (CONS (CADR INS) 0))
                        (R-USR-DATA-SEGMENT R))
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-SET-GLOBAL-STEP-CLOCK
      (INS R)
      2)

(DEFN R-TEST-AND-JUMP-OKP
      (INS TYPE TEST R)
      (AND (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE TYPE
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (IF TEST
               (FIND-LABELP (CADDR INS)
                            (PROGRAM-BODY (R-CURRENT-PROGRAM R)))
               (ADD1-R-PCP R))))

(DEFN R-TEST-AND-JUMP-STEP
      (TEST LAB X Y C V N Z R)
      (IF TEST
          (R-STATE (PC LAB (R-CURRENT-PROGRAM R))
                   (R-CFP R)
                   (R-CSP R)
                   (POP-STK (R-TSP R))
                   X Y C V N Z
                   (R-PROG-SEGMENT R)
                   (R-USR-DATA-SEGMENT R)
                   (R-SYS-DATA-SEGMENT R)
                   (R-WORD-SIZE R)
                   'RUN)
          (R-STATE (ADD1-R-PC R)
                   (R-CFP R)
                   (R-CSP R)
                   (POP-STK (R-TSP R))
                   X Y C V N Z
                   (R-PROG-SEGMENT R)
                   (R-USR-DATA-SEGMENT R)
                   (R-SYS-DATA-SEGMENT R)
                   (R-WORD-SIZE R)
                   'RUN)))

(DEFN R-TEST-NAT-AND-JUMP-OKP
      (INS R)
      (R-TEST-AND-JUMP-OKP INS 'NAT
                           (P-TEST-NATP (CADR INS)
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           R))

(DEFN R-TEST-NAT-AND-JUMP-STEP
     (INS R)
     (R-TEST-AND-JUMP-STEP (P-TEST-NATP (CADR INS)
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           (CADDR INS)
                           (PC (CADDR INS) (R-CURRENT-PROGRAM R))
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           (R-C-FLG R)
                           (R-V-FLG R)
                           (R-N-FLG R)
                           (BOOL (EQUAL (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R)))
                                        0))
                           R))

(DEFN R-TEST-NAT-AND-JUMP-STEP-CLOCK
      (INS R)
      3)

(DEFN R-TEST-INT-AND-JUMP-OKP
      (INS R)
      (R-TEST-AND-JUMP-OKP INS 'INT
                           (P-TEST-INTP (CADR INS)
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           R))

(DEFN R-TEST-INT-AND-JUMP-STEP
 (INS R)
 (R-TEST-AND-JUMP-STEP
                      (P-TEST-INTP (CADR INS)
                                   (UNTAG (FETCH (R-TSP R)
                                                 (R-SYS-DATA-SEGMENT R))))
                      (CADDR INS)
                      (IF (EQUAL (CADR INS) 'POS)
                          (ADD1-ADDR (R-PC R))
                          (PC (CADDR INS)
                              (R-CURRENT-PROGRAM R)))
                      (FETCH (R-TSP R)
                             (R-SYS-DATA-SEGMENT R))
                      (R-C-FLG R)
                      (R-V-FLG R)
                      (BOOL (NEGATIVEP (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                      (BOOL (EQUAL (UNTAG (FETCH (R-TSP R)
                                                 (R-SYS-DATA-SEGMENT R)))
                                   0))
                      R))

(DEFN R-TEST-INT-AND-JUMP-STEP-CLOCK
     (INS R)
     (CASE (CAR (CDR INS))
           (ZERO 3)
           (NOT-ZERO 3)
           (NEG 3)
           (NOT-NEG 3)
           (POS (PLUS 2
                      (COND ((NEGATIVEP (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                             1)
                            ((ZEROP (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R))))
                             2)
                            (T 3))))
           (OTHERWISE (IF (NEGATIVEP (UNTAG (FETCH (R-TSP R)
                                                   (R-SYS-DATA-SEGMENT R))))
                          3 4))))

(DEFN R-TEST-BOOL-AND-JUMP-OKP
     (INS R)
     (R-TEST-AND-JUMP-OKP INS 'BOOL
                          (P-TEST-BOOLP (CADR INS)
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                          R))

(DEFN R-TEST-BOOL-AND-JUMP-STEP
  (INS R)
  (R-TEST-AND-JUMP-STEP (P-TEST-BOOLP (CADR INS)
                                      (UNTAG (FETCH (R-TSP R)
                                                    (R-SYS-DATA-SEGMENT R))))
                        (CADDR INS)
                        (PC (CADDR INS) (R-CURRENT-PROGRAM R))
                        (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (R-C-FLG R)
                        (R-V-FLG R)
                        (R-N-FLG R)
                        (TAG 'BOOL
                             (NOT-BOOL (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        R))

(DEFN R-TEST-BOOL-AND-JUMP-STEP-CLOCK
      (INS R)
      3)

(DEFN R-TEST-BITV-AND-JUMP-OKP
     (INS R)
     (R-TEST-AND-JUMP-OKP INS 'BITV
                          (P-TEST-BITVP (CADR INS)
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                          R))

(DEFN R-TEST-BITV-AND-JUMP-STEP
 (INS R)
 (R-TEST-AND-JUMP-STEP
                 (P-TEST-BITVP (CADR INS)
                               (UNTAG (FETCH (R-TSP R)
                                             (R-SYS-DATA-SEGMENT R))))
                 (CADDR INS)
                 (PC (CADDR INS) (R-CURRENT-PROGRAM R))
                 (FETCH (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
                 (R-C-FLG R)
                 (R-V-FLG R)
                 (R-N-FLG R)
                 (BOOL (ALL-ZERO-BITVP (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                 R))

(DEFN R-TEST-BITV-AND-JUMP-STEP-CLOCK
      (INS R)
      3)

(DEFN R-NO-OP-OKP
      (INS R)
      (ADD1-R-PCP R))

(DEFN R-NO-OP-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-NO-OP-STEP-CLOCK (INS R) 1)

(DEFN R-ADD-ADDR-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'ADDR
                           (ADD-ADDR (FETCH (POP-STK (R-TSP R))
                                            (R-SYS-DATA-SEGMENT R))
                                     (UNTAG (FETCH (R-TSP R)
                                                   (R-SYS-DATA-SEGMENT R))))
                           R)))

(DEFN R-ADD-ADDR-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (ADD-ADDR (FETCH (POP-STK (R-TSP R))
                                         (R-SYS-DATA-SEGMENT R))
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-ADD-ADDR-STEP-CLOCK (INS R) 2)

(DEFN R-SUB-ADDR-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (LESSP (OFFSET (FETCH (POP-STK (R-TSP R))
                                      (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))))

(DEFN R-SUB-ADDR-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (SUB-ADDR (FETCH (POP-STK (R-TSP R))
                                         (R-SYS-DATA-SEGMENT R))
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-SUB-ADDR-STEP-CLOCK (INS R) 2)

(DEFN R-EQ-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-USR-DATA-OBJECTP (FETCH (POP-STK (R-TSP R))
                                      (R-SYS-DATA-SEGMENT R))
                               R)
           (R-USR-DATA-OBJECTP (FETCH (R-TSP R)
                                      (R-SYS-DATA-SEGMENT R))
                               R)
           (EQUAL (TYPE (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R)))
                  (TYPE (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))))))

(DEFN R-EQ-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (BOOL (EQUAL (UNTAG (FETCH (POP-STK (R-TSP R))
                                          (R-SYS-DATA-SEGMENT R)))
                            (UNTAG (FETCH (R-TSP R)
                                          (R-SYS-DATA-SEGMENT R)))))
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (BOOL (EQUAL (UNTAG (FETCH (POP-STK (R-TSP R))
                                                   (R-SYS-DATA-SEGMENT R)))
                                     (UNTAG (FETCH (R-TSP R)
                                                   (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-EQ-STEP-CLOCK (INS R) 4)

(DEFN R-LT-ADDR-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (EQUAL (AREA-NAME (FETCH (R-TSP R)
                                    (R-SYS-DATA-SEGMENT R)))
                  (AREA-NAME (FETCH (POP-STK (R-TSP R))
                                    (R-SYS-DATA-SEGMENT R))))))

(DEFN R-LT-ADDR-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (BOOL (LESSP (OFFSET (FETCH (POP-STK (R-TSP R))
                                           (R-SYS-DATA-SEGMENT R)))
                            (OFFSET (FETCH (R-TSP R)
                                           (R-SYS-DATA-SEGMENT R)))))
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (BOOL (LESSP (OFFSET (FETCH (POP-STK (R-TSP R))
                                                    (R-SYS-DATA-SEGMENT R)))
                                     (OFFSET (FETCH (R-TSP R)
                                                    (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-LT-ADDR-STEP-CLOCK (INS R) 4)

(DEFN R-FETCH-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-FETCH-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (FETCH (FETCH (R-TSP R)
                                      (R-SYS-DATA-SEGMENT R))
                               (R-USR-DATA-SEGMENT R))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-FETCH-STEP-CLOCK (INS R) 2)

(DEFN R-DEPOSIT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'ADDR
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-USR-DATA-OBJECTP (FETCH (POP-STK (R-TSP R))
                                      (R-SYS-DATA-SEGMENT R))
                               R)))

(DEFN R-DEPOSIT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (POP-STK (R-TSP R)))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (DEPOSIT (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R))
                        (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R))
                        (R-USR-DATA-SEGMENT R))
               (R-SYS-DATA-SEGMENT R)
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-DEPOSIT-STEP-CLOCK (INS R) 2)

(DEFN R-ADD-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'INT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-INTEGERP (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                                (R-SYS-DATA-SEGMENT R)))
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-ADD-INT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'INT
                             (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                                  (R-SYS-DATA-SEGMENT R)))
                                    (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-ADD-INT-STEP-CLOCK (INS R) 2)

(DEFN R-ADD-INT-WITH-CARRY-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (POP-STK (R-TSP R)))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'INT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (POP-STK (R-TSP R)))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-ADD-INT-WITH-CARRY-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (TAG 'INT
   (FIX-SMALL-INTEGER
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                            (R-SYS-DATA-SEGMENT R)))
                              (UNTAG (FETCH (R-TSP R)
                                            (R-SYS-DATA-SEGMENT R)))))
                (R-WORD-SIZE R)))
  (FETCH (POP-STK (R-TSP R))
         (R-SYS-DATA-SEGMENT R))
  (FETCH (POP-STK (POP-STK (R-TSP R)))
         (R-SYS-DATA-SEGMENT R))
  (BOOL
   (NOT
    (SMALL-INTEGERP
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                            (R-SYS-DATA-SEGMENT R)))
                              (UNTAG (FETCH (R-TSP R)
                                            (R-SYS-DATA-SEGMENT R)))))
                (R-WORD-SIZE R))))
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (TAG 'INT
    (FIX-SMALL-INTEGER
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                            (R-SYS-DATA-SEGMENT R)))
                              (UNTAG (FETCH (R-TSP R)
                                            (R-SYS-DATA-SEGMENT R)))))
                (R-WORD-SIZE R)))
   (POP-STK (R-TSP R))
   (DEPOSIT
    (BOOL
     (NOT
      (SMALL-INTEGERP
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (IPLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                            (R-SYS-DATA-SEGMENT R)))
                              (UNTAG (FETCH (R-TSP R)
                                            (R-SYS-DATA-SEGMENT R)))))
                (R-WORD-SIZE R))))
    (POP-STK (POP-STK (R-TSP R)))
    (R-SYS-DATA-SEGMENT R)))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-ADD-INT-WITH-CARRY-STEP-CLOCK
      (INS R)
      6)

(DEFN R-ADD1-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-INTEGERP (IPLUS 1
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-ADD1-INT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'INT
                             (IPLUS 1
                                    (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-ADD1-INT-STEP-CLOCK (INS R) 1)

(DEFN R-SUB-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'INT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                      (R-SYS-DATA-SEGMENT R)))
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-SUB-INT-STEP
   (INS R)
   (R-STATE (ADD1-R-PC R)
            (R-CFP R)
            (R-CSP R)
            (POP-STK (R-TSP R))
            (FETCH (R-TSP R)
                   (R-SYS-DATA-SEGMENT R))
            (R-Y R)
            (R-C-FLG R)
            (R-V-FLG R)
            (R-N-FLG R)
            (R-Z-FLG R)
            (R-PROG-SEGMENT R)
            (R-USR-DATA-SEGMENT R)
            (DEPOSIT (TAG 'INT
                          (IDIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                     (POP-STK (R-TSP R))
                     (R-SYS-DATA-SEGMENT R))
            (R-WORD-SIZE R)
            'RUN))

(DEFN R-SUB-INT-STEP-CLOCK (INS R) 2)

(DEFN R-SUB-INT-WITH-CARRY-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (POP-STK (R-TSP R)))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'INT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (POP-STK (R-TSP R)))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-SUB-INT-WITH-CARRY-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (TAG 'INT
   (FIX-SMALL-INTEGER
    (IDIFFERENCE
                (UNTAG (FETCH (POP-STK (R-TSP R))
                              (R-SYS-DATA-SEGMENT R)))
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))
    (R-WORD-SIZE R)))
  (FETCH (R-TSP R)
         (R-SYS-DATA-SEGMENT R))
  (FETCH (POP-STK (POP-STK (R-TSP R)))
         (R-SYS-DATA-SEGMENT R))
  (BOOL
   (NOT
    (SMALL-INTEGERP
     (IDIFFERENCE
                (UNTAG (FETCH (POP-STK (R-TSP R))
                              (R-SYS-DATA-SEGMENT R)))
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))
     (R-WORD-SIZE R))))
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (TAG 'INT
    (FIX-SMALL-INTEGER
     (IDIFFERENCE
                (UNTAG (FETCH (POP-STK (R-TSP R))
                              (R-SYS-DATA-SEGMENT R)))
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))
     (R-WORD-SIZE R)))
   (POP-STK (R-TSP R))
   (DEPOSIT
    (BOOL
     (NOT
      (SMALL-INTEGERP
       (IDIFFERENCE
                (UNTAG (FETCH (POP-STK (R-TSP R))
                              (R-SYS-DATA-SEGMENT R)))
                (IPLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))
       (R-WORD-SIZE R))))
    (POP-STK (POP-STK (R-TSP R)))
    (R-SYS-DATA-SEGMENT R)))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-SUB-INT-WITH-CARRY-STEP-CLOCK
      (INS R)
      6)

(DEFN R-SUB1-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R)))
                                        1)
                           (R-WORD-SIZE R))))

(DEFN R-SUB1-INT-STEP
     (INS R)
     (R-STATE (ADD1-R-PC R)
              (R-CFP R)
              (R-CSP R)
              (R-TSP R)
              (R-X R)
              (R-Y R)
              (R-C-FLG R)
              (R-V-FLG R)
              (R-N-FLG R)
              (R-Z-FLG R)
              (R-PROG-SEGMENT R)
              (R-USR-DATA-SEGMENT R)
              (DEPOSIT (TAG 'INT
                            (IDIFFERENCE (UNTAG (FETCH (R-TSP R)
                                                       (R-SYS-DATA-SEGMENT R)))
                                         1))
                       (R-TSP R)
                       (R-SYS-DATA-SEGMENT R))
              (R-WORD-SIZE R)
              'RUN))

(DEFN R-SUB1-INT-STEP-CLOCK (INS R) 1)

(DEFN R-NEG-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-INTEGERP (INEGATE (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-NEG-INT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'INT
                             (INEGATE (UNTAG (FETCH (R-TSP R)
                                                    (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-NEG-INT-STEP-CLOCK (INS R) 1)

(DEFN R-LT-INT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'INT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-LT-INT-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (BOOL
   (NEGATIVEP
        (FIX-SMALL-INTEGER (IDIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                      (R-SYS-DATA-SEGMENT R)))
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))
  (R-Y R)
  (R-C-FLG R)
  (BOOL
      (NOT (SMALL-INTEGERP (IDIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                      (R-SYS-DATA-SEGMENT R)))
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))
  (BOOL
   (NEGATIVEP
        (FIX-SMALL-INTEGER (IDIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                      (R-SYS-DATA-SEGMENT R)))
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT (BOOL (ILESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                                       (R-SYS-DATA-SEGMENT R)))
                         (UNTAG (FETCH (R-TSP R)
                                       (R-SYS-DATA-SEGMENT R)))))
           (POP-STK (R-TSP R))
           (R-SYS-DATA-SEGMENT R))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-LT-INT-STEP-CLOCK (INS R) 7)

(DEFN R-INT-TO-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'INT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (NEGATIVEP (UNTAG (FETCH (R-TSP R)
                                         (R-SYS-DATA-SEGMENT R)))))))

(DEFN R-INT-TO-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT
                             (UNTAG (FETCH (R-TSP R)
                                           (R-SYS-DATA-SEGMENT R))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-INT-TO-NAT-STEP-CLOCK
      (INS R)
      1)

(DEFN R-ADD-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-NATURALP (PLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                               (R-SYS-DATA-SEGMENT R)))
                                 (UNTAG (FETCH (R-TSP R)
                                               (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-ADD-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT
                             (PLUS (UNTAG (FETCH (POP-STK (R-TSP R))
                                                 (R-SYS-DATA-SEGMENT R)))
                                   (UNTAG (FETCH (R-TSP R)
                                                 (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-ADD-NAT-STEP-CLOCK (INS R) 2)

(DEFN R-ADD-NAT-WITH-CARRY-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (POP-STK (R-TSP R)))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (POP-STK (R-TSP R)))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-ADD-NAT-WITH-CARRY-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (TAG 'NAT
   (FIX-SMALL-NATURAL
                 (PLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (POP-STK (R-TSP R))
                                     (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R))))
                 (R-WORD-SIZE R)))
  (FETCH (POP-STK (R-TSP R))
         (R-SYS-DATA-SEGMENT R))
  (BOOL
   (NOT
    (SMALL-NATURALP
                 (PLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (POP-STK (R-TSP R))
                                     (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R))))
                 (R-WORD-SIZE R))))
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (TAG 'NAT
    (FIX-SMALL-NATURAL
                 (PLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (POP-STK (R-TSP R))
                                     (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R))))
                 (R-WORD-SIZE R)))
   (POP-STK (R-TSP R))
   (DEPOSIT
    (BOOL
     (NOT
      (SMALL-NATURALP
                 (PLUS (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))
                       (UNTAG (FETCH (POP-STK (R-TSP R))
                                     (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R))))
                 (R-WORD-SIZE R))))
    (POP-STK (POP-STK (R-TSP R)))
    (R-SYS-DATA-SEGMENT R)))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-ADD-NAT-WITH-CARRY-STEP-CLOCK
      (INS R)
      6)

(DEFN R-ADD1-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-NATURALP (ADD1 (UNTAG (FETCH (R-TSP R)
                                               (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-ADD1-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT
                             (ADD1 (UNTAG (FETCH (R-TSP R)
                                                 (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-ADD1-NAT-STEP-CLOCK (INS R) 1)

(DEFN R-SUB1-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (ZEROP (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))))

(DEFN R-SUB1-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT
                             (SUB1 (UNTAG (FETCH (R-TSP R)
                                                 (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-SUB1-NAT-STEP-CLOCK (INS R) 1)

(DEFN R-SUB-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                                     (R-SYS-DATA-SEGMENT R)))
                       (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))))))

(DEFN
    R-SUB-NAT-STEP
    (INS R)
    (R-STATE (ADD1-R-PC R)
             (R-CFP R)
             (R-CSP R)
             (POP-STK (R-TSP R))
             (FETCH (R-TSP R)
                    (R-SYS-DATA-SEGMENT R))
             (R-Y R)
             (R-C-FLG R)
             (R-V-FLG R)
             (R-N-FLG R)
             (R-Z-FLG R)
             (R-PROG-SEGMENT R)
             (R-USR-DATA-SEGMENT R)
             (DEPOSIT (TAG 'NAT
                           (DIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                      (POP-STK (R-TSP R))
                      (R-SYS-DATA-SEGMENT R))
             (R-WORD-SIZE R)
             'RUN))

(DEFN R-SUB-NAT-STEP-CLOCK (INS R) 2)

(DEFN R-SUB-NAT-WITH-CARRY-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (POP-STK (R-TSP R)))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (POP-STK (R-TSP R)))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-SUB-NAT-WITH-CARRY-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (POP-STK (R-TSP R))
  (TAG 'NAT
   (IF
    (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                         (R-SYS-DATA-SEGMENT R)))
           (PLUS (UNTAG (FETCH (R-TSP R)
                               (R-SYS-DATA-SEGMENT R)))
                 (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                            (R-SYS-DATA-SEGMENT R))))))
    (DIFFERENCE
     (EXP 2 (R-WORD-SIZE R))
     (DIFFERENCE (PLUS (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))
                       (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R)))))
                 (UNTAG (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R)))))
    (DIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                              (R-SYS-DATA-SEGMENT R)))
                (PLUS (UNTAG (FETCH (R-TSP R)
                                    (R-SYS-DATA-SEGMENT R)))
                      (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                 (R-SYS-DATA-SEGMENT R))))))))
  (FETCH (R-TSP R)
         (R-SYS-DATA-SEGMENT R))
  (BOOL (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                             (R-SYS-DATA-SEGMENT R)))
               (PLUS (UNTAG (FETCH (R-TSP R)
                                   (R-SYS-DATA-SEGMENT R)))
                     (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                (R-SYS-DATA-SEGMENT R)))))))
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (TAG 'NAT
    (IF
     (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                          (R-SYS-DATA-SEGMENT R)))
            (PLUS (UNTAG (FETCH (R-TSP R)
                                (R-SYS-DATA-SEGMENT R)))
                  (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                             (R-SYS-DATA-SEGMENT R))))))
     (DIFFERENCE
      (EXP 2 (R-WORD-SIZE R))
      (DIFFERENCE
                 (PLUS (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))
                       (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R)))))
                 (UNTAG (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R)))))
     (DIFFERENCE (UNTAG (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R)))
                 (PLUS (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))
                       (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R))))))))
   (POP-STK (R-TSP R))
   (DEPOSIT
    (BOOL (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                               (R-SYS-DATA-SEGMENT R)))
                 (PLUS (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))
                       (BOOL-TO-NAT (UNTAG (FETCH (POP-STK (POP-STK (R-TSP R)))
                                                  (R-SYS-DATA-SEGMENT R)))))))
    (POP-STK (POP-STK (R-TSP R)))
    (R-SYS-DATA-SEGMENT R)))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-SUB-NAT-WITH-CARRY-STEP-CLOCK
      (INS R)
      6)

(DEFN R-LT-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-LT-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (BOOL (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                                          (R-SYS-DATA-SEGMENT R)))
                            (UNTAG (FETCH (R-TSP R)
                                          (R-SYS-DATA-SEGMENT R)))))
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (BOOL (LESSP (UNTAG (FETCH (POP-STK (R-TSP R))
                                                   (R-SYS-DATA-SEGMENT R)))
                                     (UNTAG (FETCH (R-TSP R)
                                                   (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-LT-NAT-STEP-CLOCK (INS R) 4)

(DEFN R-MULT2-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (SMALL-NATURALP (TIMES 2
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R))))

(DEFN R-MULT2-NAT-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'NAT
                             (TIMES 2
                                    (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-MULT2-NAT-STEP-CLOCK
      (INS R)
      1)

(DEFN R-MULT2-NAT-WITH-CARRY-OUT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN
 R-MULT2-NAT-WITH-CARRY-OUT-STEP
 (INS R)
 (R-STATE
  (ADD1-R-PC R)
  (R-CFP R)
  (R-CSP R)
  (PUSH-STK (R-TSP R))
  (TAG 'NAT
       (FIX-SMALL-NATURAL (TIMES 2
                                 (UNTAG (FETCH (R-TSP R)
                                               (R-SYS-DATA-SEGMENT R))))
                          (R-WORD-SIZE R)))
  (R-Y R)
  (BOOL (NOT (SMALL-NATURALP (TIMES 2
                                    (UNTAG (FETCH (R-TSP R)
                                                  (R-SYS-DATA-SEGMENT R))))
                             (R-WORD-SIZE R))))
  (R-V-FLG R)
  (R-N-FLG R)
  (R-Z-FLG R)
  (R-PROG-SEGMENT R)
  (R-USR-DATA-SEGMENT R)
  (DEPOSIT
   (TAG 'NAT
        (FIX-SMALL-NATURAL (TIMES 2
                                  (UNTAG (FETCH (R-TSP R)
                                                (R-SYS-DATA-SEGMENT R))))
                           (R-WORD-SIZE R)))
   (PUSH-STK (R-TSP R))
   (DEPOSIT
      (BOOL (NOT (SMALL-NATURALP (TIMES 2
                                        (UNTAG (FETCH (R-TSP R)
                                                      (R-SYS-DATA-SEGMENT R))))
                                 (R-WORD-SIZE R))))
      (R-TSP R)
      (R-SYS-DATA-SEGMENT R)))
  (R-WORD-SIZE R)
  'RUN))

(DEFN R-MULT2-NAT-WITH-CARRY-OUT-STEP-CLOCK
      (INS R)
      5)

(DEFN R-DIV2-NAT-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'NAT
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (NOT (ZEROP (FREE-STK-SIZE (R-TSP R))))))

(DEFN R-DIV2-NAT-STEP
 (INS R)
 (R-STATE
        (ADD1-R-PC R)
        (R-CFP R)
        (R-CSP R)
        (PUSH-STK (R-TSP R))
        (TAG 'NAT
             (QUOTIENT (UNTAG (FETCH (R-TSP R)
                                     (R-SYS-DATA-SEGMENT R)))
                       2))
        (R-Y R)
        (BOOL (EQUAL (REMAINDER (UNTAG (FETCH (R-TSP R)
                                              (R-SYS-DATA-SEGMENT R)))
                                2)
                     1))
        (R-V-FLG R)
        (R-N-FLG R)
        (R-Z-FLG R)
        (R-PROG-SEGMENT R)
        (R-USR-DATA-SEGMENT R)
        (DEPOSIT (TAG 'NAT
                      (REMAINDER (UNTAG (FETCH (R-TSP R)
                                               (R-SYS-DATA-SEGMENT R)))
                                 2))
                 (PUSH-STK (R-TSP R))
                 (DEPOSIT (TAG 'NAT
                               (QUOTIENT (UNTAG (FETCH (R-TSP R)
                                                       (R-SYS-DATA-SEGMENT R)))
                                         2))
                          (R-TSP R)
                          (R-SYS-DATA-SEGMENT R)))
        (R-WORD-SIZE R)
        'RUN))

(DEFN R-DIV2-NAT-STEP-CLOCK (INS R) 5)

(DEFN R-OR-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-OR-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (OR-BITV (UNTAG (FETCH (POP-STK (R-TSP R))
                                                    (R-SYS-DATA-SEGMENT R)))
                                      (UNTAG (FETCH (R-TSP R)
                                                    (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-OR-BITV-STEP-CLOCK (INS R) 2)

(DEFN R-AND-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-AND-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (AND-BITV (UNTAG (FETCH (POP-STK (R-TSP R))
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-AND-BITV-STEP-CLOCK (INS R) 2)

(DEFN R-NOT-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-NOT-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (NOT-BITV (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-NOT-BITV-STEP-CLOCK (INS R) 1)

(DEFN R-XOR-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-XOR-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (XOR-BITV (UNTAG (FETCH (POP-STK (R-TSP R))
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-XOR-BITV-STEP-CLOCK (INS R) 2)

(DEFN R-RSH-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-RSH-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (RSH-BITV (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-RSH-BITV-STEP-CLOCK (INS R) 1)

(DEFN R-LSH-BITV-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BITV
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-LSH-BITV-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BITV
                             (LSH-BITV (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-LSH-BITV-STEP-CLOCK (INS R) 1)

(DEFN R-OR-BOOL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-OR-BOOL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BOOL
                             (OR-BOOL (UNTAG (FETCH (POP-STK (R-TSP R))
                                                    (R-SYS-DATA-SEGMENT R)))
                                      (UNTAG (FETCH (R-TSP R)
                                                    (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-OR-BOOL-STEP-CLOCK (INS R) 2)

(DEFN R-AND-BOOL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (NOT (EMPTY-STKP (POP-STK (R-TSP R))
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (POP-STK (R-TSP R))
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-AND-BOOL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (POP-STK (R-TSP R))
               (FETCH (R-TSP R)
                      (R-SYS-DATA-SEGMENT R))
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BOOL
                             (AND-BOOL (UNTAG (FETCH (POP-STK (R-TSP R))
                                                     (R-SYS-DATA-SEGMENT R)))
                                       (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (POP-STK (R-TSP R))
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-AND-BOOL-STEP-CLOCK (INS R) 2)

(DEFN R-NOT-BOOL-OKP
      (INS R)
      (AND (ADD1-R-PCP R)
           (NOT (EMPTY-STKP (R-TSP R)
                            (R-SYS-DATA-SEGMENT R)))
           (R-OBJECTP-TYPE 'BOOL
                           (FETCH (R-TSP R)
                                  (R-SYS-DATA-SEGMENT R))
                           R)))

(DEFN R-NOT-BOOL-STEP
      (INS R)
      (R-STATE (ADD1-R-PC R)
               (R-CFP R)
               (R-CSP R)
               (R-TSP R)
               (R-X R)
               (R-Y R)
               (R-C-FLG R)
               (R-V-FLG R)
               (R-N-FLG R)
               (R-Z-FLG R)
               (R-PROG-SEGMENT R)
               (R-USR-DATA-SEGMENT R)
               (DEPOSIT (TAG 'BOOL
                             (NOT-BOOL (UNTAG (FETCH (R-TSP R)
                                                     (R-SYS-DATA-SEGMENT R)))))
                        (R-TSP R)
                        (R-SYS-DATA-SEGMENT R))
               (R-WORD-SIZE R)
               'RUN))

(DEFN R-NOT-BOOL-STEP-CLOCK (INS R) 1)

(DEFN R-INS-OKP
      (INS R)
      (CASE (CAR INS)
            (CALL (R-CALL-OKP INS R))
            (RET (R-RET-OKP INS R))
            (LOCN (R-LOCN-OKP INS R))
            (PUSH-CONSTANT (R-PUSH-CONSTANT-OKP INS R))
            (PUSH-LOCAL (R-PUSH-LOCAL-OKP INS R))
            (PUSH-GLOBAL (R-PUSH-GLOBAL-OKP INS R))
            (PUSH-CTRL-STK-FREE-SIZE (R-PUSH-CTRL-STK-FREE-SIZE-OKP INS R))
            (PUSH-TEMP-STK-FREE-SIZE (R-PUSH-TEMP-STK-FREE-SIZE-OKP INS R))
            (PUSH-TEMP-STK-INDEX (R-PUSH-TEMP-STK-INDEX-OKP INS R))
            (JUMP-IF-TEMP-STK-FULL (R-JUMP-IF-TEMP-STK-FULL-OKP INS R))
            (JUMP-IF-TEMP-STK-EMPTY (R-JUMP-IF-TEMP-STK-EMPTY-OKP INS R))
            (POP (R-POP-OKP INS R))
            (POP* (R-POP*-OKP INS R))
            (POPN (R-POPN-OKP INS R))
            (POP-LOCAL (R-POP-LOCAL-OKP INS R))
            (POP-GLOBAL (R-POP-GLOBAL-OKP INS R))
            (POP-LOCN (R-POP-LOCN-OKP INS R))
            (POP-CALL (R-POP-CALL-OKP INS R))
            (FETCH-TEMP-STK (R-FETCH-TEMP-STK-OKP INS R))
            (DEPOSIT-TEMP-STK (R-DEPOSIT-TEMP-STK-OKP INS R))
            (JUMP (R-JUMP-OKP INS R))
            (JUMP-CASE (R-JUMP-CASE-OKP INS R))
            (PUSHJ (R-PUSHJ-OKP INS R))
            (POPJ (R-POPJ-OKP INS R))
            (SET-LOCAL (R-SET-LOCAL-OKP INS R))
            (SET-GLOBAL (R-SET-GLOBAL-OKP INS R))
            (TEST-NAT-AND-JUMP (R-TEST-NAT-AND-JUMP-OKP INS R))
            (TEST-INT-AND-JUMP (R-TEST-INT-AND-JUMP-OKP INS R))
            (TEST-BOOL-AND-JUMP (R-TEST-BOOL-AND-JUMP-OKP INS R))
            (TEST-BITV-AND-JUMP (R-TEST-BITV-AND-JUMP-OKP INS R))
            (NO-OP (R-NO-OP-OKP INS R))
            (ADD-ADDR (R-ADD-ADDR-OKP INS R))
            (SUB-ADDR (R-SUB-ADDR-OKP INS R))
            (EQ (R-EQ-OKP INS R))
            (LT-ADDR (R-LT-ADDR-OKP INS R))
            (FETCH (R-FETCH-OKP INS R))
            (DEPOSIT (R-DEPOSIT-OKP INS R))
            (ADD-INT (R-ADD-INT-OKP INS R))
            (ADD-INT-WITH-CARRY (R-ADD-INT-WITH-CARRY-OKP INS R))
            (ADD1-INT (R-ADD1-INT-OKP INS R))
            (SUB-INT (R-SUB-INT-OKP INS R))
            (SUB-INT-WITH-CARRY (R-SUB-INT-WITH-CARRY-OKP INS R))
            (SUB1-INT (R-SUB1-INT-OKP INS R))
            (NEG-INT (R-NEG-INT-OKP INS R))
            (LT-INT (R-LT-INT-OKP INS R))
            (INT-TO-NAT (R-INT-TO-NAT-OKP INS R))
            (ADD-NAT (R-ADD-NAT-OKP INS R))
            (ADD-NAT-WITH-CARRY (R-ADD-NAT-WITH-CARRY-OKP INS R))
            (ADD1-NAT (R-ADD1-NAT-OKP INS R))
            (SUB-NAT (R-SUB-NAT-OKP INS R))
            (SUB-NAT-WITH-CARRY (R-SUB-NAT-WITH-CARRY-OKP INS R))
            (SUB1-NAT (R-SUB1-NAT-OKP INS R))
            (LT-NAT (R-LT-NAT-OKP INS R))
            (MULT2-NAT (R-MULT2-NAT-OKP INS R))
            (MULT2-NAT-WITH-CARRY-OUT (R-MULT2-NAT-WITH-CARRY-OUT-OKP INS R))
            (DIV2-NAT (R-DIV2-NAT-OKP INS R))
            (OR-BITV (R-OR-BITV-OKP INS R))
            (AND-BITV (R-AND-BITV-OKP INS R))
            (NOT-BITV (R-NOT-BITV-OKP INS R))
            (XOR-BITV (R-XOR-BITV-OKP INS R))
            (RSH-BITV (R-RSH-BITV-OKP INS R))
            (LSH-BITV (R-LSH-BITV-OKP INS R))
            (OR-BOOL (R-OR-BOOL-OKP INS R))
            (AND-BOOL (R-AND-BOOL-OKP INS R))
            (NOT-BOOL (R-NOT-BOOL-OKP INS R))
            (OTHERWISE F)))

(DEFN R-INS-STEP
      (INS R)
      (CASE (CAR INS)
            (CALL (R-CALL-STEP INS R))
            (RET (R-RET-STEP INS R))
            (LOCN (R-LOCN-STEP INS R))
            (PUSH-CONSTANT (R-PUSH-CONSTANT-STEP INS R))
            (PUSH-LOCAL (R-PUSH-LOCAL-STEP INS R))
            (PUSH-GLOBAL (R-PUSH-GLOBAL-STEP INS R))
            (PUSH-CTRL-STK-FREE-SIZE (R-PUSH-CTRL-STK-FREE-SIZE-STEP INS R))
            (PUSH-TEMP-STK-FREE-SIZE (R-PUSH-TEMP-STK-FREE-SIZE-STEP INS R))
            (PUSH-TEMP-STK-INDEX (R-PUSH-TEMP-STK-INDEX-STEP INS R))
            (JUMP-IF-TEMP-STK-FULL (R-JUMP-IF-TEMP-STK-FULL-STEP INS R))
            (JUMP-IF-TEMP-STK-EMPTY (R-JUMP-IF-TEMP-STK-EMPTY-STEP INS R))
            (POP (R-POP-STEP INS R))
            (POP* (R-POP*-STEP INS R))
            (POPN (R-POPN-STEP INS R))
            (POP-LOCAL (R-POP-LOCAL-STEP INS R))
            (POP-GLOBAL (R-POP-GLOBAL-STEP INS R))
            (POP-LOCN (R-POP-LOCN-STEP INS R))
            (POP-CALL (R-POP-CALL-STEP INS R))
            (FETCH-TEMP-STK (R-FETCH-TEMP-STK-STEP INS R))
            (DEPOSIT-TEMP-STK (R-DEPOSIT-TEMP-STK-STEP INS R))
            (JUMP (R-JUMP-STEP INS R))
            (JUMP-CASE (R-JUMP-CASE-STEP INS R))
            (PUSHJ (R-PUSHJ-STEP INS R))
            (POPJ (R-POPJ-STEP INS R))
            (SET-LOCAL (R-SET-LOCAL-STEP INS R))
            (SET-GLOBAL (R-SET-GLOBAL-STEP INS R))
            (TEST-NAT-AND-JUMP (R-TEST-NAT-AND-JUMP-STEP INS R))
            (TEST-INT-AND-JUMP (R-TEST-INT-AND-JUMP-STEP INS R))
            (TEST-BOOL-AND-JUMP (R-TEST-BOOL-AND-JUMP-STEP INS R))
            (TEST-BITV-AND-JUMP (R-TEST-BITV-AND-JUMP-STEP INS R))
            (NO-OP (R-NO-OP-STEP INS R))
            (ADD-ADDR (R-ADD-ADDR-STEP INS R))
            (SUB-ADDR (R-SUB-ADDR-STEP INS R))
            (EQ (R-EQ-STEP INS R))
            (LT-ADDR (R-LT-ADDR-STEP INS R))
            (FETCH (R-FETCH-STEP INS R))
            (DEPOSIT (R-DEPOSIT-STEP INS R))
            (ADD-INT (R-ADD-INT-STEP INS R))
            (ADD-INT-WITH-CARRY (R-ADD-INT-WITH-CARRY-STEP INS R))
            (ADD1-INT (R-ADD1-INT-STEP INS R))
            (SUB-INT (R-SUB-INT-STEP INS R))
            (SUB-INT-WITH-CARRY (R-SUB-INT-WITH-CARRY-STEP INS R))
            (SUB1-INT (R-SUB1-INT-STEP INS R))
            (NEG-INT (R-NEG-INT-STEP INS R))
            (LT-INT (R-LT-INT-STEP INS R))
            (INT-TO-NAT (R-INT-TO-NAT-STEP INS R))
            (ADD-NAT (R-ADD-NAT-STEP INS R))
            (ADD-NAT-WITH-CARRY (R-ADD-NAT-WITH-CARRY-STEP INS R))
            (ADD1-NAT (R-ADD1-NAT-STEP INS R))
            (SUB-NAT (R-SUB-NAT-STEP INS R))
            (SUB-NAT-WITH-CARRY (R-SUB-NAT-WITH-CARRY-STEP INS R))
            (SUB1-NAT (R-SUB1-NAT-STEP INS R))
            (LT-NAT (R-LT-NAT-STEP INS R))
            (MULT2-NAT (R-MULT2-NAT-STEP INS R))
            (MULT2-NAT-WITH-CARRY-OUT (R-MULT2-NAT-WITH-CARRY-OUT-STEP INS R))
            (DIV2-NAT (R-DIV2-NAT-STEP INS R))
            (OR-BITV (R-OR-BITV-STEP INS R))
            (AND-BITV (R-AND-BITV-STEP INS R))
            (NOT-BITV (R-NOT-BITV-STEP INS R))
            (XOR-BITV (R-XOR-BITV-STEP INS R))
            (RSH-BITV (R-RSH-BITV-STEP INS R))
            (LSH-BITV (R-LSH-BITV-STEP INS R))
            (OR-BOOL (R-OR-BOOL-STEP INS R))
            (AND-BOOL (R-AND-BOOL-STEP INS R))
            (NOT-BOOL (R-NOT-BOOL-STEP INS R))
            (OTHERWISE (R-HALT R 'RUN))))

(DEFN R-STEP1
      (INS R)
      (IF (R-INS-OKP INS R)
          (R-INS-STEP INS R)
          (R-HALT R
                  (X-Y-ERROR-MSG 'R (CAR INS)))))

(DEFN R-STEP
      (R)
      (IF (EQUAL (R-PSW R) 'RUN)
          (R-STEP1 (R-CURRENT-INSTRUCTION R) R)
          R))

(DEFN R (R N)
  (IF (ZEROP N)
      R
      (R (R-STEP R) (SUB1 N))))

(DEFN R-INS-STEP-CLOCK
     (INS R)
     (CASE (CAR INS)
           (CALL (R-CALL-STEP-CLOCK INS R))
           (RET (R-RET-STEP-CLOCK INS R))
           (LOCN (R-LOCN-STEP-CLOCK INS R))
           (PUSH-CONSTANT (R-PUSH-CONSTANT-STEP-CLOCK INS R))
           (PUSH-LOCAL (R-PUSH-LOCAL-STEP-CLOCK INS R))
           (PUSH-GLOBAL (R-PUSH-GLOBAL-STEP-CLOCK INS R))
           (PUSH-CTRL-STK-FREE-SIZE (R-PUSH-CTRL-STK-FREE-SIZE-STEP-CLOCK INS
                                                                          R))
           (PUSH-TEMP-STK-FREE-SIZE (R-PUSH-TEMP-STK-FREE-SIZE-STEP-CLOCK INS
                                                                          R))
           (PUSH-TEMP-STK-INDEX (R-PUSH-TEMP-STK-INDEX-STEP-CLOCK INS R))
           (JUMP-IF-TEMP-STK-FULL (R-JUMP-IF-TEMP-STK-FULL-STEP-CLOCK INS R))
           (JUMP-IF-TEMP-STK-EMPTY (R-JUMP-IF-TEMP-STK-EMPTY-STEP-CLOCK INS R))
           (POP (R-POP-STEP-CLOCK INS R))
           (POP* (R-POP*-STEP-CLOCK INS R))
           (POPN (R-POPN-STEP-CLOCK INS R))
           (POP-LOCAL (R-POP-LOCAL-STEP-CLOCK INS R))
           (POP-GLOBAL (R-POP-GLOBAL-STEP-CLOCK INS R))
           (POP-LOCN (R-POP-LOCN-STEP-CLOCK INS R))
           (POP-CALL (R-POP-CALL-STEP-CLOCK INS R))
           (FETCH-TEMP-STK (R-FETCH-TEMP-STK-STEP-CLOCK INS R))
           (DEPOSIT-TEMP-STK (R-DEPOSIT-TEMP-STK-STEP-CLOCK INS R))
           (JUMP (R-JUMP-STEP-CLOCK INS R))
           (JUMP-CASE (R-JUMP-CASE-STEP-CLOCK INS R))
           (PUSHJ (R-PUSHJ-STEP-CLOCK INS R))
           (POPJ (R-POPJ-STEP-CLOCK INS R))
           (SET-LOCAL (R-SET-LOCAL-STEP-CLOCK INS R))
           (SET-GLOBAL (R-SET-GLOBAL-STEP-CLOCK INS R))
           (TEST-NAT-AND-JUMP (R-TEST-NAT-AND-JUMP-STEP-CLOCK INS R))
           (TEST-INT-AND-JUMP (R-TEST-INT-AND-JUMP-STEP-CLOCK INS R))
           (TEST-BOOL-AND-JUMP (R-TEST-BOOL-AND-JUMP-STEP-CLOCK INS R))
           (TEST-BITV-AND-JUMP (R-TEST-BITV-AND-JUMP-STEP-CLOCK INS R))
           (NO-OP (R-NO-OP-STEP-CLOCK INS R))
           (ADD-ADDR (R-ADD-ADDR-STEP-CLOCK INS R))
           (SUB-ADDR (R-SUB-ADDR-STEP-CLOCK INS R))
           (EQ (R-EQ-STEP-CLOCK INS R))
           (LT-ADDR (R-LT-ADDR-STEP-CLOCK INS R))
           (FETCH (R-FETCH-STEP-CLOCK INS R))
           (DEPOSIT (R-DEPOSIT-STEP-CLOCK INS R))
           (ADD-INT (R-ADD-INT-STEP-CLOCK INS R))
           (ADD-INT-WITH-CARRY (R-ADD-INT-WITH-CARRY-STEP-CLOCK INS R))
           (ADD1-INT (R-ADD1-INT-STEP-CLOCK INS R))
           (SUB-INT (R-SUB-INT-STEP-CLOCK INS R))
           (SUB-INT-WITH-CARRY (R-SUB-INT-WITH-CARRY-STEP-CLOCK INS R))
           (SUB1-INT (R-SUB1-INT-STEP-CLOCK INS R))
           (NEG-INT (R-NEG-INT-STEP-CLOCK INS R))
           (LT-INT (R-LT-INT-STEP-CLOCK INS R))
           (INT-TO-NAT (R-INT-TO-NAT-STEP-CLOCK INS R))
           (ADD-NAT (R-ADD-NAT-STEP-CLOCK INS R))
           (ADD-NAT-WITH-CARRY (R-ADD-NAT-WITH-CARRY-STEP-CLOCK INS R))
           (ADD1-NAT (R-ADD1-NAT-STEP-CLOCK INS R))
           (SUB-NAT (R-SUB-NAT-STEP-CLOCK INS R))
           (SUB-NAT-WITH-CARRY (R-SUB-NAT-WITH-CARRY-STEP-CLOCK INS R))
           (SUB1-NAT (R-SUB1-NAT-STEP-CLOCK INS R))
           (LT-NAT (R-LT-NAT-STEP-CLOCK INS R))
           (MULT2-NAT (R-MULT2-NAT-STEP-CLOCK INS R))
           (MULT2-NAT-WITH-CARRY-OUT (R-MULT2-NAT-WITH-CARRY-OUT-STEP-CLOCK INS
                                                                            R))
           (DIV2-NAT (R-DIV2-NAT-STEP-CLOCK INS R))
           (OR-BITV (R-OR-BITV-STEP-CLOCK INS R))
           (AND-BITV (R-AND-BITV-STEP-CLOCK INS R))
           (NOT-BITV (R-NOT-BITV-STEP-CLOCK INS R))
           (XOR-BITV (R-XOR-BITV-STEP-CLOCK INS R))
           (RSH-BITV (R-RSH-BITV-STEP-CLOCK INS R))
           (LSH-BITV (R-LSH-BITV-STEP-CLOCK INS R))
           (OR-BOOL (R-OR-BOOL-STEP-CLOCK INS R))
           (AND-BOOL (R-AND-BOOL-STEP-CLOCK INS R))
           (NOT-BOOL (R-NOT-BOOL-STEP-CLOCK INS R))
           (OTHERWISE 0)))

(DEFN R-STEP1-CLOCK
      (INS R)
      (IF (R-INS-OKP INS R)
          (R-INS-STEP-CLOCK INS R)
          0))

(DEFN R-STEP-CLOCK
      (R)
      (IF (EQUAL (R-PSW R) 'RUN)
          (R-STEP1-CLOCK (R-CURRENT-INSTRUCTION R)
                         R)
          0))

(DEFN CLOCK
      (R N)
      (IF (ZEROP N)
          0
          (PLUS (R-STEP-CLOCK R)
                (CLOCK (R-STEP R) (SUB1 N)))))

; Book: r-i.events.  In this section we prove that the r machine
; is correctly implemented on the i machine.

(disable unlabel)
(disable r-usr-data-typep)
(disable r-instructionp)
(disable i-usr-data-typep)

(prove-lemma r-instructionp-observation (rewrite)
  (implies (r-instructionp (unlabel ins))
           (not (equal (car (unlabel ins)) 'dcl)))
  ((enable r-instructionp)))

(prove-lemma r-push-constant-observation (rewrite)
    (implies (and (r-instructionp (unlabel ins))
                  (equal (car (unlabel ins))
                         'push-constant))
             (not (equal (caadr (unlabel ins)) 'dl)))
    ((enable r-instructionp)))

; This section is stolen from im.events.

(enable i-objectp-type-simplifier)
(disable i-objectp-type)

; I will disable type, tag and untag for sanity's sake,
; but prove the obvious relationships first.

(enable type-tag)

(enable untag-tag)

(disable type)
(disable tag)
(disable untag)

; And I will do a similar thing for the adp handlers

(enable adp-name-cons)
(enable adp-offset-cons)
(enable adp-name-add-adp)
(enable adp-offset-add-adp)
(enable adp-name-sub-adp)
(enable adp-offset-sub-adp)

(disable sub-adp)
(disable add-adp)
(disable adp-name)
(disable adp-offset)

; The function BOOLEANP is a killer because it
; causes everything to split.  I will disable it
; and prove what I need about it as necessary.

(disable booleanp)

(disable bool-to-logical)

; Some accellerators for psw handling...

(enable not-equal-x-y-error-msg-run)

(prove-lemma not-equal-x-y-error-msg-halt (rewrite)
  (not (equal (x-y-error-msg x y) 'halt)))

(disable x-y-error-msg)

(enable i-psw-i-halt)

(disable i-halt)

; Now I repeat the i-objectp-type exercise for r-objectp-type:

(prove-lemma r-objectp-type-simplifier (rewrite)
  (and (equal (r-objectp-type 'nat x r)
              (and (equal (type x) 'nat)
                   (equal (cddr x) nil)
                   (small-naturalp (untag x)
                                   (r-word-size r))))
       (equal (r-objectp-type 'int x r)
              (and (equal (type x) 'int)
                   (equal (cddr x) nil)
                   (small-integerp (untag x)
                                   (r-word-size r))))
       (equal (r-objectp-type 'bitv x r)
              (and (equal (type x) 'bitv)
                   (equal (cddr x) nil)
                   (bit-vectorp (untag x)
                                (r-word-size r))))
       (equal (r-objectp-type 'bool x r)
              (and (equal (type x) 'bool)
                   (equal (cddr x) nil)
                   (booleanp (untag x))))
       (equal (r-objectp-type 'addr x r)
              (and (equal (type x) 'addr)
                   (equal (cddr x) nil)
                   (adpp (untag x)
                         (r-usr-data-segment r))))
       (equal (r-objectp-type 'pc x r)
              (and (equal (type x) 'pc)
                   (equal (cddr x) nil)
                   (pcpp (untag x)
                         (r-prog-segment r))))
       (equal (r-objectp-type 'subr x r)
              (and (equal (type x) 'subr)
                   (equal (cddr x) nil)
                   (definedp (untag x)
                             (r-prog-segment r))))
       (equal (r-objectp-type 'sys-addr x r)
              (and (equal (type x) 'sys-addr)
                   (equal (cddr x) nil)
                   (adpp (untag x)
                         (r-sys-data-segment r))))))

(disable r-objectp-type)

; The notion of r-usr-data-objectp is important in the definition
; of proper r states.  It is defined as a conjunction of
; r-objectp and r-usr-data-typep.  We do not allow either of those
; to expand in our proofs, except under careful control because they
; case case splits.

(disable r-objectp)
(disable r-usr-data-typep)


; I disable icode1 and will enable it when it is needed.

(disable icode1)


; We now prove a lemma that is basically equivalent to

; (implies (proper-r-statep r load-addr) body-of-proper-r-statep)

; except that the body has been simplified so that it is
; in normal form.  The point is to permit me
; to keep proper-r-statep disabled but to allow each of
; its conjuncts to be proved by backchaining into the
; (proper-r-statep r load-addr) hypothesis that governs every main
; theorem.  I have also tossed in few other facts that
; follow from those conjuncts.

; The following embarrassing rule is needed to cause the
; rewriter to replace the (assoc & &) by the nearly
; explicit albeit larger list expression.

(prove-lemma equality-stuffer (rewrite)
  (implies (equal (assoc name alist) (list name (tag type obj)))
           (equal (cdr (assoc name alist))
                  (list (tag type obj)))))

(prove-lemma listp-assoc-implies-definedp (rewrite)
  (implies (listp (assoc name alist))
           (definedp name alist)))

(prove-lemma proper-r-statep-properties (rewrite)
  (implies (proper-r-statep r load-addr)
   (and

; r is an r-state:

    (r-statep r)

; the r-pc is an r-object of type pc

    (equal (type (r-pc r)) 'pc)
    (equal (cddr (r-pc r)) nil)
    (listp (untag (r-pc r)))
    (definedp (adp-name (untag (r-pc r)))
              (r-prog-segment r))
    (numberp (adp-offset (untag (r-pc r))))
    (lessp (adp-offset (untag (r-pc r)))
           (length (program-body (assoc (adp-name (untag (r-pc r)))
                                        (r-prog-segment r)))))

; r-cfp is a legal address into the cstk of the sys-data-segment

    (equal (type (r-cfp r)) 'sys-addr)
    (listp (untag (r-cfp r)))
    (equal (adp-name (untag (r-cfp r)))
           'cstk)
    (equal (cddr (r-cfp r)) nil)
    (adpp (untag (r-cfp r)) (r-sys-data-segment r))

    ; In addition, we observe that the adpp can be expanded
    ; to yield:

    (definedp 'cstk
              (r-sys-data-segment r))
    (numberp (adp-offset (untag (r-cfp r))))
    (lessp (adp-offset (untag (r-cfp r)))
           (length (cdr (assoc 'cstk
                               (r-sys-data-segment r)))))

    ; From which we can also conclude:

    (listp (cdr (assoc 'cstk
                       (r-sys-data-segment r))))

; r-csp is a legal address into the cstk of the sys-data-segment

    (equal (type (r-csp r)) 'sys-addr)
    (listp (untag (r-csp r)))
    (equal (adp-name (untag (r-csp r)))
           'cstk)
    (equal (cddr (r-csp r)) nil)
    (adpp (untag (r-csp r)) (r-sys-data-segment r))

    ; In addition, we observe that the adpp can be expanded
    ; to yield:

    (numberp (adp-offset (untag (r-csp r))))
    (lessp (adp-offset (untag (r-csp r)))
           (length (cdr (assoc 'cstk
                               (r-sys-data-segment r)))))

; r-tsp is a legal address into the tstk of the sys-data-segment

    (equal (type (r-tsp r)) 'sys-addr)
    (listp (untag (r-tsp r)))
    (equal (adp-name (untag (r-tsp r)))
           'tstk)
    (equal (cddr (r-tsp r)) nil)
    (adpp (untag (r-tsp r)) (r-sys-data-segment r))

    ; In addition, we observe that the adpp can be expanded
    ; to yield:

    (definedp 'tstk
              (r-sys-data-segment r))
    (numberp (adp-offset (untag (r-tsp r))))
    (lessp (adp-offset (untag (r-tsp r)))
           (length (cdr (assoc 'tstk
                               (r-sys-data-segment r)))))

    ; From which we can also conclude:

    (listp (cdr (assoc 'tstk
                       (r-sys-data-segment r))))

; The three constants full-ctrl-stk-addr, full-temp-stk-addr
; and empty-temp-stk-addr are present and defined appropriately.

     (equal (assoc 'full-ctrl-stk-addr (r-sys-data-segment r))
            '(full-ctrl-stk-addr (sys-addr (cstk . 0))))
     (equal (assoc 'full-temp-stk-addr (r-sys-data-segment r))
            '(full-temp-stk-addr (sys-addr (tstk . 0))))
     (equal (assoc 'empty-temp-stk-addr (r-sys-data-segment r))
            (list 'empty-temp-stk-addr
                  (tag 'sys-addr
                       (cons 'tstk
                             (sub1
                              (length
                               (cdr
                                (assoc
                                 'tstk
                                 (r-sys-data-segment r)))))))))     

    ; We also express this in terms of the concepts that will be useful
    ; later, namely adpp and fetch-adp.  Note:  These alone are not
    ; equivalent to the assoc expressions above because the assocs tell
    ; us these three areas are singletons and the fetch-adps below 
    ; don't.

    (adpp '(full-ctrl-stk-addr . 0)
          (r-sys-data-segment r))
    (adpp '(full-temp-stk-addr . 0)
          (r-sys-data-segment r))
    (adpp '(empty-temp-stk-addr . 0)
          (r-sys-data-segment r))

    (equal (fetch-adp '(full-ctrl-stk-addr . 0)
                      (r-sys-data-segment r))
           '(sys-addr (cstk . 0)))
    (equal (fetch-adp '(full-temp-stk-addr . 0)
                      (r-sys-data-segment r))
           '(sys-addr (tstk . 0)))
    (equal (fetch-adp '(empty-temp-stk-addr . 0)
                      (r-sys-data-segment r))
           (tag 'sys-addr
                (cons 'tstk
                      (sub1 (length
                             (cdr (assoc
                                   'tstk
                                   (r-sys-data-segment r))))))))

; The four flags are all r-objects of type bool

    (equal (type (r-c-flg r)) 'bool)
    (equal (cddr (r-c-flg r)) nil)
    (booleanp (untag (r-c-flg r)))
    (equal (type (r-v-flg r)) 'bool)
    (equal (cddr (r-v-flg r)) nil)
    (booleanp (untag (r-v-flg r)))
    (equal (type (r-n-flg r)) 'bool)
    (equal (cddr (r-n-flg r)) nil)
    (booleanp (untag (r-n-flg r)))
    (equal (type (r-z-flg r)) 'bool)
    (equal (cddr (r-z-flg r)) nil)
    (booleanp (untag (r-z-flg r)))

;   The program segment is syntactically legal r level piton:

    (r-prog-segmentp (r-prog-segment r))

;   The user-data segment is well-formed and contains only
;   user data objects.

    (proper-r-usr-data-segmentp (r-usr-data-segment r) r)

;   The system is loadable:

    (lessp (plus load-addr
                 (segment-length (icompile (r-prog-segment r)))
                 (segment-length (r-usr-data-segment r))
                 (segment-length (r-sys-data-segment r)))
           (exp 2 (r-word-size r))))))

(disable listp-assoc-implies-definedp)
(disable equality-stuffer)

; Having proved that, we will

(disable proper-r-statep)

; I now begin the study of find-label and pc mapping

(prove-lemma find-labelp-is-find-label (rewrite)
  (equal (find-labelp lab lst)
         (lessp (find-label lab lst) (length lst))))

(prove-lemma find-label-append (rewrite)
   (equal (find-label lab (append a b))
          (if (find-labelp lab a)
              (find-label lab a)
              (plus (length a)
                    (find-label lab b)))))

(enable difference-x-x)

(enable length-append)

; The following odd rule is needed because we sometimes treat
; a tagged object, e.g., the constant following a move_x_*,
; as an instruction and ask if it is labelled.

(prove-lemma car-tag (rewrite)
  (equal (car (tag type obj)) type)
  ((enable tag)))

(prove-lemma find-label-jump_*-lst (rewrite)
  (equal (find-label lab (jump_*-lst lst program))
         (length (jump_*-lst lst program))))

(prove-lemma find-label-if (rewrite)
  (equal (find-label lab (if a b c))
         (if a (find-label lab b) (find-label lab c))))

(prove-lemma length-if{jsm} (rewrite)
  (equal (length (if a b c))
         (if a (length b) (length c))))

; The icode1 fn is too big for the theorem prover's rewriter to
; explore on the standard akcl stack.   So I cut the function
; into two parts:

(defn icode12 (ins pcn prog)
      (case (car ins)
            (EQ (ICODE-EQ INS PCN PROG))
            (LT-ADDR (ICODE-LT-ADDR INS PCN PROG))
            (FETCH (ICODE-FETCH INS PCN PROG))
            (DEPOSIT (ICODE-DEPOSIT INS PCN PROG))
            (ADD-INT (ICODE-ADD-INT INS PCN PROG))
            (ADD-INT-WITH-CARRY (ICODE-ADD-INT-WITH-CARRY INS PCN PROG))
            (ADD1-INT (ICODE-ADD1-INT INS PCN PROG))
            (SUB-INT (ICODE-SUB-INT INS PCN PROG))
            (SUB-INT-WITH-CARRY (ICODE-SUB-INT-WITH-CARRY INS PCN PROG))
            (SUB1-INT (ICODE-SUB1-INT INS PCN PROG))
            (NEG-INT (ICODE-NEG-INT INS PCN PROG))
            (LT-INT (ICODE-LT-INT INS PCN PROG))
            (INT-TO-NAT (ICODE-INT-TO-NAT INS PCN PROG))
            (ADD-NAT (ICODE-ADD-NAT INS PCN PROG))
            (ADD-NAT-WITH-CARRY (ICODE-ADD-NAT-WITH-CARRY INS PCN PROG))
            (ADD1-NAT (ICODE-ADD1-NAT INS PCN PROG))
            (SUB-NAT (ICODE-SUB-NAT INS PCN PROG))
            (SUB-NAT-WITH-CARRY (ICODE-SUB-NAT-WITH-CARRY INS PCN PROG))
            (SUB1-NAT (ICODE-SUB1-NAT INS PCN PROG))
            (LT-NAT (ICODE-LT-NAT INS PCN PROG))
            (MULT2-NAT (ICODE-MULT2-NAT INS PCN PROG))
            (MULT2-NAT-WITH-CARRY-OUT (ICODE-MULT2-NAT-WITH-CARRY-OUT INS PCN
                                                                    PROG))
            (DIV2-NAT (ICODE-DIV2-NAT INS PCN PROG))
            (OR-BITV (ICODE-OR-BITV INS PCN PROG))
            (AND-BITV (ICODE-AND-BITV INS PCN PROG))
            (NOT-BITV (ICODE-NOT-BITV INS PCN PROG))
            (XOR-BITV (ICODE-XOR-BITV INS PCN PROG))
            (RSH-BITV (ICODE-RSH-BITV INS PCN PROG))
            (LSH-BITV (ICODE-LSH-BITV INS PCN PROG))
            (OR-BOOL (ICODE-OR-BOOL INS PCN PROG))
            (AND-BOOL (ICODE-AND-BOOL INS PCN PROG))
            (NOT-BOOL (ICODE-NOT-BOOL INS PCN PROG))
            (OTHERWISE '((ERROR)))))

(defn icode11 (ins pcn prog)
      (CASE (CAR INS)
            (CALL (ICODE-CALL INS PCN PROG))
            (RET (ICODE-RET INS PCN PROG))
            (LOCN (ICODE-LOCN INS PCN PROG))
            (PUSH-CONSTANT (ICODE-PUSH-CONSTANT INS PCN PROG))
            (PUSH-LOCAL (ICODE-PUSH-LOCAL INS PCN PROG))
            (PUSH-GLOBAL (ICODE-PUSH-GLOBAL INS PCN PROG))
            (PUSH-CTRL-STK-FREE-SIZE (ICODE-PUSH-CTRL-STK-FREE-SIZE INS PCN
                                                                  PROG))
            (PUSH-TEMP-STK-FREE-SIZE (ICODE-PUSH-TEMP-STK-FREE-SIZE INS PCN
                                                                  PROG))
            (PUSH-TEMP-STK-INDEX (ICODE-PUSH-TEMP-STK-INDEX INS PCN PROG))
            (JUMP-IF-TEMP-STK-FULL (ICODE-JUMP-IF-TEMP-STK-FULL INS PCN PROG))
            (JUMP-IF-TEMP-STK-EMPTY (ICODE-JUMP-IF-TEMP-STK-EMPTY INS PCN PROG))
            (POP (ICODE-POP INS PCN PROG))
            (POP* (ICODE-POP* INS PCN PROG))
            (POPN (ICODE-POPN INS PCN PROG))
            (POP-LOCAL (ICODE-POP-LOCAL INS PCN PROG))
            (POP-GLOBAL (ICODE-POP-GLOBAL INS PCN PROG))
            (POP-LOCN (ICODE-POP-LOCN INS PCN PROG))
            (POP-CALL (ICODE-POP-CALL INS PCN PROG))
            (FETCH-TEMP-STK (ICODE-FETCH-TEMP-STK INS PCN PROG))
            (DEPOSIT-TEMP-STK (ICODE-DEPOSIT-TEMP-STK INS PCN PROG))
            (JUMP (ICODE-JUMP INS PCN PROG))
            (JUMP-CASE (ICODE-JUMP-CASE INS PCN PROG))
            (PUSHJ (ICODE-PUSHJ INS PCN PROG))
            (POPJ (ICODE-POPJ INS PCN PROG))
            (SET-LOCAL (ICODE-SET-LOCAL INS PCN PROG))
            (SET-GLOBAL (ICODE-SET-GLOBAL INS PCN PROG))
            (TEST-NAT-AND-JUMP (ICODE-TEST-NAT-AND-JUMP INS PCN PROG))
            (TEST-INT-AND-JUMP (ICODE-TEST-INT-AND-JUMP INS PCN PROG))
            (TEST-BOOL-AND-JUMP (ICODE-TEST-BOOL-AND-JUMP INS PCN PROG))
            (TEST-BITV-AND-JUMP (ICODE-TEST-BITV-AND-JUMP INS PCN PROG))
            (NO-OP (ICODE-NO-OP INS PCN PROG))
            (ADD-ADDR (ICODE-ADD-ADDR INS PCN PROG))
            (SUB-ADDR (ICODE-SUB-ADDR INS PCN PROG))
            (otherwise (icode12 ins pcn prog))))

(prove-lemma icode1-is-icode11 (rewrite)
  (equal (icode1 ins pcn prog)
         (icode11 ins pcn prog))
  ((enable icode1)))

(disable icode11)
(disable icode12)

(prove-lemma find-label-icode12 (rewrite)
  (implies (r-instructionp (unlabel ins))
           (equal (find-label lab
                              (icode12 (unlabel ins) pcn program))
                  (length (icode12 (unlabel ins) pcn program))))
  ((enable icode12)))

(prove-lemma find-label-icode1 (rewrite)
  (implies (r-instructionp (unlabel ins))
           (equal (find-label lab
                              (icode1 (unlabel ins) pcn program))
                  (length (icode1 (unlabel ins) pcn program))))
  ((enable icode11)))

(disable icode1-is-icode11)

(prove-lemma find-label-failure-extends-to-cdr (rewrite)
  (implies (equal (find-label lab lst) (length lst))
           (equal (find-label lab (cdr lst)) (length (cdr lst)))))

(prove-lemma find-label-icode (rewrite)
  (implies (r-instructionp (unlabel ins))
           (equal (find-label lab
                              (icode ins pcn program))
                  (if (equal lab (cons (name program) pcn))
                      0
                      (length (icode ins pcn program))))))

(prove-lemma find-label-icompile-program-body-lemma1 (rewrite)
  (implies (and (listp lab)
                (equal (car lab) (car program))
                (equal (cdr lab) pcn))
           (equal (find-label lab (icompile-program-body body pcn program))
                  0)))

(enable equal-length-0)

(prove-lemma listp-first-n (rewrite)
  (equal (listp (first-n n x))
         (not (zerop n))))

(prove-lemma length-first-n (rewrite)
  (equal (length (first-n n x)) (fix n)))

(prove-lemma zerop-difference (rewrite)
  (equal (equal (difference x y) 0)
         (not (lessp y x))))

(prove-lemma car-first-n (rewrite)
  (equal (car (first-n n x))
         (if (zerop n) 0 (car x))))

(prove-lemma find-label-icompile-program-body-lemma2 nil
  (implies (lessp pcn n)
           (equal (first-n (difference (sub1 n) pcn) (cdr b))
                  (cdr (first-n (difference n pcn) b)))))

; The following hackish lemma is dangerous because it folds up
; difference.  I'll disable it as soon as it has done its bit.
; The term (cdr lab) could be replaced by n and the four hyps could
; be replaced by (lessp pcn n), but things are this way so it
; finds immediate use in the next proof.

(prove-lemma find-label-icompile-program-body-lemma3 (rewrite) ;will disable
  (implies (and (listp lab)
                (numberp (cdr lab))
                (numberp pcn)
                (not (lessp (cdr lab) pcn))
                (not (equal lab (cons (car lab) pcn))))
           (equal (first-n (difference (sub1 (cdr lab)) pcn) (cdr b))
                  (cdr (first-n (difference (cdr lab) pcn) b))))
  ((use (find-label-icompile-program-body-lemma2 (n (cdr lab))))))

; In the useful statement of the relationship below, lab is an pcpp,
; namely an untagged r-level pc.  But for the proof itself lab is
; a cons pair.  So we have to enable adp-name and adp-offset.

(prove-lemma find-label-icompile-program-body (rewrite)
 (implies (and (listp lab)
               (equal (adp-name lab) (name program))
               (numberp (adp-offset lab))
               (numberp pcn)
               (not (lessp (adp-offset lab) pcn))
               (not (lessp (plus pcn (length body)) (adp-offset lab)))
               (r-program-bodyp body))
          (equal (find-label lab
                             (icompile-program-body body pcn program))
                 (length (icompile-program-body
                          (first-n (difference (adp-offset lab) pcn) body)
                          pcn program))))
 ((enable adp-name adp-offset)
  (disable icode)))

(disable find-label-icompile-program-body-lemma3)

(prove-lemma assoc-of-append (rewrite)
 (equal (append (append a b) c)
        (append a (append b c))))

; !!! Here we enable plus-add1 (which is a conjunct that hits an add1
; in either side of a plus) to replace a lemma that hit (plus x (add1 y))
; only.

(enable plus-add1)

(prove-lemma icompile-program-body-append (rewrite)
  (implies (numberp pcn)
           (equal (icompile-program-body (append body1 body2) pcn program)
                  (append (icompile-program-body body1
                                                 pcn
                                                 program)
                          (icompile-program-body body2
                                                 (plus (length body1) pcn)
                                                 program)))))
; !!! Plus-0 is more powerful than the rule we're replacing,
; (plus x 0) = (fix x).

(enable plus-0)

(prove-lemma plus-difference (rewrite)
  (equal (plus (difference x y) y) (if (lessp x y) (fix y) (fix x))))

; The next two lemmas are of questionable value in indiscriminant
; use so they will be disabled as soon as they've been used where needed.

(prove-lemma difference-add1 (rewrite)      ;will be disabled
  (implies (not (lessp x y))
           (equal (difference (add1 x) y)
                  (add1 (difference x y)))))

(prove-lemma open-first-n-at-high-end (rewrite)  ;will be disabled
  (equal (first-n (add1 n) x)
         (append (first-n n x) (list (get n x)))))


(prove-lemma find-label-add-adp-1-icompile-program-body (rewrite)
  (implies (and (listp r-pc)
                (equal (name program) (adp-name r-pc))
                (numberp (adp-offset r-pc))
                (numberp pcn)
                (not (lessp (adp-offset r-pc) pcn))
                (lessp (adp-offset r-pc) (plus pcn (length body)))
                (r-program-bodyp body))
           (equal (find-label (add-adp r-pc 1)
                              (icompile-program-body body pcn program))
                  (plus (find-label r-pc
                                    (icompile-program-body body pcn program))
                        (length (icode (get (difference (adp-offset r-pc) pcn)
                                          body)
                                     (adp-offset r-pc)
                                     program)))))
  ((enable adp-name adp-offset add-adp)
   (disable difference)))

(disable difference-add1)
(disable open-first-n-at-high-end)

; We are next headed for the result that no labels occur in the prelude
; (at least, no labels of the form (cons name n) where n is numeric).

; However, we will first

(disable name)
(disable formal-vars)
(disable temp-var-dcls)
(disable program-body)

; This probably could be done much earlier.

(enable length-rev)
(enable associativity-of-plus)

(prove-lemma find-label-generate-prelude1 (rewrite)
  (implies (r-temp-var-dclsp var-dcls)
           (equal 
            (find-label lab
                        (generate-prelude1 var-dcls))
            (length (generate-prelude1 var-dcls)))))

(prove-lemma not-find-label-generate-prelude2 (rewrite)
             (equal (find-label lab
                                (generate-prelude2 formal-vars))
                    (length (generate-prelude2 formal-vars))))

(prove-lemma r-temp-var-dclsp-append (rewrite)
  (equal (r-temp-var-dclsp (append var-dcls1 var-dcls2))
         (and (r-temp-var-dclsp var-dcls1)
              (r-temp-var-dclsp var-dcls2))))



(prove-lemma r-temp-var-dclsp-rev (rewrite)
  (equal (r-temp-var-dclsp (rev var-dcls))
         (r-temp-var-dclsp var-dcls)))

; The following is necessary because generate-prelude was defined
; with REVERSE (which is REV1) rather than with REV.

(prove-lemma reverse-is-rev (rewrite)
  (equal (reverse x) (rev x))
  ((enable rev1-is-rev)))

(disable reverse)

(prove-lemma find-label-generate-prelude (rewrite)
  (implies (and (r-temp-var-dclsp (temp-var-dcls prog))
                (numberp (adp-offset lab)))
           (equal (find-label lab
                              (generate-prelude prog))
                  (length (generate-prelude prog))))
  ((disable temp-var-dcls)))

(disable generate-prelude)
(disable generate-postlude)

; Now we begin the study of labels in the icompiled body

(prove-lemma member-assoc (rewrite)
  (implies (definedp x a)
           (member (assoc x a) a)))

(prove-lemma difference-x-0 (rewrite)
  (equal (difference x 0) (fix x)))

(enable car-assoc)

(enable length-cons)

(prove-lemma listp-if (rewrite)
  (equal (listp (if a b c))
         (if a (listp b) (listp c))))

; Note that the following lemma is stored as a type-prescription and
; hence the dependency of subsequent facts on this may not be apparent.

(prove-lemma listp-icode12 (rewrite)
  (listp (icode12 ins pcn prog))
  ((enable icode12)))

(prove-lemma listp-icode1 (rewrite)
  (listp (icode1 ins pcn prog))
  ((enable icode1-is-icode11 icode11)))

(prove-lemma listp-icompile-program-body (rewrite)
  (equal (listp (icompile-program-body body pcn prog))
         (listp body)))

(defn induct-hint1 (n body pcn)
  (if (zerop n)
      t
      (if (nlistp body)
          t
          (induct-hint1 (sub1 n) (cdr body) (add1 pcn)))))

(prove-lemma weak-monotonicity-of-icompile-program-body (rewrite)
 (implies (and (lessp n (length body))
               (numberp pcn))
          (not (lessp (length (icompile-program-body body
                                                     pcn
                                                     prog))
                      (plus
                       (length (icompile-program-body (first-n n body)
                                                      pcn
                                                      prog))
                       (length (icode (get n body)
                                    (plus n pcn)
                                    prog))))))
 ((induct (induct-hint1 n body pcn))))

; The next major goal is R->I_PC-TAG-ADD-ADP-1, which has the hypothesis
; that R is a proper-r-statep.  We need to be able to recover various
; things from that.  We get those lemmas now.  The trick to the lemmas
; below is that we don't want free vars in them.  So I prove the
; interesting fact as a lemma of class nil and then instantiate
; it to components of the proper-r-statep r.  In the "instantiated"
; version I also backchain through the proper-r-statep-observations
; to get the single hypothesis (proper-r-statep r load-addr).

(prove-lemma r-program-bodyp-program-body-lemma nil
  (implies (and (r-prog-segmentp prog-segment)
                (member prog prog-segment))
           (r-program-bodyp (program-body prog))))

(prove-lemma r-program-bodyp-program-body (rewrite)
  (implies (proper-r-statep r load-addr)
           (r-program-bodyp
            (program-body
             (assoc (adp-name (untag (r-pc r)))
                    (r-prog-segment r)))))
  ((use (r-program-bodyp-program-body-lemma
         (prog-segment (r-prog-segment r))
         (prog (assoc (adp-name (untag (r-pc r)))
                      (r-prog-segment r)))))))

(prove-lemma r-temp-var-dclsp-temp-var-dcls-lemma nil
  (implies (and (r-prog-segmentp prog-segment)
                (member prog prog-segment))
           (r-temp-var-dclsp (temp-var-dcls prog))))

(prove-lemma r-temp-var-dclsp-temp-var-dcls (rewrite)
  (implies (proper-r-statep r load-addr)
           (r-temp-var-dclsp 
            (temp-var-dcls
             (assoc (adp-name (untag (r-pc r)))
                    (r-prog-segment r)))))
  ((use (r-temp-var-dclsp-temp-var-dcls-lemma
         (prog-segment (r-prog-segment r))
         (prog (assoc (adp-name (untag (r-pc r)))
                      (r-prog-segment r)))))))

; Now we begin our attack directly on the lemma that says
; you can map down an incremented r-pc by mapping down the
; the r-pc and then incrementing by the length of icode.

(prove-lemma equal-tag (rewrite)
  (equal (equal (tag t1 obj1)
                (tag t2 obj2))
         (and (equal t1 t2)
              (equal obj1 obj2)))
  ((enable tag)))

(prove-lemma add-adp-cons (rewrite)
  (equal (add-adp (cons name n) m)
         (cons name (plus n m)))
  ((enable add-adp)))

(prove-lemma name-assoc (rewrite)
  (implies (definedp name alist)
           (equal (name (assoc name alist))
                  name))
  ((enable name)))

(prove-lemma find-label-generate-postlude (rewrite)
  (equal (find-label lab (generate-postlude prog))
         (if (equal lab (cons (name prog) (length (program-body prog))))
             0
             (length (generate-postlude prog))))
  ((enable generate-postlude)))

(prove-lemma equal-add-adp-cons-adp-name (rewrite)
  (equal (equal (add-adp x n) (cons (adp-name x) y))
         (equal (plus (adp-offset x) n) y))
  ((enable add-adp adp-name adp-offset)))

(prove-lemma weak-monotonicity-of-icompile-program-body-0 (rewrite)
 (implies (and (lessp n (length body))
               (numberp n))
          (not (lessp (length (icompile-program-body body
                                                     0
                                                     prog))
                      (plus
                       (length (icompile-program-body (first-n n body)
                                                      0
                                                      prog))
                       (length (icode (get n body)
                                    n
                                    prog))))))
 ((use (weak-monotonicity-of-icompile-program-body (pcn 0)))))

(prove-lemma leq-means-lessp-is-not-equal (rewrite)
  (implies (and (not (lessp b (plus a i)))
                (numberp b))
           (equal (lessp (plus a i) b)
                  (not (equal (plus a i) b)))))

(prove-lemma equal-plus-cancellation1 (rewrite)
  (equal (equal x (plus x y))
         (and (numberp x)
              (zerop y))))
                  
(prove-lemma last-instruction (rewrite)
  (implies (and (lessp n (length body))
                (numberp n)
                (numberp pcn))
           (equal
            (equal (plus (length (icompile-program-body (first-n n body)
                                                        pcn
                                                        prog))
                         (length (icode (get n body) (plus n pcn) prog)))
                   (length (icompile-program-body body pcn prog)))
            (equal n (sub1 (length body)))))
  ((induct (induct-hint1 n body pcn))
   (disable icode)))

(prove-lemma last-instruction-0 (rewrite)
  (implies (and (lessp n (length body))
                (numberp n))
           (equal
            (equal (plus (length (icompile-program-body (first-n n body)
                                                        0
                                                        prog))
                         (length (icode (get n body) n prog)))
                   (length (icompile-program-body body 0 prog)))
            (equal n (sub1 (length body)))))
  ((use (last-instruction (pcn 0)))
   (disable icode)))

(prove-lemma equal-plus-cancellation2 (rewrite)
  (equal (equal (plus x y) (plus x z))
         (equal (fix y) (fix z))))

(prove-lemma r->i_pc-tag-add-adp-1-lemma1 (rewrite)
  (implies (and (equal (add1 n) (length body))
                (numberp n)
                (numberp pcn))
           (equal (equal (length (icompile-program-body body
                                                        pcn
                                                        prog))
                         (plus (length (icompile-program-body (first-n n body)
                                                        pcn
                                                        prog))
                               (length (icode (get n body)
                                            (plus n pcn)
                                            prog))))
                  t))
  ((induct (induct-hint1 n body pcn))))

(prove-lemma r->i_pc-tag-add-adp-1-lemma1-0 (rewrite)
  (implies (and (equal (add1 n) (length body))
                (numberp n))
           (equal (equal (length (icompile-program-body body
                                                        0
                                                        prog))
                         (plus (length (icompile-program-body (first-n n body)
                                                        0
                                                        prog))
                               (length (icode (get n body)
                                            n
                                            prog))))
                  t))
  ((use (r->i_pc-tag-add-adp-1-lemma1 (pcn 0)))))

(prove-lemma r->i_pc-tag-add-adp-1-lemma2 (rewrite)
  (implies (and (numberp n)
                (numberp pcn))
           (equal (equal (length (icompile-program-body body
                                                        pcn
                                                        prog))
                         (length (icompile-program-body (first-n n body)
                                                        pcn
                                                        prog)))
                  (equal n (length body))))
  ((induct (induct-hint1 n body pcn))))

(prove-lemma r->i_pc-tag-add-adp-1 (rewrite)
 (implies
       (proper-r-statep r load-addr)
       (equal (r->i_pc (tag 'pc (add-adp (untag (r-pc r)) 1))
                       (r-prog-segment r))
              (add-addr (r->i_pc (r-pc r) (r-prog-segment r))
                        (length (icode (get (offset (r-pc r))
                                          (program-body (r-current-program r)))
                                     (offset (r-pc r))
                                     (definition (adp-name (untag (r-pc r)))
                                                 (r-prog-segment r)))))))
 ((disable icode difference)))

(prove-lemma assoc-icompile (rewrite)
  (implies (definedp name progs)
           (equal (assoc name (icompile progs))
                  (icompile-program (definition name progs))))
  ((enable name)))

(prove-lemma get-car-cdr-n (rewrite)
  (equal (get n x)
         (car (cdr-n n x))))

(prove-lemma cdr-n-plus (rewrite)
  (equal (cdr-n (plus m n) x)
         (cdr-n n (cdr-n m x))))

(prove-lemma cdr-n-append (rewrite)
  (implies (not (lessp (length a) n))
           (equal (cdr-n n (append a b))
                  (append (cdr-n n a) b))))

(prove-lemma listp-cdr-n (rewrite)
  (equal (listp (cdr-n n x))
         (lessp n (length x))))


(prove-lemma not-lessp-length-find-label (rewrite)
  (not (lessp (length x) (find-label lab x))))


; I used to prove this but I'm not sure I'll use it so it has been skipped
;(prove-lemma first-n-cdr-n (rewrite)
;  (implies (lessp n (length x))
;          (equal (append (first-n n x) (cdr-n n x)) x)))


(prove-lemma car-append (rewrite)
  (implies (listp a)
           (equal (car (append a b)) (car a))))

; here is my new version of what is shown below...

(prove-lemma cdr-n-length-icompile-program-body-first-n (rewrite)
  (implies (and (not (lessp (length body) n))
                (numberp n)
                (numberp pcn))
           (equal (cdr-n (length (icompile-program-body (first-n n body)
                                                        pcn
                                                        prog))
                         (icompile-program-body body pcn prog))
                  (icompile-program-body (cdr-n n body)
                                         (plus n pcn)
                                         prog)))
  ((induct (induct-hint1 n body pcn))))



(prove-lemma icompile-program-body-cdr-n-expander (rewrite)
  (implies (proper-r-statep r load-addr)
           (equal (ICOMPILE-PROGRAM-BODY
                   (CDR-N (ADP-OFFSET (UNTAG (R-PC R)))
                          (PROGRAM-BODY (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                                               (R-PROG-SEGMENT R))))
                   (ADP-OFFSET (UNTAG (R-PC R)))
                   (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                          (R-PROG-SEGMENT R)))
                  (append (ICODE (CAR (CDR-N (ADP-OFFSET (UNTAG (R-PC R)))
                                           (PROGRAM-BODY
                                            (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                                                   (R-PROG-SEGMENT R)))))
                               (ADP-OFFSET (UNTAG (R-PC R)))
                               (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                                      (R-PROG-SEGMENT R)))
                          (ICOMPILE-PROGRAM-BODY
                           (cdr (CDR-N (ADP-OFFSET (UNTAG (R-PC R)))
                                       (PROGRAM-BODY
                                        (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                                               (R-PROG-SEGMENT R)))))
                           (add1 (ADP-OFFSET (UNTAG (R-PC R))))
                           (ASSOC (ADP-NAME (UNTAG (R-PC R)))
                                  (R-PROG-SEGMENT R))))))
  ((disable icode)))

(prove-lemma fetch-adp-add-adp-untag-r->i (rewrite)
 (implies
  (and (proper-r-statep r load-addr)
       (lessp n
              (length (icode (get (offset (r-pc r))
                                (program-body
                                 (definition (adp-name (untag (r-pc r)))
                                             (r-prog-segment r))))
                           (offset (r-pc r))
                           (definition (adp-name (untag (r-pc r)))
                                       (r-prog-segment r))))))
  (equal (fetch-adp (add-adp (untag (r->i_pc (r-pc r)
                                             (r-prog-segment r)))
                             n)
                    (icompile (r-prog-segment r)))
         (get n
              (icode (get (offset (r-pc r))
                        (program-body (definition (area-name (r-pc r))
                                                  (r-prog-segment r))))
                   (offset (r-pc r))
                   (definition (area-name (r-pc r))
                               (r-prog-segment r))))))
 ((disable icode)))

; This is really a crucial result because it tells us how to get the i-level
; instruction corresponding to a given r level one.  In the future I prefer
; to see get rather than cdr-n, so now that cdr-n has done its job I'm going
; to disable to rewrite rule that introduces it.

(disable get-car-cdr-n)

; In order for the above lemma to be used, R->I_PC must be disabled.
; We need the following about it:

(prove-lemma adp-name-untag-r->i_pc (rewrite)
  (equal (adp-name (untag (r->i_pc (r-pc r)
                                   (r-prog-segment r))))
         (adp-name (untag (r-pc r)))))
 
(disable r->i_pc)





(prove-lemma definedp-icompile (rewrite)
  (equal (definedp name (icompile list))
         (definedp name list))
  ((enable name)))


(prove-lemma length-generate-prelude1 (rewrite)
  (equal (length (generate-prelude1 temp-var-dcls))
         (times (length temp-var-dcls) 2)))

(prove-lemma length-generate-prelude2 (rewrite)
  (equal (length (generate-prelude2 formal-vars))
         (length formal-vars)))

(prove-lemma length-generate-prelude (rewrite)
             (equal (length (generate-prelude program))
                    (plus 2
                          (times (length (temp-var-dcls program)) 2)
                          (length (formal-vars program))))
             ((enable generate-prelude)))

(prove-lemma length-generate-postlude (rewrite)
  (equal (length (generate-postlude prog)) 3)
  ((enable generate-postlude)))

(prove-lemma find-label-cdr-icompile-program (rewrite)
  (implies (and (lessp (add1 (adp-offset lab))
                       (length (program-body prog)))
                (r-temp-var-dclsp (temp-var-dcls prog))
                (numberp (adp-offset lab))
                (r-program-bodyp (program-body prog))
                (equal (adp-name lab) (name prog))
                (listp lab))
           (lessp (add1 (find-label lab
                                    (cdr (icompile-program prog))))
                  (length (cdr (icompile-program prog))))))

(disable length-generate-prelude)

(prove-lemma addp-add-adp-untag-r->i_pc (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (not (lessp (length (icode (get (offset (r-pc r))
                                              (program-body
                                               (definition
                                                 (adp-name (untag (r-pc r)))
                                                 (r-prog-segment r))))
                                         (offset (r-pc r))
                                         (definition
                                           (adp-name (untag (r-pc r)))
                                           (r-prog-segment r))))
                            n)))
           (adpp (add-adp (untag (r->i_pc (r-pc r)
                                          (r-prog-segment r)))
                          n)
                 (icompile (r-prog-segment r))))
  ((enable r->i_pc add-adp)
   (disable icode)))

; The following disable is necessary because adpp is used in the concl above.
; This could have been done earlier, when we disabled the other adp fns.
; If it is moved, however, we must remember to enable it for the proof above.


(disable adpp)

; The following lemma establishes that every label of the form
; (cons name n) where name is less than the length of the program
; occurs in the icompiled program.  It follows from our
; FIND-LABEL-ICOMPILE-PROGRAM-BODY but we wish to have that
; rewrite rule disabled so as not to rewrite FIND-LABEL
; expressions in the future.

(prove-lemma lessp-find-label-icompile-program (rewrite)
 (implies (and (listp lab)
               (equal (adp-name lab) (name program))
               (numberp (adp-offset lab))
               (not (lessp (length (program-body program))
                           (adp-offset lab)))
               (r-programp program))
          (lessp (find-label lab
                             (cdr (icompile-program program)))
                 (length (cdr (icompile-program program)))))
 ((use (find-label-icompile-program-body
        (body (program-body program))
        (pcn 0)))
  (enable adp-name adp-offset)
  (disable find-label-icompile-program-body)))
        
; To relieve the hypothesis about r-programp we will need:

(prove-lemma r-prog-segmentp-contains-r-programp nil
  (implies (and (r-prog-segmentp segment)
                (member prog segment))
           (r-programp prog)))

(prove-lemma proper-r-statep-implies-r-programp (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r)))
           (r-programp (assoc name (r-prog-segment r))))
  ((use (r-prog-segmentp-contains-r-programp
         (segment (r-prog-segment r))
         (prog (assoc name (r-prog-segment r)))))))

(disable r-programp)

; At this point I think we have completely dealt with all issues concerning
; FIND-LABEL and we will disable the lemmas surrounding it.

(disable find-label-generate-postlude)
(disable find-label-generate-prelude)
(disable not-find-label-generate-prelude2)
(disable find-label-generate-prelude1)
(disable find-label-add-adp-1-icompile-program-body)
(disable find-label-icompile-program-body)
(disable find-label-icompile-program-body-lemma1)
(disable find-label-icode)
(disable find-label-failure-extends-to-cdr)
(disable find-label-icode1)
(disable find-label-jump_*-lst)
(disable find-label-append)

; We have also exhausted our patience with icompile-program and will
; shut it down.

(prove-lemma name-cons (rewrite)
             (equal (name (cons x y)) x)
             ((enable name)))

(prove-lemma name-icompile-program (rewrite)
  (equal (name (icompile-program program)) (name program)))


(disable icompile-program)



; Now in order for these lemmas mentioning (icode (get & &) ...) to be used
; we have to force icode to expand when we know what the instr opcode is.
; That is what the following theorems do:

(prove-lemma icode-opener (rewrite)
 (implies
  (equal (car (unlabel ins)) (pack xxx))
  (equal
   (icode ins pcn prog)
   (dl-block
    (cons (name prog) pcn)
    ins
    (case (car (unlabel ins))
          (call (icode-call (unlabel ins) pcn prog))
          (ret (icode-ret (unlabel ins) pcn prog))
          (locn (icode-locn (unlabel ins) pcn prog))
          (push-constant (icode-push-constant (unlabel ins)
                                            pcn prog))
          (push-local (icode-push-local (unlabel ins)
                                      pcn prog))
          (push-global (icode-push-global (unlabel ins)
                                        pcn prog))
          (push-ctrl-stk-free-size (icode-push-ctrl-stk-free-size (unlabel ins)
                                                                pcn prog))
          (push-temp-stk-free-size (icode-push-temp-stk-free-size (unlabel ins)
                                                                pcn prog))
          (push-temp-stk-index (icode-push-temp-stk-index (unlabel ins)
                                                        pcn prog))
          (jump-if-temp-stk-full (icode-jump-if-temp-stk-full (unlabel ins)
                                                            pcn prog))
          (jump-if-temp-stk-empty (icode-jump-if-temp-stk-empty (unlabel ins)
                                                              pcn prog))
          (pop (icode-pop (unlabel ins) pcn prog))
          (pop* (icode-pop* (unlabel ins)
                          pcn prog))
          (popn (icode-popn (unlabel ins)
                          pcn prog))
          (pop-local (icode-pop-local (unlabel ins)
                                    pcn prog))
          (pop-global (icode-pop-global (unlabel ins)
                                      pcn prog))
          (pop-locn (icode-pop-locn (unlabel ins) pcn prog))
          (pop-call (icode-pop-call (unlabel ins) pcn prog))
          (fetch-temp-stk (icode-fetch-temp-stk (unlabel ins) pcn prog))
          (deposit-temp-stk (icode-deposit-temp-stk (unlabel ins) pcn prog))
          (jump (icode-jump (unlabel ins) pcn prog))
          (jump-case (icode-jump-case (unlabel ins)
                                    pcn prog))
          (pushj (icode-pushj (unlabel ins) pcn prog))
          (popj (icode-popj (unlabel ins) pcn prog))
          (set-local (icode-set-local (unlabel ins)
                                    pcn prog))
          (set-global (icode-set-global (unlabel ins)
                                      pcn prog))
          (test-nat-and-jump (icode-test-nat-and-jump (unlabel ins)
                                                    pcn prog))
          (test-int-and-jump (icode-test-int-and-jump (unlabel ins)
                                                    pcn prog))
          (test-bool-and-jump (icode-test-bool-and-jump (unlabel ins)
                                                      pcn prog))
          (test-bitv-and-jump (icode-test-bitv-and-jump (unlabel ins)
                                                      pcn prog))
          (no-op (icode-no-op (unlabel ins) pcn prog))
          (add-addr (icode-add-addr (unlabel ins) pcn prog))
          (sub-addr (icode-sub-addr (unlabel ins) pcn prog))
          (eq (icode-eq (unlabel ins) pcn prog))
          (lt-addr (icode-lt-addr (unlabel ins) pcn prog))
          (fetch (icode-fetch (unlabel ins) pcn prog))
          (deposit (icode-deposit (unlabel ins) pcn prog))
          (add-int (icode-add-int (unlabel ins) pcn prog))
          (add-int-with-carry (icode-add-int-with-carry (unlabel ins)
                                                      pcn prog))
          (add1-int (icode-add1-int (unlabel ins) pcn prog))
          (sub-int (icode-sub-int (unlabel ins) pcn prog))
          (sub-int-with-carry (icode-sub-int-with-carry (unlabel ins)
                                                      pcn prog))
          (sub1-int (icode-sub1-int (unlabel ins) pcn prog))
          (neg-int (icode-neg-int (unlabel ins) pcn prog))
          (lt-int (icode-lt-int (unlabel ins) pcn prog))
          (int-to-nat (icode-int-to-nat (unlabel ins) pcn prog))
          (add-nat (icode-add-nat (unlabel ins) pcn prog))
          (add-nat-with-carry (icode-add-nat-with-carry (unlabel ins)
                                                      pcn prog))
          (add1-nat (icode-add1-nat (unlabel ins) pcn prog))
          (sub-nat (icode-sub-nat (unlabel ins) pcn prog))
          (sub-nat-with-carry (icode-sub-nat-with-carry (unlabel ins)
                                                      pcn prog))
          (sub1-nat (icode-sub1-nat (unlabel ins) pcn prog))
          (lt-nat (icode-lt-nat (unlabel ins) pcn prog))
          (mult2-nat (icode-mult2-nat (unlabel ins)
                                    pcn prog))
          (mult2-nat-with-carry-out (icode-mult2-nat-with-carry-out (unlabel ins)
                                                                  pcn prog))
          (div2-nat (icode-div2-nat (unlabel ins) pcn prog))
          (or-bitv (icode-or-bitv (unlabel ins) pcn prog))
          (and-bitv (icode-and-bitv (unlabel ins) pcn prog))
          (not-bitv (icode-not-bitv (unlabel ins) pcn prog))
          (xor-bitv (icode-xor-bitv (unlabel ins) pcn prog))
          (rsh-bitv (icode-rsh-bitv (unlabel ins) pcn prog))
          (lsh-bitv (icode-lsh-bitv (unlabel ins) pcn prog))
          (or-bool (icode-or-bool (unlabel ins) pcn prog))
          (and-bool (icode-and-bool (unlabel ins) pcn prog))
          (not-bool (icode-not-bool (unlabel ins) pcn prog))
          (otherwise '((error)))))))
 ((enable icode1)))


(disable icode)

(prove-lemma fetch-adp-add-adp-untag-r->i-0 (rewrite)
 (implies (proper-r-statep r load-addr)
  (equal (fetch-adp (untag (r->i_pc (r-pc r) (r-prog-segment r)))
                    (icompile (r-prog-segment r)))
         (car (icode (get (offset (r-pc r))
                        (program-body (definition (area-name (r-pc r))
                                        (r-prog-segment r))))
                   (offset (r-pc r))
                   (definition (area-name (r-pc r))
                     (r-prog-segment r))))))
 ((use (fetch-adp-add-adp-untag-r->i (n 0)))
  (disable fetch-adp-add-adp-untag-r->i)))

; I also want to disable deposit-adp.  But I need to prove the
; fundamental relationships between fetch and deposit first.

(prove-lemma assoc-put-assoc{gen} (rewrite)
             (equal
              (assoc u1
                     (put-assoc val
                                u2
                                segment))
              (if (equal u1 u2)
                  (if (definedp u1 segment)
                      (cons u1 val)
                    f)
                (assoc u1 segment))))

(prove-lemma get-nlistp (rewrite)
  (implies (nlistp x) (equal (get n x) 0)))

(prove-lemma get-put (rewrite)
  (implies (and (numberp n)
                (numberp k))
           (equal (get n (put val k lst))
                  (if (equal n k)
                      val
                      (get n lst)))))

(prove-lemma put-assoc-put-assoc (rewrite)
  (equal (put-assoc val1 name (put-assoc val2 name alist))
         (put-assoc val1 name alist)))

(prove-lemma put-put (rewrite)
  (equal (put val1 n (put val2 n lst))
         (put val1 n lst)))

(prove-lemma adpp-put-assoc (rewrite)
  (implies (equal (length val) (length (definiens name alist)))
           (equal (adpp x (put-assoc val name alist))
                  (adpp x alist)))
  ((enable adpp)))

(enable length-put)

(prove-lemma adpp-deposit-adp (rewrite)
  (implies (adpp adp2 segment)
           (equal (adpp adp1 (deposit-adp val adp2 segment))
                  (adpp adp1 segment)))
  ((enable adpp)))

(prove-lemma fetch-adp-deposit-adp (rewrite)
  (implies (and (adpp adp1 segment)
                (adpp adp2 segment))
           (equal (fetch-adp adp1 (deposit-adp val adp2 segment))
                  (if (equal adp1 adp2)
                      val
                      (fetch-adp adp1 segment))))
  ((enable adpp adp-name adp-offset)))

(prove-lemma deposit-adp-deposit-adp (rewrite)
  (equal (deposit-adp val1 adp (deposit-adp val2 adp segment))
         (deposit-adp val1 adp segment)))

; That concludes our first pass at fetch-adp and deposit-adp lemmas.

(disable deposit-adp)
(disable fetch-adp)


(prove-lemma unlabel-dl (rewrite)
  (equal (unlabel (dl a b c)) c)
  ((enable unlabel)))

(disable dl)

(prove-lemma type-r->i_pc (rewrite)
  (equal (type (r->i_pc r-pc r-prog-segment)) 'ipc)
  ((enable r->i_pc)))

(prove-lemma cddr-r->i_pc (rewrite)
  (equal (cddr (r->i_pc r-pc r-prog-segment)) nil)
  ((enable tag r->i_pc)))

(prove-lemma addp-add-adp-untag-r->i_pc-0 (rewrite)
  (implies (proper-r-statep r load-addr)
           (adpp (untag (r->i_pc (r-pc r)
                                 (r-prog-segment r)))
                 (icompile (r-prog-segment r))))
  ((use (addp-add-adp-untag-r->i_pc (n 0)))
   (enable add-adp adp-offset r->i_pc)
   (disable addp-add-adp-untag-r->i_pc )))

(prove-lemma add-adp-add-adp (rewrite)
  (equal (add-adp (add-adp adp i) j)
         (add-adp adp (plus i j)))
  ((enable add-adp)))

; We are now headed into the block of lemmas that are responsible
; for expanding (i * 3 load-addr) for various 3's.  Very roughly speaking,
; we expand (I * 3 load-addr) to (I-STEP (I-STEP (I-STEP *))).  But there
; are various problems, all more or less having to do with the
; fact that we wish to simplify that nest of I-STEPs from the
; inside out, thus symbolically executing the i-level code.
; So imagine that * above is just any intermediate state produced
; in this process.

; The first problem is we call the "I-STATE-OKP problem."
; The sequence of function calls from I is

; I -> I-STEP -> I-STEP1 -> I-STATE-OKP, I-INS-OKP & I-INS-STEP.

; We will need to prove (I-STATE-OKP * load-addr).  But we have from the
; im level proofs:

(enable i-state-okp-i-ins-step)

(disable i-ins-step)
(disable i-ins-okp)

#|
(include-book i-m-book "i-m" t nil)

; Now we disable all of the just imported events except for
; i-state-okp-i-ins-step and we also disable i-ins-step and i-ins-okp.
; This inclusion also introduces many function symbols.  Most we
; keep disabled.  But we used PROPERP in a theorem far below (without
; really knowing when it came into the chronology) and then discovered
; when a proof failed that it was introduced here and was disabled.
; We need it enabled.  One way to look at this inclusion is that we
; looked at "i-m" and saw two things we need, i-state-okp-i-ins-step
; and properp.

(status i-m-book-status
        (set-difference (union (@ *e* add-adp-add-adp)
                               '(i-state-okp-i-ins-step properp))
                        '(i-ins-step i-ins-okp)))

|#
; Thus, on every unfolding of I we get for free the I-STATE-OKP
; if we have it initially (which we do).  But the invariant
; lemma above can't be used if * has been simplified out to
; an I-STATE shell.  So our first move is to replace (I * n load-addr)
; by (I* * n load-addr), where I* is like I but does not have the I-STATE-OKP
; check at all.  We prove that I is I* if the initial state is OKP.

(defn i* (i n load-addr)
  (if (zerop n)
      i
      (if (equal (i-psw i) 'run)
          (if (i-ins-okp (i-current-instruction i) i)
              (i* (i-ins-step (i-current-instruction i) i load-addr) (sub1 n) load-addr)
              (i-halt i (x-y-error-msg 'i (car (i-current-instruction i)))))
          i)))

; A little lemma to deal with the fact that I* halts on the first non-RUN
; psw while I chugs onward.

(prove-lemma i-id-on-non-run (rewrite)
  (implies (not (equal (i-psw i) 'run))
           (equal (i i n load-addr) i)))

; The solution to the I-STATE-OKP problem:

(prove-lemma i-state-okp-implies-i-is-i* (rewrite)
  (implies (and (numberp load-addr)
                (i-state-okp i load-addr))
           (equal (i i n load-addr) (i* i N load-addr)))
  ((disable i-state-okp)))

(disable i)

; So now (I s n load-addr) stays in the problem until we can show that s is
; okp and then it changes to I*.

; There is only one s for which we need to prove i-state-okp, and
; that is the opened up version of (r->i r):


(prove-lemma proper-r-statep-implies-i-state-okp-r->i-opened (rewrite)
  (implies (proper-r-statep r load-addr)
           (i-state-okp (i-state (r->i_pc (r-pc r) (r-prog-segment r))
                                 (r-cfp r)
                                 (r-csp r)
                                 (r-tsp r)
                                 (r-x r)
                                 (r-y r)
                                 (r-c-flg r)
                                 (r-v-flg r)
                                 (r-n-flg r)
                                 (r-z-flg r)
                                 (icompile (r-prog-segment r))
                                 (r-usr-data-segment r)
                                 (r-sys-data-segment r)
                                 (r-word-size r)
                                 'run) load-addr)))

(disable i-state-okp)

; Aside:  We will want the elegant version later so we prove it now:

(prove-lemma proper-r-statep-implies-i-state-okp-r->i nil
  (implies (and (proper-r-statep r load-addr)
                (not (errorp (r-psw r))))
           (i-state-okp (r->i r) load-addr)))

; Next we want to expand (I* s (ADD1 n) load-addr).  But we want this to
; happen only if s has been reduced to an explicit state.  That way
; we avoid a proliferation of case splits.

(prove-lemma i*-opener (rewrite)
  (implies
   (equal ins
          (i-current-instruction
           (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                    i-c-flg i-v-flg i-n-flg i-z-flg
                    i-prog-segment
                    i-usr-data-segment
                    i-sys-data-segment
                    i-word-size i-psw)))
   (equal (i* (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              (add1 n)
              load-addr)
          (if (equal i-psw 'run)
              (if (i-ins-okp ins
                             (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                                      i-c-flg i-v-flg i-n-flg i-z-flg
                                      i-prog-segment
                                      i-usr-data-segment
                                      i-sys-data-segment
                                      i-word-size i-psw))
                  (i* (i-ins-step ins
                                  (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                                           i-c-flg i-v-flg i-n-flg i-z-flg
                                           i-prog-segment
                                           i-usr-data-segment
                                           i-sys-data-segment
                                           i-word-size i-psw)
                                  load-addr)
                      n
                      load-addr)
                  (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                           i-c-flg i-v-flg i-n-flg i-z-flg
                           i-prog-segment
                           i-usr-data-segment
                           i-sys-data-segment
                           i-word-size 
                           (x-y-error-msg 'i (car ins))))
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))))
  ((enable i-halt)
   (disable i-current-instruction)))

(prove-lemma i*-done (rewrite)
  (equal (i* i 0 load-addr) i))

(disable i*)

; So now the only way (i* i n load-addr) will open is if n is 0 or n is an ADD1
; and i is an explicit state.

; Next we consider the problem of opening up I-INS-OKP and I-INS-STEP.
; We wish to open these fns only when the instruction is known and
; the state is explicit.

; Because the i machine has instructions that are all constants --
; there are no operands (unlike the r-level ICODE-OPENER case) --
; we just prove a set of unconditional equalities

(prove-lemma i-ins-okp-opener (rewrite)
 (and
  (equal
   (i-ins-okp '(add_<c>_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<c>_x_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<tsp>_<tsp>{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<tsp>_<tsp>{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_<tsp>{a}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<tsp>{a}_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_tsp_*{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_tsp_*{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_tsp_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_tsp_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<tsp>{i}_x{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_<tsp>{n}_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_pc_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_pc_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_x_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(add_x{n}_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-add_x{n}_csp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(addc_<c>_x{n}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-addc_<c>_x{n}_y{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(addc_<v>_x{i}_y{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-addc_<v>_x{i}_y{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(and_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-and_<tsp>{v}_x{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(and_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-and_<tsp>{b}_x{b}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(asr_<c>_<tsp>_<tsp>{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-asr_<c>_<tsp>_<tsp>{b}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(cpop_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-cpop_cfp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(cpop_pc)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-cpop_pc-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(cpush_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-cpush_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(cpush_<tsp>+)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-cpush_<tsp>+-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(cpush_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-cpush_cfp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(decr_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-decr_<tsp>_<tsp>{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(decr_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-decr_<tsp>_<tsp>{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(incr_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-incr_<tsp>_<tsp>{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(incr_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-incr_<tsp>_<tsp>{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(incr_y_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-incr_y_y{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(int-to-nat)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-int-to-nat-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump-n_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump-n_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump-nn_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump-nn_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump-nz_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump-nz_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump-z_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump-z_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(jump_x{subr})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-jump_x{subr}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(lsr_<c>_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-lsr_<c>_x_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(lsr_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-lsr_<tsp>_<tsp>{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move-c_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move-c_<tsp>_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move-v_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move-v_<tsp>_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move-z_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move-z_<tsp>_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move-n_x_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move-n_x_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_<tsp>_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_<x{a}>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_<x{a}>_<tsp>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_<x{s}>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_<x{s}>_<tsp>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_cfp_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_cfp_csp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_csp_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_csp_cfp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_x_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_x_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_x_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_x_<x{s}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_x_tsp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_x_tsp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_x_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_x_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_y_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_y_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_y_<y{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_y_<y{s}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(move_y_tsp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-move_y_tsp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(neg_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-neg_<tsp>_<tsp>{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(not_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-not_<tsp>_<tsp>{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(or_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-or_<tsp>{v}_x{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(or_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-or_<tsp>{b}_x{b}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<c>_<tsp>{a}_x{a})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<c>_<tsp>{a}_x{a}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<c>_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<c>_<tsp>{n}_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<nv>_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<nv>_<tsp>{i}_x{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<tsp>{a}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<tsp>{a}_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_x{s}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_x{s}_y{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<tsp>{i}_x{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<tsp>{n}_x{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<tsp>{s}_x{s})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<tsp>{s}_x{s}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(sub_<z>_x{s}_y{s})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-sub_<z>_x{s}_y{s}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(subb_<c>_x{n}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-subb_<c>_x{n}_y{n}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(subb_<v>_x{i}_y{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-subb_<v>_x{i}_y{i}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_<c>_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_<c>_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_<x{a}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_<x{a}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_<x{s}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_pc)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_pc-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop_y-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop{v}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop{v}_<z>_y-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop{b}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop{b}_<z>_y-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop{i}_<zn>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop{i}_<zn>_y-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpop{n}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpop{n}_<z>_y-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_*-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_<x{a}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_<x{a}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_<x{s}>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_csp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_tsp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_tsp-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(tpush_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-tpush_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(xor_<tsp>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-xor_<tsp>_<tsp>-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(xor_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-xor_<tsp>{v}_x{v}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(xor_<tsp>{b}_*{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-xor_<tsp>{b}_*{b}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(xor_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-xor_<tsp>{b}_x{b}-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-okp '(xor_<z>_<tsp>_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw))
   (i-xor_<z>_<tsp>_x-okp
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw))))
  ((enable i-ins-okp)
   (disable i-add_<c>_x_x{n}-okp
            i-add_<tsp>_<tsp>{v}-okp
            i-add_<tsp>_<tsp>{n}-okp
            i-add_<tsp>{a}_x{n}-okp
            i-add_tsp_*{n}-okp
            i-add_tsp_x{n}-okp
            i-add_<tsp>{i}_x{i}-okp
            i-add_<tsp>{n}_x{n}-okp
            i-add_pc_x{n}-okp
            i-add_x_x{n}-okp
            i-add_x{n}_csp-okp
            i-addc_<c>_x{n}_y{n}-okp
            i-addc_<v>_x{i}_y{i}-okp
            i-and_<tsp>{v}_x{v}-okp
            i-and_<tsp>{b}_x{b}-okp
            i-asr_<c>_<tsp>_<tsp>{b}-okp
            i-cpop_cfp-okp
            i-cpop_pc-okp
            i-cpush_*-okp
            i-cpush_<tsp>+-okp
            i-cpush_cfp-okp
            i-decr_<tsp>_<tsp>{i}-okp
            i-decr_<tsp>_<tsp>{n}-okp
            i-incr_<tsp>_<tsp>{i}-okp
            i-incr_<tsp>_<tsp>{n}-okp
            i-incr_y_y{n}-okp
            i-int-to-nat-okp
            i-jump-n_x-okp
            i-jump-nn_x-okp
            i-jump-nz_x-okp
            i-jump-z_x-okp
            i-jump_*-okp
            i-jump_x{subr}-okp
            i-lsr_<c>_x_x{n}-okp
            i-lsr_<tsp>_<tsp>{v}-okp
            i-move-c_<tsp>_*-okp
            i-move-v_<tsp>_*-okp
            i-move-z_<tsp>_*-okp
            i-move-n_x_*-okp
            i-move_<tsp>_*-okp
            i-move_<x{a}>_<tsp>-okp
            i-move_<x{s}>_<tsp>-okp
            i-move_cfp_csp-okp
            i-move_csp_cfp-okp
            i-move_x_*-okp
            i-move_x_<x{s}>-okp
            i-move_x_tsp-okp
            i-move_x_x-okp
            i-move_y_*-okp
            i-move_y_<y{s}>-okp
            i-move_y_tsp-okp
            i-neg_<tsp>_<tsp>{i}-okp
            i-not_<tsp>_<tsp>{v}-okp
            i-or_<tsp>{v}_x{v}-okp
            i-or_<tsp>{b}_x{b}-okp
            i-sub_<c>_<tsp>{a}_x{a}-okp
            i-sub_<c>_<tsp>{n}_x{n}-okp
            i-sub_<nv>_<tsp>{i}_x{i}-okp
            i-sub_<tsp>{a}_x{n}-okp
            i-sub_x{s}_y{n}-okp
            i-sub_<tsp>{i}_x{i}-okp
            i-sub_<tsp>{n}_x{n}-okp
            i-sub_<tsp>{s}_x{s}-okp
            i-sub_<z>_x{s}_y{s}-okp
            i-subb_<c>_x{n}_y{n}-okp
            i-subb_<v>_x{i}_y{i}-okp
            i-tpop_<c>_x-okp
            i-tpop_<x{a}>-okp
            i-tpop_<x{s}>-okp
            i-tpop_pc-okp
            i-tpop_x-okp
            i-tpop_y-okp
            i-tpop{v}_<z>_y-okp
            i-tpop{b}_<z>_y-okp
            i-tpop{i}_<zn>_y-okp
            i-tpop{n}_<z>_y-okp
            i-tpush_*-okp
            i-tpush_<x{a}>-okp
            i-tpush_<x{s}>-okp
            i-tpush_csp-okp
            i-tpush_tsp-okp
            i-tpush_x-okp
            i-xor_<tsp>_<tsp>-okp
            i-xor_<tsp>{v}_x{v}-okp
            i-xor_<tsp>{b}_*{b}-okp
            i-xor_<tsp>{b}_x{b}-okp
            i-xor_<z>_<tsp>_x-okp)))

(prove-lemma i-ins-step-opener (rewrite)
 (and
  (equal
   (i-ins-step '(add_<c>_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<c>_x_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<tsp>_<tsp>{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<tsp>_<tsp>{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_<tsp>{a}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<tsp>{a}_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_tsp_*{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_tsp_*{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_tsp_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_tsp_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<tsp>{i}_x{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_<tsp>{n}_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_pc_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_pc_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_x_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(add_x{n}_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-add_x{n}_csp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(addc_<c>_x{n}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-addc_<c>_x{n}_y{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(addc_<v>_x{i}_y{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-addc_<v>_x{i}_y{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(and_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-and_<tsp>{v}_x{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(and_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-and_<tsp>{b}_x{b}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(asr_<c>_<tsp>_<tsp>{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-asr_<c>_<tsp>_<tsp>{b}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(cpop_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-cpop_cfp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(cpop_pc)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-cpop_pc-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(cpush_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-cpush_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(cpush_<tsp>+)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-cpush_<tsp>+-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(cpush_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-cpush_cfp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(decr_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-decr_<tsp>_<tsp>{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(decr_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-decr_<tsp>_<tsp>{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(incr_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-incr_<tsp>_<tsp>{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(incr_<tsp>_<tsp>{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-incr_<tsp>_<tsp>{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(incr_y_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-incr_y_y{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(int-to-nat)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-int-to-nat-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump-n_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump-n_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump-nn_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump-nn_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump-nz_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump-nz_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump-z_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump-z_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(jump_x{subr})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-jump_x{subr}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(lsr_<c>_x_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-lsr_<c>_x_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(lsr_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-lsr_<tsp>_<tsp>{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move-c_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move-c_<tsp>_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move-v_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move-v_<tsp>_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move-z_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move-z_<tsp>_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move-n_x_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move-n_x_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_<tsp>_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_<tsp>_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_<x{a}>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_<x{a}>_<tsp>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_<x{s}>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_<x{s}>_<tsp>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_cfp_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_cfp_csp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_csp_cfp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_csp_cfp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_x_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_x_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_x_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_x_<x{s}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_x_tsp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_x_tsp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_x_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_x_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_y_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_y_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_y_<y{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-move_y_<y{s}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(move_y_tsp)
               (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                        i-c-flg i-v-flg i-n-flg i-z-flg
                        i-prog-segment
                        i-usr-data-segment
                        i-sys-data-segment
                        i-word-size i-psw)
               load-addr)
   (i-move_y_tsp-step
    (i-state i-pc i-cfp i-csp i-tsp i-x i-y
             i-c-flg i-v-flg i-n-flg i-z-flg
             i-prog-segment
             i-usr-data-segment
             i-sys-data-segment
             i-word-size i-psw)))
  (equal
   (i-ins-step '(neg_<tsp>_<tsp>{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-neg_<tsp>_<tsp>{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(not_<tsp>_<tsp>{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-not_<tsp>_<tsp>{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(or_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-or_<tsp>{v}_x{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(or_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-or_<tsp>{b}_x{b}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<c>_<tsp>{a}_x{a})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<c>_<tsp>{a}_x{a}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<c>_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<c>_<tsp>{n}_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<nv>_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<nv>_<tsp>{i}_x{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<tsp>{a}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<tsp>{a}_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_x{s}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_x{s}_y{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<tsp>{i}_x{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<tsp>{i}_x{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<tsp>{n}_x{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<tsp>{n}_x{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<tsp>{s}_x{s})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<tsp>{s}_x{s}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(sub_<z>_x{s}_y{s})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-sub_<z>_x{s}_y{s}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(subb_<c>_x{n}_y{n})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-subb_<c>_x{n}_y{n}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(subb_<v>_x{i}_y{i})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-subb_<v>_x{i}_y{i}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_<c>_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_<c>_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_<x{a}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_<x{a}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_<x{s}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_pc)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_pc-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop_y-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop{v}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop{v}_<z>_y-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop{b}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop{b}_<z>_y-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop{i}_<zn>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop{i}_<zn>_y-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpop{n}_<z>_y)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpop{n}_<z>_y-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_*)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_*-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_<x{a}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_<x{a}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_<x{s}>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_<x{s}>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_csp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_csp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_tsp)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_tsp-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(tpush_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-tpush_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(xor_<tsp>_<tsp>)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-xor_<tsp>_<tsp>-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(xor_<tsp>{v}_x{v})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-xor_<tsp>{v}_x{v}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(xor_<tsp>{b}_*{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-xor_<tsp>{b}_*{b}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(xor_<tsp>{b}_x{b})
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-xor_<tsp>{b}_x{b}-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)))
  (equal
   (i-ins-step '(xor_<z>_<tsp>_x)
              (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                       i-c-flg i-v-flg i-n-flg i-z-flg
                       i-prog-segment
                       i-usr-data-segment
                       i-sys-data-segment
                       i-word-size i-psw)
              load-addr)
   (i-xor_<z>_<tsp>_x-step
     (i-state i-pc i-cfp i-csp i-tsp i-x i-y
              i-c-flg i-v-flg i-n-flg i-z-flg
              i-prog-segment
              i-usr-data-segment
              i-sys-data-segment
              i-word-size i-psw)
     load-addr)))
  ((enable i-ins-step)
   (disable i-add_<c>_x_x{n}-step
            i-add_<tsp>_<tsp>{v}-step
            i-add_<tsp>_<tsp>{n}-step
            i-add_<tsp>{a}_x{n}-step
            i-add_tsp_*{n}-step
            i-add_tsp_x{n}-step
            i-add_<tsp>{i}_x{i}-step
            i-add_<tsp>{n}_x{n}-step
            i-add_pc_x{n}-step
            i-add_x_x{n}-step
            i-add_x{n}_csp-step
            i-addc_<c>_x{n}_y{n}-step
            i-addc_<v>_x{i}_y{i}-step
            i-and_<tsp>{v}_x{v}-step
            i-and_<tsp>{b}_x{b}-step
            i-asr_<c>_<tsp>_<tsp>{b}-step
            i-cpop_cfp-step
            i-cpop_pc-step
            i-cpush_*-step
            i-cpush_<tsp>+-step
            i-cpush_cfp-step
            i-decr_<tsp>_<tsp>{i}-step
            i-decr_<tsp>_<tsp>{n}-step
            i-incr_<tsp>_<tsp>{i}-step
            i-incr_<tsp>_<tsp>{n}-step
            i-incr_y_y{n}-step
            i-int-to-nat-step
            i-jump-n_x-step
            i-jump-nn_x-step
            i-jump-nz_x-step
            i-jump-z_x-step
            i-jump_*-step
            i-jump_x{subr}-step
            i-lsr_<c>_x_x{n}-step
            i-lsr_<tsp>_<tsp>{v}-step
            i-move-c_<tsp>_*-step
            i-move-v_<tsp>_*-step
            i-move-z_<tsp>_*-step
            i-move-n_x_*-step
            i-move_<tsp>_*-step
            i-move_<x{a}>_<tsp>-step
            i-move_<x{s}>_<tsp>-step
            i-move_cfp_csp-step
            i-move_csp_cfp-step
            i-move_x_*-step
            i-move_x_<x{s}>-step
            i-move_x_tsp-step
            i-move_x_x-step
            i-move_y_*-step
            i-move_y_<y{s}>-step
            i-move_y_tsp-step
            i-neg_<tsp>_<tsp>{i}-step
            i-not_<tsp>_<tsp>{v}-step
            i-or_<tsp>{v}_x{v}-step
            i-or_<tsp>{b}_x{b}-step
            i-sub_<c>_<tsp>{a}_x{a}-step
            i-sub_<c>_<tsp>{n}_x{n}-step
            i-sub_<nv>_<tsp>{i}_x{i}-step
            i-sub_<tsp>{a}_x{n}-step
            i-sub_x{s}_y{n}-step
            i-sub_<tsp>{i}_x{i}-step
            i-sub_<tsp>{n}_x{n}-step
            i-sub_<tsp>{s}_x{s}-step
            i-sub_<z>_x{s}_y{s}-step
            i-subb_<c>_x{n}_y{n}-step
            i-subb_<v>_x{i}_y{i}-step
            i-tpop_<c>_x-step
            i-tpop_<x{a}>-step
            i-tpop_<x{s}>-step
            i-tpop_pc-step
            i-tpop_x-step
            i-tpop_y-step
            i-tpop{v}_<z>_y-step
            i-tpop{b}_<z>_y-step
            i-tpop{i}_<zn>_y-step
            i-tpop{n}_<z>_y-step
            i-tpush_*-step
            i-tpush_<x{a}>-step
            i-tpush_<x{s}>-step
            i-tpush_csp-step
            i-tpush_tsp-step
            i-tpush_x-step
            i-xor_<tsp>_<tsp>-step
            i-xor_<tsp>{v}_x{v}-step
            i-xor_<tsp>{b}_*{b}-step
            i-xor_<tsp>{b}_x{b}-step
            i-xor_<z>_<tsp>_x-step)))

; Empty-stkp introduces difference, which slows things down a lot.
; We avoid opening it by proving:

(prove-lemma powerful-length-put nil
  (equal (length (put val n lst))
         (if (lessp n (length lst)) (length lst) (add1 n))))

(prove-lemma empty-stkp-deposit-adp (rewrite)
  (implies (not (empty-stkp sp segment))
           (not (empty-stkp sp
                            (deposit-adp val adp segment))))
  ((use (powerful-length-put
         (n (adp-offset adp))
         (lst (cdr (assoc (adp-name adp) segment))))
        (listp-assoc-implies-definedp (name (adp-name adp)) (alist segment)))
   (enable deposit-adp)))

; Under what conditions is a pushed stack empty?  What does empty
; mean?  It means there is no room left.  When is there no room?  When
; the stack pointer is one less than the length of the stack area.
; A push moves the stack pointer down -- provided the pointer is not
; zero (i.e., provided the stack is not already full).  So, summarizing,
; a pushed stack pointer is non-empty provided it wasn't full before
; the push.  In addition, it had better be a legal stack pointer
; initially or else the push could just bring it down onto the
; upper limit!

(prove-lemma not-empty-stkp-push (rewrite)
  (implies (and (adpp (untag sp) segment)
                (not (zerop (adp-offset (untag sp)))))
           (not (empty-stkp (tag 'sys-addr (sub-adp (untag sp) (add1 n)))
                            segment)))
  ((enable sub-adp adpp)))

(disable empty-stkp)

; The following lemma temporarily opens up adpp by backchaining into
; its defn.

(prove-lemma adpp-backchainer (rewrite)
  (implies (and (listp x) 
                (numberp (adp-offset x)) 
                (definedp (adp-name x) segment) 
                (lessp (adp-offset x) 
                       (length (definiens (adp-name x) segment))))
           (adpp x segment))
  ((enable adpp)))




; We need to

(disable i-objectp)

; we will deduce what we have to from it.

(prove-lemma unlabel-tag (rewrite)
  (equal (unlabel (tag type obj))
         (if (equal type 'dl) 0 (tag type obj)))
  ((enable unlabel tag)))

(enable cddr-tag)

; I am now heading for the lemma that states that if x is an r-objectp
; in r then it is an i-objectp in an appropriately corresponding i state.

(prove-lemma same-signature-implies-adpp (rewrite)
  (implies (same-signature segment1 segment2)
           (equal (adpp x segment1)
                  (adpp x segment2)))
  ((enable adpp)))

(prove-lemma r-program-bodyp-program-body-any (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r)))
           (r-program-bodyp (program-body (assoc name
                                                     (r-prog-segment r)))))
  ((use (r-program-bodyp-program-body-lemma
         (prog-segment (r-prog-segment r))
         (prog (assoc name
                      (r-prog-segment r)))))
   (disable r-program-bodyp-program-body-lemma)))

(prove-lemma listp-cdr-icompile-program (rewrite)
  (listp (cdr (icompile-program program)))
  ((enable icompile-program)))

; So here is the r-objectp -> i-objectp lemma.

; The proper-r-statep below is required to show that the labels show up
; properly in the i-level code.

(prove-lemma r-objectp-implies-i-objectp (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (r-objectp x r)
                (same-signature (r-sys-data-segment r)
                                i-sys-data-segment)
                (same-signature (r-usr-data-segment r)
                                i-usr-data-segment))
           (i-objectp x (i-state i-pc i-cfp i-csp i-tsp i-x i-y
                                 i-c-flg i-v-flg i-n-flg i-z-flg
                                 (icompile (r-prog-segment r))
                                 i-usr-data-segment
                                 i-sys-data-segment
                                 (r-word-size r)
                                 i-psw)))
  ((enable r-objectp i-objectp adp-name adp-offset)))
                
(prove-lemma same-signature-reflexive (rewrite)
  (same-signature segment segment))

(prove-lemma same-signature-put-assoc (rewrite)
  (implies (and (litatom name)
                (definedp name segment2)
                (equal (length (definiens name segment2))
                       (length val)))
           (equal (same-signature segment1 (put-assoc val name segment2))
                  (same-signature segment1 segment2))))

; The litatom hyp in the same-signature lemma will be relieved, I think,
; by:

(defn proper-alistp (alist)
 (if (nlistp alist)
     (equal alist nil)
     (and (listp (car alist))
          (litatom (caar alist))
          (proper-alistp (cdr alist)))))

(prove-lemma litatom-adp-name (rewrite)
  (implies (and (definedp (adp-name adp) segment)
                (proper-alistp segment))
           (litatom (adp-name adp))))

; The lemma above has nothing to do with adp-name -- it could be generalized
; to an arbitrary name.  But it has been so instantiated to be useful.

; To establish the proper-alistp above we'll need something like the following
; two lemmas.  The first dives past all the modifications to the 
; usr-data-segment and the second (or third) backchains into the
; proper-r-statep.

(prove-lemma proper-alistp-put-assoc (rewrite)
  (equal (proper-alistp (put-assoc val name alist))
         (proper-alistp alist)))

(prove-lemma proper-r-usr-data-segmentp-implies-proper-alistp nil
  (implies (proper-r-usr-data-segmentp segment r)
           (proper-alistp segment)))

(prove-lemma proper-alistp-r-usr-data-segment (rewrite)
  (implies (proper-r-statep r load-addr)
           (proper-alistp (r-usr-data-segment r)))
  ((use (proper-r-usr-data-segmentp-implies-proper-alistp
         (segment (r-usr-data-segment r))))))

; The r-objectp hyp of the i-objectp lemma will often be relieved by the
; next lemma when fetching from the r-usr-data-segment.

(prove-lemma r-objectp-get-all-r-usr-data-objectps (rewrite)
  (implies (and (lessp n (length lst))
                (all-r-usr-data-objectps lst r))
           (r-objectp (get n lst) r)))

(prove-lemma all-r-usr-data-objectps-cdr-assoc (rewrite)
  (implies (and (proper-r-usr-data-segmentp segment r)
                (definedp name segment))
           (all-r-usr-data-objectps (cdr (assoc name segment)) r)))

(prove-lemma r-objectp-fetch-adp-r-usr-data-segment (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (adpp adp (r-usr-data-segment r)))
           (r-objectp (fetch-adp adp (r-usr-data-segment r))
                      r))
  ((enable adpp fetch-adp)))

(prove-lemma r-objectp-opener (rewrite)
  (and (implies (equal (type x) 'nat)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (small-naturalp (untag x)
                                            (r-word-size r)))))
       (implies (equal (type x) 'int)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (small-integerp (untag x)
                                            (r-word-size r)))))
       (implies (equal (type x) 'bitv)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (bit-vectorp (untag x)
                                         (r-word-size r)))))
       (implies (equal (type x) 'bool)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (booleanp (untag x)))))
       (implies (equal (type x) 'addr)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (adpp (untag x)
                                  (r-usr-data-segment r)))))
       (implies (equal (type x) 'pc)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (pcpp (untag x)
                                  (r-prog-segment r)))))
       (implies (equal (type x) 'subr)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (definedp (untag x)
                                      (r-prog-segment r)))))
       (implies (equal (type x) 'sys-addr)
                (equal (r-objectp x r)
                       (and (equal (cddr x) nil)
                            (adpp (untag x)
                                  (r-sys-data-segment r))))))
  ((enable r-objectp)))




(prove-lemma i-objectp-tag (rewrite)
  (and (equal (i-objectp (tag 'nat x) i)
              (small-naturalp x (i-word-size i)))
       (equal (i-objectp (tag 'int x) i)
              (small-integerp x (i-word-size i)))
       (equal (i-objectp (tag 'bitv x) i)
              (bit-vectorp x (i-word-size i)))
       (equal (i-objectp (tag 'bool x) i)
              (booleanp x))
       (equal (i-objectp (tag 'addr x) i)
              (adpp x (i-usr-data-segment i)))
       (equal (i-objectp (tag 'pc x) i)
              (icode-labelp x (i-prog-segment i)))
       (equal (i-objectp (tag 'subr x) i)
              (adpp (cons x 0) (i-prog-segment i)))
       (equal (i-objectp (tag 'sys-addr x) i)
              (adpp x (i-sys-data-segment i)))
       (equal (i-objectp (tag 'ipc x) i)
              (adpp x (i-prog-segment i))))
  ((enable i-objectp)))

; Now we begin the one way correspondence proofs for each instruction.

(prove-lemma no-op-one-way-correspondence-r-i (rewrite)
 (implies (and (equal (r-psw r) 'run)
               (equal (car (r-current-instruction r))
                      'no-op)
               (proper-r-statep r load-addr)
               (numberp load-addr)
               (r-no-op-okp (r-current-instruction r)
                            r))
          (equal (r->i (r-no-op-step (r-current-instruction r)
                                     r))
                 (i (r->i r)
                    (r-no-op-step-clock
                     (r-current-instruction r)
                     r) load-addr))))

(prove-lemma push-global-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-global)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-global-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-global-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-push-global-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lessp-find-position-of-var (rewrite)
  (not (lessp (length x)
              (find-position-of-var name x))))

(prove-lemma lessp-length-icompile-program nil
  (implies (member prog progs)
           (not (lessp (segment-length (icompile progs))
                       (length (cdr (icompile-program prog)))))))

(prove-lemma times-add1{gen} (rewrite)
  (equal (times x (add1 y)) (plus x (times x y))))

(prove-lemma length-strip-cars (rewrite)
  (equal (length (strip-cars x)) (length x)))

(prove-lemma lessp-length-local-vars nil
  (lessp (length (local-vars d))
         (length (generate-prelude d)))
  ((enable generate-prelude)))

(prove-lemma lessp-find-position-of-var-exp (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r)))
           (lessp (find-position-of-var
                   var
                   (append (formal-vars (assoc name (r-prog-segment r)))
                           (strip-cars (temp-var-dcls (assoc name (r-prog-segment r))))))
                  (exp 2 (r-word-size r))))
  ((enable icompile-program)
   (use (lessp-length-icompile-program (prog (definition name (r-prog-segment r)))
                                       (progs (r-prog-segment r)))
        (lessp-length-local-vars (d (definition name (r-prog-segment r)))))))

(prove-lemma push-local-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-local)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-local-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-local-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-push-local-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma add-addp-1-folded (rewrite)
 (equal (cons (adp-name (untag (r-pc r)))
              (add1 (adp-offset (untag (r-pc r)))))
        (add-adp (untag (r-pc r)) 1))
 ((enable add-adp)))
                  
(prove-lemma unlabel-non-dl (rewrite)
  (implies (not (equal (car x) 'dl))
           (equal (unlabel x) x))
  ((enable unlabel)))

(prove-lemma r-program-bodyp-contains-r-instructionps nil
  (implies (and (r-program-bodyp lst)
                (member ins lst))
           (r-instructionp (unlabel ins))))

(prove-lemma r-prog-segmentp-contains-r-program-bodyps nil
  (implies (and (r-prog-segmentp segment)
                (member prog segment))
           (r-program-bodyp (program-body prog)))
  ((enable r-programp)))

(prove-lemma member-get (rewrite)
  (implies (lessp n (length lst))
           (member (get n lst) lst)))

(prove-lemma proper-r-statep-implies-r-instructionp (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r))
                (lessp n (length (program-body (assoc name (r-prog-segment r))))))
           (r-instructionp (unlabel (get n
                                             (program-body (assoc name
                                                                  (r-prog-segment r)))))))
  ((use (r-prog-segmentp-contains-r-program-bodyps
         (segment (r-prog-segment r))
         (prog (assoc name
                      (r-prog-segment r))))
        (r-program-bodyp-contains-r-instructionps
         (lst (program-body (assoc name
                                   (r-prog-segment r))))
         (ins (get n
                   (program-body (assoc name
                                        (r-prog-segment r)))))))))

(prove-lemma pcpp-cons (rewrite)
  (implies
   (and (definedp name (r-prog-segment r))
        (numberp n)
        (lessp n
               (length (program-body (assoc name
                                            (r-prog-segment r))))))
   (pcpp (cons name n)
         (r-prog-segment r)))
  ((enable pcpp)))

(prove-lemma not-r-objectp (rewrite)
  (implies (not (listp x)) (not (r-objectp x r)))
  ((enable r-objectp)))

(prove-lemma push-constant-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-constant)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-constant-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-constant-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-push-constant-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma i-objectp-cons-sys-addr (rewrite)
  (equal (i-objectp (list 'sys-addr adp) i)
         (adpp adp (i-sys-data-segment i)))
  ((enable i-objectp untag type)))

(prove-lemma sub-adp-sub-adp (rewrite)
  (equal (sub-adp (sub-adp adp i) j)
         (sub-adp adp (plus i j)))
  ((enable sub-adp)))

(prove-lemma equal-sub-adp-cons-adp-name (rewrite)
  (equal (equal (sub-adp x n) (cons (adp-name x) y))
         (equal (difference (adp-offset x) n) y))
  ((enable sub-adp adp-name adp-offset)))

(prove-lemma length-cdr-assoc-deposit-adp (rewrite)
  (implies (adpp adp segment)
           (equal (length (cdr (assoc name (deposit-adp val adp segment))))
                  (length (cdr (assoc name segment)))))
  ((enable adpp deposit-adp)))

(prove-lemma push-ctrl-stk-free-size-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-ctrl-stk-free-size)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-ctrl-stk-free-size-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-ctrl-stk-free-size-step
                         (r-current-instruction r)
                         r))
                  (i (r->i r)
                     (r-push-ctrl-stk-free-size-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma push-temp-stk-free-size-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-temp-stk-free-size)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-temp-stk-free-size-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-temp-stk-free-size-step
                         (r-current-instruction r)
                         r))
                  (i (r->i r)
                     (r-push-temp-stk-free-size-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub1-difference (rewrite)
  (equal (sub1 (difference x y)) (difference (sub1 x) y)))

(prove-lemma lessp-length-assoc-segment-length (rewrite)
  (not (lessp (segment-length segment) (length (cdr (assoc name segment))))))

(prove-lemma lessp-length-assoc-tstk-exp-2-word-size (rewrite)
  (implies (proper-r-statep r load-addr)
           (lessp (length (cdr (assoc 'tstk (r-sys-data-segment r))))
                  (exp 2 (r-word-size r)))))

(prove-lemma push-temp-stk-index-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'push-temp-stk-index)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-push-temp-stk-index-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-push-temp-stk-index-step
                         (r-current-instruction r)
                         r))
                  (i (r->i r)
                     (r-push-temp-stk-index-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(disable sub1-difference)

(prove-lemma pop-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; r-pop*-okp just checks that tsp + n is a stack address, but the
; i machine needs to know n is a small-naturalp.  The following
; lemma establishes that.

(prove-lemma adpp-implies-lessp-exp-2-word-size (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (adpp (add-adp a n) (r-sys-data-segment r)))
           (equal (lessp n (exp 2 (r-word-size r)))
                  t))
  ((enable adpp)))

(prove-lemma pop*-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop*)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop*-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop*-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop*-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma plus-add1-first (rewrite)
  (equal (plus (add1 i) j) (add1 (plus i j))))

(prove-lemma popn-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'popn)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-popn-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-popn-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-popn-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma pop-local-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop-local)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop-local-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop-local-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop-local-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma pop-global-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop-global)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop-global-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop-global-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop-global-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(enable get-add1-cons)

(prove-lemma get-0 (rewrite) (equal (get 0 lst) (car lst)))
           
(prove-lemma set-local-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'set-local)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-set-local-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-set-local-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-set-local-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma set-global-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'set-global)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-set-global-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-set-global-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-set-global-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; The following lemma really just opens up r->i_pc in the
; special case that arises for the jump instruction.

(prove-lemma r->i_pc-opener-in-jump-case (rewrite)
  (equal (r->i_pc (tag 'pc
                       (cons name
                             (find-label lab
                                         (program-body
                                          (assoc name  
                                                 (r-prog-segment r))))))
                  (r-prog-segment r))
         (tag 'ipc 
              (cons name 
                    (find-label
                     (cons name
                             (find-label lab
                                         (program-body
                                          (assoc name  
                                                 (r-prog-segment r)))))
                     (cdr (icompile-program
                           (definition name
                             (r-prog-segment r))))))))
  ((enable r->i_pc)))

(prove-lemma jump-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'jump)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-jump-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-jump-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-jump-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma pushj-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pushj)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pushj-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pushj-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pushj-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma r->i_pc-opener-in-popj-case (rewrite)
 (equal (r->i_pc (fetch-adp (untag (r-tsp r))
                            (r-sys-data-segment r))
                 (r-prog-segment r))
        (tag 'ipc
             (cons (area-name (fetch-adp (untag (r-tsp r))
                                         (r-sys-data-segment r)))
                   (find-label
                    (untag (fetch-adp (untag (r-tsp r))
                                      (r-sys-data-segment r)))
                    (cdr (icompile-program
                          (definition
                            (area-name
                             (fetch-adp (untag (r-tsp r))
                                        (r-sys-data-segment r)))
                            (r-prog-segment r))))))))
  ((enable r->i_pc)))

(prove-lemma popj-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'popj)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-popj-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-popj-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-popj-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma add-addr-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add-addr)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add-addr-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add-addr-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add-addr-step-clock
                      (r-current-instruction r)
                      r) load-addr)))
  ((disable fetch-adp)))

(prove-lemma sub-addr-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub-addr)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub-addr-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub-addr-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub-addr-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; In all of the xor instructions we should be careful not to
; expand the xors.  This also holds for the other boolean
; instructions.  It especially holds for any instruction involving
; the hideous:

(disable xor-xxx)

(prove-lemma i-usr-data-typep-is-r-usr-data-typep (rewrite)
  (equal (i-usr-data-typep x) (r-usr-data-typep x))
  ((enable i-usr-data-typep r-usr-data-typep)))

(prove-lemma listp-cdr-assoc-deposit-adp (rewrite)
  (implies (adpp adp segment)
           (equal (listp (cdr (assoc name (deposit-adp val adp segment))))
                  (listp (cdr (assoc name segment)))))
  ((enable adpp deposit-adp)))

(prove-lemma i-objectp-bool (rewrite)
  (i-objectp (bool x) s)
  ((enable i-objectp)))

(prove-lemma type-bool (rewrite)
  (equal (type (bool x)) 'bool))

(prove-lemma cddr-bool (rewrite)
  (equal (cddr (bool x)) nil))

(prove-lemma booleanp-untag-bool (rewrite)
  (booleanp (untag (bool x)))
  ((enable booleanp)))

(prove-lemma equal-untag-bool-t (rewrite)
  (equal (equal (untag (bool x)) 't)
         (if x t f)))

(prove-lemma equal-untag-bool-f (rewrite)
  (equal (equal (untag (bool x)) 'f)
         (not x)))

(disable bool)

; Despite the disabling of bool above, we still sometimes
; see '(bool t) because we write it explicitly in some
; definitions and assembly code.

(prove-lemma i-objectp-quote-bool (rewrite)
  (and (i-objectp '(bool t) s)
       (i-objectp '(bool f) s))
  ((enable i-objectp)))
              

; The following lemma has nothing to do with fetch-adp
; but is so instantiated to control its consideration.

; We first prove the general version.

(prove-lemma r-objectps-of-same-type-equal-iff-untags-equal nil
  (implies (and (r-objectp x r)
                (r-objectp y r)
                (equal (type x) (type y)))
           (equal (equal (untag x) (untag y))
                  (equal x y)))
  ((enable type untag r-objectp)))

; and then instantiate it:

(prove-lemma r-objectps-of-same-type-equal-iff-untags-equal-rewrite (rewrite)
  (implies (and (r-objectp (fetch-adp adp1 segment1) r)
                (r-objectp (fetch-adp adp2 segment2) r)
                (equal (type (fetch-adp adp1 segment1))
                       (type (fetch-adp adp2 segment2))))
           (equal (equal (untag (fetch-adp adp1 segment1))
                         (untag (fetch-adp adp2 segment2)))
                  (equal (fetch-adp adp1 segment1)
                         (fetch-adp adp2 segment2))))
  ((use (r-objectps-of-same-type-equal-iff-untags-equal
         (x (fetch-adp adp1 segment1))
         (y (fetch-adp adp2 segment2))))))

(prove-lemma eq-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'eq)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-eq-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-eq-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-eq-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lt-addr-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'lt-addr)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-lt-addr-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-lt-addr-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-lt-addr-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; I might need a more general version of the following lemma.
; But right now I need this and the more general versions I have
; thought of are messy because they introduce cases on the
; relative magnitudes of the increment, decrement, and initial
; offset.

; The hypothesis below is weaker than (adpp adp segment) because
; that stronger hyp has the free variable segment in it.

(prove-lemma sub1-adp-add1-adp (rewrite)
  (implies (and (listp adp)
                (numberp (adp-offset adp)))
           (equal (sub-adp (add-adp adp 1) 1)
                  adp))
  ((enable adpp sub-adp add-adp adp-name adp-offset)))

; The following lemma has free vars in the hyp that cannot be
; relieved in the actual application needed, so I use lemma class
; nil and instantiate it,  backchaining on into the proper-r-statep.

(prove-lemma tag-untag nil
  (implies (and (r-objectp x r)
                (equal (type x) type))
           (equal (tag type (untag x)) x))
  ((enable r-objectp type untag tag)))

(prove-lemma tag-untag-r-tsp (rewrite)
  (implies (proper-r-statep r load-addr)
           (equal (tag 'sys-addr (untag (r-tsp r)))
                  (r-tsp r)))
  ((use (tag-untag (x (r-tsp r))
                   (type 'sys-addr)))))

(prove-lemma fetch-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'fetch)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-fetch-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-fetch-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-fetch-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma deposit-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'deposit)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-deposit-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-deposit-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-deposit-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma fetch-temp-stk-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'fetch-temp-stk)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-fetch-temp-stk-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-fetch-temp-stk-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-fetch-temp-stk-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma deposit-temp-stk-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'deposit-temp-stk)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-deposit-temp-stk-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-deposit-temp-stk-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-deposit-temp-stk-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; Here is the second of the promised sub-adp-add-adp lemmas.

(prove-lemma sub1-adp-add2-adp
             (rewrite)
             (implies (and (listp adp)
                           (numberp (adp-offset adp)))
                      (equal (sub-adp (add-adp adp 2) 1)
                             (add-adp adp 1)))
             ((enable adpp sub-adp add-adp adp-name adp-offset)))

; The following simple identity needs the hypothesis that x is an integerp.
; But since we have that it is actually a small-integerp, I'll use that
; and save the trouble of backchaining through small-integerp implies
; integerp.

(prove-lemma iplus-0{special} (rewrite) 
  (implies (small-integerp x word-size)
           (equal (iplus 0 x) x)))

(enable commutativity-of-iplus)

(prove-lemma small-integerp-fix-small-integer-plus-case (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size))
           (small-integerp
            (fix-small-integer
             (iplus (bool-to-nat c) (iplus x y))
             word-size)
            word-size)))

(prove-lemma small-integerp-fix-small-integer-difference-case (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size))
           (small-integerp
            (fix-small-integer
             (idifference x (iplus y (bool-to-nat c)))
             word-size)
            word-size)))

(disable fix-small-integer)
(disable bool-to-nat)
(disable iplus)
(disable idifference)
(disable ilessp)
(disable integerp)
(disable small-integerp)

(prove-lemma add-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add-int-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add-int-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))


(prove-lemma add-int-with-carry-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add-int-with-carry)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add-int-with-carry-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add-int-with-carry-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add-int-with-carry-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma add1-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add1-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add1-int-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add1-int-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add1-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub-int-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub-int-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub-int-with-carry-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub-int-with-carry)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub-int-with-carry-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub-int-with-carry-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub-int-with-carry-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub1-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub1-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub1-int-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub1-int-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub1-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma neg-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'neg-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-neg-int-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-neg-int-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-neg-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(disable xor-bool)

(prove-lemma not-empty-stkp-implies-adpp-pop (rewrite)
  (implies (and (adpp (untag sp) segment)
                (not (empty-stkp sp segment)))
           (adpp (add-adp (untag sp) 1) segment))
  ((enable empty-stkp adpp add-adp)))

; We are about to go into a really silly little section.  We need to
; know that the word-size is not 0.  To get that, we
; use R-LOADABLEP and the fact that the sys-data-segment is
; non-empty.

(prove-lemma r-loadablep-and-cstk-implies-not-zerop-r-word-size nil
  (implies (and (proper-r-statep r load-addr)
                (lessp (adp-offset (untag (r-cfp r)))
                       (length (cdr (assoc 'cstk
                                           (r-sys-data-segment r))))))
           (not (zerop (r-word-size r))))
  ((enable proper-r-statep r-loadablep)
   (use (cstk-implies-not-zerop-segment-length
         (segment (r-sys-data-segment r))
         (n (adp-offset (untag (r-cfp r))))))))

(prove-lemma proper-r-statep-implies-r-loadablep-and-cstk nil
  (implies (proper-r-statep r load-addr)
           (and (r-loadablep r load-addr)
                (lessp (adp-offset (untag (r-cfp r)))
                       (length (cdr (assoc 'cstk
                                           (r-sys-data-segment r))))))))

(prove-lemma proper-r-statep-implies-lessp-0-r-word-size (rewrite)
  (implies (proper-r-statep r load-addr)
           (and (numberp (r-word-size r))
                (lessp 0 (r-word-size r))))
  ((use (r-loadablep-and-cstk-implies-not-zerop-r-word-size)
        (proper-r-statep-implies-r-loadablep-and-cstk))))


; We now prove the key fact:  (ilessp x y) is equivalent to
; the xor of the v-flg and the n-flg.  Because of case splits
; caused by the paths through the icode-lt-int code, we need to
; prove this fact in 4 different versions, as though xor had
; opened up:

(prove-lemma ilessp-is-xor-case1 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (small-integerp (idifference x y)         ; v-flg = f
                                word-size)
                (negativep                                ; n-flg = t
                 (fix-small-integer (idifference x y)
                                    word-size)))
           (ilessp x y))
  ((enable small-integerp integerp fix-small-integer
           idifference iplus inegate ilessp)))

(prove-lemma ilessp-is-xor-case2 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (not (small-integerp (idifference x y)     ; v-flg = t
                                     word-size))
                (negativep                                 ; n-flg = t
                 (fix-small-integer (idifference x y)
                                    word-size)))
           (not (ilessp x y)))
  ((enable small-integerp integerp fix-small-integer
           idifference iplus inegate ilessp)))

(prove-lemma ilessp-is-xor-case3 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (small-integerp (idifference x y)          ; v-flg = f
                                word-size)
                (not (negativep                            ; n-flg = f
                      (fix-small-integer (idifference x y)
                                         word-size))))
           (not (ilessp x y)))
  ((enable small-integerp integerp fix-small-integer
           idifference iplus inegate ilessp)))

(prove-lemma ilessp-is-xor-case4 (rewrite)
  (implies (and (small-integerp x word-size)
                (small-integerp y word-size)
                (not (zerop word-size))
                (not (small-integerp (idifference x y)      ; v-flg = t
                                     word-size))
                (not (negativep                             ; n-flg = f
                      (fix-small-integer (idifference x y)
                                         word-size))))
           (ilessp x y))
  ((enable small-integerp integerp fix-small-integer
           idifference iplus inegate ilessp)))

(prove-lemma lt-int-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'lt-int)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-lt-int-okp (r-current-instruction r)
                              r))
           (equal (r->i (r-lt-int-step (r-current-instruction r)
                                       r))
                  (i (r->i r)
                     (r-lt-int-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma int-to-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'int-to-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-int-to-nat-okp (r-current-instruction r)
                              r))
           (equal (r->i (r-int-to-nat-step (r-current-instruction r)
                                       r))
                  (i (r->i r)
                     (r-int-to-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma add-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lessp-remainder{special} (rewrite)
  (implies (not (zerop y))
           (lessp (remainder x y) y)))

(prove-lemma add-nat-with-carry-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add-nat-with-carry)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add-nat-with-carry-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add-nat-with-carry-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add-nat-with-carry-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma add1-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'add1-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-add1-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-add1-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-add1-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub-nat-with-carry-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub-nat-with-carry)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub-nat-with-carry-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub-nat-with-carry-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub-nat-with-carry-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma sub1-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'sub1-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-sub1-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-sub1-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-sub1-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lt-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'lt-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-lt-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-lt-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-lt-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma mult2-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'mult2-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-mult2-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-mult2-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-mult2-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma mult2-nat-with-carry-out-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'mult2-nat-with-carry-out)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-mult2-nat-with-carry-out-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-mult2-nat-with-carry-out-step
                         (r-current-instruction r)
                         r))
                  (i (r->i r)
                     (r-mult2-nat-with-carry-out-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lessp-quotient{special} (rewrite)
  (not (lessp x (quotient x y))))

; The following lemma is just an instance of the much prettier fact
; that (remainder x 2) is 0 or 1.  But I couldn't think of a way to
; state that fact without causing a lot of backchaining.  So I'll
; just do it this way.

(prove-lemma remainder-by-2-not-1-lemma (rewrite)
  (implies (not (equal (remainder (untag (fetch-adp (untag (r-tsp r))
                                                    (r-sys-data-segment r)))
                                  2)
                       1))
           (equal (remainder (untag (fetch-adp (untag (r-tsp r))
                                                   (r-sys-data-segment r)))
                                 2)
                      0)))

(prove-lemma exp-2-at-least-2 nil
  (implies (not (zerop i)) (lessp 1 (exp 2 i))))

(prove-lemma i-objectp-nat-0 (rewrite)
  (implies (lessp 0 (i-word-size i))
           (i-objectp '(nat 0) i))
  ((use (exp-2-at-least-2 (i (i-word-size i))))
   (enable i-objectp)))

(prove-lemma i-objectp-nat-1 (rewrite)
  (implies (lessp 0 (i-word-size i))
           (i-objectp '(nat 1) i))
  ((use (exp-2-at-least-2 (i (i-word-size i))))
   (enable i-objectp)))

; Thus ends the silly little section.

(prove-lemma div2-nat-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'div2-nat)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-div2-nat-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-div2-nat-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-div2-nat-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma or-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'or-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-or-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-or-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-or-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma and-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'and-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-and-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-and-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-and-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma not-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'not-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-not-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-not-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-not-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma xor-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'xor-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-xor-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-xor-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-xor-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma rsh-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'rsh-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-rsh-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-rsh-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-rsh-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma lsh-bitv-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'lsh-bitv)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-lsh-bitv-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-lsh-bitv-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-lsh-bitv-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(disable or-bool)
(disable and-bool)
(disable not-bool)

(prove-lemma or-bool-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'or-bool)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-or-bool-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-or-bool-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-or-bool-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma and-bool-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'and-bool)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-and-bool-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-and-bool-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-and-bool-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma xor-bool-t-is-not-bool (rewrite)
  (equal (xor-bool x 't) (not-bool x))
  ((enable xor-bool not-bool)))

(prove-lemma not-bool-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'not-bool)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-not-bool-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-not-bool-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-not-bool-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma jump-if-temp-stk-full-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'jump-if-temp-stk-full)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-jump-if-temp-stk-full-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-jump-if-temp-stk-full-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-jump-if-temp-stk-full-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma jump-if-temp-stk-empty-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'jump-if-temp-stk-empty)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-jump-if-temp-stk-empty-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-jump-if-temp-stk-empty-step
                         (r-current-instruction r)
                         r))
                  (i (r->i r)
                     (r-jump-if-temp-stk-empty-step-clock
                      (r-current-instruction r)
                      r) load-addr)))
  ((enable empty-stkp)))

(prove-lemma test-nat-and-jump-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'test-nat-and-jump)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-test-nat-and-jump-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-test-nat-and-jump-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-test-nat-and-jump-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; The following lemma recognizes a certain opened up
; r->i_pc and folds it back together.  This is needed
; in test-int-and-jump.  

(prove-lemma r->i_pc-folder-test-int-and-jump-case (rewrite)
 (equal (cons
         (adp-name (untag (r-pc r)))
         (find-label
          (add-adp (untag (r-pc r)) 1)
          (cdr (icompile-program (assoc (adp-name (untag (r-pc r)))
                                        (r-prog-segment r))))))

        (untag (r->i_pc (add1-addr (r-pc r))
                        (r-prog-segment r))))
((enable r->i_pc)))

(prove-lemma small-integerp-subtypes (rewrite)
 (implies (and (small-integerp (untag obj) word-size)
               (not (numberp (untag obj))))
          (negativep (untag obj)))
 ((enable small-integerp integerp)))

(prove-lemma test-int-and-jump-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'test-int-and-jump)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-test-int-and-jump-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-test-int-and-jump-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-test-int-and-jump-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; The following lemma makes the arbitrary convention that we'll represent
; all comparisions on Booleans as comparisons with 'F.

(prove-lemma booleanp-subtypes (rewrite)
  (implies (booleanp (untag obj))
           (equal (equal (untag obj) 't)
                  (not (equal (untag obj) 'f))))
  ((enable booleanp)))

; Now we'll pay for that decision:

(prove-lemma not-bool-of-non-f (rewrite)
  (implies (not (equal (untag obj) 'f))
           (equal (not-bool (untag obj)) 'f))
  ((enable not-bool)))

(prove-lemma test-bool-and-jump-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'test-bool-and-jump)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-test-bool-and-jump-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-test-bool-and-jump-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-test-bool-and-jump-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma test-bitv-and-jump-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'test-bitv-and-jump)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-test-bitv-and-jump-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-test-bitv-and-jump-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-test-bitv-and-jump-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma pop-locn-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop-locn)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop-locn-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop-locn-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop-locn-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma locn-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'locn)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-locn-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-locn-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-locn-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; The code generated for the jump-case instruction pops a number, n,
; off the stack and doubles it, as part of the computation of the
; index into a jump table.  We must prove that 2n is representable.
; We do it by observing that 2n is less than the number of labels
; supplied in the jump-case, that the number of labels is dominated
; by the length of the icode, that the length of the icode for an instruction
; is dominated by the length of the icompile-program, that the length
; of the program is dominated by the segment-length, and that the
; segment length is representable.

(prove-lemma length-jump_*-lst (rewrite)
  (equal (length (jump_*-lst labs program))
         (times 2 (length labs))))

(prove-lemma jump-case-instruction-is-much-shorter-than-icode nil
  (implies (equal (car (unlabel ins)) 'jump-case)
           (lessp (times 2 (length (cdr (unlabel ins))))
                  (length (icode ins pcn body)))))
                  
(prove-lemma icode-is-shorter-than-icompile-program nil
  (implies (and (lessp n (length (program-body prog)))
                (numberp n))
           (lessp (length (icode (get n (program-body prog)) n prog))
                  (length (icompile-program prog))))
  ((enable icompile-program)
   (disable weak-monotonicity-of-icompile-program-body-0)
   (use (weak-monotonicity-of-icompile-program-body-0
         (body (program-body prog))))))

; In the following theorem, the (untag (fetch-adp ...)) could
; be generalized to the variable case-number.

(prove-lemma jump-case-number-is-very-small (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (equal
                 (car (unlabel (get (adp-offset (untag (r-pc r)))
                                    (program-body
                                     (assoc (adp-name (untag (r-pc r)))
                                            (r-prog-segment r))))))
                 'jump-case)
                (lessp (untag (fetch-adp (untag (r-tsp r))

                                         (r-sys-data-segment r)))
                       (length
                        (cdr
                         (unlabel
                          (get (adp-offset (untag (r-pc r)))
                               (program-body (assoc (adp-name (untag (r-pc r)))
                                                    (r-prog-segment r)))))))))
           (lessp (times 2 (untag (fetch-adp (untag (r-tsp r))
                                             (r-sys-data-segment r))))
                  (exp 2 (r-word-size r))))
  ((use (proper-r-statep-implies-r-loadablep-and-cstk)
        (lessp-length-icompile-program
         (prog (assoc (adp-name (untag (r-pc r)))
                      (r-prog-segment r)))
         (progs (r-prog-segment r)))
        (icode-is-shorter-than-icompile-program
         (n (adp-offset (untag (r-pc r))))
         (prog (assoc (adp-name (untag (r-pc r)))
                      (r-prog-segment r))))
        (jump-case-instruction-is-much-shorter-than-icode
         (ins (get (adp-offset (untag (r-pc r)))
                   (program-body
                    (assoc (adp-name (untag (r-pc r)))
                           (r-prog-segment r)))))
         (pcn (adp-offset (untag (r-pc r))))
         (body (program-body (assoc (adp-name (untag (r-pc r)))
                                    (r-prog-segment r))))))))

(prove-lemma times-0 (rewrite)
 (implies (zerop z) (equal (times x z) 0)))

(prove-lemma get-2n-jump_*-lst (rewrite)
  (implies (lessp n (length labs))
           (equal (get (times 2 n)
                       (jump_*-lst labs prog))
                  '(jump_*)))
  ((expand (jump_*-lst labs prog))
   (induct (get n labs))))

(prove-lemma get-add1-2n-jump_*-lst (rewrite)
  (implies (lessp n (length labs))
           (equal (get (add1 (times 2 n))
                       (jump_*-lst labs prog))
                  (pc (get n labs) prog)))
  ((expand (jump_*-lst labs prog))
   (induct (get n labs))))

(prove-lemma jump-case-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'jump-case)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-jump-case-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-jump-case-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-jump-case-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

(prove-lemma find-label-prelude (rewrite)
   (implies (equal name (name program))
            (equal (find-label
                    (cons name '(prelude))
                    (cdr (icompile-program program)))
                   0))
   ((enable icompile-program find-label-append
            generate-prelude dl)))

(prove-lemma fetch-adp-prelude-0 (rewrite)
  (implies (definedp name prog-segment)
           (equal (fetch-adp (cons name 0)
                             (icompile prog-segment))
                  (dl (cons name '(prelude))
                      '(prelude)
                      '(cpush_cfp))))
  ((enable fetch-adp icompile-program get-car-cdr-n generate-prelude)))

(prove-lemma fetch-adp-prelude-1 (rewrite)
  (implies (definedp name prog-segment)
           (equal (fetch-adp (cons name 1)
                             (icompile prog-segment))
                  '(move_cfp_csp)))
  ((enable fetch-adp icompile-program get-car-cdr-n generate-prelude)))


(prove-lemma adpp-prelude (rewrite)
  (implies (and (definedp name prog-segment)
                (numberp n)
                (not (lessp
                      (length (generate-prelude (assoc name prog-segment)))
                      n)))
           (adpp (cons name n) (icompile prog-segment)))
  ((enable adpp icompile-program)))


(enable length-generate-prelude)

(prove-lemma i*-plus nil
  (equal (i* s (plus i j) load-addr)
         (i* (i* s i load-addr) j load-addr))
  ((enable i*)))

; The following theorem is just an instance of the i*-plus theorem above.
; However, I don't want the i*-plus theorem as a rewrite rule because I
; don't want the i* expression rewritten until we have done all the work
; we can.

(prove-lemma i*-plus-prelude1-prelude2 (rewrite)
  (equal (i* s
             (plus (length (temp-var-dcls prog))
                     (length (formal-vars prog)))
             load-addr)
         (i* (i* s (length (temp-var-dcls prog)) load-addr)
             (length (formal-vars prog))
             load-addr))
  ((use (i*-plus (i (length (temp-var-dcls prog)))
                 (j (length (formal-vars prog)))))))

; We now wish to package up the execution of prelude1.  See i*-prelude1
; below.  To prove it, we must prove the more general i*-prelude1-generalized
 
; We start by establishing what fetch-adp returns on both even and odd
; addresses into the prelude1.  The main theorems of this section are
; fetch-adp-prelude1-even and fetch-adp-prelude1-odd.

(prove-lemma sub-adp-0 (rewrite)
  (implies (adpp x segment)
           (equal (sub-adp x 0) x))
  ((enable sub-adp adpp adp-name adp-offset)))

(prove-lemma tag-type-untag (rewrite)
  (implies (and (equal (type x) type)
                (equal (cddr x) nil))
           (equal (tag type (untag x)) x))
  ((enable tag type untag)))

(prove-lemma adpp-sub-adp (rewrite)
  (implies (adpp x segment)
           (adpp (sub-adp x 1) segment))
  ((enable adpp sub-adp)))

(prove-lemma fetch-adp-prelude1-even-lemma (rewrite)
 (implies (lessp n (length rev-temp-var-dcls))
          (equal
           (car (cdr-n (plus n n)
                       (generate-prelude1 rev-temp-var-dcls)))
           '(cpush_*)))
 ((induct (get n rev-temp-var-dcls))
  (expand (generate-prelude1 rev-temp-var-dcls))
  (disable cdr-n-plus)))

(prove-lemma fetch-adp-prelude1-even (rewrite)
  (implies (and (definedp name prog-segment)
                (lessp n (length (temp-var-dcls (assoc name prog-segment)))))
           (equal (fetch-adp (cons name (add1 (add1 (plus n n))))
                             (icompile prog-segment))
                  '(cpush_*)))
  ((enable fetch-adp icompile-program get-car-cdr-n generate-prelude)
   (disable cdr-n-plus)))


(prove-lemma listp-rev (rewrite)
  (equal (listp (rev x)) (listp x)))

(prove-lemma get-append (rewrite)
 (implies (lessp n (length a))
          (equal (get n (append a b)) (get n a))))

(prove-lemma fetch-adp-prelude1-odd-lemma (rewrite)
  (implies (lessp n (length rev-temp-var-dcls))
           (equal (get (add1 (plus n n))
                       (generate-prelude1 rev-temp-var-dcls))
                  (cadr (get n rev-temp-var-dcls)))))

(prove-lemma fetch-adp-prelude1-odd (rewrite)
  (implies (and (definedp name prog-segment)
                (lessp n (length (temp-var-dcls (assoc name prog-segment)))))
           (equal (fetch-adp (cons name (add1 (add1 (add1 (plus n n)))))
                             (icompile prog-segment))
                  (cadr (get n (rev
                                (temp-var-dcls
                                 (assoc name prog-segment)))))))

  ((enable fetch-adp icompile-program generate-prelude
           length-generate-prelude1)
   (disable get)))

; We need establish that what the CPUSH_* pushes is an i-objectp
; in the current i-state.  We know that everything r-call-step
; pushes is an r-objectp in the initial r state.  We need to make
; the connections.  The key here is our previously proved lemma
; that r-objectp-implies-i-objectp.  We first establish that what
; is pushed at the i-level is an r-object.

(prove-lemma adpp-implies-numberp-adp-offset (rewrite)
  (implies (adpp x segment)
           (numberp (adp-offset x)))
  ((enable adpp)))

(prove-lemma all-r-objectps-implies-r-objectp-get (rewrite)
  (implies (and (lessp n (length var-dcls))
                (all-r-objectps (strip-cadrs var-dcls) r))
           (r-objectp (cadr (get n var-dcls)) r)))

; Unfortunately, what the icompiler lays down is not elements of
; (strip-cadrs var-dcls) but elements of its reverse.  So we need
; to prove that the reverse doesn't affect the argument above.

(prove-lemma strip-cadrs-append (rewrite)
  (equal (strip-cadrs (append a b))
         (append (strip-cadrs a) (strip-cadrs b))))

(prove-lemma all-r-objectps-append (rewrite)
  (implies (properp a)
           (equal (all-r-objectps (append a b) r)
                  (and (all-r-objectps a r)
                       (all-r-objectps b r)))))

(prove-lemma properp-strip-cadrs (rewrite)
  (properp (strip-cadrs x)))

(prove-lemma all-r-objectps-strip-cadrs-rev (rewrite)
  (equal (all-r-objectps (strip-cadrs (rev x)) r)
         (all-r-objectps (strip-cadrs x) r)))

; The work above is sufficient to relieve the r-objectp hyp
; in r-objectp-implies-i-objectp.

; We also have to establish that the signature of the r state
; is the same as that of the i state.  This follows from:

(prove-lemma same-signature-deposit-adp (rewrite)
  (implies (and (litatom (adp-name adp))
                (adpp adp segment2))
           (equal (same-signature segment1 (deposit-adp val adp segment2))
                  (same-signature segment1 segment2)))
  ((enable deposit-adp adpp)))


; Now once the i machine has fetched the element it UNLABELs it.
; We need to show that it is not a DL.  That follows from the
; fact that we have a proper-r-statep which thus contains
; a r-programp which thus contains r-temp-var-dclsp,
; none of which is a DL.  Again we have to worry about the
; reverse.

(enable member-append)

(prove-lemma member-rev (rewrite)
  (equal (member x (rev l))
         (member x l)))

(prove-lemma unlabel-cadr-get-rev-temp-var-dcls-lemma nil
  (implies (and (member var-dcl temp-var-dcls)
                (r-temp-var-dclsp temp-var-dcls))
           (equal (unlabel (cadr var-dcl))
                  (cadr var-dcl))))

(prove-lemma unconditional-get-append (rewrite)
  (equal (get n (append a b))
         (if (lessp n (length a))
             (get n a)
             (get (difference n (length a)) b)))
  ((disable get-append)))

(prove-lemma get-rev nil
  (implies (lessp n (length l))
           (equal (get n (rev l))
                  (get (sub1 (difference (length l) n)) l))))

(disable unconditional-get-append)

(prove-lemma member-get-rev (rewrite)
  (implies (lessp n (length l))
           (member (get n (rev l)) l))
  ((use (get-rev)
        (member-get (n (sub1 (difference (length l) n)))
                    (lst l)))
   (disable member-get)))

(prove-lemma unlabel-cadr-get-rev-temp-var-dcls (rewrite)
  (implies
   (and (proper-r-statep r load-addr)
        (definedp name (r-prog-segment r))
        (lessp n (length (temp-var-dcls (assoc name (r-prog-segment r))))))
   (equal (unlabel
           (cadr
            (get
             n
             (rev (temp-var-dcls (assoc name (r-prog-segment r)))))))
          (cadr
           (get
            n
            (rev (temp-var-dcls (assoc name (r-prog-segment r))))))))
  ((use (unlabel-cadr-get-rev-temp-var-dcls-lemma
         (var-dcl (get
                   n
                   (rev (temp-var-dcls (assoc name (r-prog-segment r))))))
         (temp-var-dcls
          (temp-var-dcls (assoc name (r-prog-segment r)))))
        (proper-r-statep-implies-r-programp))
   (disable proper-r-statep-implies-r-programp)
   (enable r-programp)))


; In the prelude1 proof we have difference disabled and the following lemma
; comes in at just the right place and reduces the pc in the induction
; conclusion to that in the induction hypothesis.
                  
(prove-lemma add4-plus-difference-difference (rewrite)
  (implies (not (lessp n (add1 z)))
           (equal (add1
                   (add1
                    (add1
                     (add1
                      (plus
                       (difference n (add1 z))
                       (difference n (add1 z)))))))
                  (add1 (add1
                         (plus (difference n z)(difference n z)))))))


; Finally, we need to show that depositing one element and then the
; rest is the same as depositing them all.

(prove-lemma deposit-lst-append (rewrite)
  (implies (adpp (untag sp) segment)
           (equal (deposit-lst (append a b) sp segment)
                  (deposit-lst b
                               (push-stk-n (length a) sp)
                               (deposit-lst a sp segment))))
  ((induct (deposit-lst a sp segment))
   (do-not-generalize t)))

(prove-lemma first-n-opener-right-end (rewrite)
 (implies (lessp z (length lst))
          (equal (first-n (add1 z) lst)
                 (append (first-n z lst)
                         (list (get z lst))))))

(enable properp-rev)

(prove-lemma append-right-id (rewrite)
  (implies (properp a) (equal (append a nil) a)))

(enable rev-append)

(prove-lemma get-difference-sub1-length-rev (rewrite)
  (implies (lessp z (length temp-var-dcls))
           (equal (get (difference (sub1 (length temp-var-dcls))
                                   z)
                       (rev temp-var-dcls))
                  (get z temp-var-dcls)))
  ((enable unconditional-get-append)))

; The basic idea of the execution of i*-prelude1-generalized is that
; we start in the middle of the prelude (with n pushes left to go)
; and execute those n.  We then describe what happens to the stack.
; The lemma below is the key observation.  To understand it, it is
; really necessary to see the prelude1 theorem first.

(prove-lemma deposit-lst-equivalence (rewrite)
  (implies (and (adpp (sub-adp (untag csp) 1) sys-data-segment)
                (numberp z)
                (lessp z (length temp-var-dcls))) 
         (equal
              (deposit-lst
               (rev (strip-cadrs (first-n z temp-var-dcls)))
               (tag 'sys-addr
                    (sub-adp (untag csp) 2))
               (deposit-adp
                (cadr
                 (get
                  (difference
                       (length temp-var-dcls)
                       (add1 z))
                  (rev temp-var-dcls)))
                (sub-adp (untag csp) 1)
                sys-data-segment))
              (deposit-lst
               (rev
                (strip-cadrs
                    (first-n (add1 z)
                             temp-var-dcls)))
               (tag 'sys-addr
                    (sub-adp (untag csp) 1))
               sys-data-segment)))
  ((disable first-n)))

; i*-prelude1-generalized requires a complicated induction.  The
; idea is to execute one clock tick and say what happens to
; csp (it is pushed by one) and sys-data-segment (one of the
; temp-var-dcls' initial values is deposited).  

(defn hint-prelude1 (n csp sys-data-segment name r)
  (if (zerop n)
      t
      (hint-prelude1 (sub1 n)
                     (push-stk csp)
                 
                     (deposit
                      (cadr
                       (get
                        (difference
                         (length (temp-var-dcls
                                  (assoc name (r-prog-segment r))))
                         n)
                        (rev (temp-var-dcls
                                  (assoc name (r-prog-segment r))))))
                      (push-stk csp)
                      sys-data-segment)
                     name r)))

; Crucial to this proof is that we elim (SUB1 N).  This introduces
; an (I* s (ADD1 Z) load-addr) where we had an (I* s N load-addr).  Then I* can be
; opened.  But the elimination on (SUB1 N) is not the first elimination
; available -- we can also elim on CDR and on the accessors to the
; R-STATEs.  Thus, I disable those elim lemmas.  I also keep first-n
; and difference closed up, manipulating them completely with the
; lemmas above.

(prove-lemma i*-prelude1-generalized nil
  (implies
   (and (proper-r-statep r load-addr)
        (all-r-objectps
         (strip-cadrs
          (temp-var-dcls (assoc name (r-prog-segment r))))
         r)
        (definedp name (r-prog-segment r))
        (same-signature (r-sys-data-segment r)
                        sys-data-segment)
        (numberp n)
        (not (lessp (length
                     (temp-var-dcls
                      (assoc name (r-prog-segment r))))
                    n))
        (cstkp csp sys-data-segment)
        (not (lessp (adp-offset (untag csp)) n)))
   (equal (i* (i-state
               (tag 'ipc
                    (cons name
                          (add1
                           (add1
                            (times 2
                                   (difference
                                    (length
                                     (temp-var-dcls
                                      (assoc name (r-prog-segment r))))
                                    n))))))
               cfp
               csp
               tsp
               x y c-flg v-flg n-flg z-flg
               (icompile (r-prog-segment r))
               (r-usr-data-segment r)
               sys-data-segment
               (r-word-size r)
               'run)
              n
              load-addr)
          (i-state
           (tag 'ipc
                (cons name
                      (add1
                       (add1
                        (times 2
                               (length
                                (temp-var-dcls
                                 (assoc name (r-prog-segment r)))))))))
           cfp
           (push-stk-n n csp)
           tsp
           x y c-flg v-flg n-flg z-flg
           (icompile (r-prog-segment r))
           (r-usr-data-segment r)
           (deposit-lst
            (rev
             (strip-cadrs
              (first-n n
                       (temp-var-dcls
                        (assoc name (r-prog-segment r))))))
            (push-stk csp)
            sys-data-segment)
           (r-word-size r)
           'run)))
  ((disable first-n difference
            CAR-CDR-ELIM
            R-PC-R-CFP-R-CSP-R-TSP-R-X-R-Y-R-C-FLG-R-V-FLG-R-N-FLG-R-Z-FLG-R-PROG-SEGMENT-R-USR-DATA-SEGMENT-R-SYS-DATA-SEGMENT-R-WORD-SIZE-R-PSW-ELIM)
   (induct (hint-prelude1 n csp sys-data-segment name r))))

; The above theorem tells us what happens if we execute the last n
; instructions in prelude1.  Now we instantiate n with the number
; of executable instructions in prelude1 and deduce what happens when
; we execute the prelude1.

; To prove the instance we need the trivial:

(disable first-n-opener-right-end)

(prove-lemma first-n-length (rewrite)
  (equal (strip-cadrs (first-n (length lst) lst))
         (strip-cadrs lst)))

; The above theorem is essentially just a first-n property and has
; almost nothing to do with strip-cadrs:  (first-n (length lst) lst)
; is lst.  That is not true if lst is not proper.  Rather than set up
; the lemmas necessary to get that the temp-var-dcls are proper, I'll
; just observe that in our application we strip-cadrs the result and
; that does the same thing whether lst is proper or not.

(prove-lemma i*-prelude1 (rewrite)
  (implies
   (and (proper-r-statep r load-addr)
        (all-r-objectps
         (strip-cadrs
          (temp-var-dcls (assoc name (r-prog-segment r))))
         r)
        (definedp name (r-prog-segment r))
        (same-signature (r-sys-data-segment r)
                        sys-data-segment)
        (cstkp csp sys-data-segment)
        (not (lessp (adp-offset (untag csp))
                    (length
                     (temp-var-dcls
                      (assoc name (r-prog-segment r)))))))
   (equal (i* (i-state
               (tag 'ipc
                    (cons name 2))
               cfp
               csp
               tsp
               x y c-flg v-flg n-flg z-flg
               (icompile (r-prog-segment r))
               (r-usr-data-segment r)
               sys-data-segment
               (r-word-size r)
               'run)
              (length
               (temp-var-dcls
                (assoc name (r-prog-segment r))))
              load-addr)
          (i-state
           (tag 'ipc
                (cons name
                      (add1
                       (add1
                        (times 2
                               (length
                                (temp-var-dcls
                                 (assoc name (r-prog-segment r)))))))))
           cfp
           (push-stk-n (length
                        (temp-var-dcls
                         (assoc name (r-prog-segment r))))
                       csp)
           tsp
           x y c-flg v-flg n-flg z-flg
           (icompile (r-prog-segment r))
           (r-usr-data-segment r)
           (deposit-lst
            (rev
             (strip-cadrs
              (temp-var-dcls
               (assoc name (r-prog-segment r)))))
            (push-stk csp)
            sys-data-segment)
           (r-word-size r)
           'run)))
  ((use (i*-prelude1-generalized
         (n (length (temp-var-dcls
                        (assoc name (r-prog-segment r)))))))))

; That completes our work on prelude1.

; We now turn to prelude2.  

; For some reason the proof of the call one-way-correspondence theorem
; raises the possibility that the sum of the lengths of the temp-var-dcls
; and the formal-vars is 0.  Rather than prevent this case split, I just
; deal with it.  The following lemma reduces that case to the case that
; there are not temp or formal variables.

(enable equal-plus-0)

; In the case where both formals and temp-var-dcls is empty, we
; immediately get to the end of the prelude and the only remaining
; problem is dealing with the two pc expressions.  On the r level
; we have (r->i_pc (tag 'pc (cons name 0)) (r-prog-segment r))
; while at the i level we have
; (tag 'ipc (cons name length-prelude)).  We will rewrite the former
; to the latter.  We have all the necessary machinery to do this.
; We do have to appeal to the fact that the temp-var-dcls of the
; program are well-formed, e.g., r-temp-var-dclsp, if the
; program is in the program segment of a proper r state.  That was
; proved earlier, but for an instance in which name was derived from
; the current pc.  We need it for the subroutine name now.  So we
; just instantiate the necessary lemma.  

(prove-lemma r->i_pc-prelude (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r)))
              (EQUAL
                (R->I_PC
                 (TAG 'PC (CONS name 0))
                 (R-PROG-SEGMENT R))
                (TAG 'IPC
                 (CONS
                  name
                  (length
                   (generate-prelude (assoc name (r-prog-segment r))))))))
  ((disable length-generate-prelude)
   (enable r->i_pc icompile-program
           find-label-append
           find-label-generate-prelude
           find-label-icompile-program-body-lemma1
           find-label-generate-postlude)
   (use (r-temp-var-dclsp-temp-var-dcls-lemma
         (prog-segment (r-prog-segment r))
         (prog (assoc name (r-prog-segment r)))))))


; In this pathological case we also have to know:

(prove-lemma add-adp-0-untag-r-tsp (rewrite)
  (implies (and (listp x)
                (numberp (adp-offset x)))
           (equal (add-adp x 0) x))
  ((enable adpp add-adp adp-name adp-offset)))

; We might as well get the sub-adp analogue:

(prove-lemma sub-adp-0-untag-r-tsp (rewrite)
  (implies (and (listp x)
                (numberp (adp-offset x)))
           (equal (sub-adp x 0) x))
  ((enable adpp sub-adp adp-name adp-offset)))

; Embarassing anomoly:  The LENGTH-GENERATE-PRELUDE lemma introduces a term
; of the form (TIMES x 2) which is replaced by (PLUS x x) by the
; TIMES-ADD1{gen} lemma.  But I*-PRELUDE introduces (TIMES 2 x) which is
; left alone.  I could reformulate LENGTH-GENERATE-PRELUDE.  But
; instead I will just prove (TIMES 2 X) = (PLUS X X) and keep
; TIMES out of the problem henceforth.

(enable times-2)

; We start our study of prelude2 just like that of prelude1,
; by determining what instruction you get when you fetch from the prelude2.

(prove-lemma fetch-adp-prelude2-lemma (rewrite)
 (implies (lessp n (length formal-vars))
          (equal
           (get n (generate-prelude2 formal-vars))
           '(cpush_<tsp>+)))
 ((induct (get n formal-vars))
  (expand (generate-prelude2 formal-vars))))

(prove-lemma difference-plus-k-k-length nil
  (implies (and (equal (plus k k) (length a))
                (numberp n))
           (equal (difference (plus k k n) (length a))
                  n)))

(prove-lemma get-append-bridge (rewrite)
  (implies (and (equal (plus k k) (length a))
                (numberp n))
           (equal (get (plus k (plus k n)) (append a b))
                  (get n b)))
  ((enable unconditional-get-append)
   (use (difference-plus-k-k-length))))

(prove-lemma fetch-adp-prelude2 (rewrite)
  (implies (and (definedp name prog-segment)
                (numberp n)
                (lessp n (length (formal-vars (assoc name prog-segment)))))
           (equal (fetch-adp (cons name
                                   (add1
                                    (add1
                                     (plus (length
                                            (temp-var-dcls
                                             (assoc name prog-segment)))
                                           (length
                                            (temp-var-dcls
                                             (assoc name prog-segment)))
                                           n))))
                             (icompile prog-segment))
                  '(cpush_<tsp>+)))
  ((enable length-generate-prelude
           fetch-adp icompile-program generate-prelude)))

(disable get-append-bridge)

; We specify the induction for prelude2 with:

(defn hint-prelude2 (n csp tsp sys-data-segment name r)
  (if (zerop n)
      t
      (hint-prelude2 (sub1 n)
                     (push-stk csp)
                     (pop-stk tsp)
                     (deposit
                      (fetch-adp (untag tsp)
                                 sys-data-segment)
                      (push-stk csp)
                      sys-data-segment)
                     name r)))

; Just as in the prelude1 case, we have disabled difference and use
; tweezers to manipulate such expressions.  This lemma shows that
; the pc in the induction conclusion is equal to that in the induction
; hypothesis.

(prove-lemma add1-add1-plus-length-length-difference-length-add1 (rewrite)
  (implies
   (not (lessp (length (formal-vars (assoc name (r-prog-segment r))))
               (add1 z))) 
   (equal (add1
           (add1
            (add1
             (plus
              (length (temp-var-dcls (assoc name (r-prog-segment r))))
              (length (temp-var-dcls (assoc name (r-prog-segment r))))
              (difference
               (length (formal-vars (assoc name (r-prog-segment r))))
               (add1 z))))))
          (add1
           (add1
            (plus
             (length (temp-var-dcls (assoc name (r-prog-segment r))))
             (length (temp-var-dcls (assoc name (r-prog-segment r))))
             (difference
              (length (formal-vars (assoc name (r-prog-segment r))))
              z)))))))

; We also have to show that if you fetch n things from the tstk all
; at once that it is equivalent to fetching them interspersed with
; writes to the cstk.  In particular:

(prove-lemma fetch-n-tstk-deposit-adp-cstk (rewrite)
  (implies (and (adpp csp-adp sys-data-segment)
                (equal (adp-name csp-adp) 'cstk)
                (tstkp tsp sys-data-segment)
                (not (lessp (stk-length tsp sys-data-segment) z)))
           (equal (fetch-n z
                           tsp
                           (deposit-adp val
                                        csp-adp
                                        sys-data-segment))
                  (fetch-n z
                           tsp
                           sys-data-segment)))
  ((enable adpp)
   (induct (fetch-n z tsp sys-data-segment))))

; So here is the generalized version of i*-prelude2.

(prove-lemma i*-prelude2-generalized nil
  (implies 
   (and (proper-r-statep r load-addr)
        (definedp name (r-prog-segment r))
        (cstkp csp sys-data-segment)
        (tstkp tsp sys-data-segment)
        (not (lessp (adp-offset (untag csp)) n))
        (not (lessp (stk-length tsp sys-data-segment) n))
        (numberp n)
        (not (lessp (length (formal-vars (assoc name (r-prog-segment r))))
                    n)))
   (equal
    (i* (i-state
         (tag 'ipc
              (cons
               name
               (add1
                (add1
                 (plus (length
                        (temp-var-dcls
                         (assoc name (r-prog-segment r))))
                       (length
                        (temp-var-dcls
                         (assoc name (r-prog-segment r))))
                       (difference
                        (length (formal-vars (assoc name (r-prog-segment r))))
                        n))))))
         cfp
         csp
         tsp
         x y c-flg v-flg n-flg z-flg
         (icompile (r-prog-segment r))
         (r-usr-data-segment r)
         sys-data-segment
         (r-word-size r)
         'run)
        n
        load-addr)
    (i-state
     (tag 'ipc
          (cons
           name
           (add1
            (add1
             (plus
              (length
               (temp-var-dcls
                (assoc name (r-prog-segment r))))
              (length
               (temp-var-dcls
                (assoc name (r-prog-segment r))))
              (length
               (formal-vars
                (assoc name (r-prog-segment r)))))))))
     cfp
     (push-stk-n n csp)
     (pop-stk-n n tsp)
     x y c-flg v-flg n-flg z-flg
     (icompile (r-prog-segment r))
     (r-usr-data-segment r)
     (deposit-lst
      (fetch-n
       n
       tsp
       sys-data-segment)
      (push-stk csp)
      sys-data-segment)
     (r-word-size r)
     'run)))
  ((enable adpp empty-stkp)
   (disable difference
            CAR-CDR-ELIM
            R-PC-R-CFP-R-CSP-R-TSP-R-X-R-Y-R-C-FLG-R-V-FLG-R-N-FLG-R-Z-FLG-R-PROG-SEGMENT-R-USR-DATA-SEGMENT-R-SYS-DATA-SEGMENT-R-WORD-SIZE-R-PSW-ELIM)
   (induct (hint-prelude2 n csp tsp sys-data-segment name r))))

(prove-lemma i*-prelude2 (rewrite)
  (implies 
   (and (proper-r-statep r load-addr)
        (definedp name (r-prog-segment r))
        (cstkp csp sys-data-segment)
        (tstkp tsp sys-data-segment)
        (not (lessp (adp-offset (untag csp))
                    (length (formal-vars (assoc name (r-prog-segment r))))))
        (not (lessp (stk-length tsp sys-data-segment)
                    (length (formal-vars (assoc name (r-prog-segment r)))))))
   (equal
    (i* (i-state
         (tag 'ipc
              (cons
               name
               (add1
                (add1
                 (plus (length
                        (temp-var-dcls
                         (assoc name (r-prog-segment r))))
                       (length
                        (temp-var-dcls
                         (assoc name (r-prog-segment r)))))))))
         cfp
         csp
         tsp
         x y c-flg v-flg n-flg z-flg
         (icompile (r-prog-segment r))
         (r-usr-data-segment r)
         sys-data-segment
         (r-word-size r)
         'run)
        (length (formal-vars (assoc name (r-prog-segment r))))
        load-addr)
    (i-state
     (tag 'ipc
          (cons
           name
           (add1
            (add1
             (plus
              (length
               (temp-var-dcls
                (assoc name (r-prog-segment r))))
              (length
               (temp-var-dcls
                (assoc name (r-prog-segment r))))
              (length
               (formal-vars
                (assoc name (r-prog-segment r)))))))))
     cfp
     (push-stk-n (length (formal-vars (assoc name (r-prog-segment r))))
                 csp)
     (pop-stk-n (length (formal-vars (assoc name (r-prog-segment r))))
                tsp)
     x y c-flg v-flg n-flg z-flg
     (icompile (r-prog-segment r))
     (r-usr-data-segment r)
     (deposit-lst
      (fetch-n
       (length (formal-vars (assoc name (r-prog-segment r))))
       tsp
       sys-data-segment)
      (push-stk csp)
      sys-data-segment)
     (r-word-size r)
     'run)))
  ((use (i*-prelude2-generalized
         (n (length (formal-vars (assoc name (r-prog-segment r)))))))))

(disable adpp-sub-adp)

(prove-lemma adpp-sub-adp-generalize (rewrite)
  (implies (adpp x segment)
           (adpp (sub-adp x n) segment))
  ((enable adpp sub-adp)))

(prove-lemma length-strip-cadrs (rewrite)
  (equal (length (strip-cadrs x)) (length x)))

(prove-lemma definedp-put-assoc{special} (rewrite)
  (implies (definedp name1 segment)
           (definedp name1 (put-assoc val name2 segment))))

; We have some theorems like these, but they rewrite
; (adpp ... (deposit-adp ... segment)) to (adpp ... segment)
; under hyps about the legality of the deposit address.  I have
; since gotten tired of proving the legality of the addresses and
; wish to observe that even if the address is illegal the worst
; case is that the area written into becomes longer.  So the
; legal addresses after the deposit include the legal addresses
; before.

(prove-lemma adpp-deposit-adp-generalized (rewrite)
  (implies (adpp adp1 segment)
           (adpp adp1 (deposit-adp val adp2 segment)))
  ((use (powerful-length-put
            (n (adp-offset adp2))
            (lst (cdr (assoc (adp-name adp1) segment)))))
   (enable adpp deposit-adp)))

(prove-lemma adpp-deposit-lst (rewrite)
  (implies (adpp adp1 segment)
           (adpp adp1 (deposit-lst lst adp2 segment))))

; The following crappy lemma is used in relieving the fifth hypothesis
; of the i*-prelude2 lemma.  This undoubtedly could be generalized
; but I just got tired of finding elegant solutions.  This fact is
; immediate from linear arithmetic; unfortunately, it involves a little
; case analysis and is not caught during back chaining.

(prove-lemma i*-prelude2-hyp-5-reliever (rewrite)
  (implies
   (and
    (not (equal (sub1 (adp-offset (untag (r-csp r))))
                0))
    (not
     (lessp
      (sub1 (sub1 (adp-offset (untag (r-csp r)))))
      (plus
       (length
        (formal-vars
         (assoc
          (cadr
           (unlabel
            (get (adp-offset (untag (r-pc r)))
                 (program-body (assoc (adp-name (untag (r-pc r)))
                                      (r-prog-segment r))))))
          (r-prog-segment r))))
       (length
        (temp-var-dcls
         (assoc
          (cadr
           (unlabel
            (get (adp-offset (untag (r-pc r)))
                 (program-body (assoc (adp-name (untag (r-pc r)))
                                      (r-prog-segment r))))))
          (r-prog-segment r))))))))
   (equal
    (lessp
     (difference
      (sub1 (sub1 (adp-offset (untag (r-csp r)))))
      (length
       (temp-var-dcls
        (assoc
         (cadr (unlabel (get (adp-offset (untag (r-pc r)))
                             (program-body (assoc (adp-name (untag (r-pc r)))
                                                  (r-prog-segment r))))))
         (r-prog-segment r)))))
     (length
      (formal-vars
       (assoc (cadr (unlabel
                     (get (adp-offset (untag (r-pc r)))
                          (program-body (assoc (adp-name (untag (r-pc r)))
                                               (r-prog-segment r))))))
              (r-prog-segment r)))))
    f)))

; The sixth hypothesis of i*-prelude2 also requires work.  The problem
; is that by the time we get around to asking the stk-length of tstk for
; prelude2 we have done some deposits into sys-data-segment and we must know
; that we haven't changed its length.  We have already proved that
; deposit-adp doesn't change the length, but now we must deal with
; deposit-lst.  In the case in point, we know the deposits have all
; gone into the cstk and we are interested in the length of the tstk.
; Rather than argue that no deposit-lst changes the length  of its
; area -- a theorem that requires the additional hypothesis that the
; length of the list scanned is sufficiently short -- I will prove
; this one:

(prove-lemma length-cdr-assoc-deposit-lst (rewrite)
  (implies (not (equal name (adp-name (untag adp))))
           (equal (length (cdr (assoc name (deposit-lst lst adp segment))))
                  (length (cdr (assoc name segment)))))
  ((induct (deposit-lst lst adp segment))
   (enable deposit-adp)))

; Now we finally turn to the arithmetic battles suggested by the fact
; that we don't know plus is commutative.  I don't want to add that
; rule; I don't want to even take the chance that it'll mess things
; up.  Instead I will prove each instance I need.

(prove-lemma commutativity-of-plus-application (rewrite)
  (equal
   (equal
    (sub-adp
     (untag (r-csp r))
     (add1
      (add1
       (plus
        (length
         (formal-vars
          (assoc name (r-prog-segment r))))
        (length
         (temp-var-dcls
          (assoc name (r-prog-segment r))))))))
    (sub-adp
     (untag (r-csp r))
     (add1
      (add1
       (plus
        (length
         (temp-var-dcls
          (assoc name (r-prog-segment r))))
        (length
         (formal-vars
          (assoc name (r-prog-segment r)))))))))
   t)
  ((use (commutativity-of-plus
         (x (length
             (temp-var-dcls
              (assoc name (r-prog-segment r)))))
         (y (length
             (formal-vars
              (assoc name (r-prog-segment r)))))))))

; And again, we have to consider the fact that the r level machine
; fetches all the args from tsp and then deposits them in csp
; while the i level machine does the fetches and deposits in an
; interleaved fashion.  We exploit, once again, the fact that
; we are fetching from one area and depositing into another.

(prove-lemma assoc-deposit-lst (rewrite)
  (implies (not (equal name (adp-name (untag csp))))
           (equal (assoc name (deposit-lst lst csp segment))
                  (assoc name segment)))
  ((induct (deposit-lst lst csp segment))
   (enable deposit-adp)))

(prove-lemma fetch-n-tstk-deposit-lst-cstk (rewrite)
  (implies (not (equal (adp-name (untag tsp))
                       (adp-name (untag csp))))
           (equal (fetch-n n tsp (deposit-lst lst csp segment))
                  (fetch-n n tsp segment)))
  ((enable fetch-adp deposit-adp)))

(prove-lemma call-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'call)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-call-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-call-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-call-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; We now turn to the pop-call instruction, which has basically
; the same proof as that just done.  There are a few
; minor differences.  Pop-call starts by doing a pop and
; requires that the tstk be non-empty:

(prove-lemma proper-r-state-implies-legal-r-tsp nil
  (implies (proper-r-statep r load-addr)
           (lessp (adp-offset (untag (r-tsp r)))
                  (length (cdr (assoc 'tstk
                                      (r-sys-data-segment r)))))))
(prove-lemma assoc-tstk (rewrite)
 (implies (proper-r-statep r load-addr)
          (listp (cdr (assoc 'tstk (r-sys-data-segment r)))))
 ((use (proper-r-state-implies-legal-r-tsp))))

; When r-pop-call-okp checks that the call is ok, it uses
; r-call-okp on a faked up r state.  r-call-okp checks, among
; other things, that all the temp-var-dcl values are r-objects
; in that faked up state.  But the 2nd hypothesis of i*-prelude1
; requires that they all be objects in r.  The following lemma
; establishes that:

(prove-lemma same-signature-implies-r-objectp (rewrite)
  (implies (and (r-objectp x r2)
                (equal (r-prog-segment r1) (r-prog-segment r2))
                (same-signature (r-usr-data-segment r1)
                                (r-usr-data-segment r2))
                (same-signature (r-sys-data-segment r1)
                                (r-sys-data-segment r2))
                (equal (r-word-size r1) (r-word-size r2)))
           (r-objectp x r1))
  ((enable r-objectp)))

(prove-lemma same-signature-implies-all-r-objectps (rewrite)
  (implies (and (all-r-objectps lst r2)
                (equal (r-prog-segment r1) (r-prog-segment r2))
                (same-signature (r-usr-data-segment r1)
                                (r-usr-data-segment r2))
                (same-signature (r-sys-data-segment r1)
                                (r-sys-data-segment r2))
                (equal (r-word-size r1) (r-word-size r2)))
           (all-r-objectps lst r1)))

(disable same-signature-implies-r-objectp)

; So now we can do pop-call.

(prove-lemma pop-call-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'pop-call)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-pop-call-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-pop-call-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-pop-call-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; So, now we turn to the ret instruction.  We begin with the study
; of the postlude.  First, you've got to find it.

(prove-lemma first-n-length-properp (rewrite)
  (implies (properp lst)
           (equal (first-n (length lst) lst) lst)))

(prove-lemma r-program-bodyp-implies-properp (rewrite)
  (implies (r-program-bodyp body)
           (properp body)))

(prove-lemma properp-program-body (rewrite)
  (implies (proper-r-statep r load-addr)
           (properp (program-body (assoc (adp-name (untag (r-pc r)))
                                                 (r-prog-segment r)))))
  ((use (r-program-bodyp-program-body))
   (disable r-program-bodyp-program-body
            r-program-bodyp-program-body-any)))

(prove-lemma find-label-postlude (rewrite)
  (implies (proper-r-statep r load-addr)
           (equal
            (find-label
             (cons
              (adp-name (untag (r-pc r)))
              (length (program-body (assoc (adp-name (untag (r-pc r)))
                                           (r-prog-segment r)))))
             (cdr (icompile-program (assoc (adp-name (untag (r-pc r)))
                                           (r-prog-segment r)))))
            (plus (length (generate-prelude
                           (assoc (adp-name (untag (r-pc r)))
                                  (r-prog-segment r))))
                  (length
                   (icompile-program-body (program-body
                                           (assoc (adp-name (untag (r-pc r)))
                                                  (r-prog-segment r)))
                                          0
                                          (assoc (adp-name (untag (r-pc r)))
                                                 (r-prog-segment r)))))))
                    
((disable length-generate-prelude)
 (enable icompile-program
         find-label-generate-postlude
         find-label-generate-prelude
         find-label-icompile-program-body
         find-label-append)))

; Then you've got to know what you get when you fetch from it:

(prove-lemma fetch-adp-postlude0 (rewrite)
  (implies
   (proper-r-statep r load-addr)
   (equal (FETCH-ADP
           (CONS
            (ADP-NAME (UNTAG (R-PC R)))
            (plus (length (generate-prelude
                           (assoc (adp-name (untag (r-pc r)))
                                  (r-prog-segment r))))
                  (length
                   (icompile-program-body (program-body
                                           (assoc (adp-name (untag (r-pc r)))
                                                  (r-prog-segment r)))
                                          0
                                          (assoc (adp-name (untag (r-pc r)))
                                                 (r-prog-segment r))))))
           (ICOMPILE (R-PROG-SEGMENT R)))
          (DL (CONS (ADP-NAME (UNTAG (R-PC R)))
                    (LENGTH (PROGRAM-BODY
                             (assoc (adp-name (untag (r-pc r)))
                                    (r-prog-segment r)))))
              '(postlude)
              '(MOVE_CSP_CFP))))
  ((disable ASSOCiativity-OF-PLUS PLUS-ADD1-FIRST LENGTH-GENERATE-PRELUDE)
   (enable fetch-adp icompile-program generate-postlude
           unconditional-get-append)))

(prove-lemma difference-add1-plus-i-j-i (rewrite)
  (equal (difference (add1 (plus i j)) i)
         (add1 j)))

(prove-lemma difference-add1-i-i (rewrite)
  (equal (difference (add1 i) i) 1))

(prove-lemma fetch-adp-postlude1 (rewrite)
  (implies
   (proper-r-statep r load-addr)
   (equal (FETCH-ADP
           (CONS
            (ADP-NAME (UNTAG (R-PC R)))
            (add1 
             (plus (length (generate-prelude
                            (assoc (adp-name (untag (r-pc r)))
                                   (r-prog-segment r))))
                   (length
                    (icompile-program-body (program-body
                                            (assoc (adp-name (untag (r-pc r)))
                                                   (r-prog-segment r)))
                                           0
                                           (assoc (adp-name (untag (r-pc r)))
                                                  (r-prog-segment r)))))))
           (ICOMPILE (R-PROG-SEGMENT R)))
          '(CPOP_CFP)))
  ((disable ASSOCiativity-OF-PLUS PLUS-ADD1-FIRST LENGTH-GENERATE-PRELUDE)
   (enable fetch-adp icompile-program generate-postlude
           unconditional-get-append)))

(disable difference-add1-plus-i-j-i)
(disable difference-add1-i-i)

(prove-lemma difference-add2-plus-i-j-i (rewrite)
  (equal (difference (add1 (add1 (plus i j))) i)
         (add1 (add1 j))))

(prove-lemma difference-add2-i-i (rewrite)
  (equal (difference (add1 (add1 i)) i) 2))

(prove-lemma fetch-adp-postlude2 (rewrite)
  (implies
   (proper-r-statep r load-addr)
   (equal (FETCH-ADP
           (CONS
            (ADP-NAME (UNTAG (R-PC R)))
            (add1
             (add1
              (plus (length (generate-prelude
                             (assoc (adp-name (untag (r-pc r)))
                                    (r-prog-segment r))))
                    (length
                     (icompile-program-body (program-body
                                             (assoc (adp-name (untag (r-pc r)))
                                                    (r-prog-segment r)))
                                            0
                                            (assoc (adp-name (untag (r-pc r)))
                                                   (r-prog-segment r))))))))
           (ICOMPILE (R-PROG-SEGMENT R)))
          '(CPOP_PC)))
  ((disable ASSOCiativity-OF-PLUS PLUS-ADD1-FIRST LENGTH-GENERATE-PRELUDE)
   (enable fetch-adp icompile-program generate-postlude
           unconditional-get-append)))

(disable difference-add2-plus-i-j-i)
(disable difference-add2-i-i)

(disable length-generate-prelude)

(prove-lemma length-icompile-program (rewrite)
  (equal (length (cdr (icompile-program prog)))
         (plus (length (generate-prelude prog))
               (length (icompile-program-body (program-body prog) 0 prog))
               3))
  ((enable icompile-program)))

; As usual in the cases involving jump we have to open up r->i_pc in
; the internal application (not in the fetch-execute cycle for this 
; instruction).

(prove-lemma r->i_pc-folder-ret-case (rewrite)
  (equal (tag 'ipc
              (cons
               (adp-name (untag (fetch-adp (add-adp (untag (r-cfp r)) 1)
                                           (r-sys-data-segment r))))
               (find-label
                (untag (fetch-adp (add-adp (untag (r-cfp r)) 1)
                                  (r-sys-data-segment r)))
                (cdr
                 (icompile-program
                  (assoc
                   (adp-name (untag (fetch-adp (add-adp (untag (r-cfp r)) 1)
                                               (r-sys-data-segment r))))
                   (r-prog-segment r)))))))
         (r->i_pc (fetch-adp (add-adp (untag (r-cfp r)) 1)
                             (r-sys-data-segment r))
                  (r-prog-segment r)))
   ((enable r->i_pc)))

(prove-lemma ret-one-way-correspondence-r-i (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ret)
                (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-ret-okp (r-current-instruction r)
                                   r))
           (equal (r->i (r-ret-step (r-current-instruction r)
                                            r))
                  (i (r->i r)
                     (r-ret-step-clock
                      (r-current-instruction r)
                      r) load-addr))))

; We now begin the proof of the invariance of proper-r-statep
; under the r-step function.  The theorem is needed to relieve the
; proper-r-statep hypothesis in our induction hypothesis for the
; owc theorem.

; The proof proceeds exactly as you would expect, one lemma for
; each r-level instruction.

; First, however, we prove a key fact about proper-r-statep.
; The idea is that if r is proper and r' is obtained from r by 
; modifying certain of the fields, e.g., pushing on r-tsp, 
; what must we establish to show that r' is proper?  We
; lay all this out in the proper-r-statep-r-state lemma below.

(prove-lemma equal-lessp-rewriter (rewrite)
  (equal (equal (lessp x y) z)
         (and (implies (lessp x y) (equal t z))
              (implies (not (lessp x y)) (equal f z)))))

(prove-lemma same-signature-segment-length (rewrite)
  (implies (same-signature segment1 segment2)
           (equal (segment-length segment2) (segment-length segment1))))

(prove-lemma same-signature-implies-r-objectp-rewriter (rewrite)
  (implies 
   (and (proper-r-statep r load-addr) 
        (same-signature (r-sys-data-segment r) 
                        r-sys-data-segment) 
        (same-signature (r-usr-data-segment r) 
                        r-usr-data-segment))
   (equal
    (r-objectp x
               (r-state r-pc r-cfp r-csp r-tsp r-x r-y 
                        r-c-flg r-v-flg r-n-flg 
                        r-z-flg 
                        (r-prog-segment r) 
                        r-usr-data-segment 
                        r-sys-data-segment 
                        (r-word-size r) 
                        r-psw))
    (r-objectp x r)))
 ((enable r-objectp)))

(prove-lemma same-signature-implies-all-r-usr-data-objectps (rewrite)
  (implies 
   (and (proper-r-statep r load-addr) 
        (same-signature (r-sys-data-segment r) 
                        r-sys-data-segment) 
        (same-signature (r-usr-data-segment r) 
                        r-usr-data-segment))
   (equal
    (all-r-usr-data-objectps lst
                             (r-state r-pc r-cfp r-csp r-tsp r-x r-y 
                                      r-c-flg r-v-flg r-n-flg 
                                      r-z-flg 
                                      (r-prog-segment r) 
                                      r-usr-data-segment 
                                      r-sys-data-segment 
                                      (r-word-size r) 
                                      r-psw))
    (all-r-usr-data-objectps lst r))))

(prove-lemma same-signature-implies-proper-r-usr-data-segmentp (rewrite)
  (implies 
   (and (proper-r-statep r load-addr) 
        (same-signature (r-sys-data-segment r) 
                        r-sys-data-segment) 
        (same-signature (r-usr-data-segment r) 
                        r-usr-data-segment))
   (equal
    (proper-r-usr-data-segmentp lst
                                (r-state r-pc r-cfp r-csp r-tsp r-x r-y 
                                         r-c-flg r-v-flg r-n-flg 
                                         r-z-flg 
                                         (r-prog-segment r) 
                                         r-usr-data-segment 
                                         r-sys-data-segment 
                                         (r-word-size r) 
                                         r-psw))
    (proper-r-usr-data-segmentp lst r))))


; Here is the main theorem of this section.  This is really a
; beautiful result because it says that proper-r-statep can
; be opened up on an explicit r-state, r', that is weakly related
; to another r-state, r,  (as delivered by the
; step functions) provided  r was proper and
; has the same signatures for the sys and usr data segments.
; These hypotheses should be easy to get, given our existing
; work.

; But when we "open" proper-r-statep on r' we don't actually use
; r' but r in the various checks.  For example, we require that
; the new r-tsp be a tstkp in r, not in r' as the defn would
; require.  They are equivalent, of course, but by reducing
; the conditions to facts about r we render most of them obvious.
; The reason for this is that a typical step will change a few of
; the fields and leave the rest untouched.  Those that are untouched
; will be proper by the properness of r.

; The hint below, to expand (proper-r-statep r' load-addr), is ugly.  At first
; I just enabled proper-r-statep.  But that is suicide.  The reason is
; that we have an enormous number of rules that back chain to proper-r-statep
; and if it is enabled, those rules kill us.

(prove-lemma proper-r-statep-r-state (rewrite) 
  (implies (and (proper-r-statep r load-addr)
                (same-signature (r-sys-data-segment r) r-sys-data-segment)
                (same-signature (r-usr-data-segment r) r-usr-data-segment))
           (equal (proper-r-statep
                   (r-state r-pc
                            r-cfp
                            r-csp
                            r-tsp
                            r-x
                            r-y
                            r-c-flg
                            r-v-flg
                            r-n-flg
                            r-z-flg
                            (r-prog-segment r)
                            r-usr-data-segment
                            r-sys-data-segment
                            (r-word-size r)
                            r-psw) load-addr)
                  (and (r-objectp-type 'pc r-pc r)
                       (cstkp r-cfp (r-sys-data-segment r))
                       (cstkp r-csp (r-sys-data-segment r))
                       (tstkp r-tsp (r-sys-data-segment r))
                       (equal (definition 'full-ctrl-stk-addr
                                r-sys-data-segment)
                              (list 'full-ctrl-stk-addr
                                    (tag 'sys-addr '(cstk . 0))))
                       (equal (definition 'full-temp-stk-addr
                                r-sys-data-segment)
                              (list 'full-temp-stk-addr
                                    (tag 'sys-addr '(tstk . 0))))
                       (equal (definition 'empty-temp-stk-addr
                                r-sys-data-segment)
                              (list 'empty-temp-stk-addr
                                    (tag 'sys-addr
                                         (cons 'tstk
                                               (sub1
                                                (length
                                                 (definiens
                                                  'tstk
                                                   r-sys-data-segment)))))))
                       (r-objectp-type 'bool r-c-flg r)
                       (r-objectp-type 'bool r-v-flg r)
                       (r-objectp-type 'bool r-n-flg r)
                       (r-objectp-type 'bool r-z-flg r)
                       (proper-r-usr-data-segmentp r-usr-data-segment r))))
   ((expand (proper-r-statep
             (r-state r-pc
                      r-cfp
                      r-csp
                      r-tsp
                      r-x
                      r-y
                      r-c-flg
                      r-v-flg
                      r-n-flg
                      r-z-flg
                      (r-prog-segment r)
                      r-usr-data-segment
                      r-sys-data-segment
                      (r-word-size r)
                      r-psw) load-addr))))
          
(disable same-signature-segment-length)
(disable equal-lessp-rewriter)

                                       


(prove-lemma no-op-preserves-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-no-op-okp (r-current-instruction r) r))
           (proper-r-statep
            (r-no-op-step (r-current-instruction r) r) load-addr)))

; This lemma is similar to fetch-adp-deposit-adp, but we are
; interested in the entire area assoc finds, not just the
; contents of a given location.

(prove-lemma assoc-deposit-adp (rewrite)
  (implies (not (equal name (adp-name adp)))
           (equal (assoc name (deposit-adp val adp segment))
                  (assoc name segment)))
  ((enable deposit-adp)))

(prove-lemma push-global-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-global-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-push-global-step (r-current-instruction r)
                                 r) load-addr)))

(prove-lemma push-local-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-local-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-push-local-step (r-current-instruction r)
                                r) load-addr)))

(prove-lemma push-constant-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-constant-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-push-constant-step (r-current-instruction r)
                                   r) load-addr)))

(prove-lemma push-ctrl-stk-free-size-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-ctrl-stk-free-size-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-push-ctrl-stk-free-size-step
              (r-current-instruction r)
              r) load-addr)))

(prove-lemma push-temp-stk-free-size-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-temp-stk-free-size-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-push-temp-stk-free-size-step
              (r-current-instruction r)
              r) load-addr)))

(prove-lemma push-temp-stk-index-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-push-temp-stk-index-okp (r-current-instruction r)
                                           r))
           (proper-r-statep
            (r-push-temp-stk-index-step
             (r-current-instruction r)
             r) load-addr)))

(prove-lemma pop-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop-step (r-current-instruction r)
                         r) load-addr)))

(prove-lemma pop*-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop*-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop*-step (r-current-instruction r)
                               r) load-addr)))

(prove-lemma popn-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-popn-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-popn-step (r-current-instruction r)
                               r) load-addr)))

(prove-lemma pop-local-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop-local-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop-local-step (r-current-instruction r)
                               r) load-addr)))

; This lemma is just like litatom-adp-name above except
; is about (cadr (unlabel x)) instead of (adp-name adp).
; As noted earlier, it actually has nothing to do with
; cadr or adp-name; it is an instance of a more general
; (but unusable) rule about proper-alists and litatom.

(prove-lemma litatom-cadr-unlabel (rewrite)
  (implies (and (definedp (cadr (unlabel x)) segment)
                (proper-alistp segment))
           (litatom (cadr (unlabel x)))))

; Here is another fundamental fact:

(prove-lemma all-r-usr-data-objectps-put (rewrite)
  (implies (and (lessp n (length lst))
                (r-usr-data-objectp x r)
                (all-r-usr-data-objectps lst r))
           (all-r-usr-data-objectps (put x n lst) r)))

(prove-lemma not-definedp-put-assoc (rewrite)
  (implies (not (definedp name1 alist))
           (not (definedp name1 (put-assoc val name2 alist)))))

(prove-lemma proper-r-usr-data-segmentp-deposit-adp (rewrite)
  (implies (and (adpp adp segment)
                (proper-r-usr-data-segmentp segment r)
                (r-usr-data-objectp val r))
           (proper-r-usr-data-segmentp (deposit-adp val adp segment)
                                        r))
  ((enable adpp deposit-adp)))

(prove-lemma pop-global-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop-global-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop-global-step (r-current-instruction r)
                                r) load-addr)))

(prove-lemma set-local-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-set-local-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-set-local-step (r-current-instruction r)
                               r) load-addr)))

(prove-lemma set-global-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-set-global-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-set-global-step (r-current-instruction r)
                                r) load-addr)))

(prove-lemma jump-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-jump-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-jump-step (r-current-instruction r)
                          r) load-addr)))

(prove-lemma pushj-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pushj-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pushj-step (r-current-instruction r)
                           r) load-addr)))

(prove-lemma popj-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-popj-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-popj-step (r-current-instruction r)
                          r) load-addr)))

(prove-lemma add-addr-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add-addr-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add-addr-step (r-current-instruction r)
                              r) load-addr))
  ((disable fetch-adp)))

(prove-lemma sub-addr-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub-addr-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub-addr-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma eq-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-eq-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-eq-step (r-current-instruction r)
                        r) load-addr)))

(prove-lemma lt-addr-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-lt-addr-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-lt-addr-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma fetch-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-fetch-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-fetch-step (r-current-instruction r)
                           r) load-addr)))

(prove-lemma litatom-adp-name-instance (rewrite)
  (implies (and (adpp (untag (fetch-adp (untag (r-tsp r))
                                        (r-sys-data-segment r)))
                      (r-usr-data-segment r))
                (proper-alistp (r-usr-data-segment r)))
           (litatom
            (adp-name
             (untag (fetch-adp (untag (r-tsp r))
                               (r-sys-data-segment r))))))
  ((enable adpp)))

(prove-lemma not-zerop-sub1-difference (rewrite)
  (equal (equal (sub1 (difference x y)) 0)
         (not (lessp y (sub1 x)))))

(prove-lemma not-empty-stkp-implies-adpp-add-adp (rewrite)
  (implies (and (adpp adp segment)
                (not (empty-stkp (tag 'sys-addr (add-adp adp n))
                                 segment))
                (numberp n))
           (adpp (add-adp adp (add1 n)) segment))
  ((enable adpp empty-stkp add-adp)))

(prove-lemma deposit-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-deposit-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-deposit-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma fetch-temp-stk-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-fetch-temp-stk-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-fetch-temp-stk-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma deposit-temp-stk-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-deposit-temp-stk-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-deposit-temp-stk-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma add-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add-int-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add-int-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma add-int-with-carry-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add-int-with-carry-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add-int-with-carry-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma add1-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add1-int-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add1-int-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma sub-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub-int-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub-int-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma sub-int-with-carry-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub-int-with-carry-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub-int-with-carry-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma sub1-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub1-int-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub1-int-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma neg-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-neg-int-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-neg-int-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma lt-int-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-lt-int-okp (r-current-instruction r)
                              r))
           (proper-r-statep
            (r-lt-int-step (r-current-instruction r)
                           r) load-addr)))

(prove-lemma int-to-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-int-to-nat-okp (r-current-instruction r)
                              r))
           (proper-r-statep
            (r-int-to-nat-step (r-current-instruction r)
                           r) load-addr)))

(prove-lemma add-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add-nat-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma add-nat-with-carry-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add-nat-with-carry-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add-nat-with-carry-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma add1-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-add1-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-add1-nat-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma sub-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub-nat-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma sub-nat-with-carry-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub-nat-with-carry-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub-nat-with-carry-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma sub1-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-sub1-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-sub1-nat-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma lt-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-lt-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-lt-nat-step (r-current-instruction r)
                            r) load-addr)))

(prove-lemma mult2-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-mult2-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-mult2-nat-step (r-current-instruction r)
                               r) load-addr)))

(prove-lemma mult2-nat-with-carry-out-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-mult2-nat-with-carry-out-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-mult2-nat-with-carry-out-step
              (r-current-instruction r)
              r) load-addr)))

(prove-lemma div2-nat-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-div2-nat-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-div2-nat-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma or-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-or-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-or-bitv-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma and-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-and-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-and-bitv-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma not-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-not-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-not-bitv-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma xor-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-xor-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-xor-bitv-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma rsh-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-rsh-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-rsh-bitv-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma lsh-bitv-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-lsh-bitv-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-lsh-bitv-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma or-bool-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-or-bool-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-or-bool-step (r-current-instruction r)
                             r) load-addr)))

(prove-lemma and-bool-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-and-bool-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-and-bool-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma not-bool-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-not-bool-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-not-bool-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma jump-if-temp-stk-full-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-jump-if-temp-stk-full-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-jump-if-temp-stk-full-step (r-current-instruction r)
                                           r) load-addr)))

(prove-lemma jump-if-temp-stk-empty-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-jump-if-temp-stk-empty-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-jump-if-temp-stk-empty-step
              (r-current-instruction r)
              r) load-addr))
  ((enable empty-stkp)))

(prove-lemma test-nat-and-jump-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-test-nat-and-jump-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-test-nat-and-jump-step (r-current-instruction r)
                                       r) load-addr)))

(prove-lemma test-int-and-jump-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-test-int-and-jump-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-test-int-and-jump-step (r-current-instruction r)
                                       r) load-addr)))

(prove-lemma test-bool-and-jump-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-test-bool-and-jump-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-test-bool-and-jump-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma test-bitv-and-jump-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-test-bitv-and-jump-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-test-bitv-and-jump-step (r-current-instruction r)
                                        r) load-addr)))

(prove-lemma pop-locn-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop-locn-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop-locn-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma locn-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-locn-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-locn-step (r-current-instruction r)
                          r) load-addr)))

(prove-lemma jump-case-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-jump-case-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-jump-case-step (r-current-instruction r)
                               r) load-addr)))

(prove-lemma same-signature-deposit-lst (rewrite)
  (implies (and (adpp (untag sp) segment2)
                (litatom (adp-name (untag sp)))
                (not (lessp (add1 (adp-offset (untag sp))) (length lst))))
           (equal (same-signature segment1 (deposit-lst lst sp segment2))
                  (same-signature segment1 segment2)))
  ((induct (deposit-lst lst sp segment2))))

(prove-lemma length-fetch-n (rewrite)
 (equal (length (fetch-n n sp segment)) (fix n)))

; In the call case, the same-signature-deposit-lst lemma is used twice
; in establishing the sys-data-segment same-signature hyp of the 
; proper-r-statep-r-state theorem.  The first time is to strip off
; the deposit-lst across the formals and the second is to strip off
; the deposit-lst across the temp-var-dcls.  Both times we have to
; prove the third hyp of same-signature-deposit-lst lemma, the one
; that says there is enough room on the stack to push everything in
; the list.  The problem, as always, is that DIFFERENCE is messing
; things up.  We need a lemma for each occasion.

(prove-lemma same-signature-deposit-lst-hyp-3-reliever-1 (rewrite)
  (implies (not (lessp c (plus y x)))
           (equal (lessp (if (equal c 0) 0 (difference (sub1 c) x))
                         (sub1 y))
                  f)))

(prove-lemma same-signature-deposit-lst-hyp-3-reliever-2 (rewrite)
  (implies (not (lessp c (plus y x)))
           (equal (lessp (if (equal c 0) 0 (sub1 c))
                         (sub1 x))
                  f)))

; Historical Note:  Until I got to the call case, I was unaware that
; it has been assumed that program bodies are always listps.  Otherwise,
; setting the pc to 0 on call would be illegal.  I had to add the listp
; requirement to r-programp to get call to go through.

(prove-lemma listp-program-body-generalized nil
  (implies (and (r-prog-segmentp segment)
                (definedp name segment))
           (listp (program-body (assoc name segment))))
  ((enable r-programp)))

(prove-lemma listp-program-body (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (definedp name (r-prog-segment r)))
           (listp (program-body (assoc name (r-prog-segment r)))))
  ((use (listp-program-body-generalized (segment (r-prog-segment r))))))

(prove-lemma call-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-call-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-call-step (r-current-instruction r)
                          r) load-addr)))

(prove-lemma pop-call-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-pop-call-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-pop-call-step (r-current-instruction r)
                              r) load-addr)))

(prove-lemma ret-proper-r-statep (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (proper-r-statep r load-addr)
                (r-ret-okp (r-current-instruction r)
                                   r))
            (proper-r-statep
             (r-ret-step (r-current-instruction r)
                         r) load-addr)))

; I will now disable all the individual okp, step, and clock functions.

(disable r-call-okp)
(disable r-call-step)
(disable r-call-step-clock)
(disable r-ret-okp)
(disable r-ret-step)
(disable r-ret-step-clock)
(disable r-locn-okp)
(disable r-locn-step)
(disable r-locn-step-clock)
(disable r-push-constant-okp)
(disable r-push-constant-step)
(disable r-push-constant-step-clock)
(disable r-push-local-okp)
(disable r-push-local-step)
(disable r-push-local-step-clock)
(disable r-push-global-okp)
(disable r-push-global-step)
(disable r-push-global-step-clock)
(disable r-push-ctrl-stk-free-size-okp)
(disable r-push-ctrl-stk-free-size-step)
(disable r-push-ctrl-stk-free-size-step-clock)
(disable r-push-temp-stk-free-size-okp)
(disable r-push-temp-stk-free-size-step)
(disable r-push-temp-stk-free-size-step-clock)
(disable r-push-temp-stk-index-okp)
(disable r-push-temp-stk-index-step)
(disable r-push-temp-stk-index-step-clock)
(disable r-jump-if-temp-stk-full-okp)
(disable r-jump-if-temp-stk-full-step)
(disable r-jump-if-temp-stk-full-step-clock)
(disable r-jump-if-temp-stk-empty-okp)
(disable r-jump-if-temp-stk-empty-step)
(disable r-jump-if-temp-stk-empty-step-clock)
(disable r-pop-okp)
(disable r-pop-step)
(disable r-pop-step-clock)
(disable r-pop*-okp)
(disable r-pop*-step)
(disable r-pop*-step-clock)
(disable r-popn-okp)
(disable r-popn-step)
(disable r-popn-step-clock)
(disable r-pop-local-okp)
(disable r-pop-local-step)
(disable r-pop-local-step-clock)
(disable r-pop-global-okp)
(disable r-pop-global-step)
(disable r-pop-global-step-clock)
(disable r-pop-locn-okp)
(disable r-pop-locn-step)
(disable r-pop-locn-step-clock)
(disable r-pop-call-okp)
(disable r-pop-call-step)
(disable r-pop-call-step-clock)
(disable r-fetch-temp-stk-okp)
(disable r-fetch-temp-stk-step)
(disable r-fetch-temp-stk-step-clock)
(disable r-deposit-temp-stk-okp)
(disable r-deposit-temp-stk-step)
(disable r-deposit-temp-stk-step-clock)
(disable r-jump-okp)
(disable r-jump-step)
(disable r-jump-step-clock)
(disable r-jump-case-okp)
(disable r-jump-case-step)
(disable r-jump-case-step-clock)
(disable r-pushj-okp)
(disable r-pushj-step)
(disable r-pushj-step-clock)
(disable r-popj-okp)
(disable r-popj-step)
(disable r-popj-step-clock)
(disable r-set-local-okp)
(disable r-set-local-step)
(disable r-set-local-step-clock)
(disable r-set-global-okp)
(disable r-set-global-step)
(disable r-set-global-step-clock)
(disable r-test-nat-and-jump-okp)
(disable r-test-nat-and-jump-step)
(disable r-test-nat-and-jump-step-clock)
(disable r-test-int-and-jump-okp)
(disable r-test-int-and-jump-step)
(disable r-test-int-and-jump-step-clock)
(disable r-test-bool-and-jump-okp)
(disable r-test-bool-and-jump-step)
(disable r-test-bool-and-jump-step-clock)
(disable r-test-bitv-and-jump-okp)
(disable r-test-bitv-and-jump-step)
(disable r-test-bitv-and-jump-step-clock)
(disable r-no-op-okp)
(disable r-no-op-step)
(disable r-no-op-step-clock)
(disable r-add-addr-okp)
(disable r-add-addr-step)
(disable r-add-addr-step-clock)
(disable r-sub-addr-okp)
(disable r-sub-addr-step)
(disable r-sub-addr-step-clock)
(disable r-eq-okp)
(disable r-eq-step)
(disable r-eq-step-clock)
(disable r-lt-addr-okp)
(disable r-lt-addr-step)
(disable r-lt-addr-step-clock)
(disable r-fetch-okp)
(disable r-fetch-step)
(disable r-fetch-step-clock)
(disable r-deposit-okp)
(disable r-deposit-step)
(disable r-deposit-step-clock)
(disable r-add-int-okp)
(disable r-add-int-step)
(disable r-add-int-step-clock)
(disable r-add-int-with-carry-okp)
(disable r-add-int-with-carry-step)
(disable r-add-int-with-carry-step-clock)
(disable r-add1-int-okp)
(disable r-add1-int-step)
(disable r-add1-int-step-clock)
(disable r-sub-int-okp)
(disable r-sub-int-step)
(disable r-sub-int-step-clock)
(disable r-sub-int-with-carry-okp)
(disable r-sub-int-with-carry-step)
(disable r-sub-int-with-carry-step-clock)
(disable r-sub1-int-okp)
(disable r-sub1-int-step)
(disable r-sub1-int-step-clock)
(disable r-neg-int-okp)
(disable r-neg-int-step)
(disable r-neg-int-step-clock)
(disable r-lt-int-okp)
(disable r-lt-int-step)
(disable r-lt-int-step-clock)
(disable r-int-to-nat-okp)
(disable r-int-to-nat-step)
(disable r-int-to-nat-step-clock)
(disable r-add-nat-okp)
(disable r-add-nat-step)
(disable r-add-nat-step-clock)
(disable r-add-nat-with-carry-okp)
(disable r-add-nat-with-carry-step)
(disable r-add-nat-with-carry-step-clock)
(disable r-add1-nat-okp)
(disable r-add1-nat-step)
(disable r-add1-nat-step-clock)
(disable r-sub-nat-okp)
(disable r-sub-nat-step)
(disable r-sub-nat-step-clock)
(disable r-sub-nat-with-carry-okp)
(disable r-sub-nat-with-carry-step)
(disable r-sub-nat-with-carry-step-clock)
(disable r-sub1-nat-okp)
(disable r-sub1-nat-step)
(disable r-sub1-nat-step-clock)
(disable r-lt-nat-okp)
(disable r-lt-nat-step)
(disable r-lt-nat-step-clock)
(disable r-mult2-nat-okp)
(disable r-mult2-nat-step)
(disable r-mult2-nat-step-clock)
(disable r-mult2-nat-with-carry-out-okp)
(disable r-mult2-nat-with-carry-out-step)
(disable r-mult2-nat-with-carry-out-step-clock)
(disable r-div2-nat-okp)
(disable r-div2-nat-step)
(disable r-div2-nat-step-clock)
(disable r-or-bitv-okp)
(disable r-or-bitv-step)
(disable r-or-bitv-step-clock)
(disable r-and-bitv-okp)
(disable r-and-bitv-step)
(disable r-and-bitv-step-clock)
(disable r-not-bitv-okp)
(disable r-not-bitv-step)
(disable r-not-bitv-step-clock)
(disable r-xor-bitv-okp)
(disable r-xor-bitv-step)
(disable r-xor-bitv-step-clock)
(disable r-rsh-bitv-okp)
(disable r-rsh-bitv-step)
(disable r-rsh-bitv-step-clock)
(disable r-lsh-bitv-okp)
(disable r-lsh-bitv-step)
(disable r-lsh-bitv-step-clock)
(disable r-or-bool-okp)
(disable r-or-bool-step)
(disable r-or-bool-step-clock)
(disable r-and-bool-okp)
(disable r-and-bool-step)
(disable r-and-bool-step-clock)
(disable r-not-bool-okp)
(disable r-not-bool-step)
(disable r-not-bool-step-clock)

; I now proceed to package all this up into two lemmas
; about r-step.  The first is that it preserves proper-r-statep.
; The second is the one-way-correspondence theorem for it.

(prove-lemma proper-r-statep-r-halt (rewrite)
  (implies (proper-r-statep r load-addr) (proper-r-statep (r-halt r psw) load-addr)))

; I am trying to control the case explosion produced by r-step.
; It has two sources, r-ins-okp and r-ins-step.  I have arbitrarily
; decided to disable r-ins-okp and let r-ins-step drive the case
; expansion.  To get away with disabling r-ins-okp I need to be
; able to establish all of the individual instruction okps from
; (r-ins-okp ins r).  Then, when the previously proved lemmas
; for particular instructions need a particular okp, they will
; find it here:

(prove-lemma r-ins-okp-backchainer (rewrite)
  (implies (r-ins-okp ins r)
           (and
            (implies (equal (car ins) 'call)
                     (r-call-okp ins r))
            (implies (equal (car ins) 'ret)
                     (r-ret-okp ins r))
            (implies (equal (car ins) 'locn)
                     (r-locn-okp ins r))
            (implies (equal (car ins) 'push-constant)
                     (r-push-constant-okp ins r))
            (implies (equal (car ins) 'push-local)
                     (r-push-local-okp ins r))
            (implies (equal (car ins) 'push-global)
                     (r-push-global-okp ins r))
            (implies (equal (car ins) 'push-ctrl-stk-free-size)
                     (r-push-ctrl-stk-free-size-okp ins r))
            (implies (equal (car ins) 'push-temp-stk-free-size)
                     (r-push-temp-stk-free-size-okp ins r))
            (implies (equal (car ins) 'push-temp-stk-index)
                     (r-push-temp-stk-index-okp ins r))
            (implies (equal (car ins) 'jump-if-temp-stk-full)
                     (r-jump-if-temp-stk-full-okp ins r))
            (implies (equal (car ins) 'jump-if-temp-stk-empty)
                     (r-jump-if-temp-stk-empty-okp ins r))
            (implies (equal (car ins) 'pop)
                     (r-pop-okp ins r))
            (implies (equal (car ins) 'pop*)
                     (r-pop*-okp ins r))
            (implies (equal (car ins) 'popn)
                     (r-popn-okp ins r))
            (implies (equal (car ins) 'pop-local)
                     (r-pop-local-okp ins r))
            (implies (equal (car ins) 'pop-global)
                     (r-pop-global-okp ins r))
            (implies (equal (car ins) 'pop-locn)
                     (r-pop-locn-okp ins r))
            (implies (equal (car ins) 'pop-call)
                     (r-pop-call-okp ins r))
            (implies (equal (car ins) 'fetch-temp-stk)
                     (r-fetch-temp-stk-okp ins r))
            (implies (equal (car ins) 'deposit-temp-stk)
                     (r-deposit-temp-stk-okp ins r))
            (implies (equal (car ins) 'jump)
                     (r-jump-okp ins r))
            (implies (equal (car ins) 'jump-case)
                     (r-jump-case-okp ins r))
            (implies (equal (car ins) 'pushj)
                     (r-pushj-okp ins r))
            (implies (equal (car ins) 'popj)
                     (r-popj-okp ins r))
            (implies (equal (car ins) 'set-local)
                     (r-set-local-okp ins r))
            (implies (equal (car ins) 'set-global)
                     (r-set-global-okp ins r))
            (implies (equal (car ins) 'test-nat-and-jump)
                     (r-test-nat-and-jump-okp ins r))
            (implies (equal (car ins) 'test-int-and-jump)
                     (r-test-int-and-jump-okp ins r))
            (implies (equal (car ins) 'test-bool-and-jump)
                     (r-test-bool-and-jump-okp ins r))
            (implies (equal (car ins) 'test-bitv-and-jump)
                     (r-test-bitv-and-jump-okp ins r))
            (implies (equal (car ins) 'no-op)
                     (r-no-op-okp ins r))
            (implies (equal (car ins) 'add-addr)
                     (r-add-addr-okp ins r))
            (implies (equal (car ins) 'sub-addr)
                     (r-sub-addr-okp ins r))
            (implies (equal (car ins) 'eq)
                     (r-eq-okp ins r))
            (implies (equal (car ins) 'lt-addr)
                     (r-lt-addr-okp ins r))
            (implies (equal (car ins) 'fetch)
                     (r-fetch-okp ins r))
            (implies (equal (car ins) 'deposit)
                     (r-deposit-okp ins r))
            (implies (equal (car ins) 'add-int)
                     (r-add-int-okp ins r))
            (implies (equal (car ins) 'add-int-with-carry)
                     (r-add-int-with-carry-okp ins r))
            (implies (equal (car ins) 'add1-int)
                     (r-add1-int-okp ins r))
            (implies (equal (car ins) 'sub-int)
                     (r-sub-int-okp ins r))
            (implies (equal (car ins) 'sub-int-with-carry)
                     (r-sub-int-with-carry-okp ins r))
            (implies (equal (car ins) 'sub1-int)
                     (r-sub1-int-okp ins r))
            (implies (equal (car ins) 'neg-int)
                     (r-neg-int-okp ins r))
            (implies (equal (car ins) 'lt-int)
                     (r-lt-int-okp ins r))
            (implies (equal (car ins) 'int-to-nat)
                     (r-int-to-nat-okp ins r))
            (implies (equal (car ins) 'add-nat)
                     (r-add-nat-okp ins r))
            (implies (equal (car ins) 'add-nat-with-carry)
                     (r-add-nat-with-carry-okp ins r))
            (implies (equal (car ins) 'add1-nat)
                     (r-add1-nat-okp ins r))
            (implies (equal (car ins) 'sub-nat)
                     (r-sub-nat-okp ins r))
            (implies (equal (car ins) 'sub-nat-with-carry)
                     (r-sub-nat-with-carry-okp ins r))
            (implies (equal (car ins) 'sub1-nat)
                     (r-sub1-nat-okp ins r))
            (implies (equal (car ins) 'lt-nat)
                     (r-lt-nat-okp ins r))
            (implies (equal (car ins) 'mult2-nat)
                     (r-mult2-nat-okp ins r))
            (implies (equal (car ins) 'mult2-nat-with-carry-out)
                     (r-mult2-nat-with-carry-out-okp ins r))
            (implies (equal (car ins) 'div2-nat)
                     (r-div2-nat-okp ins r))
            (implies (equal (car ins) 'or-bitv)
                     (r-or-bitv-okp ins r))
            (implies (equal (car ins) 'and-bitv)
                     (r-and-bitv-okp ins r))
            (implies (equal (car ins) 'not-bitv)
                     (r-not-bitv-okp ins r))
            (implies (equal (car ins) 'xor-bitv)
                     (r-xor-bitv-okp ins r))
            (implies (equal (car ins) 'rsh-bitv)
                     (r-rsh-bitv-okp ins r))
            (implies (equal (car ins) 'lsh-bitv)
                     (r-lsh-bitv-okp ins r))
            (implies (equal (car ins) 'or-bool)
                     (r-or-bool-okp ins r))
            (implies (equal (car ins) 'and-bool)
                     (r-and-bool-okp ins r))
            (implies (equal (car ins) 'not-bool)
                     (r-not-bool-okp ins r)))))

(disable r-ins-okp)

; The proof strategy I have in mind requires that the machine be able
; to walk all the way down the IF tree inside of a single r-ins-step.
; Unfortunately, we run out of stack space before we get there.  The
; solution is to define new versions of r-ins-step and
; r-ins-step-clock that are composed of two functions, each of which
; handles half of the instructions.

(defn r-ins-step2 (ins r)
  (case (car ins)
        (eq                     (r-eq-step ins r))
        (lt-addr                (r-lt-addr-step ins r))
        (fetch                  (r-fetch-step ins r))
        (deposit                (r-deposit-step ins r))
        (add-int                (r-add-int-step ins r))
        (add-int-with-carry     (r-add-int-with-carry-step ins r))
        (add1-int               (r-add1-int-step ins r))
        (sub-int                (r-sub-int-step ins r))
        (sub-int-with-carry     (r-sub-int-with-carry-step ins r))
        (sub1-int               (r-sub1-int-step ins r))
        (neg-int                (r-neg-int-step ins r))
        (lt-int                 (r-lt-int-step ins r))
        (int-to-nat             (r-int-to-nat-step ins r))
        (add-nat                (r-add-nat-step ins r))
        (add-nat-with-carry     (r-add-nat-with-carry-step ins r))
        (add1-nat               (r-add1-nat-step ins r))
        (sub-nat                (r-sub-nat-step ins r))
        (sub-nat-with-carry     (r-sub-nat-with-carry-step ins r))
        (sub1-nat               (r-sub1-nat-step ins r))
        (lt-nat                 (r-lt-nat-step ins r))
        (mult2-nat              (r-mult2-nat-step ins r))
        (mult2-nat-with-carry-out
         (r-mult2-nat-with-carry-out-step ins r))
        (div2-nat               (r-div2-nat-step ins r))
        (or-bitv                (r-or-bitv-step ins r))
        (and-bitv               (r-and-bitv-step ins r))
        (not-bitv               (r-not-bitv-step ins r))
        (xor-bitv               (r-xor-bitv-step ins r))
        (rsh-bitv               (r-rsh-bitv-step ins r))
        (lsh-bitv               (r-lsh-bitv-step ins r))
        (or-bool                (r-or-bool-step ins r))
        (and-bool               (r-and-bool-step ins r))
        (not-bool               (r-not-bool-step ins r))
        (otherwise              (r-halt r 'run))))

(defn r-ins-step1 (ins r)
  (case (car ins)
    (call                       (r-call-step ins r))
    (ret                        (r-ret-step ins r))
    (locn                       (r-locn-step ins r))
    (push-constant              (r-push-constant-step ins r))
    (push-local                 (r-push-local-step ins r))
    (push-global                (r-push-global-step ins r))
    (push-ctrl-stk-free-size    (r-push-ctrl-stk-free-size-step ins r))
    (push-temp-stk-free-size    (r-push-temp-stk-free-size-step ins r))
    (push-temp-stk-index        (r-push-temp-stk-index-step ins r))
    (jump-if-temp-stk-full      (r-jump-if-temp-stk-full-step ins r))
    (jump-if-temp-stk-empty     (r-jump-if-temp-stk-empty-step ins r))
    (pop                        (r-pop-step ins r))
    (pop*                       (r-pop*-step ins r))
    (popn                       (r-popn-step ins r))
    (pop-local                  (r-pop-local-step ins r))
    (pop-global                 (r-pop-global-step ins r))
    (pop-locn                   (r-pop-locn-step ins r))
    (pop-call                   (r-pop-call-step ins r))
    (fetch-temp-stk             (r-fetch-temp-stk-step ins r))
    (deposit-temp-stk           (r-deposit-temp-stk-step ins r))
    (jump                       (r-jump-step ins r))
    (jump-case                  (r-jump-case-step ins r))
    (pushj                      (r-pushj-step ins r))
    (popj                       (r-popj-step ins r))
    (set-local                  (r-set-local-step ins r))
    (set-global                 (r-set-global-step ins r))
    (test-nat-and-jump          (r-test-nat-and-jump-step ins r))
    (test-int-and-jump          (r-test-int-and-jump-step ins r))
    (test-bool-and-jump         (r-test-bool-and-jump-step ins r))
    (test-bitv-and-jump         (r-test-bitv-and-jump-step ins r))
    (no-op                      (r-no-op-step ins r))
    (add-addr                   (r-add-addr-step ins r))
    (sub-addr                   (r-sub-addr-step ins r))
    (otherwise                  (r-ins-step2 ins r))))

(defn r-ins-step-clock2 (ins r)
  (case (car ins)
        (eq                     (r-eq-step-clock ins r))
        (lt-addr                (r-lt-addr-step-clock ins r))
        (fetch                  (r-fetch-step-clock ins r))
        (deposit                (r-deposit-step-clock ins r))
        (add-int                (r-add-int-step-clock ins r))
        (add-int-with-carry     (r-add-int-with-carry-step-clock ins r))
        (add1-int               (r-add1-int-step-clock ins r))
        (sub-int                (r-sub-int-step-clock ins r))
        (sub-int-with-carry     (r-sub-int-with-carry-step-clock ins r))
        (sub1-int               (r-sub1-int-step-clock ins r))
        (neg-int                (r-neg-int-step-clock ins r))
        (lt-int                 (r-lt-int-step-clock ins r))
        (int-to-nat             (r-int-to-nat-step-clock ins r))
        (add-nat                (r-add-nat-step-clock ins r))
        (add-nat-with-carry     (r-add-nat-with-carry-step-clock ins r))
        (add1-nat               (r-add1-nat-step-clock ins r))
        (sub-nat                (r-sub-nat-step-clock ins r))
        (sub-nat-with-carry     (r-sub-nat-with-carry-step-clock ins r))
        (sub1-nat               (r-sub1-nat-step-clock ins r))
        (lt-nat                 (r-lt-nat-step-clock ins r))
        (mult2-nat              (r-mult2-nat-step-clock ins r))
        (mult2-nat-with-carry-out
         (r-mult2-nat-with-carry-out-step-clock ins r))
        (div2-nat               (r-div2-nat-step-clock ins r))
        (or-bitv                (r-or-bitv-step-clock ins r))
        (and-bitv               (r-and-bitv-step-clock ins r))
        (not-bitv               (r-not-bitv-step-clock ins r))
        (xor-bitv               (r-xor-bitv-step-clock ins r))
        (rsh-bitv               (r-rsh-bitv-step-clock ins r))
        (lsh-bitv               (r-lsh-bitv-step-clock ins r))
        (or-bool                (r-or-bool-step-clock ins r))
        (and-bool               (r-and-bool-step-clock ins r))
        (not-bool               (r-not-bool-step-clock ins r))
        (otherwise              0)))

(defn r-ins-step-clock1 (ins r)
  (case (car ins)
    (call                       (r-call-step-clock ins r))
    (ret                        (r-ret-step-clock ins r))
    (locn                       (r-locn-step-clock ins r))
    (push-constant              (r-push-constant-step-clock ins r))
    (push-local                 (r-push-local-step-clock ins r))
    (push-global                (r-push-global-step-clock ins r))
    (push-ctrl-stk-free-size    (r-push-ctrl-stk-free-size-step-clock ins r))
    (push-temp-stk-free-size    (r-push-temp-stk-free-size-step-clock ins r))
    (push-temp-stk-index        (r-push-temp-stk-index-step-clock ins r))
    (jump-if-temp-stk-full      (r-jump-if-temp-stk-full-step-clock ins r))
    (jump-if-temp-stk-empty     (r-jump-if-temp-stk-empty-step-clock ins r))
    (pop                        (r-pop-step-clock ins r))
    (pop*                       (r-pop*-step-clock ins r))
    (popn                       (r-popn-step-clock ins r))
    (pop-local                  (r-pop-local-step-clock ins r))
    (pop-global                 (r-pop-global-step-clock ins r))
    (pop-locn                   (r-pop-locn-step-clock ins r))
    (pop-call                   (r-pop-call-step-clock ins r))
    (fetch-temp-stk             (r-fetch-temp-stk-step-clock ins r))
    (deposit-temp-stk           (r-deposit-temp-stk-step-clock ins r))
    (jump                       (r-jump-step-clock ins r))
    (jump-case                  (r-jump-case-step-clock ins r))
    (pushj                      (r-pushj-step-clock ins r))
    (popj                       (r-popj-step-clock ins r))
    (set-local                  (r-set-local-step-clock ins r))
    (set-global                 (r-set-global-step-clock ins r))
    (test-nat-and-jump          (r-test-nat-and-jump-step-clock ins r))
    (test-int-and-jump          (r-test-int-and-jump-step-clock ins r))
    (test-bool-and-jump         (r-test-bool-and-jump-step-clock ins r))
    (test-bitv-and-jump         (r-test-bitv-and-jump-step-clock ins r))
    (no-op                      (r-no-op-step-clock ins r))
    (add-addr                   (r-add-addr-step-clock ins r))
    (sub-addr                   (r-sub-addr-step-clock ins r))
    (otherwise                  (r-ins-step-clock2 ins r))))

; We now prove these functions are equivalent to what we normally use:

(prove-lemma r-ins-step-is-r-ins-step1 (rewrite)
  (equal (r-ins-step ins r)
         (r-ins-step1 ins r)))

(prove-lemma r-ins-step-clock-is-r-ins-step-clock1 (rewrite)
  (equal (r-ins-step-clock ins r)
         (r-ins-step-clock1 ins r)))

(disable r-ins-step)
(disable r-ins-step-clock)

; Now we will prove that r-step preserves proper-r-statep.

; Consider (proper-r-statep (r-step r) load-addr).  The r-step will expand to ifs.
; We'll bring the ifs out of proper-r-statep with:

(prove-lemma proper-r-statep-if (rewrite)
  (equal (proper-r-statep (if a b c) load-addr)
         (if a (proper-r-statep b load-addr) (proper-r-statep c load-addr))))

; That will elevate the test a, which will be (r-ins-okp ins r) the first
; time and then particular instruction opcodes subsequently.  Under each
; particular assumption we'll have to prove (proper-r-statep b load-addr) where
; b will be the corresponding r-xxx-step.  Our just proved backchainer
; and our previously proved lemmas will hit each.  However, because we
; can't explore the full depth of r-ins-step, we will first do this for
; r-ins-step2 and then for r-step (which will expand into r-ins-step and
; hence into r-ins-step1, where it will then do the first half of the nest
; and then appeal to our r-ins-step2 work).

(disable r-current-instruction)

(prove-lemma proper-r-statep-r-ins-step2 (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (equal (r-psw r) 'run)
                (r-ins-okp (r-current-instruction r) r))
           (proper-r-statep (r-ins-step2 (r-current-instruction r) r) load-addr)))

(disable r-ins-step2)

(prove-lemma proper-r-statep-r-step (rewrite)
  (implies (proper-r-statep r load-addr)
           (proper-r-statep (r-step r) load-addr)))

; Note:  This was easier before I added Bill Young's requested 7 instructions.
; It was those 7 that put me beyond the depth of the stack!

; We repeat the exercise now, for one-way-correspondence.

; First we draw out the ifs.

(prove-lemma r->i-if (rewrite)
  (equal (r->i (if a b c)) (if a (r->i b) (r->i c))))

(prove-lemma i-if (rewrite)
  (equal (i r (if a b c) load-addr) (if a (i r b load-addr) (i r c load-addr))))

(prove-lemma equal-if-if (rewrite)
  (equal (equal (if a b c) (if a d e))
         (if a (equal b d) (equal c e))))

; Note how clever the above strategy is.  Without this lemma, which extracts
; the branches of two isomorphic if nests simultaneously from the arms of
; the equal, we would cross multiply the tests.

; Then we arrange for the error and termination cases.

(prove-lemma i-0 (rewrite)
  (equal (i i 0 load-addr) i)
  ((enable i)))

(prove-lemma r-halt-run (rewrite)
  (implies (and (r-statep r)
                (equal (r-psw r) 'run))
           (equal (r-halt r 'run) r)))

; Now we are really shooting for one-way-correspondence-r-i-step, below,
; but it has two occurrences of (r-step r) in it and I don't want to deal
; with them both at once.  So I'll first prove a mildly simplified version
; and then prove that if the (r-step r) is non-erroneous then the r-ins-okp
; below holds.

(prove-lemma one-way-correspondence-r-i-step2-simplified (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (numberp load-addr)
                (equal (r-psw r) 'run)
                (r-ins-okp (r-current-instruction r) r))
           (equal (r->i (r-ins-step2 (r-current-instruction r) r))
                  (i (r->i r)
                     (r-ins-step-clock2 (r-current-instruction r) r) load-addr)))
  ((enable r-ins-step2)))

(disable r-ins-step-clock2)

(prove-lemma one-way-correspondence-r-i-step-simplified nil
  (implies (and (proper-r-statep r load-addr)
                (numberp load-addr)
                (r-ins-okp (r-current-instruction r) r))
           (equal (r->i (r-step r))
                  (i (r->i r)
                     (r-step-clock r) load-addr))))

(prove-lemma r->i-r-halt (rewrite)
  (implies (equal (r-psw r) 'run)
           (equal (r->i (r-halt r 'halt))
                  (r->i r))))

(prove-lemma r-psw-r-halt (rewrite)
  (equal (r-psw (r-halt r psw)) psw))

; The double occurrence of r-step in the thm below makes its direct proof
; very explosive.  So I proved the simplified version above, from which this
; version is easy.

(prove-lemma one-way-correspondence-r-i-step (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (numberp load-addr)
                (not (errorp (r-psw (r-step r)))))
           (equal (r->i (r-step r))
                  (i (r->i r)
                     (r-step-clock r) load-addr)))
  ((use (one-way-correspondence-r-i-step-simplified))
   (disable r->i r-step1-clock r-ins-step r-ins-okp r-halt
            r-current-instruction)))

(prove-lemma i-plus (rewrite)
  (equal (i i (plus x y) load-addr)
         (i (i i x load-addr) y load-addr))
  ((enable i)
   (disable i-step)))

(prove-lemma once-errorp-always-errorp-step (rewrite)
  (implies (not (errorp (r-psw (r-step r))))
           (not (errorp (r-psw r))))
  ((disable r-ins-okp r-ins-step)))

(prove-lemma once-errorp-always-errorp (rewrite)
  (implies (not (errorp (r-psw (r r n))))
           (not (errorp (r-psw r))))
  ((disable r-step)))

(prove-lemma one-way-correspondence-r-i (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (numberp load-addr)
                (not (errorp (r-psw (r r n)))))
           (equal (r->i (r r n))
                  (i (r->i r)
                     (clock r n) load-addr)))
  ((disable errorp r-step r->i r-step-clock)))

(prove-lemma proper-r-statep-r (rewrite)
  (implies (proper-r-statep r load-addr)
           (proper-r-statep (r r n) load-addr))
  ((disable r-step)))

(prove-lemma all-r-usr-data-objectps-implies-all-i-usr-data-objectps 
  (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (all-r-usr-data-objectps lst r))
           (all-i-usr-data-objectps lst (r->i r))))

(prove-lemma proper-r-usr-data-segmentp-implies-proper-i-usr-data-segmentp
  nil
  (implies (and (proper-r-statep r load-addr)
                (proper-r-usr-data-segmentp segment r))
           (proper-i-usr-data-segmentp segment (r->i r)))
  ((disable r->i)))

(prove-lemma proper-r-statep-implies-proper-i-user-data-segmentp (rewrite)
  (implies (proper-r-statep r load-addr)
           (proper-i-usr-data-segmentp (r-usr-data-segment r)
                                       (r->i r)))
  ((use (proper-r-usr-data-segmentp-implies-proper-i-usr-data-segmentp
         (segment (r-usr-data-segment r))))))


; Book: p.events.  Finally, we define the p machine itself, the semantics
; of Piton.  

(set-status close-data-base-4 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

; We now build p-r.events from its subbooks.

(DEFN P-HALT
      (P PSW)
      (P-STATE (P-PC P)
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               PSW))

(DEFN RGET
      (N LST)
      (GET (SUB1 (DIFFERENCE (LENGTH LST) N))
           LST))

(DEFN RPUT
      (VAL N LST)
      (PUT VAL
           (SUB1 (DIFFERENCE (LENGTH LST) N))
           LST))

(DEFN PUSH (X STK) (CONS X STK))

(DEFN POPN
      (N X)
      (IF (ZEROP N)
          X
          (POPN (SUB1 N) (CDR X))))

(DEFN TOP1 (STK) (TOP (POP STK)))

(DEFN TOP2
      (STK)
      (TOP (POP (POP STK))))

(DEFN ALL-FIND-LABELP
      (LAB-LST LST)
      (IF (NLISTP LAB-LST)
          T
          (AND (FIND-LABELP (CAR LAB-LST) LST)
               (ALL-FIND-LABELP (CDR LAB-LST) LST))))

(DEFN P-OBJECTP
      (X P)
      (AND (LISTP X)
           (EQUAL (CDDR X) NIL)
           (CASE (TYPE X)
                 (NAT (SMALL-NATURALP (UNTAG X)
                                      (P-WORD-SIZE P)))
                 (INT (SMALL-INTEGERP (UNTAG X)
                                      (P-WORD-SIZE P)))
                 (BITV (BIT-VECTORP (UNTAG X)
                                    (P-WORD-SIZE P)))
                 (BOOL (BOOLEANP (UNTAG X)))
                 (ADDR (ADPP (UNTAG X) (P-DATA-SEGMENT P)))
                 (PC (PCPP (UNTAG X) (P-PROG-SEGMENT P)))
                 (SUBR (DEFINEDP (UNTAG X)
                                 (P-PROG-SEGMENT P)))
                 (OTHERWISE F))))

(DEFN P-OBJECTP-TYPE
      (TYPE X P)
      (AND (EQUAL (TYPE X) TYPE)
           (P-OBJECTP X P)))

(DEFN ALL-P-OBJECTPS
      (LST P)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (P-OBJECTP (CAR LST) P)
               (ALL-P-OBJECTPS (CDR LST) P))))

(DEFN ADD1-P-PC
      (P)
      (ADD1-ADDR (P-PC P)))

(DEFN P-CURRENT-PROGRAM
      (P)
      (DEFINITION (AREA-NAME (P-PC P))
                  (P-PROG-SEGMENT P)))

(DEFN P-CURRENT-INSTRUCTION
      (P)
      (UNLABEL (GET (OFFSET (P-PC P))
                    (PROGRAM-BODY (P-CURRENT-PROGRAM P)))))

(DEFN P-FRAME
      (BINDINGS RET-PC)
      (LIST BINDINGS RET-PC))

(DEFN LOCAL-VAR-VALUE
      (VAR CTRL-STK)
      (DEFINIENS VAR (BINDINGS (TOP CTRL-STK))))

(DEFN SET-LOCAL-VAR-VALUE
      (VAL VAR CTRL-STK)
      (PUSH (P-FRAME (PUT-VALUE VAL VAR
                                (BINDINGS (TOP CTRL-STK)))
                     (RET-PC (TOP CTRL-STK)))
            (POP CTRL-STK)))

(DEFN PAIR-FORMAL-VARS-WITH-ACTUALS
      (FORMAL-VARS TEMP-STK)
      (PAIRLIST FORMAL-VARS
                (REV (FIRST-N (LENGTH FORMAL-VARS)
                                  TEMP-STK))))

(DEFN PAIR-TEMPS-WITH-INITIAL-VALUES
      (TEMP-VAR-DCLS)
      (IF (NLISTP TEMP-VAR-DCLS)
          NIL
          (CONS (CONS (CAAR TEMP-VAR-DCLS)
                      (CADAR TEMP-VAR-DCLS))
                (PAIR-TEMPS-WITH-INITIAL-VALUES (CDR TEMP-VAR-DCLS)))))

(DEFN MAKE-P-CALL-FRAME
      (FORMAL-VARS TEMP-STK TEMP-VAR-DCLS RET-PC)
      (P-FRAME (APPEND (PAIR-FORMAL-VARS-WITH-ACTUALS FORMAL-VARS TEMP-STK)
                       (PAIR-TEMPS-WITH-INITIAL-VALUES TEMP-VAR-DCLS))
               RET-PC))

(DEFN P-CALL-OKP
 (INS P)
 (AND
  (NOT
   (LESSP
    (P-MAX-CTRL-STK-SIZE P)
    (P-CTRL-STK-SIZE
       (PUSH (MAKE-P-CALL-FRAME (FORMAL-VARS (DEFINITION (CADR INS)
                                                         (P-PROG-SEGMENT P)))
                                (P-TEMP-STK P)
                                (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                                           (P-PROG-SEGMENT P)))
                                (ADD1-ADDR (P-PC P)))
             (P-CTRL-STK P)))))
  (NOT (LESSP (LENGTH (P-TEMP-STK P))
              (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                               (P-PROG-SEGMENT P))))))))

(DEFN
 P-CALL-STEP
 (INS P)
 (P-STATE
       (TAG 'PC (CONS (CADR INS) 0))
       (PUSH (MAKE-P-CALL-FRAME (FORMAL-VARS (DEFINITION (CADR INS)
                                                         (P-PROG-SEGMENT P)))
                                (P-TEMP-STK P)
                                (TEMP-VAR-DCLS (DEFINITION (CADR INS)
                                                           (P-PROG-SEGMENT P)))
                                (ADD1-ADDR (P-PC P)))
             (P-CTRL-STK P))
       (POPN (LENGTH (FORMAL-VARS (DEFINITION (CADR INS)
                                              (P-PROG-SEGMENT P))))
             (P-TEMP-STK P))
       (P-PROG-SEGMENT P)
       (P-DATA-SEGMENT P)
       (P-MAX-CTRL-STK-SIZE P)
       (P-MAX-TEMP-STK-SIZE P)
       (P-WORD-SIZE P)
       'RUN))

(DEFN P-RET-OKP (INS P) T)

(DEFN P-RET-STEP
      (INS P)
      (IF (LISTP (POP (P-CTRL-STK P)))
          (P-STATE (RET-PC (TOP (P-CTRL-STK P)))
                   (POP (P-CTRL-STK P))
                   (P-TEMP-STK P)
                   (P-PROG-SEGMENT P)
                   (P-DATA-SEGMENT P)
                   (P-MAX-CTRL-STK-SIZE P)
                   (P-MAX-TEMP-STK-SIZE P)
                   (P-WORD-SIZE P)
                   'RUN)
          (P-HALT P 'HALT)))

(DEFN P-LOCN-OKP
      (INS P)
      (AND (P-OBJECTP-TYPE 'NAT
                           (LOCAL-VAR-VALUE (CADR INS)
                                            (P-CTRL-STK P))
                           P)
           (LESSP (UNTAG (LOCAL-VAR-VALUE (CADR INS)
                                          (P-CTRL-STK P)))
                  (LENGTH (BINDINGS (TOP (P-CTRL-STK P)))))
           (LESSP (LENGTH (P-TEMP-STK P))
                  (P-MAX-TEMP-STK-SIZE P))))

(DEFN P-LOCN-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (CDR (GET (UNTAG (LOCAL-VAR-VALUE (CADR INS)
                                                       (P-CTRL-STK P)))
                               (BINDINGS (TOP (P-CTRL-STK P)))))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-CONSTANT-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN UNABBREVIATE-CONSTANT
      (C P)
      (COND ((EQUAL C 'PC) (ADD1-P-PC P))
            ((NLISTP C)
             (PC C (P-CURRENT-PROGRAM P)))
            (T C)))

(DEFN P-PUSH-CONSTANT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (UNABBREVIATE-CONSTANT (CADR INS) P)
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-LOCAL-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN P-PUSH-LOCAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (LOCAL-VAR-VALUE (CADR INS)
                                      (P-CTRL-STK P))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-GLOBAL-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN P-PUSH-GLOBAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (FETCH (TAG 'ADDR (CONS (CADR INS) 0))
                            (P-DATA-SEGMENT P))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-CTRL-STK-FREE-SIZE-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN P-PUSH-CTRL-STK-FREE-SIZE-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (DIFFERENCE (P-MAX-CTRL-STK-SIZE P)
                                      (P-CTRL-STK-SIZE (P-CTRL-STK P))))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-TEMP-STK-FREE-SIZE-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN P-PUSH-TEMP-STK-FREE-SIZE-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (DIFFERENCE (P-MAX-TEMP-STK-SIZE P)
                                      (LENGTH (P-TEMP-STK P))))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSH-TEMP-STK-INDEX-OKP
      (INS P)
      (AND (LESSP (LENGTH (P-TEMP-STK P))
                  (P-MAX-TEMP-STK-SIZE P))
           (LESSP (CADR INS)
                  (LENGTH (P-TEMP-STK P)))))

(DEFN P-PUSH-TEMP-STK-INDEX-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (SUB1 (DIFFERENCE (LENGTH (P-TEMP-STK P))
                                            (CADR INS))))
                     (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-JUMP-IF-TEMP-STK-FULL-OKP
      (INS P)
      T)

(DEFN P-JUMP-IF-TEMP-STK-FULL-STEP
      (INS P)
      (P-STATE (IF (EQUAL (LENGTH (P-TEMP-STK P))
                          (P-MAX-TEMP-STK-SIZE P))
                   (PC (CADR INS) (P-CURRENT-PROGRAM P))
                   (ADD1-P-PC P))
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-JUMP-IF-TEMP-STK-EMPTY-OKP
      (INS P)
      T)

(DEFN P-JUMP-IF-TEMP-STK-EMPTY-STEP
      (INS P)
      (P-STATE (IF (ZEROP (LENGTH (P-TEMP-STK P)))
                   (PC (CADR INS) (P-CURRENT-PROGRAM P))
                   (ADD1-P-PC P))
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP-OKP
      (INS P)
      (LISTP (P-TEMP-STK P)))

(DEFN P-POP-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP*-OKP
      (INS P)
      (NOT (LESSP (LENGTH (P-TEMP-STK P))
                  (CADR INS))))

(DEFN P-POP*-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (POPN (CADR INS) (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POPN-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (NOT (LESSP (LENGTH (P-TEMP-STK P))
                       (ADD1 (UNTAG (TOP (P-TEMP-STK P))))))))

(DEFN P-POPN-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (POPN (UNTAG (TOP (P-TEMP-STK P)))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP-LOCAL-OKP
      (INS P)
      (LISTP (P-TEMP-STK P)))

(DEFN P-POP-LOCAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (SET-LOCAL-VAR-VALUE (TOP (P-TEMP-STK P))
                                    (CADR INS)
                                    (P-CTRL-STK P))
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP-GLOBAL-OKP
      (INS P)
      (LISTP (P-TEMP-STK P)))

(DEFN P-POP-GLOBAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (DEPOSIT (TOP (P-TEMP-STK P))
                        (TAG 'ADDR (CONS (CADR INS) 0))
                        (P-DATA-SEGMENT P))
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP-LOCN-OKP
      (INS P)
      (AND (P-OBJECTP-TYPE 'NAT
                           (LOCAL-VAR-VALUE (CADR INS)
                                            (P-CTRL-STK P))
                           P)
           (LESSP (UNTAG (LOCAL-VAR-VALUE (CADR INS)
                                          (P-CTRL-STK P)))
                  (LENGTH (BINDINGS (TOP (P-CTRL-STK P)))))
           (LISTP (P-TEMP-STK P))))

(DEFN PUT-VALUE-INDIRECT
      (VAL N LST)
      (IF (LISTP LST)
          (IF (ZEROP N)
              (CONS (CONS (CAAR LST) VAL) (CDR LST))
              (CONS (CAR LST)
                    (PUT-VALUE-INDIRECT VAL
                                        (SUB1 N)
                                        (CDR LST))))
          LST))

(DEFN SET-LOCAL-VAR-INDIRECT
      (VAL INDEX CTRL-STK)
      (PUSH (P-FRAME (PUT-VALUE-INDIRECT VAL INDEX
                                         (BINDINGS (TOP CTRL-STK)))
                     (RET-PC (TOP CTRL-STK)))
            (POP CTRL-STK)))

(DEFN P-POP-LOCN-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (SET-LOCAL-VAR-INDIRECT (TOP (P-TEMP-STK P))
                                       (UNTAG (LOCAL-VAR-VALUE (CADR INS)
                                                               (P-CTRL-STK P)))
                                       (P-CTRL-STK P))
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POP-CALL-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'SUBR
                           (TOP (P-TEMP-STK P))
                           P)
           (P-CALL-OKP (LIST 'CALL
                             (UNTAG (TOP (P-TEMP-STK P))))
                       (P-STATE (P-PC P)
                                (P-CTRL-STK P)
                                (POP (P-TEMP-STK P))
                                (P-PROG-SEGMENT P)
                                (P-DATA-SEGMENT P)
                                (P-MAX-CTRL-STK-SIZE P)
                                (P-MAX-TEMP-STK-SIZE P)
                                (P-WORD-SIZE P)
                                'RUN))))

(DEFN P-POP-CALL-STEP
      (INS P)
      (P-CALL-STEP (LIST 'CALL
                         (UNTAG (TOP (P-TEMP-STK P))))
                   (P-STATE (P-PC P)
                            (P-CTRL-STK P)
                            (POP (P-TEMP-STK P))
                            (P-PROG-SEGMENT P)
                            (P-DATA-SEGMENT P)
                            (P-MAX-CTRL-STK-SIZE P)
                            (P-MAX-TEMP-STK-SIZE P)
                            (P-WORD-SIZE P)
                            'RUN)))

(DEFN P-FETCH-TEMP-STK-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (LESSP (UNTAG (TOP (P-TEMP-STK P)))
                  (LENGTH (P-TEMP-STK P)))))

(DEFN P-FETCH-TEMP-STK-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (RGET (UNTAG (TOP (P-TEMP-STK P)))
                           (P-TEMP-STK P))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-DEPOSIT-TEMP-STK-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (LESSP (UNTAG (TOP (P-TEMP-STK P)))
                  (LENGTH (POP (POP (P-TEMP-STK P)))))))

(DEFN P-DEPOSIT-TEMP-STK-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (RPUT (TOP1 (P-TEMP-STK P))
                     (UNTAG (TOP (P-TEMP-STK P)))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-JUMP-OKP (INS P) T)

(DEFN P-JUMP-STEP
      (INS P)
      (P-STATE (PC (CADR INS) (P-CURRENT-PROGRAM P))
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-JUMP-CASE-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (LESSP (UNTAG (TOP (P-TEMP-STK P)))
                  (LENGTH (CDR INS)))))

(DEFN P-JUMP-CASE-STEP
      (INS P)
      (P-STATE (PC (GET (UNTAG (TOP (P-TEMP-STK P)))
                        (CDR INS))
                   (P-CURRENT-PROGRAM P))
               (P-CTRL-STK P)
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-PUSHJ-OKP
      (INS P)
      (LESSP (LENGTH (P-TEMP-STK P))
             (P-MAX-TEMP-STK-SIZE P)))

(DEFN P-PUSHJ-STEP
      (INS P)
      (P-STATE (PC (CADR INS) (P-CURRENT-PROGRAM P))
               (P-CTRL-STK P)
               (PUSH (ADD1-P-PC P) (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-POPJ-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'PC
                           (TOP (P-TEMP-STK P))
                           P)
           (EQUAL (AREA-NAME (TOP (P-TEMP-STK P)))
                  (AREA-NAME (P-PC P)))))

(DEFN P-POPJ-STEP
      (INS P)
      (P-STATE (TOP (P-TEMP-STK P))
               (P-CTRL-STK P)
               (POP (P-TEMP-STK P))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SET-LOCAL-OKP
      (INS P)
      (LISTP (P-TEMP-STK P)))

(DEFN P-SET-LOCAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (SET-LOCAL-VAR-VALUE (TOP (P-TEMP-STK P))
                                    (CADR INS)
                                    (P-CTRL-STK P))
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SET-GLOBAL-OKP
      (INS P)
      (LISTP (P-TEMP-STK P)))

(DEFN P-SET-GLOBAL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (DEPOSIT (TOP (P-TEMP-STK P))
                        (TAG 'ADDR (CONS (CADR INS) 0))
                        (P-DATA-SEGMENT P))
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-TEST-AND-JUMP-OKP
      (INS TYPE TEST P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE TYPE
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-TEST-AND-JUMP-STEP
      (TEST LAB P)
      (IF TEST
          (P-STATE (PC LAB (P-CURRENT-PROGRAM P))
                   (P-CTRL-STK P)
                   (POP (P-TEMP-STK P))
                   (P-PROG-SEGMENT P)
                   (P-DATA-SEGMENT P)
                   (P-MAX-CTRL-STK-SIZE P)
                   (P-MAX-TEMP-STK-SIZE P)
                   (P-WORD-SIZE P)
                   'RUN)
          (P-STATE (ADD1-P-PC P)
                   (P-CTRL-STK P)
                   (POP (P-TEMP-STK P))
                   (P-PROG-SEGMENT P)
                   (P-DATA-SEGMENT P)
                   (P-MAX-CTRL-STK-SIZE P)
                   (P-MAX-TEMP-STK-SIZE P)
                   (P-WORD-SIZE P)
                   'RUN)))


(DEFN P-TEST-NAT-AND-JUMP-OKP
      (INS P)
      (P-TEST-AND-JUMP-OKP INS 'NAT
                           (P-TEST-NATP (CADR INS)
                                        (UNTAG (TOP (P-TEMP-STK P))))
                           P))

(DEFN P-TEST-NAT-AND-JUMP-STEP
      (INS P)
      (P-TEST-AND-JUMP-STEP (P-TEST-NATP (CADR INS)
                                         (UNTAG (TOP (P-TEMP-STK P))))
                            (CADDR INS)
                            P))

(DEFN P-TEST-INT-AND-JUMP-OKP
      (INS P)
      (P-TEST-AND-JUMP-OKP INS 'INT
                           (P-TEST-INTP (CADR INS)
                                        (UNTAG (TOP (P-TEMP-STK P))))
                           P))

(DEFN P-TEST-INT-AND-JUMP-STEP
      (INS P)
      (P-TEST-AND-JUMP-STEP (P-TEST-INTP (CADR INS)
                                         (UNTAG (TOP (P-TEMP-STK P))))
                            (CADDR INS)
                            P))

(DEFN P-TEST-BOOL-AND-JUMP-OKP
      (INS P)
      (P-TEST-AND-JUMP-OKP INS 'BOOL
                           (P-TEST-BOOLP (CADR INS)
                                         (UNTAG (TOP (P-TEMP-STK P))))
                           P))

(DEFN P-TEST-BOOL-AND-JUMP-STEP
      (INS P)
      (P-TEST-AND-JUMP-STEP (P-TEST-BOOLP (CADR INS)
                                          (UNTAG (TOP (P-TEMP-STK P))))
                            (CADDR INS)
                            P))

(DEFN P-TEST-BITV-AND-JUMP-OKP
      (INS P)
      (P-TEST-AND-JUMP-OKP INS 'BITV
                           (P-TEST-BITVP (CADR INS)
                                         (UNTAG (TOP (P-TEMP-STK P))))
                           P))

(DEFN P-TEST-BITV-AND-JUMP-STEP
      (INS P)
      (P-TEST-AND-JUMP-STEP (P-TEST-BITVP (CADR INS)
                                          (UNTAG (TOP (P-TEMP-STK P))))
                            (CADDR INS)
                            P))

(DEFN P-NO-OP-OKP (INS P) T)

(DEFN P-NO-OP-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (P-TEMP-STK P)
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-ADD-ADDR-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'ADDR
                           (TOP1 (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'ADDR
                           (ADD-ADDR (TOP1 (P-TEMP-STK P))
                                     (UNTAG (TOP (P-TEMP-STK P))))
                           P)))

(DEFN P-ADD-ADDR-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (ADD-ADDR (TOP1 (P-TEMP-STK P))
                               (UNTAG (TOP (P-TEMP-STK P))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SUB-ADDR-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'ADDR
                           (TOP1 (P-TEMP-STK P))
                           P)
           (NOT (LESSP (OFFSET (TOP1 (P-TEMP-STK P)))
                       (UNTAG (TOP (P-TEMP-STK P)))))))

(DEFN P-SUB-ADDR-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (SUB-ADDR (TOP1 (P-TEMP-STK P))
                               (UNTAG (TOP (P-TEMP-STK P))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-EQ-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (EQUAL (TYPE (TOP (P-TEMP-STK P)))
                  (TYPE (TOP1 (P-TEMP-STK P))))))

(DEFN P-EQ-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (BOOL (EQUAL (UNTAG (TOP1 (P-TEMP-STK P)))
                                  (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-LT-ADDR-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'ADDR
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'ADDR
                           (TOP1 (P-TEMP-STK P))
                           P)
           (EQUAL (AREA-NAME (TOP (P-TEMP-STK P)))
                  (AREA-NAME (TOP1 (P-TEMP-STK P))))))

(DEFN P-LT-ADDR-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (BOOL (LESSP (OFFSET (TOP1 (P-TEMP-STK P)))
                                  (OFFSET (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-FETCH-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'ADDR
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-FETCH-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (FETCH (TOP (P-TEMP-STK P))
                            (P-DATA-SEGMENT P))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-DEPOSIT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'ADDR
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-DEPOSIT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (POP (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (DEPOSIT (TOP1 (P-TEMP-STK P))
                        (TOP (P-TEMP-STK P))
                        (P-DATA-SEGMENT P))
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-ADD-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'INT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (SMALL-INTEGERP (IPLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                  (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-ADD-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'INT
                          (IPLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                 (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-ADD-INT-WITH-CARRY-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (LISTP (POP (POP (P-TEMP-STK P))))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'INT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP2 (P-TEMP-STK P))
                           P)))

(DEFN P-ADD-INT-WITH-CARRY-STEP
 (INS P)
 (P-STATE
  (ADD1-P-PC P)
  (P-CTRL-STK P)
  (PUSH
   (TAG 'INT
        (FIX-SMALL-INTEGER (IPLUS (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))
                                  (IPLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                         (UNTAG (TOP (P-TEMP-STK P)))))
                           (P-WORD-SIZE P)))
   (PUSH
    (BOOL
        (NOT (SMALL-INTEGERP (IPLUS (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))
                                    (IPLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                           (UNTAG (TOP (P-TEMP-STK P)))))
                             (P-WORD-SIZE P))))
    (POP (POP (POP (P-TEMP-STK P))))))
  (P-PROG-SEGMENT P)
  (P-DATA-SEGMENT P)
  (P-MAX-CTRL-STK-SIZE P)
  (P-MAX-TEMP-STK-SIZE P)
  (P-WORD-SIZE P)
  'RUN))

(DEFN P-ADD1-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (SMALL-INTEGERP (IPLUS 1 (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-ADD1-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'INT
                          (IPLUS 1
                                 (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SUB-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'INT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                                        (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-SUB-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'INT
                          (IDIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                                       (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SUB-INT-WITH-CARRY-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (LISTP (POP (POP (P-TEMP-STK P))))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'INT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP2 (P-TEMP-STK P))
                           P)))

(DEFN P-SUB-INT-WITH-CARRY-STEP
 (INS P)
 (P-STATE
  (ADD1-P-PC P)
  (P-CTRL-STK P)
  (PUSH
   (TAG 'INT
    (FIX-SMALL-INTEGER
              (IDIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                           (IPLUS (UNTAG (TOP (P-TEMP-STK P)))
                                  (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))))
              (P-WORD-SIZE P)))
   (PUSH
    (BOOL
     (NOT
      (SMALL-INTEGERP
              (IDIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                           (IPLUS (UNTAG (TOP (P-TEMP-STK P)))
                                  (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))))
              (P-WORD-SIZE P))))
    (POP (POP (POP (P-TEMP-STK P))))))
  (P-PROG-SEGMENT P)
  (P-DATA-SEGMENT P)
  (P-MAX-CTRL-STK-SIZE P)
  (P-MAX-TEMP-STK-SIZE P)
  (P-WORD-SIZE P)
  'RUN))

(DEFN P-SUB1-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (SMALL-INTEGERP (IDIFFERENCE (UNTAG (TOP (P-TEMP-STK P)))
                                        1)
                           (P-WORD-SIZE P))))

(DEFN P-SUB1-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'INT
                          (IDIFFERENCE (UNTAG (TOP (P-TEMP-STK P)))
                                       1))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-NEG-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (SMALL-INTEGERP (INEGATE (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-NEG-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'INT
                          (INEGATE (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-LT-INT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'INT
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-LT-INT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (BOOL (ILESSP (UNTAG (TOP1 (P-TEMP-STK P)))
                                   (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-INT-TO-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'INT
                           (TOP (P-TEMP-STK P))
                           P)
           (NOT (NEGATIVEP (UNTAG (TOP (P-TEMP-STK P)))))))

(DEFN P-INT-TO-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (UNTAG (TOP (P-TEMP-STK P))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-ADD-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'NAT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (SMALL-NATURALP (PLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                 (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-ADD-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (PLUS (UNTAG (TOP1 (P-TEMP-STK P)))
                                (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-ADD-NAT-WITH-CARRY-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (LISTP (POP (POP (P-TEMP-STK P))))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'NAT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP2 (P-TEMP-STK P))
                           P)))

(DEFN P-ADD-NAT-WITH-CARRY-STEP
 (INS P)
 (P-STATE
  (ADD1-P-PC P)
  (P-CTRL-STK P)
  (PUSH
   (TAG 'NAT
        (FIX-SMALL-NATURAL (PLUS (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))
                                 (UNTAG (TOP1 (P-TEMP-STK P)))
                                 (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P)))
   (PUSH
    (BOOL
         (NOT (SMALL-NATURALP (PLUS (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))
                                    (UNTAG (TOP1 (P-TEMP-STK P)))
                                    (UNTAG (TOP (P-TEMP-STK P))))
                              (P-WORD-SIZE P))))
    (POP (POP (POP (P-TEMP-STK P))))))
  (P-PROG-SEGMENT P)
  (P-DATA-SEGMENT P)
  (P-MAX-CTRL-STK-SIZE P)
  (P-MAX-TEMP-STK-SIZE P)
  (P-WORD-SIZE P)
  'RUN))

(DEFN P-ADD1-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (SMALL-NATURALP (ADD1 (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-ADD1-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (ADD1 (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SUB-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'NAT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (NOT (LESSP (UNTAG (TOP1 (P-TEMP-STK P)))
                       (UNTAG (TOP (P-TEMP-STK P)))))))

(DEFN P-SUB-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (DIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                                      (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-SUB-NAT-WITH-CARRY-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (LISTP (POP (POP (P-TEMP-STK P))))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'NAT
                           (TOP1 (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP2 (P-TEMP-STK P))
                           P)))

(DEFN P-SUB-NAT-WITH-CARRY-STEP
 (INS P)
 (P-STATE
  (ADD1-P-PC P)
  (P-CTRL-STK P)
  (PUSH
   (TAG 'NAT
    (IF
     (LESSP (UNTAG (TOP1 (P-TEMP-STK P)))
            (PLUS (UNTAG (TOP (P-TEMP-STK P)))
                  (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))))
     (DIFFERENCE (EXP 2 (P-WORD-SIZE P))
                 (DIFFERENCE (PLUS (UNTAG (TOP (P-TEMP-STK P)))
                                   (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P)))))
                             (UNTAG (TOP1 (P-TEMP-STK P)))))
     (DIFFERENCE (UNTAG (TOP1 (P-TEMP-STK P)))
                 (PLUS (UNTAG (TOP (P-TEMP-STK P)))
                       (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P))))))))
   (PUSH (BOOL (LESSP (UNTAG (TOP1 (P-TEMP-STK P)))
                      (PLUS (UNTAG (TOP (P-TEMP-STK P)))
                            (BOOL-TO-NAT (UNTAG (TOP2 (P-TEMP-STK P)))))))
         (POP (POP (POP (P-TEMP-STK P))))))
  (P-PROG-SEGMENT P)
  (P-DATA-SEGMENT P)
  (P-MAX-CTRL-STK-SIZE P)
  (P-MAX-TEMP-STK-SIZE P)
  (P-WORD-SIZE P)
  'RUN))

(DEFN P-SUB1-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (NOT (ZEROP (UNTAG (TOP (P-TEMP-STK P)))))))

(DEFN P-SUB1-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (SUB1 (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-LT-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'NAT
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-LT-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (BOOL (LESSP (UNTAG (TOP1 (P-TEMP-STK P)))
                                  (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-MULT2-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (SMALL-NATURALP (TIMES 2 (UNTAG (TOP (P-TEMP-STK P))))
                           (P-WORD-SIZE P))))

(DEFN P-MULT2-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (TIMES 2
                                 (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-MULT2-NAT-WITH-CARRY-OUT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (LESSP (LENGTH (P-TEMP-STK P))
                  (P-MAX-TEMP-STK-SIZE P))))

(DEFN
 P-MULT2-NAT-WITH-CARRY-OUT-STEP
 (INS P)
 (P-STATE
  (ADD1-P-PC P)
  (P-CTRL-STK P)
  (PUSH (TAG 'NAT
             (FIX-SMALL-NATURAL (TIMES 2 (UNTAG (TOP (P-TEMP-STK P))))
                                (P-WORD-SIZE P)))
        (PUSH (BOOL (NOT (SMALL-NATURALP (TIMES 2 (UNTAG (TOP (P-TEMP-STK P))))
                                         (P-WORD-SIZE P))))
              (POP (P-TEMP-STK P))))
  (P-PROG-SEGMENT P)
  (P-DATA-SEGMENT P)
  (P-MAX-CTRL-STK-SIZE P)
  (P-MAX-TEMP-STK-SIZE P)
  (P-WORD-SIZE P)
  'RUN))

(DEFN P-DIV2-NAT-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'NAT
                           (TOP (P-TEMP-STK P))
                           P)
           (LESSP (LENGTH (P-TEMP-STK P))
                  (P-MAX-TEMP-STK-SIZE P))))

(DEFN P-DIV2-NAT-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'NAT
                          (REMAINDER (UNTAG (TOP (P-TEMP-STK P)))
                                     2))
                     (PUSH (TAG 'NAT
                                (QUOTIENT (UNTAG (TOP (P-TEMP-STK P)))
                                          2))
                           (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-OR-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BITV
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-OR-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (OR-BITV (UNTAG (TOP1 (P-TEMP-STK P)))
                                   (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-AND-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BITV
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-AND-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (AND-BITV (UNTAG (TOP1 (P-TEMP-STK P)))
                                    (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-NOT-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-NOT-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (NOT-BITV (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-XOR-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BITV
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-XOR-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (XOR-BITV (UNTAG (TOP1 (P-TEMP-STK P)))
                                    (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-RSH-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-RSH-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (RSH-BITV (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-LSH-BITV-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'BITV
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-LSH-BITV-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BITV
                          (LSH-BITV (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-OR-BOOL-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'BOOL
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-OR-BOOL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BOOL
                          (OR-BOOL (UNTAG (TOP1 (P-TEMP-STK P)))
                                   (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-AND-BOOL-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (LISTP (POP (P-TEMP-STK P)))
           (P-OBJECTP-TYPE 'BOOL
                           (TOP (P-TEMP-STK P))
                           P)
           (P-OBJECTP-TYPE 'BOOL
                           (TOP1 (P-TEMP-STK P))
                           P)))

(DEFN P-AND-BOOL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BOOL
                          (AND-BOOL (UNTAG (TOP1 (P-TEMP-STK P)))
                                    (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (POP (P-TEMP-STK P))))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-NOT-BOOL-OKP
      (INS P)
      (AND (LISTP (P-TEMP-STK P))
           (P-OBJECTP-TYPE 'BOOL
                           (TOP (P-TEMP-STK P))
                           P)))

(DEFN P-NOT-BOOL-STEP
      (INS P)
      (P-STATE (ADD1-P-PC P)
               (P-CTRL-STK P)
               (PUSH (TAG 'BOOL
                          (NOT-BOOL (UNTAG (TOP (P-TEMP-STK P)))))
                     (POP (P-TEMP-STK P)))
               (P-PROG-SEGMENT P)
               (P-DATA-SEGMENT P)
               (P-MAX-CTRL-STK-SIZE P)
               (P-MAX-TEMP-STK-SIZE P)
               (P-WORD-SIZE P)
               'RUN))

(DEFN P-INS-OKP
      (INS P)
      (CASE (CAR INS)
            (CALL (P-CALL-OKP INS P))
            (RET (P-RET-OKP INS P))
            (LOCN (P-LOCN-OKP INS P))
            (PUSH-CONSTANT (P-PUSH-CONSTANT-OKP INS P))
            (PUSH-LOCAL (P-PUSH-LOCAL-OKP INS P))
            (PUSH-GLOBAL (P-PUSH-GLOBAL-OKP INS P))
            (PUSH-CTRL-STK-FREE-SIZE (P-PUSH-CTRL-STK-FREE-SIZE-OKP INS P))
            (PUSH-TEMP-STK-FREE-SIZE (P-PUSH-TEMP-STK-FREE-SIZE-OKP INS P))
            (PUSH-TEMP-STK-INDEX (P-PUSH-TEMP-STK-INDEX-OKP INS P))
            (JUMP-IF-TEMP-STK-FULL (P-JUMP-IF-TEMP-STK-FULL-OKP INS P))
            (JUMP-IF-TEMP-STK-EMPTY (P-JUMP-IF-TEMP-STK-EMPTY-OKP INS P))
            (POP (P-POP-OKP INS P))
            (POP* (P-POP*-OKP INS P))
            (POPN (P-POPN-OKP INS P))
            (POP-LOCAL (P-POP-LOCAL-OKP INS P))
            (POP-GLOBAL (P-POP-GLOBAL-OKP INS P))
            (POP-LOCN (P-POP-LOCN-OKP INS P))
            (POP-CALL (P-POP-CALL-OKP INS P))
            (FETCH-TEMP-STK (P-FETCH-TEMP-STK-OKP INS P))
            (DEPOSIT-TEMP-STK (P-DEPOSIT-TEMP-STK-OKP INS P))
            (JUMP (P-JUMP-OKP INS P))
            (JUMP-CASE (P-JUMP-CASE-OKP INS P))
            (PUSHJ (P-PUSHJ-OKP INS P))
            (POPJ (P-POPJ-OKP INS P))
            (SET-LOCAL (P-SET-LOCAL-OKP INS P))
            (SET-GLOBAL (P-SET-GLOBAL-OKP INS P))
            (TEST-NAT-AND-JUMP (P-TEST-NAT-AND-JUMP-OKP INS P))
            (TEST-INT-AND-JUMP (P-TEST-INT-AND-JUMP-OKP INS P))
            (TEST-BOOL-AND-JUMP (P-TEST-BOOL-AND-JUMP-OKP INS P))
            (TEST-BITV-AND-JUMP (P-TEST-BITV-AND-JUMP-OKP INS P))
            (NO-OP (P-NO-OP-OKP INS P))
            (ADD-ADDR (P-ADD-ADDR-OKP INS P))
            (SUB-ADDR (P-SUB-ADDR-OKP INS P))
            (EQ (P-EQ-OKP INS P))
            (LT-ADDR (P-LT-ADDR-OKP INS P))
            (FETCH (P-FETCH-OKP INS P))
            (DEPOSIT (P-DEPOSIT-OKP INS P))
            (ADD-INT (P-ADD-INT-OKP INS P))
            (ADD-INT-WITH-CARRY (P-ADD-INT-WITH-CARRY-OKP INS P))
            (ADD1-INT (P-ADD1-INT-OKP INS P))
            (SUB-INT (P-SUB-INT-OKP INS P))
            (SUB-INT-WITH-CARRY (P-SUB-INT-WITH-CARRY-OKP INS P))
            (SUB1-INT (P-SUB1-INT-OKP INS P))
            (NEG-INT (P-NEG-INT-OKP INS P))
            (LT-INT (P-LT-INT-OKP INS P))
            (INT-TO-NAT (P-INT-TO-NAT-OKP INS P))
            (ADD-NAT (P-ADD-NAT-OKP INS P))
            (ADD-NAT-WITH-CARRY (P-ADD-NAT-WITH-CARRY-OKP INS P))
            (ADD1-NAT (P-ADD1-NAT-OKP INS P))
            (SUB-NAT (P-SUB-NAT-OKP INS P))
            (SUB-NAT-WITH-CARRY (P-SUB-NAT-WITH-CARRY-OKP INS P))
            (SUB1-NAT (P-SUB1-NAT-OKP INS P))
            (LT-NAT (P-LT-NAT-OKP INS P))
            (MULT2-NAT (P-MULT2-NAT-OKP INS P))
            (MULT2-NAT-WITH-CARRY-OUT (P-MULT2-NAT-WITH-CARRY-OUT-OKP INS P))
            (DIV2-NAT (P-DIV2-NAT-OKP INS P))
            (OR-BITV (P-OR-BITV-OKP INS P))
            (AND-BITV (P-AND-BITV-OKP INS P))
            (NOT-BITV (P-NOT-BITV-OKP INS P))
            (XOR-BITV (P-XOR-BITV-OKP INS P))
            (RSH-BITV (P-RSH-BITV-OKP INS P))
            (LSH-BITV (P-LSH-BITV-OKP INS P))
            (OR-BOOL (P-OR-BOOL-OKP INS P))
            (AND-BOOL (P-AND-BOOL-OKP INS P))
            (NOT-BOOL (P-NOT-BOOL-OKP INS P))
            (OTHERWISE F)))

(DEFN P-INS-STEP
      (INS P)
      (CASE (CAR INS)
            (CALL (P-CALL-STEP INS P))
            (RET (P-RET-STEP INS P))
            (LOCN (P-LOCN-STEP INS P))
            (PUSH-CONSTANT (P-PUSH-CONSTANT-STEP INS P))
            (PUSH-LOCAL (P-PUSH-LOCAL-STEP INS P))
            (PUSH-GLOBAL (P-PUSH-GLOBAL-STEP INS P))
            (PUSH-CTRL-STK-FREE-SIZE (P-PUSH-CTRL-STK-FREE-SIZE-STEP INS P))
            (PUSH-TEMP-STK-FREE-SIZE (P-PUSH-TEMP-STK-FREE-SIZE-STEP INS P))
            (PUSH-TEMP-STK-INDEX (P-PUSH-TEMP-STK-INDEX-STEP INS P))
            (JUMP-IF-TEMP-STK-FULL (P-JUMP-IF-TEMP-STK-FULL-STEP INS P))
            (JUMP-IF-TEMP-STK-EMPTY (P-JUMP-IF-TEMP-STK-EMPTY-STEP INS P))
            (POP (P-POP-STEP INS P))
            (POP* (P-POP*-STEP INS P))
            (POPN (P-POPN-STEP INS P))
            (POP-LOCAL (P-POP-LOCAL-STEP INS P))
            (POP-GLOBAL (P-POP-GLOBAL-STEP INS P))
            (POP-LOCN (P-POP-LOCN-STEP INS P))
            (POP-CALL (P-POP-CALL-STEP INS P))
            (FETCH-TEMP-STK (P-FETCH-TEMP-STK-STEP INS P))
            (DEPOSIT-TEMP-STK (P-DEPOSIT-TEMP-STK-STEP INS P))
            (JUMP (P-JUMP-STEP INS P))
            (JUMP-CASE (P-JUMP-CASE-STEP INS P))
            (PUSHJ (P-PUSHJ-STEP INS P))
            (POPJ (P-POPJ-STEP INS P))
            (SET-LOCAL (P-SET-LOCAL-STEP INS P))
            (SET-GLOBAL (P-SET-GLOBAL-STEP INS P))
            (TEST-NAT-AND-JUMP (P-TEST-NAT-AND-JUMP-STEP INS P))
            (TEST-INT-AND-JUMP (P-TEST-INT-AND-JUMP-STEP INS P))
            (TEST-BOOL-AND-JUMP (P-TEST-BOOL-AND-JUMP-STEP INS P))
            (TEST-BITV-AND-JUMP (P-TEST-BITV-AND-JUMP-STEP INS P))
            (NO-OP (P-NO-OP-STEP INS P))
            (ADD-ADDR (P-ADD-ADDR-STEP INS P))
            (SUB-ADDR (P-SUB-ADDR-STEP INS P))
            (EQ (P-EQ-STEP INS P))
            (LT-ADDR (P-LT-ADDR-STEP INS P))
            (FETCH (P-FETCH-STEP INS P))
            (DEPOSIT (P-DEPOSIT-STEP INS P))
            (ADD-INT (P-ADD-INT-STEP INS P))
            (ADD-INT-WITH-CARRY (P-ADD-INT-WITH-CARRY-STEP INS P))
            (ADD1-INT (P-ADD1-INT-STEP INS P))
            (SUB-INT (P-SUB-INT-STEP INS P))
            (SUB-INT-WITH-CARRY (P-SUB-INT-WITH-CARRY-STEP INS P))
            (SUB1-INT (P-SUB1-INT-STEP INS P))
            (NEG-INT (P-NEG-INT-STEP INS P))
            (LT-INT (P-LT-INT-STEP INS P))
            (INT-TO-NAT (P-INT-TO-NAT-STEP INS P))
            (ADD-NAT (P-ADD-NAT-STEP INS P))
            (ADD-NAT-WITH-CARRY (P-ADD-NAT-WITH-CARRY-STEP INS P))
            (ADD1-NAT (P-ADD1-NAT-STEP INS P))
            (SUB-NAT (P-SUB-NAT-STEP INS P))
            (SUB-NAT-WITH-CARRY (P-SUB-NAT-WITH-CARRY-STEP INS P))
            (SUB1-NAT (P-SUB1-NAT-STEP INS P))
            (LT-NAT (P-LT-NAT-STEP INS P))
            (MULT2-NAT (P-MULT2-NAT-STEP INS P))
            (MULT2-NAT-WITH-CARRY-OUT (P-MULT2-NAT-WITH-CARRY-OUT-STEP INS P))
            (DIV2-NAT (P-DIV2-NAT-STEP INS P))
            (OR-BITV (P-OR-BITV-STEP INS P))
            (AND-BITV (P-AND-BITV-STEP INS P))
            (NOT-BITV (P-NOT-BITV-STEP INS P))
            (XOR-BITV (P-XOR-BITV-STEP INS P))
            (RSH-BITV (P-RSH-BITV-STEP INS P))
            (LSH-BITV (P-LSH-BITV-STEP INS P))
            (OR-BOOL (P-OR-BOOL-STEP INS P))
            (AND-BOOL (P-AND-BOOL-STEP INS P))
            (NOT-BOOL (P-NOT-BOOL-STEP INS P))
            (OTHERWISE (P-HALT P 'RUN))))

(DEFN P-STEP1
      (INS P)
      (IF (P-INS-OKP INS P)
          (P-INS-STEP INS P)
          (P-HALT P
                  (X-Y-ERROR-MSG 'P (CAR INS)))))

(DEFN P-STEP
      (P)
      (IF (EQUAL (P-PSW P) 'RUN)
          (P-STEP1 (P-CURRENT-INSTRUCTION P) P)
          P))

(DEFN P
      (P N)
      (IF (ZEROP N)
          P
          (P (P-STEP P) (SUB1 N))))

(DEFN PROPER-P-CALL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (DEFINEDP (CADR INS)
                     (P-PROG-SEGMENT P))))

(DEFN PROPER-P-RET-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-LOCN-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (MEMBER (CADR INS)
                   (LOCAL-VARS (DEFINITION NAME
                                           (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-PUSH-CONSTANT-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (OR (P-OBJECTP (CADR INS) P)
               (EQUAL (CADR INS) 'PC)
               (FIND-LABELP (CADR INS)
                            (PROGRAM-BODY (DEFINITION NAME
                                                      (P-PROG-SEGMENT P)))))))

(DEFN PROPER-P-PUSH-LOCAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (MEMBER (CADR INS)
                   (LOCAL-VARS (DEFINITION NAME
                                           (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-PUSH-GLOBAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (DEFINEDP (CADR INS)
                     (P-DATA-SEGMENT P))))

(DEFN PROPER-P-PUSH-CTRL-STK-FREE-SIZE-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-PUSH-TEMP-STK-FREE-SIZE-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-PUSH-TEMP-STK-INDEX-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (SMALL-NATURALP (CADR INS)
                           (P-WORD-SIZE P))))

(DEFN PROPER-P-JUMP-IF-TEMP-STK-FULL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (FIND-LABELP (CADR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-JUMP-IF-TEMP-STK-EMPTY-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (FIND-LABELP (CADR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-POP-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-POP*-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (SMALL-NATURALP (CADR INS)
                           (P-WORD-SIZE P))))

(DEFN PROPER-P-POPN-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-POP-LOCAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (MEMBER (CADR INS)
                   (LOCAL-VARS (DEFINITION NAME
                                           (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-POP-GLOBAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (DEFINEDP (CADR INS)
                     (P-DATA-SEGMENT P))))

(DEFN PROPER-P-POP-LOCN-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (MEMBER (CADR INS)
                   (LOCAL-VARS (DEFINITION NAME
                                           (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-POP-CALL-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-FETCH-TEMP-STK-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-DEPOSIT-TEMP-STK-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-JUMP-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (FIND-LABELP (CADR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-JUMP-CASE-INSTRUCTIONP
      (INS NAME P)
      (AND (LISTP (CDR INS))
           (ALL-FIND-LABELP (CDR INS)
                            (PROGRAM-BODY (DEFINITION NAME
                                                      (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-PUSHJ-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (FIND-LABELP (CADR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-POPJ-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SET-LOCAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (MEMBER (CADR INS)
                   (LOCAL-VARS (DEFINITION NAME
                                           (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-SET-GLOBAL-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 2)
           (DEFINEDP (CADR INS)
                     (P-DATA-SEGMENT P))))

(DEFN PROPER-P-TEST-NAT-AND-JUMP-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 3)
           (FIND-LABELP (CADDR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-TEST-INT-AND-JUMP-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 3)
           (FIND-LABELP (CADDR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-TEST-BOOL-AND-JUMP-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 3)
           (FIND-LABELP (CADDR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-TEST-BITV-AND-JUMP-INSTRUCTIONP
      (INS NAME P)
      (AND (EQUAL (LENGTH INS) 3)
           (FIND-LABELP (CADDR INS)
                        (PROGRAM-BODY (DEFINITION NAME
                                                  (P-PROG-SEGMENT P))))))

(DEFN PROPER-P-NO-OP-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD-ADDR-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB-ADDR-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-EQ-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-LT-ADDR-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-FETCH-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-DEPOSIT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD-INT-WITH-CARRY-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD1-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB-INT-WITH-CARRY-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB1-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-NEG-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-LT-INT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-INT-TO-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD-NAT-WITH-CARRY-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-ADD1-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB-NAT-WITH-CARRY-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-SUB1-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-LT-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-MULT2-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-MULT2-NAT-WITH-CARRY-OUT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-DIV2-NAT-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-OR-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-AND-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-NOT-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-XOR-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-RSH-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-LSH-BITV-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-OR-BOOL-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-AND-BOOL-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-NOT-BOOL-INSTRUCTIONP
      (INS NAME P)
      (EQUAL (LENGTH INS) 1))

(DEFN PROPER-P-INSTRUCTIONP
 (INS NAME P)
 (AND
  (PROPERP INS)
  (CASE
   (CAR INS)
   (CALL (PROPER-P-CALL-INSTRUCTIONP INS NAME P))
   (RET (PROPER-P-RET-INSTRUCTIONP INS NAME P))
   (LOCN (PROPER-P-LOCN-INSTRUCTIONP INS NAME P))
   (PUSH-CONSTANT (PROPER-P-PUSH-CONSTANT-INSTRUCTIONP INS NAME P))
   (PUSH-LOCAL (PROPER-P-PUSH-LOCAL-INSTRUCTIONP INS NAME P))
   (PUSH-GLOBAL (PROPER-P-PUSH-GLOBAL-INSTRUCTIONP INS NAME P))
   (PUSH-CTRL-STK-FREE-SIZE (PROPER-P-PUSH-CTRL-STK-FREE-SIZE-INSTRUCTIONP INS
                                                                           NAME
                                                                           P))
   (PUSH-TEMP-STK-FREE-SIZE (PROPER-P-PUSH-TEMP-STK-FREE-SIZE-INSTRUCTIONP INS
                                                                           NAME
                                                                           P))
   (PUSH-TEMP-STK-INDEX (PROPER-P-PUSH-TEMP-STK-INDEX-INSTRUCTIONP INS NAME P))
   (JUMP-IF-TEMP-STK-FULL (PROPER-P-JUMP-IF-TEMP-STK-FULL-INSTRUCTIONP INS
                                                                       NAME P))
   (JUMP-IF-TEMP-STK-EMPTY (PROPER-P-JUMP-IF-TEMP-STK-EMPTY-INSTRUCTIONP INS
                                                                         NAME
                                                                         P))
   (POP (PROPER-P-POP-INSTRUCTIONP INS NAME P))
   (POP* (PROPER-P-POP*-INSTRUCTIONP INS NAME P))
   (POPN (PROPER-P-POPN-INSTRUCTIONP INS NAME P))
   (POP-LOCAL (PROPER-P-POP-LOCAL-INSTRUCTIONP INS NAME P))
   (POP-GLOBAL (PROPER-P-POP-GLOBAL-INSTRUCTIONP INS NAME P))
   (POP-LOCN (PROPER-P-POP-LOCN-INSTRUCTIONP INS NAME P))
   (POP-CALL (PROPER-P-POP-CALL-INSTRUCTIONP INS NAME P))
   (FETCH-TEMP-STK (PROPER-P-FETCH-TEMP-STK-INSTRUCTIONP INS NAME P))
   (DEPOSIT-TEMP-STK (PROPER-P-DEPOSIT-TEMP-STK-INSTRUCTIONP INS NAME P))
   (JUMP (PROPER-P-JUMP-INSTRUCTIONP INS NAME P))
   (JUMP-CASE (PROPER-P-JUMP-CASE-INSTRUCTIONP INS NAME P))
   (PUSHJ (PROPER-P-PUSHJ-INSTRUCTIONP INS NAME P))
   (POPJ (PROPER-P-POPJ-INSTRUCTIONP INS NAME P))
   (SET-LOCAL (PROPER-P-SET-LOCAL-INSTRUCTIONP INS NAME P))
   (SET-GLOBAL (PROPER-P-SET-GLOBAL-INSTRUCTIONP INS NAME P))
   (TEST-NAT-AND-JUMP (PROPER-P-TEST-NAT-AND-JUMP-INSTRUCTIONP INS NAME P))
   (TEST-INT-AND-JUMP (PROPER-P-TEST-INT-AND-JUMP-INSTRUCTIONP INS NAME P))
   (TEST-BOOL-AND-JUMP (PROPER-P-TEST-BOOL-AND-JUMP-INSTRUCTIONP INS NAME P))
   (TEST-BITV-AND-JUMP (PROPER-P-TEST-BITV-AND-JUMP-INSTRUCTIONP INS NAME P))
   (NO-OP (PROPER-P-NO-OP-INSTRUCTIONP INS NAME P))
   (ADD-ADDR (PROPER-P-ADD-ADDR-INSTRUCTIONP INS NAME P))
   (SUB-ADDR (PROPER-P-SUB-ADDR-INSTRUCTIONP INS NAME P))
   (EQ (PROPER-P-EQ-INSTRUCTIONP INS NAME P))
   (LT-ADDR (PROPER-P-LT-ADDR-INSTRUCTIONP INS NAME P))
   (FETCH (PROPER-P-FETCH-INSTRUCTIONP INS NAME P))
   (DEPOSIT (PROPER-P-DEPOSIT-INSTRUCTIONP INS NAME P))
   (ADD-INT (PROPER-P-ADD-INT-INSTRUCTIONP INS NAME P))
   (ADD-INT-WITH-CARRY (PROPER-P-ADD-INT-WITH-CARRY-INSTRUCTIONP INS NAME P))
   (ADD1-INT (PROPER-P-ADD1-INT-INSTRUCTIONP INS NAME P))
   (SUB-INT (PROPER-P-SUB-INT-INSTRUCTIONP INS NAME P))
   (SUB-INT-WITH-CARRY (PROPER-P-SUB-INT-WITH-CARRY-INSTRUCTIONP INS NAME P))
   (SUB1-INT (PROPER-P-SUB1-INT-INSTRUCTIONP INS NAME P))
   (NEG-INT (PROPER-P-NEG-INT-INSTRUCTIONP INS NAME P))
   (LT-INT (PROPER-P-LT-INT-INSTRUCTIONP INS NAME P))
   (INT-TO-NAT (PROPER-P-INT-TO-NAT-INSTRUCTIONP INS NAME P))
   (ADD-NAT (PROPER-P-ADD-NAT-INSTRUCTIONP INS NAME P))
   (ADD-NAT-WITH-CARRY (PROPER-P-ADD-NAT-WITH-CARRY-INSTRUCTIONP INS NAME P))
   (ADD1-NAT (PROPER-P-ADD1-NAT-INSTRUCTIONP INS NAME P))
   (SUB-NAT (PROPER-P-SUB-NAT-INSTRUCTIONP INS NAME P))
   (SUB-NAT-WITH-CARRY (PROPER-P-SUB-NAT-WITH-CARRY-INSTRUCTIONP INS NAME P))
   (SUB1-NAT (PROPER-P-SUB1-NAT-INSTRUCTIONP INS NAME P))
   (LT-NAT (PROPER-P-LT-NAT-INSTRUCTIONP INS NAME P))
   (MULT2-NAT (PROPER-P-MULT2-NAT-INSTRUCTIONP INS NAME P))
   (MULT2-NAT-WITH-CARRY-OUT
                           (PROPER-P-MULT2-NAT-WITH-CARRY-OUT-INSTRUCTIONP INS
                                                                           NAME
                                                                           P))
   (DIV2-NAT (PROPER-P-DIV2-NAT-INSTRUCTIONP INS NAME P))
   (OR-BITV (PROPER-P-OR-BITV-INSTRUCTIONP INS NAME P))
   (AND-BITV (PROPER-P-AND-BITV-INSTRUCTIONP INS NAME P))
   (NOT-BITV (PROPER-P-NOT-BITV-INSTRUCTIONP INS NAME P))
   (XOR-BITV (PROPER-P-XOR-BITV-INSTRUCTIONP INS NAME P))
   (RSH-BITV (PROPER-P-RSH-BITV-INSTRUCTIONP INS NAME P))
   (LSH-BITV (PROPER-P-LSH-BITV-INSTRUCTIONP INS NAME P))
   (OR-BOOL (PROPER-P-OR-BOOL-INSTRUCTIONP INS NAME P))
   (AND-BOOL (PROPER-P-AND-BOOL-INSTRUCTIONP INS NAME P))
   (NOT-BOOL (PROPER-P-NOT-BOOL-INSTRUCTIONP INS NAME P))
   (OTHERWISE F))))

(DEFN PROPER-LABELED-P-INSTRUCTIONSP
      (LST NAME P)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (LEGAL-LABELP (CAR LST))
               (PROPER-P-INSTRUCTIONP (UNLABEL (CAR LST))
                                      NAME P)
               (PROPER-LABELED-P-INSTRUCTIONSP (CDR LST)
                                               NAME P))))

(DEFN FALL-OFF-PROOFP
      (LST)
      (MEMBER (CAR (UNLABEL (GET (SUB1 (LENGTH LST)) LST)))
              '(RET JUMP JUMP-CASE POPJ)))

(DEFN PROPER-P-PROGRAM-BODYP
      (LST NAME P)
      (AND (LISTP LST)
           (PROPER-LABELED-P-INSTRUCTIONSP LST NAME P)
           (FALL-OFF-PROOFP LST)))

(DEFN ALL-LITATOMS
      (LST)
      (IF (NLISTP LST)
          (EQUAL LST NIL)
          (AND (LITATOM (CAR LST))
               (ALL-LITATOMS (CDR LST)))))

(DEFN PROPER-P-TEMP-VAR-DCLSP
      (TEMP-VAR-DCLS P)
      (IF (NLISTP TEMP-VAR-DCLS)
          T
          (AND (LITATOM (CAAR TEMP-VAR-DCLS))
               (P-OBJECTP (CADAR TEMP-VAR-DCLS) P)
               (PROPER-P-TEMP-VAR-DCLSP (CDR TEMP-VAR-DCLS)
                                        P))))

(DEFN PROPER-P-PROGRAMP
      (PROG P)
      (AND (LITATOM (NAME PROG))
           (ALL-LITATOMS (FORMAL-VARS PROG))
           (PROPER-P-TEMP-VAR-DCLSP (TEMP-VAR-DCLS PROG)
                                    P)
           (PROPER-P-PROGRAM-BODYP (PROGRAM-BODY PROG)
                                   (NAME PROG)
                                   P)))

(DEFN PROPER-P-PROG-SEGMENTP
      (SEGMENT P)
      (IF (NLISTP SEGMENT)
          (EQUAL SEGMENT NIL)
          (AND (PROPER-P-PROGRAMP (CAR SEGMENT) P)
               (PROPER-P-PROG-SEGMENTP (CDR SEGMENT)
                                       P))))

(DEFN PROPER-P-ALISTP
      (ALIST P)
      (IF (NLISTP ALIST)
          (EQUAL ALIST NIL)
          (AND (LISTP (CAR ALIST))
               (LITATOM (CAAR ALIST))
               (P-OBJECTP (CDAR ALIST) P)
               (PROPER-P-ALISTP (CDR ALIST) P))))

(DEFN PROPER-P-FRAMEP
      (FRAME NAME P)
      (AND (LISTP FRAME)
           (LISTP (CDR FRAME))
           (EQUAL (CDDR FRAME) NIL)
           (PROPER-P-ALISTP (BINDINGS FRAME) P)
           (EQUAL (STRIP-CARS (BINDINGS FRAME))
                  (LOCAL-VARS (DEFINITION NAME (P-PROG-SEGMENT P))))
           (P-OBJECTP-TYPE 'PC
                           (RET-PC FRAME)
                           P)))

(DEFN PROPER-P-CTRL-STKP
      (CTRL-STK NAME P)
      (IF (NLISTP CTRL-STK)
          (EQUAL CTRL-STK NIL)
          (AND (PROPER-P-FRAMEP (TOP CTRL-STK)
                                NAME P)
               (PROPER-P-CTRL-STKP (POP CTRL-STK)
                                   (AREA-NAME (RET-PC (TOP CTRL-STK)))
                                   P)))
      ((LESSP (COUNT CTRL-STK))))

(DEFN PROPER-P-TEMP-STKP
      (TEMP-STK P)
      (IF (NLISTP TEMP-STK)
          (EQUAL TEMP-STK NIL)
          (AND (P-OBJECTP (TOP TEMP-STK) P)
               (PROPER-P-TEMP-STKP (POP TEMP-STK)
                                   P)))
      ((LESSP (COUNT TEMP-STK))))

(DEFN PROPER-P-AREA
      (AREA P)
      (AND (LITATOM (CAR AREA))
           (LISTP (CDR AREA))
           (ALL-P-OBJECTPS (CDR AREA) P)))

(DEFN PROPER-P-DATA-SEGMENTP
      (DATA-SEGMENT P)
      (IF (NLISTP DATA-SEGMENT)
          (EQUAL DATA-SEGMENT NIL)
          (AND (PROPER-P-AREA (CAR DATA-SEGMENT) P)
               (NOT (DEFINEDP (CAAR DATA-SEGMENT)
                              (CDR DATA-SEGMENT)))
               (PROPER-P-DATA-SEGMENTP (CDR DATA-SEGMENT)
                                       P))))

(DEFN PROPER-P-STATEP
      (P)
      (AND (P-STATEP P)
           (P-OBJECTP-TYPE 'PC (P-PC P) P)
           (LISTP (P-CTRL-STK P))
           (PROPER-P-FRAMEP (TOP (P-CTRL-STK P))
                            (AREA-NAME (P-PC P))
                            P)
           (PROPER-P-CTRL-STKP (POP (P-CTRL-STK P))
                               (AREA-NAME (RET-PC (TOP (P-CTRL-STK P))))
                               P)
           (NOT (LESSP (P-MAX-CTRL-STK-SIZE P)
                       (P-CTRL-STK-SIZE (P-CTRL-STK P))))
           (PROPER-P-TEMP-STKP (P-TEMP-STK P) P)
           (NOT (LESSP (P-MAX-TEMP-STK-SIZE P)
                       (LENGTH (P-TEMP-STK P))))
           (PROPER-P-PROG-SEGMENTP (P-PROG-SEGMENT P)
                                   P)
           (PROPER-P-DATA-SEGMENTP (P-DATA-SEGMENT P)
                                   P)
           (NUMBERP (P-MAX-CTRL-STK-SIZE P))
           (NUMBERP (P-MAX-TEMP-STK-SIZE P))
           (NUMBERP (P-WORD-SIZE P))
           (LESSP (P-MAX-CTRL-STK-SIZE P)
                  (EXP 2 (P-WORD-SIZE P)))
           (LESSP (P-MAX-TEMP-STK-SIZE P)
                  (EXP 2 (P-WORD-SIZE P)))
           (LESSP 0 (P-WORD-SIZE P))))

; Book: p-r.events.  In this section we prove that the p machine
; is implemented on the r machine.

(disable unlabel)
(disable r-usr-data-typep)
(disable r-instructionp)

; I will disable type, tag and untag for sanity's sake,
; but prove the obvious relationships first.

(enable type-tag)

(enable untag-tag)

(prove-lemma equal-tags (rewrite)
  (equal (equal (tag type x)
                (tag type y))
         (equal x y)))

(enable cddr-tag)

(disable type)
(disable tag)
(disable untag)

; The function BOOLEANP is a killer because it
; causes everything to split.  I will disable it
; and prove what I need about it as necessary.

(disable booleanp)

; Error messages are irrelevant as long as they are not 'run or 'halt.

(enable not-equal-x-y-error-msg-run)

(enable not-equal-x-y-error-msg-halt)

(disable x-y-error-msg)

(enable r-psw-r-halt)

(disable r-halt)

; Now I arrange for r-objectp to open when we know the type:

(enable r-objectp-opener)

(disable r-objectp)
(disable r-usr-data-typep)

; We repeat the same exercise for p-objectp:

(prove-lemma p-objectp-opener (rewrite)
  (and (implies (equal (type x) 'nat)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (small-naturalp (untag x)
                                            (p-word-size p)))))
       (implies (equal (type x) 'int)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (small-integerp (untag x)
                                            (p-word-size p)))))
       (implies (equal (type x) 'bitv)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (bit-vectorp (untag x)
                                         (p-word-size p)))))
       (implies (equal (type x) 'bool)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (booleanp (untag x)))))
       (implies (equal (type x) 'addr)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (adpp (untag x)
                                  (p-data-segment p)))))
       (implies (equal (type x) 'pc)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (pcpp (untag x)
                                  (p-prog-segment p)))))
       (implies (equal (type x) 'subr)
                (equal (p-objectp x p)
                       (and (equal (cddr x) nil)
                            (definedp (untag x)
                                      (p-prog-segment p)))))))

(disable p-objectp)


(disable name)
(disable formal-vars)
(disable temp-var-dcls)
(disable program-body)

(prove-lemma bindings-p-frame (rewrite)
  (equal (bindings (p-frame alist pc)) alist))

(prove-lemma ret-pc-p-frame (rewrite)
  (equal (ret-pc (p-frame alist pc)) pc))

(disable bindings)
(disable ret-pc)
(disable p-frame)

(enable associativity-of-plus)
(enable commutativity-of-plus) 
(enable plus-add1)
(enable commutativity2-of-plus)

; difference is used a lot in the stack pointer mappings and
; it is opened too often.  I want to control the expansion of
; difference carefully.

(disable difference)

; The icompiler is involved in the characterization of loadablep
; but is actually irrelevant at this level.
; So we

(disable icompile)

; to save the trouble of repeatedly considering expanding it.

; We need to get from (car (p-current-instruction p)) = 'no-op and
; (proper-p-statep p) the fact that
; (proper-p-no-op-instructionp (p-current-instruction p) name p).
; We will do it in two steps.  First we prove that proper-p-statep
; implies proper-p-instructionp for the current instruction.
; Then we'll arrange for proper-p-statep to expand and introduce
; the implied proper-p-instructionp too.

(disable proper-p-instructionp)

(disable legal-labelp)

(prove-lemma proper-labeled-p-instructionsp-implies-labelp-and-instructionp
             nil
  (implies (and (proper-labeled-p-instructionsp lst name p)
                (member x lst))
           (and (legal-labelp x)
                (proper-p-instructionp (unlabel x) name p))))

(prove-lemma proper-p-prog-segmentp-implies-proper-p-programp nil
  (implies (and (proper-p-prog-segmentp segment p)
                (member prog segment))
           (proper-p-programp prog p)))
           
(enable member-assoc)

(enable name-assoc)

(enable member-get)

(prove-lemma proper-p-statep-implies-proper-p-instructionp nil
  (implies (and (proper-p-prog-segmentp (p-prog-segment p) p)
                (definedp (car (untag (p-pc p))) (p-prog-segment p))
                (lessp (cdr (untag (p-pc p)))
                       (length
                        (program-body
                         (assoc (car (untag (p-pc p)))
                                (p-prog-segment p))))))
           (proper-p-instructionp (p-current-instruction p)
                                  (car (untag (p-pc p)))
                                  p))
  ((use (proper-p-prog-segmentp-implies-proper-p-programp
         (segment (p-prog-segment p))
         (prog (assoc (car (untag (p-pc p))) (p-prog-segment p))))
        (proper-labeled-p-instructionsp-implies-labelp-and-instructionp
         (lst (program-body
               (assoc (car (untag (p-pc p))) (p-prog-segment p))))
         (name (car (untag (p-pc p))))
         (x (get (cdr (untag (p-pc p)))
                 (program-body
                  (assoc (car (untag (p-pc p))) (p-prog-segment p)))))))))

         
; Now I restructure proper-p-statep into two parts, those that
; have to do with arithmetic and those that do not.  The parts
; that do not are arithmetic, I confine to proper-p-statep1,
; which I keep closed and backchain into as needed.  The other
; parts I keep out in the open.  In addition, I throw in the
; proper-p-instructionp proved above, essentially forward
; chaining through the lemma.

(disable p-loadablep)

(defn proper-p-statep1 (p)
  (and (p-statep p)
       (equal (type (p-pc p)) 'pc)
       (listp (p-pc p))
       (equal (cddr (p-pc p)) nil)
       (listp (untag (p-pc p)))
       (definedp (car (untag (p-pc p)))
                 (p-prog-segment p))
       (listp (p-ctrl-stk p))
       (listp (car (p-ctrl-stk p)))
       (listp (cdr (car (p-ctrl-stk p))))
       (equal (cddr (car (p-ctrl-stk p)))
              nil)
       (proper-p-alistp (bindings (car (p-ctrl-stk p)))
                        p)
       (equal
        (strip-cars (bindings (car (p-ctrl-stk p))))
        (append (formal-vars
                 (assoc (car (untag (p-pc p)))
                        (p-prog-segment p)))
                (strip-cars
                 (temp-var-dcls (assoc (car (untag (p-pc p)))
                                       (p-prog-segment p))))))
       (equal (type (ret-pc (car (p-ctrl-stk p))))
              'pc)
       (listp (ret-pc (car (p-ctrl-stk p))))
       (equal (cddr (ret-pc (car (p-ctrl-stk p))))
              nil)
       (listp (untag (ret-pc (car (p-ctrl-stk p)))))
       (definedp (car (untag (ret-pc (car (p-ctrl-stk p)))))
                 (p-prog-segment p))
       (proper-p-ctrl-stkp (cdr (p-ctrl-stk p))
                           (car (untag (ret-pc (car (p-ctrl-stk p)))))
                           p)
       (proper-p-temp-stkp (p-temp-stk p) p)
       (proper-p-prog-segmentp (p-prog-segment p) p)
       (proper-p-data-segmentp (p-data-segment p) p)))

(prove-lemma proper-p-statep-restructuring (rewrite)
 (equal (proper-p-statep p)
        (and (proper-p-statep1 p)
             (numberp (cdr (untag (p-pc p))))
             (lessp (cdr (untag (p-pc p)))
                    (length (program-body (assoc (car (untag (p-pc p)))
                                                 (p-prog-segment p)))))
             (numberp (cdr (untag (ret-pc (car (p-ctrl-stk p))))))
             (lessp
              (cdr (untag (ret-pc (car (p-ctrl-stk p)))))
              (length
               (program-body
                (assoc (car (untag (ret-pc (car (p-ctrl-stk p)))))
                       (p-prog-segment p)))))
             (not (lessp (p-max-ctrl-stk-size p)
                         (p-ctrl-stk-size (p-ctrl-stk p))))
             (not (lessp (p-max-temp-stk-size p)
                         (length (p-temp-stk p))))
             (numberp (p-max-ctrl-stk-size p))
             (numberp (p-max-temp-stk-size p))
             (numberp (p-word-size p))
             (lessp (p-max-ctrl-stk-size p) (exp 2 (p-word-size p)))
             (lessp (p-max-temp-stk-size p) (exp 2 (p-word-size p)))
             (lessp 0 (p-word-size p))
             (proper-p-instructionp (p-current-instruction p)
                                    (car (untag (p-pc p)))
                                    p)))
 ((use (proper-p-statep-implies-proper-p-instructionp))))

(prove-lemma proper-p-statep1-properties (rewrite)
  (implies (proper-p-statep1 p)
           (and (p-statep p)
                (equal (type (p-pc p)) 'pc)
                (listp (p-pc p))
                (equal (cddr (p-pc p)) nil)
                (listp (untag (p-pc p)))
                (definedp (car (untag (p-pc p)))
                          (p-prog-segment p))
                (listp (p-ctrl-stk p))
                (listp (car (p-ctrl-stk p)))
                (listp (cdr (car (p-ctrl-stk p))))
                (equal (cddr (car (p-ctrl-stk p)))
                       nil)
                (proper-p-alistp (bindings (car (p-ctrl-stk p)))
                                 p)
                (equal
                 (strip-cars (bindings (car (p-ctrl-stk p))))
                 (append (formal-vars
                          (assoc (car (untag (p-pc p)))
                                 (p-prog-segment p)))
                         (strip-cars
                          (temp-var-dcls (assoc (car (untag (p-pc p)))
                                                (p-prog-segment p))))))
                (equal (type (ret-pc (car (p-ctrl-stk p))))
                       'pc)
                (listp (ret-pc (car (p-ctrl-stk p))))
                (equal (cddr (ret-pc (car (p-ctrl-stk p))))
                       nil)
                (listp (untag (ret-pc (car (p-ctrl-stk p)))))
                (definedp (car (untag (ret-pc (car (p-ctrl-stk p)))))
                          (p-prog-segment p))
                (proper-p-ctrl-stkp (cdr (p-ctrl-stk p))
                                    (car (untag (ret-pc (car (p-ctrl-stk p)))))
                                    p)
                (proper-p-temp-stkp (p-temp-stk p) p)
                (proper-p-prog-segmentp (p-prog-segment p) p)
                (proper-p-data-segmentp (p-data-segment p) p))))

(disable proper-p-statep)
(disable proper-p-statep1)

(disable p-current-instruction)

; Now I provide a simple delayed opener for proper-p-instructionp:

(prove-lemma proper-p-instructionp-opener (rewrite)
  (implies
   (equal (car ins) (pack xxx))
   (equal (proper-p-instructionp ins name p)
          (and
           (properp ins)
           (case
            (car ins)
            (call (proper-p-call-instructionp ins name p))
            (ret (proper-p-ret-instructionp ins name p))
            (locn (proper-p-locn-instructionp ins name p))
            (push-constant (proper-p-push-constant-instructionp ins name p))
            (push-local (proper-p-push-local-instructionp ins name p))
            (push-global (proper-p-push-global-instructionp ins name p))
            (push-ctrl-stk-free-size 
             (proper-p-push-ctrl-stk-free-size-instructionp
              ins name p))
            (push-temp-stk-free-size
             (proper-p-push-temp-stk-free-size-instructionp
              ins name p))
            (push-temp-stk-index
             (proper-p-push-temp-stk-index-instructionp
              ins name p))
            (jump-if-temp-stk-full
             (proper-p-jump-if-temp-stk-full-instructionp
              ins name p))
            (jump-if-temp-stk-empty
             (proper-p-jump-if-temp-stk-empty-instructionp
              ins name p))
            (pop (proper-p-pop-instructionp ins name p))
            (pop* (proper-p-pop*-instructionp ins name p))
            (popn (proper-p-popn-instructionp ins name p))
            (pop-local (proper-p-pop-local-instructionp ins name p))
            (pop-global (proper-p-pop-global-instructionp ins name p))
            (pop-locn (proper-p-pop-locn-instructionp ins name p))
            (pop-call (proper-p-pop-call-instructionp ins name p))
            (fetch-temp-stk (proper-p-fetch-temp-stk-instructionp ins name p))
            (deposit-temp-stk (proper-p-deposit-temp-stk-instructionp
                               ins name p))
            (jump (proper-p-jump-instructionp ins name p))
            (jump-case (proper-p-jump-case-instructionp ins name p))
            (pushj (proper-p-pushj-instructionp ins name p))
            (popj (proper-p-popj-instructionp ins name p))
            (set-local (proper-p-set-local-instructionp ins name p))
            (set-global (proper-p-set-global-instructionp ins name p))
            (test-nat-and-jump (proper-p-test-nat-and-jump-instructionp
                                 ins name p))
            (test-int-and-jump (proper-p-test-int-and-jump-instructionp
                                 ins name p))
            (test-bool-and-jump (proper-p-test-bool-and-jump-instructionp
                                 ins name p))
            (test-bitv-and-jump (proper-p-test-bitv-and-jump-instructionp
                                 ins name p))
            (no-op (proper-p-no-op-instructionp ins name p))
            (add-addr (proper-p-add-addr-instructionp ins name p))
            (sub-addr (proper-p-sub-addr-instructionp ins name p))
            (eq (proper-p-eq-instructionp ins name p))
            (lt-addr (proper-p-lt-addr-instructionp ins name p))
            (fetch (proper-p-fetch-instructionp ins name p))
            (deposit (proper-p-deposit-instructionp ins name p))
            (add-int (proper-p-add-int-instructionp ins name p))
            (add-int-with-carry (proper-p-add-int-with-carry-instructionp
                                 ins name p))
            (add1-int (proper-p-add1-int-instructionp ins name p))
            (sub-int (proper-p-sub-int-instructionp ins name p))
            (sub-int-with-carry (proper-p-sub-int-with-carry-instructionp
                                 ins name p))
            (sub1-int (proper-p-sub1-int-instructionp ins name p))
            (neg-int (proper-p-neg-int-instructionp ins name p))
            (lt-int (proper-p-lt-int-instructionp ins name p))
            (int-to-nat (proper-p-int-to-nat-instructionp ins name p))
            (add-nat (proper-p-add-nat-instructionp ins name p))
            (add-nat-with-carry (proper-p-add-nat-with-carry-instructionp
                                 ins name p))
            (add1-nat (proper-p-add1-nat-instructionp ins name p))
            (sub-nat (proper-p-sub-nat-instructionp ins name p))
            (sub-nat-with-carry (proper-p-sub-nat-with-carry-instructionp
                                 ins name p))
            (sub1-nat (proper-p-sub1-nat-instructionp ins name p))
            (lt-nat (proper-p-lt-nat-instructionp ins name p))
            (mult2-nat (proper-p-mult2-nat-instructionp ins name p))
            (mult2-nat-with-carry-out
             (proper-p-mult2-nat-with-carry-out-instructionp
              ins name p))
            (div2-nat (proper-p-div2-nat-instructionp ins name p))
            (or-bitv (proper-p-or-bitv-instructionp ins name p))
            (and-bitv (proper-p-and-bitv-instructionp ins name p))
            (not-bitv (proper-p-not-bitv-instructionp ins name p))
            (xor-bitv (proper-p-xor-bitv-instructionp ins name p))
            (rsh-bitv (proper-p-rsh-bitv-instructionp ins name p))
            (lsh-bitv (proper-p-lsh-bitv-instructionp ins name p))
            (or-bool (proper-p-or-bool-instructionp ins name p))
            (and-bool (proper-p-and-bool-instructionp ins name p))
            (not-bool (proper-p-not-bool-instructionp ins name p))
            (otherwise f)))))
  ((enable proper-p-instructionp)
   (disable proper-p-call-instructionp
            proper-p-ret-instructionp
            proper-p-locn-instructionp
            proper-p-push-constant-instructionp
            proper-p-push-local-instructionp
            proper-p-push-global-instructionp
            proper-p-push-ctrl-stk-free-size-instructionp
            proper-p-push-temp-stk-free-size-instructionp
            proper-p-push-temp-stk-index-instructionp
            proper-p-jump-if-temp-stk-full-instructionp
            proper-p-jump-if-temp-stk-empty-instructionp
            proper-p-pop-instructionp
            proper-p-pop*-instructionp
            proper-p-popn-instructionp
            proper-p-pop-local-instructionp
            proper-p-pop-global-instructionp
            proper-p-pop-locn-instructionp
            proper-p-pop-call-instructionp
            proper-p-fetch-temp-stk-instructionp
            proper-p-deposit-temp-stk-instructionp
            proper-p-jump-instructionp
            proper-p-jump-case-instructionp
            proper-p-pushj-instructionp
            proper-p-popj-instructionp
            proper-p-set-local-instructionp
            proper-p-set-global-instructionp
            proper-p-test-nat-and-jump-instructionp
            proper-p-test-int-and-jump-instructionp
            proper-p-test-bool-and-jump-instructionp
            proper-p-test-bitv-and-jump-instructionp
            proper-p-no-op-instructionp
            proper-p-add-addr-instructionp
            proper-p-sub-addr-instructionp
            proper-p-eq-instructionp
            proper-p-lt-addr-instructionp
            proper-p-fetch-instructionp
            proper-p-deposit-instructionp
            proper-p-add-int-instructionp
            proper-p-add-int-with-carry-instructionp
            proper-p-add1-int-instructionp
            proper-p-sub-int-instructionp
            proper-p-sub-int-with-carry-instructionp
            proper-p-sub1-int-instructionp
            proper-p-neg-int-instructionp
            proper-p-lt-int-instructionp
            proper-p-int-to-nat-instructionp
            proper-p-add-nat-instructionp
            proper-p-add-nat-with-carry-instructionp
            proper-p-add1-nat-instructionp
            proper-p-sub-nat-instructionp
            proper-p-sub-nat-with-carry-instructionp
            proper-p-sub1-nat-instructionp
            proper-p-lt-nat-instructionp
            proper-p-mult2-nat-instructionp
            proper-p-mult2-nat-with-carry-out-instructionp
            proper-p-div2-nat-instructionp
            proper-p-or-bitv-instructionp
            proper-p-and-bitv-instructionp
            proper-p-not-bitv-instructionp
            proper-p-xor-bitv-instructionp
            proper-p-rsh-bitv-instructionp
            proper-p-lsh-bitv-instructionp
            proper-p-or-bool-instructionp
            proper-p-and-bool-instructionp
            proper-p-not-bool-instructionp)))

; The following lemma tells us that if the current instruction is
; not one of the fall-off barriers then it is possible to increment
; the pc.

(prove-lemma proper-p-statep-implies-add1-p-pcp (rewrite)
  (implies (and (equal (car (p-current-instruction p)) (pack xxx))
                (proper-p-statep1 p)
                (lessp (cdr (untag (p-pc p)))
                       (length (program-body
                                (assoc (car (untag (p-pc p)))
                                       (p-prog-segment p)))))
                (not (member (car (p-current-instruction p))
                             '(ret jump jump-case popj))))
           (lessp (cdr (untag (p-pc p)))
                  (sub1 (length (program-body
                                 (assoc (car (untag (p-pc p)))
                                        (p-prog-segment p)))))))
  ((enable p-current-instruction)
   (use (proper-p-prog-segmentp-implies-proper-p-programp
         (segment (p-prog-segment p))
         (prog (assoc (car (untag (p-pc p))) (p-prog-segment p)))))))

; We also know that the r-current-instruction of the mapped down state
; is the p-current-instruction.

(prove-lemma r-current-instruction-p->r (rewrite)
  (equal (r-current-instruction (p->r p))
         (p-current-instruction p))
  ((enable p-current-instruction)))

(disable r-current-instruction)

; Henceforth, in my lemmas building up to the owc theorem, I will use
; (p-current-instruction p) even on the r side of the lemmas because the
; above theorem gives the equality I would otherwise need.  Furthermore,
; with the above theorem around, (r-current-instruction (p->r p)) would
; be Knuth-Bendixed away anyway.

; The major difficulty of this proof is in controlling the expansion
; of the sys-data-segment and tracking the isomorphism between the
; p and r level stacks -- that is ALL there is to this proof!

; We will keep p->r_sys-data-segment disabled because it generates
; a big list I don't like to see.  

; We begin by showing what you get when you assoc for each of
; the 5 components of the sys-data-segment.


(prove-lemma assoc-cstk-p->r_sys-data-segment (rewrite)
  (equal (assoc 'cstk
                (p->r_sys-data-segment ctrl-stk
                                       max-ctrl-stk-size
                                       temp-stk
                                       max-temp-stk-size))
         (p->r_ctrl-stk ctrl-stk max-ctrl-stk-size)))

(prove-lemma assoc-tstk-p->r_sys-data-segment (rewrite)
  (equal (assoc 'tstk
                (p->r_sys-data-segment ctrl-stk
                                       max-ctrl-stk-size
                                       temp-stk
                                       max-temp-stk-size))
         (p->r_temp-stk temp-stk max-temp-stk-size)))

(prove-lemma assoc-full-ctrl-stk-addr-p->r_sys-data-segment (rewrite)
  (equal (assoc 'full-ctrl-stk-addr
                (p->r_sys-data-segment ctrl-stk
                                       max-ctrl-stk-size
                                       temp-stk
                                       max-temp-stk-size))
         (list 'full-ctrl-stk-addr
               (tag 'sys-addr '(cstk . 0)))))

(prove-lemma assoc-full-temp-stk-addr-p->r_sys-data-segment (rewrite)
  (equal (assoc 'full-temp-stk-addr
                (p->r_sys-data-segment ctrl-stk
                                       max-ctrl-stk-size
                                       temp-stk
                                       max-temp-stk-size))
         (list 'full-temp-stk-addr
               (tag 'sys-addr '(tstk . 0)))))

(prove-lemma assoc-empty-temp-stk-addr-p->r_sys-data-segment (rewrite)
  (equal (assoc 'empty-temp-stk-addr
                (p->r_sys-data-segment ctrl-stk
                                       max-ctrl-stk-size
                                       temp-stk
                                       max-temp-stk-size))
            (list 'empty-temp-stk-addr
                  (tag 'sys-addr
                       (cons 'tstk max-temp-stk-size)))))

; Next we establish that those we put into are defined:

(prove-lemma definedp-tstk-p->r_sys-data-segment (rewrite)
  (definedp 'tstk (p->r_sys-data-segment ctrl-stk
                                         max-ctrl-stk-size
                                         temp-stk
                                         max-temp-stk-size)))

(prove-lemma definedp-cstk-p->r_sys-data-segment (rewrite)
  (definedp 'cstk (p->r_sys-data-segment ctrl-stk
                                         max-ctrl-stk-size
                                         temp-stk
                                         max-temp-stk-size)))

; Next we establish the lengths of the mapped down cstk and tstk:

(prove-lemma length-strip-cdrs (rewrite)
  (equal (length (strip-cdrs x)) (length x)))

(enable length-append)

(prove-lemma length-p->r_ctrl-stk1 (rewrite)
  (equal (length (p->r_ctrl-stk1 stk max)) (p-ctrl-stk-size stk)))

(prove-lemma length-nat-0s (rewrite)
  (equal (length (nat-0s n)) (fix n)))

(enable lessp-difference=0)

(prove-lemma length-cdr-p->r_ctrl-stk (rewrite)
 (implies (not (lessp max-ctrl-stk-size
                      (p-ctrl-stk-size ctrl-stk)))
          (equal (length
                  (cdr (p->r_ctrl-stk ctrl-stk max-ctrl-stk-size)))
                 (add1 max-ctrl-stk-size))))

(prove-lemma length-cdr-p->r_temp-stk (rewrite)
 (implies (not (lessp max-temp-stk-size
                      (length temp-stk)))
          (equal (length
                  (cdr (p->r_temp-stk temp-stk max-temp-stk-size)))
                 (add1 max-temp-stk-size))))

; Now we show what happens when you access and change the mapped down stacks.
; My plan is this.  I will leave p->r_ctrl-stk and p->r_temp-stk disabled.
; I will explain how to get an "arbitrary" element out of both.
; I will explain how to put at an "arbitrary" location in p->r_ctrl-stk --
; by showing that the appropriate put-assoc-put combination on p->r_ctrl-stk
; is equal to a p->r_ctrl-stk of an appropriate put.  But I will not discuss
; how to put into p->r_temp-stk.  The problem has to do with popping the
; temp stack and the fact that we often pop several times and then put.
; It is not possible to say what the corresponding p->r_temp-stk would be
; because of the dead junk at the top.  This problem is dealt with by
; stk-equal and so we will address putting into the p->r_temp-stk when
; we deal with stk-equal.

; We start with accessing the temp-stk, which is the simplest operation.

(enable unconditional-get-append)

(prove-lemma difference-difference-difference (rewrite)
  (implies (and (not (lessp i j))
                (not (lessp i k)))
           (equal (difference (difference i j)
                              (difference i k))
                  (difference k j)))
  ((enable difference)))

; The following theorem shows how to get at an "arbitrary"
; address in a mapped down stack, where by "arbitrary" I
; mean any address in the live part.

(prove-lemma get-cdr-p->r_temp-stk (rewrite)
  (implies (and (not (lessp max-temp-stk-size (length temp-stk)))
                (lessp i max-temp-stk-size)
                (not (lessp i
                            (difference max-temp-stk-size
                                        (length temp-stk)))))
           (equal (get i
                       (cdr (p->r_temp-stk temp-stk max-temp-stk-size)))
                  (get (difference i
                                   (difference max-temp-stk-size
                                               (length temp-stk)))
                       temp-stk))))

; Most often we will be getting at the top of the temp stk,
; which is i = (difference max-temp-stk-size (length temp-stk))
; (just look at p->r_tsp).  In that case, we will need:

(enable difference-x-x)

; When we get at top1 i will be 
;    (difference max-temp-stk-size (length (cdr temp-stk)))
; and the (difference max-temp-stk-size (length temp-stk))
; above will become
;    (difference max-temp-stk-size (add1 (length (cdr temp-stk))))
; which will expand to 
;    (sub1 (difference max-temp-stk-size (length (cdr temp-stk))))
; by 

(prove-lemma difference-add1{special} (rewrite)
  (equal (difference x (add1 y))
         (sub1 (difference x y))))

; So we will need:

(prove-lemma difference-x-sub1-x (rewrite)
  (implies (not (zerop x))
           (equal (difference x (sub1 x)) 1)))

; Similarly for top2:

(prove-lemma difference-x-sub2-x (rewrite)
  (implies (and (not (zerop x))
                (not (zerop (sub1 x))))
           (equal (difference x (sub1 (sub1 x))) 2)))

; We then eliminate the gets in these cases because the p machine
; uses top1 and top2, not get-1 and get-2:

(enable get-0)

(prove-lemma get-1 (rewrite)
  (equal (get 1 lst) (cadr lst)))

(prove-lemma get-2 (rewrite)
  (equal (get 2 lst) (caddr lst)))
  
; Now I turn to the control stack.  Again, we need to be able to
; get and put into it.  However, we only entertain those operations
; on local variable positions of the top frame.

; We begin with get

; The key idea, of course, is that getting at a specified position
; in the strip-cdrs of an alist is the same as assoc.

(prove-lemma get-find-position-of-var nil
  (implies (and (proper-p-alistp alist p)
                (member var (strip-cars alist)))
           (equal (get (find-position-of-var var (strip-cars alist))
                       (append (strip-cdrs alist) stk))
                  (cdr (assoc var alist)))))

; Now we have to work a little to establish the correspondence between
; the list we find the position in and the list we assoc into.

(prove-lemma member-implies-lessp-find-position-of-var (rewrite)
  (implies (member x lst)
           (lessp (find-position-of-var x lst) (length lst))))

(prove-lemma equal-strip-cars-implies-equal-lengths nil
  (implies (equal (strip-cars x) y)
           (equal (length x) (length y))))

(enable length-strip-cars)

(prove-lemma length-bindings (rewrite)
  (implies (proper-p-statep1 p)
           (equal (length (bindings (car (p-ctrl-stk p))))
                  (plus (length
                         (formal-vars (assoc (car (untag (p-pc p)))
                                             (p-prog-segment p))))
                        (length
                         (temp-var-dcls
                          (assoc (car (untag (p-pc p)))
                                 (p-prog-segment p)))))))
  ((use (equal-strip-cars-implies-equal-lengths
         (x (bindings (car (p-ctrl-stk p))))
         (y (APPEND (FORMAL-VARS
                     (ASSOC (CAR (UNTAG (P-PC P)))
                            (P-PROG-SEGMENT P)))
                    (STRIP-CARS
                     (TEMP-VAR-DCLS (ASSOC (CAR (UNTAG (P-PC P)))
                                           (P-PROG-SEGMENT P))))))))))

(prove-lemma difference-plus{special} (rewrite)
  (equal (difference (plus x y) x) (fix y)))

(prove-lemma p->r_ctrl-stk1-opener (rewrite)
  (implies (proper-p-statep1 p)
           (equal (p->r_ctrl-stk1 (p-ctrl-stk p)
                                  (p-max-ctrl-stk-size p))
                  (append (p->r_p-frame (top (p-ctrl-stk p))
                                        (pop (p-ctrl-stk p))
                                        (p-max-ctrl-stk-size p))
                          (p->r_ctrl-stk1 (pop (p-ctrl-stk p))
                                          (p-max-ctrl-stk-size p)))))
  ((expand (p->r_ctrl-stk1 (p-ctrl-stk p)
                           (p-max-ctrl-stk-size p)))))

; And here is the main lemma about getting at a local variable
; slot in the mapped down control stack:

(prove-lemma get-cdr-p->r_ctrl-stk-1 (rewrite)
  (implies (and (proper-p-statep1 p)
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p))))          
                (member var
                        (append (formal-vars (assoc (car (untag (p-pc p)))
                                                    (p-prog-segment p)))
                                (strip-cars
                                 (temp-var-dcls
                                  (assoc (car (untag (p-pc p)))
                                         (p-prog-segment p)))))))
           (equal (get
                   (plus (difference (p-max-ctrl-stk-size p)
                                     (p-ctrl-stk-size (p-ctrl-stk p)))
                         (find-position-of-var
                          var
                          (append (formal-vars (assoc (car (untag (p-pc p)))
                                                      (p-prog-segment p)))
                                  (strip-cars
                                   (temp-var-dcls
                                    (assoc (car (untag (p-pc p)))
                                           (p-prog-segment p)))))))
                   (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                       (p-max-ctrl-stk-size p))))
                  (cdr (assoc var
                              (bindings (car (p-ctrl-stk p)))))))
  ((use (get-find-position-of-var
         (alist (bindings (car (p-ctrl-stk p))))))))


; Now we turn to put.

(prove-lemma put-find-position-of-var nil
  (implies (and (proper-p-alistp alist p)
                (member var (strip-cars alist)))
           (equal (put val
                       (find-position-of-var var (strip-cars alist))
                       (append (strip-cdrs alist) stk))
                  (append (strip-cdrs (put-assoc val var alist)) stk))))

(enable equal-length-0)

(prove-lemma put-plus-append (rewrite)
  (implies (equal i (length a))
           (equal (put val (plus i j) (append a b))
                  (append a (put val j b))))
  ((induct (get i a))))

(prove-lemma length-put-assoc (rewrite)
  (equal (length (put-assoc val name alist)) (length alist)))

(prove-lemma p-ctrl-stk-size-cons-p-frame-put-assoc (rewrite)
  (implies (listp stk)
           (equal
            (p-ctrl-stk-size
             (cons (p-frame (put-assoc val
                                       var
                                       (bindings (car stk)))
                            (ret-pc (car stk)))
                   (cdr stk)))
            (p-ctrl-stk-size stk))))


(enable associativity-of-append)

(prove-lemma put-cdr-p->r_ctrl-stk-1 (rewrite)
  (implies (and (proper-p-statep1 p)
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p))))          
                (member var
                        (append (formal-vars (assoc (car (untag (p-pc p)))
                                                    (p-prog-segment p)))
                                (strip-cars
                                 (temp-var-dcls
                                  (assoc (car (untag (p-pc p)))
                                         (p-prog-segment p)))))))
           (equal
            (put
             val
             (plus
              (difference (p-max-ctrl-stk-size p)
                          (p-ctrl-stk-size (p-ctrl-stk p)))
              (find-position-of-var
               var
               (append
                (formal-vars (assoc (car (untag (p-pc p)))
                                    (p-prog-segment p)))
                (strip-cars (temp-var-dcls (assoc (car (untag (p-pc p)))
                                                  (p-prog-segment p)))))))
             (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                 (p-max-ctrl-stk-size p))))
            (cdr (p->r_ctrl-stk
                  (cons (p-frame (put-assoc val
                                            var
                                            (bindings (car (p-ctrl-stk p))))
                                 (ret-pc (car (p-ctrl-stk p))))
                        (cdr (p-ctrl-stk p)))
                  (p-max-ctrl-stk-size p)))))
  ((disable p-ctrl-stk-size p->r_cfp)
   (use (put-find-position-of-var
         (alist (bindings (car (p-ctrl-stk p))))
         (stk (cons
               (p->r_cfp (cdr (p-ctrl-stk p))
                         (p-max-ctrl-stk-size p))
               (cons (ret-pc (car (p-ctrl-stk p)))
                     (append (p->r_ctrl-stk1 (cdr (p-ctrl-stk p))
                                             (p-max-ctrl-stk-size p))
                             '((nat 0))))))))))

; Recall that we are keeping p->r_sys-data-segment closed.  So we have
; to package up the put-assoc that the r machine does on its sys-data-segment:

(prove-lemma car-p->r_ctrl-stk (rewrite)
  (equal (car (p->r_ctrl-stk temp-stk max)) 'cstk))

(prove-lemma car-p->r_temp-stk (rewrite)
  (equal (car (p->r_temp-stk temp-stk max)) 'tstk))

(prove-lemma put-assoc-cstk-p->r_sys-data-segment-local (rewrite)
  (equal (put-assoc (cdr (p->r_ctrl-stk ctrl-stk1 max-ctrl-stk-size1))
                    'cstk
                    (p->r_sys-data-segment ctrl-stk2
                                           max-ctrl-stk-size2
                                           temp-stk2
                                           max-temp-stk-size2))
         (p->r_sys-data-segment ctrl-stk1
                                max-ctrl-stk-size1
                                temp-stk2
                                max-temp-stk-size2)))

; Note:  The suffix "local" on the name above is present because we
; have a more elaborate version of this same idea later for call.

; Finally, we shut down the mappers:

(disable p->r_ctrl-stk)
(disable p->r_temp-stk)
(disable p->r_sys-data-segment)

; Now we address the stk-equal problem.  Since we have p->r_sys-data-segment
; disabled, we need theorems that tell us when one such application is
; stk-equal to another or to a put-assoc that changes on of the components.

; The following function is the standard induction hint for theorems about
; stk-equal that use a non-variable term for the stack pointer.  E.g.,
; if (stk-equal sp ...) could be proved by pop-to-empty-stkp induction
; on sp, then (stk-equal (tag 'sys-addr (cons 'cstk n)) ...) should be
; proved by (stk-equal-hint-1 n ...) induction on n.

(defn stk-equal-hint-1 (n max)
  (if (zerop (difference max n))
      t
      (stk-equal-hint-1 (add1 n)
                        max))
  ((lessp (difference max n))))


; Because of the restrictions on the form of terms used as induction
; hints, we need a second form of this hint function.  (The problem has
; to do with the prohibition of non-variable terms in induction hint
; args, even for args in constant slots.)

(enable difference-x-0)

(defn stk-equal-hint-2 (n ctrl-stk max-ctrl-stk-size
                          temp-stk max-temp-stk-size)
  (if (zerop (sub1
              (difference
               (length
                (cdr (assoc 'cstk
                            (p->r_sys-data-segment ctrl-stk
                                                   max-ctrl-stk-size
                                                   temp-stk
                                                   max-temp-stk-size))))
               n)))
      t
      (stk-equal-hint-2 (plus n 1)
                        ctrl-stk max-ctrl-stk-size
                        temp-stk max-temp-stk-size))
  ((lessp (sub1
           (difference
            (length
             (cdr (assoc 'cstk
                         (p->r_sys-data-segment ctrl-stk
                                                max-ctrl-stk-size
                                                temp-stk
                                                max-temp-stk-size)
                         )))
            n)))))

; By the way, normally in the theorems we have to prove formulas of the
; form (stk-equal sp segment1 segment2) have the following ancestry and:
; form.  The sp is some semi-explicit pointer like 
; (tag 'sys-addr (cons 'cstk n)) as produced by p->r_csp.  Segment1 is
; a call of p->r_sys-data-segment on the result of stepping the p machine.
; Segment2 is the result of stepping the r machine on the original
; p->r_sys-data-segment.  

; If the stack pointer of interest is in the cstk area, then it doesn't
; matter what happens to the tstk area at the r level.  The following theorem
; formalizes that for the case where the r-level does nothing, e.g., no-op.

(prove-lemma stk-equal-reflexive-cstk (rewrite)
  (stk-equal (tag 'sys-addr (cons 'cstk n))
             (p->r_sys-data-segment ctrl-stk
                                    max-ctrl-stk-size
                                    temp-stk1
                                    max-temp-stk-size1)
             (p->r_sys-data-segment ctrl-stk
                                    max-ctrl-stk-size
                                    temp-stk2
                                    max-temp-stk-size2))
  ((induct (stk-equal-hint-2 n
                             ctrl-stk
                             max-ctrl-stk-size
                             temp-stk1
                             max-temp-stk-size1))))


; The next theorem formalizes it (by reducing it to the no-op case) when the
; r-level just hits the tstk:

(prove-lemma assoc-put-assoc-1 (rewrite)
  (implies (not (equal name1 name2))
           (equal (assoc name1 (put-assoc val name2 alist))
                  (assoc name1 alist))))

(defn stk-equal-hint-3 (n segment)
      (if (zerop (sub1 (difference (length (cdr (assoc 'cstk segment)))
                                   n)))
          t
          (stk-equal-hint-3 (plus n 1) segment))
      ((lessp (sub1 (difference (length (cdr (assoc 'cstk segment)))
                                n)))))

(prove-lemma stk-equal-cstk-put-assoc-tstk (rewrite)
  (equal (stk-equal (tag 'sys-addr (cons 'cstk n))
                    segment1
                    (put-assoc area 'tstk segment2))
         (stk-equal (tag 'sys-addr (cons 'cstk n))
                    segment1
                    segment2))
  ((induct (stk-equal-hint-3 n segment1))))

; We now do the same thing for the case where the r-level machine doesn't
; change the cstk.  This is very common, of course.

(defn stk-equal-hint-4 (n ctrl-stk max-ctrl-stk-size
                          temp-stk max-temp-stk-size)
  (if (zerop (sub1
              (difference
               (length
                (cdr (assoc 'tstk
                            (p->r_sys-data-segment ctrl-stk
                                                   max-ctrl-stk-size
                                                   temp-stk
                                                   max-temp-stk-size))))
               n)))
      t
      (stk-equal-hint-4 (plus n 1)
                        ctrl-stk max-ctrl-stk-size
                        temp-stk max-temp-stk-size))
  ((lessp (sub1
           (difference
            (length
             (cdr (assoc 'tstk
                         (p->r_sys-data-segment ctrl-stk
                                                max-ctrl-stk-size
                                                temp-stk
                                                max-temp-stk-size)
                         )))
            n)))))

(prove-lemma stk-equal-reflexive-tstk (rewrite)
  (stk-equal (tag 'sys-addr (cons 'tstk n))
             (p->r_sys-data-segment ctrl-stk1
                                    max-ctrl-stk-size1
                                    temp-stk
                                    max-temp-stk-size)
             (p->r_sys-data-segment ctrl-stk2
                                    max-ctrl-stk-size2
                                    temp-stk
                                    max-temp-stk-size))
  ((induct (stk-equal-hint-4 n
                             ctrl-stk1
                             max-ctrl-stk-size1
                             temp-stk
                             max-temp-stk-size))))


; This completely handles the stk-equal work for the cstk (except on
; CALL and RET, which we be done specially when they arise).  Now I
; turn to tstk.

; Consider the pattern of pushes and pops used by our instructions.
; For each we need to know that the high level operation corresponds to
; the low level one.  The patterns we use are

;   pattern     typical instruction

;  push            push-global
;  pop             pop-global
;  pop 2           deposit
;  pop 1 push 1    add1-nat
;  pop 2 push 1    add-addr
;  pop 3 push 2    add-nat-with-carry
;  pop 1 push 2    mult2-nat-with-carry-out

; Our approach to stk-equal questions of the form
; (stk-equal (tag 'sys-addr (cons 'tstk n))
;            (p->r_sys-data-segment ... p-level-temp-stk ...)
;            r-level-temp-stk)
; will be to reduce them to (equal p-level-temp-stk &), where & is the
; "live part" of the r-level-temp-stk.  We don't define the function
; live-part but rather just use the combination of cdr-n and all-but-last
; defined below.

(prove-lemma get-equal-car-cdr-n (rewrite)
  (equal (get n lst) (car (cdr-n n lst))))

(prove-lemma cdr-n-nil (rewrite)
  (implies (and (not (lessp n (length lst)))
                (properp lst))
           (equal (cdr-n n lst)
                  (if (equal (fix n) (length lst))
                      nil
                      0))))

(prove-lemma length-all-but-last (rewrite)
  (equal (length (all-but-last x))
         (sub1 (length x))))

(prove-lemma properp-all-but-last (rewrite)
  (properp (all-but-last x)))

(prove-lemma stk-equal-is-equal-cdr-n-all-but-last-lemma1 (rewrite)
  (implies (equal (cdr-n n x) (cdr-n n y))
           (equal (equal (cdr-n n (cdr x)) (cdr-n n (cdr y)))
                  t)))

(prove-lemma stk-equal-is-equal-cdr-n-all-but-last-lemma2 (rewrite)
  (implies (and (lessp n (sub1 (length lst1)))
                (numberp n)
                (equal (cdr-n n (cdr (all-but-last lst1)))
                       (cdr-n n (cdr (all-but-last lst2))))
                (equal (length lst1)
                       (length lst2))
                (not (equal (cdr-n n (all-but-last lst1))
                            (cdr-n n (all-but-last lst2)))))
           (not (equal (car (cdr-n n lst1))
                       (car (cdr-n n lst2))))))

(prove-lemma stk-equal-is-equal-cdr-n-all-but-last-lemma3 (rewrite)
  (implies (and (lessp n (sub1 (length lst1)))
                (numberp n)
                (equal (length lst1)
                       (length lst2))
                (equal
                 (cdr-n n
                        (all-but-last lst1))
                 (cdr-n n
                        (all-but-last lst2))))
           (equal (equal (car (cdr-n n lst1))
                         (car (cdr-n n lst2)))
                  t)))

(prove-lemma equal-sub1-difference-0 (rewrite)
  (equal (equal (sub1 (difference x y)) 0)
         (not (lessp y (sub1 x))))
  ((enable difference)))

; This is the key theorem.  We do not, in general, want to eliminate
; stk-equal, so it is proved with lemma class nil.  We'll prove a
; certain instance of it later for use as a rewrite rule.

; Note that as proved below it applies as well to the cstk as to tstk.

(prove-lemma stk-equal-is-equal-cdr-n-all-but-last nil
  (implies (and (numberp (cdr (untag sp)))
                (equal (length (cdr (assoc (car (untag sp)) segment1)))
                       (length (cdr (assoc (car (untag sp)) segment2)))))
           (equal (stk-equal sp segment1 segment2)
                  (equal (cdr-n (cdr (untag sp))
                                (all-but-last
                                 (cdr (assoc (car (untag sp)) segment1))))
                         (cdr-n (cdr (untag sp))
                                (all-but-last
                                 (cdr (assoc (car (untag sp)) segment2)))))))
  ((enable empty-stkp)
   (induct (stk-equal sp segment1 segment2))))

(disable equal-sub1-difference-0)
(disable get-equal-car-cdr-n)
(disable cdr-n-nil)
(disable stk-equal-is-equal-cdr-n-all-but-last-lemma1)
(disable stk-equal-is-equal-cdr-n-all-but-last-lemma2)
(disable stk-equal-is-equal-cdr-n-all-but-last-lemma3)


(prove-lemma assoc-put-assoc-2 (rewrite)
  (implies (definedp name alist)
           (equal (assoc name (put-assoc val name alist))
                  (cons name val))))

(prove-lemma all-but-last-append (rewrite)
  (implies (listp b)
           (equal (all-but-last (append a b))
                  (append a (all-but-last b)))))

(prove-lemma length-cdr-n (rewrite)
  (equal (length (cdr-n n lst))
         (difference (length lst) n))
  ((enable difference)))

(enable append-right-id)

(prove-lemma cdr-n-append{special} (rewrite)
  (implies (equal n (length a))
           (equal (cdr-n n (append a b)) b)))

; Here, finally, is the rewrite rule that reduce stk-equal
; questions on tstk to consideration of the "live part" of the
; r-level stack:

(prove-lemma stk-equal-tstk-p->r_sys-data-segment (rewrite)
  (implies (and (properp temp-stk)
                (equal n (difference max-temp-stk-size
                                     (length temp-stk)))
                (not (lessp max-temp-stk-size (length temp-stk)))
                (equal (add1 max-temp-stk-size)
                       (length (cdr (assoc 'tstk segment)))))
           (equal (stk-equal (tag 'sys-addr
                                  (cons 'tstk n))
                             (p->r_sys-data-segment ctrl-stk
                                                    max-ctrl-stk-size
                                                    temp-stk
                                                    max-temp-stk-size)
                             segment)
                  (equal temp-stk
                         (cdr-n (difference max-temp-stk-size
                                            (length temp-stk))
                                (all-but-last
                                 (cdr (assoc 'tstk segment)))))))
((enable p->r_temp-stk)
   (use (stk-equal-is-equal-cdr-n-all-but-last
         (sp (tag 'sys-addr
                  (cons 'tstk
                        (difference max-temp-stk-size
                                    (length temp-stk)))))
         (segment1 (p->r_sys-data-segment ctrl-stk
                                          max-ctrl-stk-size
                                          temp-stk
                                          max-temp-stk-size))
         (segment2 segment)))))
                              
(disable stk-equal)
(disable empty-stkp)

; To use the theorem above we need to relieve the hypotheses.

; The typical form of instantiations for temp-stk in the lemma
; above is either (p-temp-stk p) or else some collection of
; conses and cdrs of it.  We need to know that it is proper.
; The first theorem below establishes that the initial temp
; stack is proper.

(prove-lemma proper-p-temp-stkp-implies-properp nil
  (implies (proper-p-temp-stkp stk p)
           (properp stk)))

(prove-lemma properp-p-temp-stkp (rewrite)
  (implies (proper-p-statep1 p)
           (properp (p-temp-stk p)))
  ((use (proper-p-temp-stkp-implies-properp (stk (p-temp-stk p))))))

; And this one establishes that the cdr of it is proper.  This is
; what we'll need when we pop.

(prove-lemma properp-implies-properp-cdr (rewrite)
  (implies (and (listp x)
                (properp x))
           (properp (cdr x))))

; When we push we'll cons onto the stack and that cons will be eaten
; by properp itself.

; The only other problematic hypothesis for the lemma above is that
; concerning the length of the new tstk area.  The typical instantiation
; of segment above will a put-assoc.  When we assoc for 'tstk in it we
; will get a (put val n previous-area), where n is some legal address in
; the previous tstk area.  We need to know the length of the resulting
; area.  It is, of course, unchanged:

(enable length-put)

; That handles most of the problems I can anticipate on relieving the
; hyps.  Now we consider simplifying the rhs of the lemma under the
; typical instantiations of segment.  We are interested in cdr-n and
; all-but-last lemmas on the result of (assoc 'tstk segment).  As noted,
; the assoc will turn into a put under most instantiations of segment.

; In the case that it is a put, we will use the following lemma to
; drive the all-but-last through the put.  If there are multiple puts,
; this lemma will drive it all the way down.

(prove-lemma all-but-last-put (rewrite)
  (implies (lessp n (sub1 (length lst)))
           (equal (all-but-last (put val n lst))
                  (put val n (all-but-last lst)))))

; Eventually it will come to rest against the original tsk and we'll
; open it up:

(prove-lemma all-but-last-cdr-p->r_temp-stk (rewrite)
  (implies (properp temp-stk)
           (equal (all-but-last
                   (cdr (p->r_temp-stk temp-stk max-temp-stk-size)))
                  (append (nat-0s (difference max-temp-stk-size
                                              (length temp-stk)))
                          temp-stk)))
  ((enable p->r_temp-stk)))

; to remove the (NAT 0) at the end, kicking out an append
; which will let the PUTs start to resolve themselves.

; Now if the put is an simple push the following lemma will take care
; of it:

(prove-lemma nat-0s-opener-at-right-end nil
  (equal (nat-0s n)
         (if (zerop n)
             nil
             (append (nat-0s (sub1 n)) (list '(nat 0))))))
           
(prove-lemma nat-0s-opener-at-right-end-on-add1 (rewrite)
  (equal (nat-0s (add1 n))
         (append (nat-0s n) (list '(nat 0))))
  ((use (nat-0s-opener-at-right-end (n (add1 n))))))

(prove-lemma put-append (rewrite)
  (implies (and (equal n (length a))
                (listp b))
           (equal (put val n (append a b))
                  (append a (cons val (cdr b)))))
  ((induct (get n a))))

; Whew!  That was tough wasn't it?  Anyway, here is the key fact
; about a put that implements a push.

(prove-lemma put-append-1{special} (rewrite)
  (implies (and (not (zerop n))
                (equal k (sub1 n)))
           (equal (put val k (append (nat-0s n) lst))
                  (append (nat-0s k) (cons val lst))))
  ((disable nat-0s)
   (use (nat-0s-opener-at-right-end))))

; The following is needed to simplify the cdr-n in the case where
; we have done a pop.

(prove-lemma cdr-n-cdr (rewrite)
  (equal (cdr-n n (cdr lst))
         (cdr (cdr-n n lst))))


; There are probably more facts about cdr-n than I have proved.  I will
; prove the rest as needed to get the owc proofs through.

; Now we begin considering the same-signature requirements of r-equal.

(prove-lemma same-signature-reflexive{special} (rewrite)
  (implies (and (not (lessp max-ctrl-stk-size (p-ctrl-stk-size ctrl-stk1)))
                (not (lessp max-ctrl-stk-size (p-ctrl-stk-size ctrl-stk2)))
                (not (lessp max-temp-stk-size (length temp-stk1)))
                (not (lessp max-temp-stk-size (length temp-stk2))))
           (same-signature (p->r_sys-data-segment ctrl-stk1
                                                  max-ctrl-stk-size
                                                  temp-stk1
                                                  max-temp-stk-size)
                           (p->r_sys-data-segment ctrl-stk2
                                                  max-ctrl-stk-size
                                                  temp-stk2
                                                  max-temp-stk-size)))
  ((enable p->r_sys-data-segment p->r_ctrl-stk p->r_temp-stk)))

(prove-lemma same-signature-put-assoc-1 (rewrite)
  (implies (and (definedp name segment1)
                (litatom name)
                (equal (length val)
                       (length (definiens name segment1))))
           (equal (same-signature (put-assoc val name segment1)
                                  segment2)
                  (same-signature segment1 segment2))))

(prove-lemma same-signature-put-assoc-2 (rewrite)
  (implies (and (definedp name segment2)
                (litatom name)
                (equal (length val)
                       (length (definiens name segment2))))
           (equal (same-signature segment1
                                  (put-assoc val name segment2))
                  (same-signature segment1 segment2))))


(disable same-signature)


; Now I want to disable get and put so that they are only manipulated by
; the lemmas we have proved.

(disable get)

(disable put)

; I have decided to do the owc proofs at this level a little differently.
; First I will prove that
; (p-xxx-okp p) -> (requal (p->r (p-xxx-step p)) (r-xxx-step (p->r p)))
; Then I will prove
; (p-xxx-okp p) -> (r-xxx-okp (p->r p)).

; Then I will put them together to get 
; (p->xxx-okp p) -> (r-equal (p->r (p-xxx-step p)) (r-step (p->r p))).

; We now begin the owc proofs.  I have selected several theorems for my
; initial test section and will work on the lemma development to make the
; proofs of these work.  Then I'll turn it loose on all the others.
; CALL and RET are left for last.  I have made sure to include one theorem
; for each pattern of tstk use mentioned above, plus local variable
; pushing and popping.  I begin, as always, with no-op, the simplest.

(prove-lemma no-op-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'no-op)
               (proper-p-statep p)
               (p-no-op-okp (p-current-instruction p)
                          p))
          (r-equal (p->r (p-no-op-step (p-current-instruction p)
                                       p))
                   (r-no-op-step (p-current-instruction p)
                                 (p->r p)))))

(prove-lemma push-global-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-global)
               (proper-p-statep p)
               (p-push-global-okp (p-current-instruction p)
                          p))
          (r-equal (p->r (p-push-global-step (p-current-instruction p)
                                       p))
                   (r-push-global-step (p-current-instruction p)
                                 (p->r p)))))

(prove-lemma lessp-length-cdr (rewrite)
  (not (lessp (length x) (length (cdr x)))))

; To relieve the 2nd hypothesis of get-cdr-p->r_temp-stk, the one
; that says that i is less than max-temp-stk-size, we need to know,
; in the case of a simple pop, that:

(prove-lemma lessp-difference-x-y-x (rewrite)
  (implies (and (not (lessp max (length temp-stk)))
                (listp temp-stk))
           (lessp (difference max (length temp-stk))
                  max)))

; Note:  The rule above uses max as a free-var, accidentally.  I
; don't know if this will prevent its use later...

(prove-lemma pop-global-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-global)
               (proper-p-statep p)
               (p-pop-global-okp (p-current-instruction p)
                          p))
          (r-equal (p->r (p-pop-global-step (p-current-instruction p)
                                       p))
                   (r-pop-global-step (p-current-instruction p)
                                 (p->r p)))))

(prove-lemma push-local-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-local)
               (proper-p-statep p)
               (p-push-local-okp (p-current-instruction p)
                                 p))
          (r-equal (p->r (p-push-local-step (p-current-instruction p)
                                            p))
                   (r-push-local-step (p-current-instruction p)
                                      (p->r p)))))

(prove-lemma pop-local-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-local)
               (proper-p-statep p)
               (p-pop-local-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-pop-local-step (p-current-instruction p)
                                           p))
                   (r-pop-local-step (p-current-instruction p)
                                     (p->r p)))))

(prove-lemma difference-add1-x-x (rewrite)
  (equal (difference (add1 x) x) 1))

(prove-lemma cdr-n-append-pop2 (rewrite)
  (implies (and (not (zerop n))
                (not (zerop (sub1 n))))
           (equal (cdr-n n (append (nat-0s (sub1 (sub1 n))) stk))
                  (cddr stk))))

(prove-lemma deposit-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit)
               (proper-p-statep p)
               (p-deposit-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-deposit-step (p-current-instruction p)
                                         p))
                   (r-deposit-step (p-current-instruction p)
                                   (p->r p)))))

; The following lemmas are needed because lessp opens up when it
; on (lessp (p-max-temp-stk-size p) (length (p-temp-stk p)))
; because length opens up.

(prove-lemma not-equal-p-max-temp-stk-size-0 (rewrite)
  (implies (and (listp (p-temp-stk p))
                (not (lessp (p-max-temp-stk-size p)
                            (length (p-temp-stk p)))))
           (not (equal (p-max-temp-stk-size p) 0))))

(prove-lemma not-lessp-sub1-p-max-temp-stk-size (rewrite)
  (implies (not (lessp (p-max-temp-stk-size p)
                       (length (p-temp-stk p))))
           (not (lessp (sub1 (p-max-temp-stk-size p))
                       (length (cdr (p-temp-stk p)))))))

(prove-lemma add1-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-nat)
               (proper-p-statep p)
               (p-add1-nat-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-add1-nat-step (p-current-instruction p)
                                          p))
                   (r-add1-nat-step (p-current-instruction p)
                                    (p->r p)))))


; The following lemma explains a push after two pops.

(prove-lemma put-append-2{special} (rewrite)
  (implies (and (not (zerop n))
                (listp (cdr stk)))
           (equal (put val n (append (nat-0s (sub1 n)) stk))
                  (append (nat-0s (sub1 n))
                          (cons (car stk)
                                (cons val (cddr stk))))))
  ((enable put)))

(prove-lemma cdr-n-append-2 (rewrite)
  (implies (not (zerop n))
           (equal (cdr-n n (append (nat-0s (sub1 n)) stk))
                  (cdr stk))))

(prove-lemma add-addr-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-addr)
               (proper-p-statep p)
               (p-add-addr-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-add-addr-step (p-current-instruction p)
                                          p))
                   (r-add-addr-step (p-current-instruction p)
                                    (p->r p)))))

; Because add-nat-with-carry writes twice to the tstk, we need:

(enable put-assoc-put-assoc)

; Both the p and the r machine use fix-small-natural and small-naturalp
; to operate on nats, so I will

(disable fix-small-natural)
(disable small-naturalp)
(disable bool-to-nat)
(disable bool)

; The following lemma explains a push after three pops.


(prove-lemma put-append-nat-0s-sub1-sub1 (rewrite)
  (implies (and (not (zerop (sub1 n)))
                (listp (cddr stk)))
           (equal (put val n (append (nat-0s (sub1 (sub1 n))) stk))
                  (append (nat-0s (sub1 (sub1 n)))
                          (cons (car stk)
                                (cons (cadr stk)
                                      (cons val (cdddr stk)))))))
  ((enable put)))

(prove-lemma add-nat-with-carry-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat-with-carry)
               (proper-p-statep p)
               (p-add-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-add-nat-with-carry-step (p-current-instruction p)
                                                    p))
                   (r-add-nat-with-carry-step (p-current-instruction p)
                                              (p->r p)))))

; As above, length opens up on (cons val (cdr temp-stk)), and lessp
; opens on that and we have to accomodate them.

(prove-lemma not-equal-sub1-p-max-temp-stk-size-0 (rewrite)
  (implies (and (listp (p-temp-stk p))
                (lessp (length (p-temp-stk p))
                       (p-max-temp-stk-size p)))
           (not (equal (sub1 (p-max-temp-stk-size p)) 0))))

(prove-lemma not-lessp-sub1-sub1-p-max-temp-stk-size (rewrite)
  (implies (lessp (length (p-temp-stk p))
                  (p-max-temp-stk-size p))
           (equal (lessp (sub1 (sub1 (p-max-temp-stk-size p)))
                         (length (cdr (p-temp-stk p))))
                  f)))

(prove-lemma mult2-nat-with-carry-out-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat-with-carry-out)
               (proper-p-statep p)
               (p-mult2-nat-with-carry-out-okp (p-current-instruction p)
                                               p))
          (r-equal (p->r (p-mult2-nat-with-carry-out-step
                          (p-current-instruction p)
                          p))
                   (r-mult2-nat-with-carry-out-step
                    (p-current-instruction p)
                    (p->r p)))))

(prove-lemma difference-sub1 (rewrite)
  (equal (difference (sub1 x) y) (sub1 (difference x y))))

(prove-lemma fetch-temp-stk-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch-temp-stk)
               (proper-p-statep p)
               (p-fetch-temp-stk-okp (p-current-instruction p)
                                               p))
          (r-equal (p->r (p-fetch-temp-stk-step
                          (p-current-instruction p)
                          p))
                   (r-fetch-temp-stk-step
                    (p-current-instruction p)
                    (p->r p)))))

(prove-lemma properp-put (rewrite)
  (implies (properp lst)
           (properp (put val n lst)))
  ((enable put)))

(prove-lemma cdr-n-put (rewrite)
  (implies (and (not (lessp n k))
                (lessp n (length lst)))
           (equal (cdr-n k
                         (put val
                              n
                              lst))
                  (put val
                       (difference n k)
                       (cdr-n k lst))))
  ((enable put difference)))
                              
(prove-lemma deposit-temp-stk-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit-temp-stk)
               (proper-p-statep p)
               (p-deposit-temp-stk-okp (p-current-instruction p)
                                               p))
          (r-equal (p->r (p-deposit-temp-stk-step
                          (p-current-instruction p)
                          p))
                   (r-deposit-temp-stk-step
                    (p-current-instruction p)
                    (p->r p)))))

(disable cdr-n-put)
(disable difference-sub1)

; The pop* instruction shows a new twist:  popping many things off tstk.
; The p machine uses popn but we have a lot of machinery sitting around
; for cdr-n, which is an equivalent function:

(prove-lemma popn-is-cdr-n (rewrite)
  (equal (popn n lst) (cdr-n n lst)))

; We now turn to stk-equal on the tstk. Recall 
; stk-equal-tstk-p->r_sys-data-segment:  it has two variables of importance,
; temp-stk, the p-level version of the stack, and segment, the r-level
; sys-data-segment. In the call case, temp-stk will be a popn (now cdr-n)
; and segment is untouched.  If we can relieve the hyps of the lemma,
; we will have to prove that the popn is equal to a certain 
; cdrn-all-but-last expression.

(prove-lemma properp-cdr-n (rewrite)
  (implies (not (lessp (length lst) n))
           (equal (properp (cdr-n n lst))
                  (properp lst))))

; That relieves the hyps.  The all-but-last disappears under
; the hands of our previous lemmas, taking the terminal '(NAT 0)
; with it.  We are left with proving the equivalence of two CDR-N
; expressions.  The key is getting the n in one of them into a
; normal form to allow cdr-n-plus-append, below, to apply.

(prove-lemma difference-x-difference (rewrite)
  (implies (and (not (lessp len n))
                (not (lessp max len)))
           (equal (difference max (difference len n))
                  (plus n (difference max len)))))

(prove-lemma cdr-n-plus-append (rewrite)
  (implies (equal i (length a))
           (equal (cdr-n (plus i j) (append a b))
                  (cdr-n j b))))

(prove-lemma cdr-n-plus-append-commuted (rewrite)
  (implies (equal i (length a))
           (equal (cdr-n (plus j i) (append a b))
                  (cdr-n j b))))

(prove-lemma pop*-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop*)
               (proper-p-statep p)
               (p-pop*-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-pop*-step (p-current-instruction p)
                                           p))
                   (r-pop*-step (p-current-instruction p)
                                     (p->r p)))))

(prove-lemma length-cdr-cdr-n (rewrite)
  (equal (length (cdr (cdr-n n lst)))
         (difference (length (cdr lst)) n))
  ((disable length-cdr-n)
   (use (length-cdr-n (n (add1 n))))))

(prove-lemma properp-cdr-cdr-n (rewrite)
  (implies (not (lessp (length lst) (add1 n)))
           (equal (properp (cdr (cdr-n n lst)))
                  (properp lst)))
  ((disable properp-cdr-n)
   (use (properp-cdr-n (n (add1 n))))))

(prove-lemma cdr-n-plus-sub1-append-commuted (rewrite)
  (implies (and (not (zerop i))
                (numberp j)
                (equal (sub1 i) (length a)))
           (equal (cdr-n (plus j i) (append a b))
                  (cdr (cdr-n j b))))
  ((disable cdr-n-plus-append-commuted)
   (use (cdr-n-plus-append-commuted (i (sub1 i)) (j (add1 j))))))

(prove-lemma popn-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popn)
               (proper-p-statep p)
               (p-popn-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-popn-step (p-current-instruction p)
                                           p))
                   (r-popn-step (p-current-instruction p)
                                     (p->r p)))))

; This ends the test section.


(prove-lemma set-local-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-local)
               (proper-p-statep p)
               (p-set-local-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-set-local-step (p-current-instruction p)
                                           p))
                   (r-set-local-step (p-current-instruction p)
                                     (p->r p)))))

(prove-lemma set-global-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-global)
               (proper-p-statep p)
               (p-set-global-okp (p-current-instruction p)
                                 p))
          (r-equal (p->r (p-set-global-step (p-current-instruction p)
                                            p))
                   (r-set-global-step (p-current-instruction p)
                                      (p->r p)))))

(prove-lemma push-constant-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-constant)
               (proper-p-statep p)
               (p-push-constant-okp (p-current-instruction p)
                                    p))
          (r-equal (p->r (p-push-constant-step (p-current-instruction p)
                                               p))
                   (r-push-constant-step (p-current-instruction p)
                                         (p->r p)))))

(prove-lemma push-ctrl-stk-free-size-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-ctrl-stk-free-size)
               (proper-p-statep p)
               (p-push-ctrl-stk-free-size-okp (p-current-instruction p)
                                              p))
          (r-equal (p->r (p-push-ctrl-stk-free-size-step
                          (p-current-instruction p)
                          p))
                   (r-push-ctrl-stk-free-size-step
                    (p-current-instruction p)
                    (p->r p)))))

(prove-lemma push-temp-stk-free-size-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-free-size)
               (proper-p-statep p)
               (p-push-temp-stk-free-size-okp (p-current-instruction p)
                                              p))
          (r-equal (p->r (p-push-temp-stk-free-size-step
                          (p-current-instruction p)
                          p))
                   (r-push-temp-stk-free-size-step
                    (p-current-instruction p)
                    (p->r p)))))

(prove-lemma push-temp-stk-index-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-index)
               (proper-p-statep p)
               (p-push-temp-stk-index-okp (p-current-instruction p)
                                          p))
          (r-equal (p->r (p-push-temp-stk-index-step
                          (p-current-instruction p)
                          p))
                   (r-push-temp-stk-index-step
                    (p-current-instruction p)
                    (p->r p)))))

(prove-lemma pop-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop)
               (proper-p-statep p)
               (p-pop-okp (p-current-instruction p)
                          p))
          (r-equal (p->r (p-pop-step (p-current-instruction p)
                                     p))
                   (r-pop-step (p-current-instruction p)
                               (p->r p)))))

(prove-lemma jump-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump)
               (proper-p-statep p)
               (p-jump-okp (p-current-instruction p)
                           p))
          (r-equal (p->r (p-jump-step (p-current-instruction p)
                                      p))
                   (r-jump-step (p-current-instruction p)
                                (p->r p)))))

(prove-lemma pushj-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pushj)
               (proper-p-statep p)
               (p-pushj-okp (p-current-instruction p)
                            p))
          (r-equal (p->r (p-pushj-step (p-current-instruction p)
                                       p))
                   (r-pushj-step (p-current-instruction p)
                                 (p->r p)))))

(prove-lemma popj-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popj)
               (proper-p-statep p)
               (p-popj-okp (p-current-instruction p)
                           p))
          (r-equal (p->r (p-popj-step (p-current-instruction p)
                                      p))
                   (r-popj-step (p-current-instruction p)
                                (p->r p)))))

(prove-lemma sub-addr-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-addr)
               (proper-p-statep p)
               (p-sub-addr-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-sub-addr-step (p-current-instruction p)
                                          p))
                   (r-sub-addr-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma eq-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'eq)
               (proper-p-statep p)
               (p-eq-okp (p-current-instruction p)
                         p))
          (r-equal (p->r (p-eq-step (p-current-instruction p)
                                    p))
                   (r-eq-step (p-current-instruction p)
                              (p->r p)))))

(prove-lemma lt-addr-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-addr)
               (proper-p-statep p)
               (p-lt-addr-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-lt-addr-step (p-current-instruction p)
                                         p))
                   (r-lt-addr-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma fetch-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch)
               (proper-p-statep p)
               (p-fetch-okp (p-current-instruction p)
                            p))
          (r-equal (p->r (p-fetch-step (p-current-instruction p)
                                       p))
                   (r-fetch-step (p-current-instruction p)
                                 (p->r p)))))

(disable small-integerp)
(disable iplus)
(disable fix-small-integer)
(disable idifference)
(disable inegate)
(disable ilessp)

(prove-lemma add-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int)
               (proper-p-statep p)
               (p-add-int-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-add-int-step (p-current-instruction p)
                                         p))
                   (r-add-int-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma add-int-with-carry-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int-with-carry)
               (proper-p-statep p)
               (p-add-int-with-carry-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-add-int-with-carry-step (p-current-instruction p)
                                                    p))
                   (r-add-int-with-carry-step (p-current-instruction p)
                                              (p->r p)))))

(prove-lemma add1-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-int)
               (proper-p-statep p)
               (p-add1-int-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-add1-int-step (p-current-instruction p)
                                          p))
                   (r-add1-int-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma sub-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int)
               (proper-p-statep p)
               (p-sub-int-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-sub-int-step (p-current-instruction p)
                                         p))
                   (r-sub-int-step (p-current-instruction p)
                                   (p->r p)))))

(enable commutativity-of-iplus)

(prove-lemma sub-int-with-carry-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int-with-carry)
               (proper-p-statep p)
               (p-sub-int-with-carry-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-sub-int-with-carry-step (p-current-instruction p)
                                                    p))
                   (r-sub-int-with-carry-step (p-current-instruction p)
                                              (p->r p)))))

(prove-lemma sub1-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-int)
               (proper-p-statep p)
               (p-sub1-int-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-sub1-int-step (p-current-instruction p)
                                          p))
                   (r-sub1-int-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma neg-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'neg-int)
               (proper-p-statep p)
               (p-neg-int-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-neg-int-step (p-current-instruction p)
                                         p))
                   (r-neg-int-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma lt-int-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-int)
               (proper-p-statep p)
               (p-lt-int-okp (p-current-instruction p)
                             p))
          (r-equal (p->r (p-lt-int-step (p-current-instruction p)
                                        p))
                   (r-lt-int-step (p-current-instruction p)
                                  (p->r p)))))

(prove-lemma int-to-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'int-to-nat)
               (proper-p-statep p)
               (p-int-to-nat-okp (p-current-instruction p)
                             p))
          (r-equal (p->r (p-int-to-nat-step (p-current-instruction p)
                                        p))
                   (r-int-to-nat-step (p-current-instruction p)
                                  (p->r p)))))

(prove-lemma add-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat)
               (proper-p-statep p)
               (p-add-nat-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-add-nat-step (p-current-instruction p)
                                         p))
                   (r-add-nat-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma sub-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat)
               (proper-p-statep p)
               (p-sub-nat-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-sub-nat-step (p-current-instruction p)
                                         p))
                   (r-sub-nat-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma sub-nat-with-carry-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat-with-carry)
               (proper-p-statep p)
               (p-sub-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-sub-nat-with-carry-step (p-current-instruction p)
                                                    p))
                   (r-sub-nat-with-carry-step (p-current-instruction p)
                                              (p->r p)))))

(prove-lemma sub1-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-nat)
               (proper-p-statep p)
               (p-sub1-nat-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-sub1-nat-step (p-current-instruction p)
                                          p))
                   (r-sub1-nat-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma lt-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-nat)
               (proper-p-statep p)
               (p-lt-nat-okp (p-current-instruction p)
                             p))
          (r-equal (p->r (p-lt-nat-step (p-current-instruction p)
                                        p))
                   (r-lt-nat-step (p-current-instruction p)
                                  (p->r p)))))

(prove-lemma mult2-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat)
               (proper-p-statep p)
               (p-mult2-nat-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-mult2-nat-step (p-current-instruction p)
                                           p))
                   (r-mult2-nat-step (p-current-instruction p)
                                     (p->r p)))))

(prove-lemma div2-nat-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'div2-nat)
               (proper-p-statep p)
               (p-div2-nat-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-div2-nat-step (p-current-instruction p)
                                          p))
                   (r-div2-nat-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma or-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bitv)
               (proper-p-statep p)
               (p-or-bitv-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-or-bitv-step (p-current-instruction p)
                                         p))
                   (r-or-bitv-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma and-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bitv)
               (proper-p-statep p)
               (p-and-bitv-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-and-bitv-step (p-current-instruction p)
                                          p))
                   (r-and-bitv-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma not-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bitv)
               (proper-p-statep p)
               (p-not-bitv-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-not-bitv-step (p-current-instruction p)
                                          p))
                   (r-not-bitv-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma xor-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'xor-bitv)
               (proper-p-statep p)
               (p-xor-bitv-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-xor-bitv-step (p-current-instruction p)
                                          p))
                   (r-xor-bitv-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma rsh-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'rsh-bitv)
               (proper-p-statep p)
               (p-rsh-bitv-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-rsh-bitv-step (p-current-instruction p)
                                          p))
                   (r-rsh-bitv-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma lsh-bitv-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lsh-bitv)
               (proper-p-statep p)
               (p-lsh-bitv-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-lsh-bitv-step (p-current-instruction p)
                                          p))
                   (r-lsh-bitv-step (p-current-instruction p)
                                    (p->r p)))))

(disable and-bool)
(disable or-bool)
(disable not-bool)

(prove-lemma or-bool-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bool)
               (proper-p-statep p)
               (p-or-bool-okp (p-current-instruction p)
                              p))
          (r-equal (p->r (p-or-bool-step (p-current-instruction p)
                                         p))
                   (r-or-bool-step (p-current-instruction p)
                                   (p->r p)))))

(prove-lemma and-bool-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bool)
               (proper-p-statep p)
               (p-and-bool-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-and-bool-step (p-current-instruction p)
                                          p))
                   (r-and-bool-step (p-current-instruction p)
                                    (p->r p)))))

(prove-lemma not-bool-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bool)
               (proper-p-statep p)
               (p-not-bool-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-not-bool-step (p-current-instruction p)
                                          p))
                   (r-not-bool-step (p-current-instruction p)
                                    (p->r p)))))

; In the next owc, we happen to compute a tstk stack pointer that
; is constant.  In particular, we generate (tag 'sys-addr (cons 'tstk n))
; for n = 0.  Thus, the tag computes and we get a constant that does
; not match a tag expression.  I therefore have to prove:

(prove-lemma stk-equal-reflexive-tstk-instance (rewrite)
  (stk-equal '(sys-addr (tstk . 0))
             (p->r_sys-data-segment ctrl-stk1 max-ctrl-stk-size1
                                    temp-stk max-temp-stk-size)
             (p->r_sys-data-segment ctrl-stk2 max-ctrl-stk-size2
                                    temp-stk max-temp-stk-size))
  ((use (stk-equal-reflexive-tstk (n 0)))
   (disable stk-equal-reflexive-tstk)))

(prove-lemma jump-if-temp-stk-full-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-full)
               (proper-p-statep p)
               (p-jump-if-temp-stk-full-okp (p-current-instruction p)
                                            p))
          (r-equal (p->r (p-jump-if-temp-stk-full-step
                          (p-current-instruction p)
                          p))
                   (r-jump-if-temp-stk-full-step
                    (p-current-instruction p)
                    (p->r p)))))

; The following owc depends upon the definition of empty-stkp.  Recall
; that it has been disabled.  This is the only one so far that needs
; to know what it is.  Of course, the test made by the r-level
; jump-if-temp-stk-empty crucially depends on empty-stkp being
; consistently defined with the arithmetic done at the r-level.

(prove-lemma jump-if-temp-stk-empty-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-empty)
               (proper-p-statep p)
               (p-jump-if-temp-stk-empty-okp (p-current-instruction p)
                                             p))
          (r-equal (p->r (p-jump-if-temp-stk-empty-step
                          (p-current-instruction p)
                          p))
                   (r-jump-if-temp-stk-empty-step
                    (p-current-instruction p)
                    (p->r p))))
 ((enable empty-stkp)))

; All of the test instructions at the r level use the same
; predicate the p level does to determine whether the test
; is satisfied.

(disable p-test-natp)
(disable p-test-intp)
(disable p-test-bitvp)
(disable p-test-boolp)

(prove-lemma test-nat-and-jump-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-nat-and-jump)
               (proper-p-statep p)
               (p-test-nat-and-jump-okp (p-current-instruction p)
                                        p))
          (r-equal (p->r (p-test-nat-and-jump-step (p-current-instruction p)
                                                   p))
                   (r-test-nat-and-jump-step (p-current-instruction p)
                                             (p->r p)))))

(prove-lemma test-int-and-jump-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-int-and-jump)
               (proper-p-statep p)
               (p-test-int-and-jump-okp (p-current-instruction p)
                                        p))
          (r-equal (p->r (p-test-int-and-jump-step (p-current-instruction p)
                                                   p))
                   (r-test-int-and-jump-step (p-current-instruction p)
                                             (p->r p)))))

(prove-lemma test-bool-and-jump-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bool-and-jump)
               (proper-p-statep p)
               (p-test-bool-and-jump-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-test-bool-and-jump-step (p-current-instruction p)
                                                    p))
                   (r-test-bool-and-jump-step (p-current-instruction p)
                                              (p->r p)))))

(prove-lemma test-bitv-and-jump-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bitv-and-jump)
               (proper-p-statep p)
               (p-test-bitv-and-jump-okp (p-current-instruction p)
                                         p))
          (r-equal (p->r (p-test-bitv-and-jump-step (p-current-instruction p)
                                                    p))
                   (r-test-bitv-and-jump-step (p-current-instruction p)
                                              (p->r p)))))

(prove-lemma length-put-value-indirect (rewrite)
  (equal (length (put-value-indirect val n alist))
         (length alist)))

(prove-lemma put-is-put-value-indirect nil
  (implies (lessp i (length alist))
           (equal (put val
                       i
                       (append (strip-cdrs alist) stk))
                  (append (strip-cdrs (put-value-indirect val i alist)) stk)))
  ((enable put)))


(prove-lemma put-plus-append-commuted (rewrite)
  (implies (equal i (length a))
           (equal (put val (plus j i) (append a b))
                  (append a (put val j b))))
  ((enable put)
   (induct (get i a))))

(prove-lemma put-cdr-p->r_ctrl-stk-2 (rewrite)
 (implies (and (proper-p-statep1 p)
               (not (lessp (p-max-ctrl-stk-size p)
                           (p-ctrl-stk-size (p-ctrl-stk p))))
               (lessp i (length (bindings (car (p-ctrl-stk p))))))
          (equal (put val
                      (plus (difference (p-max-ctrl-stk-size p)
                                        (p-ctrl-stk-size (p-ctrl-stk p)))
                            i)
                      (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                          (p-max-ctrl-stk-size p))))
                 (cdr (p->r_ctrl-stk
                       (cons
                        (p-frame
                         (put-value-indirect val
                                             i
                                             (bindings (car (p-ctrl-stk p))))
                         (ret-pc (car (p-ctrl-stk p))))
                        (cdr (p-ctrl-stk p)))
                       (p-max-ctrl-stk-size p)))))
  ((enable p->r_ctrl-stk p-frame bindings ret-pc)
   (disable p->r_cfp)
   (use (put-is-put-value-indirect
         (alist (bindings (car (p-ctrl-stk p))))
         (stk (cons
               (p->r_cfp (cdr (p-ctrl-stk p))
                         (p-max-ctrl-stk-size p))
               (cons (ret-pc (car (p-ctrl-stk p)))
                     (append (p->r_ctrl-stk1 (cdr (p-ctrl-stk p))
                                             (p-max-ctrl-stk-size p))
                             '((nat 0))))))))))

(disable put-plus-append-commuted)


(prove-lemma p-ctrl-stk-size-put-value-indirect (rewrite)
  (implies (listp ctrl-stk)
           (equal (p-ctrl-stk-size
                   (cons
                    (p-frame (put-value-indirect val
                                                 i
                                                 (bindings (car ctrl-stk)))
                             (ret-pc (car ctrl-stk)))
                    (cdr ctrl-stk)))
                  (p-ctrl-stk-size ctrl-stk))))


; The semantics of the pop-locn instruction, at the p level,
; introduces the term (cdr (p-ctrl-stk p)), which permits
; (p-ctrl-stk-size (p-ctrl-stk p)) to expand.  When that happens
; the lemma above (at least) is no longer applicable.  Perhaps
; the problem could be avoided by proving a bridged version of that
; single result.  But rather than do that, I will simply disable
; p-ctrl-stk-size in the owc proof.

(prove-lemma pop-locn-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-locn)
               (proper-p-statep p)
               (p-pop-locn-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-pop-locn-step (p-current-instruction p)
                                          p))
                   (r-pop-locn-step (p-current-instruction p)
                                    (p->r p))))
 ((disable p-ctrl-stk-size)))

(prove-lemma difference-plus-x-y-y (rewrite)
  (equal (difference (plus x y) y) (fix x)))

(prove-lemma get-strip-cdrs (rewrite)
  (equal (get i (strip-cdrs alist))
         (cdr (get i alist)))
  ((enable get)))

(prove-lemma get-non-numberp (rewrite)
  (implies (not (numberp i)) (equal (get i x) (car x)))
  ((enable get)))

(prove-lemma get-cdr-p->r_ctrl-stk-2 (rewrite)
  (implies (and (proper-p-statep1 p)
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p))))          
                (lessp i (length (bindings (car (p-ctrl-stk p))))))
           (equal (get
                   (plus (difference (p-max-ctrl-stk-size p)
                                     (p-ctrl-stk-size (p-ctrl-stk p)))
                         i)
                   (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                       (p-max-ctrl-stk-size p))))
                  (cdr (get i (bindings (car (p-ctrl-stk p)))))))
  ((enable p->r_ctrl-stk)))

(disable get-non-numberp)

; I now need a more general version of get-find-position-of-var.
; This could be moved up to make the proof of the other version
; faster.

(prove-lemma get-find-position-of-var-generalized nil
  (implies (member var (strip-cars alist))
           (equal (get (find-position-of-var var
                                             (strip-cars alist))
                       alist)
                  (assoc var alist)))
  ((enable get)))
  
(prove-lemma get-find-position-of-var-bindings (rewrite)
  (implies (and (proper-p-statep1 p)
                (member var
                        (append
                         (formal-vars (assoc (car (untag (p-pc p)))
                                             (p-prog-segment p)))
                         (strip-cars
                          (temp-var-dcls (assoc (car (untag (p-pc p)))
                                                (p-prog-segment p)))))))
           (equal
            (get
             (find-position-of-var
              var
              (append (formal-vars (assoc (car (untag (p-pc p)))
                                          (p-prog-segment p)))
                      (strip-cars (temp-var-dcls (assoc (car (untag (p-pc p)))
                                                        (p-prog-segment p))))))
             (bindings (car (p-ctrl-stk p))))
            (assoc var (bindings (car (p-ctrl-stk p))))))
  ((use (get-find-position-of-var-generalized
         (alist (bindings (car (p-ctrl-stk p))))))))

(prove-lemma locn-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'locn)
               (proper-p-statep p)
               (p-locn-okp (p-current-instruction p)
                           p))
          (r-equal (p->r (p-locn-step (p-current-instruction p)
                                      p))
                   (r-locn-step (p-current-instruction p)
                                (p->r p)))))

(prove-lemma jump-case-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-case)
               (proper-p-statep p)
               (p-jump-case-okp (p-current-instruction p)
                                p))
          (r-equal (p->r (p-jump-case-step (p-current-instruction p)
                                           p))
                   (r-jump-case-step (p-current-instruction p)
                                     (p->r p)))))

; We are headed into the CALL case.  I am going to keep
; p-ctrl-stk-size disabled and open it explicitly on the newly
; pushed stack.

(prove-lemma p-ctrl-stk-size-cons-p-frame (rewrite)
  (equal (p-ctrl-stk-size (cons p-frame stk))
         (plus (p-frame-size p-frame) (p-ctrl-stk-size stk))))

; Proceeding with the proof of the owc, I first address the equality
; of the two ctrl stack sizes.  It suffices to know.

(prove-lemma length-pairlist (rewrite)
  (equal (length (pairlist a b)) (length a)))

(prove-lemma length-pair-temps-with-initial-values (rewrite)
  (equal (length
          (pair-temps-with-initial-values alist))
         (length alist)))

; The following speeds things up slightly.

(enable plus-0)

; Next we establish that the lengths of the final tstks are the same
; at both levels.  This follows from what we already have about popn
; being cdr-n and the length of cdr-n.

; Now we proceed to the stk-equal question on the cstk.  This is the
; crux of the call proof.  By allowing p->r_ctrl-stk to open we
; turn it into an append of nat-0s, etc., and enable our previously
; implemented lemmas converting puts to pushes to work.

; That explains the first two puts that the r machine does on call,
; one to push the ret-pc, the other to push the old cfp.

; Then r does a fetch-n to get the formals and a deposit-lst to push
; the formals and locals.  We deal with that now.

; We establish that the values the r machine fetches from its
; temp stk are the same as the values the p machine fetches.

(defn fetch-n-p->r_sys-data-segment-generalized-hint (n i)
  (if (zerop n)
      t
      (fetch-n-p->r_sys-data-segment-generalized-hint (sub1 n) (add1 i))))

(prove-lemma cdr-n-append-1 (rewrite)
  (implies (not (lessp (length a) n))
           (equal (cdr-n n (append a b))
                  (append (cdr-n n a) b))))

(prove-lemma car-append{general} (rewrite)
  (equal (car (append a b))
         (if (listp a)
             (car a)
             (car b))))

(enable listp-cdr-n)

(prove-lemma fetch-n-p->r_sys-data-segment-generalized nil
  (implies (and (proper-p-statep1 p)
                (numberp i)
                (not (lessp (length (cdr-n i (p-temp-stk p)))
                            n)))
           (equal
            (fetch-n n
                     (tag 'sys-addr
                          (cons 'tstk
                                (plus i
                                      (difference (p-max-temp-stk-size p)
                                                  (length (p-temp-stk p))))))
                     (p->r_sys-data-segment (p-ctrl-stk p)
                                            (p-max-ctrl-stk-size p)
                                            (p-temp-stk p)
                                            (p-max-temp-stk-size p)))

            (first-n n (cdr-n i (p-temp-stk p)))))
  ((enable p->r_temp-stk get-equal-car-cdr-n)
   (induct (fetch-n-p->r_sys-data-segment-generalized-hint n i))))

(prove-lemma fetch-n-p->r_sys-data-segment-call (rewrite)
  (implies (and (proper-p-statep1 p)
                (not (lessp (length (p-temp-stk p)) n)))
           (equal
            (fetch-n n
                     (tag 'sys-addr
                          (cons 'tstk
                                (difference (p-max-temp-stk-size p)
                                            (length (p-temp-stk p)))))
                     (p->r_sys-data-segment (p-ctrl-stk p)
                                            (p-max-ctrl-stk-size p)
                                            (p-temp-stk p)
                                            (p-max-temp-stk-size p)))

            (first-n n (p-temp-stk p))))
  ((use (fetch-n-p->r_sys-data-segment-generalized (i 0)))))
         

; So next the r machine does a deposit-lst on cstk.  Since deposit-lst
; operates on a segment, not just a single area, we have to give it
; a segment below.  The segment we give it is one obtained by doing
; a put-assoc to any other segment.  The value put by that put-assoc 
; represents the cstk on which the deposits occur.  That cstk, in our
; application, happens to be the one on which the ret-pc and cfp were
; pushed.

(defn deposit-lst-put-assoc-append-hint (n lst stk)
  (if (nlistp lst)
      t
      (deposit-lst-put-assoc-append-hint (sub1 n)
                                          (cdr lst)
                                          (cons (car lst) stk))))

(prove-lemma deposit-lst-put-assoc-append (rewrite)
  (implies (and (definedp 'cstk segment)
                (not (lessp n (length lst)))
                (numberp n))
           (equal
            (deposit-lst lst
                         (tag 'sys-addr (cons 'cstk (sub1 n)))
                         (put-assoc (append (nat-0s n) stk) 'cstk segment))
            (put-assoc (append (nat-0s (difference n (length lst)))
                               (append (rev lst)
                                       stk))
                       'cstk
                       segment)))
  ((induct (deposit-lst-put-assoc-append-hint n lst stk))
   (expand (deposit-lst lst
                        (tag 'sys-addr
                             (cons 'cstk (sub1 n)))
                        (put-assoc (append (nat-0s n) stk)
                                   'cstk
                                   segment)))
   (enable difference-sub1)
   (disable nat-0s)))

; Note:  Each iteration we do a put.  We want our put-append-1 lemma to
; resolve it.  We don't want nat-0s expanding on us!

; To relieve the hypotheses we have to know the classic theorems:

(enable length-first-n)

(enable length-strip-cadrs)

; Having applied the lemma it remains to simplify the resulting rhs.  This
; requires more golden oldies:

(prove-lemma rev-rev (rewrite)
  (implies (properp x)
           (equal (rev (rev x)) x)))

(enable properp-strip-cadrs)

(prove-lemma append-nil{special} (rewrite)
  (equal (append nil x) x))

; The rule above isn't crucial of course but it speeds things
; up a bit.

; Having simplified the rhs maximally, we observe that it is
; equivalent to using p->r_sys-data-segment on a newly pushed
; p-frame.

; Before we can prove that we have to know the following classic theorems:

(prove-lemma strip-cdrs-append (rewrite)
  (equal (strip-cdrs (append a b))
         (append (strip-cdrs a) (strip-cdrs b))))

(prove-lemma strip-cdrs-pairlist (rewrite)
  (implies (and (equal (length a) (length b))
                (properp b))
           (equal (strip-cdrs (pairlist a b)) b)))

(prove-lemma strip-cdrs-pair-temps-with-initial-values (rewrite)
  (equal (strip-cdrs (pair-temps-with-initial-values alist))
         (strip-cadrs alist)))

(prove-lemma difference-difference (rewrite)
  (equal (difference (difference x y) z)
         (difference x (plus y z))))

(enable properp-rev)

(enable rev-append)

(enable length-rev)

; Here then is the theorem that folds the PUT-ASSOC of the r-level
; cstk into a p->r_sys-data-segment.

; Note:  At one time I arranged this lemma to fold up into a
; p->r_ctrl-stk, with the intention of relying on 
; put-assoc-cstk-p->r_sys-dat-segment-local to fold that
; up into the p->r_sys-data-segment.  That strategy did not
; work in the proof of the call owc because there I have
; p->r_ctrl-stk enabled and as soon as it was folded up
; it unfolded again.

(prove-lemma put-assoc-cstk-p->r_sys-data-segment-call (rewrite)
  (implies
   (not (lessp (sub1 (sub1 (p-max-ctrl-stk-size p)))
               (plus (p-ctrl-stk-size (p-ctrl-stk p))
                     (length (formal-vars (assoc name
                                                 (p-prog-segment p))))
                     (length (temp-var-dcls (assoc name
                                                   (p-prog-segment p)))))))
   (equal
    (put-assoc
     (append
      (nat-0s
       (difference
        (sub1 (sub1 (difference (p-max-ctrl-stk-size p)
                                (p-ctrl-stk-size (p-ctrl-stk p)))))
        (plus
         (length (formal-vars (assoc name
                                     (p-prog-segment p))))
         (length (temp-var-dcls (assoc name
                                       (p-prog-segment p)))))))
      (append
       (rev
        (first-n
         (length (formal-vars (assoc name
                                     (p-prog-segment p))))
         (p-temp-stk p)))
       (append
        (strip-cadrs
         (temp-var-dcls (assoc name
                               (p-prog-segment p))))
        (cons
         (tag 'sys-addr
              (cons 'cstk
                    (sub1
                     (sub1 (difference (p-max-ctrl-stk-size p)
                                       (p-ctrl-stk-size
                                        (cdr (p-ctrl-stk p))))))))
         (cons (tag 'pc
                    (cons (car (untag (p-pc p)))
                          (add1 (cdr (untag (p-pc p))))))
               (append (p->r_ctrl-stk1 (p-ctrl-stk p)
                                       (p-max-ctrl-stk-size p))
                       '((nat 0))))))))
     'cstk
     (p->r_sys-data-segment ctrl-stk
                            (p-max-ctrl-stk-size p)
                            temp-stk
                            max-temp-stk-size))
    (p->r_sys-data-segment
      (cons
       (p-frame
        (append
         (pairlist
          (formal-vars (assoc name
                              (p-prog-segment p)))
          (rev
           (first-n
            (length (formal-vars (assoc name
                                        (p-prog-segment p))))
            (p-temp-stk p))))
         (pair-temps-with-initial-values
          (temp-var-dcls (assoc name
                                (p-prog-segment p)))))
        (tag 'pc
             (cons (car (untag (p-pc p)))
                   (add1 (cdr (untag (p-pc p)))))))
       (p-ctrl-stk p))
      (p-max-ctrl-stk-size p)
      temp-stk
      max-temp-stk-size)))
  ((enable p->r_sys-data-segment
           p->r_ctrl-stk
           p-frame
           bindings
           ret-pc
           difference-sub1)))

(disable difference-difference)

; The lemma above takes care of the stk-equal question for cstk, given
; reflexivity.

(prove-lemma call-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'call)
               (proper-p-statep p)
               (p-call-okp (p-current-instruction p)
                           p))
          (r-equal (p->r (p-call-step (p-current-instruction p)
                                      p))
                   (r-call-step (p-current-instruction p)
                                (p->r p))))
 ((enable p->r_ctrl-stk)
  (disable p-ctrl-stk-size
           p->r_ctrl-stk1
           p->r_ctrl-stk1-opener)))

; pop-call does an additional pop, which causes us a little trouble.

; The following three lemmas are necessary to let us relieve the hypotheses
; of the DEPOSIT-LST-PUT-ASSOC-APPEND lemma.

(prove-lemma not-equal-sub1-difference-p-max-ctrl-stk-size-etc (rewrite)
   (implies
    (and (proper-p-statep1 p)
         (not (lessp (sub1 (sub1 (p-max-ctrl-stk-size p)))
                     (plus (p-ctrl-stk-size (p-ctrl-stk p))
                           (length
                            (formal-vars
                             (assoc (untag (car (p-temp-stk p)))
                                    (p-prog-segment p))))
                           (length
                            (temp-var-dcls
                             (assoc (untag (car (p-temp-stk p)))
                                    (p-prog-segment p))))))))
    (not (equal (sub1 (difference (p-max-ctrl-stk-size p)
                                  (p-ctrl-stk-size (p-ctrl-stk p))))
                0)))
   ((expand (p-ctrl-stk-size (p-ctrl-stk p)))))

(enable length-fetch-n)

(prove-lemma not-lessp-sub1-sub1-difference-p-max-ctrl-stk-size-etc (rewrite)
  (implies 
   (and (proper-p-statep1 p)
        (not (lessp (sub1 (sub1 (p-max-ctrl-stk-size p)))
                    (plus (p-ctrl-stk-size (p-ctrl-stk p))
                          (length
                           (formal-vars
                            (assoc (untag (car (p-temp-stk p)))
                                   (p-prog-segment p))))
                          (length
                           (temp-var-dcls
                            (assoc (untag (car (p-temp-stk p)))
                                   (p-prog-segment p))))))))
   (equal
    (lessp (sub1 (sub1 (difference (p-max-ctrl-stk-size p)
                                   (p-ctrl-stk-size (p-ctrl-stk p)))))
           (plus (length (formal-vars (assoc (untag (car (p-temp-stk p)))
                                             (p-prog-segment p))))
                 (length (temp-var-dcls (assoc (untag (car (p-temp-stk p)))
                                               (p-prog-segment p))))))
    f))
   ((expand (p-ctrl-stk-size (p-ctrl-stk p)))))

(prove-lemma fetch-n-p->r_sys-data-segment-pop-call (rewrite)
  (implies (and (proper-p-statep1 p)
                (not (lessp (p-max-temp-stk-size p)
                            (length (p-temp-stk p))))
                (not (lessp (length (cdr (p-temp-stk p))) n)))
           (equal
            (fetch-n n
                     (tag 'sys-addr
                          (cons 'tstk
                                (difference (p-max-temp-stk-size p)
                                            (length (cdr (p-temp-stk p))))))
                     (p->r_sys-data-segment (p-ctrl-stk p)
                                            (p-max-ctrl-stk-size p)
                                            (p-temp-stk p)
                                            (p-max-temp-stk-size p)))

            (first-n n (cdr (p-temp-stk p)))))
  ((use (fetch-n-p->r_sys-data-segment-generalized (i 1)))))

(prove-lemma put-assoc-cstk-p->r_sys-data-segment-pop-call (rewrite)
  (implies
   (not (lessp (sub1 (sub1 (p-max-ctrl-stk-size p)))
               (plus (p-ctrl-stk-size (p-ctrl-stk p))
                     (length (formal-vars (assoc name
                                                 (p-prog-segment p))))
                     (length (temp-var-dcls (assoc name
                                                   (p-prog-segment p)))))))
   (equal
    (put-assoc
     (append
      (nat-0s
       (sub1
        (sub1
         (difference
          (difference (p-max-ctrl-stk-size p)
                      (p-ctrl-stk-size (p-ctrl-stk p)))
          (plus
           (length (formal-vars (assoc name
                                       (p-prog-segment p))))
           (length (temp-var-dcls (assoc name
                                         (p-prog-segment p)))))))))
      (append
       (rev
        (first-n
         (length (formal-vars (assoc name
                                     (p-prog-segment p))))
         (cdr (p-temp-stk p))))
       (append
        (strip-cadrs
         (temp-var-dcls (assoc name
                               (p-prog-segment p))))
        (cons
         (tag 'sys-addr
              (cons 'cstk
                    (sub1
                     (sub1 (difference (p-max-ctrl-stk-size p)
                                       (p-ctrl-stk-size
                                        (cdr (p-ctrl-stk p))))))))
         (cons (tag 'pc
                    (cons (car (untag (p-pc p)))
                          (add1 (cdr (untag (p-pc p))))))
               (append (p->r_ctrl-stk1 (p-ctrl-stk p)
                                       (p-max-ctrl-stk-size p))
                       '((nat 0))))))))
     'cstk
     (p->r_sys-data-segment ctrl-stk
                            (p-max-ctrl-stk-size p)
                            temp-stk
                            max-temp-stk-size))
    (p->r_sys-data-segment
      (cons
       (p-frame
        (append
         (pairlist
          (formal-vars (assoc name
                              (p-prog-segment p)))
          (rev
           (first-n
            (length (formal-vars (assoc name
                                        (p-prog-segment p))))
            (cdr (p-temp-stk p)))))
         (pair-temps-with-initial-values
          (temp-var-dcls (assoc name
                                (p-prog-segment p)))))
        (tag 'pc
             (cons (car (untag (p-pc p)))
                   (add1 (cdr (untag (p-pc p)))))))
       (p-ctrl-stk p))
      (p-max-ctrl-stk-size p)
      temp-stk
      max-temp-stk-size)))
  ((enable p->r_sys-data-segment
           p->r_ctrl-stk
           p-frame
           bindings
           ret-pc
           difference-sub1
           difference-difference)))

(prove-lemma cdr-n-plus-append-pop-call (rewrite)
  (implies (lessp len max)
           (equal (cdr-n (plus (difference max len)
                               n)
                         (append (nat-0s (sub1 (difference max len)))
                                 stk))
                  (cdr (cdr-n n stk))))
  ((enable difference)
   (induct (difference max len))))

; pop-call has all the disable/enable hints of call; in addition,
; it disables nat-0s.  The problem is that because of the extra
; pop there is permission to expand nat-0s one more and lemmas
; fail to fire, it also enables difference-sub1 to let the extra
; pop come out where I expect it.

(prove-lemma pop-call-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-call)
               (proper-p-statep p)
               (p-pop-call-okp (p-current-instruction p)
                               p))
          (r-equal (p->r (p-pop-call-step (p-current-instruction p)
                                          p))
                   (r-pop-call-step (p-current-instruction p)
                                    (p->r p))))
  ((enable p->r_ctrl-stk difference-sub1)
   (disable nat-0s
            p-ctrl-stk-size
            p->r_ctrl-stk1
            p->r_ctrl-stk1-opener)))

; I am now headed for ret.  Because the ret command sometimes halts,
; and we're trying to prove r-equals of such states, we need to know
; what r-halt does.  I suppose I could have allowed it to expand.


(prove-lemma components-of-r-halt (rewrite)
  (and (equal (r-pc (r-halt r psw)) (r-pc r))
       (equal (r-cfp (r-halt r psw)) (r-cfp r))
       (equal (r-csp (r-halt r psw)) (r-csp r))
       (equal (r-tsp (r-halt r psw)) (r-tsp r))
       (equal (r-x (r-halt r psw)) (r-x r))
       (equal (r-y (r-halt r psw)) (r-y r))
       (equal (r-c-flg (r-halt r psw)) (r-c-flg r))
       (equal (r-v-flg (r-halt r psw)) (r-v-flg r))
       (equal (r-n-flg (r-halt r psw)) (r-n-flg r))
       (equal (r-z-flg (r-halt r psw)) (r-z-flg r))
       (equal (r-prog-segment (r-halt r psw)) (r-prog-segment r))
       (equal (r-usr-data-segment (r-halt r psw)) (r-usr-data-segment r))
       (equal (r-sys-data-segment (r-halt r psw)) (r-sys-data-segment r))
       (equal (r-word-size (r-halt r psw)) (r-word-size r)))
  ((enable r-halt)))

; The p level machine cdrs the ctrl stack.  The r level, of course,
; doesn't, but it does set the csp and cfp by computation on the
; about-to-be popped top frame.  We need to know that the values
; it retrieves for ret-pc and the new cfp are the same as those the
; p machine uses.

; The values of cfp and ret-pc are fetched from an address based
; on the current cfp, which involves the size of the stack from
; before the top frame was pushed.  But the lemmas we have for
; explaining how to get from a stack are based on offsets from the
; the top of the stack, not negative offsets from somewhere in the
; middle.  The following lemma takes care of this by converting the
; previously computed cfp from a "somewhere in the middle" address
; to an offset from the current top.

; Warning:  The following lemma folds up p-ctrl-stk-size.  It must be not
; enabled unless that function is disabled.

(prove-lemma difference-p-ctrl-stk-size-folder (rewrite)
  (implies (and (listp (p-ctrl-stk p))
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p)))))
           (equal (difference (p-max-ctrl-stk-size p)
                              (p-ctrl-stk-size (cdr (p-ctrl-stk p))))
                  (add1
                   (plus (difference (p-max-ctrl-stk-size p)
                                     (p-ctrl-stk-size (p-ctrl-stk p)))
                         (length (bindings (top (p-ctrl-stk p))))
                         1)))))

; Note: The rather cruious ordering of the addends above makes it perfect
; fodder for get-append, provided the system doesn't rearrange the
; plus nests.  Note that the classic properties of plus are disabled
; in the next lemma.

; So here are the two lemmas that tell us the r machine fetches the same
; ret-pc and cfp that the p machine does.

(prove-lemma ret-pc-in-correct-position (rewrite)
  (implies (and (listp (p-ctrl-stk p))
                (not (lessp (p-max-ctrl-stk-size p)
                       (p-ctrl-stk-size (p-ctrl-stk p)))))
           (equal
                (get (sub1 (difference (p-max-ctrl-stk-size p)
                                       (p-ctrl-stk-size (cdr (p-ctrl-stk p)))))
                     (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                         (p-max-ctrl-stk-size p))))
                (ret-pc (car (p-ctrl-stk p)))))
  ((disable commutativity-of-plus
            commutativity2-of-plus
            plus-add1
            difference-add1{special}
            p->r_cfp)
   (enable p->r_ctrl-stk)))

(prove-lemma cfp-in-correct-position (rewrite)
  (implies (and (listp (p-ctrl-stk p))
                (not (lessp (p-max-ctrl-stk-size p)
                       (p-ctrl-stk-size (p-ctrl-stk p)))))
           (equal
                (get (sub1
                      (sub1
                       (difference (p-max-ctrl-stk-size p)
                                   (p-ctrl-stk-size (cdr (p-ctrl-stk p))))))
                     (cdr (p->r_ctrl-stk (p-ctrl-stk p)
                                         (p-max-ctrl-stk-size p))))
                (p->r_cfp (cdr (p-ctrl-stk p))
                          (p-max-ctrl-stk-size p))))
  ((disable commutativity-of-plus
            commutativity2-of-plus
            plus-add1
            difference-add1{special}
            p->r_cfp)
   (enable p->r_ctrl-stk)))

; And now we shut down the lemma that folds p-ctrl-stk-size.

(disable difference-p-ctrl-stk-size-folder)

; The next pair of lemmas help deal with the arithmetic surrounding
; the hypothesis that the ctrl-stk has more than one frame on it.

(prove-lemma lessp-p-ctrl-stk-size (rewrite)
  (implies (listp stk)
           (lessp 0 (p-ctrl-stk-size stk))))

(prove-lemma zerop-difference-p-ctrl-stk-size (rewrite)
  (implies (and (listp (p-ctrl-stk p))
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p)))))
           (equal (equal
                   (sub1
                    (sub1
                     (difference
                      (add1 (p-max-ctrl-stk-size p))
                      (sub1 (difference
                             (p-max-ctrl-stk-size p)
                             (p-ctrl-stk-size (cdr (p-ctrl-stk p))))))))
                   0)
                  (nlistp (cdr (p-ctrl-stk p)))))
  ((expand (p-ctrl-stk-size (cdr (p-ctrl-stk p))))))

; We now consider the crux of the matter, which is proving the
; stk-equality of the ctrl stks after the ret.  Recall that until
; now we have handled stk-equal questions in two different ways:
; For cstk we arranged for the r-level operation to fold itself into
; a mapped down image of the corresponding p level operation and then
; appealed simply to the reflexivity of stk-equal.  For tstk, on the
; other hand, we adopted the much more general strategy of showing
; the equality of the live part of the two stacks.  The stk-equal
; question on tstk was converted to an equality question on cdr-n
; and all-but-last by the lemma stk-equal-tstk-p->r_sys-data-segment.

; To handle ret we will adopt the tstk strategy for cstk.
; We prove a cstk version of stk-equal-tstk-p->r_sys-data-segment.

; If you look below you will see it.  It is necessary to know
; what cdr-n and all-but-last do on p->r_ctrl-stk.

(enable properp-append)

(prove-lemma properp-p->r_ctrl-stk1 (rewrite)
  (properp (p->r_ctrl-stk1 ctrl-stk max-ctrl-stk-size)))

(prove-lemma all-but-last-cdr-p->r_ctrl-stk (rewrite)
  (equal (all-but-last
          (cdr (p->r_ctrl-stk ctrl-stk max-ctrl-stk-size)))
         (append (nat-0s (difference max-ctrl-stk-size
                                     (p-ctrl-stk-size ctrl-stk)))
                 (p->r_ctrl-stk1 ctrl-stk max-ctrl-stk-size)))
  ((enable p->r_ctrl-stk)))

; Here then is the lemma.  The hints were formed by analogy with
; the hints for the tstk version.

(prove-lemma stk-equal-cstk-p->r_sys-data-segment (rewrite)
  (implies (and (properp ctrl-stk)
                (equal n (difference max-ctrl-stk-size
                                     (p-ctrl-stk-size ctrl-stk)))
                (not (lessp max-ctrl-stk-size (p-ctrl-stk-size ctrl-stk)))
                (equal (add1 max-ctrl-stk-size)
                       (length (cdr (assoc 'cstk segment)))))
           (equal (stk-equal (tag 'sys-addr
                                  (cons 'cstk n))
                             (p->r_sys-data-segment ctrl-stk
                                                    max-ctrl-stk-size
                                                    temp-stk
                                                    max-temp-stk-size)
                             segment)
                  (equal (p->r_ctrl-stk1 ctrl-stk max-ctrl-stk-size)
                         (cdr-n (difference max-ctrl-stk-size
                                            (p-ctrl-stk-size ctrl-stk))
                                (all-but-last
                                 (cdr (assoc 'cstk segment)))))))
((enable p->r_temp-stk)
   (use (stk-equal-is-equal-cdr-n-all-but-last
         (sp (tag 'sys-addr
                  (cons 'cstk
                        (difference max-ctrl-stk-size
                                    (p-ctrl-stk-size ctrl-stk)))))
         (segment1 (p->r_sys-data-segment ctrl-stk
                                          max-ctrl-stk-size
                                          temp-stk
                                          max-temp-stk-size))
         (segment2 segment)))))

; To apply the lemma we to be able to relieve the hypothesis that
; the new ctrl-stk produced by the p machine is proper.

(prove-lemma proper-p-ctrl-stkp-implies-properp nil
  (implies (proper-p-ctrl-stkp ctrl-stk name p)
           (properp ctrl-stk)))

(prove-lemma properp-p-ctrl-stkp (rewrite)
  (implies (proper-p-statep1 p)
           (properp (cdr (p-ctrl-stk p))))
  ((disable proper-p-ctrl-stkp)
   (use (proper-p-ctrl-stkp-implies-properp
         (ctrl-stk (cdr (p-ctrl-stk p)))
         (name (car (untag (ret-pc (car (p-ctrl-stk p))))))))))

; Once we've done that we rewrite the stk-equal to the cdr-n of
; the all-but-last of the mapped down stack.  The all-but-last
; theorem above takes care of that function.  The following cdr-n
; lemma shows that the cdr-n is exactly enough to pop off the
; top frame.

(prove-lemma difference-plus-plus-plus-cancellation (rewrite)
  (equal (difference (plus x (plus y (plus z n))) n)
         (plus y (plus z x))))

; The odd reordering of the addends above makes the result perfect
; fodder for cdr-n-plus-append.

(prove-lemma cdr-n-append-ret (rewrite)
  (implies (and (equal max (plus 2
                                 (length part1)
                                 (length part2)
                                 (length tail)))
                (equal len (length tail)))
           (equal (cdr-n (difference max len)
                         (append part1
                                 (append part2
                                         (cons e1
                                               (cons e2
                                                     tail)))))
                  tail))
  ((disable commutativity-of-plus
            commutativity2-of-plus
            plus-add1)))

; And that is that.

(prove-lemma ret-one-way-correspondence-p-r (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'ret)
               (proper-p-statep p)
               (p-ret-okp (p-current-instruction p)
                          p))
          (r-equal (p->r (p-ret-step (p-current-instruction p)
                                     p))
                   (r-ret-step (p-current-instruction p)
                               (p->r p))))
 ((expand (p-ctrl-stk-size (p-ctrl-stk p)))
  (disable p-ctrl-stk-size)
  (enable empty-stkp)))

; We now attack the invariance of proper-p-statep.  The proof is
; as you would expect, by consideration of each of the cases.

; We first prove a beautiful theorem.  Suppose p is a proper p state
; and p' is derived from p, having certain components in common with it
; (e.g., the program segment).  Then the question "is p' proper?"
; can be reduced the some questions about its components and p.
; That may sound like just opening up proper-p-statep, but it's not.
; Opening up would reduce the question to some questions about its
; components and p'.  The nice thing about reducing it to p is that
; we will generally have many hypotheses about things being
; proper p objects.

; The amount of work we have to do to prove this lemma is an indication
; of how much it saves us, over merely opening up proper-p-statep.


; Whenever I have a same-signature as a hyp of a rule with concl
; lhs = rhs the same-signature will determine the direction of
; the rule.  In particular, (same-signature segment1 segment2)
; in a hyp means I will rewrite segment1 terms to segment2 terms.

(enable same-signature-segment-length)

(prove-lemma same-signature-implies-equal-p-loadablep (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (p-loadablep (p-state new-pc
                                        new-ctrl-stk
                                        new-temp-stk
                                        (p-prog-segment p)
                                        new-data-segment
                                        (p-max-ctrl-stk-size p)
                                        (p-max-temp-stk-size p)
                                        (p-word-size p)
                                        new-psw)
                               load-addr)
                  (p-loadablep p load-addr)))
  ((enable p-loadablep)))

(prove-lemma same-signature-implies-equal-lengths (rewrite)
  (implies (same-signature segment1 segment2)
           (equal (length (cdr (assoc name segment1)))
                  (length (cdr (assoc name segment2)))))
  ((enable same-signature)))

(prove-lemma same-signature-implies-equal-definedp (rewrite)
  (implies (same-signature segment1 segment2)
           (equal (definedp name segment1)
                  (definedp name segment2)))
  ((enable same-signature)))

(prove-lemma same-signature-implies-equal-p-objectp (rewrite)
  (implies 
   (same-signature new-data-segment
                   (p-data-segment p))
   (equal
    (p-objectp x
               (p-state new-pc
                        new-ctrl-stk
                        new-temp-stk
                        (p-prog-segment p)
                        new-data-segment
                        (p-max-ctrl-stk-size p)
                        (p-max-temp-stk-size p)
                        (p-word-size p)
                        new-psw))
    (p-objectp x p)))
 ((enable p-objectp)))

(prove-lemma same-signature-implies-equal-all-p-objectps (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (all-p-objectps lst (p-state new-pc
                                               new-ctrl-stk
                                               new-temp-stk
                                               (p-prog-segment p)
                                               new-data-segment
                                               (p-max-ctrl-stk-size p)
                                               (p-max-temp-stk-size p)
                                               (p-word-size p)
                                               new-psw))
                  (all-p-objectps lst p))))

(prove-lemma same-signature-implies-equal-proper-p-alistp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-alistp alist
                                   (p-state new-pc
                                            new-ctrl-stk
                                            new-temp-stk
                                            (p-prog-segment p)
                                            new-data-segment
                                            (p-max-ctrl-stk-size p)
                                            (p-max-temp-stk-size p)
                                            (p-word-size p)
                                            new-psw))
                  (proper-p-alistp alist p))))

(prove-lemma same-signature-implies-equal-proper-p-framep (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-framep frame
                                   name
                                   (p-state new-pc
                                            new-ctrl-stk
                                            new-temp-stk
                                            (p-prog-segment p)
                                            new-data-segment
                                            (p-max-ctrl-stk-size p)
                                            (p-max-temp-stk-size p)
                                            (p-word-size p)
                                            new-psw))
                  (proper-p-framep frame name p))))

(disable proper-p-framep)

(prove-lemma same-signature-implies-equal-proper-p-ctrl-stkp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-ctrl-stkp stk
                                      name
                                      (p-state new-pc
                                               new-ctrl-stk
                                               new-temp-stk
                                               (p-prog-segment p)
                                               new-data-segment
                                               (p-max-ctrl-stk-size p)
                                               (p-max-temp-stk-size p)
                                               (p-word-size p)
                                               new-psw))
                  (proper-p-ctrl-stkp stk name p))))

(prove-lemma same-signature-implies-equal-proper-p-temp-stkp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-temp-stkp stk
                                      (p-state new-pc
                                               new-ctrl-stk
                                               new-temp-stk
                                               (p-prog-segment p)
                                               new-data-segment
                                               (p-max-ctrl-stk-size p)
                                               (p-max-temp-stk-size p)
                                               (p-word-size p)
                                               new-psw))
                  (proper-p-temp-stkp stk p))))

(prove-lemma same-signature-implies-equal-proper-p-temp-var-dclsp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-temp-var-dclsp lst
                                           (p-state new-pc
                                                    new-ctrl-stk
                                                    new-temp-stk
                                                    (p-prog-segment p)
                                                    new-data-segment
                                                    (p-max-ctrl-stk-size p)
                                                    (p-max-temp-stk-size p)
                                                    (p-word-size p)
                                                    new-psw))
                  (proper-p-temp-var-dclsp lst p))))

(prove-lemma same-signature-implies-equal-proper-p-instructionp
             (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-instructionp
                                ins
                                name
                                (p-state new-pc
                                         new-ctrl-stk
                                         new-temp-stk
                                         (p-prog-segment p)
                                         new-data-segment
                                         (p-max-ctrl-stk-size p)
                                         (p-max-temp-stk-size p)
                                         (p-word-size p)
                                         new-psw))
                  (proper-p-instructionp ins name p)))
  ((enable proper-p-instructionp)))

(prove-lemma same-signature-implies-equal-proper-labeled-p-instructionsp
             (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-labeled-p-instructionsp
                                lst
                                name
                                (p-state new-pc
                                         new-ctrl-stk
                                         new-temp-stk
                                         (p-prog-segment p)
                                         new-data-segment
                                         (p-max-ctrl-stk-size p)
                                         (p-max-temp-stk-size p)
                                         (p-word-size p)
                                         new-psw))
                  (proper-labeled-p-instructionsp lst name p))))

(prove-lemma same-signature-implies-equal-proper-p-program-bodyp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-program-bodyp lst
                                          name
                                          (p-state new-pc
                                                   new-ctrl-stk
                                                   new-temp-stk
                                                   (p-prog-segment p)
                                                   new-data-segment
                                                   (p-max-ctrl-stk-size p)
                                                   (p-max-temp-stk-size p)
                                                   (p-word-size p)
                                                   new-psw))
                  (proper-p-program-bodyp lst name p))))

(disable proper-p-program-bodyp)

(prove-lemma same-signature-implies-equal-proper-p-programp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-programp prog
                                     (p-state new-pc
                                              new-ctrl-stk
                                              new-temp-stk
                                              (p-prog-segment p)
                                              new-data-segment
                                              (p-max-ctrl-stk-size p)
                                              (p-max-temp-stk-size p)
                                              (p-word-size p)
                                              new-psw))
                  (proper-p-programp prog p))))

(disable proper-p-programp)

(prove-lemma same-signature-implies-equal-proper-p-prog-segmentp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-prog-segmentp lst
                                          (p-state new-pc
                                                   new-ctrl-stk
                                                   new-temp-stk
                                                   (p-prog-segment p)
                                                   new-data-segment
                                                   (p-max-ctrl-stk-size p)
                                                   (p-max-temp-stk-size p)
                                                   (p-word-size p)
                                                   new-psw))
                  (proper-p-prog-segmentp lst p))))

(prove-lemma same-signature-implies-equal-proper-p-data-segmentp (rewrite)
  (implies (same-signature new-data-segment (p-data-segment p))
           (equal (proper-p-data-segmentp lst
                                          (p-state new-pc
                                                   new-ctrl-stk
                                                   new-temp-stk
                                                   (p-prog-segment p)
                                                   new-data-segment
                                                   (p-max-ctrl-stk-size p)
                                                   (p-max-temp-stk-size p)
                                                   (p-word-size p)
                                                   new-psw))
                  (proper-p-data-segmentp lst p))))
                   
; We are about to prove the theorem that is our main tool for
; the invariance proofs.  However, there is one major trick ahead.
; Here is a typical step theorem we will have to prove:

;(prove-lemma xxx-preserves-proper-p-statep (rewrite)
; (implies (and (equal (p-psw p) 'run)
;               (equal (car (p-current-instruction p))
;                      'xxx)
;               (proper-p-statep p)
;               (p-xxx-okp (p-current-instruction p) p))
;          (proper-p-statep
;           (p-xxx-step (p-current-instruction p) p))))

; Recall proper-p-state-restructuring.  It is an unconditional
; rewrite that replaces the hypothesized (proper-p-statep p)
; by a conjunction of (proper-p-statep1 p) and some linear
; conditions and a gratuitous but extremely useful
; (proper-p-instructionp (p-current-instruction p) p).
; We depend on that restructuring to let us access many of the
; lemmas already proved.

; However, that same restructuring will hit our concluding
; (proper-p-statep (p-xxx-step ...)) and force us to prove
; different things than we wish.  We are going to avoid this by
; a silly syntactic trick.  The step theorems we prove will
; be of the form:

;(prove-lemma xxx-preserves-proper-p-statep (rewrite)
; (implies (and (equal (p-psw p) 'run)
;               (proper-p-statep p)
;               (p-xxx-okp (p-current-instruction p) p))
;          (ur-proper-p-statep
;           (p-xxx-step (p-current-instruction p) p))))

; where ur-proper-p-statep is in fact proper-p-statep but
; is disabled.  

(defn ur-proper-p-statep (p) (proper-p-statep p))

; The lemma towards which we have been working, namely the
; lemma that rewrites (proper-p-statep p') to a conjunction
; of facts about p, will actually rewrite (ur-proper-p-statep p'):

(prove-lemma ur-proper-p-statep-p-state (rewrite)
  (implies
   (and (proper-p-statep p)
        (same-signature new-data-segment (p-data-segment p)))
   (equal
    (ur-proper-p-statep
     (p-state new-pc
              new-ctrl-stk
              new-temp-stk
              (p-prog-segment p)
              new-data-segment
              (p-max-ctrl-stk-size p)
              (p-max-temp-stk-size p)
              (p-word-size p)
              new-psw))
    (and 
     (p-objectp-type 'pc new-pc p)
     (listp new-ctrl-stk)
     (proper-p-framep (top new-ctrl-stk)
                      (area-name new-pc)
                      p)
     (proper-p-ctrl-stkp (pop new-ctrl-stk)
                         (area-name (ret-pc (top new-ctrl-stk)))
                         p)
     (not (lessp (p-max-ctrl-stk-size p)
                 (p-ctrl-stk-size new-ctrl-stk)))
     (proper-p-temp-stkp new-temp-stk p)
     (not (lessp (p-max-temp-stk-size p)
                 (length new-temp-stk)))
     (proper-p-data-segmentp new-data-segment
                             p))))
  ((disable proper-p-statep-restructuring)
   (expand (proper-p-statep p)
           (proper-p-statep
            (p-state new-pc
                     new-ctrl-stk
                     new-temp-stk
                     (p-prog-segment p)
                     new-data-segment
                     (p-max-ctrl-stk-size p)
                     (p-max-temp-stk-size p)
                     (p-word-size p)
                     new-psw)))))

(disable ur-proper-p-statep)

; When we are all done we will reveal that ur-proper-p-statep
; is proper-p-statep and get the invariance theorem.

; To apply the main lemma above we need to establish the
; same-signature hypothesis.  We will prove the necessary
; lemmas as needed.  For the no-op case it is:

(enable same-signature-reflexive)

; We also have to be able to establish (proper-p-statep p)
; in a context in which it has been restructured.  This is
; a new problem -- in our previous proofs we always went after
; (proper-p-statep1 p) or explicit inequalities.  Anyway, to
; get (proper-p-statep p) it is sufficient to know:

(prove-lemma listp-p-current-instruction (rewrite)
  (implies (equal (car (p-current-instruction p)) (pack xxx))
           (listp (p-current-instruction p))))

(enable proper-p-framep)

(prove-lemma no-op-preserves-proper-p-statep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                      'no-op)
                (proper-p-statep p)
                (p-no-op-okp (p-current-instruction p) p))
           (ur-proper-p-statep
            (p-no-op-step (p-current-instruction p) p))))

; To prove push-global we need to know that the object pushed is
; a p-objectp.  The object pushed is fetched from the data segment.
; So we have to prove the general fact that anything fetched from
; the data segment is a p-objectp.  This, of course, will be used
; in many of the subsequent proofs.

(prove-lemma all-p-objectps-implies-p-objectp nil
  (implies (and (all-p-objectps lst p)
                (member x lst))
           (p-objectp x p)))

(prove-lemma proper-p-data-segmentp-implies-all-p-objectps (rewrite)
  (implies (and (proper-p-data-segmentp segment p)
                (definedp name segment))
           (all-p-objectps (cdr (assoc name segment)) p)))

(prove-lemma p-objectp-get-p-data-segment (rewrite)
  (implies (and (proper-p-data-segmentp segment p)
                (definedp name segment)
                (lessp n (length (cdr (assoc name segment)))))
           (p-objectp (get n (cdr (assoc name segment))) p))
  ((use (all-p-objectps-implies-p-objectp
         (lst (cdr (assoc name segment)))
         (x (get n (cdr (assoc name segment))))))))

; To access global vars we use a naked car of the global data
; area, knowing that it is a listp -- i.e., there is not
; legal address check.  In addition, we don't get via the
; function get and so the lemma above is not quite what
; we need.  We take care of these details here.

(prove-lemma definedp-p-data-segment-implies-listp-generalized nil
  (implies (and (proper-p-data-segmentp segment p)
                (definedp name segment))
           (listp (cdr (assoc name segment)))))

(prove-lemma definedp-p-data-segment-implies-listp (rewrite)
  (implies (and (proper-p-statep1 p)
                (definedp name (p-data-segment p)))
           (listp (cdr (assoc name (p-data-segment p)))))
  ((use (definedp-p-data-segment-implies-listp-generalized
          (segment (p-data-segment p))))))

(prove-lemma p-objectp-cadr-assoc-p-data-segment (rewrite)
  (implies (and (proper-p-statep1 p)
                (definedp name (p-data-segment p)))
           (p-objectp (car (cdr (assoc name (p-data-segment p)))) p))
  ((use (p-objectp-get-p-data-segment (n 0)
                                      (segment (p-data-segment p))))
   (disable p-objectp-get-p-data-segment)))

; So that sets us up for:

(prove-lemma push-global-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-global)
               (proper-p-statep p)
               (p-push-global-okp (p-current-instruction p)
                          p))
          (ur-proper-p-statep
           (p-push-global-step (p-current-instruction p)
                               p))))

; To do pop-global we need first to relieve the hypotheses on our
; ur-proper-p-statep-p-state lemma, namely the same-signature
; hypothesis on the data segment.  The new data segment in
; question is obtained by put-assoc and put.  So we prove:

(prove-lemma same-signature-put-assoc-generalized nil
  (implies (and (proper-p-data-segmentp segment p)
                (definedp name segment)
                (equal (length val)
                       (length (cdr (assoc name segment)))))
           (same-signature (put-assoc val name segment) segment))
  ((enable same-signature)))

; The proper-p-data-segmentp hyp above is necessary only to assure us that
; the alist does not have any nlistp members, so a less sophisticated
; (and state free) predicate could have been used.  But since I had this
; one I used it.  Unfortunately, it introduces a free variable, p, so
; I eliminate it and make it a rewrite rule by choosing the only
; instantiation I ever need:

(prove-lemma same-signature-put-assoc{special} (rewrite)
  (implies (and (proper-p-statep1 p)
                (definedp name (p-data-segment p))
                (equal (length val)
                       (length (cdr (assoc name (p-data-segment p))))))
           (same-signature (put-assoc val name (p-data-segment p))
                           (p-data-segment p)))
  ((use (same-signature-put-assoc-generalized
         (segment (p-data-segment p))))))

; Since pop-global pops the temp stack, we have to prove that the new
; one is proper:

(prove-lemma proper-p-temp-stk-cdr (rewrite)
  (implies (and (listp stk)
                (proper-p-temp-stkp stk p))
           (proper-p-temp-stkp (cdr stk) p)))

; We wouldn't need the theorem above if proper-p-statep were opened in the
; hypothesis because the (proper-p-temp-stkp (p-temp-stk p) p) would open
; given our interest in (cdr (p-temp-stk p)).

; Finally, since pop-global does a put into the data segment, we need to
; to prove that proper-p-data-segmentp is preserved by the put-assoc and
; put.

(prove-lemma all-p-objectps-put (rewrite)
  (implies (and (p-objectp val p)
                (lessp n (length lst))
                (all-p-objectps lst p))
           (all-p-objectps (put val n lst) p))
  ((enable put)))

(enable definedp-put-assoc)

(prove-lemma proper-p-data-segmentp-put-assoc (rewrite)
  (implies (and (proper-p-data-segmentp segment p)
                (definedp name segment)
                (listp lst)
                (all-p-objectps lst p))
           (proper-p-data-segmentp (put-assoc lst name segment) p)))

; The lemma above does the job, but note that we need to know that
; the thing we put into the data area is a p-objectp.  What is that
; thing?  It's the top of the temp stack.  So we need to prove:

(prove-lemma p-objectp-top-p-temp-stk (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (listp temp-stk))
           (p-objectp (car temp-stk) p)))

; We also get the similar results for top1 and top2:

(prove-lemma p-objectp-top1-p-temp-stk (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (listp (cdr temp-stk)))
           (p-objectp (cadr temp-stk) p)))

(prove-lemma p-objectp-top2-p-temp-stk (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (listp (cddr temp-stk)))
           (p-objectp (caddr temp-stk) p)))

; For CALL I will need a more general lemma about the first-n
; of the temp-stk, but I'll wait till I see the need.

; The provision of the three lemmas above interacts in a detrimental
; way with something else in our proofs.  Consider p-deposit-okp,
; for example.  It requires that the top of the temp-stk by a
; p-objectp of type 'addr.  When we assume that -okp we have been
; getting the p-objectp in our assumptions and the p-objectp has then
; been opening up to reveal important things like that the car of the
; object is definedp in the data-segment or, in the case of the arithmetic
; instructions, the object is a numberp.  But with the provision of the
; three p-objectp lemmas above, whenever we hypothesis that something on
; the stack is a p-objectp of a given type the hypothesis is rewritten
; simply to the fact that it is of the right type -- because the p-objectp
; is obvious by the thing merely being on the stack.  This in fact
; suggests an improvement we could make in the defns of all the -okp
; fns:  don't check p-objectp of things on the stack, just check their
; types.  I'll save that for another day.

; Meanwhile, we have a problem:  lots of rules have definedp and numberp
; hyps that will no longer be relieved because the three lemmas above
; have simplified away the p-objectps that used to open up.  What to do?

; I am taking a really simple way out, exploiting the fact that all the
; -okp fns that check for the type of an object do so with
; p-objectp-type.  I will disable it after proving the rule below, which
; not only expands p-objectp-type but also the resulting p-objectp.
; This trick just slips the p-objectp past the three lemmas above.

(prove-lemma p-objectp-type-opener (rewrite)
  (and (equal (p-objectp-type 'nat x p)
              (and (equal (type x) 'nat)
                   (equal (cddr x) nil)
                   (small-naturalp (untag x)
                                   (p-word-size p))))
       (equal (p-objectp-type 'int x p)
              (and (equal (type x) 'int)
                   (equal (cddr x) nil)
                   (small-integerp (untag x)
                                   (p-word-size p))))
       (equal (p-objectp-type 'bitv x p)
              (and (equal (type x) 'bitv)
                   (equal (cddr x) nil)
                   (bit-vectorp (untag x)
                                (p-word-size p))))
       (equal (p-objectp-type 'bool x p)
              (and (equal (type x) 'bool)
                   (equal (cddr x) nil)
                   (booleanp (untag x))))
       (equal (p-objectp-type 'addr x p)
              (and (equal (type x) 'addr)
                   (equal (cddr x) nil)
                   (adpp (untag x)
                         (p-data-segment p))))
       (equal (p-objectp-type 'pc x p)
              (and (equal (type x) 'pc)
                   (equal (cddr x) nil)
                   (pcpp (untag x)
                         (p-prog-segment p))))
       (equal (p-objectp-type 'subr x p)
              (and (equal (type x) 'subr)
                   (equal (cddr x) nil)
                   (definedp (untag x)
                             (p-prog-segment p))))))

(disable p-objectp-type)

; Confession:  I feel a little dirty for this.  If I ever remove
; the p-objectp tests in the -okp predicates, this will return to
; bite me.  By the way, this problem first arose when I did
; the deposit preservation lemma below.  I put the solution up
; here to keep it in proximity with the lemmas that caused the
; trouble.

(prove-lemma pop-global-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-global)
               (proper-p-statep p)
               (p-pop-global-okp (p-current-instruction p)
                          p))
          (ur-proper-p-statep
           (p-pop-global-step (p-current-instruction p)
                              p))))

; We need similar machinery to do local variable manipulation.
; In particular, we need to know that any var value extracted
; from the top frame of the ctrl stack is a p-objectp and that
; depositing any p-objectp there leaves the stack proper.

; Here's extraction:

(prove-lemma p-objectp-cdr-assoc-proper-p-alistp (rewrite)
  (implies (and (proper-p-alistp alist p)
                (member var (strip-cars alist)))
           (p-objectp (cdr (assoc var alist)) p)))

; So we get:

(prove-lemma push-local-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-local)
               (proper-p-statep p)
               (p-push-local-okp (p-current-instruction p)
                                 p))
          (ur-proper-p-statep
           (p-push-local-step (p-current-instruction p)
                              p))))

; And now we deal with depositing.  The p machine puts a
; new frame on the stack, replacing the old one.  We need
; to prove that the new frame is proper.  There are many
; parts.  The new frame is built with P-FRAME and the 
; "shape" requirements follow immediately from its defn:

(prove-lemma p-frame-properties (rewrite)
  (and (listp (cdr (p-frame alist ret-pc)))
       (equal (cddr (p-frame alist ret-pc)) nil))
  ((enable p-frame)))

; The requirement that the new bindings be a proper-p-alistp
; is established by:

(prove-lemma proper-p-alistp-put-assoc (rewrite)
  (implies (and (proper-p-alistp alist p)
                (member var (strip-cars alist))
                (p-objectp val p))
           (proper-p-alistp (put-assoc val var alist) p)))

; The requirement that the strip-cars of the bindings be
; the local-vars of the current subroutine follows from the
; observation that the strip-cars of the new bindings is the
; same as for the old:

(prove-lemma strip-cars-put-assoc (rewrite)
  (equal (strip-cars (put-assoc val var alist))
         (strip-cars alist)))

; That completes the proof that the new frame is proper.  We
; also have to prove that the new ctrl stack isn't too big.
; This follows immediately from the fact that the new stack is
; the same size as the old, but that simple observation doesn't
; help us unless we disable some arithmetic stuff, because the
; sizes are computed and cause some linear arithmetic splits.
; Rather than disable I'll just handle the splits.  It suffices
; to know:

(prove-lemma not-equal-p-ctrl-stk-size-1 (rewrite)
  (implies (proper-p-statep1 p)
           (not (equal (sub1 (p-ctrl-stk-size (p-ctrl-stk p))) 0)))
  ((expand (p-ctrl-stk-size (p-ctrl-stk p)))))

; That completes the entire pop-local exercise.

(prove-lemma pop-local-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-local)
               (proper-p-statep p)
               (p-pop-local-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-pop-local-step (p-current-instruction p)
                             p))))

(prove-lemma deposit-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit)
               (proper-p-statep p)
               (p-deposit-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-deposit-step (p-current-instruction p)
                           p))))

(prove-lemma add1-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-nat)
               (proper-p-statep p)
               (p-add1-nat-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-add1-nat-step (p-current-instruction p)
                            p))))

(prove-lemma add-addr-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-addr)
               (proper-p-statep p)
               (p-add-addr-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-add-addr-step (p-current-instruction p)
                            p))))

; I still need some facts about lessp length and cdr!
; I hope this will take care of it:

(prove-lemma not-lessp-length-cdr-backchainer (rewrite)
  (implies (not (lessp max (length lst)))
           (equal (lessp max (length (cdr lst))) f)))

; For add-nat-with-carry we need to prove that our computed
; result is a p-objectp.  It suffices to know:

(prove-lemma small-naturalp-fix-small-natural (rewrite)
  (small-naturalp (fix-small-natural i n)
                  n)
  ((enable small-naturalp fix-small-natural)))

; These kind of lemmas will be required each time we shift to
; consideration of a new data type.

(prove-lemma add-nat-with-carry-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat-with-carry)
               (proper-p-statep p)
               (p-add-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-add-nat-with-carry-step (p-current-instruction p)
                                      p))))

(prove-lemma mult2-nat-with-carry-out-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat-with-carry-out)
               (proper-p-statep p)
               (p-mult2-nat-with-carry-out-okp (p-current-instruction p)
                                               p))
          (ur-proper-p-statep
           (p-mult2-nat-with-carry-out-step
            (p-current-instruction p)
            p))))

(prove-lemma p-objectp-get-temp-stk (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (lessp n (length temp-stk)))
           (p-objectp (get n temp-stk) p))
  ((induct (get n temp-stk))
   (enable get)))

(prove-lemma fetch-temp-stk-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch-temp-stk)
               (proper-p-statep p)
               (p-fetch-temp-stk-okp (p-current-instruction p)
                                               p))
          (ur-proper-p-statep
           (p-fetch-temp-stk-step
            (p-current-instruction p)
            p))))

(prove-lemma proper-p-temp-stkp-put (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (p-objectp val p)
                (lessp n (length temp-stk)))
           (proper-p-temp-stkp (put val n temp-stk) p))
  ((induct (put val n temp-stk))
   (enable put)))

(prove-lemma deposit-temp-stk-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit-temp-stk)
               (proper-p-statep p)
               (p-deposit-temp-stk-okp (p-current-instruction p)
                                               p))
          (ur-proper-p-statep
           (p-deposit-temp-stk-step
            (p-current-instruction p)
            p))))

; For POP* we clearly need:

(prove-lemma proper-p-temp-stkp-cdr-n (rewrite)
  (implies (and (proper-p-temp-stkp stk p)
                (not (lessp (length stk) n)))
           (proper-p-temp-stkp (cdr-n n stk) p))
  ((induct (cdr-n n stk))))

(prove-lemma pop*-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop*)
               (proper-p-statep p)
               (p-pop*-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-pop*-step (p-current-instruction p)
                             p))))

(prove-lemma popn-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popn)
               (proper-p-statep p)
               (p-popn-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-popn-step (p-current-instruction p)
                             p))))


; For what it's worth, this concludes the so-called "test section"
; of instructions identified as interesting in the case of the
; one-way-correspondence proof.

(prove-lemma set-local-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-local)
               (proper-p-statep p)
               (p-set-local-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-set-local-step (p-current-instruction p)
                             p))))

(prove-lemma set-global-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-global)
               (proper-p-statep p)
               (p-set-global-okp (p-current-instruction p)
                                 p))
          (ur-proper-p-statep
           (p-set-global-step (p-current-instruction p)
                              p))))

; To get push-constant we have to know that the case analysis done
; to unabbreviate the constant is the same as that done in the
; syntax check, proper-p-push-constant-instructionp.  It suffices
; to know:

(prove-lemma nlistp-implies-not-p-objectp (rewrite)
  (implies (nlistp x)
           (equal (p-objectp x p) f))
  ((enable p-objectp)))

(prove-lemma labels-are-nlistp-generalized nil
  (implies (and (proper-labeled-p-instructionsp body name p)
                (listp lab))
           (not (find-labelp lab body)))
  ((enable legal-labelp)))

(prove-lemma proper-p-prog-segmentp-implies-proper-labled-p-instructionsp nil
  (implies (and (proper-p-prog-segmentp segment p)
                (definedp name segment))
           (proper-labeled-p-instructionsp
            (program-body (assoc name segment))
            name p))
  ((enable proper-p-programp proper-p-program-bodyp name)))

(prove-lemma labels-are-nlistp (rewrite)
  (implies (and (proper-p-statep1 p)
                (definedp name (p-prog-segment p))
                (listp lab))
           (not (find-labelp lab
                             (program-body
                              (assoc name (p-prog-segment p))))))
  ((use (labels-are-nlistp-generalized
         (body (program-body
                (assoc name (p-prog-segment p)))))
        (proper-p-prog-segmentp-implies-proper-labled-p-instructionsp
         (segment (p-prog-segment p))))))

; The following is needed to prove that when a "label" is pushed
; the object is a p-objectp.

(prove-lemma lessp-find-label (rewrite)
  (implies (find-labelp lab lst)
           (lessp (find-label lab lst) (length lst))))

(prove-lemma push-constant-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-constant)
               (proper-p-statep p)
               (p-push-constant-okp (p-current-instruction p)
                                    p))
          (ur-proper-p-statep
           (p-push-constant-step (p-current-instruction p)
                                 p))))

; To get push-ctrl-stk-free-size we need to know that the number
; pushed is a small-naturalp.  Despite its name the lemma below
; actually shows that any number less than p-max-ctrl-stk-size is
; ok.

(prove-lemma proper-p-statep-implies-small-naturalp-p-max-ctrl-stk-size
             (rewrite)
  (implies (lessp (p-max-ctrl-stk-size p)
                  (exp 2 (p-word-size p)))
           (small-naturalp (difference (p-max-ctrl-stk-size p)
                                       n)
                           (p-word-size p)))
  ((enable small-naturalp)))

(prove-lemma push-ctrl-stk-free-size-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-ctrl-stk-free-size)
               (proper-p-statep p)
               (p-push-ctrl-stk-free-size-okp (p-current-instruction p)
                                              p))
          (ur-proper-p-statep
           (p-push-ctrl-stk-free-size-step
            (p-current-instruction p)
            p))))

; We prove an analogous lemma for p-max-temp-stk-size:

(prove-lemma proper-p-statep-implies-small-naturalp-p-max-temp-stk-size
             (rewrite)
  (implies (lessp (p-max-temp-stk-size p)
                  (exp 2 (p-word-size p)))
           (small-naturalp (difference (p-max-temp-stk-size p)
                                       n)
                           (p-word-size p)))
  ((enable small-naturalp)))

(prove-lemma push-temp-stk-free-size-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-free-size)
               (proper-p-statep p)
               (p-push-temp-stk-free-size-okp (p-current-instruction p)
                                              p))
          (ur-proper-p-statep
           (p-push-temp-stk-free-size-step
            (p-current-instruction p)
            p))))

; And we prove the analogous lemma for the index pushed by push-temp-stk-index.

(prove-lemma proper-p-statep-implies-small-naturalp-length-p-temp-stk
             (rewrite)
  (implies (and (lessp (p-max-temp-stk-size p)
                       (exp 2 (p-word-size p)))
                (lessp (length (p-temp-stk p)) (p-max-temp-stk-size p)))
           (small-naturalp (sub1 (difference (length (p-temp-stk p)) n))
                           (p-word-size p)))
  ((enable small-naturalp)))

(prove-lemma push-temp-stk-index-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-index)
               (proper-p-statep p)
               (p-push-temp-stk-index-okp (p-current-instruction p)
                                          p))
          (ur-proper-p-statep
           (p-push-temp-stk-index-step
            (p-current-instruction p)
            p))))

(prove-lemma pop-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop)
               (proper-p-statep p)
               (p-pop-okp (p-current-instruction p)
                          p))
          (ur-proper-p-statep
           (p-pop-step (p-current-instruction p)
                       p))))

(prove-lemma jump-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump)
               (proper-p-statep p)
               (p-jump-okp (p-current-instruction p)
                           p))
          (ur-proper-p-statep
           (p-jump-step (p-current-instruction p)
                        p))))

(prove-lemma pushj-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pushj)
               (proper-p-statep p)
               (p-pushj-okp (p-current-instruction p)
                            p))
          (ur-proper-p-statep
           (p-pushj-step (p-current-instruction p)
                         p))))

(prove-lemma popj-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popj)
               (proper-p-statep p)
               (p-popj-okp (p-current-instruction p)
                           p))
          (ur-proper-p-statep
           (p-popj-step (p-current-instruction p)
                        p))))

(prove-lemma sub-addr-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-addr)
               (proper-p-statep p)
               (p-sub-addr-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-sub-addr-step (p-current-instruction p)
                            p))))

; Since bool is disabled we need:

(prove-lemma p-objectp-bool (rewrite)
  (p-objectp (bool x) p)
  ((enable bool)))

(prove-lemma eq-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'eq)
               (proper-p-statep p)
               (p-eq-okp (p-current-instruction p)
                         p))
          (ur-proper-p-statep
           (p-eq-step (p-current-instruction p)
                      p))))

(prove-lemma lt-addr-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-addr)
               (proper-p-statep p)
               (p-lt-addr-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-lt-addr-step (p-current-instruction p)
                           p))))

(prove-lemma fetch-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch)
               (proper-p-statep p)
               (p-fetch-okp (p-current-instruction p)
                            p))
          (ur-proper-p-statep
           (p-fetch-step (p-current-instruction p)
                         p))))

(prove-lemma add-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int)
               (proper-p-statep p)
               (p-add-int-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-add-int-step (p-current-instruction p)
                           p))))

(enable small-integerp-fix-small-integer-plus-case)

(prove-lemma add-int-with-carry-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int-with-carry)
               (proper-p-statep p)
               (p-add-int-with-carry-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-add-int-with-carry-step (p-current-instruction p)
                                      p))))

(prove-lemma add1-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-int)
               (proper-p-statep p)
               (p-add1-int-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-add1-int-step (p-current-instruction p)
                            p))))

(prove-lemma sub-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int)
               (proper-p-statep p)
               (p-sub-int-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-sub-int-step (p-current-instruction p)
                           p))))

(enable small-integerp-fix-small-integer-difference-case)

(prove-lemma sub-int-with-carry-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int-with-carry)
               (proper-p-statep p)
               (p-sub-int-with-carry-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-sub-int-with-carry-step (p-current-instruction p)
                                      p))))

(prove-lemma sub1-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-int)
               (proper-p-statep p)
               (p-sub1-int-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-sub1-int-step (p-current-instruction p)
                            p))))

(prove-lemma neg-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'neg-int)
               (proper-p-statep p)
               (p-neg-int-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-neg-int-step (p-current-instruction p)
                           p))))

(prove-lemma lt-int-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-int)
               (proper-p-statep p)
               (p-lt-int-okp (p-current-instruction p)
                             p))
          (ur-proper-p-statep
           (p-lt-int-step (p-current-instruction p)
                          p))))

; For int-to-nat conversion we clearly need:

(prove-lemma small-integerp-implies-small-naturalp (rewrite)
  (implies (and (small-integerp x word-size)
                (not (negativep x)))
           (small-naturalp x word-size))
  ((enable small-integerp ilessp small-naturalp)))

(prove-lemma int-to-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'int-to-nat)
               (proper-p-statep p)
               (p-int-to-nat-okp (p-current-instruction p)
                             p))
          (ur-proper-p-statep
           (p-int-to-nat-step (p-current-instruction p)
                          p))))

(prove-lemma add-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat)
               (proper-p-statep p)
               (p-add-nat-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-add-nat-step (p-current-instruction p)
                           p))))

(prove-lemma small-naturalp-difference (rewrite)
  (implies (small-naturalp x word-size)
           (small-naturalp (difference x y) word-size))
  ((enable small-naturalp)))

(prove-lemma sub-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat)
               (proper-p-statep p)
               (p-sub-nat-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-sub-nat-step (p-current-instruction p)
                           p))))

; sub-nat-with-carry flag returns one of two different
; differences depending on the args.  We have to show that
; both are small-naturalps.  The first is handled by
; small-natural-difference above.

; The second is:

(prove-lemma small-naturalp-difference-exp-x (rewrite)
  (implies (not (zerop x))
           (small-naturalp (difference (exp 2 word-size) x)
                           word-size))
  ((enable small-naturalp)))

(prove-lemma sub-nat-with-carry-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat-with-carry)
               (proper-p-statep p)
               (p-sub-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-sub-nat-with-carry-step (p-current-instruction p)
                                      p))))

(prove-lemma small-naturalp-sub1 (rewrite)
  (implies (small-naturalp x word-size)
           (small-naturalp (sub1 x) word-size))
  ((enable small-naturalp)))

(prove-lemma sub1-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-nat)
               (proper-p-statep p)
               (p-sub1-nat-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-sub1-nat-step (p-current-instruction p)
                            p))))

(prove-lemma lt-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-nat)
               (proper-p-statep p)
               (p-lt-nat-okp (p-current-instruction p)
                             p))
          (ur-proper-p-statep
           (p-lt-nat-step (p-current-instruction p)
                          p))))

(prove-lemma mult2-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat)
               (proper-p-statep p)
               (p-mult2-nat-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-mult2-nat-step (p-current-instruction p)
                             p))))

; For div2-nat we must establish that the results are small-naturalps.

(prove-lemma not-lessp-remainder (rewrite)
  (not (lessp x (remainder x y))))
           
(enable not-lessp-quotient)

(prove-lemma small-naturalp-remainder (rewrite)
  (implies (small-naturalp x word-size)
           (small-naturalp (remainder x 2) word-size))
  ((enable small-naturalp)))

(prove-lemma small-naturalp-quotient (rewrite)
  (implies (small-naturalp x word-size)
           (small-naturalp (quotient x 2) word-size))
  ((enable small-naturalp)))

(prove-lemma div2-nat-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'div2-nat)
               (proper-p-statep p)
               (p-div2-nat-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-div2-nat-step (p-current-instruction p)
                            p))))

; We must show that each bit vector operation yields a bit vector:

(prove-lemma bit-vectorp-or-bitv (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (bit-vectorp (or-bitv x y) word-size)))

(prove-lemma bit-vectorp-and-bitv (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (bit-vectorp (and-bitv x y) word-size)))

(prove-lemma bit-vectorp-xor-bitv (rewrite)
  (implies (and (bit-vectorp x word-size)
                (bit-vectorp y word-size))
           (bit-vectorp (xor-bitv x y) word-size)))

(prove-lemma bit-vectorp-not-bitv (rewrite)
  (implies (bit-vectorp x word-size)
           (bit-vectorp (not-bitv x) word-size)))

; It surprised me to see that we need, yet again, the fact that our
; machine has a non-zero word-size.

(prove-lemma bit-vectorp-rsh-bitv (rewrite)
  (implies (and (bit-vectorp x word-size)
                (not (zerop word-size)))
           (bit-vectorp (rsh-bitv x) word-size)))

(disable rsh-bitv)

(prove-lemma bit-vectorp-lsh-bitv (rewrite)
  (implies (and (bit-vectorp x word-size)
                (not (zerop word-size)))
           (bit-vectorp (lsh-bitv x) word-size)))

(disable lsh-bitv)

; To use the latter two rules we need:

(prove-lemma p-loadablep-implies-not-zerop-p-word-size (rewrite)
  (implies (p-loadablep p load-addr)
           (and (numberp (p-word-size p))
                (not (equal (p-word-size p) 0))))
  ((enable p-loadablep)))

(prove-lemma or-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bitv)
               (proper-p-statep p)
               (p-or-bitv-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-or-bitv-step (p-current-instruction p)
                           p))))

(prove-lemma and-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bitv)
               (proper-p-statep p)
               (p-and-bitv-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-and-bitv-step (p-current-instruction p)
                            p))))

(prove-lemma not-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bitv)
               (proper-p-statep p)
               (p-not-bitv-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-not-bitv-step (p-current-instruction p)
                            p))))

(prove-lemma xor-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'xor-bitv)
               (proper-p-statep p)
               (p-xor-bitv-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-xor-bitv-step (p-current-instruction p)
                            p))))

(prove-lemma rsh-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'rsh-bitv)
               (proper-p-statep p)
               (p-rsh-bitv-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-rsh-bitv-step (p-current-instruction p)
                            p))))

(prove-lemma lsh-bitv-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lsh-bitv)
               (proper-p-statep p)
               (p-lsh-bitv-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-lsh-bitv-step (p-current-instruction p)
                            p))))

; And we must do the analogous thing for the boolean type and its
; operators.

(prove-lemma booleanp-or-bool (rewrite)
  (implies (and (booleanp x)
                (booleanp y))
           (booleanp (or-bool x y)))
  ((enable booleanp or-bool)))

(prove-lemma booleanp-and-bool (rewrite)
  (implies (and (booleanp x)
                (booleanp y))
           (booleanp (and-bool x y)))
  ((enable booleanp and-bool)))

(prove-lemma booleanp-not-bool (rewrite)
  (implies (booleanp x)
           (booleanp (not-bool x)))
  ((enable booleanp not-bool)))

(prove-lemma or-bool-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bool)
               (proper-p-statep p)
               (p-or-bool-okp (p-current-instruction p)
                              p))
          (ur-proper-p-statep
           (p-or-bool-step (p-current-instruction p)
                           p))))

(prove-lemma and-bool-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bool)
               (proper-p-statep p)
               (p-and-bool-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-and-bool-step (p-current-instruction p)
                            p))))

(prove-lemma not-bool-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bool)
               (proper-p-statep p)
               (p-not-bool-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-not-bool-step (p-current-instruction p)
                            p))))

(prove-lemma jump-if-temp-stk-full-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-full)
               (proper-p-statep p)
               (p-jump-if-temp-stk-full-okp (p-current-instruction p)
                                            p))
          (ur-proper-p-statep
           (p-jump-if-temp-stk-full-step
            (p-current-instruction p)
            p))))

(prove-lemma jump-if-temp-stk-empty-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-empty)
               (proper-p-statep p)
               (p-jump-if-temp-stk-empty-okp (p-current-instruction p)
                                             p))
          (ur-proper-p-statep
           (p-jump-if-temp-stk-empty-step
            (p-current-instruction p)
            p)))
 ((enable empty-stkp)))

(prove-lemma test-nat-and-jump-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-nat-and-jump)
               (proper-p-statep p)
               (p-test-nat-and-jump-okp (p-current-instruction p)
                                        p))
          (ur-proper-p-statep
           (p-test-nat-and-jump-step (p-current-instruction p)
                                     p))))

(prove-lemma test-int-and-jump-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-int-and-jump)
               (proper-p-statep p)
               (p-test-int-and-jump-okp (p-current-instruction p)
                                        p))
          (ur-proper-p-statep
           (p-test-int-and-jump-step (p-current-instruction p)
                                     p))))

(prove-lemma test-bool-and-jump-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bool-and-jump)
               (proper-p-statep p)
               (p-test-bool-and-jump-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-test-bool-and-jump-step (p-current-instruction p)
                                      p))))

(prove-lemma test-bitv-and-jump-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bitv-and-jump)
               (proper-p-statep p)
               (p-test-bitv-and-jump-okp (p-current-instruction p)
                                         p))
          (ur-proper-p-statep
           (p-test-bitv-and-jump-step (p-current-instruction p)
                                      p))))

; Since pop-locn uses put-value-indirect to modify the control
; stack, we must know:

(prove-lemma proper-p-alistp-put-value-indirect (rewrite)
  (implies (and (proper-p-alistp alist p)
                (lessp n (length alist))
                (p-objectp val p))
           (proper-p-alistp (put-value-indirect val n alist) p)))

(prove-lemma strip-cars-put-value-indirect (rewrite)
  (equal (strip-cars (put-value-indirect val n alist))
         (strip-cars alist)))

; Note:  below we prevent p-ctrl-stk-size from expanding -- either
; via its defn or the -cons-p-frame lemma proved during the call
; owc work.  This allows the lemma we proved during pop-locn 
; owc to normalize the ctrl-stk-size of the new stack.

(prove-lemma pop-locn-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-locn)
               (proper-p-statep p)
               (p-pop-locn-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-pop-locn-step (p-current-instruction p)
                            p)))
 ((disable p-ctrl-stk-size p-ctrl-stk-size-cons-p-frame)))

(prove-lemma p-objectp-cdr-get-proper-p-alistp (rewrite)
  (implies (and (proper-p-alistp alist p)
                (lessp n (length alist)))
           (p-objectp (cdr (get n alist)) p))
  ((enable get)))

(prove-lemma locn-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'locn)
               (proper-p-statep p)
               (p-locn-okp (p-current-instruction p)
                           p))
          (ur-proper-p-statep
           (p-locn-step (p-current-instruction p)
                        p))))

; The legality of the pc computed by a jump-case depends on the
; all-find-labelp check:

(prove-lemma all-find-labelp-implies-find-labelp-get (rewrite)
  (implies (and (all-find-labelp lst body)
                (lessp n (length lst)))
           (find-labelp (get n lst) body))
  ((enable get)))

(prove-lemma jump-case-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-case)
               (proper-p-statep p)
               (p-jump-case-okp (p-current-instruction p)
                                p))
          (ur-proper-p-statep
           (p-jump-case-step (p-current-instruction p)
                             p))))

; So now we begin call.

; First we establish that the body of the called subroutine is a listp.

(prove-lemma listp-program-body-generalized{special} nil
  (implies (and (proper-p-prog-segmentp segment p)
                (definedp name segment))
           (listp (program-body (assoc name segment))))
  ((enable proper-p-programp proper-p-program-bodyp)))

(prove-lemma listp-program-body{special} (rewrite)
  (implies (and (proper-p-statep1 p)
                (definedp name (p-prog-segment p)))
           (listp (program-body (assoc name (p-prog-segment p)))))
  ((use (listp-program-body-generalized{special}
         (segment (p-prog-segment p))))))

; Next we have to know that the bindings in the new frame is proper.
; We take it in steps.  First, we divide it into the section of formals
; and the section of locals:

(prove-lemma proper-p-alistp-append (rewrite)
  (implies (properp a)
           (equal (proper-p-alistp (append a b) p)
                  (and (proper-p-alistp a p)
                       (proper-p-alistp b p)))))

; In the application in question, a above is a call of pairlist.  It is 
; properp:

; A lemma properp-pairlist exists in fm9001.events, but it did not
; originally.  We accommodate this change by introducing the "my-"
; prefix below.

(prove-lemma my-properp-pairlist (rewrite)
  (properp (pairlist a b)))

; So after the rule is applied, we have to prove two proper-p-alistps.
; The first is for the pairlist of the formals to the actuals.
; The second is for the initialization of the temp vars.

; The first is handled by:

(prove-lemma proper-p-alistp-pairlist (rewrite)
  (implies (and (all-litatoms formals)
                (all-p-objectps actuals p)
                (equal (length formals) (length actuals)))
           (proper-p-alistp (pairlist formals actuals) p)))

; where the hypotheses above are relieved as follows.  The all-litatoms
; of the formals is derived from proper-p-prog-segmentp:

(prove-lemma all-litatoms-formal-vars-generalized nil
  (implies (and (proper-p-prog-segmentp segment p)
                (definedp name segment))
           (all-litatoms (formal-vars (assoc name segment))))
  ((enable proper-p-programp proper-p-program-bodyp)))

(prove-lemma all-litatoms-formal-vars (rewrite)
  (implies (and (proper-p-prog-segmentp (p-prog-segment p) p)
                (definedp name (p-prog-segment p)))
           (all-litatoms (formal-vars (assoc name (p-prog-segment p)))))
  ((use (all-litatoms-formal-vars-generalized
         (segment (p-prog-segment p))))))

; The all-p-objectps of the actuals is a little more interesting.  The
; actuals in question are the reverse of the first-n elements of temp-stk.
; We eliminate the reverse with:

(prove-lemma all-p-objectps-append (rewrite)
  (implies (properp a)
           (equal (all-p-objectps (append a b) p)
                  (and (all-p-objectps a p)
                       (all-p-objectps b p)))))

(prove-lemma all-p-objectps-rev (rewrite)
  (implies (properp lst)
           (equal (all-p-objectps (rev lst) p)
                  (all-p-objectps lst p))))

; where we know:

(prove-lemma properp-first-n (rewrite)
  (properp (first-n n lst)))

; Then we get that the first-n elements of the temp stack are p-objects
; by:

(prove-lemma all-p-objectps-first-n (rewrite)
  (implies (and (proper-p-temp-stkp temp-stk p)
                (not (lessp (length temp-stk) n)))
           (all-p-objectps (first-n n temp-stk) p))
  ((induct (first-n n temp-stk))))

; The third hypothesis of the pairlist lemma above is that the lengths of
; the formals and actuals are the same.  That follows from what we've
; already proved.

; Now we move to the second proper-p-alistp task, namely, for the
; initialization of the temp vars.  That is handled by:

(prove-lemma proper-p-prog-segmentp-implies-proper-p-temp-var-dclsp (rewrite)
  (implies (and (proper-p-prog-segmentp segment p)
                (definedp name segment))
           (proper-p-temp-var-dclsp (temp-var-dcls (assoc name segment))
                                    p))
  ((enable proper-p-programp proper-p-program-bodyp)))

(prove-lemma proper-p-alistp-pair-temps-with-initial-values (rewrite)
  (implies (proper-p-temp-var-dclsp var-dcls p)
           (proper-p-alistp (pair-temps-with-initial-values var-dcls)
                            p)))

; That takes care of the proper-p-alistp of the new bindings.

; Next we have to prove that the strip-cars of the new bindings
; is correct.  We start by distributing the strip-cars over the
; append

(prove-lemma strip-cars-append (rewrite)
  (equal (strip-cars (append a b))
         (append (strip-cars a)
                 (strip-cars b))))

; Of course, a and b are as discussed above.  So for the a side we need:

(prove-lemma strip-cars-pairlist (rewrite)
  (implies (properp formals)
           (equal (strip-cars (pairlist formals actuals)) formals)))

; where we know

(prove-lemma all-litatoms-implies-properp (rewrite)
  (implies (all-litatoms lst) (properp lst)))

; and we've already set up the machinery to show that the formals are
; all-litatoms.

; For the b side, its

(prove-lemma strip-cars-pair-temps-with-initial-values (rewrite)
  (equal (strip-cars (pair-temps-with-initial-values lst))
         (strip-cars lst)))

; That completes the work for the strip-cars.  

; The next part of the proper-p-statep check is that the temp-stk
; is proper.  We did the work for that with POP*.

; And that is all we need for call.

(prove-lemma call-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'call)
               (proper-p-statep p)
               (p-call-okp (p-current-instruction p)
                           p))
          (ur-proper-p-statep
           (p-call-step (p-current-instruction p)
                        p)))
 ((enable p->r_ctrl-stk)
  (disable p-ctrl-stk-size
           p->r_ctrl-stk1
           p->r_ctrl-stk1-opener)))

; Note:  The hints above are identical to those for the call owc
; proof.  The entire list of preservation lemmas was generated
; mechanically, hints and all, from the owc list.

; The call work also takes care of pop-call.

(prove-lemma pop-call-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-call)
               (proper-p-statep p)
               (p-pop-call-okp (p-current-instruction p)
                               p))
          (ur-proper-p-statep
           (p-pop-call-step (p-current-instruction p)
                            p)))
  ((enable p->r_ctrl-stk difference-sub1)
   (disable nat-0s
            p-ctrl-stk-size
            p->r_ctrl-stk1
            p->r_ctrl-stk1-opener)))

; The ret case splits into two parts:  a top level ret or a ret inside
; a subroutine.  In both cases the problem is to prove proper-p-framep
; of the newly exposed frame.  If we leave proper-p-framep enabled,
; the proof of the top-level return is trivial because the newly exposed
; frame IS the frame described by proper-p-statep1, where proper-p-framep
; is opened up.  But the proof of the interior return becomes complicated
; because proper-p-framep expands after we pop the stack.  We therefore
; disable proper-p-framep in our proof and first prove:

; In the lemma below we need a little more than proper-p-statep1, 
; because the arithmetic part of proper-p-statep was not put into
; proper-p-statep1.

(prove-lemma proper-p-statep1-implies-proper-p-framep (rewrite)
  (implies (and (proper-p-statep1 p)
                (numberp (cdr (untag (ret-pc (car (p-ctrl-stk p))))))
                (lessp
                 (cdr (untag (ret-pc (car (p-ctrl-stk p)))))
                 (length
                  (program-body
                   (assoc (car (untag (ret-pc (car (p-ctrl-stk p)))))
                          (p-prog-segment p))))))
           (proper-p-framep (car (p-ctrl-stk p))
                            (car (untag (p-pc p)))
                            p)))

; In the case of an interior return, it suffices to open up
; proper-p-ctrl-stkp to see that the newly exposed frame is ok
; and that the rest of the stack is proper.  But proper-p-ctrl-stkp
; is hidden in proper-p-statep1.  So I prove two backchaining
; lemmas:

(prove-lemma proper-p-ctrl-stkp-implies-proper-p-framep (rewrite)
  (implies (and (proper-p-ctrl-stkp (cdr (p-ctrl-stk p))
                                    (car (untag
                                          (ret-pc (car (p-ctrl-stk p)))))
                                    p)
                (listp (cdr (p-ctrl-stk p))))
           (proper-p-framep (cadr (p-ctrl-stk p))
                            (car (untag (ret-pc (car (p-ctrl-stk p)))))
                            p))
  ((disable proper-p-framep)))

(prove-lemma proper-p-ctrl-stkp-implies-proper-p-ctrl-stkp (rewrite)
  (implies (and (proper-p-ctrl-stkp (cdr (p-ctrl-stk p))
                                    (car (untag
                                          (ret-pc (car (p-ctrl-stk p)))))
                                    p)
                (listp (cdr (p-ctrl-stk p))))
           (proper-p-ctrl-stkp (cddr (p-ctrl-stk p))
                               (car (untag (ret-pc (cadr (p-ctrl-stk p)))))
                               p))
  ((disable proper-p-framep)))

(prove-lemma ret-preserves-proper-p-statep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'ret)
               (proper-p-statep p)
               (p-ret-okp (p-current-instruction p)
                          p))
          (ur-proper-p-statep
           (p-ret-step (p-current-instruction p)
                       p)))
 ((expand (p-ctrl-stk-size (p-ctrl-stk p)))
  (disable p-ctrl-stk-size proper-p-framep)
  (enable empty-stkp)))

; I had forgotten to handle the lemmas of the form:

; (p-xxx-okp p) -> (r-xxx-okp (p->r p)).

; So I'll do them now.  Once I tried doing them up
; there, where I had their -step correspondents, but
; I found there were several useful rules developed during
; the proper-p-state preservation lemmas.

(prove-lemma p-no-op-okp-implies-r-no-op-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'no-op)
               (proper-p-statep p)
               (p-no-op-okp (p-current-instruction p)
                            p))
          (r-no-op-okp (p-current-instruction p)
                       (p->r p))))

(prove-lemma p-push-global-okp-implies-r-push-global-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-global)
               (proper-p-statep p)
               (p-push-global-okp (p-current-instruction p)
                                  p))
          (r-push-global-okp (p-current-instruction p)
                             (p->r p))))

(enable empty-stkp)

; We need to know that every p-objectp is an r-usr-data-objectp

(prove-lemma p-objectp-is-r-usr-data-typep nil
  (implies (p-objectp x p)
           (r-usr-data-typep (type x)))
  ((enable p-objectp r-usr-data-typep)))
  
; The lemma above isn't very useful as a rule because of the free
; var.  We take care of that for the instance we need right now:

(prove-lemma r-usr-data-typep-top (rewrite)
  (implies (and (proper-p-statep1 p)
                (listp (p-temp-stk p)))
           (r-usr-data-typep (type (car (p-temp-stk p)))))
  ((use (p-objectp-is-r-usr-data-typep
         (x (car (p-temp-stk p)))))))

(prove-lemma r-usr-data-typep-top1 (rewrite)
  (implies (and (proper-p-statep1 p)
                (listp (cdr (p-temp-stk p))))
           (r-usr-data-typep (type (cadr (p-temp-stk p)))))
  ((use (p-objectp-is-r-usr-data-typep
         (x (cadr (p-temp-stk p)))))))

(prove-lemma r-usr-data-typep-top2 (rewrite)
  (implies (and (proper-p-statep1 p)
                (listp (cddr (p-temp-stk p))))
           (r-usr-data-typep (type (caddr (p-temp-stk p)))))
  ((use (p-objectp-is-r-usr-data-typep
         (x (caddr (p-temp-stk p)))))))

; That was the easy part, about the type tag.  Now we do the
; nitty-gritty part.

(prove-lemma p-objectp-implies-r-objectp (rewrite)
  (implies (and (p-objectp x p)
                (same-signature r-usr-data-segment
                                (p-data-segment p)))
           (r-objectp x (r-state r-pc r-cfp r-csp r-tsp
                                 r-x r-y r-c-flg r-v-flg r-n-flg r-z-flg
                                 (p-prog-segment p)
                                 r-usr-data-segment
                                 r-sys-data-segment
                                 (p-word-size p)
                                 r-psw)))
  ((enable p-objectp r-objectp)))

(prove-lemma p-pop-global-okp-implies-r-pop-global-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-global)
               (proper-p-statep p)
               (p-pop-global-okp (p-current-instruction p)
                                 p))
          (r-pop-global-okp (p-current-instruction p)
                            (p->r p))))

; To get the transition for push-local we need to know a little more
; about the size of the control stack -- recall that r-push-local-okp
; checks that several incremented stack pointers are non-empty-stkp.
; The idea is to show that the position from which we are fetching
; -- which is computed by looking up the posiition of the the var -- is not
; at the (NAT 0) marking the end of the stack.

(prove-lemma lessp-length-bindings nil
  (implies (listp ctrl-stk)
           (lessp (length (bindings (top ctrl-stk)))
                  (p-ctrl-stk-size ctrl-stk))))

(prove-lemma lessp-length-bindings-p-ctrl-stk (rewrite)
  (implies (proper-p-statep1 p)
           (lessp (plus (length
                         (formal-vars
                          (assoc (car (untag (p-pc p)))
                                 (p-prog-segment p))))
                        (length
                         (temp-var-dcls
                          (assoc (car (untag (p-pc p)))
                                 (p-prog-segment p)))))
                  (p-ctrl-stk-size (p-ctrl-stk p))))
  ((use (lessp-length-bindings
         (ctrl-stk (p-ctrl-stk p))))))

(prove-lemma p-push-local-okp-implies-r-push-local-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-local)
               (proper-p-statep p)
               (p-push-local-okp (p-current-instruction p)
                                 p))
          (r-push-local-okp (p-current-instruction p)
                            (p->r p))))

(prove-lemma p-pop-local-okp-implies-r-pop-local-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-local)
               (proper-p-statep p)
               (p-pop-local-okp (p-current-instruction p)
                                p))
          (r-pop-local-okp (p-current-instruction p)
                           (p->r p))))

(prove-lemma p-deposit-okp-implies-r-deposit-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit)
               (proper-p-statep p)
               (p-deposit-okp (p-current-instruction p)
                              p))
          (r-deposit-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-add1-nat-okp-implies-r-add1-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-nat)
               (proper-p-statep p)
               (p-add1-nat-okp (p-current-instruction p)
                               p))
          (r-add1-nat-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-add-addr-okp-implies-r-add-addr-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-addr)
               (proper-p-statep p)
               (p-add-addr-okp (p-current-instruction p)
                               p))
          (r-add-addr-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-add-nat-with-carry-okp-implies-r-add-nat-with-carry-okp
             (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat-with-carry)
               (proper-p-statep p)
               (p-add-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (r-add-nat-with-carry-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma
 p-mult2-nat-with-carry-out-okp-implies-r-mult2-nat-with-carry-out-okp
 (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat-with-carry-out)
               (proper-p-statep p)
               (p-mult2-nat-with-carry-out-okp (p-current-instruction p)
                                               p))
          (r-mult2-nat-with-carry-out-okp
           (p-current-instruction p)
           (p->r p))))

(prove-lemma p-fetch-temp-stk-okp-implies-r-fetch-temp-stk-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch-temp-stk)
               (proper-p-statep p)
               (p-fetch-temp-stk-okp (p-current-instruction p)
                                               p))
          (r-fetch-temp-stk-okp
           (p-current-instruction p)
           (p->r p))))

(prove-lemma p-deposit-temp-stk-okp-implies-r-deposit-temp-stk-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit-temp-stk)
               (proper-p-statep p)
               (p-deposit-temp-stk-okp (p-current-instruction p)
                                               p))
          (r-deposit-temp-stk-okp
           (p-current-instruction p)
           (p->r p))))

; To prove the next one we need to know that small-naturalp, as
; checked in proper-p-pop*-instructionp, implies numberp, as
; checked in r-pop*-okp.  We just enable small-naturalp

(prove-lemma p-pop*-okp-implies-r-pop*-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop*)
               (proper-p-statep p)
               (p-pop*-okp (p-current-instruction p)
                                p))
          (r-pop*-okp (p-current-instruction p)
                           (p->r p)))
 ((enable small-naturalp)))

(prove-lemma p-popn-okp-implies-r-popn-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popn)
               (proper-p-statep p)
               (p-popn-okp (p-current-instruction p)
                                p))
          (r-popn-okp (p-current-instruction p)
                           (p->r p)))
 ((enable small-naturalp)))

(prove-lemma p-set-local-okp-implies-r-set-local-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-local)
               (proper-p-statep p)
               (p-set-local-okp (p-current-instruction p)
                                p))
          (r-set-local-okp (p-current-instruction p)
                           (p->r p))))

(prove-lemma p-set-global-okp-implies-r-set-global-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-global)
               (proper-p-statep p)
               (p-set-global-okp (p-current-instruction p)
                                 p))
          (r-set-global-okp (p-current-instruction p)
                            (p->r p))))

(prove-lemma p-push-constant-okp-implies-r-push-constant-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-constant)
               (proper-p-statep p)
               (p-push-constant-okp (p-current-instruction p)
                                    p))
          (r-push-constant-okp (p-current-instruction p)
                               (p->r p))))

(prove-lemma
 p-push-ctrl-stk-free-size-okp-implies-r-push-ctrl-stk-free-size-okp
 (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-ctrl-stk-free-size)
               (proper-p-statep p)
               (p-push-ctrl-stk-free-size-okp (p-current-instruction p)
                                              p))
          (r-push-ctrl-stk-free-size-okp
           (p-current-instruction p)
           (p->r p))))

(prove-lemma
 p-push-temp-stk-free-size-okp-implies-r-push-temp-stk-free-size-okp
 (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-free-size)
               (proper-p-statep p)
               (p-push-temp-stk-free-size-okp (p-current-instruction p)
                                              p))
          (r-push-temp-stk-free-size-okp
           (p-current-instruction p)
           (p->r p))))

; Again, we enable small-naturalp to get the numberp check at the r-level.

(prove-lemma p-push-temp-stk-index-okp-implies-r-push-temp-stk-index-okp
             (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-index)
               (proper-p-statep p)
               (p-push-temp-stk-index-okp (p-current-instruction p)
                                          p))
          (r-push-temp-stk-index-okp
           (p-current-instruction p)
           (p->r p)))
 ((enable small-naturalp)))

(prove-lemma p-pop-okp-implies-r-pop-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop)
               (proper-p-statep p)
               (p-pop-okp (p-current-instruction p)
                          p))
          (r-pop-okp (p-current-instruction p)
                     (p->r p))))

(prove-lemma p-jump-okp-implies-r-jump-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump)
               (proper-p-statep p)
               (p-jump-okp (p-current-instruction p)
                           p))
          (r-jump-okp (p-current-instruction p)
                      (p->r p))))

(prove-lemma p-pushj-okp-implies-r-pushj-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pushj)
               (proper-p-statep p)
               (p-pushj-okp (p-current-instruction p)
                            p))
          (r-pushj-okp (p-current-instruction p)
                       (p->r p))))

(prove-lemma p-popj-okp-implies-r-popj-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popj)
               (proper-p-statep p)
               (p-popj-okp (p-current-instruction p)
                           p))
          (r-popj-okp (p-current-instruction p)
                      (p->r p))))

(prove-lemma p-sub-addr-okp-implies-r-sub-addr-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-addr)
               (proper-p-statep p)
               (p-sub-addr-okp (p-current-instruction p)
                               p))
          (r-sub-addr-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-eq-okp-implies-r-eq-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'eq)
               (proper-p-statep p)
               (p-eq-okp (p-current-instruction p)
                         p))
          (r-eq-okp (p-current-instruction p)
                    (p->r p))))

(prove-lemma p-lt-addr-okp-implies-r-lt-addr-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-addr)
               (proper-p-statep p)
               (p-lt-addr-okp (p-current-instruction p)
                              p))
          (r-lt-addr-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-fetch-okp-implies-r-fetch-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch)
               (proper-p-statep p)
               (p-fetch-okp (p-current-instruction p)
                            p))
          (r-fetch-okp (p-current-instruction p)
                       (p->r p))))

(prove-lemma p-add-int-okp-implies-r-add-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int)
               (proper-p-statep p)
               (p-add-int-okp (p-current-instruction p)
                              p))
          (r-add-int-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-add-int-with-carry-okp-implies-r-add-int-with-carry-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int-with-carry)
               (proper-p-statep p)
               (p-add-int-with-carry-okp (p-current-instruction p)
                                         p))
          (r-add-int-with-carry-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma p-add1-int-okp-implies-r-add1-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-int)
               (proper-p-statep p)
               (p-add1-int-okp (p-current-instruction p)
                               p))
          (r-add1-int-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-sub-int-okp-implies-r-sub-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int)
               (proper-p-statep p)
               (p-sub-int-okp (p-current-instruction p)
                              p))
          (r-sub-int-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-sub-int-with-carry-okp-implies-r-sub-int-with-carry-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int-with-carry)
               (proper-p-statep p)
               (p-sub-int-with-carry-okp (p-current-instruction p)
                                         p))
          (r-sub-int-with-carry-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma p-sub1-int-okp-implies-r-sub1-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-int)
               (proper-p-statep p)
               (p-sub1-int-okp (p-current-instruction p)
                               p))
          (r-sub1-int-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-neg-int-okp-implies-r-neg-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'neg-int)
               (proper-p-statep p)
               (p-neg-int-okp (p-current-instruction p)
                              p))
          (r-neg-int-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-lt-int-okp-implies-r-lt-int-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-int)
               (proper-p-statep p)
               (p-lt-int-okp (p-current-instruction p)
                             p))
          (r-lt-int-okp (p-current-instruction p)
                        (p->r p))))

(prove-lemma p-int-to-nat-okp-implies-r-int-to-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'int-to-nat)
               (proper-p-statep p)
               (p-int-to-nat-okp (p-current-instruction p)
                             p))
          (r-int-to-nat-okp (p-current-instruction p)
                        (p->r p))))

(prove-lemma p-add-nat-okp-implies-r-add-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat)
               (proper-p-statep p)
               (p-add-nat-okp (p-current-instruction p)
                              p))
          (r-add-nat-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-sub-nat-okp-implies-r-sub-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat)
               (proper-p-statep p)
               (p-sub-nat-okp (p-current-instruction p)
                              p))
          (r-sub-nat-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-sub-nat-with-carry-okp-implies-r-sub-nat-with-carry-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat-with-carry)
               (proper-p-statep p)
               (p-sub-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (r-sub-nat-with-carry-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma p-sub1-nat-okp-implies-r-sub1-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-nat)
               (proper-p-statep p)
               (p-sub1-nat-okp (p-current-instruction p)
                               p))
          (r-sub1-nat-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-lt-nat-okp-implies-r-lt-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-nat)
               (proper-p-statep p)
               (p-lt-nat-okp (p-current-instruction p)
                             p))
          (r-lt-nat-okp (p-current-instruction p)
                        (p->r p))))

(prove-lemma p-mult2-nat-okp-implies-r-mult2-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat)
               (proper-p-statep p)
               (p-mult2-nat-okp (p-current-instruction p)
                                p))
          (r-mult2-nat-okp (p-current-instruction p)
                           (p->r p))))

(prove-lemma p-div2-nat-okp-implies-r-div2-nat-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'div2-nat)
               (proper-p-statep p)
               (p-div2-nat-okp (p-current-instruction p)
                               p))
          (r-div2-nat-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-or-bitv-okp-implies-r-or-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bitv)
               (proper-p-statep p)
               (p-or-bitv-okp (p-current-instruction p)
                              p))
          (r-or-bitv-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-and-bitv-okp-implies-r-and-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bitv)
               (proper-p-statep p)
               (p-and-bitv-okp (p-current-instruction p)
                               p))
          (r-and-bitv-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-not-bitv-okp-implies-r-not-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bitv)
               (proper-p-statep p)
               (p-not-bitv-okp (p-current-instruction p)
                               p))
          (r-not-bitv-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-xor-bitv-okp-implies-r-xor-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'xor-bitv)
               (proper-p-statep p)
               (p-xor-bitv-okp (p-current-instruction p)
                               p))
          (r-xor-bitv-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-rsh-bitv-okp-implies-r-rsh-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'rsh-bitv)
               (proper-p-statep p)
               (p-rsh-bitv-okp (p-current-instruction p)
                               p))
          (r-rsh-bitv-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-lsh-bitv-okp-implies-r-lsh-bitv-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lsh-bitv)
               (proper-p-statep p)
               (p-lsh-bitv-okp (p-current-instruction p)
                               p))
          (r-lsh-bitv-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-or-bool-okp-implies-r-or-bool-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bool)
               (proper-p-statep p)
               (p-or-bool-okp (p-current-instruction p)
                              p))
          (r-or-bool-okp (p-current-instruction p)
                         (p->r p))))

(prove-lemma p-and-bool-okp-implies-r-and-bool-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bool)
               (proper-p-statep p)
               (p-and-bool-okp (p-current-instruction p)
                               p))
          (r-and-bool-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-not-bool-okp-implies-r-not-bool-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bool)
               (proper-p-statep p)
               (p-not-bool-okp (p-current-instruction p)
                               p))
          (r-not-bool-okp (p-current-instruction p)
                          (p->r p))))

(prove-lemma p-jump-if-temp-stk-full-okp-implies-r-jump-if-temp-stk-full-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-full)
               (proper-p-statep p)
               (p-jump-if-temp-stk-full-okp (p-current-instruction p)
                                            p))
          (r-jump-if-temp-stk-full-okp
           (p-current-instruction p)
           (p->r p))))

(prove-lemma p-jump-if-temp-stk-empty-okp-implies-r-jump-if-temp-stk-empty-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-empty)
               (proper-p-statep p)
               (p-jump-if-temp-stk-empty-okp (p-current-instruction p)
                                             p))
          (r-jump-if-temp-stk-empty-okp
           (p-current-instruction p)
           (p->r p)))
 ((enable empty-stkp)))

(prove-lemma p-test-nat-and-jump-okp-implies-r-test-nat-and-jump-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-nat-and-jump)
               (proper-p-statep p)
               (p-test-nat-and-jump-okp (p-current-instruction p)
                                        p))
          (r-test-nat-and-jump-okp (p-current-instruction p)
                                   (p->r p))))

(prove-lemma p-test-int-and-jump-okp-implies-r-test-int-and-jump-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-int-and-jump)
               (proper-p-statep p)
               (p-test-int-and-jump-okp (p-current-instruction p)
                                        p))
          (r-test-int-and-jump-okp (p-current-instruction p)
                                   (p->r p))))

(prove-lemma p-test-bool-and-jump-okp-implies-r-test-bool-and-jump-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bool-and-jump)
               (proper-p-statep p)
               (p-test-bool-and-jump-okp (p-current-instruction p)
                                         p))
          (r-test-bool-and-jump-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma p-test-bitv-and-jump-okp-implies-r-test-bitv-and-jump-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bitv-and-jump)
               (proper-p-statep p)
               (p-test-bitv-and-jump-okp (p-current-instruction p)
                                         p))
          (r-test-bitv-and-jump-okp (p-current-instruction p)
                                    (p->r p))))

(prove-lemma p-pop-locn-okp-implies-r-pop-locn-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-locn)
               (proper-p-statep p)
               (p-pop-locn-okp (p-current-instruction p)
                               p))
          (r-pop-locn-okp (p-current-instruction p)
                          (p->r p)))
 ((disable p-ctrl-stk-size)))

(prove-lemma p-locn-okp-implies-r-locn-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'locn)
               (proper-p-statep p)
               (p-locn-okp (p-current-instruction p)
                           p))
          (r-locn-okp (p-current-instruction p)
                      (p->r p))))

(prove-lemma p-jump-case-okp-implies-r-jump-case-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-case)
               (proper-p-statep p)
               (p-jump-case-okp (p-current-instruction p)
                                p))
          (r-jump-case-okp (p-current-instruction p)
                           (p->r p))))

(prove-lemma proper-p-temp-var-dclsp-implies-all-p-objectps (rewrite)
  (implies (proper-p-temp-var-dclsp temp-var-dcls p)
           (all-p-objectps (strip-cadrs temp-var-dcls) p)))
 
(prove-lemma all-p-objectps-implies-all-r-objectps (rewrite)
  (implies (and (all-p-objectps lst p)
                (same-signature r-usr-data-segment
                                (p-data-segment p)))
           (all-r-objectps lst (r-state r-pc r-cfp r-csp r-tsp
                                        r-x r-y r-c-flg r-v-flg r-n-flg r-z-flg
                                        (p-prog-segment p)
                                        r-usr-data-segment
                                        r-sys-data-segment
                                        (p-word-size p)
                                        r-psw))))

(prove-lemma p-call-okp-implies-r-call-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'call)
               (proper-p-statep p)
               (p-call-okp (p-current-instruction p)
                           p))
          (r-call-okp (p-current-instruction p)
                      (p->r p)))
 ((enable p->r_ctrl-stk)
  (disable p-ctrl-stk-size
           p->r_ctrl-stk1
           p->r_ctrl-stk1-opener)))

(prove-lemma p-pop-call-okp-implies-r-pop-call-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-call)
               (proper-p-statep p)
               (p-pop-call-okp (p-current-instruction p)
                               p))
          (r-pop-call-okp (p-current-instruction p)
                          (p->r p)))
  ((enable p->r_ctrl-stk difference-sub1)
   (disable nat-0s
            p-ctrl-stk-size
            p->r_ctrl-stk1
            p->r_ctrl-stk1-opener)))

(prove-lemma p-ret-okp-implies-r-ret-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'ret)
               (proper-p-statep p)
               (p-ret-okp (p-current-instruction p)
                          p))
          (r-ret-okp (p-current-instruction p)
                     (p->r p)))
 ((expand (p-ctrl-stk-size (p-ctrl-stk p)))
  (disable p-ctrl-stk-size)
  (enable empty-stkp)))

; We now turn to the preservation of r-equal.  Our basic strategy is to
; disable r-equal after proving rewrite rules that let us convert
; terms involving r2 to terms involving r1 under the hyp that r2 is
; r-equal to r1.  Then we will force open the r-equal in the conclusion
; of our theorems by an r-equal-r-state lemma below.  We begin with
; the very basic r-equal properties:

(prove-lemma r-equal-properties (rewrite)
 (implies (r-equal r2 r1)
          (and (r-statep r2)
               (r-statep r1)
               (equal (r-pc r2) (r-pc r1))
               (equal (r-cfp r2) (r-cfp r1))
               (equal (r-csp r2) (r-csp r1))
               (equal (r-tsp r2) (r-tsp r1))
               (equal (r-prog-segment r2)
                      (r-prog-segment r1))
               (equal (r-usr-data-segment r2)
                      (r-usr-data-segment r1))
               (stk-equal (r-csp r1)
                          (r-sys-data-segment r2)
                          (r-sys-data-segment r1))
               (stk-equal (r-tsp r1)
                          (r-sys-data-segment r2)
                          (r-sys-data-segment r1))
               (same-signature (r-sys-data-segment r2)
                               (r-sys-data-segment r1))
               (equal (r-word-size r2)
                      (r-word-size r1))
               (equal (r-psw r2) (r-psw r1)))))

(prove-lemma r-equal-r-state (rewrite)
  (equal (r-equal (r-state r-pc2
                           r-cfp2
                           r-csp2
                           r-tsp2
                           r-x2
                           r-y2
                           r-c-flg2
                           r-v-flg2
                           r-n-flg2
                           r-z-flg2
                           r-prog-segment
                           r-usr-data-segment2
                           r-sys-data-segment2
                           r-word-size
                           r-psw)
                  (r-state r-pc1
                           r-cfp1
                           r-csp1
                           r-tsp1
                           r-x1
                           r-y1
                           r-c-flg1
                           r-v-flg1
                           r-n-flg1
                           r-z-flg1
                           r-prog-segment
                           r-usr-data-segment1
                           r-sys-data-segment1
                           r-word-size
                           r-psw))
         (and
          (equal r-pc2 r-pc1)
          (equal r-cfp2 r-cfp1)
          (equal r-csp2 r-csp1)
          (equal r-tsp2 r-tsp1)
          (equal r-usr-data-segment2
                 r-usr-data-segment1)
          (stk-equal r-csp1
                     r-sys-data-segment2
                     r-sys-data-segment1)
          (stk-equal r-tsp1
                     r-sys-data-segment2
                     r-sys-data-segment1)
          (same-signature r-sys-data-segment2
                          r-sys-data-segment1))))

(disable r-equal)

(prove-lemma r-equal-implies-equal-r-current-instruction (rewrite)
  (implies (r-equal r2 r1)
           (equal (r-current-instruction r2)
                  (r-current-instruction r1)))
  ((enable r-current-instruction)))

; We adopt the same policy for handling proper-r-statep that we adopted
; at the r-i level:

(enable proper-r-statep-properties)

; Note: Unfortunately, the above remark is wrong, as I discovered much
; later below where I have to prove
; proper-r-statep-properties{augmented}.  The two statements of
; proper-r-statep-properties (in r-i.events and p-r.events) are NOT
; the same!

; Having proved that, we will

(disable proper-r-statep)

(prove-lemma r-equal-implies-equal-add1-r-pcp (rewrite)
  (implies (r-equal r2 r1)
           (equal (add1-r-pcp r2)
                  (add1-r-pcp r1))))

(disable add1-r-pcp)

; We need to enable empty-stkp.  The reason is that the r-equal in our
; hypothesis tells us that the tstk, say, in both r1 and r2 are stk-equal,
; but that implies the equality of the live parts only down to the empty-stk.
; It does not assure us that both stacks have the '(NAT 0) at the bottom.
; But all of our tests just insure that when we get at n in the stack,
; n is less than the length of the stack.  We now need to know that it is
; less than sub1 the length of the stack, so we're within the range checked
; by the stk-equal.  That assurance is given only by the empty-stkp.

(enable empty-stkp)

(prove-lemma r-equal-implies-equal-r-no-op-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                       'no-op)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal (r-no-op-okp (r-current-instruction r1) r2)
                  (r-no-op-okp (r-current-instruction r1) r1))))

(prove-lemma no-op-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'no-op)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-no-op-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-no-op-step (r-current-instruction r1) r2)
            (r-no-op-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-global-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-global-okp (r-current-instruction r1) r2)
            (r-push-global-okp (r-current-instruction r1) r1))))

; The following lemma is the key to obtaining the stk-equal on the cstk
; in cases where the cstk is not being modified.

(prove-lemma stk-equal-cstk-put-assoc-tstk2 (rewrite)
  (implies (equal (car (untag csp)) 'cstk)
           (equal (stk-equal csp
                             (put-assoc val2 'tstk segment2)
                             (put-assoc val1 'tstk segment1))
                  (stk-equal csp segment2 segment1)))
  ((enable stk-equal)
   (induct (stk-equal csp segment2 segment1))))

; And now we turn to the key lemma for the stk-equal on the tstk.
; The lemma, stk-equal-put-assoc-push, below, is general enough to apply
; to the cstk as well, if it is being pushed.

(prove-lemma get-put{special} (rewrite)
  (implies (and (numberp k)
                (numberp n)
                (lessp n (length lst)))
           (equal (get k (put val n lst))
                  (if (equal k n) val (get k lst))))
  ((enable get put)))

; The following lemma is the inductive part of the main theorem,
; named stk-equal-put-assoc-push, below.  The form of the main
; theorem is discussed there.

(prove-lemma stk-equal-put-assoc-above-top (rewrite)
  (implies (and (equal name (car (untag sp)))
                (definedp name segment1)
                (definedp name segment2)
                (numberp (cdr (untag sp)))
                (numberp n)
                (lessp n (cdr (untag sp)))
                (equal (length area1) (length (cdr (assoc name segment1))))
                (equal (length area2) (length (cdr (assoc name segment2))))
                (lessp n (sub1 (length area1)))
                (lessp n (sub1 (length area2))))
           (equal (stk-equal sp
                             (put-assoc (put val n area2)
                                        name segment2)
                             (put-assoc (put val n area1)
                                        name segment1))
                  (stk-equal sp
                             (put-assoc area2 name segment2)
                             (put-assoc area1 name segment1))))
((induct (stk-equal sp segment2 segment1))
 (enable stk-equal empty-stkp)))


(prove-lemma equal-sub1-difference (rewrite)
  (equal (equal 0 (sub1 (difference max n)))
         (not (lessp n (sub1 max))))
  ((enable difference)))

; This is the main theorem for dealing with stk-equality on two
; stacks that have been pushed.  The lemma says, roughly, that if
; you are interested in stack equality from sp on down, and you
; just deposited equal things at sp, then pop and omit the deposits.

; But the lemma is more general that that suggests.  Consider
; the use of area1 and area2.  My first version of the lemma
; used (cdr (assoc name segmenti)) for areai.
; That limited the utility of the lemma to cases in which
; only one thing is pushed.  This version permits areai to be another
; put.  Observe that on the rhs of the lemma I omite the puts but I
; keep the put-assocs because I have to put the areai's into the
; segments.

(prove-lemma stk-equal-put-assoc-push (rewrite)
  (implies (and (listp (untag sp))
                (equal name (car (untag sp)))
                (definedp name segment1)
                (definedp name segment2)
                (equal n (cdr (untag sp)))
                (numberp n)
                (equal (length area1) (length (cdr (assoc name segment1))))
                (equal (length area2) (length (cdr (assoc name segment2))))
                (not (empty-stkp (tag 'sys-addr
                                      (cons name n))
                                 segment1))
                (not (empty-stkp (tag 'sys-addr
                                      (cons name n))
                                 segment2)))
           (equal
            (stk-equal sp
                       (put-assoc (put val
                                       n
                                       area2)
                                  name
                                  segment2)
                       (put-assoc (put val
                                       n
                                       area1)
                                  name
                                  segment1))

            (stk-equal (pop-stk sp)
                       (put-assoc area2 name segment2)
                       (put-assoc area1 name segment1))))
    ((enable empty-stkp)
     (expand (stk-equal sp
                        (put-assoc (put val
                                        (cdr (untag sp))
                                        area2)
                                   (car (untag sp))
                                   segment2)
                        (put-assoc (put val
                                        (cdr (untag sp))
                                        area1)
                                   (car (untag sp))
                                   segment1)))))

; Eventually, when all the puts are exhausted we will be putting
; the original area into the segment and the following rule will
; collapse it:

(prove-lemma put-assoc-cdr-assoc (rewrite)
  (implies (listp (assoc name segment))
           (equal (put-assoc (cdr (assoc name segment)) name segment)
                  segment)))

; However, to get the hypothesis above we need:

(prove-lemma proper-r-statep-implies-tstkp nil
  (implies (proper-r-statep r load-addr)
           (lessp (cdr (untag (r-tsp r)))
                  (length (cdr (assoc 'tstk
                                      (r-sys-data-segment r)))))))

(prove-lemma listp-assoc-tstk (rewrite)
  (implies (proper-r-statep r load-addr)
           (listp (assoc 'tstk (r-sys-data-segment r))))
  ((use (proper-r-statep-implies-tstkp))))

; Finally, in the main theorem above we sometimes have to prove a
; non-empty-stkp of a pushed stack, which follows from the non-emptiness
; of the unpushed stack:

(prove-lemma not-empty-stkp-push{special} (rewrite)
  (implies (not (empty-stkp (tag 'sys-addr (cons name n)) segment))
           (not (empty-stkp (tag 'sys-addr (cons name (sub1 n))) segment)))
  ((enable empty-stkp)))

; The next lemma establishes that if we have a stk-equal at n
; we have it at all greater n.  This means that if we pop several
; things off the stack and then push one, the lemma above will take
; care of the push and the lemma below will take care of the pops.

(prove-lemma stk-equal-extends-upwards-base-case (rewrite)
  (implies (and (not (lessp n (sub1 (length (cdr (assoc name segment2))))))
                (numberp n)
                (numberp k)
                (not (lessp k n)))
           (stk-equal (tag 'sys-addr (cons name k))
                      segment2 segment1))
  ((expand (stk-equal (tag 'sys-addr (cons name k))
                      segment2 segment1))))

(defn stk-equal-hint-5 (n name segment)
      (if (zerop (sub1 (difference (length (cdr (assoc name segment)))
                                   n)))
          t
          (stk-equal-hint-5 (plus n 1) name segment))
      ((lessp (sub1 (difference (length (cdr (assoc name segment)))
                                n)))))

; The next lemma is really the key result.  However, as stated it is
; not useful as a rewrite rule because it has the free-var segment1
; picked up by the stk-equal but in our applications the stk-equal is
; enclosed inside the r-equal we keep disabled.  This pattern will be
; repeated many times in the lemma development here.

(prove-lemma stk-equal-extends-upwards nil
  (implies (and (numberp n)
                (numberp k)
                (stk-equal (tag 'sys-addr (cons name n)) segment2 segment1)
                (not (lessp k n)))
           (stk-equal (tag 'sys-addr (cons name k)) segment2 segment1))
  ((induct (stk-equal-hint-5 n name segment2))
   (enable stk-equal)))

(disable stk-equal-extends-upwards-base-case)

(prove-lemma proper-r-statep-implies-tag-untag (rewrite)
 (implies (and (equal (type x) 'sys-addr)
               (listp (untag x))
               (equal (car (untag x))
                      'tstk)
               (equal (cddr x) nil))
          (equal (tag 'sys-addr (cons 'tstk (cdr (untag x))))
                 x))
 ((enable tag type untag)))

; When this proper-r-statep-properties was proved in r-i.events it had some
; adp-name and other fns "closed".  But when it was proved in p-r.events I
; had expanded those names.  I did not notice this when I concatenated the two
; event lists and removed "duplicates"  -- i.e., I mistook the second occurrence
; of the name proper-r-statep-properties as a duplicate of the first when in fact
; the formulas were different by virtue of these non-rec fn expansions.  So here
; I prove the expanded conjuncts.

(prove-lemma proper-r-statep-properties{augmented} (rewrite)
  (implies (proper-r-statep r load-addr)
   (and
    (definedp (car (untag (r-pc r)))
              (r-prog-segment r))
    (numberp (cdr (untag (r-pc r))))
    (lessp (cdr (untag (r-pc r)))
           (length (program-body (assoc (car (untag (r-pc r)))
                                        (r-prog-segment r)))))
    (equal (car (untag (r-cfp r)))
           'cstk)
    (numberp (cdr (untag (r-cfp r))))
    (lessp (cdr (untag (r-cfp r)))
           (length (cdr (assoc 'cstk
                               (r-sys-data-segment r)))))

    (equal (car (untag (r-csp r)))
           'cstk)
    (numberp (cdr (untag (r-csp r))))
    (lessp (cdr (untag (r-csp r)))
           (length (cdr (assoc 'cstk
                               (r-sys-data-segment r)))))
    (equal (car (untag (r-tsp r)))
           'tstk)
    (numberp (cdr (untag (r-tsp r))))
    (lessp (cdr (untag (r-tsp r)))
           (length (cdr (assoc 'tstk
                               (r-sys-data-segment r)))))
    (definedp 'full-ctrl-stk-addr
              (r-sys-data-segment r))
    (definedp 'full-temp-stk-addr
              (r-sys-data-segment r))
    (definedp 'empty-temp-stk-addr
              (r-sys-data-segment r))))
  ((use (proper-r-statep-properties))
   (enable type LISTP-ASSOC-IMPLIES-DEFINEDP)
   (disable proper-r-statep-properties
            exp SEGMENT-LENGTH PLUS 
            PROPER-R-USR-DATA-SEGMENTP FETCH-ADP ADPP
            ASSOC LENGTH LESSP DEFINEDP)))

(prove-lemma r-equal-implies-stk-equal-extends-upwards-tstk (rewrite)
  (implies (and (r-equal r2 r1)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (numberp k)
                (not (lessp k (cdr (untag (r-tsp r1))))))
           (stk-equal (tag 'sys-addr (cons 'tstk k))
                      (r-sys-data-segment r2)
                      (r-sys-data-segment r1)))
  ((use (stk-equal-extends-upwards (n (cdr (untag (r-tsp r1))))
                                   (segment1 (r-sys-data-segment r1))
                                   (segment2 (r-sys-data-segment r2))
                                   (name 'tstk)))
   (enable r-equal)))

; So now we can do 

(prove-lemma push-global-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-global-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-global-step (r-current-instruction r1) r2)
            (r-push-global-step (r-current-instruction r1) r1))))

; We will keep empty-stkp disabled to cut down on the arithmetic
; used.  Of course, we need:

(prove-lemma r-equal-implies-equal-length (rewrite)
  (implies (r-equal r2 r1)
           (equal (length (cdr (assoc name (r-sys-data-segment r2))))
                  (length (cdr (assoc name (r-sys-data-segment r1))))))
  ((disable same-signature-implies-equal-lengths)
   (use (same-signature-implies-equal-lengths
         (segment1 (r-sys-data-segment r2))
         (segment2 (r-sys-data-segment r1))))))

(prove-lemma r-equal-implies-equal-empty-stkp (rewrite)
  (implies (r-equal r2 r1)
           (equal (empty-stkp sp (r-sys-data-segment r2))
                  (empty-stkp sp (r-sys-data-segment r1)))))

; The next two lemmas establish that when we get from the active
; region of either the cstk or the tstk of two r-equal states
; we get the same result.  The key fact is the lemma immediately
; below, which is then instantiated for each stack and lifted up
; to r-equal.  

(prove-lemma stk-equal-implies-equal-get nil
  (implies (and (stk-equal sp segment2 segment1)
                (numberp k)
                (numberp (cdr (untag sp)))
                (not (lessp k (cdr (untag sp))))
                (lessp k (sub1
                          (length (cdr (assoc (car (untag sp))
                                              segment2))))))
           (equal (get k (cdr (assoc (car (untag sp)) segment2)))
                  (get k (cdr (assoc (car (untag sp)) segment1)))))
  ((induct (stk-equal sp segment2 segment1))
   (enable stk-equal)))

; The instantiated versions of the lemma above requires that we know
; the stack pointer at which we are getting is non-empty.

(prove-lemma r-equal-implies-equal-get-tstk (rewrite)
  (implies (and (r-equal r2 r1)
                (proper-r-statep r1 load-addr)
                (numberp k)
                (not (empty-stkp (tag 'sys-addr
                                      (cons 'tstk k))
                                 (r-sys-data-segment r1)))
                (not (lessp k (cdr (untag (r-tsp r1))))))
           (equal (get k (cdr (assoc 'tstk (r-sys-data-segment r2))))
                  (get k (cdr (assoc 'tstk (r-sys-data-segment r1))))))
  ((use (stk-equal-implies-equal-get
         (sp (r-tsp r1))
         (segment1 (r-sys-data-segment r1))
         (segment2 (r-sys-data-segment r2))))))

; We don't actually need the cstk version just yet, but I have proved
; it because when we get to local vars we will need it.

(prove-lemma r-equal-implies-equal-get-cstk (rewrite)
  (implies (and (r-equal r2 r1)
                (proper-r-statep r1 load-addr)
                (numberp k)
                (not (empty-stkp (tag 'sys-addr
                                      (cons 'cstk k))
                                 (r-sys-data-segment r1)))
                (not (lessp k (cdr (untag (r-csp r1))))))
           (equal (get k (cdr (assoc 'cstk (r-sys-data-segment r2))))
                  (get k (cdr (assoc 'cstk (r-sys-data-segment r1))))))
  ((use (stk-equal-implies-equal-get
         (sp (r-csp r1))
         (segment1 (r-sys-data-segment r1))
         (segment2 (r-sys-data-segment r2))))))

; We now disable empty-stkp.  We will undoubtedly have to prove some
; lemmas to establish the non-empty-stkp hypotheses above.

(disable empty-stkp)  

; In the case where we are getting from r-tsp we need:




; We need that the r-objects of one state are those of the other.

(prove-lemma r-equal-implies-equal-r-objectp (rewrite)
  (implies (r-equal r2 r1)
           (equal (r-objectp x r2)
                  (r-objectp x r1)))
  ((disable same-signature-implies-equal-definedp)
   (use (same-signature-implies-equal-definedp
         (name (car (untag x)))
         (segment1 (r-sys-data-segment r2))
         (segment2 (r-sys-data-segment r1)))) 
   (expand (r-objectp x r2)
           (r-objectp x r1))))

; We also get the rule for r-objectp-type and disable that function
; because here we do not need to know what it means, just that if
; it is true for r2 it is true for r1.

(prove-lemma r-equal-implies-equal-r-objectp-type (rewrite)
  (implies (r-equal r2 r1)
           (equal (r-objectp-type type x r2)
                  (r-objectp-type type x r1))))

(disable r-objectp-type)

; And we'll get the rule for r-usr-data-objectp too.

(prove-lemma r-equal-implies-equal-r-usr-data-objectp (rewrite)
  (implies (r-equal r2 r1)
           (equal (r-usr-data-objectp x r2)
                  (r-usr-data-objectp x r1))))

(disable r-usr-data-objectp)

; Now we can also handle:

(prove-lemma r-equal-implies-equal-r-pop-global-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop-global-okp (r-current-instruction r1) r2)
            (r-pop-global-okp (r-current-instruction r1) r1))))

(prove-lemma pop-global-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop-global-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop-global-step (r-current-instruction r1) r2)
            (r-pop-global-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-local-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-local-okp (r-current-instruction r1) r2)
            (r-push-local-okp (r-current-instruction r1) r1))))

; To prove a stk-equal after a push we have to be able to establish
; the non-empty-stkp hypothesis for the pushed stack.  That follows
; from:

(prove-lemma proper-r-statep-implies-non-empty-stkp-push (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (not (zerop (free-stk-size (r-tsp r)))))
           (not (empty-stkp (tag 'sys-addr
                                 (cons 'tstk
                                       (sub1 (cdr (untag (r-tsp r))))))
                            (r-sys-data-segment r))))
             ((enable empty-stkp)))

(prove-lemma push-local-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-local-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-local-step (r-current-instruction r1) r2)
            (r-push-local-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-pop-local-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop-local-okp (r-current-instruction r1) r2)
            (r-pop-local-okp (r-current-instruction r1) r1))))

; That we could get to here without further work is not too surprising
; considering the nature of the instructions we've learned to handle.
; That we stopped here is also not surprising: we haven't explained
; how to handle stk-equal on the cstk (except in the rare case of
; pushes onto the cstk).  What we need is the lemma that says if two
; cstks are stk-equal and you put the same thing at the same place in
; both then they are still stk-equal.  This is sort of like the
; stk-equal-put-assoc-push lemma above except (a) we don't require
; that the put be a push and because of that (b) we don't require that
; the stk-equal start its scan at the location of the push.  This
; operation, of sticking something into the middle of a stack, is of
; course only performed on the cstk; never on the tstk.

(prove-lemma stk-equal-put-assoc-insertion (rewrite)
  (implies (and (listp (untag sp))
                (stk-equal sp segment2 segment1)
                (equal name (car (untag sp)))
                (definedp name segment2)
                (definedp name segment1)
                (numberp (cdr (untag sp)))
                (numberp n)
                (not (lessp n (cdr (untag sp))))
                (not (empty-stkp (tag 'sys-addr
                                      (cons name n))
                                 segment2))
                (not (empty-stkp (tag 'sys-addr
                                      (cons name n))
                                 segment1))
                (listp (assoc name segment1))
                (listp (assoc name segment2)))
           (stk-equal sp
                      (put-assoc (put val
                                      n
                                      (cdr (assoc name segment2)))
                                 name
                                 segment2)
                      (put-assoc (put val
                                      n
                                      (cdr (assoc name segment1)))
                                 name
                                 segment1)))
  ((induct (stk-equal sp segment2 segment1))
   (enable stk-equal empty-stkp)))
                                      
; The hypotheses above about (listp (assoc name segmenti)) will
; be relieved in our applications by:

(prove-lemma proper-r-statep-implies-cstkp nil
  (implies (proper-r-statep r load-addr)
           (lessp (cdr (untag (r-csp r)))
                  (length (cdr (assoc 'cstk
                                      (r-sys-data-segment r)))))))

(prove-lemma listp-assoc-cstk (rewrite)
  (implies (proper-r-statep r load-addr)
           (listp (assoc 'cstk (r-sys-data-segment r))))
  ((use (proper-r-statep-implies-cstkp))))

; The following rule is the dual of its namesake: it establishes a
; stk-equal on the tstk when the cstk has been changed.

(prove-lemma stk-equal-tstk-put-assoc-cstk2 (rewrite)
  (implies (equal (car (untag tsp)) 'tstk)
           (equal (stk-equal tsp
                             (put-assoc val2 'cstk segment2)
                             (put-assoc val1 'cstk segment1))
                  (stk-equal tsp segment2 segment1)))
  ((enable stk-equal empty-stkp)
   (induct (stk-equal tsp segment2 segment1))))

; The following lemma is needed to relieve the hypothesis that we are
; putting into a legal position.  This would not be necessary if we
; had empty-stkp enabled.

(prove-lemma empty-stkp-backchainer (rewrite)
  (implies (not (empty-stkp (tag xxx (cons name k)) segment))
           (equal (lessp k (length (cdr (assoc name segment))))
                  t))
  ((enable empty-stkp)))

(prove-lemma pop-local-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop-local-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop-local-step (r-current-instruction r1) r2)
            (r-pop-local-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-deposit-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'deposit)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-deposit-okp (r-current-instruction r1) r2)
            (r-deposit-okp (r-current-instruction r1) r1))))

(prove-lemma deposit-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'deposit)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-deposit-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-deposit-step (r-current-instruction r1) r2)
            (r-deposit-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add1-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add1-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add1-nat-okp (r-current-instruction r1) r2)
            (r-add1-nat-okp (r-current-instruction r1) r1))))

(prove-lemma add1-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add1-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add1-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add1-nat-step (r-current-instruction r1) r2)
            (r-add1-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add-addr-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add-addr-okp (r-current-instruction r1) r2)
            (r-add-addr-okp (r-current-instruction r1) r1))))

(prove-lemma add-addr-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add-addr-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add-addr-step (r-current-instruction r1) r2)
            (r-add-addr-step (r-current-instruction r1) r1))))

; The following lemma is a good example of the value of tuning
; the disable/enable strategy.  In an environment just like
; the current one except with empty-stkp enabled and the
; necessary rule that (sub1 (sub1 (difference x y))) = 0
; iff y is not lessp x-2, the following theorem took 67 seconds
; to prove and 118 seconds for io.  It now takes 3.8 to prove
; and .1 for io.  The reason is that when empty-stkp opens
; and is converted to an inequality, the linear arithmetic
; package repeatedly splits on various zerop possibilities.

(prove-lemma r-equal-implies-equal-r-add-nat-with-carry-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-nat-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add-nat-with-carry-okp (r-current-instruction r1) r2)
            (r-add-nat-with-carry-okp (r-current-instruction r1) r1))))

(prove-lemma add-nat-with-carry-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-nat-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add-nat-with-carry-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add-nat-with-carry-step (r-current-instruction r1) r2)
            (r-add-nat-with-carry-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-mult2-nat-with-carry-out-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'mult2-nat-with-carry-out)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-mult2-nat-with-carry-out-okp (r-current-instruction r1) r2)
            (r-mult2-nat-with-carry-out-okp (r-current-instruction r1) r1))))

(prove-lemma mult2-nat-with-carry-out-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'mult2-nat-with-carry-out)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-mult2-nat-with-carry-out-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-mult2-nat-with-carry-out-step (r-current-instruction r1) r2)
            (r-mult2-nat-with-carry-out-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-fetch-temp-stk-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'fetch-temp-stk)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-fetch-temp-stk-okp (r-current-instruction r1) r2)
            (r-fetch-temp-stk-okp (r-current-instruction r1) r1))))

; To relieve the hypothesis of R-EQUAL-IMPLIES-EQUAL-GET-TSTK we need:

(prove-lemma not-empty-stkp-temp-stk-index (rewrite)
  (implies (lessp n
                  (sub1 (length
                         (cdr (assoc 'tstk
                                     (r-sys-data-segment r))))))
           (not (empty-stkp
                 (tag 'sys-addr
                      (cons 'tstk
                            (sub1
                             (difference
                              (sub1 (length
                                     (cdr (assoc 'tstk
                                                 (r-sys-data-segment r)))))
                              n))))
                            (r-sys-data-segment r))))
  ((enable empty-stkp)))

(prove-lemma fetch-temp-stk-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'fetch-temp-stk)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-fetch-temp-stk-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-fetch-temp-stk-step (r-current-instruction r1) r2)
            (r-fetch-temp-stk-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-deposit-temp-stk-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'deposit-temp-stk)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-deposit-temp-stk-okp (r-current-instruction r1) r2)
            (r-deposit-temp-stk-okp (r-current-instruction r1) r1))))

(prove-lemma deposit-temp-stk-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'deposit-temp-stk)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-deposit-temp-stk-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-deposit-temp-stk-step (r-current-instruction r1) r2)
            (r-deposit-temp-stk-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-pop*-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop*)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop*-okp (r-current-instruction r1) r2)
            (r-pop*-okp (r-current-instruction r1) r1))))

(prove-lemma pop*-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop*)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop*-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop*-step (r-current-instruction r1) r2)
            (r-pop*-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-popn-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'popn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-popn-okp (r-current-instruction r1) r2)
            (r-popn-okp (r-current-instruction r1) r1))))

(prove-lemma popn-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'popn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-popn-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-popn-step (r-current-instruction r1) r2)
            (r-popn-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-set-local-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'set-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-set-local-okp (r-current-instruction r1) r2)
            (r-set-local-okp (r-current-instruction r1) r1))))

(prove-lemma set-local-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'set-local)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-set-local-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-set-local-step (r-current-instruction r1) r2)
            (r-set-local-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-set-global-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'set-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-set-global-okp (r-current-instruction r1) r2)
            (r-set-global-okp (r-current-instruction r1) r1))))

(prove-lemma set-global-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'set-global)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-set-global-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-set-global-step (r-current-instruction r1) r2)
            (r-set-global-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-constant-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-constant)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-constant-okp (r-current-instruction r1) r2)
            (r-push-constant-okp (r-current-instruction r1) r1))))

(prove-lemma push-constant-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-constant)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-constant-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-constant-step (r-current-instruction r1) r2)
            (r-push-constant-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-ctrl-stk-free-size-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-ctrl-stk-free-size)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-ctrl-stk-free-size-okp (r-current-instruction r1) r2)
            (r-push-ctrl-stk-free-size-okp (r-current-instruction r1) r1))))

(prove-lemma push-ctrl-stk-free-size-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-ctrl-stk-free-size)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-ctrl-stk-free-size-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-ctrl-stk-free-size-step (r-current-instruction r1) r2)
            (r-push-ctrl-stk-free-size-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-temp-stk-free-size-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-temp-stk-free-size)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-temp-stk-free-size-okp (r-current-instruction r1) r2)
            (r-push-temp-stk-free-size-okp (r-current-instruction r1) r1))))

(prove-lemma push-temp-stk-free-size-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'push-temp-stk-free-size)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-temp-stk-free-size-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-temp-stk-free-size-step (r-current-instruction r1) r2)
            (r-push-temp-stk-free-size-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-push-temp-stk-index-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                       'push-temp-stk-index)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-push-temp-stk-index-okp (r-current-instruction r1) r2)
            (r-push-temp-stk-index-okp (r-current-instruction r1) r1))))

(prove-lemma push-temp-stk-index-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                       'push-temp-stk-index)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-push-temp-stk-index-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-push-temp-stk-index-step (r-current-instruction r1) r2)
            (r-push-temp-stk-index-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-pop-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop-okp (r-current-instruction r1) r2)
            (r-pop-okp (r-current-instruction r1) r1))))

(prove-lemma pop-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop-step (r-current-instruction r1) r2)
            (r-pop-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-jump-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-jump-okp (r-current-instruction r1) r2)
            (r-jump-okp (r-current-instruction r1) r1))))

(prove-lemma jump-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-jump-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-jump-step (r-current-instruction r1) r2)
            (r-jump-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-pushj-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pushj)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pushj-okp (r-current-instruction r1) r2)
            (r-pushj-okp (r-current-instruction r1) r1))))

(prove-lemma pushj-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pushj)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pushj-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pushj-step (r-current-instruction r1) r2)
            (r-pushj-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-popj-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'popj)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-popj-okp (r-current-instruction r1) r2)
            (r-popj-okp (r-current-instruction r1) r1))))

(prove-lemma popj-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'popj)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-popj-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-popj-step (r-current-instruction r1) r2)
            (r-popj-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub-addr-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub-addr-okp (r-current-instruction r1) r2)
            (r-sub-addr-okp (r-current-instruction r1) r1))))

(prove-lemma sub-addr-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub-addr-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub-addr-step (r-current-instruction r1) r2)
            (r-sub-addr-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-eq-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'eq)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-eq-okp (r-current-instruction r1) r2)
            (r-eq-okp (r-current-instruction r1) r1))))

(prove-lemma eq-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'eq)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-eq-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-eq-step (r-current-instruction r1) r2)
            (r-eq-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-lt-addr-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-lt-addr-okp (r-current-instruction r1) r2)
            (r-lt-addr-okp (r-current-instruction r1) r1))))

(prove-lemma lt-addr-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-addr)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-lt-addr-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-lt-addr-step (r-current-instruction r1) r2)
            (r-lt-addr-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-fetch-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'fetch)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-fetch-okp (r-current-instruction r1) r2)
            (r-fetch-okp (r-current-instruction r1) r1))))

(prove-lemma fetch-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'fetch)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-fetch-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-fetch-step (r-current-instruction r1) r2)
            (r-fetch-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add-int-okp (r-current-instruction r1) r2)
            (r-add-int-okp (r-current-instruction r1) r1))))

(prove-lemma add-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add-int-step (r-current-instruction r1) r2)
            (r-add-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add-int-with-carry-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-int-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add-int-with-carry-okp (r-current-instruction r1) r2)
            (r-add-int-with-carry-okp (r-current-instruction r1) r1))))

(prove-lemma add-int-with-carry-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-int-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add-int-with-carry-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add-int-with-carry-step (r-current-instruction r1) r2)
            (r-add-int-with-carry-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add1-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add1-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add1-int-okp (r-current-instruction r1) r2)
            (r-add1-int-okp (r-current-instruction r1) r1))))

(prove-lemma add1-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add1-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add1-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add1-int-step (r-current-instruction r1) r2)
            (r-add1-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub-int-okp (r-current-instruction r1) r2)
            (r-sub-int-okp (r-current-instruction r1) r1))))

(prove-lemma sub-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub-int-step (r-current-instruction r1) r2)
            (r-sub-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub-int-with-carry-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-int-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub-int-with-carry-okp (r-current-instruction r1) r2)
            (r-sub-int-with-carry-okp (r-current-instruction r1) r1))))

(prove-lemma sub-int-with-carry-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-int-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub-int-with-carry-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub-int-with-carry-step (r-current-instruction r1) r2)
            (r-sub-int-with-carry-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub1-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub1-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub1-int-okp (r-current-instruction r1) r2)
            (r-sub1-int-okp (r-current-instruction r1) r1))))

(prove-lemma sub1-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub1-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub1-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub1-int-step (r-current-instruction r1) r2)
            (r-sub1-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-neg-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'neg-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-neg-int-okp (r-current-instruction r1) r2)
            (r-neg-int-okp (r-current-instruction r1) r1))))

(prove-lemma neg-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'neg-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-neg-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-neg-int-step (r-current-instruction r1) r2)
            (r-neg-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-lt-int-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-lt-int-okp (r-current-instruction r1) r2)
            (r-lt-int-okp (r-current-instruction r1) r1))))

(prove-lemma lt-int-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-int)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-lt-int-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-lt-int-step (r-current-instruction r1) r2)
            (r-lt-int-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-int-to-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'int-to-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-int-to-nat-okp (r-current-instruction r1) r2)
            (r-int-to-nat-okp (r-current-instruction r1) r1))))

(prove-lemma int-to-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'int-to-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-int-to-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-int-to-nat-step (r-current-instruction r1) r2)
            (r-int-to-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-add-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-add-nat-okp (r-current-instruction r1) r2)
            (r-add-nat-okp (r-current-instruction r1) r1))))

(prove-lemma add-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'add-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-add-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-add-nat-step (r-current-instruction r1) r2)
            (r-add-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub-nat-okp (r-current-instruction r1) r2)
            (r-sub-nat-okp (r-current-instruction r1) r1))))

(prove-lemma sub-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub-nat-step (r-current-instruction r1) r2)
            (r-sub-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub-nat-with-carry-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-nat-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub-nat-with-carry-okp (r-current-instruction r1) r2)
            (r-sub-nat-with-carry-okp (r-current-instruction r1) r1))))

(prove-lemma sub-nat-with-carry-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub-nat-with-carry)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub-nat-with-carry-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub-nat-with-carry-step (r-current-instruction r1) r2)
            (r-sub-nat-with-carry-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-sub1-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub1-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-sub1-nat-okp (r-current-instruction r1) r2)
            (r-sub1-nat-okp (r-current-instruction r1) r1))))

(prove-lemma sub1-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'sub1-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-sub1-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-sub1-nat-step (r-current-instruction r1) r2)
            (r-sub1-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-lt-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-lt-nat-okp (r-current-instruction r1) r2)
            (r-lt-nat-okp (r-current-instruction r1) r1))))

(prove-lemma lt-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lt-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-lt-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-lt-nat-step (r-current-instruction r1) r2)
            (r-lt-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-mult2-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'mult2-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-mult2-nat-okp (r-current-instruction r1) r2)
            (r-mult2-nat-okp (r-current-instruction r1) r1))))

(prove-lemma mult2-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'mult2-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-mult2-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-mult2-nat-step (r-current-instruction r1) r2)
            (r-mult2-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-div2-nat-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'div2-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-div2-nat-okp (r-current-instruction r1) r2)
            (r-div2-nat-okp (r-current-instruction r1) r1))))

(prove-lemma div2-nat-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'div2-nat)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-div2-nat-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-div2-nat-step (r-current-instruction r1) r2)
            (r-div2-nat-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-or-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'or-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-or-bitv-okp (r-current-instruction r1) r2)
            (r-or-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma or-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'or-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-or-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-or-bitv-step (r-current-instruction r1) r2)
            (r-or-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-and-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'and-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-and-bitv-okp (r-current-instruction r1) r2)
            (r-and-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma and-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'and-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-and-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-and-bitv-step (r-current-instruction r1) r2)
            (r-and-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-not-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'not-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-not-bitv-okp (r-current-instruction r1) r2)
            (r-not-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma not-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'not-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-not-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-not-bitv-step (r-current-instruction r1) r2)
            (r-not-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-xor-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'xor-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-xor-bitv-okp (r-current-instruction r1) r2)
            (r-xor-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma xor-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'xor-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-xor-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-xor-bitv-step (r-current-instruction r1) r2)
            (r-xor-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-rsh-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'rsh-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-rsh-bitv-okp (r-current-instruction r1) r2)
            (r-rsh-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma rsh-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'rsh-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-rsh-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-rsh-bitv-step (r-current-instruction r1) r2)
            (r-rsh-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-lsh-bitv-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lsh-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-lsh-bitv-okp (r-current-instruction r1) r2)
            (r-lsh-bitv-okp (r-current-instruction r1) r1))))

(prove-lemma lsh-bitv-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'lsh-bitv)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-lsh-bitv-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-lsh-bitv-step (r-current-instruction r1) r2)
            (r-lsh-bitv-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-or-bool-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'or-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-or-bool-okp (r-current-instruction r1) r2)
            (r-or-bool-okp (r-current-instruction r1) r1))))

(prove-lemma or-bool-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'or-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-or-bool-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-or-bool-step (r-current-instruction r1) r2)
            (r-or-bool-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-and-bool-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'and-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-and-bool-okp (r-current-instruction r1) r2)
            (r-and-bool-okp (r-current-instruction r1) r1))))

(prove-lemma and-bool-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'and-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-and-bool-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-and-bool-step (r-current-instruction r1) r2)
            (r-and-bool-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-not-bool-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'not-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-not-bool-okp (r-current-instruction r1) r2)
            (r-not-bool-okp (r-current-instruction r1) r1))))

(prove-lemma not-bool-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'not-bool)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-not-bool-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-not-bool-step (r-current-instruction r1) r2)
            (r-not-bool-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-jump-if-temp-stk-full-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-if-temp-stk-full)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-jump-if-temp-stk-full-okp (r-current-instruction r1) r2)
            (r-jump-if-temp-stk-full-okp (r-current-instruction r1) r1))))

(prove-lemma jump-if-temp-stk-full-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-if-temp-stk-full)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-jump-if-temp-stk-full-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-jump-if-temp-stk-full-step (r-current-instruction r1) r2)
            (r-jump-if-temp-stk-full-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-jump-if-temp-stk-empty-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-if-temp-stk-empty)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-jump-if-temp-stk-empty-okp (r-current-instruction r1) r2)
            (r-jump-if-temp-stk-empty-okp (r-current-instruction r1) r1))))

(prove-lemma jump-if-temp-stk-empty-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-if-temp-stk-empty)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-jump-if-temp-stk-empty-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-jump-if-temp-stk-empty-step (r-current-instruction r1) r2)
            (r-jump-if-temp-stk-empty-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-test-nat-and-jump-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-nat-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-test-nat-and-jump-okp (r-current-instruction r1) r2)
            (r-test-nat-and-jump-okp (r-current-instruction r1) r1))))

(prove-lemma test-nat-and-jump-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-nat-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-test-nat-and-jump-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-test-nat-and-jump-step (r-current-instruction r1) r2)
            (r-test-nat-and-jump-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-test-int-and-jump-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-int-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-test-int-and-jump-okp (r-current-instruction r1) r2)
            (r-test-int-and-jump-okp (r-current-instruction r1) r1))))

(prove-lemma test-int-and-jump-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-int-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-test-int-and-jump-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-test-int-and-jump-step (r-current-instruction r1) r2)
            (r-test-int-and-jump-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-test-bool-and-jump-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-bool-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-test-bool-and-jump-okp (r-current-instruction r1) r2)
            (r-test-bool-and-jump-okp (r-current-instruction r1) r1))))

(prove-lemma test-bool-and-jump-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-bool-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-test-bool-and-jump-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-test-bool-and-jump-step (r-current-instruction r1) r2)
            (r-test-bool-and-jump-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-test-bitv-and-jump-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-bitv-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-test-bitv-and-jump-okp (r-current-instruction r1) r2)
            (r-test-bitv-and-jump-okp (r-current-instruction r1) r1))))

(prove-lemma test-bitv-and-jump-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'test-bitv-and-jump)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-test-bitv-and-jump-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-test-bitv-and-jump-step (r-current-instruction r1) r2)
            (r-test-bitv-and-jump-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-pop-locn-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-locn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop-locn-okp (r-current-instruction r1) r2)
            (r-pop-locn-okp (r-current-instruction r1) r1)))
 ((disable p-ctrl-stk-size)))

(prove-lemma pop-locn-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-locn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop-locn-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop-locn-step (r-current-instruction r1) r2)
            (r-pop-locn-step (r-current-instruction r1) r1)))
 ((disable p-ctrl-stk-size)))

(prove-lemma r-equal-implies-equal-r-locn-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'locn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-locn-okp (r-current-instruction r1) r2)
            (r-locn-okp (r-current-instruction r1) r1))))

(prove-lemma locn-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'locn)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-locn-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-locn-step (r-current-instruction r1) r2)
            (r-locn-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-jump-case-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-case)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-jump-case-okp (r-current-instruction r1) r2)
            (r-jump-case-okp (r-current-instruction r1) r1))))

(prove-lemma jump-case-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'jump-case)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-jump-case-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-jump-case-step (r-current-instruction r1) r2)
            (r-jump-case-step (r-current-instruction r1) r1))))

; To do call, we need:

(prove-lemma r-equal-implies-equal-all-r-objectps (rewrite)
  (implies (r-equal r2 r1)
           (equal (all-r-objectps lst r2)
                  (all-r-objectps lst r1))))

(prove-lemma r-equal-implies-equal-r-call-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'call)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-call-okp (r-current-instruction r1) r2)
            (r-call-okp (r-current-instruction r1) r1))))

; Now we start working on call-step itself:

; There are two main problems.  The first is that the machine fetches the
; same actuals from each of the two states.  This is a generalization of
; r-equal-implies-equal-get-tstk.

(defn stk-equal-fetch-n-hint (n sp segment2)
  (if (zerop n)
      t
      (if (lessp (sub1 (length (cdr (assoc (car (untag sp)) segment2))))
                 (cdr (untag sp)))
          t
          (stk-equal-fetch-n-hint (sub1 n) (pop-stk sp) segment2))))

(prove-lemma stk-equal-implies-equal-fetch-n nil
  (implies (and (listp (untag sp))
                (stk-equal sp segment2 segment1)
                (not (lessp (stk-length sp segment2)
                            n)))
           (equal (fetch-n n sp segment2)
                  (fetch-n n sp segment1)))
  ((enable stk-equal empty-stkp)
   (induct (stk-equal-fetch-n-hint n sp segment2))))

(prove-lemma r-equal-implies-equal-fetch-n-call (rewrite)
  (implies (and (r-equal r2 r1)
                (listp (untag (r-tsp r1)))
                (not (lessp (stk-length (r-tsp r1)
                                        (r-sys-data-segment r1))
                            n)))
           (equal (fetch-n n (r-tsp r1) (r-sys-data-segment r2))
                  (fetch-n n (r-tsp r1) (r-sys-data-segment r1))))
  ((use (stk-equal-implies-equal-fetch-n
         (sp (r-tsp r1))
         (segment1 (r-sys-data-segment r1))
         (segment2 (r-sys-data-segment r2))))))

; The second problem is proving that deposit-lst produces stk-equal
; stacks.

; There may be an easier way to do this, but I don't see it.  My
; plan is to replace deposit-lst by deposit-lst1, which runs down
; the list in the reverse order and does the put-assocs on the outside
; of its recursion.  This function, which we prove equivalent to
; deposit-lst, is easier for stk-equal to handle because each time
; it recurses it kicks out a put-assoc for the stk-equal to eat.

(defn deposit-lst1 (lst name n segment)
  (if (nlistp lst)
      segment
      (put-assoc (put (car lst)
                      n
                      (cdr (assoc name
                                  (deposit-lst1 (cdr lst)
                                                name
                                                (add1 n)
                                                segment))))
                 name
                 segment)))

; To prove deposit-lst is deposit-lst1 we need to make explicit the
; relation with append because the main theorem involves reverse:

(prove-lemma deposit-lst1-append (rewrite)
  (implies (numberp n)
           (equal (deposit-lst1 (append a (list x)) name n segment)
                  (deposit-lst1 a
                                name
                                n
                                (put-assoc (put x
                                                (plus n (length a))
                                                (cdr (assoc name segment)))
                                           name
                                           segment))))

  ((enable difference-sub1)
   (induct (deposit-lst1 a name n segment))))

(prove-lemma plus-difference{special} (rewrite)
  (implies (not (lessp x y))
           (equal (plus y (difference x y))
                  (fix x))))

; So here is the equivalence of the two versions of deposit-lst.

(prove-lemma deposit-lst-equal-deposit-lst1 (rewrite)
  (implies (and (numberp (cdr (untag sp)))
                (not (lessp (cdr (untag sp)) (sub1 (length lst)))))
           (equal (deposit-lst lst sp segment)
                  (deposit-lst1 (rev lst)
                                (car (untag sp))
                                (difference (cdr (untag sp))
                                            (sub1 (length lst)))
                                segment)))
  ((enable difference)
   (induct (deposit-lst lst sp segment))))

; Now I am headed for the theorem that says that if you have
; two stk-equal segments then the result of doing deposit-lst is
; stk-equal.  In the proof deposit-lst will be replaced, as above,
; by deposit-lst1, and then I will use arithmetic, including

(enable difference-elim)
(enable difference-elim-rewrite)

; and

(prove-lemma difference-sub1-plus-etc (rewrite)
  (implies (and (numberp v)
                (listp lst))
           (equal (difference (sub1 (plus v (length lst)))
                              (sub1 (length lst)))
                  v)))

; to reduce the stk-equal-deposit-lst-generalized theorem to an instance of
; stk-equal-deposit-lst1, below.  By the way, the order of the
; actuals, whether reversed or not, is unimportant here; i.e., the
; reverse introduced above is now simply generalized away.

; The proof of stk-equal-deposit-lst1 relies on stk-equal-put-assoc-push
; to eat each put-assoc kicked out by deposit-lst1.  We need to relieve
; the hypotheses of the -push lemma:

(prove-lemma length-cdr-assoc-deposit-lst1 (rewrite)
  (implies (and (definedp name segment)
                (not (lessp (length (cdr (assoc name segment)))
                            (plus n (length lst)))))
           (equal (length (cdr (assoc name
                                      (deposit-lst1 lst
                                                    name
                                                    n
                                                    segment))))
                  (length (cdr (assoc name segment))))))

; In the main theorem to which we are heading, we have tag, type, and
; untag enabled.  We therefore need to state this lemma in terms of list
; rather than tag, and enable the accessors.  We explain below.

(prove-lemma room-to-deposit-lst-implies-not-empty-stkp  (rewrite)
  (implies (lessp (plus n (length (cdr lst)))
                  (sub1 (length (cdr (assoc name segment1)))))
           (not (empty-stkp (list 'sys-addr (cons name n))
                            segment1)))
  ((enable empty-stkp tag type untag)))

; After we relieve the hyps we need to simplify the rhs.  Recall that
; the rhs of the stk-equal-put-assoc-push lemma says that you continue
; the stk-equal at the next higher position after put-associng the
; name with the list into which you did the put.  In our case, the
; list into which we did the put is obtained by associng for
; the name in the result of the continued deposit-lst1.  In any case,
; the identity we need is this:

(prove-lemma stk-equal-put-assoc-cdr-assoc (rewrite)
  (implies (and (numberp n)
                (definedp name old-segment1)
                (definedp name old-segment2))
           (equal (stk-equal (list sys-addr (cons name n))
                             (put-assoc (cdr (assoc name segment1))
                                        name
                                        old-segment1)
                             (put-assoc (cdr (assoc name segment2))
                                        name
                                        old-segment2))
                  (stk-equal (list sys-addr (cons name n))
                             segment1
                             segment2)))
  ((induct (stk-equal-hint-5 n name segment1))
   (enable stk-equal empty-stkp tag type untag)))

; This is the key result for stk-equal and deposit-lst1.  The lemma is
; a little unusual in having sys-addr as a variable.  Most of the time
; we've used the constant 'sys-addr.  The reason we used a variable
; this time is just that in the lemma we are headed for,
; stk-equal-deposit-lst-generalized, we don't bother to say that
; sp-init is a sys-addr address.

(prove-lemma stk-equal-deposit-lst1 (rewrite)
  (implies (and (numberp n)
                (definedp name segment2)
                (lessp (plus n (length lst))
                       (length (cdr (assoc name segment2))))
                (definedp name segment1)
                (lessp (plus n (length lst))
                       (length (cdr (assoc name segment1))))
                (not (lessp (plus n (length lst))
                            (length lst)))
                (stk-equal (list sys-addr
                                (cons name (plus n (length lst))))
                           segment2 segment1))
           (stk-equal (list sys-addr (cons name n))
                      (deposit-lst1 lst
                                    name n segment2)
                      (deposit-lst1 lst
                                    name n segment1)))
  ((enable tag type untag)))

; Here is the main theorem about stk-equal and deposit-lst.  As noted, the
; proof involves an elim to get rid of the difference introduced when we
; trade deposit-lst for deposit-lst1.  That elim also introduces conses for
; sp-init, below, and so we need to enable type and untag so they compute on
; conses.  That is why the lemma development above used list instead of tag
; everywhere.  The lemma is of lemma class nil because we need to instantiate
; it later to derive the actual rewrite rule we need.

(prove-lemma stk-equal-deposit-lst-generalized nil
  (implies (and (equal (cddr sp-init) nil)
                (addressp sp-init segment2)
                (addressp sp-init segment1)
                (not (lessp (free-stk-size sp-init)
                            (length lst)))
                (stk-equal sp-init
                           segment2
                           segment1))
           (stk-equal (push-stk-n (length lst) sp-init)
                      (deposit-lst lst
                                    (push-stk sp-init)
                                   segment2)
                      (deposit-lst lst
                                   (push-stk sp-init)
                                   segment1)))
  ((enable tag type untag)))

; We now disable the things we introduced just for this proof.

(disable deposit-lst-equal-deposit-lst1)
(disable difference-elim)
(disable difference-sub1-plus-etc)
(disable room-to-deposit-lst-implies-not-empty-stkp)

(prove-lemma stk-equal-deposit-lst (rewrite)
  (implies (and (equal n-final (difference n-init (length lst)))
                (definedp 'cstk segment2)
                (definedp 'cstk segment1)
                (numberp n-init)
                (not (lessp n-init (length lst)))
                (lessp n-init (length (cdr (assoc 'cstk segment2))))
                (lessp n-init (length (cdr (assoc 'cstk segment1))))
                (stk-equal (tag 'sys-addr (cons 'cstk n-init))
                           segment2
                           segment1))
           (stk-equal (tag 'sys-addr (cons 'cstk n-final))
                      (deposit-lst lst
                                   (tag 'sys-addr (cons 'cstk (sub1 n-init)))
                                   segment2)
                      (deposit-lst lst
                                   (tag 'sys-addr (cons 'cstk (sub1 n-init)))
                                   segment1)))
  ((use (stk-equal-deposit-lst-generalized
         (sp-init (tag 'sys-addr (cons 'cstk n-init)))))))
                        

; Returning now to the consideration of call itself and the stk-equality
; on the new cstks, the theorem above reduces (actually backchains) the
; problem to one of the stk-equality after the first pushes of the old fp
; and ret-pc.  The following lemma establishes that the stack on which
; we're pushing is non-empty and allows the famous stk-equal-put-assoc-push
; to handle those two pushes:

(prove-lemma not-empty-stkp-push-csp (rewrite)
 (implies (and (proper-r-statep r load-addr)
               (lessp n (cdr (untag (r-csp r)))))
          (not (empty-stkp (tag 'sys-addr (cons 'cstk n))
                           (r-sys-data-segment r))))
 ((enable empty-stkp)))

; We are finally left with the stk-equality of the two cstks below the
; new frame.  That is given to us, except that we have torn the csp
; apart with all the stuff above and need to put it back together:

(prove-lemma proper-r-statep-implies-tag-untag-cstk (rewrite)
  (implies (and (equal (type x) 'sys-addr)
                (equal (car (untag x)) 'cstk)
                (equal (cddr x) nil))
           (equal (tag 'sys-addr (cons 'cstk (cdr (untag x)))) x))
  ((enable tag type untag)))

; This completes the argument that the new cstks are stk-equal.

; We now turn to the stk-equality of the new tstks.

; The only observation we need to make is that the deposit-lst on the
; cstk does not affect the question of stk-equality on the tstk.  Then
; the knowledge that stk-equal extends upwards will handle things for
; us.

; The strategy is the same as before: replace deposit-lst with
; deposit-lst1 and appeal to the simple theorem about deposit-lst1:

(prove-lemma stk-equal-tstk-deposit-lst1-cstk (rewrite)
  (equal (stk-equal (tag 'sys-addr (cons 'tstk n))
                    (deposit-lst1 lst
                                  'cstk
                                  k
                                  segment2)
                    (deposit-lst1 lst
                                  'cstk
                                  k
                                  segment1))
         (stk-equal (tag 'sys-addr (cons 'tstk n))
                    segment2
                    segment1)))

; So here is the result we needed for the stk-equality on the tstk:

(prove-lemma stk-equal-tstk-deposit-lst-cstk (rewrite)
  (implies (and (equal (car (untag csp)) 'cstk)
                (numberp (cdr (untag csp)))
                (not (lessp (cdr (untag csp)) (sub1 (length lst)))))
           (equal (stk-equal (tag 'sys-addr (cons 'tstk n))
                             (deposit-lst lst
                                          csp
                                          segment2)
                             (deposit-lst lst
                                          csp
                                          segment1))
                  (stk-equal (tag 'sys-addr (cons 'tstk n))
                             segment2
                             segment1)))
  ((enable deposit-lst-equal-deposit-lst1)))

; The last thing we have to handle is the same-signature of the new
; sys-data-segments.  We use deposit-lst1 again.

(prove-lemma same-signature-deposit-lst1 (rewrite)
  (implies (and (litatom name)
                (definedp name segment1)
                (definedp name segment2)
                (not (lessp (length (cdr (assoc name segment1)))
                            (plus n (length lst))))
                (not (lessp (length (cdr (assoc name segment2)))
                            (plus n (length lst)))))
           (equal (same-signature (deposit-lst1 lst name n segment2)
                                  (deposit-lst1 lst name n segment1))
                  (same-signature segment2 segment1))))

(prove-lemma same-signature-deposit-lst{special} (rewrite)
  (implies (and (litatom (car (untag csp)))
                (definedp (car (untag csp)) segment1)
                (definedp (car (untag csp)) segment2)
                (numberp (cdr (untag csp)))
                (not (lessp (cdr (untag csp)) (sub1 (length lst))))
                (lessp (cdr (untag csp))
                       (length (cdr (assoc (car (untag csp)) segment1))))
                (lessp (cdr (untag csp))
                       (length (cdr (assoc (car (untag csp)) segment2)))))
           (equal (same-signature
                             (deposit-lst lst
                                          csp
                                          segment2)
                             (deposit-lst lst
                                          csp
                                          segment1))
                  (same-signature
                             segment2
                             segment1)))
  ((disable plus)
   (enable deposit-lst-equal-deposit-lst1)))

; And that completes the r-equal work for call!

(prove-lemma call-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'call)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-call-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-call-step (r-current-instruction r1) r2)
            (r-call-step (r-current-instruction r1) r1))))

; In order to reduce the pop-call case to call, we need to
; explain that the fake state created by pop-call does not
; affect the tests we make:

(prove-lemma r-objectp-on-pop-call-state (rewrite)
  (implies (and (equal (r-prog-segment r) r-prog-segment)
                (equal (r-usr-data-segment r) r-usr-data-segment)
                (equal (r-word-size r) r-word-size))
           (equal (r-objectp x
                             (r-state r-pc
                                      r-cfp
                                      r-csp
                                      r-tsp
                                      r-x
                                      r-y
                                      r-c-flg
                                      r-v-flg
                                      r-n-flg
                                      r-z-flg
                                      r-prog-segment
                                      r-usr-data-segment
                                      (r-sys-data-segment r)
                                      r-word-size
                                      r-psw))
                  (r-objectp x r)))
  ((enable r-objectp)))

(prove-lemma all-r-objectps-on-pop-call-state (rewrite)
  (implies (and (equal (r-prog-segment r) r-prog-segment)
                (equal (r-usr-data-segment r) r-usr-data-segment)
                (equal (r-word-size r) r-word-size))
           (equal (all-r-objectps lst
                                  (r-state r-pc
                                           r-cfp
                                           r-csp
                                           r-tsp
                                           r-x
                                           r-y
                                           r-c-flg
                                           r-v-flg
                                           r-n-flg
                                           r-z-flg
                                           r-prog-segment
                                           r-usr-data-segment
                                           (r-sys-data-segment r)
                                           r-word-size
                                           r-psw))
                  (all-r-objectps lst r))))

(prove-lemma add1-r-pcp-on-pop-call-state (rewrite)
  (implies (and (equal (r-prog-segment r) r-prog-segment)
                (equal (r-pc r) r-pc))
           (equal (add1-r-pcp
                   (r-state r-pc 
                            r-cfp
                            r-csp
                            r-tsp
                            r-x
                            r-y
                            r-c-flg
                            r-v-flg
                            r-n-flg
                            r-z-flg
                            r-prog-segment
                            r-usr-data-segment
                            (r-sys-data-segment r)
                            r-word-size
                            r-psw))
                  (add1-r-pcp r)))
  ((enable add1-r-pcp)))
         
(prove-lemma r-equal-implies-equal-r-pop-call-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-call)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-pop-call-okp (r-current-instruction r1) r2)
            (r-pop-call-okp (r-current-instruction r1) r1))))

; Recall the lemma r-equal-implies-equal-fetch-n-call.  It rewrites
; (fetch-n n (r-tsp r1) (r-sys-data-segment r2)).  That will not
; do for pop-call because instead of (r-tsp r1) we are interested
; in (pop-stk (r-tsp r1)), with the pop-stk expanded.  So we
; prove a slightly different version:

; The proper-r-statep hypothesis added below is necessary to
; insure that (tag 'sys-addr (cons 'tstk (cdr (untag (r-tsp r1)))))
; is in fact (r-tsp r1).

(prove-lemma r-equal-implies-equal-fetch-n-pop-call (rewrite)
  (implies (and (r-equal r2 r1)
                (proper-r-statep r1 load-addr)
                (listp (untag (r-tsp r1)))
                (not (lessp
                      (stk-length
                       (tag 'sys-addr
                            (cons 'tstk
                                  (add1 (cdr (untag (r-tsp r1))))))
                       (r-sys-data-segment r1))
                      n)))
           (equal (fetch-n n
                           (tag 'sys-addr
                                (cons 'tstk
                                      (add1 (cdr (untag (r-tsp r1))))))
                           (r-sys-data-segment r2))
                  (fetch-n n
                           (tag 'sys-addr
                                (cons 'tstk
                                      (add1 (cdr (untag (r-tsp r1))))))
                           (r-sys-data-segment r1))))
  ((use (stk-equal-extends-upwards
          (n (cdr (untag (r-tsp r1))))
          (k (add1 (cdr (untag (r-tsp r1)))))
          (name 'tstk)
          (segment1 (r-sys-data-segment r1))
          (segment2 (r-sys-data-segment r2)))
        (stk-equal-implies-equal-fetch-n
         (sp (tag 'sys-addr
                  (cons 'tstk
                        (add1 (cdr (untag (r-tsp r1)))))))
         (segment1 (r-sys-data-segment r1))
         (segment2 (r-sys-data-segment r2))))))

(prove-lemma pop-call-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'pop-call)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-pop-call-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-pop-call-step (r-current-instruction r1) r2)
            (r-pop-call-step (r-current-instruction r1) r1))))

(prove-lemma r-equal-implies-equal-r-ret-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'ret)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal
            (r-ret-okp (r-current-instruction r1) r2)
            (r-ret-okp (r-current-instruction r1) r1))))

; Needless to say, on ret we need to know that the stk-equality
; on the cstk extends upwards too.  Previously we had proved it
; only for the tstk.

(prove-lemma r-equal-implies-stk-equal-extends-upwards-cstk (rewrite)
  (implies (and (r-equal r2 r1)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (numberp k)
                (not (lessp k (cdr (untag (r-csp r1))))))
           (stk-equal (tag 'sys-addr (cons 'cstk k))
                      (r-sys-data-segment r2)
                      (r-sys-data-segment r1)))
  ((use (stk-equal-extends-upwards (n (cdr (untag (r-csp r1))))
                                   (segment1 (r-sys-data-segment r1))
                                   (segment2 (r-sys-data-segment r2))
                                   (name 'cstk)))
   (enable r-equal)))

; And we need to know about r-halt:

(prove-lemma r-equal-implies-r-equal-r-halt (rewrite)
  (implies (r-equal r2 r1)
           (r-equal (r-halt r2 r-psw)
                    (r-halt r1 r-psw)))
  ((enable r-equal r-halt)))

(prove-lemma ret-preserves-r-equal (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (equal (car (r-current-instruction r1))
                      'ret)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-ret-okp (r-current-instruction r1) r2)
                (r-equal r2 r1))
           (r-equal
            (r-ret-step (r-current-instruction r1) r2)
            (r-ret-step (r-current-instruction r1) r1))))

; We also have to prove that p-loadablep is preserved by p-step.
; We do it in the expected way, beginning with the individual
; instruction steppers.

(prove-lemma no-op-preserves-p-loadablep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                      'no-op)
                (proper-p-statep p)
                (p-loadablep p load-addr)
                (p-no-op-okp (p-current-instruction p) p))
           (p-loadablep
            (p-no-op-step (p-current-instruction p) p)
            load-addr)))

(prove-lemma push-global-preserves-p-loadablep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-global)
                (proper-p-statep p)
                (p-loadablep p load-addr)
                (p-push-global-okp (p-current-instruction p)
                                   p))
           (p-loadablep
            (p-push-global-step (p-current-instruction p)
                                p)
            load-addr)))

(prove-lemma pop-global-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-global)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop-global-okp (p-current-instruction p)
                                 p))
          (p-loadablep
           (p-pop-global-step (p-current-instruction p)
                              p)
           load-addr)))

(prove-lemma push-local-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-local)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-push-local-okp (p-current-instruction p)
                                 p))
          (p-loadablep
           (p-push-local-step (p-current-instruction p)
                              p)
           load-addr)))

(prove-lemma pop-local-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-local)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop-local-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-pop-local-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma deposit-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-deposit-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-deposit-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma add1-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add1-nat-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-add1-nat-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma add-addr-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-addr)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add-addr-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-add-addr-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma add-nat-with-carry-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat-with-carry)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-add-nat-with-carry-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma mult2-nat-with-carry-out-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat-with-carry-out)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-mult2-nat-with-carry-out-okp (p-current-instruction p)
                                               p))
          (p-loadablep
           (p-mult2-nat-with-carry-out-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma fetch-temp-stk-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch-temp-stk)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-fetch-temp-stk-okp (p-current-instruction p)
                                               p))
          (p-loadablep
           (p-fetch-temp-stk-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma deposit-temp-stk-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'deposit-temp-stk)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-deposit-temp-stk-okp (p-current-instruction p)
                                               p))
          (p-loadablep
           (p-deposit-temp-stk-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma pop*-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop*)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop*-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-pop*-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma popn-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popn)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-popn-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-popn-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma set-local-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-local)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-set-local-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-set-local-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma set-global-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'set-global)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-set-global-okp (p-current-instruction p)
                                 p))
          (p-loadablep
           (p-set-global-step (p-current-instruction p)
                              p)
           load-addr)))

(prove-lemma push-constant-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-constant)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-push-constant-okp (p-current-instruction p)
                                    p))
          (p-loadablep
           (p-push-constant-step (p-current-instruction p)
                                 p)
           load-addr)))

(prove-lemma push-ctrl-stk-free-size-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-ctrl-stk-free-size)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-push-ctrl-stk-free-size-okp (p-current-instruction p)
                                              p))
          (p-loadablep
           (p-push-ctrl-stk-free-size-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma push-temp-stk-free-size-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-free-size)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-push-temp-stk-free-size-okp (p-current-instruction p)
                                              p))
          (p-loadablep
           (p-push-temp-stk-free-size-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma push-temp-stk-index-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'push-temp-stk-index)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-push-temp-stk-index-okp (p-current-instruction p)
                                          p))
          (p-loadablep
           (p-push-temp-stk-index-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma pop-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop-okp (p-current-instruction p)
                          p))
          (p-loadablep
           (p-pop-step (p-current-instruction p)
                       p)
           load-addr)))

(prove-lemma jump-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-jump-okp (p-current-instruction p)
                           p))
          (p-loadablep
           (p-jump-step (p-current-instruction p)
                        p)
           load-addr)))

(prove-lemma pushj-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pushj)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pushj-okp (p-current-instruction p)
                            p))
          (p-loadablep
           (p-pushj-step (p-current-instruction p)
                         p)
           load-addr)))

(prove-lemma popj-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'popj)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-popj-okp (p-current-instruction p)
                           p))
          (p-loadablep
           (p-popj-step (p-current-instruction p)
                        p)
           load-addr)))

(prove-lemma sub-addr-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-addr)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub-addr-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-sub-addr-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma eq-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'eq)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-eq-okp (p-current-instruction p)
                         p))
          (p-loadablep
           (p-eq-step (p-current-instruction p)
                      p)
           load-addr)))

(prove-lemma lt-addr-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-addr)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-lt-addr-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-lt-addr-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma fetch-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'fetch)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-fetch-okp (p-current-instruction p)
                            p))
          (p-loadablep
           (p-fetch-step (p-current-instruction p)
                         p)
           load-addr)))

(prove-lemma add-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add-int-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-add-int-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma add-int-with-carry-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-int-with-carry)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add-int-with-carry-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-add-int-with-carry-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma add1-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add1-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add1-int-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-add1-int-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma sub-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub-int-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-sub-int-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma sub-int-with-carry-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-int-with-carry)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub-int-with-carry-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-sub-int-with-carry-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma sub1-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub1-int-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-sub1-int-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma neg-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'neg-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-neg-int-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-neg-int-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma lt-int-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-int)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-lt-int-okp (p-current-instruction p)
                             p))
          (p-loadablep
           (p-lt-int-step (p-current-instruction p)
                          p)
           load-addr)))

(prove-lemma int-to-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'int-to-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-int-to-nat-okp (p-current-instruction p)
                             p))
          (p-loadablep
           (p-int-to-nat-step (p-current-instruction p)
                          p)
           load-addr)))

(prove-lemma add-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'add-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-add-nat-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-add-nat-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma sub-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub-nat-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-sub-nat-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma sub-nat-with-carry-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub-nat-with-carry)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub-nat-with-carry-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-sub-nat-with-carry-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma sub1-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'sub1-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-sub1-nat-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-sub1-nat-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma lt-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lt-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-lt-nat-okp (p-current-instruction p)
                             p))
          (p-loadablep
           (p-lt-nat-step (p-current-instruction p)
                          p)
           load-addr)))

(prove-lemma mult2-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'mult2-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-mult2-nat-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-mult2-nat-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma div2-nat-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'div2-nat)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-div2-nat-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-div2-nat-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma or-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-or-bitv-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-or-bitv-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma and-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-and-bitv-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-and-bitv-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma not-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-not-bitv-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-not-bitv-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma xor-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'xor-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-xor-bitv-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-xor-bitv-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma rsh-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'rsh-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-rsh-bitv-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-rsh-bitv-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma lsh-bitv-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'lsh-bitv)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-lsh-bitv-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-lsh-bitv-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma or-bool-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'or-bool)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-or-bool-okp (p-current-instruction p)
                              p))
          (p-loadablep
           (p-or-bool-step (p-current-instruction p)
                           p)
           load-addr)))

(prove-lemma and-bool-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'and-bool)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-and-bool-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-and-bool-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma not-bool-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'not-bool)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-not-bool-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-not-bool-step (p-current-instruction p)
                            p)
           load-addr)))

(prove-lemma jump-if-temp-stk-full-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-full)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-jump-if-temp-stk-full-okp (p-current-instruction p)
                                            p))
          (p-loadablep
           (p-jump-if-temp-stk-full-step
            (p-current-instruction p)
            p)
           load-addr)))

(prove-lemma jump-if-temp-stk-empty-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-if-temp-stk-empty)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-jump-if-temp-stk-empty-okp (p-current-instruction p)
                                             p))
          (p-loadablep
           (p-jump-if-temp-stk-empty-step
            (p-current-instruction p)
            p)
           load-addr))
 ((enable empty-stkp)))

(prove-lemma test-nat-and-jump-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-nat-and-jump)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-test-nat-and-jump-okp (p-current-instruction p)
                                        p))
          (p-loadablep
           (p-test-nat-and-jump-step (p-current-instruction p)
                                     p)
           load-addr)))

(prove-lemma test-int-and-jump-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-int-and-jump)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-test-int-and-jump-okp (p-current-instruction p)
                                        p))
          (p-loadablep
           (p-test-int-and-jump-step (p-current-instruction p)
                                     p)
           load-addr)))

(prove-lemma test-bool-and-jump-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bool-and-jump)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-test-bool-and-jump-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-test-bool-and-jump-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma test-bitv-and-jump-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'test-bitv-and-jump)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-test-bitv-and-jump-okp (p-current-instruction p)
                                         p))
          (p-loadablep
           (p-test-bitv-and-jump-step (p-current-instruction p)
                                      p)
           load-addr)))

(prove-lemma pop-locn-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-locn)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop-locn-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-pop-locn-step (p-current-instruction p)
                            p)
           load-addr))
 ((disable p-ctrl-stk-size p-ctrl-stk-size-cons-p-frame)))

(prove-lemma locn-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'locn)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-locn-okp (p-current-instruction p)
                           p))
          (p-loadablep
           (p-locn-step (p-current-instruction p)
                        p)
           load-addr)))

(prove-lemma jump-case-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'jump-case)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-jump-case-okp (p-current-instruction p)
                                p))
          (p-loadablep
           (p-jump-case-step (p-current-instruction p)
                             p)
           load-addr)))

(prove-lemma call-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'call)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-call-okp (p-current-instruction p)
                           p))
          (p-loadablep
           (p-call-step (p-current-instruction p)
                        p)
           load-addr))
 ((enable p->r_ctrl-stk)
  (disable p-ctrl-stk-size
           p->r_ctrl-stk1
           p->r_ctrl-stk1-opener)))

(prove-lemma pop-call-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'pop-call)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-pop-call-okp (p-current-instruction p)
                               p))
          (p-loadablep
           (p-pop-call-step (p-current-instruction p)
                            p)
           load-addr))
  ((enable p->r_ctrl-stk difference-sub1)
   (disable nat-0s
            p-ctrl-stk-size
            p->r_ctrl-stk1
            p->r_ctrl-stk1-opener)))

(prove-lemma ret-preserves-p-loadablep (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (equal (car (p-current-instruction p))
                      'ret)
               (proper-p-statep p)
               (p-loadablep p load-addr)
               (p-ret-okp (p-current-instruction p)
                          p))
          (p-loadablep
           (p-ret-step (p-current-instruction p)
                       p)
           load-addr))
 ((expand (p-ctrl-stk-size (p-ctrl-stk p)))
  (disable p-ctrl-stk-size proper-p-framep)
  (enable empty-stkp)))

; We now turn our attention to putting all these lemmas together to
; get the p-step and r-step versions of each.

(disable p-call-okp)
(disable p-call-step)
(disable p-ret-okp)
(disable p-ret-step)
(disable p-locn-okp)
(disable p-locn-step)
(disable p-push-constant-okp)
(disable p-push-constant-step)
(disable p-push-local-okp)
(disable p-push-local-step)
(disable p-push-global-okp)
(disable p-push-global-step)
(disable p-push-ctrl-stk-free-size-okp)
(disable p-push-ctrl-stk-free-size-step)
(disable p-push-temp-stk-free-size-okp)
(disable p-push-temp-stk-free-size-step)
(disable p-push-temp-stk-index-okp)
(disable p-push-temp-stk-index-step)
(disable p-jump-if-temp-stk-full-okp)
(disable p-jump-if-temp-stk-full-step)
(disable p-jump-if-temp-stk-empty-okp)
(disable p-jump-if-temp-stk-empty-step)
(disable p-pop-okp)
(disable p-pop-step)
(disable p-pop*-okp)
(disable p-pop*-step)
(disable p-popn-okp)
(disable p-popn-step)
(disable p-pop-local-okp)
(disable p-pop-local-step)
(disable p-pop-global-okp)
(disable p-pop-global-step)
(disable p-pop-locn-okp)
(disable p-pop-locn-step)
(disable p-pop-call-okp)
(disable p-pop-call-step)
(disable p-fetch-temp-stk-okp)
(disable p-fetch-temp-stk-step)
(disable p-deposit-temp-stk-okp)
(disable p-deposit-temp-stk-step)
(disable p-jump-okp)
(disable p-jump-step)
(disable p-jump-case-okp)
(disable p-jump-case-step)
(disable p-pushj-okp)
(disable p-pushj-step)
(disable p-popj-okp)
(disable p-popj-step)
(disable p-set-local-okp)
(disable p-set-local-step)
(disable p-set-global-okp)
(disable p-set-global-step)
(disable p-test-nat-and-jump-okp)
(disable p-test-nat-and-jump-step)
(disable p-test-int-and-jump-okp)
(disable p-test-int-and-jump-step)
(disable p-test-bool-and-jump-okp)
(disable p-test-bool-and-jump-step)
(disable p-test-bitv-and-jump-okp)
(disable p-test-bitv-and-jump-step)
(disable p-no-op-okp)
(disable p-no-op-step)
(disable p-add-addr-okp)
(disable p-add-addr-step)
(disable p-sub-addr-okp)
(disable p-sub-addr-step)
(disable p-eq-okp)
(disable p-eq-step)
(disable p-lt-addr-okp)
(disable p-lt-addr-step)
(disable p-fetch-okp)
(disable p-fetch-step)
(disable p-deposit-okp)
(disable p-deposit-step)
(disable p-add-int-okp)
(disable p-add-int-step)
(disable p-add-int-with-carry-okp)
(disable p-add-int-with-carry-step)
(disable p-add1-int-okp)
(disable p-add1-int-step)
(disable p-sub-int-okp)
(disable p-sub-int-step)
(disable p-sub-int-with-carry-okp)
(disable p-sub-int-with-carry-step)
(disable p-sub1-int-okp)
(disable p-sub1-int-step)
(disable p-neg-int-okp)
(disable p-neg-int-step)
(disable p-lt-int-okp)
(disable p-lt-int-step)
(disable p-int-to-nat-okp)
(disable p-int-to-nat-step)
(disable p-add-nat-okp)
(disable p-add-nat-step)
(disable p-add-nat-with-carry-okp)
(disable p-add-nat-with-carry-step)
(disable p-add1-nat-okp)
(disable p-add1-nat-step)
(disable p-sub-nat-okp)
(disable p-sub-nat-step)
(disable p-sub-nat-with-carry-okp)
(disable p-sub-nat-with-carry-step)
(disable p-sub1-nat-okp)
(disable p-sub1-nat-step)
(disable p-lt-nat-okp)
(disable p-lt-nat-step)
(disable p-mult2-nat-okp)
(disable p-mult2-nat-step)
(disable p-mult2-nat-with-carry-out-okp)
(disable p-mult2-nat-with-carry-out-step)
(disable p-div2-nat-okp)
(disable p-div2-nat-step)
(disable p-or-bitv-okp)
(disable p-or-bitv-step)
(disable p-and-bitv-okp)
(disable p-and-bitv-step)
(disable p-not-bitv-okp)
(disable p-not-bitv-step)
(disable p-xor-bitv-okp)
(disable p-xor-bitv-step)
(disable p-rsh-bitv-okp)
(disable p-rsh-bitv-step)
(disable p-lsh-bitv-okp)
(disable p-lsh-bitv-step)
(disable p-or-bool-okp)
(disable p-or-bool-step)
(disable p-and-bool-okp)
(disable p-and-bool-step)
(disable p-not-bool-okp)
(disable p-not-bool-step)

(disable r-call-okp)
(disable r-call-step)
(disable r-ret-okp)
(disable r-ret-step)
(disable r-locn-okp)
(disable r-locn-step)
(disable r-push-constant-okp)
(disable r-push-constant-step)
(disable r-push-local-okp)
(disable r-push-local-step)
(disable r-push-global-okp)
(disable r-push-global-step)
(disable r-push-ctrl-stk-free-size-okp)
(disable r-push-ctrl-stk-free-size-step)
(disable r-push-temp-stk-free-size-okp)
(disable r-push-temp-stk-free-size-step)
(disable r-push-temp-stk-index-okp)
(disable r-push-temp-stk-index-step)
(disable r-jump-if-temp-stk-full-okp)
(disable r-jump-if-temp-stk-full-step)
(disable r-jump-if-temp-stk-empty-okp)
(disable r-jump-if-temp-stk-empty-step)
(disable r-pop-okp)
(disable r-pop-step)
(disable r-pop*-okp)
(disable r-pop*-step)
(disable r-popn-okp)
(disable r-popn-step)
(disable r-pop-local-okp)
(disable r-pop-local-step)
(disable r-pop-global-okp)
(disable r-pop-global-step)
(disable r-pop-locn-okp)
(disable r-pop-locn-step)
(disable r-pop-call-okp)
(disable r-pop-call-step)
(disable r-fetch-temp-stk-okp)
(disable r-fetch-temp-stk-step)
(disable r-deposit-temp-stk-okp)
(disable r-deposit-temp-stk-step)
(disable r-jump-okp)
(disable r-jump-step)
(disable r-jump-case-okp)
(disable r-jump-case-step)
(disable r-pushj-okp)
(disable r-pushj-step)
(disable r-popj-okp)
(disable r-popj-step)
(disable r-set-local-okp)
(disable r-set-local-step)
(disable r-set-global-okp)
(disable r-set-global-step)
(disable r-test-nat-and-jump-okp)
(disable r-test-nat-and-jump-step)
(disable r-test-int-and-jump-okp)
(disable r-test-int-and-jump-step)
(disable r-test-bool-and-jump-okp)
(disable r-test-bool-and-jump-step)
(disable r-test-bitv-and-jump-okp)
(disable r-test-bitv-and-jump-step)
(disable r-no-op-okp)
(disable r-no-op-step)
(disable r-add-addr-okp)
(disable r-add-addr-step)
(disable r-sub-addr-okp)
(disable r-sub-addr-step)
(disable r-eq-okp)
(disable r-eq-step)
(disable r-lt-addr-okp)
(disable r-lt-addr-step)
(disable r-fetch-okp)
(disable r-fetch-step)
(disable r-deposit-okp)
(disable r-deposit-step)
(disable r-add-int-okp)
(disable r-add-int-step)
(disable r-add-int-with-carry-okp)
(disable r-add-int-with-carry-step)
(disable r-add1-int-okp)
(disable r-add1-int-step)
(disable r-sub-int-okp)
(disable r-sub-int-step)
(disable r-sub-int-with-carry-okp)
(disable r-sub-int-with-carry-step)
(disable r-sub1-int-okp)
(disable r-sub1-int-step)
(disable r-neg-int-okp)
(disable r-neg-int-step)
(disable r-lt-int-okp)
(disable r-lt-int-step)
(disable r-int-to-nat-okp)
(disable r-int-to-nat-step)
(disable r-add-nat-okp)
(disable r-add-nat-step)
(disable r-add-nat-with-carry-okp)
(disable r-add-nat-with-carry-step)
(disable r-add1-nat-okp)
(disable r-add1-nat-step)
(disable r-sub-nat-okp)
(disable r-sub-nat-step)
(disable r-sub-nat-with-carry-okp)
(disable r-sub-nat-with-carry-step)
(disable r-sub1-nat-okp)
(disable r-sub1-nat-step)
(disable r-lt-nat-okp)
(disable r-lt-nat-step)
(disable r-mult2-nat-okp)
(disable r-mult2-nat-step)
(disable r-mult2-nat-with-carry-out-okp)
(disable r-mult2-nat-with-carry-out-step)
(disable r-div2-nat-okp)
(disable r-div2-nat-step)
(disable r-or-bitv-okp)
(disable r-or-bitv-step)
(disable r-and-bitv-okp)
(disable r-and-bitv-step)
(disable r-not-bitv-okp)
(disable r-not-bitv-step)
(disable r-xor-bitv-okp)
(disable r-xor-bitv-step)
(disable r-rsh-bitv-okp)
(disable r-rsh-bitv-step)
(disable r-lsh-bitv-okp)
(disable r-lsh-bitv-step)
(disable r-or-bool-okp)
(disable r-or-bool-step)
(disable r-and-bool-okp)
(disable r-and-bool-step)
(disable r-not-bool-okp)
(disable r-not-bool-step)

; Our plan for putting everything together requires -- as every plan must
; I think -- enough Lisp stack space for the rewriter to completely explore
; the if-nest in r-ins-step and the other "big switch" functions.
; Unfortunately that is not the case.  So we artificially partition our
; functions into two nearly equal halves and deal with each half separately.

(defn r-ins-okp2 (ins r)
  (case (car ins)
        (eq                     (r-eq-okp ins r))
        (lt-addr                (r-lt-addr-okp ins r))
        (fetch                  (r-fetch-okp ins r))
        (deposit                (r-deposit-okp ins r))
        (add-int                (r-add-int-okp ins r))
        (add-int-with-carry     (r-add-int-with-carry-okp ins r))
        (add1-int               (r-add1-int-okp ins r))
        (sub-int                (r-sub-int-okp ins r))
        (sub-int-with-carry     (r-sub-int-with-carry-okp ins r))
        (sub1-int               (r-sub1-int-okp ins r))
        (neg-int                (r-neg-int-okp ins r))
        (lt-int                 (r-lt-int-okp ins r))
        (int-to-nat             (r-int-to-nat-okp ins r))
        (add-nat                (r-add-nat-okp ins r))
        (add-nat-with-carry     (r-add-nat-with-carry-okp ins r))
        (add1-nat               (r-add1-nat-okp ins r))
        (sub-nat                (r-sub-nat-okp ins r))
        (sub-nat-with-carry     (r-sub-nat-with-carry-okp ins r))
        (sub1-nat               (r-sub1-nat-okp ins r))
        (lt-nat                 (r-lt-nat-okp ins r))
        (mult2-nat              (r-mult2-nat-okp ins r))
        (mult2-nat-with-carry-out
         (r-mult2-nat-with-carry-out-okp ins r))
        (div2-nat               (r-div2-nat-okp ins r))
        (or-bitv                (r-or-bitv-okp ins r))
        (and-bitv               (r-and-bitv-okp ins r))
        (not-bitv               (r-not-bitv-okp ins r))
        (xor-bitv               (r-xor-bitv-okp ins r))
        (rsh-bitv               (r-rsh-bitv-okp ins r))
        (lsh-bitv               (r-lsh-bitv-okp ins r))
        (or-bool                (r-or-bool-okp ins r))
        (and-bool               (r-and-bool-okp ins r))
        (not-bool               (r-not-bool-okp ins r))
        (otherwise              f)))

(defn r-ins-okp1 (ins r)
  (case (car ins)
    (call                       (r-call-okp ins r))
    (ret                        (r-ret-okp ins r))
    (locn                       (r-locn-okp ins r))
    (push-constant              (r-push-constant-okp ins r))
    (push-local                 (r-push-local-okp ins r))
    (push-global                (r-push-global-okp ins r))
    (push-ctrl-stk-free-size    (r-push-ctrl-stk-free-size-okp ins r))
    (push-temp-stk-free-size    (r-push-temp-stk-free-size-okp ins r))
    (push-temp-stk-index        (r-push-temp-stk-index-okp ins r))
    (jump-if-temp-stk-full      (r-jump-if-temp-stk-full-okp ins r))
    (jump-if-temp-stk-empty     (r-jump-if-temp-stk-empty-okp ins r))
    (pop                        (r-pop-okp ins r))
    (pop*                       (r-pop*-okp ins r))
    (popn                       (r-popn-okp ins r))
    (pop-local                  (r-pop-local-okp ins r))
    (pop-global                 (r-pop-global-okp ins r))
    (pop-locn                   (r-pop-locn-okp ins r))
    (pop-call                   (r-pop-call-okp ins r))
    (fetch-temp-stk             (r-fetch-temp-stk-okp ins r))
    (deposit-temp-stk           (r-deposit-temp-stk-okp ins r))
    (jump                       (r-jump-okp ins r))
    (jump-case                  (r-jump-case-okp ins r))
    (pushj                      (r-pushj-okp ins r))
    (popj                       (r-popj-okp ins r))
    (set-local                  (r-set-local-okp ins r))
    (set-global                 (r-set-global-okp ins r))
    (test-nat-and-jump          (r-test-nat-and-jump-okp ins r))
    (test-int-and-jump          (r-test-int-and-jump-okp ins r))
    (test-bool-and-jump         (r-test-bool-and-jump-okp ins r))
    (test-bitv-and-jump         (r-test-bitv-and-jump-okp ins r))
    (no-op                      (r-no-op-okp ins r))
    (add-addr                   (r-add-addr-okp ins r))
    (sub-addr                   (r-sub-addr-okp ins r))
    (otherwise                  (r-ins-okp2 ins r))))

(prove-lemma r-ins-okp-is-r-ins-okp1 (rewrite)
  (equal (r-ins-okp ins r)
         (r-ins-okp1 ins r)))

(disable r-ins-okp)
(disable r-ins-okp-is-r-ins-okp1)

; We repeat the exercise for r-ins-step.

(enable r-ins-step-is-r-ins-step1)

(disable r-ins-step)
(disable r-ins-step-is-r-ins-step1)

(defn p-ins-okp2 (ins p)
  (case (car ins)
        (eq                     (p-eq-okp ins p))
        (lt-addr                (p-lt-addr-okp ins p))
        (fetch                  (p-fetch-okp ins p))
        (deposit                (p-deposit-okp ins p))
        (add-int                (p-add-int-okp ins p))
        (add-int-with-carry     (p-add-int-with-carry-okp ins p))
        (add1-int               (p-add1-int-okp ins p))
        (sub-int                (p-sub-int-okp ins p))
        (sub-int-with-carry     (p-sub-int-with-carry-okp ins p))
        (sub1-int               (p-sub1-int-okp ins p))
        (neg-int                (p-neg-int-okp ins p))
        (lt-int                 (p-lt-int-okp ins p))
        (int-to-nat             (p-int-to-nat-okp ins p))
        (add-nat                (p-add-nat-okp ins p))
        (add-nat-with-carry     (p-add-nat-with-carry-okp ins p))
        (add1-nat               (p-add1-nat-okp ins p))
        (sub-nat                (p-sub-nat-okp ins p))
        (sub-nat-with-carry     (p-sub-nat-with-carry-okp ins p))
        (sub1-nat               (p-sub1-nat-okp ins p))
        (lt-nat                 (p-lt-nat-okp ins p))
        (mult2-nat              (p-mult2-nat-okp ins p))
        (mult2-nat-with-carry-out
         (p-mult2-nat-with-carry-out-okp ins p))
        (div2-nat               (p-div2-nat-okp ins p))
        (or-bitv                (p-or-bitv-okp ins p))
        (and-bitv               (p-and-bitv-okp ins p))
        (not-bitv               (p-not-bitv-okp ins p))
        (xor-bitv               (p-xor-bitv-okp ins p))
        (rsh-bitv               (p-rsh-bitv-okp ins p))
        (lsh-bitv               (p-lsh-bitv-okp ins p))
        (or-bool                (p-or-bool-okp ins p))
        (and-bool               (p-and-bool-okp ins p))
        (not-bool               (p-not-bool-okp ins p))
        (otherwise              f)))

(defn p-ins-okp1 (ins p)
  (case (car ins)
    (call                       (p-call-okp ins p))
    (ret                        (p-ret-okp ins p))
    (locn                       (p-locn-okp ins p))
    (push-constant              (p-push-constant-okp ins p))
    (push-local                 (p-push-local-okp ins p))
    (push-global                (p-push-global-okp ins p))
    (push-ctrl-stk-free-size    (p-push-ctrl-stk-free-size-okp ins p))
    (push-temp-stk-free-size    (p-push-temp-stk-free-size-okp ins p))
    (push-temp-stk-index        (p-push-temp-stk-index-okp ins p))
    (jump-if-temp-stk-full      (p-jump-if-temp-stk-full-okp ins p))
    (jump-if-temp-stk-empty     (p-jump-if-temp-stk-empty-okp ins p))
    (pop                        (p-pop-okp ins p))
    (pop*                       (p-pop*-okp ins p))
    (popn                       (p-popn-okp ins p))
    (pop-local                  (p-pop-local-okp ins p))
    (pop-global                 (p-pop-global-okp ins p))
    (pop-locn                   (p-pop-locn-okp ins p))
    (pop-call                   (p-pop-call-okp ins p))
    (fetch-temp-stk             (p-fetch-temp-stk-okp ins p))
    (deposit-temp-stk           (p-deposit-temp-stk-okp ins p))
    (jump                       (p-jump-okp ins p))
    (jump-case                  (p-jump-case-okp ins p))
    (pushj                      (p-pushj-okp ins p))
    (popj                       (p-popj-okp ins p))
    (set-local                  (p-set-local-okp ins p))
    (set-global                 (p-set-global-okp ins p))
    (test-nat-and-jump          (p-test-nat-and-jump-okp ins p))
    (test-int-and-jump          (p-test-int-and-jump-okp ins p))
    (test-bool-and-jump         (p-test-bool-and-jump-okp ins p))
    (test-bitv-and-jump         (p-test-bitv-and-jump-okp ins p))
    (no-op                      (p-no-op-okp ins p))
    (add-addr                   (p-add-addr-okp ins p))
    (sub-addr                   (p-sub-addr-okp ins p))
    (otherwise                  (p-ins-okp2 ins p))))

(prove-lemma p-ins-okp-is-p-ins-okp1 (rewrite)
  (equal (p-ins-okp ins p)
         (p-ins-okp1 ins p)))

(disable p-ins-okp)
(disable p-ins-okp-is-p-ins-okp1)

(defn p-ins-step2 (ins p)
  (case (car ins)
        (eq                     (p-eq-step ins p))
        (lt-addr                (p-lt-addr-step ins p))
        (fetch                  (p-fetch-step ins p))
        (deposit                (p-deposit-step ins p))
        (add-int                (p-add-int-step ins p))
        (add-int-with-carry     (p-add-int-with-carry-step ins p))
        (add1-int               (p-add1-int-step ins p))
        (sub-int                (p-sub-int-step ins p))
        (sub-int-with-carry     (p-sub-int-with-carry-step ins p))
        (sub1-int               (p-sub1-int-step ins p))
        (neg-int                (p-neg-int-step ins p))
        (lt-int                 (p-lt-int-step ins p))
        (int-to-nat             (p-int-to-nat-step ins p))
        (add-nat                (p-add-nat-step ins p))
        (add-nat-with-carry     (p-add-nat-with-carry-step ins p))
        (add1-nat               (p-add1-nat-step ins p))
        (sub-nat                (p-sub-nat-step ins p))
        (sub-nat-with-carry     (p-sub-nat-with-carry-step ins p))
        (sub1-nat               (p-sub1-nat-step ins p))
        (lt-nat                 (p-lt-nat-step ins p))
        (mult2-nat              (p-mult2-nat-step ins p))
        (mult2-nat-with-carry-out
         (p-mult2-nat-with-carry-out-step ins p))
        (div2-nat               (p-div2-nat-step ins p))
        (or-bitv                (p-or-bitv-step ins p))
        (and-bitv               (p-and-bitv-step ins p))
        (not-bitv               (p-not-bitv-step ins p))
        (xor-bitv               (p-xor-bitv-step ins p))
        (rsh-bitv               (p-rsh-bitv-step ins p))
        (lsh-bitv               (p-lsh-bitv-step ins p))
        (or-bool                (p-or-bool-step ins p))
        (and-bool               (p-and-bool-step ins p))
        (not-bool               (p-not-bool-step ins p))
        (otherwise              (p-halt p 'run))))

(defn p-ins-step1 (ins p)
  (case (car ins)
    (call                       (p-call-step ins p))
    (ret                        (p-ret-step ins p))
    (locn                       (p-locn-step ins p))
    (push-constant              (p-push-constant-step ins p))
    (push-local                 (p-push-local-step ins p))
    (push-global                (p-push-global-step ins p))
    (push-ctrl-stk-free-size    (p-push-ctrl-stk-free-size-step ins p))
    (push-temp-stk-free-size    (p-push-temp-stk-free-size-step ins p))
    (push-temp-stk-index        (p-push-temp-stk-index-step ins p))
    (jump-if-temp-stk-full      (p-jump-if-temp-stk-full-step ins p))
    (jump-if-temp-stk-empty     (p-jump-if-temp-stk-empty-step ins p))
    (pop                        (p-pop-step ins p))
    (pop*                       (p-pop*-step ins p))
    (popn                       (p-popn-step ins p))
    (pop-local                  (p-pop-local-step ins p))
    (pop-global                 (p-pop-global-step ins p))
    (pop-locn                   (p-pop-locn-step ins p))
    (pop-call                   (p-pop-call-step ins p))
    (fetch-temp-stk             (p-fetch-temp-stk-step ins p))
    (deposit-temp-stk           (p-deposit-temp-stk-step ins p))
    (jump                       (p-jump-step ins p))
    (jump-case                  (p-jump-case-step ins p))
    (pushj                      (p-pushj-step ins p))
    (popj                       (p-popj-step ins p))
    (set-local                  (p-set-local-step ins p))
    (set-global                 (p-set-global-step ins p))
    (test-nat-and-jump          (p-test-nat-and-jump-step ins p))
    (test-int-and-jump          (p-test-int-and-jump-step ins p))
    (test-bool-and-jump         (p-test-bool-and-jump-step ins p))
    (test-bitv-and-jump         (p-test-bitv-and-jump-step ins p))
    (no-op                      (p-no-op-step ins p))
    (add-addr                   (p-add-addr-step ins p))
    (sub-addr                   (p-sub-addr-step ins p))
    (otherwise                  (p-ins-step2 ins p))))

(prove-lemma p-ins-step-is-p-ins-step1 (rewrite)
  (equal (p-ins-step ins p)
         (p-ins-step1 ins p)))

(disable p-ins-step)
(disable p-ins-step-is-p-ins-step1)

; We disable p-ins-okp because the main owc theorem involves p-ins-okp
; and p-ins-step, and opening either is sufficient to drive the case
; analysis.  If both open, then we get cross-multiplied cases and
; there is a lot of silly propositional work to do.  So we arbitrarily
; choose to keep p-ins-okp disabled.  Now we could choose to rewrite
; it to p-xxx-okp when the car of ins is 'xxx, analogously to what we
; did for r-ins-okp above.  But the proof of the owc should be faster
; if we do this: keep p-ins-okp disabled and show that p-xxx-okp holds
; if the car of ins is 'xxx.  The reason is that when we fire the
; xxx-one-way-correspondence-p-r lemma we will want to get p-xxx-okp
; and we'll be governed by a p-ins-okp and a hyp about car ins.  But
; the hyp about car ins won't have been raised all the way to the top
; and so won't yet be available to tell the p-ins-okp which way to go.
; This is the same strategy used for r-ins-okp in the r-i level proof.

(prove-lemma p-ins-okp2-backchainer (rewrite)
  (implies (p-ins-okp2 ins p)
           (and
            (implies (equal (car ins) 'eq)
                     (p-eq-okp ins p))
            (implies (equal (car ins) 'lt-addr)
                     (p-lt-addr-okp ins p))
            (implies (equal (car ins) 'fetch)
                     (p-fetch-okp ins p))
            (implies (equal (car ins) 'deposit)
                     (p-deposit-okp ins p))
            (implies (equal (car ins) 'add-int)
                     (p-add-int-okp ins p))
            (implies (equal (car ins) 'add-int-with-carry)
                     (p-add-int-with-carry-okp ins p))
            (implies (equal (car ins) 'add1-int)
                     (p-add1-int-okp ins p))
            (implies (equal (car ins) 'sub-int)
                     (p-sub-int-okp ins p))
            (implies (equal (car ins) 'sub-int-with-carry)
                     (p-sub-int-with-carry-okp ins p))
            (implies (equal (car ins) 'sub1-int)
                     (p-sub1-int-okp ins p))
            (implies (equal (car ins) 'neg-int)
                     (p-neg-int-okp ins p))
            (implies (equal (car ins) 'lt-int)
                     (p-lt-int-okp ins p))
            (implies (equal (car ins) 'int-to-nat)
                     (p-int-to-nat-okp ins p))
            (implies (equal (car ins) 'add-nat)
                     (p-add-nat-okp ins p))
            (implies (equal (car ins) 'add-nat-with-carry)
                     (p-add-nat-with-carry-okp ins p))
            (implies (equal (car ins) 'add1-nat)
                     (p-add1-nat-okp ins p))
            (implies (equal (car ins) 'sub-nat)
                     (p-sub-nat-okp ins p))
            (implies (equal (car ins) 'sub-nat-with-carry)
                     (p-sub-nat-with-carry-okp ins p))
            (implies (equal (car ins) 'sub1-nat)
                     (p-sub1-nat-okp ins p))
            (implies (equal (car ins) 'lt-nat)
                     (p-lt-nat-okp ins p))
            (implies (equal (car ins) 'mult2-nat)
                     (p-mult2-nat-okp ins p))
            (implies (equal (car ins) 'mult2-nat-with-carry-out)
                     (p-mult2-nat-with-carry-out-okp ins p))
            (implies (equal (car ins) 'div2-nat)
                     (p-div2-nat-okp ins p))
            (implies (equal (car ins) 'or-bitv)
                     (p-or-bitv-okp ins p))
            (implies (equal (car ins) 'and-bitv)
                     (p-and-bitv-okp ins p))
            (implies (equal (car ins) 'not-bitv)
                     (p-not-bitv-okp ins p))
            (implies (equal (car ins) 'xor-bitv)
                     (p-xor-bitv-okp ins p))
            (implies (equal (car ins) 'rsh-bitv)
                     (p-rsh-bitv-okp ins p))
            (implies (equal (car ins) 'lsh-bitv)
                     (p-lsh-bitv-okp ins p))
            (implies (equal (car ins) 'or-bool)
                     (p-or-bool-okp ins p))
            (implies (equal (car ins) 'and-bool)
                     (p-and-bool-okp ins p))
            (implies (equal (car ins) 'not-bool)
                     (p-not-bool-okp ins p)))))

(disable p-ins-okp2)

(prove-lemma p-ins-okp-backchainer (rewrite)
  (implies (p-ins-okp ins p)
           (and
            (implies (equal (car ins) 'call)
                     (p-call-okp ins p))
            (implies (equal (car ins) 'ret)
                     (p-ret-okp ins p))
            (implies (equal (car ins) 'locn)
                     (p-locn-okp ins p))
            (implies (equal (car ins) 'push-constant)
                     (p-push-constant-okp ins p))
            (implies (equal (car ins) 'push-local)
                     (p-push-local-okp ins p))
            (implies (equal (car ins) 'push-global)
                     (p-push-global-okp ins p))
            (implies (equal (car ins) 'push-ctrl-stk-free-size)
                     (p-push-ctrl-stk-free-size-okp ins p))
            (implies (equal (car ins) 'push-temp-stk-free-size)
                     (p-push-temp-stk-free-size-okp ins p))
            (implies (equal (car ins) 'push-temp-stk-index)
                     (p-push-temp-stk-index-okp ins p))
            (implies (equal (car ins) 'jump-if-temp-stk-full)
                     (p-jump-if-temp-stk-full-okp ins p))
            (implies (equal (car ins) 'jump-if-temp-stk-empty)
                     (p-jump-if-temp-stk-empty-okp ins p))
            (implies (equal (car ins) 'pop)
                     (p-pop-okp ins p))
            (implies (equal (car ins) 'pop*)
                     (p-pop*-okp ins p))
            (implies (equal (car ins) 'popn)
                     (p-popn-okp ins p))
            (implies (equal (car ins) 'pop-local)
                     (p-pop-local-okp ins p))
            (implies (equal (car ins) 'pop-global)
                     (p-pop-global-okp ins p))
            (implies (equal (car ins) 'pop-locn)
                     (p-pop-locn-okp ins p))
            (implies (equal (car ins) 'pop-call)
                     (p-pop-call-okp ins p))
            (implies (equal (car ins) 'fetch-temp-stk)
                     (p-fetch-temp-stk-okp ins p))
            (implies (equal (car ins) 'deposit-temp-stk)
                     (p-deposit-temp-stk-okp ins p))
            (implies (equal (car ins) 'jump)
                     (p-jump-okp ins p))
            (implies (equal (car ins) 'jump-case)
                     (p-jump-case-okp ins p))
            (implies (equal (car ins) 'pushj)
                     (p-pushj-okp ins p))
            (implies (equal (car ins) 'popj)
                     (p-popj-okp ins p))
            (implies (equal (car ins) 'set-local)
                     (p-set-local-okp ins p))
            (implies (equal (car ins) 'set-global)
                     (p-set-global-okp ins p))
            (implies (equal (car ins) 'test-nat-and-jump)
                     (p-test-nat-and-jump-okp ins p))
            (implies (equal (car ins) 'test-int-and-jump)
                     (p-test-int-and-jump-okp ins p))
            (implies (equal (car ins) 'test-bool-and-jump)
                     (p-test-bool-and-jump-okp ins p))
            (implies (equal (car ins) 'test-bitv-and-jump)
                     (p-test-bitv-and-jump-okp ins p))
            (implies (equal (car ins) 'no-op)
                     (p-no-op-okp ins p))
            (implies (equal (car ins) 'add-addr)
                     (p-add-addr-okp ins p))
            (implies (equal (car ins) 'sub-addr)
                     (p-sub-addr-okp ins p))))
  ((enable p-ins-okp-is-p-ins-okp1 p-ins-okp1)))

; The only problem with these backchainers is that we don't know that the
; above cases are exhaustive.  That is, suppose the current instruction
; is none of the above.  Then p-ins-okp is false.  We need to know that.
; The most natural expression of this fact is that if the instruction
; is not call and not ret and, etc., then p-ins-okp is false.  But that
; is an inefficient way to hang it, because every time we see p-ins-okp
; we'll try to show the instruction is none of the above and most of the time
; it will be one of the ones listed half-way through the list.  So we'll
; hang it on one of the instructions!  It reads: if p-ins-okp is true
; and the instruction is not call, not ret, etc., then the instruction
; is 'not-bool, except we split it into two lemmas.

(prove-lemma p-ins-okp-exhausted (rewrite)
  (implies (and (p-ins-okp ins p)
                (not (equal (car ins) 'call))
                (not (equal (car ins) 'ret))
                (not (equal (car ins) 'locn))
                (not (equal (car ins) 'push-constant))
                (not (equal (car ins) 'push-local))
                (not (equal (car ins) 'push-global))
                (not (equal (car ins) 'push-ctrl-stk-free-size))
                (not (equal (car ins) 'push-temp-stk-free-size))
                (not (equal (car ins) 'push-temp-stk-index))
                (not (equal (car ins) 'jump-if-temp-stk-full))
                (not (equal (car ins) 'jump-if-temp-stk-empty))
                (not (equal (car ins) 'pop))
                (not (equal (car ins) 'pop*))
                (not (equal (car ins) 'popn))
                (not (equal (car ins) 'pop-local))
                (not (equal (car ins) 'pop-global))
                (not (equal (car ins) 'pop-locn))
                (not (equal (car ins) 'pop-call))
                (not (equal (car ins) 'fetch-temp-stk))
                (not (equal (car ins) 'deposit-temp-stk))
                (not (equal (car ins) 'jump))
                (not (equal (car ins) 'jump-case))
                (not (equal (car ins) 'pushj))
                (not (equal (car ins) 'popj))
                (not (equal (car ins) 'set-local))
                (not (equal (car ins) 'set-global))
                (not (equal (car ins) 'test-nat-and-jump))
                (not (equal (car ins) 'test-int-and-jump))
                (not (equal (car ins) 'test-bool-and-jump))
                (not (equal (car ins) 'test-bitv-and-jump))
                (not (equal (car ins) 'no-op))
                (not (equal (car ins) 'add-addr))
                (not (equal (car ins) 'sub-addr)))
           (p-ins-okp2 ins p))
  ((enable p-ins-okp-is-p-ins-okp1 p-ins-okp1)))

(prove-lemma p-ins-okp2-exhausted (rewrite)
  (implies (and (p-ins-okp2 ins p)
                (not (equal (car ins) 'eq))
                (not (equal (car ins) 'lt-addr))
                (not (equal (car ins) 'fetch))
                (not (equal (car ins) 'deposit))
                (not (equal (car ins) 'add-int))
                (not (equal (car ins) 'add-int-with-carry))
                (not (equal (car ins) 'add1-int))
                (not (equal (car ins) 'sub-int))
                (not (equal (car ins) 'sub-int-with-carry))
                (not (equal (car ins) 'sub1-int))
                (not (equal (car ins) 'neg-int))
                (not (equal (car ins) 'lt-int))
                (not (equal (car ins) 'int-to-nat))
                (not (equal (car ins) 'add-nat))
                (not (equal (car ins) 'add-nat-with-carry))
                (not (equal (car ins) 'add1-nat))
                (not (equal (car ins) 'sub-nat))
                (not (equal (car ins) 'sub-nat-with-carry))
                (not (equal (car ins) 'sub1-nat))
                (not (equal (car ins) 'lt-nat))
                (not (equal (car ins) 'mult2-nat))
                (not (equal (car ins) 'mult2-nat-with-carry-out))
                (not (equal (car ins) 'div2-nat))
                (not (equal (car ins) 'or-bitv))
                (not (equal (car ins) 'and-bitv))
                (not (equal (car ins) 'not-bitv))
                (not (equal (car ins) 'xor-bitv))
                (not (equal (car ins) 'rsh-bitv))
                (not (equal (car ins) 'lsh-bitv))
                (not (equal (car ins) 'or-bool))
                (not (equal (car ins) 'and-bool)))
           (equal (equal (car ins) 'not-bool)
                  t))
  ((enable p-ins-okp2)))

; We will package the owc lemmas for each instruction into two lemmas
; about p-ins-okp v. r-ins-okp and p-ins-step v. r-ins-step.  Then we will
; put those together to get a p-step v. r-step lemma.

; Look at p-ins-okp-implies-r-ins-okp below.  We will let the r-ins-okp
; drive the case analysis, by enabling it during the proof.  It will
; open into an if, carrying the (p->r p) down into the maw of each of
; the n r-xxx-okps, each  governed by a hyp on the car of the current
; instruction.  When (r-xxx-okp (p-current-instruction p) (p->r p)) is
; formed, it will fire the p-xxx-okp-implies-r-xxx-okp lemma.  That will
; back chain to p-xxx-okp, under the hyp about the current instruction
; being 'xxx, and that will backchain into p-ins-okp by the lemma above.
; Every single case will be proved by appeal to one of our lemmas and
; all that will be left is proving that the case analysis done by r-ins-okp
; exhausts p-ins-okp.  But we already have that.  So one rewrite will
; prove the theorem.

; Of course, we want the following disabled:

(disable p->r)
(disable proper-p-statep-restructuring)

; And we need to split the proof into two manageable sized steps.

(prove-lemma p-r-ins-okp2 (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (proper-p-statep p)
               (p-ins-okp2 (p-current-instruction p)
                           p))
          (r-ins-okp2 (p-current-instruction p)
                      (p->r p)))
 ((enable r-ins-okp2)))

(prove-lemma p-r-ins-okp (rewrite)
 (implies (and (equal (p-psw p) 'run)
               (proper-p-statep p)
               (p-ins-okp (p-current-instruction p)
                          p))
          (r-ins-okp (p-current-instruction p)
                     (p->r p)))
 ((enable r-ins-okp-is-r-ins-okp1 r-ins-okp1)))

; Now we move on to the p v. r ins-step case.

; Now consider p-r-ins-step-owc below.  We will let both the p-ins-step
; and the r-ins-step expand.  They both go to ghastly if expressions.
; With the following lemma we will bring the p-ins-step's ifs out of p->r:

(prove-lemma p->r-if (rewrite)
  (equal (p->r (if a b c))
         (if a (p->r b) (p->r c))))

; So now the r-equal has two if nests as its args.  If we let the theorem
; prover handle things it would cross multiply them.  But there is a simpler
; way because the two nests have identical tests in the same order.  So
; we can use:

(prove-lemma r-equal-if (rewrite)
  (equal (r-equal (if op r1 r2) (if op r3 r4))
         (if op (r-equal r1 r3) (r-equal r2 r4))))

; Since r2 and r4 are themselves ifs, this will just drive on down.  At the
; bottom we will need:

(prove-lemma stk-equal-reflexive (rewrite)
 (stk-equal sp segment segment)
 ((enable stk-equal)))

(prove-lemma r-equal-reflexive (rewrite)
  (implies (r-statep r) (r-equal r r))
  ((enable r-equal)))

; Each of the branches of this new if will be an r-equality between 
; (p->r (p-xxx-step ...)) and (r-xxx-step ... (p->r p)), governed by
; the hyp that the instruction is 'xxx.  That will fire our individual
; one way correspondence lemmas and backchain to (p-xxx-okp ...), which
; we'll get, as above, from the p-ins-okp.

; So once again, under these rules, the following theorem rewrites to
; T in one pass:

(prove-lemma p-r-ins-step2-owc (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (proper-p-statep p)
                (p-ins-okp2 (p-current-instruction p)
                            p))
           (r-equal (p->r (p-ins-step2 (p-current-instruction p)
                                       p))
                    (r-ins-step2 (p-current-instruction p)
                                 (p->r p)))))

(disable p-ins-step2)
(disable r-ins-step2)

(prove-lemma p-r-ins-step-owc (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (proper-p-statep p)
                (p-ins-okp (p-current-instruction p)
                           p))
           (r-equal (p->r (p-ins-step (p-current-instruction p)
                                      p))
                    (r-ins-step (p-current-instruction p)
                                (p->r p))))
 ((enable p-ins-step-is-p-ins-step1 p-ins-step1
          r-ins-step-is-r-ins-step1 r-ins-step1)))

; We now package the p-r-ins-okp and p-r-ins-step pair into p-r-step:

; We need to know a few things about the psw to get through r-step properly.

(prove-lemma r-psw-p->r (rewrite)
  (equal (r-psw (p->r p)) (p-psw p))
  ((enable p->r)))

(prove-lemma step-one-way-correspondence-p-r (rewrite)
 (implies (and (proper-p-statep p)
               (not (errorp (p-psw (p-step p)))))
          (r-equal (p->r (p-step p))
                   (r-step (p->r p))))
 ((enable r-step)))

; So that completes the packaging of the owc lemmas.  Now we move on to
; the packaging of the proper-p-statep preservation lemmas.

; Recall that we proved the lemmas about ur-proper-p-statep.  So we
; take it in two steps.  First we gather all the lemmas into a single
; stepper concluding with ur-proper-p-statep.  Then we expose the true
; identity of ur-proper-p-statep.  As above, we deal first with p-ins-step.

; The strategy is to let p-ins-step open, bring the ifs through
; ur-proper-p-statep, and then hit each branch with the preservation
; lemma for the governing case.

(prove-lemma ur-proper-p-statep-if (rewrite)
  (equal (ur-proper-p-statep (if a b c))
         (if a (ur-proper-p-statep b) (ur-proper-p-statep c))))

(prove-lemma p-ins-step2-preserves-ur-proper-p-statep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp2 (p-current-instruction p) p)
                (proper-p-statep p))
           (ur-proper-p-statep (p-ins-step2 (p-current-instruction p) p)))
  ((enable p-ins-okp2 p-ins-step2)))

(prove-lemma p-ins-step-preserves-ur-proper-p-statep nil
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp (p-current-instruction p) p)
                (proper-p-statep p))
           (ur-proper-p-statep (p-ins-step (p-current-instruction p) p)))
  ((enable p-ins-step-is-p-ins-step1 p-ins-step1)))
           
; Now we show the true identity of ur-proper-p-statep.

(prove-lemma p-ins-step-preserves-proper-p-statep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp (p-current-instruction p) p)
                (proper-p-statep p))
           (proper-p-statep (p-ins-step (p-current-instruction p) p)))
  ((use (p-ins-step-preserves-ur-proper-p-statep))
   (enable ur-proper-p-statep)))

; And now we package it up to the p-step level:

(prove-lemma p-step-preserves-proper-p-statep (rewrite)
 (implies (and (proper-p-statep p)
               (not (errorp (p-psw (p-step p)))))
          (proper-p-statep (p-step p))))

; And that completes the packaging of the proper-p-statep preservation.

; Finally, we prove the preservation of r-equality by r-step.

; This whole exercise would be simpler if we did two things.
; (1) in all of the lemmas of the form r-equal-implies-equal-r-xxx-okp
; replace the concluding (equal lhs rhs) with (equal (equal lhs rhs) t).
; (2) in all of the lemmas r-xxx-step-preserves-r-equal, replace
; the (r-xxx-okp ... r2) hyp by (r-xxx-okp ... r1).  Then my
; concern about r-equal-reflexivity can be forgotten.  !!! except
; in the r-step lemma below -- the r-ins-okp lemma below must still
; be (equal lhs rhs) and so reflexivity must be disabled when 
; I use that lemma.


; We need a backchainer for r-ins-okp analogous to that used for p-ins-okp 
; above:

(prove-lemma r-ins-okp2-backchainer (rewrite)
  (implies (r-ins-okp2 ins r)
           (and
            (implies (equal (car ins) 'eq)
                     (r-eq-okp ins r))
            (implies (equal (car ins) 'lt-addr)
                     (r-lt-addr-okp ins r))
            (implies (equal (car ins) 'fetch)
                     (r-fetch-okp ins r))
            (implies (equal (car ins) 'deposit)
                     (r-deposit-okp ins r))
            (implies (equal (car ins) 'add-int)
                     (r-add-int-okp ins r))
            (implies (equal (car ins) 'add-int-with-carry)
                     (r-add-int-with-carry-okp ins r))
            (implies (equal (car ins) 'add1-int)
                     (r-add1-int-okp ins r))
            (implies (equal (car ins) 'sub-int)
                     (r-sub-int-okp ins r))
            (implies (equal (car ins) 'sub-int-with-carry)
                     (r-sub-int-with-carry-okp ins r))
            (implies (equal (car ins) 'sub1-int)
                     (r-sub1-int-okp ins r))
            (implies (equal (car ins) 'neg-int)
                     (r-neg-int-okp ins r))
            (implies (equal (car ins) 'lt-int)
                     (r-lt-int-okp ins r))
            (implies (equal (car ins) 'int-to-nat)
                     (r-int-to-nat-okp ins r))
            (implies (equal (car ins) 'add-nat)
                     (r-add-nat-okp ins r))
            (implies (equal (car ins) 'add-nat-with-carry)
                     (r-add-nat-with-carry-okp ins r))
            (implies (equal (car ins) 'add1-nat)
                     (r-add1-nat-okp ins r))
            (implies (equal (car ins) 'sub-nat)
                     (r-sub-nat-okp ins r))
            (implies (equal (car ins) 'sub-nat-with-carry)
                     (r-sub-nat-with-carry-okp ins r))
            (implies (equal (car ins) 'sub1-nat)
                     (r-sub1-nat-okp ins r))
            (implies (equal (car ins) 'lt-nat)
                     (r-lt-nat-okp ins r))
            (implies (equal (car ins) 'mult2-nat)
                     (r-mult2-nat-okp ins r))
            (implies (equal (car ins) 'mult2-nat-with-carry-out)
                     (r-mult2-nat-with-carry-out-okp ins r))
            (implies (equal (car ins) 'div2-nat)
                     (r-div2-nat-okp ins r))
            (implies (equal (car ins) 'or-bitv)
                     (r-or-bitv-okp ins r))
            (implies (equal (car ins) 'and-bitv)
                     (r-and-bitv-okp ins r))
            (implies (equal (car ins) 'not-bitv)
                     (r-not-bitv-okp ins r))
            (implies (equal (car ins) 'xor-bitv)
                     (r-xor-bitv-okp ins r))
            (implies (equal (car ins) 'rsh-bitv)
                     (r-rsh-bitv-okp ins r))
            (implies (equal (car ins) 'lsh-bitv)
                     (r-lsh-bitv-okp ins r))
            (implies (equal (car ins) 'or-bool)
                     (r-or-bool-okp ins r))
            (implies (equal (car ins) 'and-bool)
                     (r-and-bool-okp ins r))
            (implies (equal (car ins) 'not-bool)
                     (r-not-bool-okp ins r)))))

(disable r-ins-okp2)

(enable r-ins-okp-backchainer)

(prove-lemma r-ins-okp-exhausted (rewrite)
  (implies (and (r-ins-okp ins r)
                (not (equal (car ins) 'call))
                (not (equal (car ins) 'ret))
                (not (equal (car ins) 'locn))
                (not (equal (car ins) 'push-constant))
                (not (equal (car ins) 'push-local))
                (not (equal (car ins) 'push-global))
                (not (equal (car ins) 'push-ctrl-stk-free-size))
                (not (equal (car ins) 'push-temp-stk-free-size))
                (not (equal (car ins) 'push-temp-stk-index))
                (not (equal (car ins) 'jump-if-temp-stk-full))
                (not (equal (car ins) 'jump-if-temp-stk-empty))
                (not (equal (car ins) 'pop))
                (not (equal (car ins) 'pop*))
                (not (equal (car ins) 'popn))
                (not (equal (car ins) 'pop-local))
                (not (equal (car ins) 'pop-global))
                (not (equal (car ins) 'pop-locn))
                (not (equal (car ins) 'pop-call))
                (not (equal (car ins) 'fetch-temp-stk))
                (not (equal (car ins) 'deposit-temp-stk))
                (not (equal (car ins) 'jump))
                (not (equal (car ins) 'jump-case))
                (not (equal (car ins) 'pushj))
                (not (equal (car ins) 'popj))
                (not (equal (car ins) 'set-local))
                (not (equal (car ins) 'set-global))
                (not (equal (car ins) 'test-nat-and-jump))
                (not (equal (car ins) 'test-int-and-jump))
                (not (equal (car ins) 'test-bool-and-jump))
                (not (equal (car ins) 'test-bitv-and-jump))
                (not (equal (car ins) 'no-op))
                (not (equal (car ins) 'add-addr))
                (not (equal (car ins) 'sub-addr)))
           (r-ins-okp2 ins r))
  ((enable r-ins-okp-is-r-ins-okp1 r-ins-okp1)))

; Now we'll prove that r-equal implies r-ins-okp is indifferent to
; which state it gets.  

; The plan is to let r-ins-okp expand into ifs on both sides of the
; equal and then take them out with:

(prove-lemma equal-if (rewrite)
  (equal (equal (if a r1 r2) (if a r3 r4))
         (if a (equal r1 r3) (equal r2 r4))))

; The proof requires some care.  If you leave r-equal-reflexive enabled
; we infinitely rewrite (r-xxx-okp ins r1) to (r-xxx-okp ins r1)
; because we know r1 is r-equal to itself.

(prove-lemma r-equal-implies-equal-r-ins-okp2 (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal (r-ins-okp2 (r-current-instruction r1) r2)
                  (r-ins-okp2 (r-current-instruction r1) r1)))
 ((enable r-ins-okp2)
  (disable r-equal-reflexive)))

(prove-lemma r-equal-implies-equal-r-ins-okp (rewrite)
  (implies (and (equal (r-psw r1) 'run)
                (proper-r-statep r1 load-addr)
                (proper-r-statep r2 load-addr)
                (r-equal r2 r1))
           (equal (r-ins-okp (r-current-instruction r1) r2)
                  (r-ins-okp (r-current-instruction r1) r1)))
 ((enable r-ins-okp-is-r-ins-okp1 r-ins-okp1)
  (disable r-equal-reflexive)))



; Now we do the r-ins-step.

; We'll let r-ins-step open on both sides of the r-equal.  The r-equal-if
; lemma will drive the r-equal through the matching if-nests and we'll
; appeal to our previously proved preservation lemmas.

(prove-lemma r-ins-step2-preserves-r-equal (rewrite)
 (implies (and (equal (r-psw r1) 'run)
               (proper-r-statep r1 load-addr)
               (proper-r-statep r2 load-addr)
               (r-ins-okp2 (r-current-instruction r1) r1)
               (r-equal r2 r1))
          (r-equal (r-ins-step2 (r-current-instruction r1) r2)
                   (r-ins-step2 (r-current-instruction r1) r1)))
 ((enable r-ins-step2)
  (disable r-equal-reflexive)))

(prove-lemma r-ins-step-preserves-r-equal (rewrite)
 (implies (and (equal (r-psw r1) 'run)
               (proper-r-statep r1 load-addr)
               (proper-r-statep r2 load-addr)
               (r-ins-okp (r-current-instruction r1) r1)
               (r-equal r2 r1))
          (r-equal (r-ins-step (r-current-instruction r1) r2)
                   (r-ins-step (r-current-instruction r1) r1)))
 ((enable r-ins-step-is-r-ins-step1 r-ins-step1)
  (disable r-equal-reflexive)))

(prove-lemma r-step-preserves-r-equal (rewrite)
 (implies (and (proper-r-statep r1 load-addr)
               (proper-r-statep r2 load-addr)
               (r-equal r2 r1))
          (r-equal (r-step r2)
                   (r-step r1)))
 ((disable r-equal-reflexive)))
 
; Now we package up the p-loadablep results into a p-step.
; The approach is exactly the same as used above.

(prove-lemma p-loadablep-if (rewrite)
  (equal (p-loadablep (if a b c) load-addr)
         (if a (p-loadablep b load-addr) (p-loadablep c load-addr))))

(prove-lemma p-ins-step2-preserves-p-loadablep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp2 (p-current-instruction p) p)
                (proper-p-statep p)
                (p-loadablep p load-addr))
           (p-loadablep (p-ins-step2 (p-current-instruction p) p)
                        load-addr))
  ((enable p-ins-okp2 p-ins-step2)))

(prove-lemma p-ins-step-preserves-p-loadablep (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp (p-current-instruction p) p)
                (proper-p-statep p)
                (p-loadablep p load-addr))
           (p-loadablep (p-ins-step (p-current-instruction p) p)
                        load-addr))
  ((enable p-ins-step-is-p-ins-step1 p-ins-step1)))

(prove-lemma p-step-preserves-p-loadablep (rewrite)
 (implies (and (proper-p-statep p)
               (p-loadablep p load-addr)
               (not (errorp (p-psw (p-step p)))))
          (p-loadablep (p-step p)
                       load-addr)))

;  Now we grab an event from the r-i proofs:

#|
(include-book r-i-book "r-i" t nil)

;  The following status expression has the effect of enabling only
;  proper-r-statep-r-step among all the other things brought in by
;  the above inclusion.  It also disables r-step.

(status r-i-book-status
        (set-difference
         (union (@ *e* p-step-preserves-p-loadablep)
                '(proper-r-statep-r-step))
         '(r-step)))

|#

(enable proper-r-statep-r-step)

(disable r-step)

(prove-lemma r-preserves-r-equal (rewrite)
 (implies (and (proper-r-statep r1 load-addr)
               (proper-r-statep r2 load-addr)
               (r-equal r2 r1))
          (r-equal (r r2 n)
                   (r r1 n))))

(prove-lemma transitivity-of-same-signature (rewrite)
  (implies (and (same-signature segment1 segment2)
                (same-signature segment2 segment3))
           (same-signature segment1 segment3))
  ((enable same-signature)))

(prove-lemma transitivity-of-stk-equal (rewrite)
  (implies (and (stk-equal sp segment1 segment2)
                (stk-equal sp segment2 segment3)
                (equal (length (cdr (assoc (car (untag sp)) segment2)))
                       (length (cdr (assoc (car (untag sp)) segment1))))
                (equal (length (cdr (assoc (car (untag sp)) segment3)))
                       (length (cdr (assoc (car (untag sp)) segment1)))))
           (stk-equal sp segment1 segment3))
  ((induct (stk-equal sp segment1 segment2))
   (enable empty-stkp)
   (expand (stk-equal sp segment1 segment2)
           (stk-equal sp segment2 segment3)
           (stk-equal sp segment1 segment3))))

(prove-lemma transitivity-of-r-equal (rewrite)
  (implies (and (r-equal r1 r2)
                (r-equal r2 r3))
           (r-equal r1 r3))
  ((enable r-equal)))


; We are now headed toward the proof that proper-p-statep maps down via
; p->r to a proper-r-statep.

; Proper temp-var-dcls at the p level implies the corresponding thing
; at the r level:

(prove-lemma proper-p-temp-var-dclsp-implies-r-temp-var-dclsp (rewrite)
  (implies (proper-p-temp-var-dclsp lst p)
           (r-temp-var-dclsp lst))
  ((enable p-objectp type)))

; The surprisingly hard result is that proper programs at the p level
; implies proper programs at the r level.  We start with two
; observations: anything occuring as a label in a properly labeled
; list of instructions is a litatom; and to be a proper instruction at
; the p level means (among many other things) that the car is a piton
; opcode and push-constants satisfy the
; proper-p-push-constant-instructionp predicate.

(prove-lemma proper-labeled-p-instructionsp-implies-litatom-labels nil
  (implies (and (proper-labeled-p-instructionsp lst name p)
                (find-labelp lab lst))
           (litatom lab))
  ((enable proper-labeled-p-instructionsp legal-labelp)))

(disable proper-p-call-instructionp)
(disable proper-p-ret-instructionp)
(disable proper-p-locn-instructionp)
(disable proper-p-push-constant-instructionp)
(disable proper-p-push-local-instructionp)
(disable proper-p-push-global-instructionp)
(disable proper-p-push-ctrl-stk-free-size-instructionp)
(disable proper-p-push-temp-stk-free-size-instructionp)
(disable proper-p-push-temp-stk-index-instructionp)
(disable proper-p-jump-if-temp-stk-full-instructionp)
(disable proper-p-jump-if-temp-stk-empty-instructionp)
(disable proper-p-pop-instructionp)
(disable proper-p-pop*-instructionp)
(disable proper-p-popn-instructionp)
(disable proper-p-pop-local-instructionp)
(disable proper-p-pop-global-instructionp)
(disable proper-p-pop-locn-instructionp)
(disable proper-p-pop-call-instructionp)
(disable proper-p-fetch-temp-stk-instructionp)
(disable proper-p-deposit-temp-stk-instructionp)
(disable proper-p-jump-instructionp)
(disable proper-p-jump-case-instructionp)
(disable proper-p-pushj-instructionp)
(disable proper-p-popj-instructionp)
(disable proper-p-set-local-instructionp)
(disable proper-p-set-global-instructionp)
(disable proper-p-test-nat-and-jump-instructionp)
(disable proper-p-test-int-and-jump-instructionp)
(disable proper-p-test-bool-and-jump-instructionp)
(disable proper-p-test-bitv-and-jump-instructionp)
(disable proper-p-no-op-instructionp)
(disable proper-p-add-addr-instructionp)
(disable proper-p-sub-addr-instructionp)
(disable proper-p-eq-instructionp)
(disable proper-p-lt-addr-instructionp)
(disable proper-p-fetch-instructionp)
(disable proper-p-deposit-instructionp)
(disable proper-p-add-int-instructionp)
(disable proper-p-add-int-with-carry-instructionp)
(disable proper-p-add1-int-instructionp)
(disable proper-p-sub-int-instructionp)
(disable proper-p-sub-int-with-carry-instructionp)
(disable proper-p-sub1-int-instructionp)
(disable proper-p-neg-int-instructionp)
(disable proper-p-lt-int-instructionp)
(disable proper-p-int-to-nat-instructionp)
(disable proper-p-add-nat-instructionp)
(disable proper-p-add-nat-with-carry-instructionp)
(disable proper-p-add1-nat-instructionp)
(disable proper-p-sub-nat-instructionp)
(disable proper-p-sub-nat-with-carry-instructionp)
(disable proper-p-sub1-nat-instructionp)
(disable proper-p-lt-nat-instructionp)
(disable proper-p-mult2-nat-instructionp)
(disable proper-p-mult2-nat-with-carry-out-instructionp)
(disable proper-p-div2-nat-instructionp)
(disable proper-p-or-bitv-instructionp)
(disable proper-p-and-bitv-instructionp)
(disable proper-p-not-bitv-instructionp)
(disable proper-p-xor-bitv-instructionp)
(disable proper-p-rsh-bitv-instructionp)
(disable proper-p-lsh-bitv-instructionp)
(disable proper-p-or-bool-instructionp)
(disable proper-p-and-bool-instructionp)
(disable proper-p-not-bool-instructionp)

; We split proper-p-instructionp into two parts, as usual with our
; big switches.

(defn proper-p-instructionp2 (ins name p)
  (case
   (car ins)
   (eq (proper-p-eq-instructionp ins name p))
   (lt-addr (proper-p-lt-addr-instructionp ins name p))
   (fetch (proper-p-fetch-instructionp ins name p))
   (deposit (proper-p-deposit-instructionp ins name p))
   (add-int (proper-p-add-int-instructionp ins name p))
   (add-int-with-carry (proper-p-add-int-with-carry-instructionp ins name p))
   (add1-int (proper-p-add1-int-instructionp ins name p))
   (sub-int (proper-p-sub-int-instructionp ins name p))
   (sub-int-with-carry (proper-p-sub-int-with-carry-instructionp ins name p))
   (sub1-int (proper-p-sub1-int-instructionp ins name p))
   (neg-int (proper-p-neg-int-instructionp ins name p))
   (lt-int (proper-p-lt-int-instructionp ins name p))
   (int-to-nat (proper-p-int-to-nat-instructionp ins name p))
   (add-nat (proper-p-add-nat-instructionp ins name p))
   (add-nat-with-carry (proper-p-add-nat-with-carry-instructionp ins name p))
   (add1-nat (proper-p-add1-nat-instructionp ins name p))
   (sub-nat (proper-p-sub-nat-instructionp ins name p))
   (sub-nat-with-carry (proper-p-sub-nat-with-carry-instructionp ins name p))
   (sub1-nat (proper-p-sub1-nat-instructionp ins name p))
   (lt-nat (proper-p-lt-nat-instructionp ins name p))
   (mult2-nat (proper-p-mult2-nat-instructionp ins name p))
   (mult2-nat-with-carry-out
     (proper-p-mult2-nat-with-carry-out-instructionp ins name p))
   (div2-nat (proper-p-div2-nat-instructionp ins name p))
   (or-bitv (proper-p-or-bitv-instructionp ins name p))
   (and-bitv (proper-p-and-bitv-instructionp ins name p))
   (not-bitv (proper-p-not-bitv-instructionp ins name p))
   (xor-bitv (proper-p-xor-bitv-instructionp ins name p))
   (rsh-bitv (proper-p-rsh-bitv-instructionp ins name p))
   (lsh-bitv (proper-p-lsh-bitv-instructionp ins name p))
   (or-bool (proper-p-or-bool-instructionp ins name p))
   (and-bool (proper-p-and-bool-instructionp ins name p))
   (not-bool (proper-p-not-bool-instructionp ins name p))
   (otherwise f)))

(defn proper-p-instructionp1 (ins name p)
 (and
  (properp ins)
  (case
   (car ins)
   (call (proper-p-call-instructionp ins name p))
   (ret (proper-p-ret-instructionp ins name p))
   (locn (proper-p-locn-instructionp ins name p))
   (push-constant (proper-p-push-constant-instructionp ins name p))
   (push-local (proper-p-push-local-instructionp ins name p))
   (push-global (proper-p-push-global-instructionp ins name p))
   (push-ctrl-stk-free-size
    (proper-p-push-ctrl-stk-free-size-instructionp ins name p))
   (push-temp-stk-free-size
    (proper-p-push-temp-stk-free-size-instructionp ins name p))
   (push-temp-stk-index (proper-p-push-temp-stk-index-instructionp ins name p))
   (jump-if-temp-stk-full
    (proper-p-jump-if-temp-stk-full-instructionp ins name p))
   (jump-if-temp-stk-empty
    (proper-p-jump-if-temp-stk-empty-instructionp ins name p))
   (pop (proper-p-pop-instructionp ins name p))
   (pop* (proper-p-pop*-instructionp ins name p))
   (popn (proper-p-popn-instructionp ins name p))
   (pop-local (proper-p-pop-local-instructionp ins name p))
   (pop-global (proper-p-pop-global-instructionp ins name p))
   (pop-locn (proper-p-pop-locn-instructionp ins name p))
   (pop-call (proper-p-pop-call-instructionp ins name p))
   (fetch-temp-stk (proper-p-fetch-temp-stk-instructionp ins name p))
   (deposit-temp-stk (proper-p-deposit-temp-stk-instructionp ins name p))
   (jump (proper-p-jump-instructionp ins name p))
   (jump-case (proper-p-jump-case-instructionp ins name p))
   (pushj (proper-p-pushj-instructionp ins name p))
   (popj (proper-p-popj-instructionp ins name p))
   (set-local (proper-p-set-local-instructionp ins name p))
   (set-global (proper-p-set-global-instructionp ins name p))
   (test-nat-and-jump (proper-p-test-nat-and-jump-instructionp ins name p))
   (test-int-and-jump (proper-p-test-int-and-jump-instructionp ins name p))
   (test-bool-and-jump (proper-p-test-bool-and-jump-instructionp ins name p))
   (test-bitv-and-jump (proper-p-test-bitv-and-jump-instructionp ins name p))
   (no-op (proper-p-no-op-instructionp ins name p))
   (add-addr (proper-p-add-addr-instructionp ins name p))
   (sub-addr (proper-p-sub-addr-instructionp ins name p))
   (otherwise (proper-p-instructionp2 ins name p)))))

(prove-lemma proper-p-instructionp-is-proper-p-instructionp1 (rewrite)
  (equal (proper-p-instructionp ins name p)
         (proper-p-instructionp1 ins name p))
  ((enable proper-p-instructionp)))

(disable proper-p-instructionp-is-proper-p-instructionp1)

; The following theorem is the proper-p-instructionp2 analogoue of the
; next theorem, except that piton-opcodes has been expanded since
; I am using this as a rewrite rule.

(prove-lemma proper-p-instructionp2-implies-member-piton-opcodes (rewrite)
  (implies (proper-p-instructionp2 ins name p)
           (and (member (car ins)
                        '(CALL RET LOCN PUSH-CONSTANT PUSH-LOCAL PUSH-GLOBAL
                              PUSH-CTRL-STK-FREE-SIZE
                              PUSH-TEMP-STK-FREE-SIZE PUSH-TEMP-STK-INDEX
                              JUMP-IF-TEMP-STK-FULL JUMP-IF-TEMP-STK-EMPTY
                              POP POP* POPN POP-LOCAL POP-GLOBAL POP-LOCN
                              POP-CALL FETCH-TEMP-STK DEPOSIT-TEMP-STK JUMP
                              JUMP-CASE PUSHJ POPJ SET-LOCAL SET-GLOBAL
                              TEST-NAT-AND-JUMP TEST-INT-AND-JUMP
                              TEST-BOOL-AND-JUMP TEST-BITV-AND-JUMP NO-OP
                              ADD-ADDR SUB-ADDR EQ LT-ADDR FETCH DEPOSIT
                              ADD-INT ADD-INT-WITH-CARRY ADD1-INT SUB-INT
                              SUB-INT-WITH-CARRY SUB1-INT NEG-INT LT-INT
                              INT-TO-NAT ADD-NAT ADD-NAT-WITH-CARRY ADD1-NAT
                              SUB-NAT SUB-NAT-WITH-CARRY SUB1-NAT LT-NAT
                              MULT2-NAT MULT2-NAT-WITH-CARRY-OUT DIV2-NAT
                              OR-BITV AND-BITV NOT-BITV XOR-BITV RSH-BITV
                              LSH-BITV OR-BOOL AND-BOOL NOT-BOOL))
                (implies (equal (car ins) 'push-constant)
                         (proper-p-push-constant-instructionp ins name p))))) 

(disable proper-p-instructionp2)

(prove-lemma proper-p-instructionp-implies-member-piton-opcodes nil
  (implies (proper-p-instructionp ins name p)
           (and (member (car ins) (piton-opcodes))
                (implies (equal (car ins) 'push-constant)
                         (proper-p-push-constant-instructionp ins name p))))
  ((enable proper-p-instructionp-is-proper-p-instructionp1
           proper-p-instructionp1)
   (disable member)))

; The push-constant predicate checks that the constant is (possibly)
; a p-object.  The r level makes sure it is not a fake dl.  We need
; to know p-objects aren't dls:

(prove-lemma p-objectp-implies-not-dl (rewrite)
  (implies (p-objectp x p)
           (not (equal (car x) 'dl)))
  ((enable p-objectp type)))

; Any program defined within a proper-p-prog-segmentp has a properly
; labelled body:

(prove-lemma proper-p-prog-segmentp-contains-proper-labeled-p-instructionsp
  (rewrite)
  (implies (and (definedp name segment)
                (proper-p-prog-segmentp segment
                                        p))
           (proper-labeled-p-instructionsp
            (program-body (assoc name segment))
            name p))
  ((enable proper-p-programp proper-p-program-bodyp name)))

; So, if you have a proper list of instructions at the p level then
; it is proper at the r level, provided the name is defined within
; a proper-p-prog-segmentp.

(prove-lemma proper-p-instructionp-implies-r-instructionp (rewrite)
  (implies (and (proper-p-instructionp ins name p)
                (definedp name (p-prog-segment p))
                (proper-p-prog-segmentp (p-prog-segment p) p))
           (r-instructionp ins))
  ((use (proper-p-instructionp-implies-member-piton-opcodes)
        (proper-labeled-p-instructionsp-implies-litatom-labels
         (lst (program-body (assoc name (p-prog-segment p))))
         (lab (cadr ins))))
   (disable *1*piton-opcodes piton-opcodes)
   (enable r-instructionp
           proper-p-push-constant-instructionp)))

; Consequently, a properly labelled sequence of instructions at the p
; level is a proper sequence at the r level -- this is just an induction
; applying the lemma above.

(prove-lemma proper-labeled-p-instructionsp-implies-r-program-bodyp (rewrite)
   (implies (and (proper-labeled-p-instructionsp lst name p)
                 (definedp name (p-prog-segment p))
                 (proper-p-prog-segmentp (p-prog-segment p) p))
            (r-program-bodyp lst)))

; So a proper p prog-segment is a proper r prog-segment.  But it is
; pretty tricky to state a general enough lemma.  The trouble is that we
; need to induct on the segment while holding the state and its prog-segment
; fixed.  We need the auxiliary concept that every name in one segment
; is defined in the state's:

(defn all-names-definedp (segment1 segment2)
  (if (nlistp segment1)
      t
      (and (definedp (name (car segment1)) segment2)
           (all-names-definedp (cdr segment1) segment2))))

; Now we can state the essence of the theorem:

(prove-lemma proper-p-prog-segmentp-implies-r-prog-segmentp-generalized nil
  (implies (and (proper-p-prog-segmentp segment p)
                (all-names-definedp segment (p-prog-segment p))
                (proper-p-prog-segmentp (p-prog-segment p) p))
           (r-prog-segmentp segment))
  ((enable proper-p-programp proper-p-program-bodyp)))

; But of course,

(prove-lemma all-names-definedp-cdr (rewrite)
  (implies (all-names-definedp x (cdr y))
           (all-names-definedp x y)))

(prove-lemma all-names-definedp-reflexive (rewrite)
  (all-names-definedp segment segment)
  ((enable name)))

; And so we can instantiate the lemma above,
; proper-p-prog-segmentp-implies-r-prog-segmentp-generalized, with
; segment replaced by (p-prog-segment p) and collapse the hyps to get:

(prove-lemma proper-p-prog-segmentp-implies-r-prog-segmentp (rewrite)
  (implies (proper-p-prog-segmentp (p-prog-segment p) p)
           (r-prog-segmentp (p-prog-segment p)))
  ((use (proper-p-prog-segmentp-implies-r-prog-segmentp-generalized
         (segment (p-prog-segment p))))))

; Whew!  The delicacy of that proof really surprised me.

; So, now we move on the next part of the proper-r-statep predicate,
; the consideration of the usr-data-segment.

; The core of course is just showing that p-objects are 
; r-usr-data-objects.  Then we lift it up through several layers
; of recursion.

(prove-lemma p-objectp-implies-r-usr-data-typep (rewrite)
  (implies (p-objectp x p)
           (r-usr-data-typep (type x)))
  ((enable p-objectp r-usr-data-typep)))

(prove-lemma p-objectp-implies-r-usr-data-objectp (rewrite)
  (implies (and (p-objectp x p)
                (same-signature r-usr-data-segment
                                (p-data-segment p)))
           (r-usr-data-objectp x
                               (r-state r-pc r-cfp r-csp r-tsp r-x r-y
                                        r-c-flg r-v-flg r-n-flg r-z-flg
                                        (p-prog-segment p)
                                        r-usr-data-segment
                                        r-sys-data-segment
                                        (p-word-size p)
                                        r-psw)))
  ((enable r-usr-data-objectp)))

(prove-lemma all-p-objectps-implies-all-r-usr-data-objectps (rewrite)
  (implies (and (all-p-objectps lst p)
                (same-signature r-usr-data-segment
                                (p-data-segment p)))
           (all-r-usr-data-objectps lst
                                    (r-state r-pc r-cfp r-csp r-tsp r-x
                                             r-y r-c-flg r-v-flg r-n-flg
                                             r-z-flg
                                             (p-prog-segment p)
                                             r-usr-data-segment
                                             r-sys-data-segment
                                             (p-word-size p)
                                             r-psw))))

(prove-lemma proper-p-data-segmentp-implies-proper-r-usr-data-segmentp
             (rewrite)
  (implies (and (proper-p-data-segmentp segment p)
                (same-signature r-usr-data-segment
                                (p-data-segment p)))
           (proper-r-usr-data-segmentp segment
                                       (r-state r-pc r-cfp r-csp r-tsp r-x
                                                r-y r-c-flg r-v-flg r-n-flg
                                                r-z-flg
                                                (p-prog-segment p)
                                                r-usr-data-segment
                                                r-sys-data-segment
                                                (p-word-size p)
                                                r-psw))))


; That completes the data segment work.  Finally, we consider the question
; of loadability.

; The need for the second and third hypotheses surprised me. The size
; of the mapped down stacks is as expected only if the p level stacks
; are sufficiently small.

(prove-lemma p-loadablep-implies-r-loadablep (rewrite)
  (implies (and (p-loadablep p load-addr)
                (not (lessp (p-max-ctrl-stk-size p)
                            (p-ctrl-stk-size (p-ctrl-stk p))))
                (not (lessp (p-max-temp-stk-size p)
                            (length (p-temp-stk p)))))
           (lessp
            (plus
             load-addr
             (segment-length (p-data-segment p))
             (segment-length (icompile (p-prog-segment p)))
             (segment-length (p->r_sys-data-segment (p-ctrl-stk p)
                                                    (p-max-ctrl-stk-size p)
                                                    (p-temp-stk p)
                                                    (p-max-temp-stk-size p))))
            (exp 2 (p-word-size p))))
  ((disable lessp)
   (enable p-loadablep p->r_sys-data-segment)))

; So, here we are at what we wanted:  proper states map
; down from p to r.

(prove-lemma proper-p-statep-implies-proper-r-statep (rewrite)
  (implies (and (proper-p-statep p)
                (p-loadablep p load-addr))
           (proper-r-statep (p->r p) load-addr))
  ((enable proper-r-statep r-objectp-type proper-p-statep-restructuring p->r)
   (disable proper-r-statep-properties)))

; So we can now complete the p-r level proof by just observing the
; usual things about the treatment of errors.

(prove-lemma once-errorp-always-errorp-step{special} (rewrite)
  (implies (not (errorp (p-psw (p-step p))))
           (not (errorp (p-psw p)))))

(prove-lemma once-errorp-always-errorp{special} (rewrite)
  (implies (not (errorp (p-psw (p p n))))
           (not (errorp (p-psw p))))
  ((disable p-step)))

; The following lemma wasn't necessary until I added load-addr.  Its
; only purpose is to solve a free-var problem in r-preserves-r-equal.
; Essentially it is just that lemma except we've gone ahead and
; backchained up to (p-loadablep p load-addr) so that the
; instantiation of load-addr can be found in
; one-way-correspondence-p-r immediately below.

(prove-lemma r-preserves-r-equal-bridge (rewrite) 
  (implies (and (proper-p-statep p) 
                (p-loadablep p load-addr) 
                (proper-r-statep r2 load-addr) 
                (r-equal r2 (r-step (p->r p)))) 
           (r-equal (r r2 n) (r (r-step (p->r p)) n)))
  ((disable r-step p->r proper-r-statep r-equal r)
   (use (r-preserves-r-equal (r1 (r-step (p->r p))))
        (proper-p-statep-implies-proper-r-statep))))

(prove-lemma one-way-correspondence-p-r (rewrite)
 (implies (and (proper-p-statep p)
               (p-loadablep p load-addr)
               (not (errorp (p-psw (p p n)))))
          (r-equal (p->r (p p n))
                   (r (p->r p) n)))
 ((induct (p p n))
  (disable p-step errorp)))

(prove-lemma p-preserves-proper-p-statep (rewrite)
  (implies (and (proper-p-statep p)
                (not (errorp (p-psw (p p n)))))
           (proper-p-statep (p p n)))
  ((induct (p p n))
   (disable p-step errorp)))

; Book: prim.events (sort of).  This section contains an informal
; sketch of how all of the foregoing are put together into the final
; result.

; In the FM8502 script this informal sketch was followed by its
; formalization: we were virtually done at this point.  This section
; began as prim.events which just imported the names enabled below,
; proved a few little helpers, and then combined the results to get
; the map from P down to FM8502.  But when we tried to do that for
; FM9001 we learned that to get the map up from FM9001 to M we needed
; a constraint on the link tables having to do with the size of the
; physical memory.  (In the first effort to move Piton to FM9001 we
; proved the map down and just left the map up for this section,
; thinking it would be simple.  When we discovered the problem, we
; defined the constraint (PLAUSIBLE-DATA-LINK-TABLEP) in the section
; on m to FM9001 and we proved that it was sufficient to get the map
; up, but we did not show that the plausibility condition was
; satisfied.  We left that for here because its satisfaction is tied
; up with the notion of same-signature, which was not available at the
; time we defined plausibility.)

; So this section of the script begins the final assault on the proof
; but then has a long "digression" were we show how to get the
; plausibility condition.

(set-status close-data-base-5 t ((boot-strap initial)
                                 (add-shell enable)
                                 (*1*defn enable)
                                 (defn disable)
                                 (otherwise disable)))

(enable-theory (proper-p-statep-implies-proper-r-statep
                proper-r-statep-implies-proper-i-user-data-segmentp
                proper-r-statep-r
                proper-r-statep-r-step
                proper-r-statep-implies-i-state-okp-r->i
                display-fm9001-data-segment-m->fm9001
                display-m-data-segment-inverts-i->m
                i-link-tables-i
                i-state-okp-i-ins-step))

(prove-lemma fm9001-m-owc (rewrite)
  (implies (proper-m-statep m)
           (equal (fm9001 (m->fm9001 m) n)
                  (m->fm9001 (m m n))))
  ((use (one-way-correspondence-m-fm9001))))

(prove-lemma i-m-owc (rewrite)
  (implies (and (numberp load-addr)
                (equal (i-psw (i i n load-addr)) 'run)
                (equal (i-word-size i) 32))
           (equal (m (i->m i boot-lst load-addr) n)
                  (i->m (i i n load-addr) boot-lst load-addr)))
  ((use (i-m-one-way-correspondence))))

; (This one was oriented the other way.)

(prove-lemma r-i-owc (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (numberp load-addr)
                (not (errorp (r-psw (r r n)))))
           (equal (i (r->i r)
                     (clock r n) load-addr)
                  (r->i (r r n))))  
  ((use (one-way-correspondence-r-i))))

; (This one was oriented the other way.)

(prove-lemma p-r-owc-corrolary (rewrite)
  (implies (and (proper-p-statep p)
                (p-loadablep p load-addr)
                (not (errorp (p-psw (p p n)))))
           (and (equal (r-psw (r (p->r p) n)) (p-psw (p p n)))
                (equal (r-usr-data-segment (r (p->r p) n))
                       (p-data-segment (p p n)))))
  ((enable r-equal p->r)
   (use (one-way-correspondence-p-r))))

; (This one was packaged up with R-EQUAL and now we are just interested
; in the equality of the psw and data segment components.)

; The three owc theorems have hypotheses about word-size, proper states,
; and psws.  The proper states hyps are all obtainable from the
; proper-p-statep in the top goal and the previously noted theorem
; that proper-p-statep implies proper-r-statep of p->r and the corresponding
; relation down to the i-level by r->i.  However, the lemma that we
; can get from proper r states to proper i states is not a REWRITE
; rule and so we package it up now:

(prove-lemma proper-r-statep-implies-i-state-okp-r->i-rewrite (rewrite)
             (implies (and (proper-r-statep r load-addr)
                           (not (errorp (r-psw r))))
                      (i-state-okp (r->i r) load-addr))
             ((use (proper-r-statep-implies-i-state-okp-r->i))))

; The main theorem contains the hypothesis that the word size at the p-level
; is 32.  But our i-m-owc requires that the word size at the i level be 32.
; Clearly we need to know that the word size is the same all the way down:

(prove-lemma i-word-size-r->i (rewrite)
  (equal (i-word-size (r->i r)) (r-word-size r))
  ((enable r->i)))

(prove-lemma r-word-size-p->r (rewrite)
  (equal (r-word-size (p->r p)) (p-word-size p))
  ((enable p->r)))

; Similarly, the main theorem gives us that the final p-psw is not an errorp.
; But the i-m-owc requires that the final i-psw is 'run.  The corrollary to
; the p-r-owc gives us that the r-psw is not an error.  So it suffices to
; observe

(prove-lemma i-psw-r->i (rewrite)
  (implies (not (errorp (r-psw r)))
           (equal (i-psw (r->i r)) 'run))
  ((enable errorp r->i)))

; That completes the preliminaries.  We will use the three owcs without
; further attention to their hyps.  We now give the proof of the top goal.

; Note:  The following comments are from the FM8502 proof.  But all of this
; still holds except that we now have one more mapping function, M->FM9001,
; after i->m.

; Consider the display-m-data-segment expression in the top goal:

; (display-m-data-segment (fm8502 (i->m (r->i (p->r p0)) boot-lst load-addr) ...) ...)

; By the equivalence of m and fm8502, this becomes

; (display-m-data-segment (m (i->m (r->i (p->r p0)) boot-lst load-addr) ...) ...).

; Then, by i-m-owc, the i->m is brought outside the m to produce:

; (display-m-data-segment (i->m (i (r->i (p->r p0)) n load-addr) boot-lst load-addr) ...).

; Then, by r-i-owc, the r->i is brought outside the i:

; (display-m-data-segment (i->m (r->i (r (p->r p0) n)) boot-lst load-addr)
;                         (type-specification (p-data-segment (p p0 n)))
;                         (link-tables p0 load-addr))

; In addition, link-tables expands and we get:

; (display-m-data-segment (i->m (r->i (r (p->r p0) n)) boot-lst load-addr)
;                         (type-specification (p-data-segment (p p0 n)))
;                         (i-link-tables (r->i (p->r p0)) load-addr))

; We wish that would match the left-hand side of the conclusion of
; display-m-data-segment-inverts-i->m, said conclusion being:

; (equal (display-m-data-segment (i->m i boot-lst load-addr)
;                                (type-specification (i-usr-data-segment i))
;                                (i-link-tables i load-addr))
;        (i-usr-data-segment i)))

; But it does not because of the second and third args.

; We therefore build a bridged version of the lemma noted above.  It
; is:

(prove-lemma display-m-data-segment-inverts-i->m-bridge (rewrite)
   (implies (and (numberp load-addr)
                 (proper-i-usr-data-segmentp (i-usr-data-segment i) i)
                 (i-state-okp i load-addr)
                 (equal type-spec (type-specification (i-usr-data-segment i)))
                 (equal link-tables (i-link-tables i load-addr)))
            (equal (display-m-data-segment (i->m i boot-lst load-addr)
                                           type-spec
                                           link-tables)
                   (i-usr-data-segment i)))
   ((use (display-m-data-segment-inverts-i->m))))

; Suppose we could relieve the four hyps.   Then the top goal would reduce
; to:

;  (equal (i-usr-data-segment (r->i (r (p->r p0) n)))
;         (p-data-segment (p p0 n))).

; But we know

(prove-lemma i-usr-data-segment-r->i (rewrite)
   (equal (i-usr-data-segment (r->i r))
          (r-usr-data-segment r))
   ((enable r->i)))

; So the top goal becomes:

;  (equal (r-usr-data-segment (r (p->r p0) n))
;         (p-data-segment (p p0 n))).

; which t by the corrollary of p-r-owc.

; So it only remains to relieve the hypotheses of the bridged display lemma 
; above.  There are four:

; Hyp1. (proper-i-usr-data-segmentp (i-usr-data-segment i) i)
; Hyp2. (i-state-okp i load-addr)
; Hyp3. (equal type-spec (type-specification (i-usr-data-segment i)))
; Hyp4. (equal link-tables (i-link-tables i load-addr)))

; where i           is   (r->i (r (p->r p0) n))
;       type-spec   is   (type-specification (p-data-segment (p p0 n)))
;       link-tables is   (i-link-tables (r->i (p->r p0)) load-addr)

; We deal with them in turn.

; Hyp1.  The fully instantiated first hypothesis is:

;   (proper-i-usr-data-segmentp (i-usr-data-segment (r->i (r (p->r p0) n)))
;                               (r->i (r (p->r p0) n)))

; If we apply the previous rule for simplifying the i-usr-data-segment of
; r->i, we would get:

;   (proper-i-usr-data-segmentp (r-usr-data-segment (r (p->r p0) n))
;                               (r->i (r (p->r p0) n)))

; This would immediately match the imported theorem
; proper-r-statep-implies-proper-i-user-data-segmentp
; and we would only have to establish that (r (p->r p0) n) was a
; proper-r-statep.  This follows from the fact that p->r is a
; proper-r-statep (since p0 is a proper-p-statep) and r preserves
; proper-r-statep.  [Note:  we could have relied on p preserving
; proper-p-statep, but then we'd need to express the r term above
; as (p->r (p p0 n)).]

; But this simple argument doesn't work because of the presence of
; the p-r-owc corrollary.  In particular, (r-usr-data-segment (r (p->r p0) n))
; rewrites to (p-data-segment (p p0 n)) by the corrollary and we no
; longer get the match on proper-r-statep-implies-proper-i-user-data-segmentp.

; So we prove a bridged version of that rule:

(prove-lemma proper-r-statep-implies-proper-i-user-data-segmentp-bridge
             (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (equal segment (r-usr-data-segment r)))
           (proper-i-usr-data-segmentp segment
                                       (r->i r)))
  ((use (proper-r-statep-implies-proper-i-user-data-segmentp))))

; That completes hyp1.

; Hyp2.  (i-state-okp (r->i (r (p->r p0) n)) load-addr) follows from the fact that
; r->i produces okp i states from proper r states.

; Hyp3.  The third hypothesis to prove is that the equivalence of

;    (type-specification (p-data-segment (p p0 n)))

; and

;    (type-specification (i-usr-data-segment (r->i (r (p->r p0 n))))).

; The first is what occurs in the top goal; the second is what our lemma
; expects.  But the previously noted fact about the i-usr-data-segment
; of r->i reduces the second to:

;    (type-specification (r-usr-data-segment (r (p->r p0 n))))

; And the corrollary of p-r-owc reduces that to the first.

; Hyp4.  The last hypothesis is the equivalence of

;    (i-link-tables (r->i (p->r p0)) load-addr)

; and

;    (i-link-tables (r->i (r (p->r p0) n)) load-addr).

; Observe that what we are asked to show is that execution on the r machine
; preserves the i-link-tables (computed from mapped down r states).  But
; we know that the i machine preserves link tables.  And we know, from
; r-i-owc, that any mapped down r computation can be seen as an i computation
; on the mapped down states.  So the above requirement follows.  Here is
; a formal rendering of it:

(prove-lemma i-link-tables-r->i (rewrite)
  (implies (and (numberp load-addr)
                (equal (r-word-size r0) 32)
                (proper-r-statep r0 load-addr)
                (not (errorp (r-psw (r r0 n)))))
           (equal (i-link-tables (r->i (r r0 n)) load-addr)
                  (i-link-tables (r->i r0) load-addr)))
  ((use (i-link-tables-i
         (i (r->i r0))
         (n (clock r0 n))
         (load-addr load-addr)))))


; That completes the proof of FM8501 Piton.  We have to define the
; witness function, FM8502-CLOCK, but that is easy:

(defn fm9001-clock (p n)
  (clock (p->r p) n))

; Note:  In the FM8502 script we were in fact done!  Here we simply
; put top-goal.  But no longer.  We must relieve the plausibility
; constraint.

; Book: plausibility.  We now depart from the FM8502 proof and begin
; to work on deriving the plausibility condition from the fact that
; the initial p state is proper.  We ultimately have to establish that
; the intermediate machines preserve the word size of the state as
; well as the signatures of the program and data segments.

(prove-lemma bvp-listp-append (rewrite)
  (implies (bvp-listp a)
           (equal (bvp-listp (append a b))
                  (bvp-listp b)))
  ((enable bvp-listp append)))

(prove-lemma bvp-listp-link-area (rewrite)
  (bvp-listp (link-area lst link-tables 32))
  ((enable bvp-listp link-area bvp-link-word size-link-word)))

(prove-lemma bvp-listp-link-segment (rewrite)
  (bvp-listp (link-segment lst link-tables 32))
  ((enable bvp-listp link-segment)))

(prove-lemma bvp-listp-boot-code (rewrite)
  (bvp-listp (boot-code boot-lst n 32))
  ((enable boot-code bvp-listp length-nat-to-v bvp-nat-to-v)))

(prove-lemma proper-m-statep-i->m (rewrite)
  (implies (and (equal (i-word-size i) 32)
                (i-loadablep i load-addr))
           (proper-m-statep (i->m i boot-lst load-addr)))
  ((enable length-boot-code
           proper-m-statep i->m bvp-listp bvp-link-word SIZE-LINK-WORD i-loadablep
           total-i-system-size link-mem length-append
           LENGTH-LINK-SEGMENT-IS-SEGMENT-LENGTH length-cons)))

(prove-lemma i-loadable-r->i (rewrite)
  (implies (proper-r-statep r load-addr)
           (i-loadablep (r->i r) load-addr))
  ((enable proper-r-statep r-loadablep total-r-system-size
           i-loadablep r->i total-i-system-size)))

; I need to show that r preserves the word-size.  It surprises me that I haven't
; proved this at every level.  I apparently haven't proved this at any level!

(prove-lemma r-word-size-r-step1 (rewrite)
  (equal (r-word-size (r-step1 ins r)) (r-word-size r))
  ((enable r-step1 r-ins-step
            R-CALL-STEP
            R-RET-STEP
            R-LOCN-STEP
            R-PUSH-CONSTANT-STEP
            R-PUSH-LOCAL-STEP
            R-PUSH-GLOBAL-STEP
            R-PUSH-CTRL-STK-FREE-SIZE-STEP
            R-PUSH-TEMP-STK-FREE-SIZE-STEP
            R-PUSH-TEMP-STK-INDEX-STEP
            R-JUMP-IF-TEMP-STK-FULL-STEP
            R-JUMP-IF-TEMP-STK-EMPTY-STEP
            R-POP-STEP
            R-POP*-STEP
            R-POPN-STEP
            R-POP-LOCAL-STEP
            R-POP-GLOBAL-STEP
            R-POP-LOCN-STEP
            R-POP-CALL-STEP
            R-FETCH-TEMP-STK-STEP
            R-DEPOSIT-TEMP-STK-STEP
            R-JUMP-STEP
            R-JUMP-CASE-STEP
            R-PUSHJ-STEP
            R-POPJ-STEP
            R-SET-LOCAL-STEP
            R-SET-GLOBAL-STEP
            R-TEST-NAT-AND-JUMP-STEP
            R-TEST-INT-AND-JUMP-STEP
            R-TEST-BOOL-AND-JUMP-STEP
            R-TEST-BITV-AND-JUMP-STEP
            R-TEST-AND-JUMP-STEP
            R-NO-OP-STEP
            R-ADD-ADDR-STEP
            R-SUB-ADDR-STEP
            R-EQ-STEP
            R-LT-ADDR-STEP
            R-FETCH-STEP
            R-DEPOSIT-STEP
            R-ADD-INT-STEP
            R-ADD-INT-WITH-CARRY-STEP
            R-ADD1-INT-STEP
            R-SUB-INT-STEP
            R-SUB-INT-WITH-CARRY-STEP
            R-SUB1-INT-STEP
            R-NEG-INT-STEP
            R-LT-INT-STEP
            R-INT-TO-NAT-STEP
            R-ADD-NAT-STEP
            R-ADD-NAT-WITH-CARRY-STEP
            R-ADD1-NAT-STEP
            R-SUB-NAT-STEP
            R-SUB-NAT-WITH-CARRY-STEP
            R-SUB1-NAT-STEP
            R-LT-NAT-STEP
            R-MULT2-NAT-STEP
            R-MULT2-NAT-WITH-CARRY-OUT-STEP
            R-DIV2-NAT-STEP
            R-OR-BITV-STEP
            R-AND-BITV-STEP
            R-NOT-BITV-STEP
            R-XOR-BITV-STEP
            R-RSH-BITV-STEP
            R-LSH-BITV-STEP
            R-OR-BOOL-STEP
            R-AND-BOOL-STEP
            R-NOT-BOOL-STEP
            R-HALT)))

(prove-lemma r-word-size-r-step (rewrite)
  (equal (r-word-size (r-step r)) (r-word-size r))
  ((enable r-step)))

(prove-lemma r-word-size-r (rewrite)
  (equal (r-word-size (r r n)) (r-word-size r))
  ((enable r)))

; I have confirmed that if we add the following PLAUSIBLE-TYPE-
; SPEC-AND-LINK-TABLESP instance as an axiom, we can prove top-goal.
; So the entire problem reduces to that described below.  Everything
; between here and the proof of consolidated-plausibility-argument was
; created over a 3 day period (Oct 9-11, 1991) in order to establish
; the plausibility hypothesis necessary to apply DISPLAY-FM9001-
; DATA-SEGMENT-M->FM9001.  That hypothesis is:

; (PLAUSIBLE-DATA-LINK-TABLEP
;         (TYPE-SPECIFICATION (P-DATA-SEGMENT (P P0 N)))
;         (LENGTH (M-MEM (I->M (R->I (R (P->R P0) N)) boot-lst LOAD-ADDR)))
;         (USR-DATA-LINKS (I-LINK-TABLES (R->I (P->R P0)) LOAD-ADDR)))
; under the assumptions
; (NOT (ERRORP (P-PSW (P P0 N))))
; (EQUAL (P-WORD-SIZE P0) 32)
; (P-LOADABLEP P0 LOAD-ADDR)
; (PROPER-P-STATEP P0)

; Plausibility insures that, for each area in the type-spec, the base address of
; the area plus the length of the area must be less than or equal to the length of
; the memory.  

; We start by noting 

(prove-lemma same-signature-plausible-data-link-tablep nil
  (implies (and (same-signature seg1 seg2)
                (plausible-data-link-tablep (type-specification seg1)
                                            n
                                            table))
           (plausible-data-link-tablep (type-specification seg2)
                                       n
                                       table))
  ((enable same-signature plausible-data-link-tablep type-specification
           signature area-type-specification length-type-lst length)))

(prove-lemma same-signature-reflexive-1 (rewrite)
  (same-signature segment segment)
  ((use (same-signature-reflexive))))

(prove-lemma proper-p-data-segmentp-proper-alistp (rewrite)
  (implies (proper-p-data-segmentp x p) (proper-alistp x))
  ((enable proper-p-data-segmentp
           proper-p-data-segmentp
           proper-p-area
           proper-alistp)))

(prove-lemma proper-alistp-p-data-segment (rewrite)
  (implies (proper-p-statep p)
           (proper-alistp (p-data-segment p)))
  ((enable proper-p-statep-restructuring
           proper-p-statep1)))

; Our next goal is to prove that the p machine does not change the
; signature of the data segment.  Most instructions don't change
; the data segment at all and the corresponding lemma can be proved
; without using most of the hypotheses provided.  But we make all of the
; lemmas of the same form simply so we can use an Emacs macro to
; create them all.  Had these proofs been done at the appropriate
; stage in the proof of the p-r, we would not need to give the hints.

(prove-lemma same-signature-p-ins-step-call (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'call)
                (proper-p-statep p)
                (p-call-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-call-step (p-current-instruction p) p))))
  ((enable p-call-step)))

(prove-lemma same-signature-p-ins-step-ret (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'ret)
                (proper-p-statep p)
                (p-ret-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-ret-step (p-current-instruction p) p))))
  ((enable p-ret-step p-halt)))

(prove-lemma same-signature-p-ins-step-locn (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'locn)
                (proper-p-statep p)
                (p-locn-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-locn-step (p-current-instruction p) p))))
  ((enable p-locn-step)))

(prove-lemma same-signature-p-ins-step-push-constant (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-constant)
                (proper-p-statep p)
                (p-push-constant-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-constant-step (p-current-instruction p) p))))
  ((enable p-push-constant-step)))

(prove-lemma same-signature-p-ins-step-push-local (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-local)
                (proper-p-statep p)
                (p-push-local-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-local-step (p-current-instruction p) p))))
  ((enable p-push-local-step)))

(prove-lemma same-signature-p-ins-step-push-global (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-global)
                (proper-p-statep p)
                (p-push-global-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-global-step (p-current-instruction p) p))))
  ((enable p-push-global-step)))

(prove-lemma same-signature-p-ins-step-push-ctrl-stk-free-size (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-ctrl-stk-free-size)
                (proper-p-statep p)
                (p-push-ctrl-stk-free-size-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-ctrl-stk-free-size-step (p-current-instruction p) p))))
  ((enable p-push-ctrl-stk-free-size-step)))

(prove-lemma same-signature-p-ins-step-push-temp-stk-free-size (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-temp-stk-free-size)
                (proper-p-statep p)
                (p-push-temp-stk-free-size-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-temp-stk-free-size-step (p-current-instruction p) p))))
  ((enable p-push-temp-stk-free-size-step)))

(prove-lemma same-signature-p-ins-step-push-temp-stk-index (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'push-temp-stk-index)
                (proper-p-statep p)
                (p-push-temp-stk-index-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-push-temp-stk-index-step (p-current-instruction p) p))))
  ((enable p-push-temp-stk-index-step)))

(prove-lemma same-signature-p-ins-step-jump-if-temp-stk-full (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'jump-if-temp-stk-full)
                (proper-p-statep p)
                (p-jump-if-temp-stk-full-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-jump-if-temp-stk-full-step (p-current-instruction p) p))))
  ((enable p-jump-if-temp-stk-full-step)))

(prove-lemma same-signature-p-ins-step-jump-if-temp-stk-empty (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'jump-if-temp-stk-empty)
                (proper-p-statep p)
                (p-jump-if-temp-stk-empty-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-jump-if-temp-stk-empty-step (p-current-instruction p) p))))
  ((enable p-jump-if-temp-stk-empty-step)))

(prove-lemma same-signature-p-ins-step-pop (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop)
                (proper-p-statep p)
                (p-pop-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop-step (p-current-instruction p) p))))
  ((enable p-pop-step)))

(prove-lemma same-signature-p-ins-step-pop* (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop*)
                (proper-p-statep p)
                (p-pop*-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop*-step (p-current-instruction p) p))))
  ((enable p-pop*-step)))

(prove-lemma same-signature-p-ins-step-popn (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'popn)
                (proper-p-statep p)
                (p-popn-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-popn-step (p-current-instruction p) p))))
  ((enable p-popn-step)))

(prove-lemma same-signature-p-ins-step-pop-local (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop-local)
                (proper-p-statep p)
                (p-pop-local-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop-local-step (p-current-instruction p) p))))
  ((enable p-pop-local-step)))

; So here is the first occasion on which we need to investigate the hyps to
; get the proof.  An important fact here is that since the state is proper
; the programs are all proper so that the pop-global instruction we are
; executing references a legal area name in the data section.  If it did not
; the resulting deposit would change the signature!  Similarly, we must know that
; the length of the area is sufficient.  We have to enable the rules that were
; freely available during the p-r correspondence work.

(prove-lemma same-signature-p-ins-step-pop-global (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop-global)
                (proper-p-statep p)
                (p-pop-global-okp (p-current-instruction p)
                                  p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop-global-step (p-current-instruction p) p))))
  ((enable proper-p-statep-restructuring
           proper-p-instructionp-opener
           PROPER-P-POP-GLOBAL-INSTRUCTIONP
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           DEFINEDP-P-DATA-SEGMENT-IMPLIES-LISTP
           same-signature-deposit-adp
           p-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           p-pop-global-okp
           p-pop-global-step
           p-objectp-type
           p-objectp
           adpp)))

(prove-lemma same-signature-p-ins-step-pop-locn (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop-locn)
                (proper-p-statep p)
                (p-pop-locn-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop-locn-step (p-current-instruction p) p))))
  ((enable p-pop-locn-step)))

(prove-lemma same-signature-p-ins-step-pop-call (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pop-call)
                (proper-p-statep p)
                (p-pop-call-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pop-call-step (p-current-instruction p) p))))
  ((enable p-pop-call-step p-call-step)))

(prove-lemma same-signature-p-ins-step-fetch-temp-stk (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'fetch-temp-stk)
                (proper-p-statep p)
                (p-fetch-temp-stk-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-fetch-temp-stk-step (p-current-instruction p) p))))
  ((enable p-fetch-temp-stk-step)))

(prove-lemma same-signature-p-ins-step-deposit-temp-stk (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'deposit-temp-stk)
                (proper-p-statep p)
                (p-deposit-temp-stk-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-deposit-temp-stk-step (p-current-instruction p) p))))
  ((enable p-deposit-temp-stk-step)))

(prove-lemma same-signature-p-ins-step-jump (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'jump)
                (proper-p-statep p)
                (p-jump-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-jump-step (p-current-instruction p) p))))
  ((enable p-jump-step)))

(prove-lemma same-signature-p-ins-step-jump-case (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'jump-case)
                (proper-p-statep p)
                (p-jump-case-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-jump-case-step (p-current-instruction p) p))))
  ((enable p-jump-case-step)))

(prove-lemma same-signature-p-ins-step-pushj (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'pushj)
                (proper-p-statep p)
                (p-pushj-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-pushj-step (p-current-instruction p) p))))
  ((enable p-pushj-step)))

(prove-lemma same-signature-p-ins-step-popj (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'popj)
                (proper-p-statep p)
                (p-popj-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-popj-step (p-current-instruction p) p))))
  ((enable p-popj-step)))

(prove-lemma same-signature-p-ins-step-set-local (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'set-local)
                (proper-p-statep p)
                (p-set-local-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-set-local-step (p-current-instruction p) p))))
  ((enable p-set-local-step)))

(prove-lemma same-signature-p-ins-step-set-global (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'set-global)
                (proper-p-statep p)
                (p-set-global-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-set-global-step (p-current-instruction p) p))))
  ((enable proper-p-statep-restructuring
           proper-p-instructionp-opener
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           definedp-p-data-segment-implies-listp
           same-signature-deposit-adp
           p-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           PROPER-P-SET-GLOBAL-INSTRUCTIONP
           P-SET-GLOBAL-OKP
           P-SET-GLOBAL-STEP
           p-objectp-type
           p-objectp
           adpp)))

(prove-lemma same-signature-p-ins-step-test-nat-and-jump (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'test-nat-and-jump)
                (proper-p-statep p)
                (p-test-nat-and-jump-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-test-nat-and-jump-step (p-current-instruction p) p))))
  ((enable p-test-nat-and-jump-step p-test-and-jump-step)))

(prove-lemma same-signature-p-ins-step-test-int-and-jump (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'test-int-and-jump)
                (proper-p-statep p)
                (p-test-int-and-jump-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-test-int-and-jump-step (p-current-instruction p) p))))
  ((enable p-test-int-and-jump-step p-test-and-jump-step)))

(prove-lemma same-signature-p-ins-step-test-bool-and-jump (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'test-bool-and-jump)
                (proper-p-statep p)
                (p-test-bool-and-jump-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-test-bool-and-jump-step (p-current-instruction p) p))))
  ((enable p-test-bool-and-jump-step p-test-and-jump-step)))

(prove-lemma same-signature-p-ins-step-test-bitv-and-jump (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'test-bitv-and-jump)
                (proper-p-statep p)
                (p-test-bitv-and-jump-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-test-bitv-and-jump-step (p-current-instruction p) p))))
  ((enable p-test-bitv-and-jump-step p-test-and-jump-step)))

(prove-lemma same-signature-p-ins-step-no-op (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'no-op)
                (proper-p-statep p)
                (p-no-op-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-no-op-step (p-current-instruction p) p))))
  ((enable p-no-op-step)))

(prove-lemma same-signature-p-ins-step-add-addr (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add-addr)
                (proper-p-statep p)
                (p-add-addr-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add-addr-step (p-current-instruction p) p))))
  ((enable p-add-addr-step)))

(prove-lemma same-signature-p-ins-step-sub-addr (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub-addr)
                (proper-p-statep p)
                (p-sub-addr-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub-addr-step (p-current-instruction p) p))))
  ((enable p-sub-addr-step)))

(prove-lemma same-signature-p-ins-step-eq (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'eq)
                (proper-p-statep p)
                (p-eq-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-eq-step (p-current-instruction p) p))))
  ((enable p-eq-step)))

(prove-lemma same-signature-p-ins-step-lt-addr (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'lt-addr)
                (proper-p-statep p)
                (p-lt-addr-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-lt-addr-step (p-current-instruction p) p))))
  ((enable p-lt-addr-step)))

(prove-lemma same-signature-p-ins-step-fetch (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'fetch)
                (proper-p-statep p)
                (p-fetch-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-fetch-step (p-current-instruction p) p))))
  ((enable p-fetch-step)))

(prove-lemma same-signature-p-ins-step-deposit (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'deposit)
                (proper-p-statep p)
                (p-deposit-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-deposit-step (p-current-instruction p) p))))
  ((enable same-signature-deposit-adp
           litatom-adp-name
           deposit
           p-deposit-okp
           p-deposit-step
           p-objectp-type
           p-objectp
           adpp)))

(prove-lemma same-signature-p-ins-step-add-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add-int)
                (proper-p-statep p)
                (p-add-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add-int-step (p-current-instruction p) p))))
  ((enable p-add-int-step)))

(prove-lemma same-signature-p-ins-step-add-int-with-carry (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add-int-with-carry)
                (proper-p-statep p)
                (p-add-int-with-carry-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add-int-with-carry-step (p-current-instruction p) p))))
  ((enable p-add-int-with-carry-step)))

(prove-lemma same-signature-p-ins-step-add1-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add1-int)
                (proper-p-statep p)
                (p-add1-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add1-int-step (p-current-instruction p) p))))
  ((enable p-add1-int-step)))

(prove-lemma same-signature-p-ins-step-sub-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub-int)
                (proper-p-statep p)
                (p-sub-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub-int-step (p-current-instruction p) p))))
  ((enable p-sub-int-step)))

(prove-lemma same-signature-p-ins-step-sub-int-with-carry (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub-int-with-carry)
                (proper-p-statep p)
                (p-sub-int-with-carry-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub-int-with-carry-step (p-current-instruction p) p))))
  ((enable p-sub-int-with-carry-step)))

(prove-lemma same-signature-p-ins-step-sub1-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub1-int)
                (proper-p-statep p)
                (p-sub1-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub1-int-step (p-current-instruction p) p))))
  ((enable p-sub1-int-step)))

(prove-lemma same-signature-p-ins-step-neg-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'neg-int)
                (proper-p-statep p)
                (p-neg-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-neg-int-step (p-current-instruction p) p))))
  ((enable p-neg-int-step)))

(prove-lemma same-signature-p-ins-step-lt-int (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'lt-int)
                (proper-p-statep p)
                (p-lt-int-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-lt-int-step (p-current-instruction p) p))))
  ((enable p-lt-int-step)))

(prove-lemma same-signature-p-ins-step-int-to-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'int-to-nat)
                (proper-p-statep p)
                (p-int-to-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-int-to-nat-step (p-current-instruction p) p))))
  ((enable p-int-to-nat-step)))

(prove-lemma same-signature-p-ins-step-add-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add-nat)
                (proper-p-statep p)
                (p-add-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add-nat-step (p-current-instruction p) p))))
  ((enable p-add-nat-step)))

(prove-lemma same-signature-p-ins-step-add-nat-with-carry (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add-nat-with-carry)
                (proper-p-statep p)
                (p-add-nat-with-carry-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add-nat-with-carry-step (p-current-instruction p) p))))
  ((enable p-add-nat-with-carry-step)))

(prove-lemma same-signature-p-ins-step-add1-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'add1-nat)
                (proper-p-statep p)
                (p-add1-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-add1-nat-step (p-current-instruction p) p))))
  ((enable p-add1-nat-step)))

(prove-lemma same-signature-p-ins-step-sub-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub-nat)
                (proper-p-statep p)
                (p-sub-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub-nat-step (p-current-instruction p) p))))
  ((enable p-sub-nat-step)))

(prove-lemma same-signature-p-ins-step-sub-nat-with-carry (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub-nat-with-carry)
                (proper-p-statep p)
                (p-sub-nat-with-carry-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub-nat-with-carry-step (p-current-instruction p) p))))
  ((enable p-sub-nat-with-carry-step)))

(prove-lemma same-signature-p-ins-step-sub1-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'sub1-nat)
                (proper-p-statep p)
                (p-sub1-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-sub1-nat-step (p-current-instruction p) p))))
  ((enable p-sub1-nat-step)))

(prove-lemma same-signature-p-ins-step-lt-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'lt-nat)
                (proper-p-statep p)
                (p-lt-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-lt-nat-step (p-current-instruction p) p))))
  ((enable p-lt-nat-step)))

(prove-lemma same-signature-p-ins-step-mult2-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'mult2-nat)
                (proper-p-statep p)
                (p-mult2-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-mult2-nat-step (p-current-instruction p) p))))
  ((enable p-mult2-nat-step)))

(prove-lemma same-signature-p-ins-step-mult2-nat-with-carry-out (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'mult2-nat-with-carry-out)
                (proper-p-statep p)
                (p-mult2-nat-with-carry-out-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-mult2-nat-with-carry-out-step (p-current-instruction p) p))))
  ((enable p-mult2-nat-with-carry-out-step)))

(prove-lemma same-signature-p-ins-step-div2-nat (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'div2-nat)
                (proper-p-statep p)
                (p-div2-nat-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-div2-nat-step (p-current-instruction p) p))))
  ((enable p-div2-nat-step)))

(prove-lemma same-signature-p-ins-step-or-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'or-bitv)
                (proper-p-statep p)
                (p-or-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-or-bitv-step (p-current-instruction p) p))))
  ((enable p-or-bitv-step)))

(prove-lemma same-signature-p-ins-step-and-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'and-bitv)
                (proper-p-statep p)
                (p-and-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-and-bitv-step (p-current-instruction p) p))))
  ((enable p-and-bitv-step)))

(prove-lemma same-signature-p-ins-step-not-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'not-bitv)
                (proper-p-statep p)
                (p-not-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-not-bitv-step (p-current-instruction p) p))))
  ((enable p-not-bitv-step)))

(prove-lemma same-signature-p-ins-step-xor-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'xor-bitv)
                (proper-p-statep p)
                (p-xor-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-xor-bitv-step (p-current-instruction p) p))))
  ((enable p-xor-bitv-step)))

(prove-lemma same-signature-p-ins-step-rsh-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'rsh-bitv)
                (proper-p-statep p)
                (p-rsh-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-rsh-bitv-step (p-current-instruction p) p))))
  ((enable p-rsh-bitv-step)))

(prove-lemma same-signature-p-ins-step-lsh-bitv (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'lsh-bitv)
                (proper-p-statep p)
                (p-lsh-bitv-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-lsh-bitv-step (p-current-instruction p) p))))
  ((enable p-lsh-bitv-step)))

(prove-lemma same-signature-p-ins-step-or-bool (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'or-bool)
                (proper-p-statep p)
                (p-or-bool-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-or-bool-step (p-current-instruction p) p))))
  ((enable p-or-bool-step)))

(prove-lemma same-signature-p-ins-step-and-bool (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'and-bool)
                (proper-p-statep p)
                (p-and-bool-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-and-bool-step (p-current-instruction p) p))))
  ((enable p-and-bool-step)))

(prove-lemma same-signature-p-ins-step-not-bool (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (equal (car (p-current-instruction p))
                       'not-bool)
                (proper-p-statep p)
                (p-not-bool-okp (p-current-instruction p) p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-not-bool-step (p-current-instruction p) p))))
  ((enable p-not-bool-step)))

; We now put these all together.

(prove-lemma same-signature-p-ins-step (rewrite)
  (implies (and (equal (p-psw p) 'run)
                (p-ins-okp (p-current-instruction p) p)
                (proper-p-statep p))
           (same-signature (p-data-segment p)
                           (p-data-segment (p-ins-step (p-current-instruction p) p))))
  ((enable p-ins-okp p-ins-step)))

(prove-lemma same-signature-p-step (rewrite)
  (implies (proper-p-statep p)
           (same-signature (p-data-segment p)
                           (p-data-segment (p-step p))))
  ((enable p-step p-step1 p-halt)))

(prove-lemma same-signature-p-transitivity-lemma (rewrite)
  (IMPLIES (AND (NUMBERP N)
                (NOT (EQUAL N 0))
                (SAME-SIGNATURE (P-DATA-SEGMENT (P-STEP P))
                                (P-DATA-SEGMENT (P (P-STEP P) (SUB1 N))))
                (PROPER-P-STATEP P)
                (NOT (ERRORP (P-PSW (P (P-STEP P) (SUB1 N))))))
           (SAME-SIGNATURE (P-DATA-SEGMENT P)
                           (P-DATA-SEGMENT (P (P-STEP P) (SUB1 N)))))
  ((use (TRANSITIVITY-OF-SAME-SIGNATURE
         (segment1 (p-data-segment p))
         (segment2 (P-DATA-SEGMENT (P-STEP P)))
         (segment3 (P-DATA-SEGMENT (P (P-STEP P) (SUB1 N))))))))

(prove-lemma same-signature-p (rewrite)
  (implies (and (proper-p-statep p)
                (not (errorp (p-psw (p p n)))))
           (same-signature (p-data-segment p)
                           (p-data-segment (p p n))))
  ((enable p P-STEP-PRESERVES-PROPER-P-STATEP
           ONCE-ERRORP-ALWAYS-ERRORP{SPECIAL}
           ONCE-ERRORP-ALWAYS-ERRORP-STEP{SPECIAL})))

; What we wish to prove is:
; (PLAUSIBLE-DATA-LINK-TABLEP
;   (TYPE-SPECIFICATION (P-DATA-SEGMENT (P P0 N)))
;   (LENGTH (M-MEM (I->M (R->I (R (P->R P0) N)) boot-lst LOAD-ADDR)))
;   (USR-DATA-LINKS (I-LINK-TABLES (R->I (P->R P0)) LOAD-ADDR)))

; By instantiating same-signature-plausible-data-link-tablep with 
; (seg1 (p-data-segment p0))
; (seg2 (p-data-segment (p p0 n)))
; and applealing to same-signature-p, we can backchain from our goal to

; (PLAUSIBLE-DATA-LINK-TABLEP
;   (TYPE-SPECIFICATION (P-DATA-SEGMENT P0))
;   (LENGTH (M-MEM (I->M (R->I (R (P->R P0) N)) boot-lst LOAD-ADDR)))
;   (USR-DATA-LINKS (I-LINK-TABLES (R->I (P->R P0)) LOAD-ADDR)))

; Next I need to show that
; (length (m-mem (i->m (r->i (r pr n)) boot-lst load-addr)))
;  = (length (m-mem (i->m (r->i pr) boot-lst load-addr))).
; This follows from the fact that the r-prog-segment is unchanged by r and the
; signatures of both the usr-data-segment and sys-data-segment are unchanged.

; So now we undertake those proofs. (!)

(prove-lemma same-signature-r-ins-step-call (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'call)
                (proper-r-statep r load-addr)
                (r-call-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (r-call-step (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (r-call-step (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (r-call-step (r-current-instruction r) r)))))
  ((enable r-call-okp
           r-call-step
           push-stk
           sub1-addr
           sub-addr
           ADP-OFFSET-SUB-ADP
           ADP-NAME-SUB-ADP
           PROPER-R-STATEP-PROPERTIES
           LISTP-APPEND
           LENGTH-APPEND
           length-rev
           length-strip-cadrs
           length-fetch-n
           length-cons
           equal-plus-0
           free-stk-size
           local-vars
           length-strip-cars
           offset
           plus-add1
           difference-1
           plus-0
           commutativity-of-plus
           same-signature-deposit-lst
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           r-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           r-objectp-type
           r-objectp
           adpp
           )))

(prove-lemma same-signature-r-ins-step-RET (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'RET)
                (proper-r-statep r load-addr)
                (R-RET-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-RET-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-RET-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-RET-STEP (r-current-instruction r) r)))))
  ((enable R-RET-STEP r-halt)))

(prove-lemma same-signature-r-ins-step-LOCN (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'LOCN)
                (proper-r-statep r load-addr)
                (R-LOCN-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-LOCN-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-LOCN-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-LOCN-STEP (r-current-instruction r) r)))))
  ((enable R-LOCN-okp
           R-LOCN-STEP
           push-stk
           sub1-addr
           sub-addr
           ADP-OFFSET-SUB-ADP
           ADP-NAME-SUB-ADP
           PROPER-R-STATEP-PROPERTIES
           offset
           difference-1
           free-stk-size
           same-signature-deposit-adp
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           r-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           r-objectp-type
           r-objectp
           adpp
           )))

(prove-lemma same-signature-r-ins-step-PUSH-CONSTANT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-CONSTANT)
                (proper-r-statep r load-addr)
                (R-PUSH-CONSTANT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-CONSTANT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-CONSTANT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-CONSTANT-STEP (r-current-instruction r) r)))))
  ((enable R-PUSH-CONSTANT-STEP
           R-PUSH-CONSTANT-okp
           push-stk
           sub1-addr
           sub-addr
           ADP-OFFSET-SUB-ADP
           ADP-NAME-SUB-ADP
           PROPER-R-STATEP-PROPERTIES
           offset
           difference-1
           free-stk-size
           same-signature-deposit-adp
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           r-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           r-objectp-type
           r-objectp
           adpp
           )))

(prove-lemma same-signature-r-ins-step-PUSH-LOCAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-LOCAL)
                (proper-r-statep r load-addr)
                (R-PUSH-LOCAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-LOCAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-LOCAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-LOCAL-STEP (r-current-instruction r) r)))))


    ((enable R-PUSH-local-STEP
             R-PUSH-local-okp
             PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
             DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
             DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
             OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-PUSH-GLOBAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-GLOBAL)
                (proper-r-statep r load-addr)
                (R-PUSH-GLOBAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-GLOBAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-GLOBAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-GLOBAL-STEP (r-current-instruction r) r)))))
  ((enable R-PUSH-GLOBAL-OKP R-PUSH-GLOBAL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-PUSH-CTRL-STK-FREE-SIZE (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-CTRL-STK-FREE-SIZE)
                (proper-r-statep r load-addr)
                (R-PUSH-CTRL-STK-FREE-SIZE-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-CTRL-STK-FREE-SIZE-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-CTRL-STK-FREE-SIZE-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-CTRL-STK-FREE-SIZE-STEP (r-current-instruction r) r)))))
  ((enable R-PUSH-CTRL-STK-FREE-SIZE-OKP R-PUSH-CTRL-STK-FREE-SIZE-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-PUSH-TEMP-STK-FREE-SIZE (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-TEMP-STK-FREE-SIZE)
                (proper-r-statep r load-addr)
                (R-PUSH-TEMP-STK-FREE-SIZE-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-TEMP-STK-FREE-SIZE-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-TEMP-STK-FREE-SIZE-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-TEMP-STK-FREE-SIZE-STEP (r-current-instruction r) r)))))
  ((enable R-PUSH-TEMP-STK-FREE-SIZE-OKP R-PUSH-TEMP-STK-FREE-SIZE-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-PUSH-TEMP-STK-INDEX (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSH-TEMP-STK-INDEX)
                (proper-r-statep r load-addr)
                (R-PUSH-TEMP-STK-INDEX-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSH-TEMP-STK-INDEX-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSH-TEMP-STK-INDEX-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSH-TEMP-STK-INDEX-STEP (r-current-instruction r) r)))))
  ((enable R-PUSH-TEMP-STK-INDEX-OKP R-PUSH-TEMP-STK-INDEX-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-JUMP-IF-TEMP-STK-FULL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'JUMP-IF-TEMP-STK-FULL)
                (proper-r-statep r load-addr)
                (R-JUMP-IF-TEMP-STK-FULL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-JUMP-IF-TEMP-STK-FULL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-JUMP-IF-TEMP-STK-FULL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-JUMP-IF-TEMP-STK-FULL-STEP (r-current-instruction r) r)))))
  ((enable R-JUMP-IF-TEMP-STK-FULL-OKP R-JUMP-IF-TEMP-STK-FULL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-JUMP-IF-TEMP-STK-EMPTY (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'JUMP-IF-TEMP-STK-EMPTY)
                (proper-r-statep r load-addr)
                (R-JUMP-IF-TEMP-STK-EMPTY-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-JUMP-IF-TEMP-STK-EMPTY-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-JUMP-IF-TEMP-STK-EMPTY-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-JUMP-IF-TEMP-STK-EMPTY-STEP (r-current-instruction r) r)))))
  ((enable R-JUMP-IF-TEMP-STK-EMPTY-OKP R-JUMP-IF-TEMP-STK-EMPTY-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-POP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP)
                (proper-r-statep r load-addr)
                (R-POP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP-STEP (r-current-instruction r) r)))))
  ((enable R-POP-OKP R-POP-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-POP* (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP*)
                (proper-r-statep r load-addr)
                (R-POP*-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP*-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP*-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP*-STEP (r-current-instruction r) r)))))
  ((enable R-POP*-OKP R-POP*-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-POPN (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POPN)
                (proper-r-statep r load-addr)
                (R-POPN-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POPN-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POPN-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POPN-STEP (r-current-instruction r) r)))))
  ((enable R-POPN-OKP R-POPN-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-POP-LOCAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP-LOCAL)
                (proper-r-statep r load-addr)
                (R-POP-LOCAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP-LOCAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP-LOCAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP-LOCAL-STEP (r-current-instruction r) r)))))
  ((enable R-POP-LOCAL-OKP R-POP-LOCAL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE r-objectp-type r-objectp adpp add-addr adp-offset-add-adp
           litatom-adp-name adp-name-add-adp)))

(prove-lemma same-signature-r-ins-step-POP-GLOBAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP-GLOBAL)
                (proper-r-statep r load-addr)
                (R-POP-GLOBAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP-GLOBAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP-GLOBAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP-GLOBAL-STEP (r-current-instruction r) r)))))
  ((enable R-POP-GLOBAL-OKP R-POP-GLOBAL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE litatom-cadr-unlabel adp-name-cons proper-alistp-r-usr-data-segment
           adp-offset-cons equal-length-0)))

(prove-lemma same-signature-r-ins-step-POP-LOCN (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP-LOCN)
                (proper-r-statep r load-addr)
                (R-POP-LOCN-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP-LOCN-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP-LOCN-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP-LOCN-STEP (r-current-instruction r) r)))))
  ((enable R-POP-LOCN-OKP R-POP-LOCN-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE r-objectp-type r-objectp adpp add-addr adp-offset-add-adp
           litatom-adp-name adp-name-add-adp)))

(prove-lemma same-signature-r-ins-step-POP-CALL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POP-CALL)
                (proper-r-statep r load-addr)
                (R-POP-CALL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POP-CALL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POP-CALL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POP-CALL-STEP (r-current-instruction r) r)))))
  ((enable R-POP-CALL-OKP R-POP-CALL-STEP
           r-call-okp
           r-call-step
           push-stk
           sub1-addr
           sub-addr
           ADP-OFFSET-SUB-ADP
           ADP-NAME-SUB-ADP
           PROPER-R-STATEP-PROPERTIES
           LISTP-APPEND
           LENGTH-APPEND
           length-rev
           length-strip-cadrs
           length-fetch-n
           length-cons
           equal-plus-0
           free-stk-size
           local-vars
           length-strip-cars
           offset
           plus-add1
           difference-1
           plus-0
           commutativity-of-plus
           same-signature-deposit-lst
           adp-name-cons
           adp-offset-cons
           definiens
           definition
           equal-length-0
           r-current-instruction
           litatom-cadr-unlabel
           litatom-adp-name
           untag-tag
           deposit
           r-objectp-type
           r-objectp
           adpp)))

(prove-lemma same-signature-r-ins-step-FETCH-TEMP-STK (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'FETCH-TEMP-STK)
                (proper-r-statep r load-addr)
                (R-FETCH-TEMP-STK-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-FETCH-TEMP-STK-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-FETCH-TEMP-STK-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-FETCH-TEMP-STK-STEP (r-current-instruction r) r)))))
  ((enable R-FETCH-TEMP-STK-OKP R-FETCH-TEMP-STK-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

; I am having trouble getting same-signature-r-ins-step-DEPOSIT-TEMP-STK
; so I am proving a lemma just for it.  I'm sure there is one like this
; somewhere already here.  I am embarassed to confess that the following
; dumb helper is also beyond the abilities of the unassisted prover in its
; current disabled state!  I suppose I could find lemmas to make this go
; through too, but I'll just push it through by induction!

(prove-lemma same-signature-r-ins-step-DEPOSIT-TEMP-STK-lemma-helper nil
  (implies (not (zerop n))
           (lessp (difference (sub1 (sub1 n)) untag)
                  n))
  ((induct (lessp n untag))))

(prove-lemma same-signature-r-ins-step-DEPOSIT-TEMP-STK-lemma (rewrite)
  (implies (proper-r-statep r load-addr)
           (equal (LESSP (if (EQUAL (SUB1 (LENGTH (CDR (ASSOC 'TSTK 
                                                              (R-SYS-DATA-SEGMENT R))))) 
                                    0)
                             0
                             (DIFFERENCE (SUB1 (SUB1 (LENGTH (CDR (ASSOC 'TSTK 
                                                                         (R-SYS-DATA-SEGMENT R)))))) 
                                         (UNTAG (FETCH (R-TSP R) 
                                                       (R-SYS-DATA-SEGMENT R))))) 
                         (LENGTH (CDR (ASSOC 'TSTK 
                                             (R-SYS-DATA-SEGMENT R)))))
                  t))
  ((enable proper-r-statep-properties)
   (use (same-signature-r-ins-step-DEPOSIT-TEMP-STK-lemma-helper
         (n (length (cdr (assoc 'tstk (r-sys-data-segment r)))))
         (untag (UNTAG (FETCH (R-TSP R) 
                              (R-SYS-DATA-SEGMENT R))))))))

(prove-lemma same-signature-r-ins-step-DEPOSIT-TEMP-STK (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'DEPOSIT-TEMP-STK)
                (proper-r-statep r load-addr)
                (R-DEPOSIT-TEMP-STK-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-DEPOSIT-TEMP-STK-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-DEPOSIT-TEMP-STK-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-DEPOSIT-TEMP-STK-STEP (r-current-instruction r) r)))))
  ((enable R-DEPOSIT-TEMP-STK-OKP R-DEPOSIT-TEMP-STK-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           adp-name-cons adp-offset-cons r-objectp-type r-objectp adpp small-naturalp
           lessp-0-length)))

(prove-lemma same-signature-r-ins-step-JUMP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'JUMP)
                (proper-r-statep r load-addr)
                (R-JUMP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-JUMP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-JUMP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-JUMP-STEP (r-current-instruction r) r)))))
  ((enable R-JUMP-OKP R-JUMP-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-JUMP-CASE (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'JUMP-CASE)
                (proper-r-statep r load-addr)
                (R-JUMP-CASE-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-JUMP-CASE-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-JUMP-CASE-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-JUMP-CASE-STEP (r-current-instruction r) r)))))
  ((enable R-JUMP-CASE-OKP R-JUMP-CASE-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-PUSHJ (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'PUSHJ)
                (proper-r-statep r load-addr)
                (R-PUSHJ-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-PUSHJ-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-PUSHJ-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-PUSHJ-STEP (r-current-instruction r) r)))))
  ((enable R-PUSHJ-OKP R-PUSHJ-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-POPJ (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'POPJ)
                (proper-r-statep r load-addr)
                (R-POPJ-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-POPJ-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-POPJ-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-POPJ-STEP (r-current-instruction r) r)))))
  ((enable R-POPJ-OKP R-POPJ-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-SET-LOCAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SET-LOCAL)
                (proper-r-statep r load-addr)
                (R-SET-LOCAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SET-LOCAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SET-LOCAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SET-LOCAL-STEP (r-current-instruction r) r)))))
  ((enable R-SET-LOCAL-OKP R-SET-LOCAL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           r-objectp-type r-objectp adpp add-addr adp-offset-add-adp
           litatom-adp-name adp-name-add-adp)))

(prove-lemma same-signature-r-ins-step-SET-GLOBAL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SET-GLOBAL)
                (proper-r-statep r load-addr)
                (R-SET-GLOBAL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SET-GLOBAL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SET-GLOBAL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SET-GLOBAL-STEP (r-current-instruction r) r)))))
  ((enable R-SET-GLOBAL-OKP R-SET-GLOBAL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           litatom-cadr-unlabel adp-name-cons proper-alistp-r-usr-data-segment
           adp-offset-cons equal-length-0)))

(prove-lemma same-signature-r-ins-step-TEST-NAT-AND-JUMP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'TEST-NAT-AND-JUMP)
                (proper-r-statep r load-addr)
                (R-TEST-NAT-AND-JUMP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-TEST-NAT-AND-JUMP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-TEST-NAT-AND-JUMP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-TEST-NAT-AND-JUMP-STEP (r-current-instruction r) r)))))
  ((enable R-TEST-NAT-AND-JUMP-OKP R-TEST-NAT-AND-JUMP-STEP
           r-test-and-jump-okp r-test-and-jump-step
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-TEST-INT-AND-JUMP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'TEST-INT-AND-JUMP)
                (proper-r-statep r load-addr)
                (R-TEST-INT-AND-JUMP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-TEST-INT-AND-JUMP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-TEST-INT-AND-JUMP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-TEST-INT-AND-JUMP-STEP (r-current-instruction r) r)))))
  ((enable R-TEST-INT-AND-JUMP-OKP R-TEST-INT-AND-JUMP-STEP
           r-test-and-jump-okp r-test-and-jump-step
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-TEST-BOOL-AND-JUMP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'TEST-BOOL-AND-JUMP)
                (proper-r-statep r load-addr)
                (R-TEST-BOOL-AND-JUMP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-TEST-BOOL-AND-JUMP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-TEST-BOOL-AND-JUMP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-TEST-BOOL-AND-JUMP-STEP (r-current-instruction r) r)))))
  ((enable R-TEST-BOOL-AND-JUMP-OKP R-TEST-BOOL-AND-JUMP-STEP
           r-test-and-jump-okp r-test-and-jump-step
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-TEST-BITV-AND-JUMP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'TEST-BITV-AND-JUMP)
                (proper-r-statep r load-addr)
                (R-TEST-BITV-AND-JUMP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-TEST-BITV-AND-JUMP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-TEST-BITV-AND-JUMP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-TEST-BITV-AND-JUMP-STEP (r-current-instruction r) r)))))
  ((enable R-TEST-BITV-AND-JUMP-OKP R-TEST-BITV-AND-JUMP-STEP
           r-test-and-jump-okp r-test-and-jump-step
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-NO-OP (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'NO-OP)
                (proper-r-statep r load-addr)
                (R-NO-OP-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-NO-OP-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-NO-OP-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-NO-OP-STEP (r-current-instruction r) r)))))
  ((enable R-NO-OP-OKP R-NO-OP-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE)))

(prove-lemma same-signature-r-ins-step-ADD-ADDR (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD-ADDR)
                (proper-r-statep r load-addr)
                (R-ADD-ADDR-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD-ADDR-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD-ADDR-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD-ADDR-STEP (r-current-instruction r) r)))))
  ((enable R-ADD-ADDR-OKP R-ADD-ADDR-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-SUB-ADDR (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB-ADDR)
                (proper-r-statep r load-addr)
                (R-SUB-ADDR-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB-ADDR-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB-ADDR-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB-ADDR-STEP (r-current-instruction r) r)))))
  ((enable R-SUB-ADDR-OKP R-SUB-ADDR-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-EQ (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'EQ)
                (proper-r-statep r load-addr)
                (R-EQ-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-EQ-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-EQ-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-EQ-STEP (r-current-instruction r) r)))))
  ((enable R-EQ-OKP R-EQ-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-LT-ADDR (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'LT-ADDR)
                (proper-r-statep r load-addr)
                (R-LT-ADDR-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-LT-ADDR-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-LT-ADDR-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-LT-ADDR-STEP (r-current-instruction r) r)))))
  ((enable R-LT-ADDR-OKP R-LT-ADDR-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-FETCH (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'FETCH)
                (proper-r-statep r load-addr)
                (R-FETCH-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-FETCH-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-FETCH-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-FETCH-STEP (r-current-instruction r) r)))))
  ((enable R-FETCH-OKP R-FETCH-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-DEPOSIT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'DEPOSIT)
                (proper-r-statep r load-addr)
                (R-DEPOSIT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-DEPOSIT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-DEPOSIT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-DEPOSIT-STEP (r-current-instruction r) r)))))
  ((enable R-DEPOSIT-OKP R-DEPOSIT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           r-objectp-type r-objectp adpp litatom-adp-name proper-alistp-r-usr-data-segment)))

(prove-lemma same-signature-r-ins-step-ADD-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD-INT)
                (proper-r-statep r load-addr)
                (R-ADD-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD-INT-STEP (r-current-instruction r) r)))))
  ((enable R-ADD-INT-OKP R-ADD-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma definedp-deposit-adp (rewrite)
  (equal (definedp name (deposit-adp val adp segment))
         (definedp name segment))
  ((enable deposit-adp put-value)
   (use (definedp-put-assoc
          (name name)
          (val (PUT VAL 
                    (ADP-OFFSET ADP) 
                    (DEFINIENS (ADP-NAME ADP) SEGMENT)))
          (name2 (ADP-NAME ADP))
          (segment segment)))))

; We need a special lemma here because add-int-with-carry pushes two things.
; As usual, there is undoubtedly a set of lemmas already available for this
; if I only wanted to understand every detail of the old proofs.

(prove-lemma adpp-add-adp-hack (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (LESSP (PLUS 1  
                             (ADP-OFFSET (UNTAG (R-TSP R))))  
                       (SUB1 (SUB1 (LENGTH (CDR (ASSOC 'TSTK  
                                                       (R-SYS-DATA-SEGMENT R))))))))
           (adpp (add-adp (untag (r-tsp r)) 2) (r-sys-data-segment r)))
  ((enable proper-r-statep-properties adpp add-adp adp-offset-cons adp-name-cons
           definiens commutativity-of-plus definition)))

(prove-lemma same-signature-r-ins-step-ADD-INT-WITH-CARRY (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD-INT-WITH-CARRY)
                (proper-r-statep r load-addr)
                (R-ADD-INT-WITH-CARRY-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD-INT-WITH-CARRY-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD-INT-WITH-CARRY-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD-INT-WITH-CARRY-STEP (r-current-instruction r) r)))))
  ((enable R-ADD-INT-WITH-CARRY-OKP R-ADD-INT-WITH-CARRY-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-ADD1-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD1-INT)
                (proper-r-statep r load-addr)
                (R-ADD1-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD1-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD1-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD1-INT-STEP (r-current-instruction r) r)))))
  ((enable R-ADD1-INT-OKP R-ADD1-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-SUB-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB-INT)
                (proper-r-statep r load-addr)
                (R-SUB-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB-INT-STEP (r-current-instruction r) r)))))
  ((enable R-SUB-INT-OKP R-SUB-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-SUB-INT-WITH-CARRY (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB-INT-WITH-CARRY)
                (proper-r-statep r load-addr)
                (R-SUB-INT-WITH-CARRY-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB-INT-WITH-CARRY-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB-INT-WITH-CARRY-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB-INT-WITH-CARRY-STEP (r-current-instruction r) r)))))
  ((enable R-SUB-INT-WITH-CARRY-OKP R-SUB-INT-WITH-CARRY-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-SUB1-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB1-INT)
                (proper-r-statep r load-addr)
                (R-SUB1-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB1-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB1-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB1-INT-STEP (r-current-instruction r) r)))))
  ((enable R-SUB1-INT-OKP R-SUB1-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-NEG-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'NEG-INT)
                (proper-r-statep r load-addr)
                (R-NEG-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-NEG-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-NEG-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-NEG-INT-STEP (r-current-instruction r) r)))))
  ((enable R-NEG-INT-OKP R-NEG-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-LT-INT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'LT-INT)
                (proper-r-statep r load-addr)
                (R-LT-INT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-LT-INT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-LT-INT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-LT-INT-STEP (r-current-instruction r) r)))))
  ((enable R-LT-INT-OKP R-LT-INT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-INT-TO-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'INT-TO-NAT)
                (proper-r-statep r load-addr)
                (R-INT-TO-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-INT-TO-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-INT-TO-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-INT-TO-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-INT-TO-NAT-OKP R-INT-TO-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-ADD-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD-NAT)
                (proper-r-statep r load-addr)
                (R-ADD-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-ADD-NAT-OKP R-ADD-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-ADD-NAT-WITH-CARRY (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD-NAT-WITH-CARRY)
                (proper-r-statep r load-addr)
                (R-ADD-NAT-WITH-CARRY-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD-NAT-WITH-CARRY-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD-NAT-WITH-CARRY-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD-NAT-WITH-CARRY-STEP (r-current-instruction r) r)))))
  ((enable R-ADD-NAT-WITH-CARRY-OKP R-ADD-NAT-WITH-CARRY-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-ADD1-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'ADD1-NAT)
                (proper-r-statep r load-addr)
                (R-ADD1-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-ADD1-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-ADD1-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-ADD1-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-ADD1-NAT-OKP R-ADD1-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-SUB-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB-NAT)
                (proper-r-statep r load-addr)
                (R-SUB-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-SUB-NAT-OKP R-SUB-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-SUB-NAT-WITH-CARRY (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB-NAT-WITH-CARRY)
                (proper-r-statep r load-addr)
                (R-SUB-NAT-WITH-CARRY-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB-NAT-WITH-CARRY-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB-NAT-WITH-CARRY-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB-NAT-WITH-CARRY-STEP (r-current-instruction r) r)))))
  ((enable R-SUB-NAT-WITH-CARRY-OKP R-SUB-NAT-WITH-CARRY-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-SUB1-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'SUB1-NAT)
                (proper-r-statep r load-addr)
                (R-SUB1-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-SUB1-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-SUB1-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-SUB1-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-SUB1-NAT-OKP R-SUB1-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-LT-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'LT-NAT)
                (proper-r-statep r load-addr)
                (R-LT-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-LT-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-LT-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-LT-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-LT-NAT-OKP R-LT-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-MULT2-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'MULT2-NAT)
                (proper-r-statep r load-addr)
                (R-MULT2-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-MULT2-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-MULT2-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-MULT2-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-MULT2-NAT-OKP R-MULT2-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-MULT2-NAT-WITH-CARRY-OUT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'MULT2-NAT-WITH-CARRY-OUT)
                (proper-r-statep r load-addr)
                (R-MULT2-NAT-WITH-CARRY-OUT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-MULT2-NAT-WITH-CARRY-OUT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-MULT2-NAT-WITH-CARRY-OUT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-MULT2-NAT-WITH-CARRY-OUT-STEP (r-current-instruction r) r)))))
  ((enable R-MULT2-NAT-WITH-CARRY-OUT-OKP R-MULT2-NAT-WITH-CARRY-OUT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-DIV2-NAT (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'DIV2-NAT)
                (proper-r-statep r load-addr)
                (R-DIV2-NAT-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-DIV2-NAT-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-DIV2-NAT-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-DIV2-NAT-STEP (r-current-instruction r) r)))))
  ((enable R-DIV2-NAT-OKP R-DIV2-NAT-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name
           length-cdr-assoc-deposit-adp add-adp-add-adp)))

(prove-lemma same-signature-r-ins-step-OR-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'OR-BITV)
                (proper-r-statep r load-addr)
                (R-OR-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-OR-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-OR-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-OR-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-OR-BITV-OKP R-OR-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-AND-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'AND-BITV)
                (proper-r-statep r load-addr)
                (R-AND-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-AND-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-AND-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-AND-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-AND-BITV-OKP R-AND-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-NOT-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'NOT-BITV)
                (proper-r-statep r load-addr)
                (R-NOT-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-NOT-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-NOT-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-NOT-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-NOT-BITV-OKP R-NOT-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-XOR-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'XOR-BITV)
                (proper-r-statep r load-addr)
                (R-XOR-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-XOR-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-XOR-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-XOR-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-XOR-BITV-OKP R-XOR-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-RSH-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'RSH-BITV)
                (proper-r-statep r load-addr)
                (R-RSH-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-RSH-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-RSH-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-RSH-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-RSH-BITV-OKP R-RSH-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-LSH-BITV (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'LSH-BITV)
                (proper-r-statep r load-addr)
                (R-LSH-BITV-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-LSH-BITV-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-LSH-BITV-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-LSH-BITV-STEP (r-current-instruction r) r)))))
  ((enable R-LSH-BITV-OKP R-LSH-BITV-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-OR-BOOL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'OR-BOOL)
                (proper-r-statep r load-addr)
                (R-OR-BOOL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-OR-BOOL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-OR-BOOL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-OR-BOOL-STEP (r-current-instruction r) r)))))
  ((enable R-OR-BOOL-OKP R-OR-BOOL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-AND-BOOL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'AND-BOOL)
                (proper-r-statep r load-addr)
                (R-AND-BOOL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-AND-BOOL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-AND-BOOL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-AND-BOOL-STEP (r-current-instruction r) r)))))
  ((enable R-AND-BOOL-OKP R-AND-BOOL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

(prove-lemma same-signature-r-ins-step-NOT-BOOL (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (equal (car (r-current-instruction r))
                       'NOT-BOOL)
                (proper-r-statep r load-addr)
                (R-NOT-BOOL-okp (r-current-instruction r) r))
           (and (equal (r-prog-segment (R-NOT-BOOL-STEP (r-current-instruction r) r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (R-NOT-BOOL-STEP (r-current-instruction r) r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (R-NOT-BOOL-STEP (r-current-instruction r) r)))))
  ((enable R-NOT-BOOL-OKP R-NOT-BOOL-STEP
           PROPER-R-STATEP-PROPERTIES R-CURRENT-INSTRUCTION ADPP DEFINITION 
           DEFINIENS R-OBJECTP DEPOSIT UNTAG-TAG PUSH-STK SUB-ADDR SUB1-ADDR
           DIFFERENCE-1 ADP-OFFSET-SUB-ADP ADP-NAME-SUB-ADP SAME-SIGNATURE-DEPOSIT-ADP
           OFFSET FREE-STK-SIZE
           pop-stk add1-addr add-addr adp-name-add-adp adp-offset-add-adp
           r-objectp-type r-objectp adpp empty-stkp stk-length equal-sub1-difference-0
           commutativity-of-plus area-name)))

; Now we put these all together.  We'll do each segment individually
; because the case splitting is pretty bad here:

(prove-lemma same-signature-r-prog-segment-r-ins-step (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (r-ins-okp (r-current-instruction r) r)
                (proper-r-statep r load-addr))
           (equal (r-prog-segment (r-ins-step (r-current-instruction r) r))
                  (r-prog-segment r)))
  ((enable r-ins-okp r-ins-step)))

(prove-lemma same-signature-r-usr-data-segment-r-ins-step (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (r-ins-okp (r-current-instruction r) r)
                (proper-r-statep r load-addr))
           (same-signature (r-usr-data-segment r)
                           (r-usr-data-segment (r-ins-step (r-current-instruction r) r))))
             ((enable r-ins-okp r-ins-step)))

(prove-lemma same-signature-r-sys-data-segment-r-ins-step (rewrite)
  (implies (and (equal (r-psw r) 'run)
                (r-ins-okp (r-current-instruction r) r)
                (proper-r-statep r load-addr))
           (same-signature (r-sys-data-segment r)
                           (r-sys-data-segment (r-ins-step (r-current-instruction r) r))))
  ((enable r-ins-okp r-ins-step)))

(prove-lemma same-signature-r-step (rewrite)
  (implies (proper-r-statep r load-addr)
           (and (equal (r-prog-segment (r-step r))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (r-step r)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (r-step r)))))
  ((enable r-step r-step1 r-halt)))

(prove-lemma same-signature-r-transitivity-lemma1 (rewrite)
  (implies (and (numberp n)
                (not (equal n 0))
                (same-signature (r-usr-data-segment (r-step r))
                                (r-usr-data-segment (r (r-step r) (sub1 n))))
                (proper-r-statep r load-addr)
                (not (errorp (r-psw (r (r-step r) (sub1 n))))))
           (same-signature (r-usr-data-segment r)
                           (r-usr-data-segment (r (r-step r) (sub1 n)))))
  ((use (transitivity-of-same-signature
         (segment1 (r-usr-data-segment r))
         (segment2 (r-usr-data-segment (r-step r)))
         (segment3 (r-usr-data-segment (r (r-step r) (sub1 n))))))))

(prove-lemma same-signature-r-transitivity-lemma2 (rewrite)
  (implies (and (numberp n)
                (not (equal n 0))
                (same-signature (r-sys-data-segment (r-step r))
                                (r-sys-data-segment (r (r-step r) (sub1 n))))
                (proper-r-statep r load-addr)
                (not (errorp (r-psw (r (r-step r) (sub1 n))))))
           (same-signature (r-sys-data-segment r)
                           (r-sys-data-segment (r (r-step r) (sub1 n)))))
  ((use (transitivity-of-same-signature
         (segment1 (r-sys-data-segment r))
         (segment2 (r-sys-data-segment (r-step r)))
         (segment3 (r-sys-data-segment (r (r-step r) (sub1 n))))))))

(prove-lemma same-signature-r (rewrite)
  (implies (and (proper-r-statep r load-addr)
                (not (errorp (r-psw (r r n)))))
           (and (equal (r-prog-segment (r r n))
                       (r-prog-segment r))
                (same-signature (r-usr-data-segment r)
                                (r-usr-data-segment (r r n)))
                (same-signature (r-sys-data-segment r)
                                (r-sys-data-segment (r r n)))))
  ((enable r proper-r-statep-r-step
           once-errorp-always-errorp{special}
           once-errorp-always-errorp-step{special})))

; So now we can derive from this same-signature invariance the fact that
; the length of the mapped down memory is preserved by the r machine.

; The key lemma relating same-signature and link-mem...

(prove-lemma same-signature-implies-length-link-mem nil
  (implies (and (same-signature usr-data-segment1 usr-data-segment2)
                (same-signature sys-data-segment1 sys-data-segment2))
           (equal (length (link-mem boot-lst load-addr
                                    usr-data-segment2 prog-segment sys-data-segment2
                                    tables word-size))
                  (length (link-mem boot-lst load-addr
                                    usr-data-segment1 prog-segment sys-data-segment1
                                    tables word-size))))
  ((enable link-mem length-append length-link-segment-is-segment-length
           same-signature-segment-length)))

; ... which we can use to show that the mapped down memory is the same size:

(prove-lemma length-m-mem-r->i->m (rewrite) 
  (implies (and (proper-r-statep r load-addr) 
                (numberp load-addr)
                (not (errorp (r-psw (r r n)))) 
                (equal (r-word-size r) 32)) 
           (equal (length (m-mem (i->m (r->i (r r n)) boot-lst load-addr))) 
                  (length (m-mem (i->m (r->i r) boot-lst load-addr))))) 
  ((enable r->i i->m) 
   (use (I-LINK-TABLES-R->I (r0 r)) 
        (same-signature-implies-length-link-mem 
         (prog-segment (ICOMPILE (R-PROG-SEGMENT R))) 
         (usr-data-segment1 (R-USR-DATA-SEGMENT R)) 
         (usr-data-segment2 (R-USR-DATA-SEGMENT (R R N))) 
         (sys-data-segment1 (R-SYS-DATA-SEGMENT R)) 
         (sys-data-segment2 (R-SYS-DATA-SEGMENT (R R N))) 
         (tables (I-LINK-TABLES (I-STATE (R->I_PC (R-PC R) (R-PROG-SEGMENT R))  
                                         (R-CFP R)  
                                         (R-CSP R)  
                                         (R-TSP R)  
                                         (R-X R)  
                                         (R-Y R)  
                                         (R-C-FLG R)  
                                         (R-V-FLG R)  
                                         (R-N-FLG R)  
                                         (R-Z-FLG R)  
                                         (ICOMPILE (R-PROG-SEGMENT R))  
                                         (R-USR-DATA-SEGMENT R)  
                                         (R-SYS-DATA-SEGMENT R)  
                                         (R-WORD-SIZE R)  
                                         (R->I_PSW (R-PSW R)))
                                LOAD-ADDR)) 
         (word-size (R-WORD-SIZE R))))))

(prove-lemma i-usr-data-segment-p->r->i (rewrite) 
  (equal (i-usr-data-segment (r->i (p->r p))) (p-data-segment p)) 
  ((enable p->r r->i)))

(prove-lemma once-errorp-always-errorp{mapping} (rewrite) 
  (implies (and (proper-p-statep p0) 
                (p-loadablep p0 load-addr) 
                (not (errorp (p-psw (p p0 n))))) 
           (not (errorp (r-psw (r (p->r p0) n))))) 
  ((use (one-way-correspondence-p-r (p p0))) 
   (enable p->r once-errorp-always-errorp r-equal)))

(prove-lemma length-m-mem-p->r->i->m (rewrite)
  (equal (length (m-mem (i->m (r->i (p->r p0)) boot-lst load-addr)))
         (plus load-addr
               (segment-length (p-data-segment p0)) 
               (segment-length (icompile (p-prog-segment p0))) 
               (segment-length 
                (p->r_sys-data-segment (p-ctrl-stk p0) 
                                       (p-max-ctrl-stk-size p0) 
                                       (p-temp-stk p0) 
                                       (p-max-temp-stk-size p0)))))
  ((enable p->r r->i i->m link-mem length-append
           length-boot-code
           length-link-segment-is-segment-length)))

(prove-lemma i-prog-segment-p->r->i (rewrite)
  (equal (i-prog-segment (r->i (p->r p0)))
         (icompile (p-prog-segment p0)))
  ((enable p->r r->i)))

(prove-lemma consolidated-plausibility-argument-lemma (rewrite)
  (implies (and (proper-p-statep p0) 
                (p-loadablep p0 load-addr) 
                (numberp load-addr)
                (equal (p-word-size p0) 32) 
                (not (errorp (p-psw (p p0 n)))) 
                (plausible-data-link-tablep
                 (type-specification (p-data-segment p0)) 
                 (plus load-addr
                       (segment-length (p-data-segment p0)) 
                       (segment-length (icompile (p-prog-segment p0))) 
                       (segment-length 
                        (p->r_sys-data-segment (p-ctrl-stk p0) 
                                               (p-max-ctrl-stk-size p0) 
                                               (p-temp-stk p0) 
                                               (p-max-temp-stk-size p0)))) 
                 (link-table-for-segment (p-data-segment p0)  
                                         load-addr))) 
           (plausible-data-link-tablep
            (type-specification (p-data-segment (p p0 n))) 
            (length (m-mem (i->m (r->i (r (p->r p0) n)) boot-lst load-addr))) 
            (usr-data-links (i-link-tables (r->i (p->r p0)) load-addr)))) 
  ((use (same-signature-plausible-data-link-tablep 
         (seg1 (p-data-segment p0)) 
         (seg2 (p-data-segment (p p0 n))) 
         (n (length (m-mem (i->m (r->i (p->r p0)) boot-lst load-addr))))  
         (table (link-table-for-segment  
                 (p-data-segment p0)  
                 load-addr)))) 
   (enable i-link-tables usr-data-links proper-p-statep-implies-proper-r-statep)))

; So to establish the desired plausibility condition we can backchain through
; the above and reduce the goal to:

; (plausible-data-link-tablep
;            (type-specification (p-data-segment p0)) 
;            (plus (segment-length (icompile (p-prog-segment p0))) 
;                  (segment-length (p-data-segment p0)) 
;                  (segment-length 
;                   (p->r_sys-data-segment (p-ctrl-stk p0) 
;                                          (p-max-ctrl-stk-size p0) 
;                                          (p-temp-stk p0) 
;                                          (p-max-temp-stk-size p0)))) 
;            (link-table-for-segment (p-data-segment p0)  
;                                    (segment-length (icompile (p-prog-segment p0)))))

; Which is in fact an instance of

; (plausible-data-link-tablep
;            (type-specification seg) 
;            (plus i (segment-length seg) j)
;            (link-table-for-segment seg i))

; It is this more general plausibility condition that we now attack.

(prove-lemma not-lessp-segment-length-plus-link-table-entry-length (rewrite)
  (NOT (LESSP (SEGMENT-LENGTH SEGMENT) 
              (PLUS (LINK-TABLE-ENTRY NAME SEGMENT) 
                    (LENGTH (CDR (ASSOC NAME SEGMENT))))))
  ((enable segment-length link-table-entry length assoc)))

(prove-lemma lessp-absolute-address-segment-length-rewrite{weakened-instance} (rewrite)
  (implies (and (definedp name segment)
                (equal i (length (cdr (assoc name segment)))))
           (not (lessp (segment-length segment)
                       (plus i
                             (link-table-entry name segment)))))
  ((use (LESSP-ABSOLUTE-ADDRESS-SEGMENT-LENGTH-REWRITE (offset (length (cdr (assoc name segment))))))))
  
(prove-lemma plausible-data-link-tablep-link-table-for-segment (rewrite)
  (implies (and (subsegmentp seg1 seg2)
                (numberp i)
                (not (lessp max (plus i (segment-length seg2)))))
           (plausible-data-link-tablep (type-specification seg1) max (link-table-for-segment seg2 i)))
  ((induct (type-specification seg1))
   (enable subsegmentp segment-length plausible-data-link-tablep type-specification link-table-for-segment
           area-type-specification length-type-lst assoc-link-table-for-segment
           commutativity-of-plus associativity-of-plus commutativity2-of-plus)))

(prove-lemma r-usr-data-segment-p->r (rewrite)
  (equal (r-usr-data-segment (p->r p)) (p-data-segment p))
  ((enable p->r)))

; Note:  The use and disable hints below were unnecessary
; before load-addr became an insidious free variable.

(prove-lemma proper-p-statep-implies-proper-i-usr-data-segmentp (rewrite)
  (implies (and (proper-p-statep p)
                (p-loadablep p load-addr)
                (numberp load-addr))
           (proper-i-usr-data-segmentp (p-data-segment p)
                                       (r->i (p->r p))))
  ((use (proper-p-statep-implies-proper-r-statep))
   (disable proper-p-statep-implies-proper-r-statep)
   (enable proper-p-data-segmentp
           proper-i-usr-data-segmentp
           proper-r-statep-implies-proper-i-user-data-segmentp-bridge
           proper-i-usr-data-area)))

(disable length-m-mem-p->r->i->m)
(disable length-m-mem-r->i->m)

(prove-lemma consolidated-plausibility-argument (rewrite)
  (implies (and (proper-p-statep p0)
                (p-loadablep p0 load-addr)
                (numberp load-addr)
                (not (errorp (p-psw (p p0 n))))
                (equal (p-word-size p0) 32))
           (plausible-data-link-tablep
            (type-specification (p-data-segment (p p0 n)))
            (length (m-mem (i->m (r->i (r (p->r p0) n)) boot-lst load-addr)))
            (usr-data-links (i-link-tables (r->i (p->r p0)) load-addr))))
  ((use (subsegmentp-reflexive (segment (p-data-segment p0))
                               (i (r->i (p->r p0)))))
   (disable p-r-owc-corrolary)))

; Book:  Top-goal.  Ok, so here, at long last, is the statement that
; Piton is implemented on FM9001!

(prove-lemma top-goal nil
  (IMPLIES (AND (PROPER-P-STATEP P0)
                (numberp load-addr)
                (P-LOADABLEP P0 LOAD-ADDR)
                (EQUAL (P-WORD-SIZE P0) 32)
                (EQUAL PN (P P0 N))
                (NOT (ERRORP (P-PSW PN)))
                (EQUAL TS (TYPE-SPECIFICATION
                           (P-DATA-SEGMENT PN))))
           (EQUAL (P-DATA-SEGMENT PN)
                  (DISPLAY-FM9001-DATA-SEGMENT
                   (FM9001 (LOAD P0 boot-lst load-addr)
                           (FM9001-CLOCK P0 N))
                   TS
                   (LINK-TABLES P0 load-addr))))

  ((enable load link-tables)
   (disable P-R-OWC-CORROLARY PROPER-R-STATEP-IMPLIES-PROPER-I-USER-DATA-SEGMENTP-BRIDGE)
   (use (P-R-OWC-CORROLARY (p p0))
        (PROPER-R-STATEP-IMPLIES-PROPER-I-USER-DATA-SEGMENTP-BRIDGE
         (segment (P-DATA-SEGMENT (P P0 N)))
         (r (R (P->R P0) N))))))

(set-status close-data-base-6 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

; The rest of this file is related to the implementation of the
; fm9001.  Since this version of Piton is built on an fm9001 events
; file that does not go down to that level, we omit the events below.

#|
(enable-theory (fm9001=fm9001-interpreter
                fm9001-statep
                map-down
                map-up-inverts-map-down
                fm9001-statep-implies-fm9001-state-structure
                fm9001-statep-implies-macrocycle-invariant-lemma1
                fm9001-statep-implies-macrocycle-invariant
                fm9001=chip-system-lemma1
                fm9001=chip-system))

; Book:  Piton to Dual-Eval.  We now wish to connect Piton to DUAL-EVAL, i.e.,
; to eliminate FM9001 and go straight down to the bottom.  The motivation is
; to make it easier for the user of Piton to connect his machine to the gate
; level, so that stacks can be built step-wise:  Each layer should finish by
; connecting to the bottom in one step.


; We now develop the lemmas leading to the theorem that maps Piton all the
; way down to the dual-eval level.

(defn ram-tree-hint (lst n) 
  (cond ((zerop n) t) 
        ((nlistp lst) t) 
        (t (cons (ram-tree-hint (firstn (exp 2 (sub1 n)) lst) 
                                (sub1 n)) 
                 (ram-tree-hint (restn (exp 2 (sub1 n)) lst) 
                                (sub1 n))))))

(prove-lemma not-equal-times-2-x-1 (rewrite)
  (not (equal (times 2 x) 1))
  ((enable times-0)))

(prove-lemma bvp-listp-firstn (rewrite)
  (implies (bvp-listp lst)
           (bvp-listp (firstn n lst))))

(prove-lemma bvp-listp-restn (rewrite)
  (implies (bvp-listp lst)
           (bvp-listp (restn n lst))))

(prove-lemma memory-okp-ram-tree (rewrite)
  (implies (bvp-listp lst)
           (memory-okp n 32 (ram-tree lst (exp 2 n))))
  ((enable quotient-times-instance-temp)
   (induct (ram-tree-hint lst n))))

(prove-lemma memory-okp-ram-tree-bridge (rewrite)
  (implies (and (bvp-listp lst)
                (equal k (exp 2 n)))
           (memory-okp n 32 (ram-tree lst k))))

(disable memory-okp-ram-tree)

(prove-lemma bvp-listp-cons (rewrite)
  (equal (bvp-listp (cons bv lst))
         (and (bvp bv)
              (equal (length bv) 32)
              (bvp-listp lst))))

(prove-lemma all-ramp-mem-ram-tree (rewrite)
  (implies (not (lessp (length lst) (exp 2 n)))
           (all-ramp-mem n (ram-tree lst (exp 2 n))))
  ((enable quotient-times-instance-temp length-firstn length-restn  lessp-0-exp)
   (induct (ram-tree-hint lst n))))

(prove-lemma all-ramp-mem-ram-tree-bridge (rewrite)
  (implies (and (equal k (exp 2 n))
                (not (lessp (length lst) k)))
           (all-ramp-mem n (ram-tree lst k))))

(disable all-ramp-mem-ram-tree)

(prove-lemma fm9001-statep-load (rewrite)
  (implies (and (proper-p-statep p0)
                (p-loadablep p0 load-addr)
                (equal (p-word-size p0) 32))
           (fm9001-statep (load p0 boot-lst load-addr)))
  ((disable proper-p-statep p-loadablep link-word  p->r_cfp p->r_csp p->r_tsp
            p->r_sys-data-segment r->i_pc icompile r->i_psw i-link-tables
            all-ramp-mem memory-okp ram-tree)
   (enable *1*exp length-cons size-link-word bvp-link-word bvp-listp-append
           bvp-listp-boot-code
           bvp-listp-link-segment bool-to-logical-non-f)))

(disable fm9001=fm9001-interpreter)

(prove-lemma piton-to-dual-eval (rewrite)
  (implies (and (proper-p-statep p0)
                (p-loadablep p0 load-addr)
                (numberp load-addr)
                (equal (p-word-size p0) 32)
                (not (errorp (p-psw (p p0 n))))
                (equal ts (type-specification (p-data-segment (p p0 n))))
                (chip-system& netlist)
                (chip-system-operating-inputs-p inputs 
                                                (total-microcycles (map-down (load p0 boot-lst load-addr)) 
                                                                   (map-up-inputs inputs) 
                                                                   (fm9001-clock p0 n))) 
                (operating-inputs-p (map-up-inputs inputs) 
                                    (total-microcycles (map-down (load p0 boot-lst load-addr)) 
                                                       (map-up-inputs inputs) 
                                                       (fm9001-clock p0 n))))
           (equal (p-data-segment (p p0 n))
                  (display-fm9001-data-segment
                   (map-up
                    (simulate-dual-eval-2 'chip-system inputs
                                          (map-down (load p0 boot-lst load-addr))
                                          netlist 
                                          (total-microcycles (map-down (load p0 boot-lst load-addr)) 
                                                             (map-up-inputs inputs) 
                                                             (fm9001-clock p0 n))))
                   ts
                   (link-tables p0 load-addr))))
  ((enable fm9001=chip-system)
   (disable proper-p-statep p-loadablep errorp type-specification p chip-system&
            chip-system-operating-inputs-p total-microcycles map-down load map-up-inputs
            fm9001-clock operating-inputs-p display-fm9001-data-segment map-up
            simulate-dual-eval-2 link-tables)
   (use (top-goal (pn (p p0 n))))))

(set-status close-data-base-7 t ((boot-strap initial)
                                 (add-shell enable)
                                 ((defn *1*defn) enable)
                                 (otherwise disable)))

|#

(make-lib "piton" t)
