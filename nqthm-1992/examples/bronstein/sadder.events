#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; sadder.bm: a serial adder (adds the last 2 values of the input)
; This is Paillet example 4, which has a totally fuzzy, and almost
; meaningless SPECIFICATION (verification condition).  Instead, we
; provide our OWN specs, in many different tastes:
; - in terms of stringfuns: correct-1-S
; - in terms of Lastchars (more intuitive):
; - with a "Done" line
; - or predicting "good" times (len x = 0 modulo 2)
;

;;; CIRCUIT in SUGARED form: 
#|
(setq sysd '(sy-SADDER (x)
(Y1 R 'a0 x) ; arbitrary initial value
(Y2 S plus Y1 x)
(Ydone R 1 Y4) ; specific initial value
(Y4 S bnot Ydone)
(Yout S bmux Ydone x Y2)
))

(setq sadder '(  |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_plus.bm: Plus combinational element.
; U7-DONE

;   no character function definition since BM already knows about Plus..

; Everything below generated by:     (bmcomb 'plus '() '(x y))

(DEFN S-PLUS (X Y)
      (IF (EMPTY X) (E) (A (S-PLUS (P X) (P Y)) (PLUS (L X) (L Y)))))

;; A2-Begin-S-PLUS

(PROVE-LEMMA A2-EMPTY-S-PLUS (REWRITE)
    (EQUAL (EMPTY (S-PLUS X Y)) (EMPTY X)) ((DISABLE PLUS)))

(PROVE-LEMMA A2-E-S-PLUS (REWRITE)
    (EQUAL (EQUAL (S-PLUS X Y) (E)) (EMPTY X))
    ((DISABLE S-PLUS A2-EMPTY-S-PLUS) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-PLUS))))

(PROVE-LEMMA A2-LP-S-PLUS (REWRITE) (EQUAL (LEN (S-PLUS X Y)) (LEN X))
    ((DISABLE PLUS) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-PLUS (REWRITE) (EQLEN (S-PLUS X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-PLUS)))

(PROVE-LEMMA A2-IC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-PLUS (I C_X X) (I C_Y Y))
                    (I (PLUS C_X C_Y) (S-PLUS X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I PLUS)))

(PROVE-LEMMA A2-LC-S-PLUS (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-PLUS X Y)) (PLUS (L X) (L Y))))
    ((DISABLE PLUS) (EXPAND (S-PLUS X Y))))

(PROVE-LEMMA A2-PC-S-PLUS (REWRITE)
    (EQUAL (P (S-PLUS X Y)) (S-PLUS (P X) (P Y))) ((DISABLE PLUS)))

(PROVE-LEMMA A2-HC-S-PLUS (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-PLUS X Y)) (PLUS (H X) (H Y))))
    ((DISABLE PLUS S-PLUS) (ENABLE H LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-PLUS X Y)) (S-PLUS (B X) (B Y))))
    ((DISABLE PLUS) (ENABLE B LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BNC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-PLUS X Y)) (S-PLUS (BN N X) (BN N Y))))
    ((DISABLE PLUS S-PLUS)))

;; A2-End-S-PLUS

; eof:comb_plus.bm

; comb_bnot.bm: Binary Not combinational element
; U7-DONE

(defn bnot (u)
  (if (equal u 0)
      1
      0))
	   
; Everything below generated by: (bmcomb 'bnot '() '(x))

(DEFN S-BNOT (X) (IF (EMPTY X) (E) (A (S-BNOT (P X)) (BNOT (L X)))))

;; A2-Begin-S-BNOT

(PROVE-LEMMA A2-EMPTY-S-BNOT (REWRITE)
    (EQUAL (EMPTY (S-BNOT X)) (EMPTY X)) ((DISABLE BNOT)))

(PROVE-LEMMA A2-E-S-BNOT (REWRITE)
    (EQUAL (EQUAL (S-BNOT X) (E)) (EMPTY X))
    ((DISABLE S-BNOT A2-EMPTY-S-BNOT) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-BNOT))))

(PROVE-LEMMA A2-LP-S-BNOT (REWRITE) (EQUAL (LEN (S-BNOT X)) (LEN X))
    ((DISABLE BNOT) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-BNOT (REWRITE) (EQLEN (S-BNOT X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-BNOT)))

(PROVE-LEMMA A2-IC-S-BNOT (REWRITE)
    (EQUAL (S-BNOT (I C_X X)) (I (BNOT C_X) (S-BNOT X)))
    ((ENABLE I) (DISABLE STR-A-I BNOT)))

(PROVE-LEMMA A2-LC-S-BNOT (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-BNOT X)) (BNOT (L X))))
    ((DISABLE BNOT) (EXPAND (S-BNOT X))))

(PROVE-LEMMA A2-PC-S-BNOT (REWRITE)
    (EQUAL (P (S-BNOT X)) (S-BNOT (P X))) ((DISABLE BNOT)))

(PROVE-LEMMA A2-HC-S-BNOT (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-BNOT X)) (BNOT (H X))))
    ((DISABLE BNOT S-BNOT) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-BNOT (REWRITE)
    (EQUAL (B (S-BNOT X)) (S-BNOT (B X))) ((DISABLE BNOT) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-BNOT (REWRITE)
    (EQUAL (BN N (S-BNOT X)) (S-BNOT (BN N X)))
    ((DISABLE BNOT S-BNOT)))

;; A2-End-S-BNOT

; eof:comb_bnot.bm

; comb_mux.bm: Mux combinational element, i.e. "if", but with 
; U7-DONE
;      control input binary-encoded (i.e. 0=F or 1=T) hardwired, no ref to bobi

(defn bmux (u1 u2 u3) (if (equal u1 1) u2 u3))

; everything below generated by: (bmcomb 'bmux '() '(x1 x2 x3))
; with the EXCEPTIONS/HAND-MODIFICATIONS given below.


(DEFN S-BMUX (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-BMUX (P X1) (P X2) (P X3)) (BMUX (L X1) (L X2) (L X3)))))

; SBMUX-is-SIF can make things much simpler on occasions:

(prove-lemma sbmux-is-sif (rewrite) 
    (equal (s-bmux x1 x2 x3) (s-if (s-equal x1 (s-const 1 x1)) x2 x3))
)

(disable sbmux-is-sif)

; We take advantage of SBMUX-is-SIF for all inductive proofs. To do so we
; HAND-MODIFY the code generated by Sugar to replace all the hints by:
;   - A2-EMPTY, A2-PC replace hint with: ((enable sbmux-is-sif)) 
;   - A2-LP, A2-IC, A2-HC, A2-BC: ((enable sbmux-is-sif) (disable len))
;   - A2-BNC: ((enable sbmux-is-sif) (disable bn len))

;; A2-Begin-S-BMUX

(PROVE-LEMMA A2-EMPTY-S-BMUX (REWRITE)
    (EQUAL (EMPTY (S-BMUX X1 X2 X3)) (EMPTY X1)) ((enable sbmux-is-sif)))

(PROVE-LEMMA A2-E-S-BMUX (REWRITE)
    (EQUAL (EQUAL (S-BMUX X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-BMUX A2-EMPTY-S-BMUX) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-BMUX))))

(PROVE-LEMMA A2-LP-S-BMUX (REWRITE)
    (EQUAL (LEN (S-BMUX X1 X2 X3)) (LEN X1))
    ((enable sbmux-is-sif) (disable len)))

(PROVE-LEMMA A2-LPE-S-BMUX (REWRITE) (EQLEN (S-BMUX X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-BMUX)))

(PROVE-LEMMA A2-IC-S-BMUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-BMUX (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (BMUX C_X1 C_X2 C_X3) (S-BMUX X1 X2 X3))))
    ((enable sbmux-is-sif) (disable len)))

(PROVE-LEMMA A2-LC-S-BMUX (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-BMUX X1 X2 X3)) (BMUX (L X1) (L X2) (L X3))))
    ((DISABLE BMUX) (EXPAND (S-BMUX X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-BMUX (REWRITE)
    (EQUAL (P (S-BMUX X1 X2 X3)) (S-BMUX (P X1) (P X2) (P X3)))
    ((enable sbmux-is-sif)))

(PROVE-LEMMA A2-HC-S-BMUX (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-BMUX X1 X2 X3)) (BMUX (H X1) (H X2) (H X3))))
    ((enable sbmux-is-sif) (disable len)))

;old: ((DISABLE BMUX S-BMUX) (ENABLE H LEN) (INDUCT (S-BMUX X1 X2 X3)))

(PROVE-LEMMA A2-BC-S-BMUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-BMUX X1 X2 X3))
                    (S-BMUX (B X1) (B X2) (B X3))))
    ((enable sbmux-is-sif) (disable len)))

;old: ((DISABLE BMUX) (ENABLE B LEN) (INDUCT (S-BMUX X1 X2 X3)))

(PROVE-LEMMA A2-BNC-S-BMUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-BMUX X1 X2 X3))
                    (S-BMUX (BN N X1) (BN N X2) (BN N X3))))
    ((enable sbmux-is-sif) (disable bn len)))

;old: ((DISABLE BMUX S-BMUX))

;; A2-End-S-BMUX

; eof:comb_bmux.bm


(DEFN TOPOR-SY-SADDER (LN) 
(IF (EQUAL LN 'Y1) 0 
(IF (EQUAL LN 'Y2) 1 
(IF (EQUAL LN 'YDONE) 0 
(IF (EQUAL LN 'Y4) 1 
(IF (EQUAL LN 'YOUT) 2 
0))))))

(DEFN SY-SADDER (LN X) 
(IF (EQUAL LN 'Y1) (IF (EMPTY X) (E) (I 'A0 (P X))) 
(IF (EQUAL LN 'Y2) (S-PLUS (SY-SADDER 'Y1 X) X) 
(IF (EQUAL LN 'YDONE) (IF (EMPTY X) (E) (I 1 (SY-SADDER 'Y4 (P X)))) 
(IF (EQUAL LN 'Y4) (S-BNOT (SY-SADDER 'YDONE X)) 
(IF (EQUAL LN 'YOUT) (S-BMUX (SY-SADDER 'YDONE X) X (SY-SADDER 'Y2 X)) 
(SFIX X))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-SADDER LN)))) )

;; A2-Begin-SY-SADDER

(PROVE-LEMMA A2-EMPTY-SY-SADDER (REWRITE)
    (EQUAL (EMPTY (SY-SADDER LN X)) (EMPTY X))
    ((DISABLE S-PLUS S-BNOT S-BMUX)))

(PROVE-LEMMA A2-E-SY-SADDER (REWRITE)
    (EQUAL (EQUAL (SY-SADDER LN X) (E)) (EMPTY X))
    ((DISABLE SY-SADDER A2-EMPTY-SY-SADDER) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-SADDER))))

(PROVE-LEMMA A2-LP-SY-SADDER (REWRITE)
    (EQUAL (LEN (SY-SADDER LN X)) (LEN X))
    ((DISABLE LEN S-PLUS S-BNOT S-BMUX) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-SADDER (REWRITE) (EQLEN (SY-SADDER LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-SADDER)))

(PROVE-LEMMA A2-PC-SY-SADDER (REWRITE)
    (EQUAL (P (SY-SADDER LN X)) (SY-SADDER LN (P X)))
    ((DISABLE S-PLUS S-BNOT S-BMUX A2-IC-S-PLUS A2-IC-S-BNOT
              A2-IC-S-BMUX)))

;; A2-End-SY-SADDER

;;; Circuit CORRECTNESS /Paillet:

;; we can do the actual Deroulement, which is a very WEAK spec 
;; indeed..

(prove-lemma sadder-Paillet ()
(implies (equal (len x) 2)
	 (equal (L (sy-sadder 'Yout x))
		(plus (L (P x)) (L x))
		))
((enable LEN)  ; obviously  - note: STR-not-empty-len didn't help
 (expand (SY-SADDER 'YOUT X)
	 (SY-SADDER 'YDONE X)
	 (SY-SADDER 'Y2 X)
	 (SY-SADDER 'Y4 (P X))
	 (SY-SADDER 'YDONE (P X))
	 )
 )
)

;; or we can prove the natural spec:

(prove-lemma sadder-correct-1 (rewrite)
(implies (not (empty (P x)))
	 (equal (L (sy-sadder 'Yout x))
		(if (equal (L (sy-sadder 'Ydone x)) 1)
		    (L x)
		    (plus (L (P x)) (L x) ))))
((expand (sy-sadder 'Yout x)
	 (SY-SADDER 'Y2 X)
	 )
 )
)

(prove-lemma sadder-but-wiser () 
	'horning-said-that
)

;; There are 2 lessons from the above lemma:
;; 1) if you're reading this in the thesis, congratulations 
;;    for reading so far.
;; 2) if someone claims he proved some formula mechanically,
;;    make sure the formula means something...


;; we could look at it in terms of STRING-FUNS:

(defn sadder-spec-S (x)
(S-if (S-equal (sy-sadder 'Ydone x) (S-const 1 (sy-sadder 'Ydone x)))
      x
      (S-plus (P x) x))
)

; one "trick" which makes this weird (non-MLP looking) spec work:

(prove-lemma s-plus-one-off (rewrite)
(implies (not (empty x))
	 (equal (S-plus (I u (P x)) x)
		(I (plus u (H x)) (S-plus (P x) x))))
((enable I H EMPTY) (disable STR-A-I)) ; because we are dealing with the beginning...
)

; and the second "trick" is that the off-by-one sum, and the 
; toggling contribute to working things out:

(prove-lemma sadder-correct-1-S-key (rewrite)
(equal (S-IF (S-EQUAL (SY-SADDER 'Ydone x) (S-CONST 1 (SY-SADDER 'Ydone x)))
	     x
	     (I u (S-PLUS (P x) x)))
       (S-IF (S-EQUAL (SY-SADDER 'Ydone x) (S-CONST 1 (SY-SADDER 'Ydone x)))
	     x
	     (S-PLUS (P x) x)))
((induct (induct-P x)))
)

(prove-lemma sadder-correct-1-S (rewrite)
(equal (sy-sadder 'Yout x)
       (sadder-spec-S x))
((expand (sy-sadder 'Yout x)
	 (SY-SADDER 'Y2 X)
	 )
 (enable sbmux-is-sif) ; because "key" lemma was developed that way..
 )
)

;; Going back to looking in terms of Last-chars, we would most 
;; likely only specify (more partially):

(prove-lemma sadder-correct-2 (rewrite)
(implies (and (not (empty x)) (not (empty (P x)))
	      (equal (L (sy-sadder 'Ydone x)) 0)
	      )
	 (equal (L (sy-sadder 'Yout x))
		(plus (L (P x)) (L x) )))
)

; Note: sadder-correct-2 is proved immediately from correct-1 or 
; correct-1-S, or can be obtained from scratch with the same hints 
; as correct-1. 
; The fact that such a partial spec is BM-provable probably depends
; on the fact that it requires NO induction.  In cases with 
; induction, too weak a spec would probably not go through.  In
; other words, we might have to specify a second property which 
; also specifies what happens in the "previous" or "uninteresting" 
; (Done not raised) cases.

; Another way to look at the spec is to PREDICT the timing of the 
; output, as opposed to just looking at the Done (Ydone) line.
; This of course will not always be possible. The key to the
; prediction is:

(prove-lemma sadder-correct-3-Ydone (rewrite)
(implies (not (empty x))
	 (equal (L (sy-sadder 'Ydone x))
		(if (equal (remainder (len x) 2) 0)
		    0
		    1)))
((enable LEN)) ; used meaningfully in spec
)

; or with a bit more work we can prove the 2-tick rhythm:

(prove-lemma sadder-correct-3 (rewrite)
(implies (and (not (empty x)) (equal (remainder (len x) 2) 0) )
	 (equal (L (sy-sadder 'Yout x))
		(plus (L (P x)) (L x) )))
((disable sadder-correct-1-s) ; this is not necessary, but it makes 
                              ; sadder-correct-2 trigger,which is more natural
 (enable LEN) ; without it: BM gets stuck in the stupid case of the elimination
              ; whereas with LEN around it reduces it to arithmetic.  This
              ; does mean that on the long run we want the right elimination
              ; for EMPTY DISABLED, and then we can probably get rid of len.
 )
)

; Note: removing the hyp: (not (empty (P x))) is not harmful,
; but it just forces BM into a couple of cases and 1 elimination 
; before it gets to the real meat.

; eof: sadder.bm
;))

