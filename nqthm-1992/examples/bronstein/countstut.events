#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; countstut.bm: a simple clock counter, and a STUTTERING version of it,
;     to test Stutter formalizaton. 
;
; . A2PC blows up on stuttering version, but that's been reduced to a
; a very trivial version (3 lines) which also blows up and on which one
; can see that BM loops without any rule: one of the equality hyp. is used
; in the opposite direction as the definition expansion.  
; We use ADD-AXIOM on A2-PCs which blow.
;

;;; DEFINITION OF CIRCUITs:
#|
(setq A '(sy-A (x)
(Yout R 0 Y1)
(Y1 S Inc Yout)
))

(setq B '(sy-B (x)
(Yout R 0 Y1m)
(Y1m S Mux Yst Yout Y1)
(Y1 S Inc Yout)
(Yst R T Yst1)
(Yst1 S Not Yst)
))

(setq C '(sy-C (xst)
(Yout R 0 Y1m)
(Y1m S Mux xst Yout Y1)
(Y1 S Inc Yout)
))

(setq countstut '( |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_inc.bm: INCrement combinational element
; U7-DONE

(defn Inc (u) (add1 u))

; Everything below generated by: (bmcomb 'inc '() '(x))

(DEFN S-INC (X) (IF (EMPTY X) (E) (A (S-INC (P X)) (INC (L X)))))

;; A2-Begin-S-INC

(PROVE-LEMMA A2-EMPTY-S-INC (REWRITE)
    (EQUAL (EMPTY (S-INC X)) (EMPTY X)) ((DISABLE INC)))

(PROVE-LEMMA A2-E-S-INC (REWRITE)
    (EQUAL (EQUAL (S-INC X) (E)) (EMPTY X))
    ((DISABLE S-INC A2-EMPTY-S-INC) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-INC))))

(PROVE-LEMMA A2-LP-S-INC (REWRITE) (EQUAL (LEN (S-INC X)) (LEN X))
    ((DISABLE INC) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-INC (REWRITE) (EQLEN (S-INC X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-INC)))

(PROVE-LEMMA A2-IC-S-INC (REWRITE)
    (EQUAL (S-INC (I C_X X)) (I (INC C_X) (S-INC X)))
    ((ENABLE I) (DISABLE STR-A-I INC)))

(PROVE-LEMMA A2-LC-S-INC (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-INC X)) (INC (L X))))
    ((DISABLE INC) (EXPAND (S-INC X))))

(PROVE-LEMMA A2-PC-S-INC (REWRITE) (EQUAL (P (S-INC X)) (S-INC (P X)))
    ((DISABLE INC)))

(PROVE-LEMMA A2-HC-S-INC (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-INC X)) (INC (H X))))
    ((DISABLE INC S-INC) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-INC (REWRITE) (EQUAL (B (S-INC X)) (S-INC (B X)))
    ((DISABLE INC) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-INC (REWRITE)
    (EQUAL (BN N (S-INC X)) (S-INC (BN N X))) ((DISABLE INC S-INC)))

;; A2-End-S-INC

; eof:comb_inc.bm


(DEFN TOPOR-SY-A (LN) 
(IF (EQUAL LN 'YOUT) 0 
(IF (EQUAL LN 'Y1) 1 
0)))

(DEFN SY-A (LN X) 
(IF (EQUAL LN 'YOUT) (IF (EMPTY X) (E) (I 0 (SY-A 'Y1 (P X)))) 
(IF (EQUAL LN 'Y1) (S-INC (SY-A 'YOUT X)) 
(SFIX X)))
((LEX2 (LIST (COUNT X) (TOPOR-SY-A LN)))) )

;; A2-Begin-SY-A

(PROVE-LEMMA A2-EMPTY-SY-A (REWRITE)
    (EQUAL (EMPTY (SY-A LN X)) (EMPTY X)) ((DISABLE S-INC)))

(PROVE-LEMMA A2-E-SY-A (REWRITE)
    (EQUAL (EQUAL (SY-A LN X) (E)) (EMPTY X))
    ((DISABLE SY-A A2-EMPTY-SY-A) (ENABLE EMPTY) (USE (A2-EMPTY-SY-A))))

(PROVE-LEMMA A2-LP-SY-A (REWRITE) (EQUAL (LEN (SY-A LN X)) (LEN X))
    ((DISABLE LEN S-INC) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-A (REWRITE) (EQLEN (SY-A LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-A)))

(PROVE-LEMMA A2-PC-SY-A (REWRITE)
    (EQUAL (P (SY-A LN X)) (SY-A LN (P X)))
    ((DISABLE S-INC A2-IC-S-INC)))

;; A2-End-SY-A
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_mux.bm: Mux combinational element, i.e. "if".
; U7-DONE

(defn mux (u1 u2 u3) (if u1 u2 u3))

; everything below generated by: (bmcomb 'mux '() '(x1 x2 x3))
; with the EXCEPTIONS/HAND-MODIFICATIONS given below.

(DEFN S-MUX (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-MUX (P X1) (P X2) (P X3)) (MUX (L X1) (L X2) (L X3)))))

; SMUX-is-SIF can make things much simpler on occasions:

(prove-lemma smux-is-sif (rewrite) 
    (equal (s-mux x1 x2 x3) (s-if x1 x2 x3)))

(disable smux-is-sif)

; We take advantage of SMUX-is-SIF for all inductive proofs. To do so we
; HAND-MODIFY the code generated by Sugar to replace all the hints by
;   - A2-EMPTY, A2-PC replace hint with: ((enable smux-is-sif)) 
;   - A2-LP, A2-IC, A2-HC, A2-BC: ((enable smux-is-sif) (disable len))
;   - A2-BNC: ((enable smux-is-sif) (disable bn len))

;; A2-Begin-S-MUX

(PROVE-LEMMA A2-EMPTY-S-MUX (REWRITE)
    (EQUAL (EMPTY (S-MUX X1 X2 X3)) (EMPTY X1)) ((enable smux-is-sif)))

(PROVE-LEMMA A2-E-S-MUX (REWRITE)
    (EQUAL (EQUAL (S-MUX X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-MUX A2-EMPTY-S-MUX) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-MUX))))

(PROVE-LEMMA A2-LP-S-MUX (REWRITE)
    (EQUAL (LEN (S-MUX X1 X2 X3)) (LEN X1))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LPE-S-MUX (REWRITE) (EQLEN (S-MUX X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-MUX)))

(PROVE-LEMMA A2-IC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-MUX (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (MUX C_X1 C_X2 C_X3) (S-MUX X1 X2 X3))))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LC-S-MUX (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-MUX X1 X2 X3)) (MUX (L X1) (L X2) (L X3))))
    ((DISABLE MUX) (EXPAND (S-MUX X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-MUX (REWRITE)
    (EQUAL (P (S-MUX X1 X2 X3)) (S-MUX (P X1) (P X2) (P X3)))
    ((enable smux-is-sif)))

(PROVE-LEMMA A2-HC-S-MUX (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-MUX X1 X2 X3)) (MUX (H X1) (H X2) (H X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX S-MUX) (ENABLE H LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-MUX X1 X2 X3)) (S-MUX (B X1) (B X2) (B X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX) (ENABLE B LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BNC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-MUX X1 X2 X3))
                    (S-MUX (BN N X1) (BN N X2) (BN N X3))))
    ((enable smux-is-sif) (disable bn len)))

;old: ((DISABLE MUX S-MUX))

;; A2-End-S-MUX

; eof:comb_mux.bm

;; already loaded in A: (LOAD "Comb/comb_inc.bm")

(DEFN TOPOR-SY-B (LN) 
(IF (EQUAL LN 'YOUT) 0 
(IF (EQUAL LN 'Y1M) 2 
(IF (EQUAL LN 'Y1) 1 
(IF (EQUAL LN 'YST) 0 
(IF (EQUAL LN 'YST1) 1 
0))))))

(DEFN SY-B (LN X) 
(IF (EQUAL LN 'YOUT) (IF (EMPTY X) (E) (I 0 (SY-B 'Y1M (P X)))) 
(IF (EQUAL LN 'Y1M) (S-MUX (SY-B 'YST X) (SY-B 'YOUT X) (SY-B 'Y1 X)) 
(IF (EQUAL LN 'Y1) (S-INC (SY-B 'YOUT X)) 
(IF (EQUAL LN 'YST) (IF (EMPTY X) (E) (I T (SY-B 'YST1 (P X)))) 
(IF (EQUAL LN 'YST1) (S-NOT (SY-B 'YST X)) 
(SFIX X))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-B LN)))) )

;; A2-Begin-SY-B

(PROVE-LEMMA A2-EMPTY-SY-B (REWRITE)
    (EQUAL (EMPTY (SY-B LN X)) (EMPTY X))
    ((DISABLE S-MUX S-INC S-NOT)))

(PROVE-LEMMA A2-E-SY-B (REWRITE)
    (EQUAL (EQUAL (SY-B LN X) (E)) (EMPTY X))
    ((DISABLE SY-B A2-EMPTY-SY-B) (ENABLE EMPTY) (USE (A2-EMPTY-SY-B))))

(PROVE-LEMMA A2-LP-SY-B (REWRITE) (EQUAL (LEN (SY-B LN X)) (LEN X))
    ((DISABLE LEN S-MUX S-INC S-NOT) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-B (REWRITE) (EQLEN (SY-B LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-B)))

; See note at top of file.
;(PROVE-LEMMA A2-PC-SY-B (REWRITE)
;    (EQUAL (P (SY-B LN X)) (SY-B LN (P X)))
;    ((DISABLE S-MUX S-INC S-NOT A2-IC-S-MUX A2-IC-S-INC A2-IC-S-NOT)))
(add-axiom A2-PC-SY-B (REWRITE)
    (EQUAL (P (SY-B LN XST)) (SY-B LN (P XST)))
    )

;; A2-End-SY-B

; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
;; already loaded: (LOAD "Comb/comb_mux.bm")
;; already loaded: (LOAD "Comb/comb_inc.bm")

(DEFN TOPOR-SY-C (LN) 
(IF (EQUAL LN 'YOUT) 0 
(IF (EQUAL LN 'Y1M) 2 
(IF (EQUAL LN 'Y1) 1 
0))))

(DEFN SY-C (LN XST) 
(IF (EQUAL LN 'YOUT) (IF (EMPTY XST) (E) (I 0 (SY-C 'Y1M (P XST)))) 
(IF (EQUAL LN 'Y1M) (S-MUX XST (SY-C 'YOUT XST) (SY-C 'Y1 XST)) 
(IF (EQUAL LN 'Y1) (S-INC (SY-C 'YOUT XST)) 
(SFIX XST))))
((LEX2 (LIST (COUNT XST) (TOPOR-SY-C LN)))) )

;; A2-Begin-SY-C

(PROVE-LEMMA A2-EMPTY-SY-C (REWRITE)
    (EQUAL (EMPTY (SY-C LN XST)) (EMPTY XST)) ((DISABLE S-MUX S-INC)))

(PROVE-LEMMA A2-E-SY-C (REWRITE)
    (EQUAL (EQUAL (SY-C LN XST) (E)) (EMPTY XST))
    ((DISABLE SY-C A2-EMPTY-SY-C) (ENABLE EMPTY) (USE (A2-EMPTY-SY-C))))

(PROVE-LEMMA A2-LP-SY-C (REWRITE) (EQUAL (LEN (SY-C LN XST)) (LEN XST))
    ((DISABLE LEN S-MUX S-INC) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-C (REWRITE) (EQLEN (SY-C LN XST) XST)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-C)))

; blows..
;(PROVE-LEMMA A2-PC-SY-C (REWRITE)
;    (EQUAL (P (SY-C LN XST)) (SY-C LN (P XST)))
;    ((DISABLE S-MUX S-INC A2-IC-S-MUX A2-IC-S-INC)))
; so TEMPORARILY:
(add-axiom A2-PC-SY-C (REWRITE)
    (EQUAL (P (SY-C LN XST)) (SY-C LN (P XST)))
    )

;; A2-End-SY-C

;;; BEGIN: Circuit CORRECTNESS modulo Stuttering.

;; BEGIN: new 2nd order properties for combinationals.

;; END: new 2nd order properties for combinationals.

;;; Get STUTTER theory:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 				TH_STUTTER.BM
;;;
;;; This file contains Stutter theory for BM.  It is supposed to be
;;; loaded directly when needed (i.e. not general enough to be 
;;; stored in Lib/mlp).
;;;

;;; Our current double P-recursive def. of Stutter:
;;; Originally, it came from THETA-PRF-79 (done while babysitting
;;; for Caroline...) followed by MUCH experimentation and fiddling.


(defn Stut-R (x y)
(if (empty y)
    x
    (if (empty (P y))
	(B x)
        (if (L (P y))
	    (Stut-R x (P y))
	    (B (Stut-R x (P y)))))))

(defn Stut (x y)
(if (empty y)
    (e)
    (if (empty (P y))
	(A (e) (H x))
        (if (L (P y))
	    (A (Stut (P x) (P y)) (L (Stut (P x) (P y))))
	    (A (Stut (P x) (P y)) (H (Stut-R x (P y))))))))

; Stut-Induct inducts like stut, but without the case disjunction 
; on LPx which is useless when we stutter on a line rather than an 
; input. The resulting induction is not very different from a 
; straight P induction, but it takes care of the empty Px case 
; separately, and without bringing an elimination.

(defn Stut-Induct (x)
(if (empty x)
    0
    (if (empty (P x))
	1
        (stut-induct (P x))))
)

;; Properties of Stut:

(prove-lemma Stut-Empty (rewrite)
(equal (empty (Stut x y))
       (empty y))
)

(prove-lemma Stut-E (rewrite)
(equal (equal (Stut x y) (e))
       (empty y))
((DISABLE Stut Stut-Empty) (ENABLE EMPTY)
 (USE (Stut-Empty))
 )
)

(prove-lemma Stut-P (rewrite)
(equal (P (Stut x y))
       (Stut (P x) (P y))
       )
)

;; Properties of Stut-R:

; Stut-R-E maybe shouldn't be enabled all the time, but when we're 
; doing P inductions on Stut-R, this gives the base case.  The 
; induction step is given by Stut-R-P.  Note that we don't have a 
; full empty x hyp because Stut-R returns x and not sfix x in case
; y is empty...  Maybe we want to fix that at some point.

(prove-lemma Stut-R-E (rewrite)
(equal (Stut-R (e) y)
       (e))
)

(prove-lemma Stut-R-P (rewrite)
(equal	(P (Stut-R x y))
	(Stut-R (P x) y))
)

(prove-lemma Stut-R-len (rewrite)
(lessp (len x)
       (add1 (plus (len y) (len (Stut-R x y)))))
((enable len))
)

(prove-lemma Stut-R-not-empty (rewrite)
(implies (lessp (len y) (len x))
	 (not (empty (Stut-R x y))))
((use (Stut-R-len))
 (enable len)
 )
)

; Stut-Rem removes the trailing Ts of y, but ignores Ly (like R) 
; and leaves one T: this weird def, so it works like Stut-R needs!

(defn Stut-Rem (y)
(if (empty y)
    (e)
    (if (empty (P y))
	y
        (if (L (P y))
	    (Stut-Rem (P y))
	    y))))

(prove-lemma Stut-Rem-empty (rewrite)
(equal (empty (Stut-Rem x))
       (empty x))
)

(prove-lemma Stut-Rem-len (rewrite)
(lessp (len (Stut-Rem x)) (add1 (len x)))
((enable len))
)

(prove-lemma Stut-Rem-len2 (rewrite)
(implies (and (not (empty (P x)))
	      (L (P x)))
	 (lessp (len (Stut-Rem x)) (len x)))
((enable len))
)


; Stut-Num counts the number of F in y, ignoring Ly, and starts 
; w/ 1, like Stut.
(defn Stut-Num (y)
(if (empty y)
    0
    (if (empty (P y))
	1
        (if (L (P y))
	    (Stut-Num (P y))
	    (add1 (Stut-Num (P y)))))))

(prove-lemma Stut-Num-lessp (rewrite)
(lessp (Stut-Num x) (add1 (len x)))
((enable len))
)

(prove-lemma Stut-Num-eq-0 (rewrite)
(equal (equal (Stut-Num x) 0)
       (empty x))
)


; Requires a small induction.
(prove-lemma Stut-Num-Rem-len (rewrite)
(implies (not (empty x))
	 (lessp (Stut-Num (P (Stut-Rem x)))
		(len x)
		))
((enable len))
)

; From Stut-Num and Bn we get a CLOSED FORM for Stut-R !!!

(prove-lemma Stut-R-closed (rewrite)
(equal (Stut-R x y)
       (Bn (Stut-Num y) x))
)

; Stut-inv is the key invariant property during Stuttering:

(prove-lemma Stut-inv (rewrite)
(implies (and (not (empty y))
	      (not (lessp (len x) (len y))))
	 (equal (L (Stut x y))
		(H (Stut-R x (P (Stut-Rem y))))))
((enable len H)
 (induct (Stut x y))
 (disable STR-L-Bn) ; interferes (slowdown)
 )
)
; but we only want to use it during the non-stuttering induction 
; step, and not in general so:

(prove-lemma Stut-inv0 (rewrite)
(implies (and (not (empty y))
	      (not (lessp (len x) (len y)))
	      (not (L y))
	      )
	 (equal (L (Stut x y))
		(H (Stut-R x (P (Stut-Rem y))))))
((disable Stut-Rem Stut Stut-R Stut-R-closed len))
)

(disable Stut-inv)

; Now we relate Stut-R for Py and P Rem Py, to get the key to the
; induction step on main Stut inductions, in the non-stuttering 
; case.
;
; It's a BAD rewrite (i.e. expanding, potentially self-applicable),
; and so are the preliminary lemmas needed to build to it.  This
; is not just an unfortunate construction.  It's inherent, because
; we're essentially giving an alternate definition via a Stut-Rem
; recursion.  And definitions are expanding, self-applicable, 
; rewrites.  We get around the problem by lucking out: the
; hypotheses are sufficient to prevent successful self-applic.

(prove-lemma Stut-R-indstep-Num (rewrite)
(implies (and (not (empty x))
	      (L x))
	 (equal (Stut-Num x)
		(add1 (Stut-Num (P (Stut-Rem x))))))
((disable stut-num-rem-len))
)
(disable Stut-R-indstep-Num)

; OLD induction step prereq: not needed anymore.
;
;(prove-lemma Stut-R-indstep-Num-Rem (rewrite) 
;(implies (and (not (empty y))
;	      (not (empty (P y)))
;	      (not (L (P y)))
;	      )
;	 (equal (Stut-Num (P (Stut-Rem (P y))))
;		(sub1 (Stut-Num (P (Stut-Rem y))))
;		))
;((enable Stut-R-indstep-Num))
;)
;(disable Stut-R-indstep-Num-Rem)

; OLD induction step: not needed anymore.
;
;(prove-lemma Stut-indstep (rewrite)
;(implies (and (not (empty y))
;	      (not (empty (P y)))
;	      (not (L (P y)))
;	      )
;	 (equal (Stut-R x (P y))
;		(B (Stut-R x (P (Stut-Rem (P y)))))
;		))
;((enable Stut-R-indstep-Num-Rem B-Bn-sub1)
; (disable Bn)
; )
;)
;(disable Stut-indstep) ; potentially self-looping... 
;                       ; so we enable explicitely.


; NEW & GENERALIZED induction step hack , note: needs just ONE
; prereq! We're getting cleaner...

(prove-lemma Stut-R-indstep (rewrite)
(implies (and (not (empty y))
	      (not (L y))
	      )
	 (equal (Stut-R x y)
		(B (Stut-R x (P (Stut-Rem y))))
		))
((enable Stut-R-indstep-Num))
)
(disable Stut-R-indstep)

; all the internal stuff shouldn't be needed outside:

(disable Stut-R)
(disable Stut-Num)
(disable Stut-Rem)

; Note: by leaving Stut, Stut-inv0, Stut-R-closed enabled, we get
;   the effect of an alternate recursive definition of Stut in the
;   most convenient form.  The remaining uncleanliness is that
;   Stut-R-indstep and Stut-R-closed match the same stuff, and need
;   to be used at different places in the main proof.  So far, we
;   survive by extreme cunning: they are in the right order, and
;   the hypothesis on Stut-R-indstep prevents wrong occurences. 
;   This is neither clear nor robust...

;; eof: th_stutter.bm


;; BEGIN: ACTUAL Circuit CORRECTNESS modulo Stuttering.

; REVERSAL PROPERTY for sy-a:

(prove-lemma sy-a-reversal (rewrite)
(implies (not (empty (BN N (SY-A 'YOUT (P X)))))
	 (EQUAL (H (B (BN n (SY-A 'YOUT X))))
		(ADD1 (H (BN n (SY-A 'YOUT (P X)))))))
((disable Bn STR-Bn-empty)
 (expand  (SY-A 'YOUT X)
	  )
 )
)

(prove-lemma  Count-AC-L (rewrite)
(equal (L (Stut (sy-a 'yout xst) xst))
       (L (sy-c 'yout xst)))
((expand (SY-C 'YOUT XST)
	 (SY-C 'Y1M (P XST))
	 )  ; necessary
 (enable Stut-R-indstep) ; new Stut-R-indstep doesn't seem to cost any more than the old
 (induct (Stut x xst))  ; not necessary, but speeds up by 2;may not be general.
 )
)


; Now extending to strings.  For some unknow reason, compared to Funacc, we 
; need BOTH splits here... Probably because of some weird non-triggering
; phenomenon in equality hyp usage.

(prove-lemma APL-split-Cout () ; USE hints only.
(implies (not (empty x))
	 (equal (sy-c 'Yout x)
		(A (P (sy-c 'Yout x))
		   (L (sy-c 'Yout x)) )))
((disable sy-c a2-pc-sy-c)
 )
)

(prove-lemma APL-split-StutA () ; USE hints only.
(implies (not (empty x))
	 (equal (Stut (sy-a 'Yout x) x)
		(A (P (Stut (sy-a 'Yout x) x))
		   (L (Stut (sy-a 'Yout x) x)) )))
((disable Stut Stut-P Stut-inv0 Count-AC-L)
 )
)

; and finally:

(prove-lemma Count-AC-correct (rewrite)
(equal (Stut (sy-a 'yout xst) xst)
       (sy-c 'yout xst))
((induct (induct-P xst))
 (disable Stut Stut-inv0 Stut-R-Closed sy-A A-P-L
	  ) ; needs  A2-PC's for A,C, and Stut, and Sy-C
 (use (APL-split-Cout (x xst))
      (APL-split-StutA (x xst))
      )
 )
)

;; END: ACTUAL Circuit CORRECTNESS modulo Stuttering for A and C.

(disable Count-AC-L)
(disable Count-AC-correct)

; HCorr properties are the "Hand-Correctness" formulas... They are not
; necessary for the proof of Count-AB-L, but I'm trying to see if they help.

(prove-lemma HCorr-AB-T (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (L (sy-b 'yst (P x)))
	      )
	 (equal (L (sy-b 'yout x))
		(L (sy-b 'yout (P x)))))
((expand (SY-B 'YOUT X)
	 (SY-B 'Y1M (P X))
	 )  ; necessary
 )
)
(disable  HCorr-AB-T)  ; obviously..

(prove-lemma HCorr-AB-F (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (not (L (sy-b 'yst (P x))))
	      )
	 (equal (L (sy-b 'yout x))
		(add1 (L (sy-b 'yout (P x))))))
((expand (SY-B 'YOUT X)
	 (SY-B 'Y1M (P X))
	 )  ; necessary
 )
)
(disable  HCorr-AB-F)

; Count-AB-L succeeds with either HCorrs enabled, or the expansion hint 
; therein.  The costs (time/clarity) seem equal.  In the future, if the
; effort involved in getting HCorrs is greater, the dichotomy may be useful.

(prove-lemma Count-AB-L (rewrite)
(equal (L (Stut (sy-a 'yout x) (sy-b 'yst x)))
       (L (sy-b 'yout x)))
((enable Stut-R-indstep HCorr-AB-T HCorr-AB-F)
 (induct (stut-induct x))
 )
)

(prove-lemma APL-split-Bout () ; USE hints only.
(implies (not (empty x))
	 (equal (sy-b 'Yout x)
		(A (P (sy-b 'Yout x))
		   (L (sy-b 'Yout x)) )))
((disable sy-b a2-pc-sy-b)
 )
)

(prove-lemma APL-split-StutA2 () ; USE hints only.
(implies (not (empty x))
	 (equal (Stut (sy-a 'Yout x) (sy-b 'yst x))
		(A (P (Stut (sy-a 'Yout x) (sy-b 'yst x)))
		   (L (Stut (sy-a 'Yout x) (sy-b 'yst x))) )))
((disable Stut Stut-P Stut-inv0 Count-AB-L)
 )
)

(prove-lemma Count-AB-correct (rewrite)
(equal (Stut (sy-a 'yout x) (sy-b 'yst x))
       (sy-b 'yout x))
((induct (induct-P x))
 (disable Stut Stut-inv0 Stut-R-Closed sy-A A-P-L
	  ) ; needs  A2-PC's for A,B, and Stut, and Sy-B
 (use (APL-split-Bout)
      (APL-split-StutA2)
      )
 )
)

;; END: ACTUAL Circuit CORRECTNESS modulo Stuttering for A and B.
; eof: countstut.bm
; ))

