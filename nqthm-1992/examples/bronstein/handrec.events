#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; handrec.bm: a HANDSHAKE RECEIVER piece, Paillet #6
;
;  Note: The same remark as for Serial applies: we were able to get 
;  this whole multi-input circuit through without EQ-LEN hyps, but 
;  that's because of a lucky shot in line Y4 (order made right).
;  The more general version is of course slower and uglier...
;

;;; CIRCUIT in SUGARED form:
#|
(setq sysd '(sy-HANDREC (Xcall Xm)
(Yrcall R F Xcall)
(Y0 S not Yrcall)
(Y1 S and Yrcall Yhear)
(Y2 S or Y0 Y1)
(Y3 S and Xcall Y2)
(Y4 S and Xcall Xm)
(Y5 S and Y4 Y0)
(Yhear R F Y3)
(Yinfin R F Y5)
))

(setq handrec '( |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:

(DEFN TOPOR-SY-HANDREC (LN) 
(IF (EQUAL LN 'YRCALL) 0 
(IF (EQUAL LN 'Y0) 1 
(IF (EQUAL LN 'Y1) 1 
(IF (EQUAL LN 'Y2) 2 
(IF (EQUAL LN 'Y3) 3 
(IF (EQUAL LN 'Y4) 1 
(IF (EQUAL LN 'Y5) 2 
(IF (EQUAL LN 'YHEAR) 0 
(IF (EQUAL LN 'YINFIN) 0 
0))))))))))

(DEFN SY-HANDREC (LN XCALL XM) 
(IF (EQUAL LN 'YRCALL) (IF (EMPTY XCALL) (E) (I F (P XCALL))) 
(IF (EQUAL LN 'Y0) (S-NOT (SY-HANDREC 'YRCALL XCALL XM)) 
(IF (EQUAL LN 'Y1) (S-AND (SY-HANDREC 'YRCALL XCALL XM)
                          (SY-HANDREC 'YHEAR XCALL XM)) 
(IF (EQUAL LN 'Y2) (S-OR (SY-HANDREC 'Y0 XCALL XM)
                         (SY-HANDREC 'Y1 XCALL XM)) 
(IF (EQUAL LN 'Y3) (S-AND XCALL (SY-HANDREC 'Y2 XCALL XM)) 
(IF (EQUAL LN 'Y4) (S-AND XCALL XM) 
(IF (EQUAL LN 'Y5) (S-AND (SY-HANDREC 'Y4 XCALL XM)
                          (SY-HANDREC 'Y0 XCALL XM)) 
(IF (EQUAL LN 'YHEAR) (IF (EMPTY XCALL) (E)
                          (I F (SY-HANDREC 'Y3 (P XCALL) (P XM)))) 
(IF (EQUAL LN 'YINFIN) (IF (EMPTY XCALL) (E)
                           (I F (SY-HANDREC 'Y5 (P XCALL) (P XM)))) 
(SFIX XCALL))))))))))
((LEX2 (LIST (COUNT XCALL) (TOPOR-SY-HANDREC LN)))) )

;; A2-Begin-SY-HANDREC

(PROVE-LEMMA A2-EMPTY-SY-HANDREC (REWRITE)
    (IMPLIES (EQUAL (LEN XCALL) (LEN XM))
             (EQUAL (EMPTY (SY-HANDREC LN XCALL XM)) (EMPTY XCALL)))
    ((DISABLE LEN S-NOT S-OR S-AND) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-E-SY-HANDREC (REWRITE)
    (IMPLIES (EQUAL (LEN XCALL) (LEN XM))
             (EQUAL (EQUAL (SY-HANDREC LN XCALL XM) (E)) (EMPTY XCALL)))
    ((DISABLE LEN SY-HANDREC A2-EMPTY-SY-HANDREC) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-HANDREC))))

(PROVE-LEMMA A2-LP-SY-HANDREC (REWRITE)
    (IMPLIES (EQUAL (LEN XCALL) (LEN XM))
             (EQUAL (LEN (SY-HANDREC LN XCALL XM)) (LEN XCALL)))
    ((DISABLE LEN S-NOT S-OR S-AND) (ENABLE STR-ADD1-LEN-P STR-LEN-E)))

(PROVE-LEMMA A2-LPE-SY-HANDREC (REWRITE)
    (IMPLIES (EQUAL (LEN XCALL) (LEN XM))
             (EQLEN (SY-HANDREC LN XCALL XM) XCALL))
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-HANDREC)))

(PROVE-LEMMA A2-PC-SY-HANDREC (REWRITE)
    (IMPLIES (EQUAL (LEN XCALL) (LEN XM))
             (EQUAL (P (SY-HANDREC LN XCALL XM))
                    (SY-HANDREC LN (P XCALL) (P XM))))
    ((DISABLE LEN S-NOT S-OR S-AND A2-IC-S-NOT A2-IC-S-OR A2-IC-S-AND)
     (ENABLE STR-ADD1-LEN-P)))

;; A2-End-SY-HANDREC

;;; Circuit CORRECTNESS /Paillet:

; The first correctness formula derived from the temporal logic spec
; is below, suitably accounting for the initial value output by the 
; circuit.
; Optimization notes: disabling:
;  - EMPTY alone helps in cases: 20 -> 8, but little in time: 
; 56 -> 51
;  - LEN alone helps a little in cases: 20 -> 16, a little in
; time: 56 -> 47
; both results in 16 cases (because STR-L-I fails) and 36s.
; Enabling STR-L-I2 then reduces to 4 cases and 25s.
;  
(prove-lemma correct-handrec-hear-L (rewrite)
(implies (and (not (empty Xcall))
	      (S-boolp Xcall)
	      (equal (len Xcall) (len Xm))
	      )
(equal (L (sy-HANDREC 'Yhear Xcall Xm))
       (if (empty (P Xcall))
	   F
	   (L (P Xcall)))))
((induct (induct-P2 Xcall Xm))
 (expand (sy-HANDREC 'Yhear Xcall Xm) 
	 (SY-HANDREC 'Y3 (P XCALL) (P XM))
	 (SY-HANDREC 'Y2 (P XCALL) (P XM))
	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
	 (SY-HANDREC 'Y1 (P XCALL) (P XM))
	 )
 (disable EMPTY LEN)
 (enable STR-L-I2) 
 )
)

; naturally we can weaken this theorem to look like Paillet:

(prove-lemma correct-handrec-hear-Paillet ()
(implies (and (not (empty (P Xcall)))
	      (S-boolp Xcall)
	      (equal (len Xcall) (len Xm))
	      )
(equal (L (sy-HANDREC 'Yhear Xcall Xm))
       (L (P Xcall))))
((disable sy-HANDREC S-boolp)
 )
)
; Note: we can also obtain it DIRECTLY w/ the same blastful 
; induction:
; (induct (induct-P2 Xcall Xm))
; (expand (sy-HANDREC 'Yhear Xcall Xm) 
;	 (SY-HANDREC 'Y3 (P XCALL) (P XM))
;	 (SY-HANDREC 'Y2 (P XCALL) (P XM))
;	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
;	 (SY-HANDREC 'Y1 (P XCALL) (P XM))
;	 )

; Of course, from there with a APL-split we get the string version:
; note: disabling LEN here works fine. (Never tried it enabled 
; though.)

(prove-lemma APL-split () ; USE hints only.
(implies (and (not (empty Xcall))
	      (equal (len Xcall) (len Xm)) ; we need A2-EMPTY
	      )
	 (equal (sy-HANDREC 'Yhear Xcall Xm)
		(A (P (sy-HANDREC 'Yhear Xcall Xm))
		   (L (sy-HANDREC 'Yhear Xcall Xm)))))
((disable correct-handrec-hear-L A2-PC-SY-Handrec SY-Handrec LEN)
 )
)

; Note: A-P-L is required here. The fact that it wasn't in handreco
; is probably a freak...

(prove-lemma correct-handrec-hear-S (rewrite)
(implies (and (S-boolp Xcall)
              (equal (len Xcall) (len Xm))
	      )
(equal (sy-HANDREC 'Yhear Xcall Xm)
       (if (empty Xcall)
	   (e)
	   (I F (P Xcall)))))
((use (APL-split))
 (disable A-P-L sy-HANDREC EMPTY STR-A-I S-boolp LEN)
 (enable I S-boolp-P)
 (induct (induct-P2 Xcall Xm))
 )
)

; We can also get the string equality directly by a blastful 
; induction:
; Note also that disabling LEN here is a MAJOR win: 20 cases -> 1,
; time: 31s -> 8s.
; Note also that disabling EMPTY fails the proof.  We're probably 
; missing some crucial substitute for it.  Since it's not recursive
; it may not be worth it to worry about it...

(prove-lemma correct-handrec-hear-S2 (rewrite)
(implies (and (S-boolp Xcall)
	      (equal (len Xcall) (len Xm))
	      )
(equal (sy-HANDREC 'Yhear Xcall Xm)
       (if (empty Xcall)
	   (e)
	   (I F (P Xcall)))))
((induct (induct-P2 Xcall Xm))
 (expand (sy-HANDREC 'Yhear Xcall Xm) 
	 (SY-HANDREC 'Y3 (P XCALL) (P XM))
	 (SY-HANDREC 'Y2 (P XCALL) (P XM))
	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
	 (SY-HANDREC 'Y1 (P XCALL) (P XM))
	 )
 (disable CORRECT-HANDREC-HEAR-S CORRECT-HANDREC-HEAR-L LEN)
 )
)

; As for INFIN, the correctness property is rather trivial, except
; of course that for strings we have to correct for initial 
; values...

; comb_and3.bm: Logical And combinational element, with 3 inputs
; U7-DONE

(defn and3 (u1 u2 u3)
  (and u1 u2 u3))

; Everything below generated by: (bmcomb 'and3 '() '(x1 x2 x3))

(DEFN S-AND3 (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-AND3 (P X1) (P X2) (P X3)) (AND3 (L X1) (L X2) (L X3)))))

;; A2-Begin-S-AND3

(PROVE-LEMMA A2-EMPTY-S-AND3 (REWRITE)
    (EQUAL (EMPTY (S-AND3 X1 X2 X3)) (EMPTY X1)) ((DISABLE AND3)))

(PROVE-LEMMA A2-E-S-AND3 (REWRITE)
    (EQUAL (EQUAL (S-AND3 X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-AND3 A2-EMPTY-S-AND3) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-AND3))))

(PROVE-LEMMA A2-LP-S-AND3 (REWRITE)
    (EQUAL (LEN (S-AND3 X1 X2 X3)) (LEN X1))
    ((DISABLE AND3) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-AND3 (REWRITE) (EQLEN (S-AND3 X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-AND3)))

(PROVE-LEMMA A2-IC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-AND3 (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (AND3 C_X1 C_X2 C_X3) (S-AND3 X1 X2 X3))))
    ((ENABLE I LEN) (DISABLE STR-A-I AND3) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-LC-S-AND3 (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-AND3 X1 X2 X3)) (AND3 (L X1) (L X2) (L X3))))
    ((DISABLE AND3) (EXPAND (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-AND3 (REWRITE)
    (EQUAL (P (S-AND3 X1 X2 X3)) (S-AND3 (P X1) (P X2) (P X3)))
    ((DISABLE AND3)))

(PROVE-LEMMA A2-HC-S-AND3 (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-AND3 X1 X2 X3)) (AND3 (H X1) (H X2) (H X3))))
    ((DISABLE AND3 S-AND3) (ENABLE H LEN) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-BC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-AND3 X1 X2 X3))
                    (S-AND3 (B X1) (B X2) (B X3))))
    ((DISABLE AND3) (ENABLE B LEN) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-BNC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-AND3 X1 X2 X3))
                    (S-AND3 (BN N X1) (BN N X2) (BN N X3))))
    ((DISABLE AND3 S-AND3)))

;; A2-End-S-AND3

; eof:comb_and3.bm
 ; for spec only

; a stupid local linguistic hack, which we won't always want:
(prove-lemma S-AND3-to-S-AND2 (rewrite)
(equal (S-AND3 x1 x2 x3)
       (S-AND (S-AND x1 x2)
	      x3))
)
(disable S-AND3-to-S-AND2)

; Note: we may need some A2-EMPTY in here, hence no EQ-LEN hyp., 
; but we should not need any e-equalization, hence LEN disabled
 
(prove-lemma correct-handrec-infin-S (rewrite)
(implies (and (not (empty (P (P Xcall)))) (not (empty (P Xm)))
	      (equal (len Xcall) (len Xm))
	      )
(equal (sy-HANDREC 'Yinfin Xcall Xm)
       (I F (S-AND3 (P Xcall)
		    (P Xm)
		    (I T (S-NOT (P (P Xcall))))))))
((expand (sy-HANDREC 'Yinfin Xcall Xm)
	 (SY-HANDREC 'Y5 (P XCALL) (P XM))
	 (SY-HANDREC 'Y4 (P XCALL) (P XM))
	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
	 )
 (enable S-AND3-to-S-AND2)
 (disable LEN)
 )
)

; or in terms of last-chars, and obtained from INFIN-S:

(prove-lemma correct-handrec-infin-L (rewrite)
(implies (and (not (empty (P (P Xcall)))) (not (empty (P Xm)))
	      (equal (len Xcall) (len Xm))
	      )
(equal (L (sy-HANDREC 'Yinfin Xcall Xm))
       (and (L (P Xcall))
	    (L (P Xm))
	    (not (L (P (P Xcall)))))))
((disable sy-HANDREC LEN)
 (enable STR-L-I2)
 )
)

; To prove the INITIALIZATION PROPERTY for the HANDSHAKE RECEIVER,
; Paillet #6, we take the SYSD definition for the (normal, 
; initialized) sysd, and hand-MODIFY it to be EXPLICITLY
; PARAMETRIZED on the register initial values. Then we prove that
; the right inital input sequence produces the right values in
; the register (lines).

(DEFN SY-HANDREC-i (a1 a2 a3 LN XCALL XM) 
(IF (EQUAL LN 'YRCALL) (IF (EMPTY XCALL) (E) (I a1 (P XCALL))) 
(IF (EQUAL LN 'Y0) (S-NOT (SY-HANDREC-i a1 a2 a3 'YRCALL XCALL XM)) 
(IF (EQUAL LN 'Y1) (S-AND (SY-HANDREC-i a1 a2 a3 'YRCALL XCALL XM)
                          (SY-HANDREC-i a1 a2 a3 'YHEAR XCALL XM)) 
(IF (EQUAL LN 'Y2) (S-OR (SY-HANDREC-i a1 a2 a3 'Y0 XCALL XM) (SY-HANDREC-i a1 a2 a3 'Y1 XCALL XM)) 
(IF (EQUAL LN 'Y3) (S-AND XCALL (SY-HANDREC-i a1 a2 a3 'Y2 XCALL XM)) 
(IF (EQUAL LN 'Y4) (S-AND XCALL XM) 
(IF (EQUAL LN 'Y5) (S-AND (SY-HANDREC-i a1 a2 a3 'Y4 XCALL XM)
                          (SY-HANDREC-i a1 a2 a3 'Y0 XCALL XM)) 
(IF (EQUAL LN 'YHEAR) (IF (EMPTY XCALL) (E)
                          (I a2 (SY-HANDREC-i a1 a2 a3 'Y3 (P XCALL) (P XM)))) 
(IF (EQUAL LN 'YINFIN) (IF (EMPTY XCALL) (E)
                           (I a3 (SY-HANDREC-i a1 a2 a3 'Y5 (P XCALL) (P XM)))) 
(SFIX XCALL))))))))))
((LEX2 (LIST (COUNT XCALL) (TOPOR-SY-HANDREC LN)))) )

; the correct initialization theorem reads:
; Note: u's are unconstrained characters

(prove-lemma Correct-Handrec-Init ()
(implies (and (equal Xcall_i (A (A (e) F) u1))
	      (equal Xm_i (A (A (e) u2) u3))
	      )
	 (and (equal (L (SY-HANDREC-i a1 a2 a3 'Yrcall Xcall_i Xm_i)) F)
	      (equal (L (SY-HANDREC-i a1 a2 a3 'Yhear Xcall_i Xm_i)) F)
	      (equal (L (SY-HANDREC-i a1 a2 a3 'Yinfin Xcall_i Xm_i)) F)
	      ))
((expand (SY-HANDREC-I A1 A2 A3 'Y5 (A (E) F) (A (E) U2))
	 )
 )
)

#| ))

;; THE REST OF THIS are unneeded (anymore) experiments:

(setq handrec-h1 '(
; we can try to go through the intermediate equations, like 
; Paillet, using the technique we worked out in bcdS, but it's not 
; clear it's worth it!

(defn sy-H1 (ln Xcall Xm)
(if (equal ln 'Yhear)
    (if (empty Xcall) (e) ; by hand
    (if (empty (P Xcall)) (A (e) F) ; by hand
        (I F (S-AND (P XCALL)
		    (S-OR (S-NOT (I F (P (P XCALL))))
			  (S-AND (I F (P (P XCALL)))
				 (SY-H1 'YHEAR (P XCALL) (P XM))))))
	))
(sfix Xcall)
))

;; NOTE that we got the expansion from BM by doing:
;;(dcl dummy ())
;;
;;(prove-lemma x1 ()
;;(implies (and (not (empty Xcall)) (not (empty (P Xcall))))
;;	 (equal (sy-HANDREC 'Yhear Xcall Xm) (dummy)))
;;((expand (sy-HANDREC 'Yhear Xcall Xm)
;;	 (SY-HANDREC 'Y3 (P XCALL) (P XM)) ; grabbing from proof 
;;	 (SY-HANDREC 'Y2 (P XCALL) (P XM)) ; as we went along..
;;	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
;;	 (SY-HANDREC 'Y1 (P XCALL) (P XM))
;;	 )
;; (do-not-induct) (do-not-generalize) 
;; (disable a2-ic-s-not)
;; )
;;)

; H1 is just a GENERALIZED sysd, and our A2 lemmas should still be 
; true. The following were (Sugar) generated by:
; (vp (bma2sysd-aux 'sy-H1 'sy-H1 '(x) '(and or not))) %%NOT-DONE

(prove-lemma Handrec-is-H1 (rewrite)
(equal (sy-HANDREC 'Yhear Xcall Xm)
       (sy-H1 'Yhear Xcall Xm))
((induct (induct-P2 Xcall Xm))
 (expand (sy-HANDREC 'Yhear Xcall Xm)      ; taken straight from Dummy!
	 (SY-HANDREC 'Y3 (P XCALL) (P XM))
	 (SY-HANDREC 'Y2 (P XCALL) (P XM))
	 (SY-HANDREC 'Y0 (P XCALL) (P XM))
	 (SY-HANDREC 'Y1 (P XCALL) (P XM))

	 (sy-H1 'Yhear Xcall Xm)
	 )
 (disable a2-ic-s-not)
 )
)

; then we could prove the same stuff as what we did for SY-HANDREC, 
; but that's a rather backward way to go!


; eof: handrec.bm
))  |#

