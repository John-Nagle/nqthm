#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; prod0_CSXAdd.bm
;   . definition of circuits [assumes stringadd.bm] : 
;     - if the circuit has only one line: OK without any hint
; 	We MAY want to put the TOPO hint, just for the induction, although
;	for one line it probably collapes to the same induction (LEN X).
;     - if the circuit has more than one line: 
;	   - without hints: FAIL
;          - TOPO0 is not definable, because of loops in the dependency graph!
;	   - with TOPOR: OK
; NOTE: the above comments date back to the hand-generation time, when we
;       were still trying to FIND a way to feed things to BM.  They are kept
;       here for historical purposes only...


;;; DEFINITION OF CIRCUITS:
#|
(setq sysd-prod '(sy-prod (x)
(Yprod S Times x Yprod2)
(Yprod2 R 0 Yprod)
))

(setq sysd-const0 '(sy-const0 (x)
(Yconst0 R 0 Yconst0)
))

(setq prod0_CSXA00 '(
|#

; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_times.bm: Times combinational element.
; U7-DONE

; no character function def since BM already knows about Times..

; Everything below generated by:     (bmcomb 'times '() '(x y))

(DEFN S-TIMES (X Y)
      (IF (EMPTY X) (E) (A (S-TIMES (P X) (P Y)) (TIMES (L X) (L Y)))))

;; A2-Begin-S-TIMES

(PROVE-LEMMA A2-EMPTY-S-TIMES (REWRITE)
    (EQUAL (EMPTY (S-TIMES X Y)) (EMPTY X)) ((DISABLE TIMES)))

(PROVE-LEMMA A2-E-S-TIMES (REWRITE)
    (EQUAL (EQUAL (S-TIMES X Y) (E)) (EMPTY X))
    ((DISABLE S-TIMES A2-EMPTY-S-TIMES) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-TIMES))))

(PROVE-LEMMA A2-LP-S-TIMES (REWRITE)
    (EQUAL (LEN (S-TIMES X Y)) (LEN X)) ((DISABLE TIMES) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-TIMES (REWRITE) (EQLEN (S-TIMES X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-TIMES)))

(PROVE-LEMMA A2-IC-S-TIMES (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-TIMES (I C_X X) (I C_Y Y))
                    (I (TIMES C_X C_Y) (S-TIMES X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I TIMES)))

(PROVE-LEMMA A2-LC-S-TIMES (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-TIMES X Y)) (TIMES (L X) (L Y))))
    ((DISABLE TIMES) (EXPAND (S-TIMES X Y))))

(PROVE-LEMMA A2-PC-S-TIMES (REWRITE)
    (EQUAL (P (S-TIMES X Y)) (S-TIMES (P X) (P Y))) ((DISABLE TIMES)))

(PROVE-LEMMA A2-HC-S-TIMES (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-TIMES X Y)) (TIMES (H X) (H Y))))
    ((DISABLE TIMES S-TIMES) (ENABLE H LEN) (INDUCT (S-TIMES X Y))))

(PROVE-LEMMA A2-BC-S-TIMES (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-TIMES X Y)) (S-TIMES (B X) (B Y))))
    ((DISABLE TIMES) (ENABLE B LEN) (INDUCT (S-TIMES X Y))))

(PROVE-LEMMA A2-BNC-S-TIMES (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-TIMES X Y)) (S-TIMES (BN N X) (BN N Y))))
    ((DISABLE TIMES S-TIMES)))

;; A2-End-S-TIMES

; eof:comb_times.bm


(DEFN TOPOR-SY-PROD (LN) 
(IF (EQUAL LN 'YPROD) 1 
(IF (EQUAL LN 'YPROD2) 0 
0)))

(DEFN SY-PROD (LN X) 
(IF (EQUAL LN 'YPROD) (S-TIMES X (SY-PROD 'YPROD2 X)) 
(IF (EQUAL LN 'YPROD2) (IF (EMPTY X) (E) (I 0 (SY-PROD 'YPROD (P X)))) 
(SFIX X)))
((LEX2 (LIST (COUNT X) (TOPOR-SY-PROD LN)))) )

;; A2-Begin-SY-PROD

(PROVE-LEMMA A2-EMPTY-SY-PROD (REWRITE)
    (EQUAL (EMPTY (SY-PROD LN X)) (EMPTY X)) ((DISABLE S-TIMES)))

(PROVE-LEMMA A2-E-SY-PROD (REWRITE)
    (EQUAL (EQUAL (SY-PROD LN X) (E)) (EMPTY X))
    ((DISABLE SY-PROD A2-EMPTY-SY-PROD) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-PROD))))

(PROVE-LEMMA A2-LP-SY-PROD (REWRITE)
    (EQUAL (LEN (SY-PROD LN X)) (LEN X))
    ((DISABLE LEN S-TIMES) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-PROD (REWRITE) (EQLEN (SY-PROD LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-PROD)))

(PROVE-LEMMA A2-PC-SY-PROD (REWRITE)
    (EQUAL (P (SY-PROD LN X)) (SY-PROD LN (P X)))
    ((DISABLE S-TIMES A2-IC-S-TIMES)))

;; A2-End-SY-PROD
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:

; No TOPO def for 1 line sysds because it is not needed and confuses BM

(DEFN SY-CONST0 (LN X) 
(IF (EQUAL LN 'YCONST0) (IF (EMPTY X) (E)
                            (I 0 (SY-CONST0 'YCONST0 (P X)))) 
(SFIX X))
NIL )

;; A2-Begin-SY-CONST0

(PROVE-LEMMA A2-EMPTY-SY-CONST0 (REWRITE)
    (EQUAL (EMPTY (SY-CONST0 LN X)) (EMPTY X)) ((DISABLE)))

(PROVE-LEMMA A2-E-SY-CONST0 (REWRITE)
    (EQUAL (EQUAL (SY-CONST0 LN X) (E)) (EMPTY X))
    ((DISABLE SY-CONST0 A2-EMPTY-SY-CONST0) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-CONST0))))

(PROVE-LEMMA A2-LP-SY-CONST0 (REWRITE)
    (EQUAL (LEN (SY-CONST0 LN X)) (LEN X))
    ((DISABLE LEN) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-CONST0 (REWRITE) (EQLEN (SY-CONST0 LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-CONST0)))

(PROVE-LEMMA A2-PC-SY-CONST0 (REWRITE)
    (EQUAL (P (SY-CONST0 LN X)) (SY-CONST0 LN (P X))) ((DISABLE)))

;; A2-End-SY-CONST0

;;; PROOF OF EQUIVALENCE:

; The key fact about SY-Yconst is that it equals the constant 0 function:

(prove-lemma sy-const0-is-const (rewrite)
(equal (sy-const0 'Yconst0 x)
       (s-const 0 x))
)

; The key fact (bug) about prod0 is that both lines also equal const-0 sfun 
; CRUCIAL NOTE: we only want the 1st equality, but in order for the induction
; proof to succeed, we need the stronger (global) statement.

(prove-lemma prod0-is-const (rewrite)
(and (equal (sy-prod 'Yprod x)
	    (s-const 0 x))
     (equal (sy-prod 'Yprod2 x)
	    (s-const 0 x)))
)

; now the equality is trivial:

(prove-lemma E_prodconst0 (rewrite)
(equal (sy-prod 'Yprod x) (sy-const0 'Yconst0 x))
)


; eof: prod0_CSXA00.bm
;))

