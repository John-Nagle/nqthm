#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; corr_CSXA00.bm
;   . definition of circuits [assumes stringadd.bm] : 
;       - without hints: FAIL
;	- with TOPO: OK, but proofs blows up (understood) or fails because
; 	of lack of sysd- expansion...
;	- with TOPOR: OK
;   . proof:
; 	- with 2nd order combinationals:
;		- NO expand hint: FAIL
; 		- expand hint: OK 
;	- adding the 2nd order SYSD thms changes nothing to the equivalence
;	proof.
; NOTE: the above comments date back to the hand-generation time, when we
;       were still trying to FIND a way to feed things to BM.  They are kept
;       here for historical purposes only...

; 1st circuit:
#|
(setq sysd-A '(sy-corrA (x)
(Y1 R 'a1 x)
(Y2 S Del 'a1 Y1)
(Y3 S id Y1) ;useless, but what the hell, let's try it anyway..
(Y4 R 'a2 Y3)
(Y5 S Del 'a2 Y4)
(W1 S Plus Y2 Y5)
))

; 2nd circuit:

(setq sysd-B '(sy-corrB (x)
(Z1 S Del 'a1 x)
(Z3 R 'a1 x)
(Z4 S Del 'a2 Z3)
(Z5 S Plus Z1 Z4)
(W2 R 2 Z5)
))
|#
;(setq corr_CSXA00 '(
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_id.bm: Id (identity) combinational element
; U7-DONE
;      Yes, it's probably quite useless, but it's a good test of the
;      proof generation algorithms, and as the Romans found out the
;      hard way, it sometimes help to have 0 around! 

; SUGAR NOTE: an extra lemma about it is given at the end of this file...

(defn Id (u) u)

; Everything (until ;; A2-End...) below generated by: (bmcomb 'id '() '(x))

(DEFN S-ID (X) (IF (EMPTY X) (E) (A (S-ID (P X)) (ID (L X)))))

;; A2-Begin-S-ID

(PROVE-LEMMA A2-EMPTY-S-ID (REWRITE) (EQUAL (EMPTY (S-ID X)) (EMPTY X))
    ((DISABLE ID)))

(PROVE-LEMMA A2-E-S-ID (REWRITE) (EQUAL (EQUAL (S-ID X) (E)) (EMPTY X))
    ((DISABLE S-ID A2-EMPTY-S-ID) (ENABLE EMPTY) (USE (A2-EMPTY-S-ID))))

(PROVE-LEMMA A2-LP-S-ID (REWRITE) (EQUAL (LEN (S-ID X)) (LEN X))
    ((DISABLE ID) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-ID (REWRITE) (EQLEN (S-ID X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-ID)))

(PROVE-LEMMA A2-IC-S-ID (REWRITE)
    (EQUAL (S-ID (I C_X X)) (I (ID C_X) (S-ID X)))
    ((ENABLE I) (DISABLE STR-A-I ID)))

(PROVE-LEMMA A2-LC-S-ID (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-ID X)) (ID (L X))))
    ((DISABLE ID) (EXPAND (S-ID X))))

(PROVE-LEMMA A2-PC-S-ID (REWRITE) (EQUAL (P (S-ID X)) (S-ID (P X)))
    ((DISABLE ID)))

(PROVE-LEMMA A2-HC-S-ID (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-ID X)) (ID (H X))))
    ((DISABLE ID S-ID) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-ID (REWRITE) (EQUAL (B (S-ID X)) (S-ID (B X)))
    ((DISABLE ID) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-ID (REWRITE)
    (EQUAL (BN N (S-ID X)) (S-ID (BN N X))) ((DISABLE ID S-ID)))

;; A2-End-S-ID

;; Hand-generated (potentially useful) lemmas

(prove-lemma sid-is-sfix (rewrite)
(equal (s-id x) (sfix x))
((enable sfix empty)))

(disable sid-is-sfix)

; eof:comb_id.bm

; comb_del.bm: Delta combinational element, parametrized.
; U7-DONE

(defn del (val u)
  (if (equal val u) 1 0))

; Everything below generated by SUGAR with:    (bmcomb 'del '(val) '(x))

(DEFN S-DEL (VAL X)
      (IF (EMPTY X) (E) (A (S-DEL VAL (P X)) (DEL VAL (L X)))))

;; A2-Begin-S-DEL

(PROVE-LEMMA A2-EMPTY-S-DEL (REWRITE)
    (EQUAL (EMPTY (S-DEL VAL X)) (EMPTY X)) ((DISABLE DEL)))

(PROVE-LEMMA A2-E-S-DEL (REWRITE)
    (EQUAL (EQUAL (S-DEL VAL X) (E)) (EMPTY X))
    ((DISABLE S-DEL A2-EMPTY-S-DEL) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-DEL))))

(PROVE-LEMMA A2-LP-S-DEL (REWRITE) (EQUAL (LEN (S-DEL VAL X)) (LEN X))
    ((DISABLE DEL) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-DEL (REWRITE) (EQLEN (S-DEL VAL X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-DEL)))

(PROVE-LEMMA A2-IC-S-DEL (REWRITE)
    (EQUAL (S-DEL VAL (I C_X X)) (I (DEL VAL C_X) (S-DEL VAL X)))
    ((ENABLE I) (DISABLE STR-A-I DEL)))

(PROVE-LEMMA A2-LC-S-DEL (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-DEL VAL X)) (DEL VAL (L X))))
    ((DISABLE DEL) (EXPAND (S-DEL VAL X))))

(PROVE-LEMMA A2-PC-S-DEL (REWRITE)
    (EQUAL (P (S-DEL VAL X)) (S-DEL VAL (P X))) ((DISABLE DEL)))

(PROVE-LEMMA A2-HC-S-DEL (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-DEL VAL X)) (DEL VAL (H X))))
    ((DISABLE DEL S-DEL) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-DEL (REWRITE)
    (EQUAL (B (S-DEL VAL X)) (S-DEL VAL (B X)))
    ((DISABLE DEL) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-DEL (REWRITE)
    (EQUAL (BN N (S-DEL VAL X)) (S-DEL VAL (BN N X)))
    ((DISABLE DEL S-DEL)))

;; A2-End-S-DEL

; eof:comb_del.bm


; comb_plus.bm: Plus combinational element.
; U7-DONE

;   no character function definition since BM already knows about Plus..

; Everything below generated by:     (bmcomb 'plus '() '(x y))

(DEFN S-PLUS (X Y)
      (IF (EMPTY X) (E) (A (S-PLUS (P X) (P Y)) (PLUS (L X) (L Y)))))

;; A2-Begin-S-PLUS

(PROVE-LEMMA A2-EMPTY-S-PLUS (REWRITE)
    (EQUAL (EMPTY (S-PLUS X Y)) (EMPTY X)) ((DISABLE PLUS)))

(PROVE-LEMMA A2-E-S-PLUS (REWRITE)
    (EQUAL (EQUAL (S-PLUS X Y) (E)) (EMPTY X))
    ((DISABLE S-PLUS A2-EMPTY-S-PLUS) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-PLUS))))

(PROVE-LEMMA A2-LP-S-PLUS (REWRITE) (EQUAL (LEN (S-PLUS X Y)) (LEN X))
    ((DISABLE PLUS) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-PLUS (REWRITE) (EQLEN (S-PLUS X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-PLUS)))

(PROVE-LEMMA A2-IC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-PLUS (I C_X X) (I C_Y Y))
                    (I (PLUS C_X C_Y) (S-PLUS X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I PLUS)))

(PROVE-LEMMA A2-LC-S-PLUS (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-PLUS X Y)) (PLUS (L X) (L Y))))
    ((DISABLE PLUS) (EXPAND (S-PLUS X Y))))

(PROVE-LEMMA A2-PC-S-PLUS (REWRITE)
    (EQUAL (P (S-PLUS X Y)) (S-PLUS (P X) (P Y))) ((DISABLE PLUS)))

(PROVE-LEMMA A2-HC-S-PLUS (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-PLUS X Y)) (PLUS (H X) (H Y))))
    ((DISABLE PLUS S-PLUS) (ENABLE H LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-PLUS X Y)) (S-PLUS (B X) (B Y))))
    ((DISABLE PLUS) (ENABLE B LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BNC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-PLUS X Y)) (S-PLUS (BN N X) (BN N Y))))
    ((DISABLE PLUS S-PLUS)))

;; A2-End-S-PLUS

; eof:comb_plus.bm


(DEFN TOPOR-SY-CORRA (LN) 
(IF (EQUAL LN 'Y1) 0 
(IF (EQUAL LN 'Y2) 1 
(IF (EQUAL LN 'Y3) 1 
(IF (EQUAL LN 'Y4) 0 
(IF (EQUAL LN 'Y5) 1 
(IF (EQUAL LN 'W1) 2 
0)))))))

;Parameter found: 'A1 in: (Y2 S DEL 'A1 Y1)
;Parameter found: 'A2 in: (Y5 S DEL 'A2 Y4)
(DEFN SY-CORRA (LN X) 
(IF (EQUAL LN 'Y1) (IF (EMPTY X) (E) (I 'A1 (P X))) 
(IF (EQUAL LN 'Y2) (S-DEL 'A1 (SY-CORRA 'Y1 X)) 
(IF (EQUAL LN 'Y3) (S-ID (SY-CORRA 'Y1 X)) 
(IF (EQUAL LN 'Y4) (IF (EMPTY X) (E) (I 'A2 (SY-CORRA 'Y3 (P X)))) 
(IF (EQUAL LN 'Y5) (S-DEL 'A2 (SY-CORRA 'Y4 X)) 
(IF (EQUAL LN 'W1) (S-PLUS (SY-CORRA 'Y2 X) (SY-CORRA 'Y5 X)) 
(SFIX X)))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-CORRA LN)))) )

;; A2-Begin-SY-CORRA

(PROVE-LEMMA A2-EMPTY-SY-CORRA (REWRITE)
    (EQUAL (EMPTY (SY-CORRA LN X)) (EMPTY X))
    ((DISABLE S-ID S-DEL S-PLUS)))

(PROVE-LEMMA A2-E-SY-CORRA (REWRITE)
    (EQUAL (EQUAL (SY-CORRA LN X) (E)) (EMPTY X))
    ((DISABLE SY-CORRA A2-EMPTY-SY-CORRA) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-CORRA))))

(PROVE-LEMMA A2-LP-SY-CORRA (REWRITE)
    (EQUAL (LEN (SY-CORRA LN X)) (LEN X))
    ((DISABLE LEN S-ID S-DEL S-PLUS) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-CORRA (REWRITE) (EQLEN (SY-CORRA LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-CORRA)))

(PROVE-LEMMA A2-PC-SY-CORRA (REWRITE)
    (EQUAL (P (SY-CORRA LN X)) (SY-CORRA LN (P X)))
    ((DISABLE S-ID S-DEL S-PLUS A2-IC-S-ID A2-IC-S-DEL A2-IC-S-PLUS)))

;; A2-End-SY-CORRA
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:

(DEFN TOPOR-SY-CORRB (LN) 
(IF (EQUAL LN 'Z1) 1 
(IF (EQUAL LN 'Z3) 0 
(IF (EQUAL LN 'Z4) 1 
(IF (EQUAL LN 'Z5) 2 
(IF (EQUAL LN 'W2) 0 
0))))))

;Parameter found: 'A1 in: (Z1 S DEL 'A1 X)
;Parameter found: 'A2 in: (Z4 S DEL 'A2 Z3)
(DEFN SY-CORRB (LN X) 
(IF (EQUAL LN 'Z1) (S-DEL 'A1 X) 
(IF (EQUAL LN 'Z3) (IF (EMPTY X) (E) (I 'A1 (P X))) 
(IF (EQUAL LN 'Z4) (S-DEL 'A2 (SY-CORRB 'Z3 X)) 
(IF (EQUAL LN 'Z5) (S-PLUS (SY-CORRB 'Z1 X) (SY-CORRB 'Z4 X)) 
(IF (EQUAL LN 'W2) (IF (EMPTY X) (E) (I 2 (SY-CORRB 'Z5 (P X)))) 
(SFIX X))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-CORRB LN)))) )

;; A2-Begin-SY-CORRB

(PROVE-LEMMA A2-EMPTY-SY-CORRB (REWRITE)
    (EQUAL (EMPTY (SY-CORRB LN X)) (EMPTY X)) ((DISABLE S-DEL S-PLUS)))

(PROVE-LEMMA A2-E-SY-CORRB (REWRITE)
    (EQUAL (EQUAL (SY-CORRB LN X) (E)) (EMPTY X))
    ((DISABLE SY-CORRB A2-EMPTY-SY-CORRB) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-CORRB))))

(PROVE-LEMMA A2-LP-SY-CORRB (REWRITE)
    (EQUAL (LEN (SY-CORRB LN X)) (LEN X))
    ((DISABLE LEN S-DEL S-PLUS) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-CORRB (REWRITE) (EQLEN (SY-CORRB LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-CORRB)))

(PROVE-LEMMA A2-PC-SY-CORRB (REWRITE)
    (EQUAL (P (SY-CORRB LN X)) (SY-CORRB LN (P X)))
    ((DISABLE S-DEL S-PLUS A2-IC-S-DEL A2-IC-S-PLUS)))

;; A2-End-SY-CORRB

;;; CORRECTNESS (equality):

; Lw1w2: still requires the big expansion hint...

(prove-lemma Lw1w2 (rewrite)
(implies (stringp x)
	 (equal (sy-corrA 'W1 x) (sy-corrB 'W2 x)))
((expand (sy-corrA 'W1 x)
	 (sy-corrA 'Y2 x)
	 (sy-corrA 'Y5 x)
	 (sy-corrA 'Y4 x)
	 (sy-corrA 'Y3 (p x))
	 (sy-corrB 'W2 x)
	 (sy-corrB 'Z5 (p x))
	 (sy-corrB 'Z4 (p x))
	 (sy-corrB 'Z3 (p x))
	 )
 (enable sid-is-sfix sfix  ; required to reduce s-id x to x, w/ stringp x
	 len ; fails without, some precondition in some backtracking???
	 )
 )
)

; eof: corr_CSXA00.bm
;))
