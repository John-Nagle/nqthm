#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; bcdS.bm: a BCD code checker, with serial (bit) input, but built 
;          STRUCTURELY.
;    The key lesson is that it helps (and is in fact necessary) to 
;    reduce the sysd to a generalized sysd, with just the 
;    "important" lines: Paillet's variables d'etats non-eliminables
;     expressed in terms of each other. See SY-B2 below.
;
;    Note: Proving the A2 lemmas about the generalized sysd brings 
;    2 issues:
;    - they don't seem to be used at all.
;    - A2-PC loops on its own (no rule!) and is therefore so far
;      unprovable...
;

;;; CIRCUIT in SUGARED form:

; note: registers are initialized with F instead of 0, since coded
; at logical level.
#|
(setq sysd '(sy-BCDS (x)
(Y01 S not x)
(Y02 S not x)
(Y03 S not YR3)
(Y04 S not YR1)
(Y05 S not YR2)
(Y06 S not YR3)
(Y07 S not YR1)
(Y08 S not YR3)
(Y11 S and3 Y01 YR1 YR3)
(Y12 S and3 Y02 YR2 Y03)
(Y13 S and3 Y04 Y05 Y06)
(Y14 S and3 x Y07 Y08)
(Y15 S and3 x YR1 YR3)
(Y21 S or Y11 Y12)
(Y22 S or Y13 Y14)
(Y23 S or YR2 Y15)
(YR1 R F Y21)
(YR2 R F Y22)
(YR3 R F Y23)
(Y31 S not YR1)
(Y32 S not YR2)
(Y41 S and4 x Y31 Y32 YR3)
(Yout S not Y41)
))

(setq bcdS '(  |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_and3.bm: Logical And combinational element, with 3 inputs
; U7-DONE

(defn and3 (u1 u2 u3)
  (and u1 u2 u3))

; Everything below generated by: (bmcomb 'and3 '() '(x1 x2 x3))

(DEFN S-AND3 (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-AND3 (P X1) (P X2) (P X3)) (AND3 (L X1) (L X2) (L X3)))))

;; A2-Begin-S-AND3

(PROVE-LEMMA A2-EMPTY-S-AND3 (REWRITE)
    (EQUAL (EMPTY (S-AND3 X1 X2 X3)) (EMPTY X1)) ((DISABLE AND3)))

(PROVE-LEMMA A2-E-S-AND3 (REWRITE)
    (EQUAL (EQUAL (S-AND3 X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-AND3 A2-EMPTY-S-AND3) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-AND3))))

(PROVE-LEMMA A2-LP-S-AND3 (REWRITE)
    (EQUAL (LEN (S-AND3 X1 X2 X3)) (LEN X1))
    ((DISABLE AND3) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-AND3 (REWRITE) (EQLEN (S-AND3 X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-AND3)))

(PROVE-LEMMA A2-IC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-AND3 (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (AND3 C_X1 C_X2 C_X3) (S-AND3 X1 X2 X3))))
    ((ENABLE I LEN) (DISABLE STR-A-I AND3) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-LC-S-AND3 (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-AND3 X1 X2 X3)) (AND3 (L X1) (L X2) (L X3))))
    ((DISABLE AND3) (EXPAND (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-AND3 (REWRITE)
    (EQUAL (P (S-AND3 X1 X2 X3)) (S-AND3 (P X1) (P X2) (P X3)))
    ((DISABLE AND3)))

(PROVE-LEMMA A2-HC-S-AND3 (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-AND3 X1 X2 X3)) (AND3 (H X1) (H X2) (H X3))))
    ((DISABLE AND3 S-AND3) (ENABLE H LEN) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-BC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-AND3 X1 X2 X3))
                    (S-AND3 (B X1) (B X2) (B X3))))
    ((DISABLE AND3) (ENABLE B LEN) (INDUCT (S-AND3 X1 X2 X3))))

(PROVE-LEMMA A2-BNC-S-AND3 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-AND3 X1 X2 X3))
                    (S-AND3 (BN N X1) (BN N X2) (BN N X3))))
    ((DISABLE AND3 S-AND3)))

;; A2-End-S-AND3

; eof:comb_and3.bm

; comb_and4.bm: Logical And combinational element, with 4 inputs
; U7-DONE

(defn and4 (u1 u2 u3 u4)
  (and u1 u2 u3 u4))

; Everything below generated by: (bmcomb 'and4 '() '(x1 x2 x3 x4))

(DEFN S-AND4 (X1 X2 X3 X4)
      (IF (EMPTY X1) (E)
          (A (S-AND4 (P X1) (P X2) (P X3) (P X4))
             (AND4 (L X1) (L X2) (L X3) (L X4)))))

;; A2-Begin-S-AND4

(PROVE-LEMMA A2-EMPTY-S-AND4 (REWRITE)
    (EQUAL (EMPTY (S-AND4 X1 X2 X3 X4)) (EMPTY X1)) ((DISABLE AND4)))

(PROVE-LEMMA A2-E-S-AND4 (REWRITE)
    (EQUAL (EQUAL (S-AND4 X1 X2 X3 X4) (E)) (EMPTY X1))
    ((DISABLE S-AND4 A2-EMPTY-S-AND4) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-AND4))))

(PROVE-LEMMA A2-LP-S-AND4 (REWRITE)
    (EQUAL (LEN (S-AND4 X1 X2 X3 X4)) (LEN X1))
    ((DISABLE AND4) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-AND4 (REWRITE) (EQLEN (S-AND4 X1 X2 X3 X4) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-AND4)))

(PROVE-LEMMA A2-IC-S-AND4 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3))
                  (EQUAL (LEN X3) (LEN X4)))
             (EQUAL (S-AND4 (I C_X1 X1) (I C_X2 X2) (I C_X3 X3)
                            (I C_X4 X4))
                    (I (AND4 C_X1 C_X2 C_X3 C_X4) (S-AND4 X1 X2 X3 X4))))
    ((ENABLE I LEN) (DISABLE STR-A-I AND4)
     (INDUCT (S-AND4 X1 X2 X3 X4))))

(PROVE-LEMMA A2-LC-S-AND4 (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-AND4 X1 X2 X3 X4))
                    (AND4 (L X1) (L X2) (L X3) (L X4))))
    ((DISABLE AND4) (EXPAND (S-AND4 X1 X2 X3 X4))))

(PROVE-LEMMA A2-PC-S-AND4 (REWRITE)
    (EQUAL (P (S-AND4 X1 X2 X3 X4))
           (S-AND4 (P X1) (P X2) (P X3) (P X4)))
    ((DISABLE AND4)))

(PROVE-LEMMA A2-HC-S-AND4 (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))
                       (EQUAL (LEN X3) (LEN X4))))
             (EQUAL (H (S-AND4 X1 X2 X3 X4))
                    (AND4 (H X1) (H X2) (H X3) (H X4))))
    ((DISABLE AND4 S-AND4) (ENABLE H LEN)
     (INDUCT (S-AND4 X1 X2 X3 X4))))

(PROVE-LEMMA A2-BC-S-AND4 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3))
                  (EQUAL (LEN X3) (LEN X4)))
             (EQUAL (B (S-AND4 X1 X2 X3 X4))
                    (S-AND4 (B X1) (B X2) (B X3) (B X4))))
    ((DISABLE AND4) (ENABLE B LEN) (INDUCT (S-AND4 X1 X2 X3 X4))))

(PROVE-LEMMA A2-BNC-S-AND4 (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3))
                  (EQUAL (LEN X3) (LEN X4)))
             (EQUAL (BN N (S-AND4 X1 X2 X3 X4))
                    (S-AND4 (BN N X1) (BN N X2) (BN N X3) (BN N X4))))
    ((DISABLE AND4 S-AND4)))

;; A2-End-S-AND4

; eof:comb_and4.bm


(DEFN TOPOR-SY-BCDS (LN) 
(IF (EQUAL LN 'Y01) 1 
(IF (EQUAL LN 'Y02) 1 
(IF (EQUAL LN 'Y03) 1 
(IF (EQUAL LN 'Y04) 1 
(IF (EQUAL LN 'Y05) 1 
(IF (EQUAL LN 'Y06) 1 
(IF (EQUAL LN 'Y07) 1 
(IF (EQUAL LN 'Y08) 1 
(IF (EQUAL LN 'Y11) 2 
(IF (EQUAL LN 'Y12) 2 
(IF (EQUAL LN 'Y13) 2 
(IF (EQUAL LN 'Y14) 2 
(IF (EQUAL LN 'Y15) 1 
(IF (EQUAL LN 'Y21) 3 
(IF (EQUAL LN 'Y22) 3 
(IF (EQUAL LN 'Y23) 2 
(IF (EQUAL LN 'YR1) 0 
(IF (EQUAL LN 'YR2) 0 
(IF (EQUAL LN 'YR3) 0 
(IF (EQUAL LN 'Y31) 1 
(IF (EQUAL LN 'Y32) 1 
(IF (EQUAL LN 'Y41) 2 
(IF (EQUAL LN 'YOUT) 3 
0))))))))))))))))))))))))

(DEFN SY-BCDS (LN X) 
(IF (EQUAL LN 'Y01) (S-NOT X) 
(IF (EQUAL LN 'Y02) (S-NOT X) 
(IF (EQUAL LN 'Y03) (S-NOT (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'Y04) (S-NOT (SY-BCDS 'YR1 X)) 
(IF (EQUAL LN 'Y05) (S-NOT (SY-BCDS 'YR2 X)) 
(IF (EQUAL LN 'Y06) (S-NOT (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'Y07) (S-NOT (SY-BCDS 'YR1 X)) 
(IF (EQUAL LN 'Y08) (S-NOT (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'Y11) (S-AND3 (SY-BCDS 'Y01 X) (SY-BCDS 'YR1 X)
                            (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'Y12) (S-AND3 (SY-BCDS 'Y02 X) (SY-BCDS 'YR2 X)
                            (SY-BCDS 'Y03 X)) 
(IF (EQUAL LN 'Y13) (S-AND3 (SY-BCDS 'Y04 X) (SY-BCDS 'Y05 X)
                            (SY-BCDS 'Y06 X)) 
(IF (EQUAL LN 'Y14) (S-AND3 X (SY-BCDS 'Y07 X) (SY-BCDS 'Y08 X)) 
(IF (EQUAL LN 'Y15) (S-AND3 X (SY-BCDS 'YR1 X) (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'Y21) (S-OR (SY-BCDS 'Y11 X) (SY-BCDS 'Y12 X)) 
(IF (EQUAL LN 'Y22) (S-OR (SY-BCDS 'Y13 X) (SY-BCDS 'Y14 X)) 
(IF (EQUAL LN 'Y23) (S-OR (SY-BCDS 'YR2 X) (SY-BCDS 'Y15 X)) 
(IF (EQUAL LN 'YR1) (IF (EMPTY X) (E) (I F (SY-BCDS 'Y21 (P X)))) 
(IF (EQUAL LN 'YR2) (IF (EMPTY X) (E) (I F (SY-BCDS 'Y22 (P X)))) 
(IF (EQUAL LN 'YR3) (IF (EMPTY X) (E) (I F (SY-BCDS 'Y23 (P X)))) 
(IF (EQUAL LN 'Y31) (S-NOT (SY-BCDS 'YR1 X)) 
(IF (EQUAL LN 'Y32) (S-NOT (SY-BCDS 'YR2 X)) 
(IF (EQUAL LN 'Y41) (S-AND4 X (SY-BCDS 'Y31 X) (SY-BCDS 'Y32 X)
                            (SY-BCDS 'YR3 X)) 
(IF (EQUAL LN 'YOUT) (S-NOT (SY-BCDS 'Y41 X)) 
(SFIX X))))))))))))))))))))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-BCDS LN)))) )

;; A2-Begin-SY-BCDS

(PROVE-LEMMA A2-EMPTY-SY-BCDS (REWRITE)
    (EQUAL (EMPTY (SY-BCDS LN X)) (EMPTY X))
    ((DISABLE S-AND3 S-OR S-AND4 S-NOT)))

(PROVE-LEMMA A2-E-SY-BCDS (REWRITE)
    (EQUAL (EQUAL (SY-BCDS LN X) (E)) (EMPTY X))
    ((DISABLE SY-BCDS A2-EMPTY-SY-BCDS) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-BCDS))))

(PROVE-LEMMA A2-LP-SY-BCDS (REWRITE)
    (EQUAL (LEN (SY-BCDS LN X)) (LEN X))
    ((DISABLE LEN S-AND3 S-OR S-AND4 S-NOT) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-BCDS (REWRITE) (EQLEN (SY-BCDS LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-BCDS)))

(PROVE-LEMMA A2-PC-SY-BCDS (REWRITE)
    (EQUAL (P (SY-BCDS LN X)) (SY-BCDS LN (P X)))
    ((DISABLE S-AND3 S-OR S-AND4 S-NOT A2-IC-S-AND3 A2-IC-S-OR
              A2-IC-S-AND4 A2-IC-S-NOT)))

;; A2-End-SY-BCDS

;;; Circuit CORRECTNESS /Paillet:

; BCD-Lbits defines a correct binary coded decimal, b0 is 
; most-significant. It assumes the bits are logical though (in
; contrast to bcd.bm).
(defn BCD-Lbits (b0 b1 b2 b3)
  (or (equal b0 F)
      (and (equal b1 F) (equal b2 F))))

; CORRECTNESS:

;;; WHAT PAILLET ACTUALLY PROVES: 
;;; redone-exactly, to show that we can do it too! And to teach us 
;;; how to do some nasty BM control: doing everything backwards!

;; FIRST he starts from the Register-equations, where of course he 
;; doesn't mention the initial values... In our case we have to 
;; PROVE them:
;; NOTES: 1: even though the expansion hints look gruesome, they 
;; are immediate to find out: expand everything once around the 
;; register-loop.
;;        2: we push the P's in, because otherwise clearly the eq's 
;; will loop, even though of course, they are still provable (done).
;;        3: doing all 3 equations at once is clearer than 1 by 1,
;; since the hint gets given only once, and one doesn't have to
;; disable all other proved equations while doing the next one in
;; order to prevent looping.
;;        4: if we give the most general expression: 
;; if empty x e ... then ; 
;; we get a self-looping rule since it applies to its rhs, which is 
;; still usable, as long as we USE it and DISABLE it simultaneously.
;; But that means we have to specify each use individually, and that
;; could be a pain.  
;;	  5: Fundamentally, this is an UNFOLDING rule, i.e. rhs is
;; more complex than lhs.  BM can't deal with that, except in the
;; context of a recursive DEFN, which is exactly the same thing,
;; and for which BM has hardwired smarts. Maybe that's the right 
;; way to handle UNFOLDING rewrites? Create a DEFN for them and
;; prove equality, and then use the DEFN:

(defn SY-B2 (ln x)
(IF (EQUAL LN 'YR1) (IF (EMPTY X) (E)
 (I F (S-OR (S-AND3 (S-NOT (P x)) (SY-B2 'YR1 (P x)) (SY-B2 'YR3 (P x)))
	    (S-AND3 (S-NOT (P x)) (SY-B2 'YR2 (P x)) (S-NOT (SY-B2 'YR3 (P x))))))
  )
(IF (EQUAL LN 'YR2) (IF (EMPTY X) (E)
 (I F (S-OR (S-AND3 (S-NOT (SY-B2 'YR1 (P x))) (S-NOT (SY-B2 'YR2 (P x))) (S-NOT (SY-B2 'YR3 (P x))))
	    (S-AND3 (P x) (S-NOT (SY-B2 'YR1 (P x))) (S-NOT (SY-B2 'YR3 (P x))))))
 )
(IF (EQUAL LN 'YR3) (IF (EMPTY X) (E)
 (I F (S-OR (SY-B2 'YR2 (P x))
	    (S-AND3 (P x) (SY-B2 'YR1 (P x)) (SY-B2 'YR3 (P x)))))
 )
(SFIX X))))
; note: no need for any topo-induction hint since x decreases.
)

; B2 is just a GENERALIZED sysd, and our A2 lemmas should still be 
; true. The following were (Sugar) generated by:
; (vp (bma2sysd-aux 'sy-B2 'sy-B2 '(x) '(and3 or and4 not)))
; with A2-PC disabled because last time we tried it looped, and we 
; don't need it.

;; A2-Begin-SY-B2

(PROVE-LEMMA A2-EMPTY-SY-B2 (REWRITE)
    (EQUAL (EMPTY (SY-B2 LN X)) (EMPTY X))
    ((DISABLE S-AND3 S-OR S-AND4 S-NOT)))

(PROVE-LEMMA A2-E-SY-B2 (REWRITE)
    (EQUAL (EQUAL (SY-B2 LN X) (E)) (EMPTY X))
    ((DISABLE SY-B2 A2-EMPTY-SY-B2) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-B2))))

(PROVE-LEMMA A2-LP-SY-B2 (REWRITE) (EQUAL (LEN (SY-B2 LN X)) (LEN X))
    ((DISABLE LEN S-AND3 S-OR S-AND4 S-NOT) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-B2 (REWRITE) (EQLEN (SY-B2 LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-B2)))

;(PROVE-LEMMA A2-PC-SY-B2 (REWRITE)
;    (EQUAL (P (SY-B2 LN X)) (SY-B2 LN (P X)))
;    ((DISABLE S-AND3 S-OR S-AND4 S-NOT A2-IC-S-AND3 A2-IC-S-OR
;              A2-IC-S-AND4 A2-IC-S-NOT)))

;; A2-End-SY-B2

; BCDS-is-B2 is the essence of this simplification.  
; Note that replacing the conjunction by:
; (implies (or (equal ln 'YR1) (equal ln 'YR2) (equal ln 'YR3))
;          (equal (sy-bcds ln x) (sy-B2 ln x)))
; makes it UNPROVABLE by BM, because the induction hyp needs to be 
; all 3 together, which BM won't do unless there is an explicit AND
; The thm is proved below in 2 immediates cases (on empty x).

(prove-lemma bcds-is-B2 (rewrite)
(and (equal (SY-bcdS 'YR1 x) (SY-B2 'YR1 x))
     (equal (SY-bcdS 'YR2 x) (SY-B2 'YR2 x))
     (equal (SY-bcdS 'YR3 x) (SY-B2 'YR3 x))
     )
((disable S-AND3 S-OR S-AND4 S-NOT)
 (induct (induct-P x))
 (expand (SY-BCDS 'YR1 x)
	 (SY-BCDS 'YR2 x)
	 (SY-BCDS 'YR3 x)
	 (SY-BCDS 'Y21 (P x))
	 (SY-BCDS 'Y22 (P x))
	 (SY-BCDS 'Y23 (P x))
	 (SY-BCDS 'Y11 (P x))
	 (SY-BCDS 'Y12 (P x))
	 (SY-BCDS 'Y13 (P x))
	 (SY-BCDS 'Y14 (P x))
	 (SY-BCDS 'Y15 (P x))
	 (SY-BCDS 'Y01 (P x))
	 (SY-BCDS 'Y02 (P x))
	 (SY-BCDS 'Y03 (P x))
	 (SY-BCDS 'Y04 (P x))
	 (SY-BCDS 'Y05 (P x))
	 (SY-BCDS 'Y06 (P x))
	 (SY-BCDS 'Y07 (P x))
	 (SY-BCDS 'Y08 (P x))
	 )
 )
)

; at this point we should never need SY-BCDS anymore:
(disable SY-BCDS)

; and also he does the expansion for Yout once and for all:
; Note: A-POSTERIORI analysis indicates that this lemma is not 
; really useful to BM, which is usual, since it's just a 
; non-recursive rewrite, and we might as well give the expand hint
; at the right place.

(prove-lemma BCDS-eq-Yout (rewrite)
(equal (SY-BCDS 'Yout x)
       (S-NOT (S-AND4 x
		      (S-NOT (SY-B2 'YR1 x))
		      (S-NOT (SY-B2 'YR2 x))
		      (SY-B2 'YR3 x))))
((expand (SY-BCDS 'Yout x)
	 (SY-BCDS 'Y41 x)
	 (SY-BCDS 'Y31 x)
	 (SY-BCDS 'Y32 x)
	 )
 (disable S-NOT S-AND4) ; speeds things up
 )
)


;; SECOND, he proves things about his DEROULEMENTS:
; note: all thms below are "one-shot", i.e. disabled and enabled 
; explicitely.
; NOTE: at this point we express everything in terms of B2; 
; obviously with BCDS-IS-B2 we can carry everything over.  This
; follows Paillet.

(prove-lemma BCDS-Paillet-1 (rewrite)
(implies (equal (len x) 1)
	 (and (equal (L (SY-B2 'YR1 x)) F)
	      (equal (L (SY-B2 'YR2 x)) F)
	      (equal (L (SY-B2 'YR3 x)) F)
	      ))
((disable S-OR S-AND3 S-NOT SY-B2)
 (enable LEN) ; required; Note: STR-not-empty-len makes proof clearer (3x3) but longer..
 (expand (SY-B2 'YR1 X)
	 (SY-B2 'YR2 X)
	 (SY-B2 'YR3 X)
	 )
 )
)
(disable BCDS-Paillet-1)


(prove-lemma BCDS-Paillet-1out (rewrite)
(implies (equal (len x) 1)
	 (equal (L (SY-BCDS 'Yout x)) T)
	 )
((enable STR-not-empty-len BCDS-paillet-1)
 (disable S-AND4 S-NOT ; so LC can trigger
	  len SY-B2 ; helps
	  )
 )
)
(disable BCDS-Paillet-1out)


(prove-lemma BCDS-Paillet-2 (rewrite)
(implies (equal (len x) 2)
	 (and (equal (L (SY-B2 'YR1 x)) F)
	      (equal (L (SY-B2 'YR2 x)) T)
	      (equal (L (SY-B2 'YR3 x)) F)
	      ))
((disable SY-B2  ; significant speed gain - weird..
	  S-AND3 S-OR S-NOT ; so LC can trigger for them instead.
	  )
 (enable STR-not-empty-len  ; required for L-I to trigger
	 BCDS-Paillet-1
	 LEN  ; required
	 )
 (expand (SY-B2 'YR1 X)
	 (SY-B2 'YR2 X)
	 (SY-B2 'YR3 X)
	 )
 )
)
(disable BCDS-Paillet-2)

(prove-lemma BCDS-Paillet-2out (rewrite)
(implies (equal (len x) 2)
	 (equal (L (SY-BCDS 'Yout x)) T)
	 )
((enable STR-not-empty-len BCDS-Paillet-2) ; also required here, as in 1out.
 (disable S-AND4 S-NOT ; so LC can trigger
	  len SY-B2 ; helps
	  )
 )
)
(disable BCDS-Paillet-2out)

; Note that the "boolp" hyp is not explicit in Paillet...  

(prove-lemma BCDS-Paillet-3 (rewrite)
(implies (and (equal (len x) 3)
	      (S-boolp x))
	 (and (equal (L (SY-B2 'YR1 x)) (not (L (P x))))
	      (equal (L (SY-B2 'YR2 x)) (L (P x)))
	      (equal (L (SY-B2 'YR3 x)) T)
	      ))
((disable SY-B2 ; for speed
	  len  ; len must be disabled for STR-len-P
	  S-AND3 S-OR S-NOT ; so LC can trigger for them instead, otherwise 
	                    ; we get extra (P ...) which wreak havoc.
	  )
 (enable STR-not-empty-len  ; required for L-I to trigger
	 STR-len-P          ; required for Paillet-2 to trigger
	 BCDS-Paillet-2
	 )
 (expand (SY-B2 'YR1 X)
	 (SY-B2 'YR2 X)
	 (SY-B2 'YR3 X)
	 )
 )
)
(disable BCDS-Paillet-3)

(prove-lemma BCDS-Paillet-3out (rewrite)
(implies (and (equal (len x) 3)
	      (S-boolp x))
	 (equal (L (SY-BCDS 'Yout x)) T)
	 )
((enable STR-not-empty-len BCDS-Paillet-3) ; also required here, as in 1out.
 (disable S-AND4 S-NOT ; so LC can trigger
	  len SY-B2; helps tremendously!
	  )
 )
)
(disable BCDS-Paillet-3out)

(prove-lemma BCDS-Paillet-4 (rewrite)
(implies (and (equal (len x) 4)
	      (S-boolp x))
	 (and (equal (L (SY-B2 'YR1 x)) (and (not (L (P x))) (not (L (P (P x)
)))))
	      (equal (L (SY-B2 'YR2 x)) F)
	      (equal (L (SY-B2 'YR3 x)) (or (L (P (P x))) (and (L (P x)) (not (L (P (P x)))))))
	      ))
((disable SY-B2 ; for speed
	  len  ; len must be disabled for STR-len-P
	  S-AND3 S-OR S-NOT ; so LC can trigger for them instead, otherwise 
	                    ; we get extra (P ...) which wreak havoc.
	  )
 (enable STR-not-empty-len  ; required for L-I to trigger
	 STR-len-P          ; required for Paillet-3 to trigger
	 BCDS-Paillet-3
	 )
 (expand (SY-B2 'YR1 X)
	 (SY-B2 'YR2 X)
	 (SY-B2 'YR3 X)
	 )
 )
)
(disable BCDS-Paillet-4)

; and his conclusion:

(prove-lemma BCDS-Paillet-4out (rewrite)
(implies (and (equal (len x) 4)
	      (S-boolp x))
	 (equal (L (SY-BCDS 'Yout x))
		(or (not (L X)) (and (not (L (P X))) (not (L (P (P X))))))
		))
((enable STR-not-empty-len BCDS-Paillet-4) ; also required here, as in 1out.
 (disable S-AND4 S-NOT ; so LC can trigger
	  len SY-B2 ; should help
	  )
 )
)
(disable BCDS-Paillet-4out)

; from which he leaves to the reader the real conclusion:

(prove-lemma BCDS-Paillet-4out-correct (rewrite)
(implies (and (equal (len x) 4)
	      (S-boolp x))
	 (equal (L (SY-BCDS 'Yout x))
		(BCD-Lbits (L x)  ; most recent bit interpreted as most-significant
			   (L (P x))
			   (L (P (P x)))
			   (L (P (P (P x)))))
		))
((disable BCDS-eq-Yout SY-B2)
 (enable BCDS-Paillet-4out)
 )
)
(disable BCDS-Paillet-4out-correct)

; and the last "re-initialization" condition:

(prove-lemma BCDS-Paillet-5 (rewrite)
(implies (and (equal (len x) 5)
	      (S-boolp x))
	 (and (equal (L (SY-B2 'YR1 x)) F)
	      (equal (L (SY-B2 'YR2 x)) F)
	      (equal (L (SY-B2 'YR3 x)) F)
	      ))
((disable SY-B2 ; for speed
	  len  ; len must be disabled for STR-len-P
	  S-AND3 S-OR S-NOT ; so LC can trigger for them instead, otherwise 
	                    ; we get extra (P ...) which wreak havoc.
	  )
 (enable STR-not-empty-len  ; required for L-I to trigger
	 STR-len-P          ; required for Paillet-4 to trigger
	 BCDS-Paillet-4
	 )
 (expand (SY-B2 'YR1 X)
	 (SY-B2 'YR2 X)
	 (SY-B2 'YR3 X)
	 (S-boolp x) ; why this is needed here and not before is a mystery ???
	 )
 )
)
(disable BCDS-Paillet-5)

;;; WHAT I CAN PROVE! :


; The following lemma was thought to help, but in fact it just 
; slows things:
;
;(prove-lemma STR-remainder-len (rewrite)
;(implies (and (not (zerop p)) (not (empty x)))
;	 (equal (remainder (len x) p)
;		(if (equal (remainder (len (P x)) p) (sub1 p))
;		    0
;		    (add1 (remainder (len (P x)) p)))))
;((disable remainder) ; so we go directly to ARI-remainder-add1
; (enable LEN) ; explicit
; )
;)

(prove-lemma BCDS-Paillet-R-correct (rewrite)
(implies (and (not (empty x)) (S-boolp x))
	 (and (equal (L (SY-B2 'YR1 x))
		     (if (equal (remainder (len x) 4) 1) F
		     (if (equal (remainder (len x) 4) 2) F
		     (if (equal (remainder (len x) 4) 3) (not (L (P x)))
		       (and (not (L (P x))) (not (L (P (P x)))))
		       ))))
	      (equal (L (SY-B2 'YR2 x))
		     (if (equal (remainder (len x) 4) 1) F
		     (if (equal (remainder (len x) 4) 2) T
		     (if (equal (remainder (len x) 4) 3) (L (P x))
		       F
		       ))))
	      (equal (L (SY-B2 'YR3 x))
		     (if (equal (remainder (len x) 4) 1) F
		     (if (equal (remainder (len x) 4) 2) F
		     (if (equal (remainder (len x) 4) 3) T
		       (or (L (P (P x))) (and (L (P x)) (not (L (P (P x))))))
		       ))))
	      ))
((disable S-OR S-AND3 S-NOT REMAINDER)  ; remainder help a lot, of course since
                                        ; we use ARI-REMAINDER-ADD1 as def...
 (enable STR-L-I2 ; to induce case disjunction on empty P x 
	 LEN ; required, even STR-ADD1-LEN-P STR-LEN-E don't suffice..
	     ; and with lemma above, not required, but more expensive..
	 )
 )     ; note that (the correct) induction hint makes it blow up...
)

; and finally, the true, general correctness of Paillet#5 :

(prove-lemma BCDS-Paillet-Yout-correct (rewrite)
(implies (and (not (empty x)) (S-boolp x))
	 (equal (L (SY-BCDS 'Yout x))
		(if (equal (remainder (len x) 4) 0)
		    (BCD-Lbits (L x)  ; most recent bit interpreted as most-significant
			       (L (P x))
			       (L (P (P x)))
			       (L (P (P (P x)))))
		    T)
		))
((disable SY-B2 SY-BCDS S-AND4 S-NOT len remainder S-boolp)
 )
)
; we also check the claim we make in the Ccube89 report, that we 
; need only one "build-up" lemma (R-correct). In works fine 
; (same # cases, time) with the (obvious) expand hint we used
; in BCDS-eq-Yout:
; (expand (SY-BCDS 'Yout x)
;	 (SY-BCDS 'Y41 x)
;	 (SY-BCDS 'Y31 x)
;	 (SY-BCDS 'Y32 x)
;	 )
; once again confirming that reifying rewrite lemmas which do not 
; involve induction does not really benefit Boyer-Moore, even 
; though it benefit humans!

; eof: bcdS.bm
;))
