#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; corrSL.bm is the FULL version of the Saxe/Leiserson retimed
; correlator.
; PROOF HISTORY:
; - very interestingly, a bug in the first definition I entered was 
; shown by BM reducing a case to: 
;          (IMPLIES (AND (STRINGP X)
;                        (NOT (EQUAL X (E)))
;                        (EQUAL (P X) (E))
;                        (NOT (EQUAL 'A2 (L X))))
;                   (EQUAL 4 (PLUS 1 1 0 1))).
; which is obviously false, and describes precisely the 
; counterexample!
; - a first correctness proof (brute expansion) was obtained in 
; LESS THAN 1 HOUR, and that includes finding out the definition
; was wrong!

;;; (Sugared) Circuits:
#|
(setq A '(SY-A (x)
(Y1 R 'a0 x)
(Y2 S Del 'a0 Y1)
(Y3 R 'a1 Y1)
(Y4 S Del 'a1 Y3)
(Y5 R 'a2 Y3)
(Y6 S Del 'a2 Y5)
(Y7 R 'a3 Y5)
(Y8 S Del 'a3 Y7)
(Y9 S Plus Y6 Y8)
(Y10 S Plus Y4 Y9)
(Yout S Plus Y2 Y10)
))

(setq B '(SY-B (x)
(Z1 R 'a0 x)
(Z2 S Del 'a0 Z1)
(Z3 R 'a1 Z1)
(Z4 S Del 'a1 Z3)
(Z5 S Del 'a2 Z3)
(Z6 R 'a2 Z3)
(Z7 S Del 'a3 Z6)
(Z8 S Plus Z5 Z7)
(Z9 R 2 Z8)
(Z10 S Plus Z4 Z9)
(Zout S Plus Z2 Z10)
))

(setq corrSL '(  |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_del.bm: Delta combinational element, parametrized.
; U7-DONE

(defn del (val u)
  (if (equal val u) 1 0))

; Everything below generated by SUGAR with:    (bmcomb 'del '(val) '(x))

(DEFN S-DEL (VAL X)
      (IF (EMPTY X) (E) (A (S-DEL VAL (P X)) (DEL VAL (L X)))))

;; A2-Begin-S-DEL

(PROVE-LEMMA A2-EMPTY-S-DEL (REWRITE)
    (EQUAL (EMPTY (S-DEL VAL X)) (EMPTY X)) ((DISABLE DEL)))

(PROVE-LEMMA A2-E-S-DEL (REWRITE)
    (EQUAL (EQUAL (S-DEL VAL X) (E)) (EMPTY X))
    ((DISABLE S-DEL A2-EMPTY-S-DEL) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-DEL))))

(PROVE-LEMMA A2-LP-S-DEL (REWRITE) (EQUAL (LEN (S-DEL VAL X)) (LEN X))
    ((DISABLE DEL) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-DEL (REWRITE) (EQLEN (S-DEL VAL X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-DEL)))

(PROVE-LEMMA A2-IC-S-DEL (REWRITE)
    (EQUAL (S-DEL VAL (I C_X X)) (I (DEL VAL C_X) (S-DEL VAL X)))
    ((ENABLE I) (DISABLE STR-A-I DEL)))

(PROVE-LEMMA A2-LC-S-DEL (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-DEL VAL X)) (DEL VAL (L X))))
    ((DISABLE DEL) (EXPAND (S-DEL VAL X))))

(PROVE-LEMMA A2-PC-S-DEL (REWRITE)
    (EQUAL (P (S-DEL VAL X)) (S-DEL VAL (P X))) ((DISABLE DEL)))

(PROVE-LEMMA A2-HC-S-DEL (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-DEL VAL X)) (DEL VAL (H X))))
    ((DISABLE DEL S-DEL) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-DEL (REWRITE)
    (EQUAL (B (S-DEL VAL X)) (S-DEL VAL (B X)))
    ((DISABLE DEL) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-DEL (REWRITE)
    (EQUAL (BN N (S-DEL VAL X)) (S-DEL VAL (BN N X)))
    ((DISABLE DEL S-DEL)))

;; A2-End-S-DEL

; eof:comb_del.bm


; comb_plus.bm: Plus combinational element.
; U7-DONE

;   no character function definition since BM already knows about Plus..

; Everything below generated by:     (bmcomb 'plus '() '(x y))

(DEFN S-PLUS (X Y)
      (IF (EMPTY X) (E) (A (S-PLUS (P X) (P Y)) (PLUS (L X) (L Y)))))

;; A2-Begin-S-PLUS

(PROVE-LEMMA A2-EMPTY-S-PLUS (REWRITE)
    (EQUAL (EMPTY (S-PLUS X Y)) (EMPTY X)) ((DISABLE PLUS)))

(PROVE-LEMMA A2-E-S-PLUS (REWRITE)
    (EQUAL (EQUAL (S-PLUS X Y) (E)) (EMPTY X))
    ((DISABLE S-PLUS A2-EMPTY-S-PLUS) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-PLUS))))

(PROVE-LEMMA A2-LP-S-PLUS (REWRITE) (EQUAL (LEN (S-PLUS X Y)) (LEN X))
    ((DISABLE PLUS) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-PLUS (REWRITE) (EQLEN (S-PLUS X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-PLUS)))

(PROVE-LEMMA A2-IC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-PLUS (I C_X X) (I C_Y Y))
                    (I (PLUS C_X C_Y) (S-PLUS X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I PLUS)))

(PROVE-LEMMA A2-LC-S-PLUS (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-PLUS X Y)) (PLUS (L X) (L Y))))
    ((DISABLE PLUS) (EXPAND (S-PLUS X Y))))

(PROVE-LEMMA A2-PC-S-PLUS (REWRITE)
    (EQUAL (P (S-PLUS X Y)) (S-PLUS (P X) (P Y))) ((DISABLE PLUS)))

(PROVE-LEMMA A2-HC-S-PLUS (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-PLUS X Y)) (PLUS (H X) (H Y))))
    ((DISABLE PLUS S-PLUS) (ENABLE H LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-PLUS X Y)) (S-PLUS (B X) (B Y))))
    ((DISABLE PLUS) (ENABLE B LEN) (INDUCT (S-PLUS X Y))))

(PROVE-LEMMA A2-BNC-S-PLUS (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-PLUS X Y)) (S-PLUS (BN N X) (BN N Y))))
    ((DISABLE PLUS S-PLUS)))

;; A2-End-S-PLUS

; eof:comb_plus.bm


(DEFN TOPOR-SY-A (LN) 
(IF (EQUAL LN 'Y1) 0 
(IF (EQUAL LN 'Y2) 1 
(IF (EQUAL LN 'Y3) 0 
(IF (EQUAL LN 'Y4) 1 
(IF (EQUAL LN 'Y5) 0 
(IF (EQUAL LN 'Y6) 1 
(IF (EQUAL LN 'Y7) 0 
(IF (EQUAL LN 'Y8) 1 
(IF (EQUAL LN 'Y9) 2 
(IF (EQUAL LN 'Y10) 3 
(IF (EQUAL LN 'YOUT) 4 
0))))))))))))

;Parameter found: 'A0 in: (Y2 S DEL 'A0 Y1)
;Parameter found: 'A1 in: (Y4 S DEL 'A1 Y3)
;Parameter found: 'A2 in: (Y6 S DEL 'A2 Y5)
;Parameter found: 'A3 in: (Y8 S DEL 'A3 Y7)
(DEFN SY-A (LN X) 
(IF (EQUAL LN 'Y1) (IF (EMPTY X) (E) (I 'A0 (P X))) 
(IF (EQUAL LN 'Y2) (S-DEL 'A0 (SY-A 'Y1 X)) 
(IF (EQUAL LN 'Y3) (IF (EMPTY X) (E) (I 'A1 (SY-A 'Y1 (P X)))) 
(IF (EQUAL LN 'Y4) (S-DEL 'A1 (SY-A 'Y3 X)) 
(IF (EQUAL LN 'Y5) (IF (EMPTY X) (E) (I 'A2 (SY-A 'Y3 (P X)))) 
(IF (EQUAL LN 'Y6) (S-DEL 'A2 (SY-A 'Y5 X)) 
(IF (EQUAL LN 'Y7) (IF (EMPTY X) (E) (I 'A3 (SY-A 'Y5 (P X)))) 
(IF (EQUAL LN 'Y8) (S-DEL 'A3 (SY-A 'Y7 X)) 
(IF (EQUAL LN 'Y9) (S-PLUS (SY-A 'Y6 X) (SY-A 'Y8 X)) 
(IF (EQUAL LN 'Y10) (S-PLUS (SY-A 'Y4 X) (SY-A 'Y9 X)) 
(IF (EQUAL LN 'YOUT) (S-PLUS (SY-A 'Y2 X) (SY-A 'Y10 X)) 
(SFIX X))))))))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-A LN)))) )

;; A2-Begin-SY-A

(PROVE-LEMMA A2-EMPTY-SY-A (REWRITE)
    (EQUAL (EMPTY (SY-A LN X)) (EMPTY X)) ((DISABLE S-DEL S-PLUS)))

(PROVE-LEMMA A2-E-SY-A (REWRITE)
    (EQUAL (EQUAL (SY-A LN X) (E)) (EMPTY X))
    ((DISABLE SY-A A2-EMPTY-SY-A) (ENABLE EMPTY) (USE (A2-EMPTY-SY-A))))

(PROVE-LEMMA A2-LP-SY-A (REWRITE) (EQUAL (LEN (SY-A LN X)) (LEN X))
    ((DISABLE LEN S-DEL S-PLUS) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-A (REWRITE) (EQLEN (SY-A LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-A)))

(PROVE-LEMMA A2-PC-SY-A (REWRITE)
    (EQUAL (P (SY-A LN X)) (SY-A LN (P X)))
    ((DISABLE S-DEL S-PLUS A2-IC-S-DEL A2-IC-S-PLUS)))

;; A2-End-SY-A
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:

(DEFN TOPOR-SY-B (LN) 
(IF (EQUAL LN 'Z1) 0 
(IF (EQUAL LN 'Z2) 1 
(IF (EQUAL LN 'Z3) 0 
(IF (EQUAL LN 'Z4) 1 
(IF (EQUAL LN 'Z5) 1 
(IF (EQUAL LN 'Z6) 0 
(IF (EQUAL LN 'Z7) 1 
(IF (EQUAL LN 'Z8) 2 
(IF (EQUAL LN 'Z9) 0 
(IF (EQUAL LN 'Z10) 2 
(IF (EQUAL LN 'ZOUT) 3 
0))))))))))))

;Parameter found: 'A0 in: (Z2 S DEL 'A0 Z1)
;Parameter found: 'A1 in: (Z4 S DEL 'A1 Z3)
;Parameter found: 'A2 in: (Z5 S DEL 'A2 Z3)
;Parameter found: 'A3 in: (Z7 S DEL 'A3 Z6)
(DEFN SY-B (LN X) 
(IF (EQUAL LN 'Z1) (IF (EMPTY X) (E) (I 'A0 (P X))) 
(IF (EQUAL LN 'Z2) (S-DEL 'A0 (SY-B 'Z1 X)) 
(IF (EQUAL LN 'Z3) (IF (EMPTY X) (E) (I 'A1 (SY-B 'Z1 (P X)))) 
(IF (EQUAL LN 'Z4) (S-DEL 'A1 (SY-B 'Z3 X)) 
(IF (EQUAL LN 'Z5) (S-DEL 'A2 (SY-B 'Z3 X)) 
(IF (EQUAL LN 'Z6) (IF (EMPTY X) (E) (I 'A2 (SY-B 'Z3 (P X)))) 
(IF (EQUAL LN 'Z7) (S-DEL 'A3 (SY-B 'Z6 X)) 
(IF (EQUAL LN 'Z8) (S-PLUS (SY-B 'Z5 X) (SY-B 'Z7 X)) 
(IF (EQUAL LN 'Z9) (IF (EMPTY X) (E) (I 2 (SY-B 'Z8 (P X)))) 
(IF (EQUAL LN 'Z10) (S-PLUS (SY-B 'Z4 X) (SY-B 'Z9 X)) 
(IF (EQUAL LN 'ZOUT) (S-PLUS (SY-B 'Z2 X) (SY-B 'Z10 X)) 
(SFIX X))))))))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-B LN)))) )

;; A2-Begin-SY-B

(PROVE-LEMMA A2-EMPTY-SY-B (REWRITE)
    (EQUAL (EMPTY (SY-B LN X)) (EMPTY X)) ((DISABLE S-DEL S-PLUS)))

(PROVE-LEMMA A2-E-SY-B (REWRITE)
    (EQUAL (EQUAL (SY-B LN X) (E)) (EMPTY X))
    ((DISABLE SY-B A2-EMPTY-SY-B) (ENABLE EMPTY) (USE (A2-EMPTY-SY-B))))

(PROVE-LEMMA A2-LP-SY-B (REWRITE) (EQUAL (LEN (SY-B LN X)) (LEN X))
    ((DISABLE LEN S-DEL S-PLUS) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-B (REWRITE) (EQLEN (SY-B LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-B)))

(PROVE-LEMMA A2-PC-SY-B (REWRITE)
    (EQUAL (P (SY-B LN X)) (SY-B LN (P X)))
    ((DISABLE S-DEL S-PLUS A2-IC-S-DEL A2-IC-S-PLUS)))

;; A2-End-SY-B

;;; CORRECTNESS PROOF (hand generated, dreamer!):

; The following works, but is rather inelegant, and painful to 
; scale.
; Note that STR-add1-len-P2 saves an elimination,and hence cuts the
; proof complexity, and run time in 3.
(prove-lemma EQ-A-B ()
(implies (stringp x)
	 (equal (sy-b 'Zout x)
		(sy-a 'Yout x)))
((expand (sy-b 'Zout x)
	 (sy-a 'Yout x)
	 (sy-b 'Z2 x)
	 (sy-b 'Z10 x)
	 (sy-a 'Y2 x)
	 (sy-a 'Y10 x)
	 (sy-b 'Z4 x)
	 (sy-b 'Z9 x)
	 (sy-a 'Y4 x)
	 (sy-a 'Y9 x)
	 (sy-b 'Z3 x)
	 (sy-b 'Z8 (p x))
	 (sy-a 'Y3 x)
	 (sy-a 'Y8 x)
	 (sy-a 'Y6 x)
	 (sy-a 'Y7 x)
	 (sy-a 'Y5 x)
	 (sy-b 'Z7 (p x))
	 (sy-b 'Z5 (p x))
	 (sy-b 'Z6 (p x))
	 (sy-b 'Z3 (p x))
	 (sy-a 'Y5 (p x))
	 (sy-a 'Y3 (p x))
	 (sy-b 'Z3 (p (p x)))
	 (sy-a 'Y3 (p (p x)))
	 )
 (disable len) (enable STR-add1-len-P2)
 )
)


; The next attempt uses SMARTS instead of strength:
; FIRST we build the equalities which are in some sense 
; syntactically guaranteed to be true, since they relate to the
; "unchanged" part of the circuit:

(prove-lemma EQ-Z1-Y1 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z1 x)
		(sy-a 'Y1 x)))
)
(prove-lemma EQ-Z2-Y2 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z2 x)
		(sy-a 'Y2 x)))
((expand (sy-b 'Z2 x) (sy-a 'Y2 x)))
)
(prove-lemma EQ-Z3-Y3 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z3 x)
		(sy-a 'Y3 x)))
((expand (sy-b 'Z3 x) (sy-a 'Y3 x)))
)
(prove-lemma EQ-Z4-Y4 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z4 x)
		(sy-a 'Y4 x)))
((expand (sy-b 'Z4 x) (sy-a 'Y4 x)))
)

; SECOND we prove the only tricky fact about the circuit:
(prove-lemma EQ-Z9-Y9 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z9 x)
		(sy-a 'Y9 x)))
((expand (sy-b 'Z9 x)
	 (sy-a 'Y9 x)
	 (sy-b 'Z8 (p x))
	 (sy-a 'Y8 x)
	 (sy-a 'Y6 x)
	 (sy-b 'Z7 (p x))
	 (sy-a 'Y7 x)
	 )
 (disable len) (enable STR-add1-len-P2) ; to introduce the case disjunction
 )
)

; THIRD we complete the list of trivial equalities..
(prove-lemma EQ-Z10-Y10 (rewrite)
(implies (stringp x)
	 (equal (sy-b 'Z10 x)
		(sy-a 'Y10 x)))
((expand (sy-b 'Z10 x) (sy-a 'Y10 x)))
)

; yielding the desired correctness statement!
(prove-lemma EQ-Zout-Yout ()
(implies (stringp x)
	 (equal (sy-b 'Zout x)
		(sy-a 'Yout x)))
((expand (sy-b 'Zout x) (sy-a 'Yout x)))
)

; eof: corrSL.bm
;))