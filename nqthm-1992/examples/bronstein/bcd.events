#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; bcd.bm: a BCD code checker, with serial (bit) input.
;  . we have proved correctness w/ registers init to 0 (i.e. 
;   reality) AND for ARBITRARY init values ('r0,'r1); although it 
;   doesn't REALLY MEAN anything since the combinationals interpret
;   that as ones... 2/6/89
;  . we have also expressed the correctness hypothesis in various
;   ways, to analyze idiom trade-offs for expressing that the 
;   "first 3 chars don't matter".
;

;;; CIRCUIT in SUGARED form:
#|
(setq sysd '(sy-BCD (x)
(Y0 R 'r0 x)
(Y1 R 'r1 Y0)
(Y2 S bor Y0 Y1)
(Yout S bnand x Y2)
))

(setq bcd '( |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_bor.bm: Binary Or combinational element
; U7-DONE

(defn bor (u v)
  (if (and (equal u 0) (equal v 0))
      0
      1))
	   
; Everything below generated by: (bmcomb 'bor '() '(x y))

(DEFN S-BOR (X Y)
      (IF (EMPTY X) (E) (A (S-BOR (P X) (P Y)) (BOR (L X) (L Y)))))

;; A2-Begin-S-BOR

(PROVE-LEMMA A2-EMPTY-S-BOR (REWRITE)
    (EQUAL (EMPTY (S-BOR X Y)) (EMPTY X)) ((DISABLE BOR)))

(PROVE-LEMMA A2-E-S-BOR (REWRITE)
    (EQUAL (EQUAL (S-BOR X Y) (E)) (EMPTY X))
    ((DISABLE S-BOR A2-EMPTY-S-BOR) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-BOR))))

(PROVE-LEMMA A2-LP-S-BOR (REWRITE) (EQUAL (LEN (S-BOR X Y)) (LEN X))
    ((DISABLE BOR) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-BOR (REWRITE) (EQLEN (S-BOR X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-BOR)))

(PROVE-LEMMA A2-IC-S-BOR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-BOR (I C_X X) (I C_Y Y))
                    (I (BOR C_X C_Y) (S-BOR X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I BOR)))

(PROVE-LEMMA A2-LC-S-BOR (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-BOR X Y)) (BOR (L X) (L Y))))
    ((DISABLE BOR) (EXPAND (S-BOR X Y))))

(PROVE-LEMMA A2-PC-S-BOR (REWRITE)
    (EQUAL (P (S-BOR X Y)) (S-BOR (P X) (P Y))) ((DISABLE BOR)))

(PROVE-LEMMA A2-HC-S-BOR (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-BOR X Y)) (BOR (H X) (H Y))))
    ((DISABLE BOR S-BOR) (ENABLE H LEN) (INDUCT (S-BOR X Y))))

(PROVE-LEMMA A2-BC-S-BOR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-BOR X Y)) (S-BOR (B X) (B Y))))
    ((DISABLE BOR) (ENABLE B LEN) (INDUCT (S-BOR X Y))))

(PROVE-LEMMA A2-BNC-S-BOR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-BOR X Y)) (S-BOR (BN N X) (BN N Y))))
    ((DISABLE BOR S-BOR)))

;; A2-End-S-BOR

; eof:comb_bor.bm

; comb_bnand.bm: Binary Nand combinational element
; U7-DONE

(defn bnand (u v)
  (if (or (equal u 0) (equal v 0))
      1
      0))
	   
; Everything below generated by: (bmcomb 'bnand '() '(x y))

(DEFN S-BNAND (X Y)
      (IF (EMPTY X) (E) (A (S-BNAND (P X) (P Y)) (BNAND (L X) (L Y)))))

;; A2-Begin-S-BNAND

(PROVE-LEMMA A2-EMPTY-S-BNAND (REWRITE)
    (EQUAL (EMPTY (S-BNAND X Y)) (EMPTY X)) ((DISABLE BNAND)))

(PROVE-LEMMA A2-E-S-BNAND (REWRITE)
    (EQUAL (EQUAL (S-BNAND X Y) (E)) (EMPTY X))
    ((DISABLE S-BNAND A2-EMPTY-S-BNAND) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-BNAND))))

(PROVE-LEMMA A2-LP-S-BNAND (REWRITE)
    (EQUAL (LEN (S-BNAND X Y)) (LEN X)) ((DISABLE BNAND) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-BNAND (REWRITE) (EQLEN (S-BNAND X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-BNAND)))

(PROVE-LEMMA A2-IC-S-BNAND (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-BNAND (I C_X X) (I C_Y Y))
                    (I (BNAND C_X C_Y) (S-BNAND X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I BNAND)))

(PROVE-LEMMA A2-LC-S-BNAND (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-BNAND X Y)) (BNAND (L X) (L Y))))
    ((DISABLE BNAND) (EXPAND (S-BNAND X Y))))

(PROVE-LEMMA A2-PC-S-BNAND (REWRITE)
    (EQUAL (P (S-BNAND X Y)) (S-BNAND (P X) (P Y))) ((DISABLE BNAND)))

(PROVE-LEMMA A2-HC-S-BNAND (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-BNAND X Y)) (BNAND (H X) (H Y))))
    ((DISABLE BNAND S-BNAND) (ENABLE H LEN) (INDUCT (S-BNAND X Y))))

(PROVE-LEMMA A2-BC-S-BNAND (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-BNAND X Y)) (S-BNAND (B X) (B Y))))
    ((DISABLE BNAND) (ENABLE B LEN) (INDUCT (S-BNAND X Y))))

(PROVE-LEMMA A2-BNC-S-BNAND (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-BNAND X Y)) (S-BNAND (BN N X) (BN N Y))))
    ((DISABLE BNAND S-BNAND)))

;; A2-End-S-BNAND

; eof:comb_bnand.bm


(DEFN TOPOR-SY-BCD (LN) 
(IF (EQUAL LN 'Y0) 0 
(IF (EQUAL LN 'Y1) 0 
(IF (EQUAL LN 'Y2) 1 
(IF (EQUAL LN 'YOUT) 2 
0)))))

(DEFN SY-BCD (LN X) 
(IF (EQUAL LN 'Y0) (IF (EMPTY X) (E) (I 'R0 (P X))) 
(IF (EQUAL LN 'Y1) (IF (EMPTY X) (E) (I 'R1 (SY-BCD 'Y0 (P X)))) 
(IF (EQUAL LN 'Y2) (S-BOR (SY-BCD 'Y0 X) (SY-BCD 'Y1 X)) 
(IF (EQUAL LN 'YOUT) (S-BNAND X (SY-BCD 'Y2 X)) 
(SFIX X)))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-BCD LN)))) )

;; A2-Begin-SY-BCD

(PROVE-LEMMA A2-EMPTY-SY-BCD (REWRITE)
    (EQUAL (EMPTY (SY-BCD LN X)) (EMPTY X)) ((DISABLE S-BOR S-BNAND)))

(PROVE-LEMMA A2-E-SY-BCD (REWRITE)
    (EQUAL (EQUAL (SY-BCD LN X) (E)) (EMPTY X))
    ((DISABLE SY-BCD A2-EMPTY-SY-BCD) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-BCD))))

(PROVE-LEMMA A2-LP-SY-BCD (REWRITE) (EQUAL (LEN (SY-BCD LN X)) (LEN X))
    ((DISABLE LEN S-BOR S-BNAND) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-BCD (REWRITE) (EQLEN (SY-BCD LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-BCD)))

(PROVE-LEMMA A2-PC-SY-BCD (REWRITE)
    (EQUAL (P (SY-BCD LN X)) (SY-BCD LN (P X)))
    ((DISABLE S-BOR S-BNAND A2-IC-S-BOR A2-IC-S-BNAND)))

;; A2-End-SY-BCD

;;; Circuit CORRECTNESS /Paillet:

; BCD-bits defines a correct binary coded decimal, 
;    b0 is most-significant.
(defn BCD-bits (b0 b1 b2 b3)
  (or (equal b0 0)
      (and (equal b1 0) (equal b2 0))))


; BCD-Spec defines what the circuit is supposed to compute, by its
; last char.
(defn BCD-Spec (x)
  (BCD-bits (L x)  ; most recent bit interpreted as most-significant
	    (L (P x))
	    (L (P (P x)))
	    (L (P (P (P x))))))

; CORRECTNESS:
; original correctness statement:
(prove-lemma bcd-correct ()
(implies (and (not (empty x)) (not (empty (p x))) (not (empty (p (p x)))) (not (empty (p (p (p x))))))
	 (equal (bibo (L (sy-bcd 'Yout x)))
		(BCD-Spec x)))
((expand (SY-BCD 'YOUT X)
	 (SY-BCD 'Y2 X)
	 )
 )
)

; alternative: implicitely using P(n+1) x /=e => P(n) x,..,Px,x /=e
;   ALSO works, with many more time and more CASES because BM 
;   explores all the "obviously impossible" cases and takes some 
;   time reducing the hyp to F.
(prove-lemma bcd-correct2 ()
(implies (not (empty (P (P (P x)))))
	 (equal (bibo (L (sy-bcd 'Yout x)))
		(BCD-Spec x)))
((expand (SY-BCD 'YOUT X)
	 (SY-BCD 'Y2 X)
	 )
 )
)

; alternative: use the Pn operator instead of explicit P's in hyp:
;   ALSO works, with same number of CASES as explicit P's, but a 
;   little bit more time due to the expansions of Pn required.
(prove-lemma bcd-correct3 ()
(implies (not (empty (Pn 3 x)))
	 (equal (bibo (L (sy-bcd 'Yout x)))  ; bibo converts a bit to a boolean
		(BCD-Spec x)))
((expand (SY-BCD 'YOUT X)
	 (SY-BCD 'Y2 X)
	 )
 )
)

; alternative: use LENgth > 3 instead of Pn or explicit P's.
;   ALSO works, with same number of CASES and time as Pn
(prove-lemma bcd-correct4 ()
(implies (lessp 3 (len x))
	 (equal (bibo (L (sy-bcd 'Yout x)))
		(BCD-Spec x)))
((expand (SY-BCD 'YOUT X)
	 (SY-BCD 'Y2 X)
	 )
 )
)

;; one can give a CONTRIVED reading of Paillet's as pure streams:

(defn BCD-bits-S (b0 b1 b2 b3)
  (S-or (S-equal b0 (S-const 0 b0))
	(S-and (S-equal b1 (S-const 0 b1)) (S-equal b2 (S-const 0 b2)))))

(defn BCD-Spec-S (x)
  (BCD-bits-S x  ; most recent bit interpreted as most-significant
	      (P x)
	      (P (P x))
	      (P (P (P x)))))

; but do NOT have the equality Yout = BCD-Spec-S because of the 
; initial 3 values output by the circuit.  To get around that, we 
; could:
;    - redefine BCD-Spec-S to be a big IF statement on the length 
;      of x, and put in the explicit values computed by the 
;      circuit, obtained by evaluating SY-BCD in rloop.  
;      [ A major pain ]
;    - somehow express that we're not looking at the first 3 values
;      output. 
;      We could use (RST (RST (RST ... ) = (RST (RST (RST ... ) but
;      clearly that would not work, since we currently have nothing
;      about RST.
; Note that this is essentially the PIPELINE problem.  
; So far, the best approach seems to talk about L(sysd) which is
; most natural.
; NOTE: now that we've defined B (instead of RST) to deal with 
; pipelines, and entered its theory, the above discussioon is moot.


; eof: bcd.bm
;))
