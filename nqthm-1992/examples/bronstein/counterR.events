#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; counterR.bm: a resetable clock counter, i.e. Paillet example 1.
;
; This is our first circuit w/ 2 inputs, yet to my amazement, 
; extra EQLEN hypotheses were NEVER required, neither in the A2
; lemmas, nor in the actual specifications (Paillet, or mine)!  Of 
; course, when they became required (in Paillet #7) and put in
; Sugar, they were installed here.
;
; NOTE (w/ EMPTY enabled) : Attempts to speed up A2-PC failed 
; miserably: disabling the combinationals fails because of the 
; uneven cases, and the fact that BM can't derive (empty y) from
; (empty x) and equal (len x) (len y).
; A problem we have had for a long time, and which will probably 
; persist until we solve EQLEN.
; Giving the induction hint ahead of time made things worse, as 
; usual. Twiddling with STR-P-I2 improved nothing.



;;; CIRCUIT in SUGARED form:
#|
(setq sysd '(sy-COUNT (Xc Xe)
(Ymux  S Mux Xc Xe Yinc)
(Yreg  R 0 YMux)
(Yinc  S Incn Yreg)
))

(setq counterR '( |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_mux.bm: Mux combinational element, i.e. "if".
; U7-DONE

(defn mux (u1 u2 u3) (if u1 u2 u3))

; everything below generated by: (bmcomb 'mux '() '(x1 x2 x3))
; with the EXCEPTIONS/HAND-MODIFICATIONS given below.

(DEFN S-MUX (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-MUX (P X1) (P X2) (P X3)) (MUX (L X1) (L X2) (L X3)))))

; SMUX-is-SIF can make things much simpler on occasions:

(prove-lemma smux-is-sif (rewrite) 
    (equal (s-mux x1 x2 x3) (s-if x1 x2 x3)))

(disable smux-is-sif)

; We take advantage of SMUX-is-SIF for all inductive proofs. To do so we
; HAND-MODIFY the code generated by Sugar to replace all the hints by
;   - A2-EMPTY, A2-PC replace hint with: ((enable smux-is-sif)) 
;   - A2-LP, A2-IC, A2-HC, A2-BC: ((enable smux-is-sif) (disable len))
;   - A2-BNC: ((enable smux-is-sif) (disable bn len))

;; A2-Begin-S-MUX

(PROVE-LEMMA A2-EMPTY-S-MUX (REWRITE)
    (EQUAL (EMPTY (S-MUX X1 X2 X3)) (EMPTY X1)) ((enable smux-is-sif)))

(PROVE-LEMMA A2-E-S-MUX (REWRITE)
    (EQUAL (EQUAL (S-MUX X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-MUX A2-EMPTY-S-MUX) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-MUX))))

(PROVE-LEMMA A2-LP-S-MUX (REWRITE)
    (EQUAL (LEN (S-MUX X1 X2 X3)) (LEN X1))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LPE-S-MUX (REWRITE) (EQLEN (S-MUX X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-MUX)))

(PROVE-LEMMA A2-IC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-MUX (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (MUX C_X1 C_X2 C_X3) (S-MUX X1 X2 X3))))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LC-S-MUX (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-MUX X1 X2 X3)) (MUX (L X1) (L X2) (L X3))))
    ((DISABLE MUX) (EXPAND (S-MUX X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-MUX (REWRITE)
    (EQUAL (P (S-MUX X1 X2 X3)) (S-MUX (P X1) (P X2) (P X3)))
    ((enable smux-is-sif)))

(PROVE-LEMMA A2-HC-S-MUX (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-MUX X1 X2 X3)) (MUX (H X1) (H X2) (H X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX S-MUX) (ENABLE H LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-MUX X1 X2 X3)) (S-MUX (B X1) (B X2) (B X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX) (ENABLE B LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BNC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-MUX X1 X2 X3))
                    (S-MUX (BN N X1) (BN N X2) (BN N X3))))
    ((enable smux-is-sif) (disable bn len)))

;old: ((DISABLE MUX S-MUX))

;; A2-End-S-MUX

; eof:comb_mux.bm

; comb_incn.bm: Inc modulo N combinational element, a minor modification
;               of comb_inc which shouldn't cause any difference, unless
;               the loop-around property is used in a critical way, which is
;               rare.  
; Note that N is treated as a global constant, but not as an individual 
; parameter, so we don't have to carry it around everywhere.  This is just
; an experiment, to see what's more convenient.
; U7-DONE

(dcl N ())
; we may want to add an axiom saying that it's a number, not needed so far..

(defn Incn (u) (if (equal u (N)) 0 (add1 u)))

; Everything below generated by: (bmcomb 'incn '() '(x))

(DEFN S-INCN (X) (IF (EMPTY X) (E) (A (S-INCN (P X)) (INCN (L X)))))

;; A2-Begin-S-INCN

(PROVE-LEMMA A2-EMPTY-S-INCN (REWRITE)
    (EQUAL (EMPTY (S-INCN X)) (EMPTY X)) ((DISABLE INCN)))

(PROVE-LEMMA A2-E-S-INCN (REWRITE)
    (EQUAL (EQUAL (S-INCN X) (E)) (EMPTY X))
    ((DISABLE S-INCN A2-EMPTY-S-INCN) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-INCN))))

(PROVE-LEMMA A2-LP-S-INCN (REWRITE) (EQUAL (LEN (S-INCN X)) (LEN X))
    ((DISABLE INCN) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-INCN (REWRITE) (EQLEN (S-INCN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-INCN)))

(PROVE-LEMMA A2-IC-S-INCN (REWRITE)
    (EQUAL (S-INCN (I C_X X)) (I (INCN C_X) (S-INCN X)))
    ((ENABLE I) (DISABLE STR-A-I INCN)))

(PROVE-LEMMA A2-LC-S-INCN (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-INCN X)) (INCN (L X))))
    ((DISABLE INCN) (EXPAND (S-INCN X))))

(PROVE-LEMMA A2-PC-S-INCN (REWRITE)
    (EQUAL (P (S-INCN X)) (S-INCN (P X))) ((DISABLE INCN)))

(PROVE-LEMMA A2-HC-S-INCN (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-INCN X)) (INCN (H X))))
    ((DISABLE INCN S-INCN) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-INCN (REWRITE)
    (EQUAL (B (S-INCN X)) (S-INCN (B X))) ((DISABLE INCN) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-INCN (REWRITE)
    (EQUAL (BN N (S-INCN X)) (S-INCN (BN N X)))
    ((DISABLE INCN S-INCN)))

;; A2-End-S-INCN

; eof:comb_incn.bm


(DEFN TOPOR-SY-COUNT (LN) 
(IF (EQUAL LN 'YMUX) 2 
(IF (EQUAL LN 'YREG) 0 
(IF (EQUAL LN 'YINC) 1 
0))))

(DEFN SY-COUNT (LN XC XE) 
(IF (EQUAL LN 'YMUX) (S-MUX XC XE (SY-COUNT 'YINC XC XE)) 
(IF (EQUAL LN 'YREG) (IF (EMPTY XC) (E)
                         (I 0 (SY-COUNT 'YMUX (P XC) (P XE)))) 
(IF (EQUAL LN 'YINC) (S-INCN (SY-COUNT 'YREG XC XE)) 
(SFIX XC))))
((LEX2 (LIST (COUNT XC) (TOPOR-SY-COUNT LN)))) )

;; A2-Begin-SY-COUNT

(PROVE-LEMMA A2-EMPTY-SY-COUNT (REWRITE)
    (IMPLIES (EQUAL (LEN XC) (LEN XE))
             (EQUAL (EMPTY (SY-COUNT LN XC XE)) (EMPTY XC)))
    ((DISABLE LEN S-MUX S-INCN) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-E-SY-COUNT (REWRITE)
    (IMPLIES (EQUAL (LEN XC) (LEN XE))
             (EQUAL (EQUAL (SY-COUNT LN XC XE) (E)) (EMPTY XC)))
    ((DISABLE LEN SY-COUNT A2-EMPTY-SY-COUNT) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-COUNT))))

(PROVE-LEMMA A2-LP-SY-COUNT (REWRITE)
    (IMPLIES (EQUAL (LEN XC) (LEN XE))
             (EQUAL (LEN (SY-COUNT LN XC XE)) (LEN XC)))
    ((DISABLE LEN S-MUX S-INCN) (ENABLE STR-ADD1-LEN-P STR-LEN-E)))

(PROVE-LEMMA A2-LPE-SY-COUNT (REWRITE)
    (IMPLIES (EQUAL (LEN XC) (LEN XE)) (EQLEN (SY-COUNT LN XC XE) XC))
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-COUNT)))

(PROVE-LEMMA A2-PC-SY-COUNT (REWRITE)
    (IMPLIES (EQUAL (LEN XC) (LEN XE))
             (EQUAL (P (SY-COUNT LN XC XE))
                    (SY-COUNT LN (P XC) (P XE))))
    ((DISABLE LEN S-MUX S-INCN A2-IC-S-MUX A2-IC-S-INCN)
     (ENABLE STR-ADD1-LEN-P)))

;; A2-End-SY-COUNT

;;; Circuit CORRECTNESS /Paillet:

; Note that as originally stated in Paillet, with the P outside of 
; sy-count makes for a looping (unfolding) which would have to be 
; proved kludgeily, and would be useless.  The following rule can
; be used as a rewrite.

(prove-lemma count-paillet-correct (rewrite)
(implies (and (not (empty Xc)) (not (empty Xe))
;	      (equal (len Xc) (len Xe))  ; no need for any A2-COUNT..
	      )
	 (equal (sy-count 'Yreg Xc Xe)
		(I 0 (S-IF (P Xc)
			   (P Xe)
			   (S-Incn (sy-count 'Yreg (P Xc) (P Xe)))))))
((expand (sy-count 'Yreg Xc Xe)
	 (sy-count 'Ymux (P Xc) (P Xe))
	 )
 (enable smux-is-sif) ; for dumb translation
 (disable incn ;simplifies things and shows that the actual comb is irrelevant
	  s-if ; speeds things up
	  )
 )
)

; The "last-char" reading of the spec yields:
; NOTE: we can prove it by repeating the same hint and disabling 
; CORRECT, i.e. independently.  Trying to use CORRECT fails 
; miserably because it also triggers on:
; (sy-count 'Yreg (P Xc) (P Xe)).  Note also that we need the
; EQ-LEN hyp because we need A2-EMPTY-SY-COUNT.
(prove-lemma count-paillet-correct-L ()
(implies (and (not (empty (P Xc))) (not (empty (P Xe)))
	      (equal (len Xc) (len Xe))
	      )
	 (equal (L (sy-count 'Yreg Xc Xe))
		(IF (L (P Xc))
		    (L (P Xe))
		    (incn (L (sy-count 'Yreg (P Xc) (P Xe)))))))
((expand (sy-count 'Yreg Xc Xe)
	 (sy-count 'Ymux (P Xc) (P Xe))
	 )
 (disable incn s-if count-paillet-correct) 
 (enable smux-is-sif)
 )
)

; eof: counterR.bm
;))
