#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)
; srccpu.bm is the BIG ONE!
;
; Notes:
; . As in pplfadd, some A2-PCs trigger a BM bug and blow up 
;   (here A2-PC-SY-I) so we declare it as axiom (point that out in
;   Personal Confessions section in thesis).
; . Constants:  Initial PC (pci) has to be declared and axiomatized
;   as a numberp, because we do defined arithmetic (add1) on it.  
;   Others: initial program and initial register file are quoted 
;   constants, because only undefined (dcl) functions act on them.
; . We code "NoAd" (inexistant address) as F, because it makes life
;   easier by avoiding needless equalities around.  As a general 
;   principle (at least in BM), boolean flags should be coded as
;   booleans in the model!  It also means that "small k" and 
;   "big k" in Saxe's picture are now the same thing:
;   (k ctl leftinput) = (if ctl F leftinput).


;;; (Sugared) Circuits:
#|
(setq sy-S '(sy-S (x)
(Ypc R (pci) Ypcn)
(Ypcn S mux Ybc Ybt Ypcp1)
(Ypcp1 S inc Ypc)
(Ybc S eql0 Ywd)

(Ypr R 'pro Ypr)
(Ybt S Umb Ypc Ypr)
(Ywa S Umw Ypc Ypr)
(Yra S Umr Ypc Ypr)
(Yf S Umf Ypc Ypr)

(Ywd S Ualu Yf Yrd)
(Yrd S Ulk Yra Yrf)
(Yrf R 'rfi Yrfn)
(Yrfn S Upd Ywa Ywd Yrf)
))

; pipeline elements are indicated by visual offset (and digits):
; Initial values (originally inspired by Lamport):
;
; The branch target (bt) don't matter, they get 0
; The branch control (bc) DO matter, they must start w/ False: F
; The write address (wa) also matter, they must start w/ "NoAd": F

(setq sy-I '(sy-I (x)
(Ypc R (pci) Ypcn)
(Ypcn S mux Ybc0 Ybt0 Ypcp1)
  (Ybt0 R 0 Ybt1)
  (Ybt1 R 0 Ybt2)
  (Ybt2 R 0 Ybt3)
  (Ybt3 R 0 Ybt4)
  (Ybc0 R F Ybc1k)
  (Ybc1k S k Ybc0 Ybc1)
  (Ybc1 R F Ybc2k)
  (Ybc2k S k Ybc0 Ybc2)
  (Ybc2 R F Ybc3k)
  (Ybc3k S k Ybc0 Ybc3)
  (Ybc3 R F Ybc4k)
  (Ybc4k S k Ybc0 Ybc4)
(Ypcp1 S inc Ypc)
(Ybc4 S eql0 Ywd4)

(Ypr R 'pro Ypr)
(Ybt4 S Umb Ypc Ypr)
(Ywa4 S Umw Ypc Ypr)
(Yra S Umr Ypc Ypr)
(Yf S Umf Ypc Ypr)

(Ywd4 S Ualu Yf Yrd3)
  (Yrd3 S mux Yrb3 Ywd3 Yrd2)
  (Yrd2 S mux Yrb2 Ywd2 Yrd1)
  (Yrd1 S mux Yrb1 Ywd1 Yrd)
  (Yrb3 S equal Yra Ywa3)
  (Yrb2 S equal Yra Ywa2)
  (Yrb1 S equal Yra Ywa1)
  (Ywa3 R F Ywa4k)
  (Ywa2 R F Ywa3k)
  (Ywa1 R F Ywa2k)
  (Ywa4k S k Ybc0 Ywa4)
  (Ywa3k S k Ybc0 Ywa3)
  (Ywa2k S k Ybc0 Ywa2)
  (Ywa1k S k Ybc0 Ywa1)
(Yrd S Ulk Yra Yrf)
(Yrf R 'rfi Yrfn)
(Yrfn S Upd Ywa1k Ywd1 Yrf)
  (Ywd1 R 0 Ywd2)
  (Ywd2 R 0 Ywd3)
  (Ywd3 R 0 Ywd4)

))

(setq srccpu '( |#
; Constants are hand-declared and axiomatized:

(dcl pci ())
(add-axiom pci-numberp (rewrite) (numberp (pci)))

; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_mux.bm: Mux combinational element, i.e. "if".
; U7-DONE

(defn mux (u1 u2 u3) (if u1 u2 u3))

; everything below generated by: (bmcomb 'mux '() '(x1 x2 x3))
; with the EXCEPTIONS/HAND-MODIFICATIONS given below.

(DEFN S-MUX (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-MUX (P X1) (P X2) (P X3)) (MUX (L X1) (L X2) (L X3)))))

; SMUX-is-SIF can make things much simpler on occasions:

(prove-lemma smux-is-sif (rewrite) 
    (equal (s-mux x1 x2 x3) (s-if x1 x2 x3)))

(disable smux-is-sif)

; We take advantage of SMUX-is-SIF for all inductive proofs. To do so we
; HAND-MODIFY the code generated by Sugar to replace all the hints by
;   - A2-EMPTY, A2-PC replace hint with: ((enable smux-is-sif)) 
;   - A2-LP, A2-IC, A2-HC, A2-BC: ((enable smux-is-sif) (disable len))
;   - A2-BNC: ((enable smux-is-sif) (disable bn len))

;; A2-Begin-S-MUX

(PROVE-LEMMA A2-EMPTY-S-MUX (REWRITE)
    (EQUAL (EMPTY (S-MUX X1 X2 X3)) (EMPTY X1)) ((enable smux-is-sif)))

(PROVE-LEMMA A2-E-S-MUX (REWRITE)
    (EQUAL (EQUAL (S-MUX X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-MUX A2-EMPTY-S-MUX) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-MUX))))

(PROVE-LEMMA A2-LP-S-MUX (REWRITE)
    (EQUAL (LEN (S-MUX X1 X2 X3)) (LEN X1))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LPE-S-MUX (REWRITE) (EQLEN (S-MUX X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-MUX)))

(PROVE-LEMMA A2-IC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-MUX (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (MUX C_X1 C_X2 C_X3) (S-MUX X1 X2 X3))))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LC-S-MUX (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-MUX X1 X2 X3)) (MUX (L X1) (L X2) (L X3))))
    ((DISABLE MUX) (EXPAND (S-MUX X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-MUX (REWRITE)
    (EQUAL (P (S-MUX X1 X2 X3)) (S-MUX (P X1) (P X2) (P X3)))
    ((enable smux-is-sif)))

(PROVE-LEMMA A2-HC-S-MUX (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-MUX X1 X2 X3)) (MUX (H X1) (H X2) (H X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX S-MUX) (ENABLE H LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-MUX X1 X2 X3)) (S-MUX (B X1) (B X2) (B X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX) (ENABLE B LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BNC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-MUX X1 X2 X3))
                    (S-MUX (BN N X1) (BN N X2) (BN N X3))))
    ((enable smux-is-sif) (disable bn len)))

;old: ((DISABLE MUX S-MUX))

;; A2-End-S-MUX

; eof:comb_mux.bm

; comb_inc.bm: INCrement combinational element
; U7-DONE

(defn Inc (u) (add1 u))

; Everything below generated by: (bmcomb 'inc '() '(x))

(DEFN S-INC (X) (IF (EMPTY X) (E) (A (S-INC (P X)) (INC (L X)))))

;; A2-Begin-S-INC

(PROVE-LEMMA A2-EMPTY-S-INC (REWRITE)
    (EQUAL (EMPTY (S-INC X)) (EMPTY X)) ((DISABLE INC)))

(PROVE-LEMMA A2-E-S-INC (REWRITE)
    (EQUAL (EQUAL (S-INC X) (E)) (EMPTY X))
    ((DISABLE S-INC A2-EMPTY-S-INC) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-INC))))

(PROVE-LEMMA A2-LP-S-INC (REWRITE) (EQUAL (LEN (S-INC X)) (LEN X))
    ((DISABLE INC) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-INC (REWRITE) (EQLEN (S-INC X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-INC)))

(PROVE-LEMMA A2-IC-S-INC (REWRITE)
    (EQUAL (S-INC (I C_X X)) (I (INC C_X) (S-INC X)))
    ((ENABLE I) (DISABLE STR-A-I INC)))

(PROVE-LEMMA A2-LC-S-INC (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-INC X)) (INC (L X))))
    ((DISABLE INC) (EXPAND (S-INC X))))

(PROVE-LEMMA A2-PC-S-INC (REWRITE) (EQUAL (P (S-INC X)) (S-INC (P X)))
    ((DISABLE INC)))

(PROVE-LEMMA A2-HC-S-INC (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-INC X)) (INC (H X))))
    ((DISABLE INC S-INC) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-INC (REWRITE) (EQUAL (B (S-INC X)) (S-INC (B X)))
    ((DISABLE INC) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-INC (REWRITE)
    (EQUAL (BN N (S-INC X)) (S-INC (BN N X))) ((DISABLE INC S-INC)))

;; A2-End-S-INC

; eof:comb_inc.bm

; Comb_eql0.bm: equal to 0 test, without zerop (in contrast to eq0).
; U7-DONE

(defn Eql0 (u) (equal u 0))

; Everything below generated by: (bmcomb 'eql0 '() '(x))

(DEFN S-EQL0 (X) (IF (EMPTY X) (E) (A (S-EQL0 (P X)) (EQL0 (L X)))))

;; A2-Begin-S-EQL0

(PROVE-LEMMA A2-EMPTY-S-EQL0 (REWRITE)
    (EQUAL (EMPTY (S-EQL0 X)) (EMPTY X)) ((DISABLE EQL0)))

(PROVE-LEMMA A2-E-S-EQL0 (REWRITE)
    (EQUAL (EQUAL (S-EQL0 X) (E)) (EMPTY X))
    ((DISABLE S-EQL0 A2-EMPTY-S-EQL0) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-EQL0))))

(PROVE-LEMMA A2-LP-S-EQL0 (REWRITE) (EQUAL (LEN (S-EQL0 X)) (LEN X))
    ((DISABLE EQL0) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-EQL0 (REWRITE) (EQLEN (S-EQL0 X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-EQL0)))

(PROVE-LEMMA A2-IC-S-EQL0 (REWRITE)
    (EQUAL (S-EQL0 (I C_X X)) (I (EQL0 C_X) (S-EQL0 X)))
    ((ENABLE I) (DISABLE STR-A-I EQL0)))

(PROVE-LEMMA A2-LC-S-EQL0 (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-EQL0 X)) (EQL0 (L X))))
    ((DISABLE EQL0) (EXPAND (S-EQL0 X))))

(PROVE-LEMMA A2-PC-S-EQL0 (REWRITE)
    (EQUAL (P (S-EQL0 X)) (S-EQL0 (P X))) ((DISABLE EQL0)))

(PROVE-LEMMA A2-HC-S-EQL0 (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-EQL0 X)) (EQL0 (H X))))
    ((DISABLE EQL0 S-EQL0) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-EQL0 (REWRITE)
    (EQUAL (B (S-EQL0 X)) (S-EQL0 (B X))) ((DISABLE EQL0) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-EQL0 (REWRITE)
    (EQUAL (BN N (S-EQL0 X)) (S-EQL0 (BN N X)))
    ((DISABLE EQL0 S-EQL0)))

;; A2-End-S-EQL0

; eof:comb_eq0.bm

; comb_umb.bm: Umb combinational element (= fun2)
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Umb (u v))

; Everything below generated by: (bmcomb 'Umb '() '(x y))

(DEFN S-UMB (X Y)
      (IF (EMPTY X) (E) (A (S-UMB (P X) (P Y)) (UMB (L X) (L Y)))))

;; A2-Begin-S-UMB

(PROVE-LEMMA A2-EMPTY-S-UMB (REWRITE)
    (EQUAL (EMPTY (S-UMB X Y)) (EMPTY X)) ((DISABLE UMB)))

(PROVE-LEMMA A2-E-S-UMB (REWRITE)
    (EQUAL (EQUAL (S-UMB X Y) (E)) (EMPTY X))
    ((DISABLE S-UMB A2-EMPTY-S-UMB) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UMB))))

(PROVE-LEMMA A2-LP-S-UMB (REWRITE) (EQUAL (LEN (S-UMB X Y)) (LEN X))
    ((DISABLE UMB) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UMB (REWRITE) (EQLEN (S-UMB X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UMB)))

(PROVE-LEMMA A2-IC-S-UMB (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-UMB (I C_X X) (I C_Y Y))
                    (I (UMB C_X C_Y) (S-UMB X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I UMB)))

(PROVE-LEMMA A2-LC-S-UMB (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-UMB X Y)) (UMB (L X) (L Y))))
    ((DISABLE UMB) (EXPAND (S-UMB X Y))))

(PROVE-LEMMA A2-PC-S-UMB (REWRITE)
    (EQUAL (P (S-UMB X Y)) (S-UMB (P X) (P Y))) ((DISABLE UMB)))

(PROVE-LEMMA A2-HC-S-UMB (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-UMB X Y)) (UMB (H X) (H Y))))
    ((DISABLE UMB S-UMB) (ENABLE H LEN) (INDUCT (S-UMB X Y))))

(PROVE-LEMMA A2-BC-S-UMB (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-UMB X Y)) (S-UMB (B X) (B Y))))
    ((DISABLE UMB) (ENABLE B LEN) (INDUCT (S-UMB X Y))))

(PROVE-LEMMA A2-BNC-S-UMB (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-UMB X Y)) (S-UMB (BN N X) (BN N Y))))
    ((DISABLE UMB S-UMB)))

;; A2-End-S-UMB

; eof:comb_umb.bm

; comb_umw.bm: Umw combinational element (= fun2)
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Umw (u v))

; Everything below generated by: (bmcomb 'Umw '() '(x y))

(DEFN S-UMW (X Y)
      (IF (EMPTY X) (E) (A (S-UMW (P X) (P Y)) (UMW (L X) (L Y)))))

;; A2-Begin-S-UMW

(PROVE-LEMMA A2-EMPTY-S-UMW (REWRITE)
    (EQUAL (EMPTY (S-UMW X Y)) (EMPTY X)) ((DISABLE UMW)))

(PROVE-LEMMA A2-E-S-UMW (REWRITE)
    (EQUAL (EQUAL (S-UMW X Y) (E)) (EMPTY X))
    ((DISABLE S-UMW A2-EMPTY-S-UMW) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UMW))))

(PROVE-LEMMA A2-LP-S-UMW (REWRITE) (EQUAL (LEN (S-UMW X Y)) (LEN X))
    ((DISABLE UMW) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UMW (REWRITE) (EQLEN (S-UMW X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UMW)))

(PROVE-LEMMA A2-IC-S-UMW (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-UMW (I C_X X) (I C_Y Y))
                    (I (UMW C_X C_Y) (S-UMW X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I UMW)))

(PROVE-LEMMA A2-LC-S-UMW (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-UMW X Y)) (UMW (L X) (L Y))))
    ((DISABLE UMW) (EXPAND (S-UMW X Y))))

(PROVE-LEMMA A2-PC-S-UMW (REWRITE)
    (EQUAL (P (S-UMW X Y)) (S-UMW (P X) (P Y))) ((DISABLE UMW)))

(PROVE-LEMMA A2-HC-S-UMW (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-UMW X Y)) (UMW (H X) (H Y))))
    ((DISABLE UMW S-UMW) (ENABLE H LEN) (INDUCT (S-UMW X Y))))

(PROVE-LEMMA A2-BC-S-UMW (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-UMW X Y)) (S-UMW (B X) (B Y))))
    ((DISABLE UMW) (ENABLE B LEN) (INDUCT (S-UMW X Y))))

(PROVE-LEMMA A2-BNC-S-UMW (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-UMW X Y)) (S-UMW (BN N X) (BN N Y))))
    ((DISABLE UMW S-UMW)))

;; A2-End-S-UMW

; eof:comb_umw.bm

; comb_umr.bm: Umr combinational element (= fun2)
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Umr (u v))

; Everything below generated by: (bmcomb 'Umr '() '(x y))

(DEFN S-UMR (X Y)
      (IF (EMPTY X) (E) (A (S-UMR (P X) (P Y)) (UMR (L X) (L Y)))))

;; A2-Begin-S-UMR

(PROVE-LEMMA A2-EMPTY-S-UMR (REWRITE)
    (EQUAL (EMPTY (S-UMR X Y)) (EMPTY X)) ((DISABLE UMR)))

(PROVE-LEMMA A2-E-S-UMR (REWRITE)
    (EQUAL (EQUAL (S-UMR X Y) (E)) (EMPTY X))
    ((DISABLE S-UMR A2-EMPTY-S-UMR) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UMR))))

(PROVE-LEMMA A2-LP-S-UMR (REWRITE) (EQUAL (LEN (S-UMR X Y)) (LEN X))
    ((DISABLE UMR) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UMR (REWRITE) (EQLEN (S-UMR X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UMR)))

(PROVE-LEMMA A2-IC-S-UMR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-UMR (I C_X X) (I C_Y Y))
                    (I (UMR C_X C_Y) (S-UMR X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I UMR)))

(PROVE-LEMMA A2-LC-S-UMR (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-UMR X Y)) (UMR (L X) (L Y))))
    ((DISABLE UMR) (EXPAND (S-UMR X Y))))

(PROVE-LEMMA A2-PC-S-UMR (REWRITE)
    (EQUAL (P (S-UMR X Y)) (S-UMR (P X) (P Y))) ((DISABLE UMR)))

(PROVE-LEMMA A2-HC-S-UMR (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-UMR X Y)) (UMR (H X) (H Y))))
    ((DISABLE UMR S-UMR) (ENABLE H LEN) (INDUCT (S-UMR X Y))))

(PROVE-LEMMA A2-BC-S-UMR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-UMR X Y)) (S-UMR (B X) (B Y))))
    ((DISABLE UMR) (ENABLE B LEN) (INDUCT (S-UMR X Y))))

(PROVE-LEMMA A2-BNC-S-UMR (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-UMR X Y)) (S-UMR (BN N X) (BN N Y))))
    ((DISABLE UMR S-UMR)))

;; A2-End-S-UMR

; eof:comb_umr.bm

; comb_umf.bm: Umf combinational element (= fun2)
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Umf (u v))

; Everything below generated by: (bmcomb 'Umf '() '(x y))

(DEFN S-UMF (X Y)
      (IF (EMPTY X) (E) (A (S-UMF (P X) (P Y)) (UMF (L X) (L Y)))))

;; A2-Begin-S-UMF

(PROVE-LEMMA A2-EMPTY-S-UMF (REWRITE)
    (EQUAL (EMPTY (S-UMF X Y)) (EMPTY X)) ((DISABLE UMF)))

(PROVE-LEMMA A2-E-S-UMF (REWRITE)
    (EQUAL (EQUAL (S-UMF X Y) (E)) (EMPTY X))
    ((DISABLE S-UMF A2-EMPTY-S-UMF) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UMF))))

(PROVE-LEMMA A2-LP-S-UMF (REWRITE) (EQUAL (LEN (S-UMF X Y)) (LEN X))
    ((DISABLE UMF) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UMF (REWRITE) (EQLEN (S-UMF X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UMF)))

(PROVE-LEMMA A2-IC-S-UMF (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-UMF (I C_X X) (I C_Y Y))
                    (I (UMF C_X C_Y) (S-UMF X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I UMF)))

(PROVE-LEMMA A2-LC-S-UMF (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-UMF X Y)) (UMF (L X) (L Y))))
    ((DISABLE UMF) (EXPAND (S-UMF X Y))))

(PROVE-LEMMA A2-PC-S-UMF (REWRITE)
    (EQUAL (P (S-UMF X Y)) (S-UMF (P X) (P Y))) ((DISABLE UMF)))

(PROVE-LEMMA A2-HC-S-UMF (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-UMF X Y)) (UMF (H X) (H Y))))
    ((DISABLE UMF S-UMF) (ENABLE H LEN) (INDUCT (S-UMF X Y))))

(PROVE-LEMMA A2-BC-S-UMF (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-UMF X Y)) (S-UMF (B X) (B Y))))
    ((DISABLE UMF) (ENABLE B LEN) (INDUCT (S-UMF X Y))))

(PROVE-LEMMA A2-BNC-S-UMF (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-UMF X Y)) (S-UMF (BN N X) (BN N Y))))
    ((DISABLE UMF S-UMF)))

;; A2-End-S-UMF

; eof:comb_umf.bm

; comb_ualu.bm: Ualu combinational element
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Ualu (u v))

; Everything below generated by: (bmcomb 'Ualu '() '(x y))

(DEFN S-UALU (X Y)
      (IF (EMPTY X) (E) (A (S-UALU (P X) (P Y)) (UALU (L X) (L Y)))))

;; A2-Begin-S-UALU

(PROVE-LEMMA A2-EMPTY-S-UALU (REWRITE)
    (EQUAL (EMPTY (S-UALU X Y)) (EMPTY X)) ((DISABLE UALU)))

(PROVE-LEMMA A2-E-S-UALU (REWRITE)
    (EQUAL (EQUAL (S-UALU X Y) (E)) (EMPTY X))
    ((DISABLE S-UALU A2-EMPTY-S-UALU) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UALU))))

(PROVE-LEMMA A2-LP-S-UALU (REWRITE) (EQUAL (LEN (S-UALU X Y)) (LEN X))
    ((DISABLE UALU) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UALU (REWRITE) (EQLEN (S-UALU X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UALU)))

(PROVE-LEMMA A2-IC-S-UALU (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-UALU (I C_X X) (I C_Y Y))
                    (I (UALU C_X C_Y) (S-UALU X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I UALU)))

(PROVE-LEMMA A2-LC-S-UALU (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-UALU X Y)) (UALU (L X) (L Y))))
    ((DISABLE UALU) (EXPAND (S-UALU X Y))))

(PROVE-LEMMA A2-PC-S-UALU (REWRITE)
    (EQUAL (P (S-UALU X Y)) (S-UALU (P X) (P Y))) ((DISABLE UALU)))

(PROVE-LEMMA A2-HC-S-UALU (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-UALU X Y)) (UALU (H X) (H Y))))
    ((DISABLE UALU S-UALU) (ENABLE H LEN) (INDUCT (S-UALU X Y))))

(PROVE-LEMMA A2-BC-S-UALU (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-UALU X Y)) (S-UALU (B X) (B Y))))
    ((DISABLE UALU) (ENABLE B LEN) (INDUCT (S-UALU X Y))))

(PROVE-LEMMA A2-BNC-S-UALU (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-UALU X Y)) (S-UALU (BN N X) (BN N Y))))
    ((DISABLE UALU S-UALU)))

;; A2-End-S-UALU

; eof:comb_ualu.bm

; comb_ulk.bm: Ulk combinational element
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Ulk (u v))

; Everything below generated by: (bmcomb 'Ulk '() '(x y))

(DEFN S-ULK (X Y)
      (IF (EMPTY X) (E) (A (S-ULK (P X) (P Y)) (ULK (L X) (L Y)))))

;; A2-Begin-S-ULK

(PROVE-LEMMA A2-EMPTY-S-ULK (REWRITE)
    (EQUAL (EMPTY (S-ULK X Y)) (EMPTY X)) ((DISABLE ULK)))

(PROVE-LEMMA A2-E-S-ULK (REWRITE)
    (EQUAL (EQUAL (S-ULK X Y) (E)) (EMPTY X))
    ((DISABLE S-ULK A2-EMPTY-S-ULK) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-ULK))))

(PROVE-LEMMA A2-LP-S-ULK (REWRITE) (EQUAL (LEN (S-ULK X Y)) (LEN X))
    ((DISABLE ULK) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-ULK (REWRITE) (EQLEN (S-ULK X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-ULK)))

(PROVE-LEMMA A2-IC-S-ULK (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-ULK (I C_X X) (I C_Y Y))
                    (I (ULK C_X C_Y) (S-ULK X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I ULK)))

(PROVE-LEMMA A2-LC-S-ULK (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-ULK X Y)) (ULK (L X) (L Y))))
    ((DISABLE ULK) (EXPAND (S-ULK X Y))))

(PROVE-LEMMA A2-PC-S-ULK (REWRITE)
    (EQUAL (P (S-ULK X Y)) (S-ULK (P X) (P Y))) ((DISABLE ULK)))

(PROVE-LEMMA A2-HC-S-ULK (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-ULK X Y)) (ULK (H X) (H Y))))
    ((DISABLE ULK S-ULK) (ENABLE H LEN) (INDUCT (S-ULK X Y))))

(PROVE-LEMMA A2-BC-S-ULK (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-ULK X Y)) (S-ULK (B X) (B Y))))
    ((DISABLE ULK) (ENABLE B LEN) (INDUCT (S-ULK X Y))))

(PROVE-LEMMA A2-BNC-S-ULK (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-ULK X Y)) (S-ULK (BN N X) (BN N Y))))
    ((DISABLE ULK S-ULK)))

;; A2-End-S-ULK

; eof:comb_ulk.bm

; comb_upd.bm: Upd combinational element
; U7-DONE

; arbitrary Char-Fun of arity 3:
(dcl Upd (u1 u2 u3))

; AXIOM characterising Upd:  (or at least some): see _s .

; Everything below generated by: (bmcomb 'Upd '() '(x1 x2 x3))

(DEFN S-UPD (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-UPD (P X1) (P X2) (P X3)) (UPD (L X1) (L X2) (L X3)))))

;; A2-Begin-S-UPD

(PROVE-LEMMA A2-EMPTY-S-UPD (REWRITE)
    (EQUAL (EMPTY (S-UPD X1 X2 X3)) (EMPTY X1)) ((DISABLE UPD)))

(PROVE-LEMMA A2-E-S-UPD (REWRITE)
    (EQUAL (EQUAL (S-UPD X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-UPD A2-EMPTY-S-UPD) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-UPD))))

(PROVE-LEMMA A2-LP-S-UPD (REWRITE)
    (EQUAL (LEN (S-UPD X1 X2 X3)) (LEN X1))
    ((DISABLE UPD) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-UPD (REWRITE) (EQLEN (S-UPD X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-UPD)))

(PROVE-LEMMA A2-IC-S-UPD (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-UPD (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (UPD C_X1 C_X2 C_X3) (S-UPD X1 X2 X3))))
    ((ENABLE I LEN) (DISABLE STR-A-I UPD) (INDUCT (S-UPD X1 X2 X3))))

(PROVE-LEMMA A2-LC-S-UPD (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-UPD X1 X2 X3)) (UPD (L X1) (L X2) (L X3))))
    ((DISABLE UPD) (EXPAND (S-UPD X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-UPD (REWRITE)
    (EQUAL (P (S-UPD X1 X2 X3)) (S-UPD (P X1) (P X2) (P X3)))
    ((DISABLE UPD)))

(PROVE-LEMMA A2-HC-S-UPD (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-UPD X1 X2 X3)) (UPD (H X1) (H X2) (H X3))))
    ((DISABLE UPD S-UPD) (ENABLE H LEN) (INDUCT (S-UPD X1 X2 X3))))

(PROVE-LEMMA A2-BC-S-UPD (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-UPD X1 X2 X3)) (S-UPD (B X1) (B X2) (B X3))))
    ((DISABLE UPD) (ENABLE B LEN) (INDUCT (S-UPD X1 X2 X3))))

(PROVE-LEMMA A2-BNC-S-UPD (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-UPD X1 X2 X3))
                    (S-UPD (BN N X1) (BN N X2) (BN N X3))))
    ((DISABLE UPD S-UPD)))

;; A2-End-S-UPD

; eof:comb_upd.bm


(DEFN TOPOR-SY-S (LN) 
(IF (EQUAL LN 'YPC) 0 
(IF (EQUAL LN 'YPCN) 5 
(IF (EQUAL LN 'YPCP1) 1 
(IF (EQUAL LN 'YBC) 4 
(IF (EQUAL LN 'YPR) 0 
(IF (EQUAL LN 'YBT) 1 
(IF (EQUAL LN 'YWA) 1 
(IF (EQUAL LN 'YRA) 1 
(IF (EQUAL LN 'YF) 1 
(IF (EQUAL LN 'YWD) 3 
(IF (EQUAL LN 'YRD) 2 
(IF (EQUAL LN 'YRF) 0 
(IF (EQUAL LN 'YRFN) 4 
0))))))))))))))

(DEFN SY-S (LN X) 
(IF (EQUAL LN 'YPC) (IF (EMPTY X) (E) (I (PCI) (SY-S 'YPCN (P X)))) 
(IF (EQUAL LN 'YPCN) (S-MUX (SY-S 'YBC X) (SY-S 'YBT X)
                            (SY-S 'YPCP1 X)) 
(IF (EQUAL LN 'YPCP1) (S-INC (SY-S 'YPC X)) 
(IF (EQUAL LN 'YBC) (S-EQL0 (SY-S 'YWD X)) 
(IF (EQUAL LN 'YPR) (IF (EMPTY X) (E) (I 'PRO (SY-S 'YPR (P X)))) 
(IF (EQUAL LN 'YBT) (S-UMB (SY-S 'YPC X) (SY-S 'YPR X)) 
(IF (EQUAL LN 'YWA) (S-UMW (SY-S 'YPC X) (SY-S 'YPR X)) 
(IF (EQUAL LN 'YRA) (S-UMR (SY-S 'YPC X) (SY-S 'YPR X)) 
(IF (EQUAL LN 'YF) (S-UMF (SY-S 'YPC X) (SY-S 'YPR X)) 
(IF (EQUAL LN 'YWD) (S-UALU (SY-S 'YF X) (SY-S 'YRD X)) 
(IF (EQUAL LN 'YRD) (S-ULK (SY-S 'YRA X) (SY-S 'YRF X)) 
(IF (EQUAL LN 'YRF) (IF (EMPTY X) (E) (I 'RFI (SY-S 'YRFN (P X)))) 
(IF (EQUAL LN 'YRFN) (S-UPD (SY-S 'YWA X) (SY-S 'YWD X) (SY-S 'YRF X)) 
(SFIX X))))))))))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-S LN)))) )

;; A2-Begin-SY-S

(PROVE-LEMMA A2-EMPTY-SY-S (REWRITE)
    (EQUAL (EMPTY (SY-S LN X)) (EMPTY X))
    ((DISABLE S-MUX S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU S-ULK
              S-UPD)))

(PROVE-LEMMA A2-E-SY-S (REWRITE)
    (EQUAL (EQUAL (SY-S LN X) (E)) (EMPTY X))
    ((DISABLE SY-S A2-EMPTY-SY-S) (ENABLE EMPTY) (USE (A2-EMPTY-SY-S))))

(PROVE-LEMMA A2-LP-SY-S (REWRITE) (EQUAL (LEN (SY-S LN X)) (LEN X))
    ((DISABLE LEN S-MUX S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU
              S-ULK S-UPD)
     (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-S (REWRITE) (EQLEN (SY-S LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-S)))

(PROVE-LEMMA A2-PC-SY-S (REWRITE)
    (EQUAL (P (SY-S LN X)) (SY-S LN (P X)))
    ((DISABLE S-MUX S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU S-ULK
              S-UPD A2-IC-S-MUX A2-IC-S-INC A2-IC-S-EQL0 A2-IC-S-UMB
              A2-IC-S-UMW A2-IC-S-UMR A2-IC-S-UMF A2-IC-S-UALU
              A2-IC-S-ULK A2-IC-S-UPD)))

;; A2-End-SY-S
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_k.bm: K combinational element. Semantics by Saxe in rn395 Notes 3.
; Our "k" is his "k" (i.e. little k).
; U7-DONE

(defn K (u v) (if u F v))

; Everything below generated by: (bmcomb 'K '() '(x y))

(DEFN S-K (X Y)
      (IF (EMPTY X) (E) (A (S-K (P X) (P Y)) (K (L X) (L Y)))))

;; A2-Begin-S-K

(PROVE-LEMMA A2-EMPTY-S-K (REWRITE) (EQUAL (EMPTY (S-K X Y)) (EMPTY X))
    ((DISABLE K)))

(PROVE-LEMMA A2-E-S-K (REWRITE) (EQUAL (EQUAL (S-K X Y) (E)) (EMPTY X))
    ((DISABLE S-K A2-EMPTY-S-K) (ENABLE EMPTY) (USE (A2-EMPTY-S-K))))

(PROVE-LEMMA A2-LP-S-K (REWRITE) (EQUAL (LEN (S-K X Y)) (LEN X))
    ((DISABLE K) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-K (REWRITE) (EQLEN (S-K X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-K)))

(PROVE-LEMMA A2-IC-S-K (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-K (I C_X X) (I C_Y Y))
                    (I (K C_X C_Y) (S-K X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I K)))

(PROVE-LEMMA A2-LC-S-K (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-K X Y)) (K (L X) (L Y))))
    ((DISABLE K) (EXPAND (S-K X Y))))

(PROVE-LEMMA A2-PC-S-K (REWRITE)
    (EQUAL (P (S-K X Y)) (S-K (P X) (P Y))) ((DISABLE K)))

(PROVE-LEMMA A2-HC-S-K (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-K X Y)) (K (H X) (H Y))))
    ((DISABLE K S-K) (ENABLE H LEN) (INDUCT (S-K X Y))))

(PROVE-LEMMA A2-BC-S-K (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-K X Y)) (S-K (B X) (B Y))))
    ((DISABLE K) (ENABLE B LEN) (INDUCT (S-K X Y))))

(PROVE-LEMMA A2-BNC-S-K (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-K X Y)) (S-K (BN N X) (BN N Y))))
    ((DISABLE K S-K)))

;; A2-End-S-K

; eof:comb_k.bm


(DEFN TOPOR-SY-I (LN) 
(IF (EQUAL LN 'YPC) 0 
(IF (EQUAL LN 'YPCN) 2 
(IF (EQUAL LN 'YBT0) 0 
(IF (EQUAL LN 'YBT1) 0 
(IF (EQUAL LN 'YBT2) 0 
(IF (EQUAL LN 'YBT3) 0 
(IF (EQUAL LN 'YBC0) 0 
(IF (EQUAL LN 'YBC1K) 1 
(IF (EQUAL LN 'YBC1) 0 
(IF (EQUAL LN 'YBC2K) 1 
(IF (EQUAL LN 'YBC2) 0 
(IF (EQUAL LN 'YBC3K) 1 
(IF (EQUAL LN 'YBC3) 0 
(IF (EQUAL LN 'YBC4K) 8 
(IF (EQUAL LN 'YPCP1) 1 
(IF (EQUAL LN 'YBC4) 7 
(IF (EQUAL LN 'YPR) 0 
(IF (EQUAL LN 'YBT4) 1 
(IF (EQUAL LN 'YWA4) 1 
(IF (EQUAL LN 'YRA) 1 
(IF (EQUAL LN 'YF) 1 
(IF (EQUAL LN 'YWD4) 6 
(IF (EQUAL LN 'YRD3) 5 
(IF (EQUAL LN 'YRD2) 4 
(IF (EQUAL LN 'YRD1) 3 
(IF (EQUAL LN 'YRB3) 2 
(IF (EQUAL LN 'YRB2) 2 
(IF (EQUAL LN 'YRB1) 2 
(IF (EQUAL LN 'YWA3) 0 
(IF (EQUAL LN 'YWA2) 0 
(IF (EQUAL LN 'YWA1) 0 
(IF (EQUAL LN 'YWA4K) 2 
(IF (EQUAL LN 'YWA3K) 1 
(IF (EQUAL LN 'YWA2K) 1 
(IF (EQUAL LN 'YWA1K) 1 
(IF (EQUAL LN 'YRD) 2 
(IF (EQUAL LN 'YRF) 0 
(IF (EQUAL LN 'YRFN) 2 
(IF (EQUAL LN 'YWD1) 0 
(IF (EQUAL LN 'YWD2) 0 
(IF (EQUAL LN 'YWD3) 0 
0))))))))))))))))))))))))))))))))))))))))))

(DEFN SY-I (LN X) 
(IF (EQUAL LN 'YPC) (IF (EMPTY X) (E) (I (PCI) (SY-I 'YPCN (P X)))) 
(IF (EQUAL LN 'YPCN) (S-MUX (SY-I 'YBC0 X) (SY-I 'YBT0 X)
                            (SY-I 'YPCP1 X)) 
(IF (EQUAL LN 'YBT0) (IF (EMPTY X) (E) (I 0 (SY-I 'YBT1 (P X)))) 
(IF (EQUAL LN 'YBT1) (IF (EMPTY X) (E) (I 0 (SY-I 'YBT2 (P X)))) 
(IF (EQUAL LN 'YBT2) (IF (EMPTY X) (E) (I 0 (SY-I 'YBT3 (P X)))) 
(IF (EQUAL LN 'YBT3) (IF (EMPTY X) (E) (I 0 (SY-I 'YBT4 (P X)))) 
(IF (EQUAL LN 'YBC0) (IF (EMPTY X) (E) (I F (SY-I 'YBC1K (P X)))) 
(IF (EQUAL LN 'YBC1K) (S-K (SY-I 'YBC0 X) (SY-I 'YBC1 X)) 
(IF (EQUAL LN 'YBC1) (IF (EMPTY X) (E) (I F (SY-I 'YBC2K (P X)))) 
(IF (EQUAL LN 'YBC2K) (S-K (SY-I 'YBC0 X) (SY-I 'YBC2 X)) 
(IF (EQUAL LN 'YBC2) (IF (EMPTY X) (E) (I F (SY-I 'YBC3K (P X)))) 
(IF (EQUAL LN 'YBC3K) (S-K (SY-I 'YBC0 X) (SY-I 'YBC3 X)) 
(IF (EQUAL LN 'YBC3) (IF (EMPTY X) (E) (I F (SY-I 'YBC4K (P X)))) 
(IF (EQUAL LN 'YBC4K) (S-K (SY-I 'YBC0 X) (SY-I 'YBC4 X)) 
(IF (EQUAL LN 'YPCP1) (S-INC (SY-I 'YPC X)) 
(IF (EQUAL LN 'YBC4) (S-EQL0 (SY-I 'YWD4 X)) 
(IF (EQUAL LN 'YPR) (IF (EMPTY X) (E) (I 'PRO (SY-I 'YPR (P X)))) 
(IF (EQUAL LN 'YBT4) (S-UMB (SY-I 'YPC X) (SY-I 'YPR X)) 
(IF (EQUAL LN 'YWA4) (S-UMW (SY-I 'YPC X) (SY-I 'YPR X)) 
(IF (EQUAL LN 'YRA) (S-UMR (SY-I 'YPC X) (SY-I 'YPR X)) 
(IF (EQUAL LN 'YF) (S-UMF (SY-I 'YPC X) (SY-I 'YPR X)) 
(IF (EQUAL LN 'YWD4) (S-UALU (SY-I 'YF X) (SY-I 'YRD3 X)) 
(IF (EQUAL LN 'YRD3) (S-MUX (SY-I 'YRB3 X) (SY-I 'YWD3 X)
                            (SY-I 'YRD2 X)) 
(IF (EQUAL LN 'YRD2) (S-MUX (SY-I 'YRB2 X) (SY-I 'YWD2 X)
                            (SY-I 'YRD1 X)) 
(IF (EQUAL LN 'YRD1) (S-MUX (SY-I 'YRB1 X) (SY-I 'YWD1 X)
                            (SY-I 'YRD X)) 
(IF (EQUAL LN 'YRB3) (S-EQUAL (SY-I 'YRA X) (SY-I 'YWA3 X)) 
(IF (EQUAL LN 'YRB2) (S-EQUAL (SY-I 'YRA X) (SY-I 'YWA2 X)) 
(IF (EQUAL LN 'YRB1) (S-EQUAL (SY-I 'YRA X) (SY-I 'YWA1 X)) 
(IF (EQUAL LN 'YWA3) (IF (EMPTY X) (E) (I F (SY-I 'YWA4K (P X)))) 
(IF (EQUAL LN 'YWA2) (IF (EMPTY X) (E) (I F (SY-I 'YWA3K (P X)))) 
(IF (EQUAL LN 'YWA1) (IF (EMPTY X) (E) (I F (SY-I 'YWA2K (P X)))) 
(IF (EQUAL LN 'YWA4K) (S-K (SY-I 'YBC0 X) (SY-I 'YWA4 X)) 
(IF (EQUAL LN 'YWA3K) (S-K (SY-I 'YBC0 X) (SY-I 'YWA3 X)) 
(IF (EQUAL LN 'YWA2K) (S-K (SY-I 'YBC0 X) (SY-I 'YWA2 X)) 
(IF (EQUAL LN 'YWA1K) (S-K (SY-I 'YBC0 X) (SY-I 'YWA1 X)) 
(IF (EQUAL LN 'YRD) (S-ULK (SY-I 'YRA X) (SY-I 'YRF X)) 
(IF (EQUAL LN 'YRF) (IF (EMPTY X) (E) (I 'RFI (SY-I 'YRFN (P X)))) 
(IF (EQUAL LN 'YRFN) (S-UPD (SY-I 'YWA1K X) (SY-I 'YWD1 X)
                            (SY-I 'YRF X)) 
(IF (EQUAL LN 'YWD1) (IF (EMPTY X) (E) (I 0 (SY-I 'YWD2 (P X)))) 
(IF (EQUAL LN 'YWD2) (IF (EMPTY X) (E) (I 0 (SY-I 'YWD3 (P X)))) 
(IF (EQUAL LN 'YWD3) (IF (EMPTY X) (E) (I 0 (SY-I 'YWD4 (P X)))) 
(SFIX X))))))))))))))))))))))))))))))))))))))))))
((LEX2 (LIST (COUNT X) (TOPOR-SY-I LN)))) )

;; A2-Begin-SY-I

(PROVE-LEMMA A2-EMPTY-SY-I (REWRITE)
    (EQUAL (EMPTY (SY-I LN X)) (EMPTY X))
    ((DISABLE S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU S-MUX S-EQUAL
              S-K S-ULK S-UPD)))

(PROVE-LEMMA A2-E-SY-I (REWRITE)
    (EQUAL (EQUAL (SY-I LN X) (E)) (EMPTY X))
    ((DISABLE SY-I A2-EMPTY-SY-I) (ENABLE EMPTY) (USE (A2-EMPTY-SY-I))))

(PROVE-LEMMA A2-LP-SY-I (REWRITE) (EQUAL (LEN (SY-I LN X)) (LEN X))
    ((DISABLE LEN S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU S-MUX
              S-EQUAL S-K S-ULK S-UPD)
     (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-I (REWRITE) (EQLEN (SY-I LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-I)))

; blows up, as usual.
;(PROVE-LEMMA A2-PC-SY-I (REWRITE)
;    (EQUAL (P (SY-I LN X)) (SY-I LN (P X)))
;    ((DISABLE S-INC S-EQL0 S-UMB S-UMW S-UMR S-UMF S-UALU S-MUX S-EQUAL
;              S-K S-ULK S-UPD A2-IC-S-INC A2-IC-S-EQL0 A2-IC-S-UMB
;              A2-IC-S-UMW A2-IC-S-UMR A2-IC-S-UMF A2-IC-S-UALU
;              A2-IC-S-MUX A2-IC-S-EQUAL A2-IC-S-K A2-IC-S-ULK
;              A2-IC-S-UPD)))

(add-axiom A2-PC-SY-I (REWRITE)
    (EQUAL (P (SY-I LN X)) (SY-I LN (P X)))
)

;; A2-End-SY-I


; CORRECTNESS PROOF:

;;; Get STUTTER theory:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 				TH_STUTTER.BM
;;;
;;; This file contains Stutter theory for BM.  It is supposed to be
;;; loaded directly when needed (i.e. not general enough to be 
;;; stored in Lib/mlp).
;;;

;;; Our current double P-recursive def. of Stutter:
;;; Originally, it came from THETA-PRF-79 (done while babysitting
;;; for Caroline...) followed by MUCH experimentation and fiddling.


(defn Stut-R (x y)
(if (empty y)
    x
    (if (empty (P y))
	(B x)
        (if (L (P y))
	    (Stut-R x (P y))
	    (B (Stut-R x (P y)))))))

(defn Stut (x y)
(if (empty y)
    (e)
    (if (empty (P y))
	(A (e) (H x))
        (if (L (P y))
	    (A (Stut (P x) (P y)) (L (Stut (P x) (P y))))
	    (A (Stut (P x) (P y)) (H (Stut-R x (P y))))))))

; Stut-Induct inducts like stut, but without the case disjunction 
; on LPx which is useless when we stutter on a line rather than an 
; input. The resulting induction is not very different from a 
; straight P induction, but it takes care of the empty Px case 
; separately, and without bringing an elimination.

(defn Stut-Induct (x)
(if (empty x)
    0
    (if (empty (P x))
	1
        (stut-induct (P x))))
)

;; Properties of Stut:

(prove-lemma Stut-Empty (rewrite)
(equal (empty (Stut x y))
       (empty y))
)

(prove-lemma Stut-E (rewrite)
(equal (equal (Stut x y) (e))
       (empty y))
((DISABLE Stut Stut-Empty) (ENABLE EMPTY)
 (USE (Stut-Empty))
 )
)

(prove-lemma Stut-P (rewrite)
(equal (P (Stut x y))
       (Stut (P x) (P y))
       )
)

;; Properties of Stut-R:

; Stut-R-E maybe shouldn't be enabled all the time, but when we're 
; doing P inductions on Stut-R, this gives the base case.  The 
; induction step is given by Stut-R-P.  Note that we don't have a 
; full empty x hyp because Stut-R returns x and not sfix x in case
; y is empty...  Maybe we want to fix that at some point.

(prove-lemma Stut-R-E (rewrite)
(equal (Stut-R (e) y)
       (e))
)

(prove-lemma Stut-R-P (rewrite)
(equal	(P (Stut-R x y))
	(Stut-R (P x) y))
)

(prove-lemma Stut-R-len (rewrite)
(lessp (len x)
       (add1 (plus (len y) (len (Stut-R x y)))))
((enable len))
)

(prove-lemma Stut-R-not-empty (rewrite)
(implies (lessp (len y) (len x))
	 (not (empty (Stut-R x y))))
((use (Stut-R-len))
 (enable len)
 )
)

; Stut-Rem removes the trailing Ts of y, but ignores Ly (like R) 
; and leaves one T: this weird def, so it works like Stut-R needs!

(defn Stut-Rem (y)
(if (empty y)
    (e)
    (if (empty (P y))
	y
        (if (L (P y))
	    (Stut-Rem (P y))
	    y))))

(prove-lemma Stut-Rem-empty (rewrite)
(equal (empty (Stut-Rem x))
       (empty x))
)

(prove-lemma Stut-Rem-len (rewrite)
(lessp (len (Stut-Rem x)) (add1 (len x)))
((enable len))
)

(prove-lemma Stut-Rem-len2 (rewrite)
(implies (and (not (empty (P x)))
	      (L (P x)))
	 (lessp (len (Stut-Rem x)) (len x)))
((enable len))
)


; Stut-Num counts the number of F in y, ignoring Ly, and starts 
; w/ 1, like Stut.
(defn Stut-Num (y)
(if (empty y)
    0
    (if (empty (P y))
	1
        (if (L (P y))
	    (Stut-Num (P y))
	    (add1 (Stut-Num (P y)))))))

(prove-lemma Stut-Num-lessp (rewrite)
(lessp (Stut-Num x) (add1 (len x)))
((enable len))
)

(prove-lemma Stut-Num-eq-0 (rewrite)
(equal (equal (Stut-Num x) 0)
       (empty x))
)


; Requires a small induction.
(prove-lemma Stut-Num-Rem-len (rewrite)
(implies (not (empty x))
	 (lessp (Stut-Num (P (Stut-Rem x)))
		(len x)
		))
((enable len))
)

; From Stut-Num and Bn we get a CLOSED FORM for Stut-R !!!

(prove-lemma Stut-R-closed (rewrite)
(equal (Stut-R x y)
       (Bn (Stut-Num y) x))
)

; Stut-inv is the key invariant property during Stuttering:

(prove-lemma Stut-inv (rewrite)
(implies (and (not (empty y))
	      (not (lessp (len x) (len y))))
	 (equal (L (Stut x y))
		(H (Stut-R x (P (Stut-Rem y))))))
((enable len H)
 (induct (Stut x y))
 (disable STR-L-Bn) ; interferes (slowdown)
 )
)
; but we only want to use it during the non-stuttering induction 
; step, and not in general so:

(prove-lemma Stut-inv0 (rewrite)
(implies (and (not (empty y))
	      (not (lessp (len x) (len y)))
	      (not (L y))
	      )
	 (equal (L (Stut x y))
		(H (Stut-R x (P (Stut-Rem y))))))
((disable Stut-Rem Stut Stut-R Stut-R-closed len))
)

(disable Stut-inv)

; Now we relate Stut-R for Py and P Rem Py, to get the key to the
; induction step on main Stut inductions, in the non-stuttering 
; case.
;
; It's a BAD rewrite (i.e. expanding, potentially self-applicable),
; and so are the preliminary lemmas needed to build to it.  This
; is not just an unfortunate construction.  It's inherent, because
; we're essentially giving an alternate definition via a Stut-Rem
; recursion.  And definitions are expanding, self-applicable, 
; rewrites.  We get around the problem by lucking out: the
; hypotheses are sufficient to prevent successful self-applic.

(prove-lemma Stut-R-indstep-Num (rewrite)
(implies (and (not (empty x))
	      (L x))
	 (equal (Stut-Num x)
		(add1 (Stut-Num (P (Stut-Rem x))))))
((disable stut-num-rem-len))
)
(disable Stut-R-indstep-Num)

; OLD induction step prereq: not needed anymore.
;
;(prove-lemma Stut-R-indstep-Num-Rem (rewrite) 
;(implies (and (not (empty y))
;	      (not (empty (P y)))
;	      (not (L (P y)))
;	      )
;	 (equal (Stut-Num (P (Stut-Rem (P y))))
;		(sub1 (Stut-Num (P (Stut-Rem y))))
;		))
;((enable Stut-R-indstep-Num))
;)
;(disable Stut-R-indstep-Num-Rem)

; OLD induction step: not needed anymore.
;
;(prove-lemma Stut-indstep (rewrite)
;(implies (and (not (empty y))
;	      (not (empty (P y)))
;	      (not (L (P y)))
;	      )
;	 (equal (Stut-R x (P y))
;		(B (Stut-R x (P (Stut-Rem (P y)))))
;		))
;((enable Stut-R-indstep-Num-Rem B-Bn-sub1)
; (disable Bn)
; )
;)
;(disable Stut-indstep) ; potentially self-looping... 
;                       ; so we enable explicitely.


; NEW & GENERALIZED induction step hack , note: needs just ONE
; prereq! We're getting cleaner...

(prove-lemma Stut-R-indstep (rewrite)
(implies (and (not (empty y))
	      (not (L y))
	      )
	 (equal (Stut-R x y)
		(B (Stut-R x (P (Stut-Rem y))))
		))
((enable Stut-R-indstep-Num))
)
(disable Stut-R-indstep)

; all the internal stuff shouldn't be needed outside:

(disable Stut-R)
(disable Stut-Num)
(disable Stut-Rem)

; Note: by leaving Stut, Stut-inv0, Stut-R-closed enabled, we get
;   the effect of an alternate recursive definition of Stut in the
;   most convenient form.  The remaining uncleanliness is that
;   Stut-R-indstep and Stut-R-closed match the same stuff, and need
;   to be used at different places in the main proof.  So far, we
;   survive by extreme cunning: they are in the right order, and
;   the hypothesis on Stut-R-indstep prevents wrong occurences. 
;   This is neither clear nor robust...

;; eof: th_stutter.bm


;;; ALL DOWN TO HERE IN SRCDEF.{LIB,LISP}

;;; The circuit is mostly undefined.  Here are the axioms which 
;;; give it its meaning:

; Umb-numberp: all branch targets are numbers; necessary since we 
; do Add1 and Sub1 on them, and want that to work out.

(add-axiom Umb-numberp (rewrite)  (numberp (Umb x y)))

; NoAd axiomatization:
; Supplying NoAddress (here: F) as the address to Wsel (here: Upd)
; leaves the RFile unchanged.  NoAd is never issued by the memory
; either as a Write or as a Read:

(add-axiom Upd-NoAd (rewrite)  (equal (Upd F x y) y))
(add-axiom Umw-NoAd (rewrite)  (not (equal (Umw x y) F)))
(add-axiom Umr-NoAd (rewrite)  (not (equal (Umr x y) F)))

; axiom to characterize Update and Lookup (with any non-F address 
; valid):
; Note that if we don't use the hypothesis restricting the address,
; we get an inconsistency in the theory!

(add-axiom Ulk-Upd (rewrite)
(implies (not (equal ad1 F))
	 (equal (Ulk ad1 (Upd ad2 dat rf))
		(if (equal ad1 ad2)
		    dat
		    (Ulk ad1 rf))))
)


;;; Miscellaneous facts, simplifications, etc... about the 
;;; circuits:

; Corr-S-PR expresses that the program (Ypr) is constant in S:

(prove-lemma Corr-S-PR (rewrite)
(implies (not (empty x))
	 (equal (L (sy-S 'ypr x))
		'pro))
((induct (induct-P x))
 (enable STR-L-I2)
 )
)

; Corr-I-PR expresses that the program (Ypr) is constant in I:

(prove-lemma Corr-I-PR (rewrite)
(implies (not (empty x))
	 (equal (L (sy-I 'ypr x))
		'pro))
((induct (induct-P x))
 (enable STR-L-I2)
 )
)

;;; Stuttering Correctness:

; StutCorr-rf-T expresses correctness WHEN stuttering, and only 
; Upd-NoAd is needed in order to prove it.

(prove-lemma StutCorr-rf-T (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (not (L (sy-I 'Ywa1k (P x))))
	      )
	 (equal (L (sy-I 'Yrf x))
		(L (sy-I 'Yrf (P x)))))
((expand (sy-I 'Yrf x)
	 (sy-I 'YrfN (P X))
	 )
 )
)
(disable StutCorr-rf-T) ; self-expanding, enable when needed


;; for PC in sy-I though, there is a fundamental difference. It
;; does NOT stutter sy-S PC, instead, there is a "virtual PC" in
;; sy-I which is a true stuttering of sy-S YPC, and which is
;; derivable from sy-I's global view, and with which sy-I RF is
;; in sync:

; comb_sub1.bm: SUB1 combinational element
; U7-DONE

; no charfun def, already defined in BM.

; Everything below generated by: (bmcomb 'sub1 '() '(x))

(DEFN S-SUB1 (X) (IF (EMPTY X) (E) (A (S-SUB1 (P X)) (SUB1 (L X)))))

;; A2-Begin-S-SUB1

(PROVE-LEMMA A2-EMPTY-S-SUB1 (REWRITE)
    (EQUAL (EMPTY (S-SUB1 X)) (EMPTY X)) ((DISABLE SUB1)))

(PROVE-LEMMA A2-E-S-SUB1 (REWRITE)
    (EQUAL (EQUAL (S-SUB1 X) (E)) (EMPTY X))
    ((DISABLE S-SUB1 A2-EMPTY-S-SUB1) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-SUB1))))

(PROVE-LEMMA A2-LP-S-SUB1 (REWRITE) (EQUAL (LEN (S-SUB1 X)) (LEN X))
    ((DISABLE SUB1) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-SUB1 (REWRITE) (EQLEN (S-SUB1 X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-SUB1)))

(PROVE-LEMMA A2-IC-S-SUB1 (REWRITE)
    (EQUAL (S-SUB1 (I C_X X)) (I (SUB1 C_X) (S-SUB1 X)))
    ((ENABLE I) (DISABLE STR-A-I SUB1)))

(PROVE-LEMMA A2-LC-S-SUB1 (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (L (S-SUB1 X)) (SUB1 (L X))))
    ((DISABLE SUB1) (EXPAND (S-SUB1 X))))

(PROVE-LEMMA A2-PC-S-SUB1 (REWRITE)
    (EQUAL (P (S-SUB1 X)) (S-SUB1 (P X))) ((DISABLE SUB1)))

(PROVE-LEMMA A2-HC-S-SUB1 (REWRITE)
    (IMPLIES (NOT (EMPTY X)) (EQUAL (H (S-SUB1 X)) (SUB1 (H X))))
    ((DISABLE SUB1 S-SUB1) (ENABLE H)))

(PROVE-LEMMA A2-BC-S-SUB1 (REWRITE)
    (EQUAL (B (S-SUB1 X)) (S-SUB1 (B X))) ((DISABLE SUB1) (ENABLE B)))

(PROVE-LEMMA A2-BNC-S-SUB1 (REWRITE)
    (EQUAL (BN N (S-SUB1 X)) (S-SUB1 (BN N X)))
    ((DISABLE SUB1 S-SUB1)))

;; A2-End-S-SUB1

; eof:comb_sub1.bm
 ; needed for def of ivPC

(defn ivPC (x)
(S-IF (sy-I 'Ybc0 x)
      (sy-I 'Ybt0 x)
      (S-IF (S-NOT (sy-I 'Ywa3 x))  ; all to right are F also
	    (sy-I 'Ypc x)
	    (S-IF (S-NOT (sy-I 'Ywa2 x))  ; all to right are F also
		  (S-Sub1 (sy-I 'Ypc x))
		  (S-IF (S-NOT (sy-I 'Ywa1 x))  ; that's it
			(S-Sub1 (S-Sub1 (sy-I 'Ypc x)))
			(S-Sub1 (S-Sub1 (S-Sub1 (sy-I 'Ypc x))))))))
)
(disable ivPC) ; we'll enable when needed


; sy-I-PC-numberp is a type lemma about I-PC and the branch targets
; needed for future add1-sub1 manipulation.

(prove-lemma sy-I-PC-numberp (rewrite)
(implies (not (empty x))
	 (and (numberp (L (SY-I 'YPC x)))
	      (numberp (L (SY-I 'Ybt0 x)))
	      (numberp (L (SY-I 'Ybt1 x)))
	      (numberp (L (SY-I 'Ybt2 x)))
	      (numberp (L (SY-I 'Ybt3 x)))
	      (numberp (L (SY-I 'Ybt4 x)))
	      ))
((induct (induct-P x))
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YBT4 X)
	 )
 (enable STR-L-I2)
 )
)

; Useful abbreviations about the semantics of the circuit:

(defn res (pc rf)
(UALU (UMF pc 'PRO)
      (ULK (UMR pc 'PRO)
	   rf))
)
(disable res)

; n-pc is "Next PC"
(defn n-pc (pc rf)
(MUX (EQL0 (res pc rf))
     (UMB pc 'PRO)
     (ADD1 pc))
)
(disable n-pc)

; n-rf is "Next RF"
(defn n-rf (pc rf)
(UPD (UMW pc 'PRO)
     (res pc rf)
     rf)
)
(disable n-rf)

; Now we prove that they are "correct", with respect to our intent. 
; Even though we don't use the next 3 lemmas anywhere else, they
; are a useful check - and during the development, help raise my
; confidence level! Moreover, they would be useful if we ever
; wanted to prove properties of the specification circuit (sy-S). 

(prove-lemma Corr-n-pc (rewrite)
(implies (and (not (empty x)) (not (empty (P x))))
	 (equal (L (sy-S 'Ypc x))
		(n-pc (L (sy-S 'Ypc (P x))) (L (sy-S 'Yrf (P x)))))
	 )
((enable n-pc res)
 (expand (sy-S 'ypc x)
	 (sy-S 'YPCN (P X))
	 (sy-S 'Ybc (P X))
	 (sy-S 'Ybt (P X))
	 (sy-S 'Ywd (P X))
	 (sy-S 'Yra (P X))
	 (sy-S 'Yrd (P X))
	 (sy-S 'Yf (P X))
	 )
 )
)
(disable Corr-n-pc)

(prove-lemma Corr-n-rf (rewrite)
(implies (and (not (empty x)) (not (empty (P x))))
	 (equal (L (sy-S 'Yrf x))
		(n-rf (L (sy-S 'Ypc (P x))) (L (sy-S 'Yrf (P x)))))
	 )
((enable n-rf res)
 (expand (sy-S 'Yrf x)
	 (sy-S 'YrfN (P X))
	 (sy-S 'Ywa (P X))
	 (sy-S 'Ywd (P X))
	 (sy-S 'Yra (P X))
	 (sy-S 'Yrd (P X))
	 (sy-S 'Yf (P X))
	 )
 )
)
(disable Corr-n-rf)

; Corr-S-PR-H and Corr-I-PR-H could be earlier, with the rest of 
; the constant treatment for PR, but here is where they were 
; needed & proved.

(prove-lemma Corr-S-PR-H (rewrite)
(IMPLIES (NOT (EMPTY X))
	 (EQUAL (H (SY-S 'YPR X)) 'PRO))
((expand (SY-S 'YPR X))
 )
)

(prove-lemma Corr-I-PR-H (rewrite)
(IMPLIES (NOT (EMPTY X))
	 (EQUAL (H (SY-I 'YPR X)) 'PRO))
((expand (SY-I 'YPR X))
 )
)


; REVERSAL PROPERTies for sy-S:
;  The SAME EXPAND hint as for Corr-n-pc and Corr-n-rf work.

; sy-S-reversal-pr is FUNDAMENTALLY DIFFERENT because we don't want
; to keep PR as part of the global state, so we deduce an equality
; by induction:

(prove-lemma sy-S-reversal-pr (rewrite)
(implies (not (empty (BN n (sy-S 'Ypr x))))
	 (equal (H (BN n (SY-S 'ypr x)))
		'PRO))
((enable H LEN STR-L-Bn)
 (disable Bn)
 (induct (induct-P x))
 (expand (H (BN N (I 'pro (SY-S 'YPR (P X)))))
	 )
 )
)


; we need a few simple props of ivPC for the main induction, 
; because we have to run with ivPC disabled there:

(prove-lemma ivPC-E (rewrite)
(IMPLIES (EMPTY X)
	 (EQUAL (IVPC X) (e)))
((enable ivPC))
)
(disable ivPC-E) ; enable as needed

(prove-lemma ivPC-1 (rewrite)
(IMPLIES (AND (NOT (EMPTY X)) (EMPTY (P X)))
	 (equal (L (IVPC X)) (pci)))
((enable ivPC))
)
(disable ivPC-1) ; enable as needed


; Junction (hack) lemma between the 2 hyps to get the reversals:

(prove-lemma sy-S-reversal-hyp-hack (rewrite)
(implies (not (empty (BN n (sy-S 'Ypc x))))
	 (not (empty (BN n (sy-S 'Ypr x)))))
((enable LEN))
)

(disable  sy-S-reversal-hyp-hack)

(prove-lemma sy-S-reversal-pc (rewrite)
(implies (and (not (empty (BN n (sy-S 'Ypc (P x)))))
	      (not (empty (BN n (sy-S 'Yrf (P x))))))
	 (equal (H (B (BN n (sy-S 'Ypc x))))
		(n-pc (H (BN n (sy-S 'Ypc (P x))))
		      (H (BN n (sy-S 'Yrf (P x)))))))
((disable Bn STR-Bn-empty MUX EQL0)
 (enable n-pc res sy-S-reversal-hyp-hack)
 (expand (sy-S 'ypc x)
	 (sy-S 'YPCN (P X))
	 (sy-S 'Ybc (P X))
	 (sy-S 'Ybt (P X))
	 (sy-S 'Ywd (P X))
	 (sy-S 'Yra (P X))
	 (sy-S 'Yrd (P X))
	 (sy-S 'Yf (P X))
	 )
 )
)


(prove-lemma sy-S-reversal-rf (rewrite)
(implies (and (not (empty (BN n (sy-S 'Ypc (P x)))))
	      (not (empty (BN n (sy-S 'Yrf (P x))))))
	 (equal (H (B (BN n (sy-S 'Yrf x))))
		(n-rf (H (BN n (sy-S 'Ypc (P x))))
		      (H (BN n (sy-S 'Yrf (P x)))))))
((disable Bn STR-Bn-empty)
 (enable n-rf res  sy-S-reversal-hyp-hack)
 (expand (sy-S 'Yrf x)
	 (sy-S 'YrfN (P X))
	 (sy-S 'Ywa (P X))
	 (sy-S 'Ywd (P X))
	 (sy-S 'Yra (P X))
	 (sy-S 'Yrd (P X))
	 (sy-S 'Yf (P X))
	 )
 )
)


;; Now we develop the FUNDAMENTAL INVARIANT for sy-I :

; Level is the only one which needs RES enabled, and it's also
; a bit different from the others, because it's never "reset".


; sy-I-Yra-noad tells BM Yra is always an OK address, in a usable 
; way.

(prove-lemma sy-I-Yra-noad (rewrite)
(implies (not (empty x))
	 (equal (ULK (L (SY-I 'YRA X)) (UPD ad dat rf))
		(if (equal (L (SY-I 'YRA X)) ad)
		    dat
		    (ULK (L (SY-I 'YRA X)) rf))))
((expand (SY-I 'YRA X)))
)


; We prove the equalities for YRD lines separately, to minimize 
; the mess! 
(prove-lemma sy-I-Yrd1 (rewrite) 
(implies (not (empty x))
	 (equal (L (sy-I 'Yrd1 x)) (ULK (L (sy-I 'Yra x))
					(UPD (L (sy-I 'Ywa1 x))
					     (L (sy-I 'Ywd1 x))
					     (L (sy-I 'Yrf x)))))
	 )
((expand (SY-I 'YRD1 X)
	 )
 )
)

(prove-lemma sy-I-Yrd2 (rewrite) 
(implies (not (empty x))
	 (equal (L (sy-I 'Yrd2 x)) (ULK (L (sy-I 'Yra x))
					(UPD (L (sy-I 'Ywa2 x))
					     (L (sy-I 'Ywd2 x))
					     (UPD (L (sy-I 'Ywa1 x))
						  (L (sy-I 'Ywd1 x))
						  (L (sy-I 'Yrf x))))))
	 )
((expand (SY-I 'YRD2 X)
	 )
 )
)

(prove-lemma sy-I-Yrd3 (rewrite) 
(implies (not (empty x))
	 (equal (L (sy-I 'Yrd3 x)) (ULK (L (sy-I 'Yra x))
					(UPD (L (sy-I 'Ywa3 x))
					     (L (sy-I 'Ywd3 x))
					     (UPD (L (sy-I 'Ywa2 x))
						  (L (sy-I 'Ywd2 x))
						  (UPD (L (sy-I 'Ywa1 x))
						       (L (sy-I 'Ywd1 x))
						       (L (sy-I 'Yrf x)))))))
	 )
((expand (sy-I 'Yrd3 x)
	 )
 )
)

; now we do the invariants, per level:

(prove-lemma sy-I-INV-4 ()
(implies (not (empty x))
(and (equal (L (sy-I 'Ybc4 x)) (EQL0 (L (sy-I 'Ywd4 x))) )
     (equal (L (sy-I 'Ybt4 x)) (UMB (L (sy-I 'Ypc x)) 'pro))
     (equal (L (sy-I 'Ywa4 x)) (UMW (L (sy-I 'Ypc x)) 'pro))
     (equal (L (sy-I 'Ywd4 x)) (res (L (sy-I 'Ypc x))
				    (UPD (L (sy-I 'Ywa3 x))
					 (L (sy-I 'Ywd3 x))
					 (UPD (L (sy-I 'Ywa2 x))
					      (L (sy-I 'Ywd2 x))
					      (UPD (L (sy-I 'Ywa1 x))
						   (L (sy-I 'Ywd1 x))
						   (L (sy-I 'Yrf x)))))))
     (equal (L (sy-I 'Yrd3 x)) (ULK (L (sy-I 'Yra x))
				    (UPD (L (sy-I 'Ywa3 x))
					 (L (sy-I 'Ywd3 x))
					 (UPD (L (sy-I 'Ywa2 x))
					      (L (sy-I 'Ywd2 x))
					      (UPD (L (sy-I 'Ywa1 x))
						   (L (sy-I 'Ywd1 x))
						   (L (sy-I 'Yrf x)))))))
     ))
((enable res)
 (disable EQL0)
 (expand
   (sy-I 'Ybc4 x)
   (sy-I 'Ybt4 x)
   (sy-I 'Ywa4 x)
   (sy-I 'Ywd4 x)
   (sy-I 'Yra x)
   (SY-I 'YF X)
   )
 )
)


(disable  sy-I-Yrd1)
(disable  sy-I-Yrd2)
(disable  sy-I-Yrd3)

; Note that we repeat sy-I-Yrdn for each n, and this may be costly 
; later. On the other hand, it's nice to have one property which 
; expresses the "complete" correctness of a stage.


(prove-lemma sy-I-INV-3 ()
(implies (not (empty x))
(if (not (L (sy-I 'Ywa3 x)))
    (and (not (L (sy-I 'Ybc3 x))) (not (L (sy-I 'Ywa2 x))))
    (and (equal (L (sy-I 'Ybc3 x)) (EQL0 (L (sy-I 'Ywd3 x))) )
	 (equal (L (sy-I 'Ybt3 x)) (UMB (sub1 (L (sy-I 'Ypc x))) 'pro))
	 (equal (L (sy-I 'Ywa3 x)) (UMW (sub1 (L (sy-I 'Ypc x))) 'pro))
	 (equal (L (sy-I 'Ywd3 x)) (res (sub1 (L (sy-I 'Ypc x)))
					(UPD (L (sy-I 'Ywa2 x))
					     (L (sy-I 'Ywd2 x))
					     (UPD (L (sy-I 'Ywa1 x))
						  (L (sy-I 'Ywd1 x))
						  (L (sy-I 'Yrf x))))))
	 (equal (L (sy-I 'Yrd2 x)) (ULK (L (sy-I 'Yra x))
					(UPD (L (sy-I 'Ywa2 x))
					     (L (sy-I 'Ywd2 x))
					     (UPD (L (sy-I 'Ywa1 x))
						  (L (sy-I 'Ywd1 x))
						  (L (sy-I 'Yrf x))))))
	 )))
((enable STR-L-I2 sy-I-Yrd2)
 (disable EQL0 SY-I-YRA-NOAD)
 (use (sy-I-INV-4 (x (P x))))
 (expand
   (sy-I 'Ybc3 x)
   (sy-I 'Ybt3 x)
   (sy-I 'Ywa3 x)
   (sy-I 'Ywd3 x)
   (SY-I 'YPC X)
   (SY-I 'YPCN (P X))
   (SY-I 'YWA1 X)
   (SY-I 'YWA2 X)
   (SY-I 'YWA4K (P X))
   (SY-I 'YWA3K (P X))
   (SY-I 'YWA2K (P X))
   (SY-I 'YRF X)
   (SY-I 'YRFN (P X))
   )
 )
)


(prove-lemma sy-I-INV-2 ()
(implies (not (empty x))
(if (not (L (sy-I 'Ywa2 x)))
    (and (not (L (sy-I 'Ybc2 x))) (not (L (sy-I 'Ywa1 x))))
    (and (equal (L (sy-I 'Ybc2 x)) (EQL0 (L (sy-I 'Ywd2 x))) )
	 (equal (L (sy-I 'Ybt2 x)) (UMB (sub1(sub1 (L (sy-I 'Ypc x)))) 'pro))
	 (equal (L (sy-I 'Ywa2 x)) (UMW (sub1(sub1 (L (sy-I 'Ypc x)))) 'pro))
	 (equal (L (sy-I 'Ywd2 x)) (res (sub1(sub1 (L (sy-I 'Ypc x))))
					(UPD (L (sy-I 'Ywa1 x))
					     (L (sy-I 'Ywd1 x))
					     (L (sy-I 'Yrf x)))))
	 (equal (L (sy-I 'Yrd1 x)) (ULK (L (sy-I 'Yra x))
					(UPD (L (sy-I 'Ywa1 x))
					     (L (sy-I 'Ywd1 x))
					     (L (sy-I 'Yrf x)))))
	 ))
)
((enable STR-L-I2 sy-I-Yrd1)
 (disable EQL0 SY-I-YRA-NOAD)
 (use (sy-I-INV-3 (x (P x))))
 (expand
   (sy-I 'Ybc2 x)
   (sy-I 'Ybt2 x)
   (sy-I 'Ywa2 x)
   (sy-I 'Ywd2 x)
   (SY-I 'YPC X)
   (SY-I 'YPCN (P X))
   (SY-I 'YWA1 X)
   (SY-I 'YWA3K (P X))
   (SY-I 'YWA2K (P X))
   (SY-I 'YRF X)
   (SY-I 'YRFN (P X))
   (SY-I 'YBC3K (P X))
   )
 )
)


(prove-lemma sy-I-INV-1 ()
(implies (not (empty x))
(if (not (L (sy-I 'Ywa1 x)))
    (not (L (sy-I 'Ybc1 x)))
    (and (equal (L (sy-I 'Ybc1 x)) (EQL0 (L (sy-I 'Ywd1 x))) )
	 (equal (L (sy-I 'Ybt1 x)) (UMB (sub1(sub1(sub1 (L (sy-I 'Ypc x))))) 'pro))
	 (equal (L (sy-I 'Ywa1 x)) (UMW (sub1(sub1(sub1 (L (sy-I 'Ypc x))))) 'pro))
	 (equal (L (sy-I 'Ywd1 x)) (res (sub1(sub1(sub1 (L (sy-I 'Ypc x))))) (L (sy-I 'Yrf x))))
	 (equal (L (sy-I 'Yrd x)) (ULK (L (sy-I 'Yra x)) (L (sy-I 'Yrf x))))
	      ))
)
((enable STR-L-I2)
 (disable EQL0  SY-I-YRA-NOAD)
 (use (sy-I-INV-2 (x (P x))))
 (expand
;   (sy-I 'Yrd x)  ; note that expanding it blows the stack
   (sy-I 'Ybc1 x)
   (sy-I 'Ybt1 x)
   (sy-I 'Ywa1 x)
   (sy-I 'Ywd1 x)
   (SY-I 'YPC X)
   (SY-I 'YPCN (P X))
   (SY-I 'YWA2K (P X))
   (SY-I 'YRF X)
   (SY-I 'YRFN (P X))
   (SY-I 'YBC2K (P X))
   )
 )
)

; NOTES:
; .  Having the invariants written as above entail the cost of 
; carrying lots of irrelevant information in each proof, and 
; potentially crushing BM.  So instead we'll phrase each needed
; property later as a good rewrite, and prove it by instantiating
; the right invariant(s).
; .  What we did is a hand-induction on the DEPTH of the pipeline.
; Notice that NO explicit induction was necessary, simply proving
; the thms in the right order (4-3-2-1)..


; StutCorr-pc-T expresses correctness of ivPC WHEN stuttering.

; We rewrite just the portions of the invariants we need for 
; StutCorr-pc-T so that BM will get that proof in finite time...

(prove-lemma SC-pc-T-1 (rewrite)
(implies (NOT (L (SY-I 'YWA1 x)))
	 (not (L (sy-I 'Ybc1 x))))
((use (sy-I-INV-1)))
)
(disable SC-pc-T-1)

(prove-lemma SC-pc-T-2 (rewrite)
(implies (NOT (L (SY-I 'YWA2 x)))
	 (not (L (sy-I 'Ybc2 x))))
((use (sy-I-INV-2)))
)
(disable SC-pc-T-2)

(prove-lemma SC-pc-T-3 (rewrite)
(implies (NOT (L (SY-I 'YWA3 x)))
	 (not (L (sy-I 'Ybc3 x))))
((use (sy-I-INV-3)))
)
(disable SC-pc-T-3)


(prove-lemma StutCorr-pc-T (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (not (L (sy-I 'Ywa1k (P x))))
	      )
	 (equal (L (ivPC x))
		(L (ivPC (P x)))))
((ENABLE IVPC SC-pc-T-1 SC-pc-T-2 SC-pc-T-3)
 (disable S-IF)  ; speeds things up..
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YPCP1 (P X))
	 (SY-I 'YWA1 X)
	 (SY-I 'YWA2 X)
	 (SY-I 'YWA3 X)
	 (SY-I 'YWA4 (P X))
	 (SY-I 'YWA1K (P X))
	 (SY-I 'YWA2K (P X))
	 (SY-I 'YWA3K (P X))
	 (SY-I 'YWA4K (P X))
	 (SY-I 'YBC0 X)
	 (SY-I 'YBC1K (P X))
	 )
 )
)
(disable StutCorr-pc-T) ; self-expanding, enable when needed


; Now we express the "on the right also" invariants in a useful 
; manner...

(prove-lemma SC-pc-F-3 (rewrite)
(implies (not (L (sy-I 'Ywa3 x)))
	 (not (L (sy-I 'Ywa2 x))))
((use (sy-I-INV-3)))
)
(disable SC-pc-F-3)

(prove-lemma SC-pc-F-2 (rewrite)
(implies (not (L (sy-I 'Ywa2 x)))
	 (not (L (sy-I 'Ywa1 x))))
((use (sy-I-INV-2)))
)
(disable SC-pc-F-2)


; In order to get the arithmetic to work out, we have to prove that
; we never subtract from zero...

(prove-lemma SC-PCn0-0 (rewrite)
(IMPLIES (and (NOT (EMPTY X))
	      (NOT (L (SY-I 'YWA2 X)))
	      (L (SY-I 'YWA3 X)))
	 (NOT (EQUAL (L (SY-I 'YPC X)) 0)))
((induct (induct-P x))
 (ENABLE STR-L-I2 SC-pc-T-1 SC-pc-T-2 SC-pc-T-3 SC-pc-F-2  SC-pc-F-3)
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YWA1 X)
	 (SY-I 'YWA2 X)
	 (SY-I 'YWA3 X)
	 (SY-I 'YWA2K (P X))
	 (SY-I 'YWA3K (P X))
	 (SY-I 'YWA4K (P X))
	 )
 )
)

(prove-lemma SC-PCn0-1 (rewrite)
(IMPLIES (and (NOT (EMPTY X))
	      (NOT (L (SY-I 'YWA1 X)))
	      (L (SY-I 'YWA2 X))
	      (L (SY-I 'YWA3 X)))
	 (NOT (EQUAL (SUB1 (L (SY-I 'YPC X))) 0)))
((induct (induct-P x))
 (ENABLE STR-L-I2 SC-pc-T-1 SC-pc-T-2 SC-pc-T-3 SC-pc-F-2  SC-pc-F-3)
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YWA1 X)
	 (SY-I 'YWA2 X)
	 (SY-I 'YWA3 X)
	 (SY-I 'YWA2K (P X))
	 (SY-I 'YWA3K (P X))
	 (SY-I 'YWA4K (P X))
	 )
 )
)

(prove-lemma SC-PCn0-2 (rewrite)
(implies (and (NOT (EMPTY X))
	      (L (SY-I 'YWA1 X))
	      (L (SY-I 'YWA3 X))
	      (L (SY-I 'YWA2 X))
	      )
	 (NOT (EQUAL (SUB1 (SUB1 (L (SY-I 'YPC X))))
		     0)))
((induct (induct-P x))
 (ENABLE STR-L-I2 SC-pc-T-1 SC-pc-T-2 SC-pc-T-3 SC-pc-F-2  SC-pc-F-3)
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YWA1 X)
	 (SY-I 'YWA2 X)
	 (SY-I 'YWA3 X)
	 (SY-I 'YWA2K (P X))
	 (SY-I 'YWA3K (P X))
	 (SY-I 'YWA4K (P X))
	 )
 )
)

; Now it goes through:

(prove-lemma StutCorr-pc-F (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (L (sy-I 'Ywa1k (P x)))
	      )
	 (equal (L (ivPC x))
		(n-pc  (L (ivPC (P x))) (L (sy-I 'Yrf (P x))))))
((ENABLE n-pc ivPC SC-pc-T-1 SC-pc-T-2 SC-pc-T-3 SC-pc-F-2  SC-pc-F-3)
 (disable S-IF)  ; speeds things up..
 (expand (SY-I 'YPC X)
	 (SY-I 'YPCN (P X))
	 (SY-I 'YPCP1 (P X))
	 (SY-I 'YWA1 X)
	 (SY-I 'YWA2 X)
	 (SY-I 'YWA3 X)
	 (SY-I 'YWA4 (P X))
	 (SY-I 'YWA1K (P X))
	 (SY-I 'YWA2K (P X))
	 (SY-I 'YWA3K (P X))
	 (SY-I 'YWA4K (P X))
	 (SY-I 'YBC0 X)
	 (SY-I 'YBC1K (P X))
	 )
 (use (sy-I-INV-1 (x (P x))))
 )
)
(disable StutCorr-pc-F)



(prove-lemma StutCorr-rf-F (rewrite)
(implies (and (not (empty x))
	      (not (empty (P x)))
	      (L (sy-I 'Ywa1k (P x)))
	      )
	 (equal (L (sy-I 'Yrf x))
		(n-rf  (L (ivPC (P x))) (L (sy-I 'Yrf (P x))))))
((ENABLE n-rf ivPC SC-pc-T-1 SC-pc-T-2 SC-pc-T-3 SC-pc-F-2 SC-pc-F-3)
 (disable S-IF)  ; speeds things up..
 (expand (SY-I 'Yrf X)
	 (SY-I 'YrfN (P X))
	 )
 (use (sy-I-INV-1 (x (P x))))
 )
)
(disable StutCorr-rf-F)


; We have to simultaneously prove stuttering of RF and ivPC:

(prove-lemma StutCorr-L (rewrite)
(and
  (equal (L (Stut (sy-S 'Ypc x) (S-NOT (sy-I 'Ywa1k x))))
	 (L (ivPC x)))
  (equal (L (Stut (sy-S 'Yrf x) (S-NOT (sy-I 'Ywa1k x))))
	 (L (sy-I 'Yrf x)))
  )
((enable Stut-R-indstep
	 StutCorr-pc-T
	 StutCorr-rf-T
	 StutCorr-pc-F
	 StutCorr-rf-F
	 ivPC-E ivPC-1
	 )
 (induct (stut-induct x))
 (disable S-NOT)
 (expand  (H (A (E) (PCI)))   ; for some reason it didn't..
	  )
 )
)

; Now standard passage to strings:

(prove-lemma APL-split-Irf () ; USE hints only.
(implies (not (empty x))
	 (equal (sy-I 'Yrf x)
		(A (P (sy-I 'Yrf x))
		   (L (sy-I 'Yrf x)) )))
((disable sy-I a2-pc-sy-I)
 )
)

(prove-lemma APL-split-Stut () ; USE hints only.
(implies (not (empty x))
	 (equal (Stut (sy-S 'Yrf x) (S-NOT (sy-I 'Ywa1k x)))
		(A (P (Stut (sy-S 'Yrf x) (S-NOT (sy-I 'Ywa1k x))))
		   (L (Stut (sy-S 'Yrf x) (S-NOT (sy-I 'Ywa1k x)))) )))
((disable Stut Stut-P Stut-inv0 StutCorr-L S-NOT)
 )
)


; YEEEEAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH!

(prove-lemma SRC-CPU-correct (rewrite)
(equal (Stut (sy-S 'Yrf x) (S-NOT (sy-I 'Ywa1k x)))
       (sy-I 'Yrf x))
((induct (induct-P x))
 (disable Stut Stut-inv0 Stut-R-Closed sy-S A-P-L
	  ) ; hint taken from countstut.bm
 (use (APL-split-Irf)
      (APL-split-Stut)
      )
 )
)

; eof: srccpu.bm
;))
