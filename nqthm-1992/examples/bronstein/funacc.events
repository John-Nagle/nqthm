#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; funacc.bm
;   Circuit is similar to acc, but uses ARBITRARY CHAR-FUN (arity 2) instead of
; addition. It's expressed in CSXA form.  Proving it guarantees (at the BM
; level) that the theorems stated in bm_syds_2ndorder.txt are indeed true
; in general, although of course, BM can not instantiate them.
;

;;; DEFINITION OF CIRCUIT:
#|
(setq sysd '(sy-funacc (x)
(Yfun S Fun2 x Yreg)
(Yreg R 'finit Yfun)
))

(setq funacc '(
|#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_fun2.bm: Fun2 combinational element
; U7-DONE

; arbitrary Char-Fun of arity 2:
(dcl Fun2 (u v))

; Everything below generated by: (bmcomb 'Fun2 '() '(x y))

(DEFN S-FUN2 (X Y)
      (IF (EMPTY X) (E) (A (S-FUN2 (P X) (P Y)) (FUN2 (L X) (L Y)))))

;; A2-Begin-S-FUN2

(PROVE-LEMMA A2-EMPTY-S-FUN2 (REWRITE)
    (EQUAL (EMPTY (S-FUN2 X Y)) (EMPTY X)) ((DISABLE FUN2)))

(PROVE-LEMMA A2-E-S-FUN2 (REWRITE)
    (EQUAL (EQUAL (S-FUN2 X Y) (E)) (EMPTY X))
    ((DISABLE S-FUN2 A2-EMPTY-S-FUN2) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-FUN2))))

(PROVE-LEMMA A2-LP-S-FUN2 (REWRITE) (EQUAL (LEN (S-FUN2 X Y)) (LEN X))
    ((DISABLE FUN2) (ENABLE LEN)))

(PROVE-LEMMA A2-LPE-S-FUN2 (REWRITE) (EQLEN (S-FUN2 X Y) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-FUN2)))

(PROVE-LEMMA A2-IC-S-FUN2 (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (S-FUN2 (I C_X X) (I C_Y Y))
                    (I (FUN2 C_X C_Y) (S-FUN2 X Y))))
    ((ENABLE I LEN) (DISABLE STR-A-I FUN2)))

(PROVE-LEMMA A2-LC-S-FUN2 (REWRITE)
    (IMPLIES (NOT (EMPTY X))
             (EQUAL (L (S-FUN2 X Y)) (FUN2 (L X) (L Y))))
    ((DISABLE FUN2) (EXPAND (S-FUN2 X Y))))

(PROVE-LEMMA A2-PC-S-FUN2 (REWRITE)
    (EQUAL (P (S-FUN2 X Y)) (S-FUN2 (P X) (P Y))) ((DISABLE FUN2)))

(PROVE-LEMMA A2-HC-S-FUN2 (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X)) (EQUAL (LEN X) (LEN Y)))
             (EQUAL (H (S-FUN2 X Y)) (FUN2 (H X) (H Y))))
    ((DISABLE FUN2 S-FUN2) (ENABLE H LEN) (INDUCT (S-FUN2 X Y))))

(PROVE-LEMMA A2-BC-S-FUN2 (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (B (S-FUN2 X Y)) (S-FUN2 (B X) (B Y))))
    ((DISABLE FUN2) (ENABLE B LEN) (INDUCT (S-FUN2 X Y))))

(PROVE-LEMMA A2-BNC-S-FUN2 (REWRITE)
    (IMPLIES (EQUAL (LEN X) (LEN Y))
             (EQUAL (BN N (S-FUN2 X Y)) (S-FUN2 (BN N X) (BN N Y))))
    ((DISABLE FUN2 S-FUN2)))

;; A2-End-S-FUN2

; eof:comb_fun2.bm


(DEFN TOPOR-SY-FUNACC (LN) 
(IF (EQUAL LN 'YFUN) 1 
(IF (EQUAL LN 'YREG) 0 
0)))

(DEFN SY-FUNACC (LN X) 
(IF (EQUAL LN 'YFUN) (S-FUN2 X (SY-FUNACC 'YREG X)) 
(IF (EQUAL LN 'YREG) (IF (EMPTY X) (E)
                         (I 'FINIT (SY-FUNACC 'YFUN (P X)))) 
(SFIX X)))
((LEX2 (LIST (COUNT X) (TOPOR-SY-FUNACC LN)))) )

;; A2-Begin-SY-FUNACC

(PROVE-LEMMA A2-EMPTY-SY-FUNACC (REWRITE)
    (EQUAL (EMPTY (SY-FUNACC LN X)) (EMPTY X)) ((DISABLE S-FUN2)))

(PROVE-LEMMA A2-E-SY-FUNACC (REWRITE)
    (EQUAL (EQUAL (SY-FUNACC LN X) (E)) (EMPTY X))
    ((DISABLE SY-FUNACC A2-EMPTY-SY-FUNACC) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-FUNACC))))

(PROVE-LEMMA A2-LP-SY-FUNACC (REWRITE)
    (EQUAL (LEN (SY-FUNACC LN X)) (LEN X))
    ((DISABLE LEN S-FUN2) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-LPE-SY-FUNACC (REWRITE) (EQLEN (SY-FUNACC LN X) X)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-FUNACC)))

(PROVE-LEMMA A2-PC-SY-FUNACC (REWRITE)
    (EQUAL (P (SY-FUNACC LN X)) (SY-FUNACC LN (P X)))
    ((DISABLE S-FUN2 A2-IC-S-FUN2)))

;; A2-End-SY-FUNACC

;;; SPEC definition:

(defn numer-funacc (x)
  (if (empty x)
      'finit
      (Fun2 (numer-funacc (p x)) (l x))))

; this is the standard extension from last-char-fun to MLP-string-fun.
(defn spec-funacc (x)
  (if (empty x)
      (e)
      (A (spec-funacc (p x))
	   (numer-funacc x))))


;;; Circuit CORRECTNESS:

; We now declare Fun2 to be COMMUTATIVE because the definition of NUMER-FUNACC
; funs the 2 arguments in the opposite order than the sysd, and hence
; commutativity is required.  Alternatively, we could change NUMER-FUNACC's
; definition.  (This has been tested and runs.)
(add-axiom Fun2-comm (rewrite)
(equal (Fun2 u v) (Fun2 v u))
)

; Funacc-correct-ax is a "predicative correctness statement",i.e. what we would
; do if we didn't have functional equality as a specification method, but 
; instead used a purely axiomatic approach.
; NOTE: the simplicity of the proof should imply that disabling the 
; char-function in specific instances of accumulator syds should help...

(prove-lemma funacc-correct-ax (rewrite)
(implies (not (empty x))
	 (equal (l (sy-funacc 'Yfun x))
		(numer-funacc x)))
((expand (sy-funacc 'Yfun x))
 (enable STR-L-I2) ; NECESSARY here because we want to introduce a case
                     ; disjunction BEFORE the equality hypothesis is used..
)
)

; to go to a functional equality once we have the "last" (ax) statement is
; a trivial induction, if we start out with an P-L split which is unnatural
; for BM, so we force it w/ a USE hint of A-p-l-split .  See also THETA.BM .

(prove-lemma A-p-l-split () ; USE hints only.
(implies (not (empty x))
	 (equal (sy-funacc 'Yfun x)
		(A (p (sy-funacc 'Yfun x))
		     (l (sy-funacc 'Yfun x)) )))
((disable funacc-correct-ax a2-pc-sy-funacc)
 )
)

(prove-lemma funacc-correct ()
(equal (sy-funacc 'Yfun x)
       (spec-funacc x))
((induct (induct-P x))
 (use (A-p-l-split))
 (disable A-P-L numer-funacc sy-funacc empty)
 )
)

; eof: funacc.bm
;))
