#|

 Copyright (C) 1994 by Alex Bronstein and Carolyn Talcott.  All Rights
 Reserved.

 You may copy and distribute verbatim copies of this Nqthm-1992 event script as
 you receive it, in any medium, including embedding it verbatim in derivative
 works, provided that you conspicuously and appropriately publish on each copy
 a valid copyright notice "Copyright (C) 1994 by Alex Bronstein and Carolyn
 Talcott.  All Rights Reserved."

 NO WARRANTY

 Alex Bronstein and Carolyn Talcott PROVIDE ABSOLUTELY NO WARRANTY.  THE EVENT
 SCRIPT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 THE QUALITY AND PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT
 PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 CORRECTION.

 IN NO EVENT WILL Alex Bronstein or Carolyn Talcott BE LIABLE TO YOU FOR ANY
 DAMAGES, ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
 OR LOSSES SUSTAINED BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE
 POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.

|#

(note-lib "mlp" t)

; serial.bm: a register, writable in parallel, and readable 
; serially.  This is Paillet example 3
;
; IMPORTANT NOTE: originally, we proved this multi-circuit WITHOUT 
; EQ-LEN hyps, because we got lucky and all the inputs were
; Registered, so it didn't matter.  We now go to the more general
; version for uniformity, even though it will be enormously more
; expensive, and will force EQ-LEN hyps in the correctness thms.  
; It might be worth remembering though that for circuits where all 
; inputs are immmediately Registered, we can do away with the 
; EQ-LEN hyp.
;
; OTHER IMPORTANT NOTE: all the comments below concerning various 
; ways of phrasing the hypotheses were written when EMPTY was still
; ENABLED.

;;; CIRCUIT in SUGARED form:  (after flattening out, yuck...)

#|
(setq sysd '(sy-SERIAL (xC x1 x2 x3)
(YC0 S const 0 xC)
(YM3 S mux xC x3 YC0)
(Y3 R 'a3 YM3)
(YM2 S mux xC x2 Y3)
(Y2 R 'a2 YM2)
(YM1 S mux xC x1 Y2)
(Y1 R 'a1 YM1)
))

(setq serial '( |#
; BM DEFINITIONS and A2 LEMMAS, generated by BMSYSD:
; comb_mux.bm: Mux combinational element, i.e. "if".
; U7-DONE

(defn mux (u1 u2 u3) (if u1 u2 u3))

; everything below generated by: (bmcomb 'mux '() '(x1 x2 x3))
; with the EXCEPTIONS/HAND-MODIFICATIONS given below.

(DEFN S-MUX (X1 X2 X3)
      (IF (EMPTY X1) (E)
          (A (S-MUX (P X1) (P X2) (P X3)) (MUX (L X1) (L X2) (L X3)))))

; SMUX-is-SIF can make things much simpler on occasions:

(prove-lemma smux-is-sif (rewrite) 
    (equal (s-mux x1 x2 x3) (s-if x1 x2 x3)))

(disable smux-is-sif)

; We take advantage of SMUX-is-SIF for all inductive proofs. To do so we
; HAND-MODIFY the code generated by Sugar to replace all the hints by
;   - A2-EMPTY, A2-PC replace hint with: ((enable smux-is-sif)) 
;   - A2-LP, A2-IC, A2-HC, A2-BC: ((enable smux-is-sif) (disable len))
;   - A2-BNC: ((enable smux-is-sif) (disable bn len))

;; A2-Begin-S-MUX

(PROVE-LEMMA A2-EMPTY-S-MUX (REWRITE)
    (EQUAL (EMPTY (S-MUX X1 X2 X3)) (EMPTY X1)) ((enable smux-is-sif)))

(PROVE-LEMMA A2-E-S-MUX (REWRITE)
    (EQUAL (EQUAL (S-MUX X1 X2 X3) (E)) (EMPTY X1))
    ((DISABLE S-MUX A2-EMPTY-S-MUX) (ENABLE EMPTY)
     (USE (A2-EMPTY-S-MUX))))

(PROVE-LEMMA A2-LP-S-MUX (REWRITE)
    (EQUAL (LEN (S-MUX X1 X2 X3)) (LEN X1))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LPE-S-MUX (REWRITE) (EQLEN (S-MUX X1 X2 X3) X1)
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN S-MUX)))

(PROVE-LEMMA A2-IC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (S-MUX (I C_X1 X1) (I C_X2 X2) (I C_X3 X3))
                    (I (MUX C_X1 C_X2 C_X3) (S-MUX X1 X2 X3))))
    ((enable smux-is-sif) (disable len)))

(PROVE-LEMMA A2-LC-S-MUX (REWRITE)
    (IMPLIES (NOT (EMPTY X1))
             (EQUAL (L (S-MUX X1 X2 X3)) (MUX (L X1) (L X2) (L X3))))
    ((DISABLE MUX) (EXPAND (S-MUX X1 X2 X3))))

(PROVE-LEMMA A2-PC-S-MUX (REWRITE)
    (EQUAL (P (S-MUX X1 X2 X3)) (S-MUX (P X1) (P X2) (P X3)))
    ((enable smux-is-sif)))

(PROVE-LEMMA A2-HC-S-MUX (REWRITE)
    (IMPLIES (AND (NOT (EMPTY X1))
                  (AND (EQUAL (LEN X1) (LEN X2))
                       (EQUAL (LEN X2) (LEN X3))))
             (EQUAL (H (S-MUX X1 X2 X3)) (MUX (H X1) (H X2) (H X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX S-MUX) (ENABLE H LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (B (S-MUX X1 X2 X3)) (S-MUX (B X1) (B X2) (B X3))))
    ((enable smux-is-sif) (disable len)))

;old:    ((DISABLE MUX) (ENABLE B LEN) (INDUCT (S-MUX X1 X2 X3)))

(PROVE-LEMMA A2-BNC-S-MUX (REWRITE)
    (IMPLIES (AND (EQUAL (LEN X1) (LEN X2)) (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (BN N (S-MUX X1 X2 X3))
                    (S-MUX (BN N X1) (BN N X2) (BN N X3))))
    ((enable smux-is-sif) (disable bn len)))

;old: ((DISABLE MUX S-MUX))

;; A2-End-S-MUX

; eof:comb_mux.bm


(DEFN TOPOR-SY-SERIAL (LN) 
(IF (EQUAL LN 'YC0) 1 
(IF (EQUAL LN 'YM3) 2 
(IF (EQUAL LN 'Y3) 0 
(IF (EQUAL LN 'YM2) 1 
(IF (EQUAL LN 'Y2) 0 
(IF (EQUAL LN 'YM1) 1 
(IF (EQUAL LN 'Y1) 0 
0))))))))

;Parameter found: 0 in: (YC0 S CONST 0 XC)
(DEFN SY-SERIAL (LN XC X1 X2 X3) 
(IF (EQUAL LN 'YC0) (S-CONST 0 XC) 
(IF (EQUAL LN 'YM3) (S-MUX XC X3 (SY-SERIAL 'YC0 XC X1 X2 X3)) 
(IF (EQUAL LN 'Y3) (IF (EMPTY XC) (E)
                       (I 'A3
                          (SY-SERIAL 'YM3 (P XC) (P X1) (P X2) (P X3)))) 
(IF (EQUAL LN 'YM2) (S-MUX XC X2 (SY-SERIAL 'Y3 XC X1 X2 X3)) 
(IF (EQUAL LN 'Y2) (IF (EMPTY XC) (E)
                       (I 'A2
                          (SY-SERIAL 'YM2 (P XC) (P X1) (P X2) (P X3)))) 
(IF (EQUAL LN 'YM1) (S-MUX XC X1 (SY-SERIAL 'Y2 XC X1 X2 X3)) 
(IF (EQUAL LN 'Y1) (IF (EMPTY XC) (E)
                       (I 'A1
                          (SY-SERIAL 'YM1 (P XC) (P X1) (P X2) (P X3)))) 
(SFIX XC))))))))
((LEX2 (LIST (COUNT XC) (TOPOR-SY-SERIAL LN)))) )

;; A2-Begin-SY-SERIAL

(PROVE-LEMMA A2-EMPTY-SY-SERIAL (REWRITE)
    (IMPLIES (AND (EQUAL (LEN XC) (LEN X1)) (EQUAL (LEN X1) (LEN X2))
                  (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (EMPTY (SY-SERIAL LN XC X1 X2 X3)) (EMPTY XC)))
    ((DISABLE LEN S-CONST S-MUX) (ENABLE STR-ADD1-LEN-P)))

(PROVE-LEMMA A2-E-SY-SERIAL (REWRITE)
    (IMPLIES (AND (EQUAL (LEN XC) (LEN X1)) (EQUAL (LEN X1) (LEN X2))
                  (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (EQUAL (SY-SERIAL LN XC X1 X2 X3) (E)) (EMPTY XC)))
    ((DISABLE LEN SY-SERIAL A2-EMPTY-SY-SERIAL) (ENABLE EMPTY)
     (USE (A2-EMPTY-SY-SERIAL))))

(PROVE-LEMMA A2-LP-SY-SERIAL (REWRITE)
    (IMPLIES (AND (EQUAL (LEN XC) (LEN X1)) (EQUAL (LEN X1) (LEN X2))
                  (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (LEN (SY-SERIAL LN XC X1 X2 X3)) (LEN XC)))
    ((DISABLE LEN S-CONST S-MUX) (ENABLE STR-ADD1-LEN-P STR-LEN-E)))

(PROVE-LEMMA A2-LPE-SY-SERIAL (REWRITE)
    (IMPLIES (AND (EQUAL (LEN XC) (LEN X1)) (EQUAL (LEN X1) (LEN X2))
                  (EQUAL (LEN X2) (LEN X3)))
             (EQLEN (SY-SERIAL LN XC X1 X2 X3) XC))
    ((ENABLE EQLEN-IS-EQUAL-LEN) (DISABLE LEN SY-SERIAL)))

(PROVE-LEMMA A2-PC-SY-SERIAL (REWRITE)
    (IMPLIES (AND (EQUAL (LEN XC) (LEN X1)) (EQUAL (LEN X1) (LEN X2))
                  (EQUAL (LEN X2) (LEN X3)))
             (EQUAL (P (SY-SERIAL LN XC X1 X2 X3))
                    (SY-SERIAL LN (P XC) (P X1) (P X2) (P X3))))
    ((DISABLE LEN S-CONST S-MUX A2-IC-S-CONST A2-IC-S-MUX)
     (ENABLE STR-ADD1-LEN-P)))

;; A2-End-SY-SERIAL

;;; Circuit CORRECTNESS /Paillet:

; SPECIFICATION:

; Here we interpret Paillet as talking about last-chars implicitely

(defn SERIAL-Spec-L (xC x1 x2 x3)
(if (L (P xC))
    (L (P x1))
    (if (L (P (P xC)))
	(L (P (P x2)))
        (if (L (P (P (P xC))))
	    (L (P (P (P x3))))
	    0)))
)


; Here we intepret Paillet as really talking about streams (and 
; correct for the missing initial values):

(defn SERIAL-Spec (xC x1 x2 x3)
(I 'a1 (S-IF (P xC)
	     (P x1)
	     (I 'a2 (S-IF (P (P xC))
			  (P (P x2))
			  (I 'a3 (S-IF (P (P (P xC)))
				       (P (P (P x3)))
				       (S-const 0 (P (P (P xC))))
				       ))))))
)


; CORRECTNESS:

; note: we don't need EQ-LEN hyp here, although it was tried and 
; didn't hurt.

(prove-lemma serial-correct-L (rewrite)
(implies (and (not (empty xC)) (not (empty (p xC))) (not (empty (p (p xC)))) (not (empty (p (p (p xC)))))
	      )
	 (equal (L (sy-serial 'Y1 xC x1 x2 x3))
		(SERIAL-Spec-L xC x1 x2 x3)))
((expand (SY-SERIAL 'Y1 XC X1 X2 X3)
	 (SY-SERIAL 'YM1 (P XC) (P X1) (P X2) (P X3))
	 (SY-SERIAL 'Y2 (P XC) (P X1) (P X2) (P X3))
	 (SY-SERIAL 'YM2 (P (P XC)) (P (P X1)) (P (P X2)) (P (P X3)))
	 (SY-SERIAL 'Y3 (P (P XC)) (P (P X1)) (P (P X2)) (P (P X3)))
	 (SY-SERIAL 'YM3 (P (P (P XC))) (P (P (P X1))) (P (P (P X2))) (P (P (P X3))))
	 )
 (enable SMUX-is-SIF)
 )
)

; Note: we shouldn't need the EQ-LEN hyp here, since it's just an unfolding..

(prove-lemma serial-correct (rewrite)
(implies (not (empty (P (P (P xC)))))
	 (equal (sy-serial 'Y1 xC x1 x2 x3)
		(SERIAL-Spec xC x1 x2 x3)))
((expand (SY-SERIAL 'Y1 XC X1 X2 X3)
	 (SY-SERIAL 'YM1 (P XC) (P X1) (P X2) (P X3))
	 (SY-SERIAL 'Y2 (P XC) (P X1) (P X2) (P X3))
	 (SY-SERIAL 'YM2 (P (P XC)) (P (P X1)) (P (P X2)) (P (P X3)))
	 (SY-SERIAL 'Y3 (P (P XC)) (P (P X1)) (P (P X2)) (P (P X3)))
	 (SY-SERIAL 'YM3 (P (P (P XC))) (P (P (P X1))) (P (P (P X2))) (P (P (P X3))))
	 )
 (enable SMUX-is-SIF)
 )
)

; NOTE that above we have a choice of how we phrase the hypothesis:
;   1: (and (not (empty xC)) (not (empty (p xC))) 
;           (not (empty (p (p xC)))) (not (empty (p (p (p xC))))))
;     is highly redundant but says everything needed and so solves 
;     in 1 step.
;   2: (not (empty (p (p (p xC)))))  concise, -> many cases (but 
;     LESS time!)
;   3: (not (empty (Pn 3 xC))) concise, -> same # cases as 2, but 
;     more time.
; Rewrite lemmas such as:
;(prove-lemma not-empty-Pn (rewrite)
;(equal (not (empty (Pn n x)))
;       (if (zerop n)
;	   (not (empty x))
;	   (and (not (empty x))
;		(not (empty (Pn (sub1 n) (P x)))))))
;)
; although true, have no effect on the hypothesis expansion, 
; unfortunately..


; Another property listed as "correctess" in Paillet is:
; Note that here we have translated P .. into L P .., because
; if we try to understand this last Paillet property as speaking of
; streams, then the Hypothesis: P3 C = 1 and P2 C = P C = 0
; doesn't make any sense!!!
; in fact he acknowledges that "these computations are supposed to 
; be made in a temporal interval corresponding to one cycle, but 
; this interval is not indicated in the calculus to avoid too much
; notation".  Formally of course, we don't have that luxury... 

; Again, we don't need the EQ-LEN hyp, although when we tested it, 
; it threw BM into a loop, until we DISABLED LEN; this trick might
; carry over!!

(prove-lemma serial-correct-specialcase-L ()
(implies (and (equal (L (P xC)) F)
	      (equal (L (P (P xC))) F)
	      (equal (L (P (P (P xC)))) T)
	      (not (empty xC)) (not (empty (p xC))) (not (empty (p (p xC)))) (not (empty (p (p (p xC)))))
	      )
	 (and (equal (L (sy-serial 'Y1 xC x1 x2 x3)) (L (P (P (P x3)))))
	      (equal (L (P (sy-serial 'Y1 xC x1 x2 x3))) (L (P (P (P x2)))))
	      (equal (L (P (P (sy-serial 'Y1 xC x1 x2 x3)))) (L (P (P (P x1)))))
	      ))
)

; Note above that using the (redundant) hypothesis:
; (not (empty xC)) (not (empty (p xC))) (not (empty (p (p xC)))) 
; (not (empty (p (p (p xC)))))
; makes the proof instantaneous, since otherwise BM goes through 
; eliminations to realize the "equal" hyps imply it.

; eof: serial.bm
;))


